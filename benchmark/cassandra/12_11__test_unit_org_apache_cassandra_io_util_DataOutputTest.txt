1:75508ec: /*
1:75508ec:  * Licensed to the Apache Software Foundation (ASF) under one
1:75508ec:  * or more contributor license agreements.  See the NOTICE file
1:75508ec:  * distributed with this work for additional information
1:75508ec:  * regarding copyright ownership.  The ASF licenses this file
1:75508ec:  * to you under the Apache License, Version 2.0 (the
1:75508ec:  * "License"); you may not use this file except in compliance
1:75508ec:  * with the License.  You may obtain a copy of the License at
1:75508ec:  *
1:75508ec:  *     http://www.apache.org/licenses/LICENSE-2.0
1:75508ec:  *
1:75508ec:  * Unless required by applicable law or agreed to in writing, software
1:75508ec:  * distributed under the License is distributed on an "AS IS" BASIS,
1:75508ec:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:75508ec:  * See the License for the specific language governing permissions and
1:75508ec:  * limitations under the License.
1:75508ec:  */
1:75508ec: package org.apache.cassandra.io.util;
3:75508ec: 
1:75508ec: import java.io.ByteArrayInputStream;
1:75508ec: import java.io.ByteArrayOutputStream;
1:75508ec: import java.io.DataInput;
1:75508ec: import java.io.DataInputStream;
1:75508ec: import java.io.DataOutput;
1:75508ec: import java.io.DataOutputStream;
1:75508ec: import java.io.EOFException;
1:75508ec: import java.io.File;
1:75508ec: import java.io.FileInputStream;
1:75508ec: import java.io.FileOutputStream;
1:75508ec: import java.io.IOException;
1:75508ec: import java.io.RandomAccessFile;
1:75508ec: import java.nio.ByteBuffer;
1:75508ec: import java.nio.channels.Channels;
1:f7aaea0: import java.util.ArrayDeque;
1:f7aaea0: import java.util.Deque;
1:75508ec: import java.util.Random;
1:f7aaea0: import java.util.concurrent.Callable;
1:75508ec: import java.util.concurrent.ThreadLocalRandom;
1:75508ec: 
1:75508ec: import org.junit.Assert;
1:9797511: import org.junit.BeforeClass;
1:75508ec: import org.junit.Test;
1:3adfd15: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:75508ec: import org.apache.cassandra.utils.ByteBufferUtil;
1:75508ec: 
1:75508ec: public class DataOutputTest
1:75508ec: {
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:75508ec:     @Test
1:16499ca:     public void testWrappedDataOutputStreamPlus() throws IOException
1:75508ec:     {
1:75508ec:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:16499ca:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(bos);
1:4e29b7a:         DataInput canon = testWrite(write);
1:75508ec:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
2:75508ec:         testRead(test, canon);
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:16499ca:     public void testWrappedDataOutputChannelAndChannel() throws IOException
1:75508ec:     {
1:75508ec:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:16499ca:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(bos);
2:75508ec:         DataInput canon = testWrite(write);
1:75508ec:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:75508ec:         testRead(test, canon);
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:16499ca:     public void testBufferedDataOutputStreamPlusAndChannel() throws IOException
1:16499ca:     {
1:16499ca:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:16499ca:         DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(Channels.newChannel(bos));
1:16499ca:         DataInput canon = testWrite(write);
1:16499ca:         write.close();
1:16499ca:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:16499ca:         testRead(test, canon);
1:16499ca:     }
1:16499ca: 
1:16499ca:     @Test
1:75508ec:     public void testDataOutputBuffer() throws IOException
1:75508ec:     {
1:75508ec:         DataOutputBuffer write = new DataOutputBuffer();
1:75508ec:         DataInput canon = testWrite(write);
1:75508ec:         DataInput test = new DataInputStream(new ByteArrayInputStream(write.toByteArray()));
1:75508ec:         testRead(test, canon);
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:f7aaea0:     public void testDataOutputBufferZeroReallocate() throws IOException
1:f7aaea0:     {
1:f7aaea0:         try (DataOutputBufferSpy write = new DataOutputBufferSpy())
1:f7aaea0:         {
1:f7aaea0:             for (int ii = 0; ii < 1000000; ii++)
1:f7aaea0:             {
1:f7aaea0:                 write.superReallocate(0);
1:f7aaea0:             }
1:f7aaea0:         }
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     @Test
1:75508ec:     public void testDataOutputDirectByteBuffer() throws IOException
1:75508ec:     {
1:75508ec:         ByteBuffer buf = wrap(new byte[345], true);
1:16499ca:         BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus(null, buf.duplicate());
1:75508ec:         DataInput canon = testWrite(write);
1:5baa72f:         DataInput test = new DataInputStream(new ByteArrayInputStream(ByteBufferUtil.getArray(buf)));
1:75508ec:         testRead(test, canon);
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:75508ec:     public void testDataOutputHeapByteBuffer() throws IOException
1:75508ec:     {
1:75508ec:         ByteBuffer buf = wrap(new byte[345], false);
1:16499ca:         BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus(null, buf.duplicate());
1:75508ec:         DataInput canon = testWrite(write);
1:5baa72f:         DataInput test = new DataInputStream(new ByteArrayInputStream(ByteBufferUtil.getArray(buf)));
1:75508ec:         testRead(test, canon);
1:75508ec:     }
1:75508ec: 
1:f7aaea0:     private static class DataOutputBufferSpy extends DataOutputBuffer
1:f7aaea0:     {
1:f7aaea0:         Deque<Long> sizes = new ArrayDeque<>();
1:f7aaea0: 
1:f7aaea0:         DataOutputBufferSpy()
1:f7aaea0:         {
1:f7aaea0:             sizes.offer(128L);
1:f7aaea0:         }
1:f7aaea0: 
1:f7aaea0:         void publicFlush() throws IOException
1:f7aaea0:         {
1:f7aaea0:             //Going to allow it to double instead of specifying a count
1:f7aaea0:             doFlush(1);
1:f7aaea0:         }
1:f7aaea0: 
1:f7aaea0:         void superReallocate(int count) throws IOException
1:f7aaea0:         {
1:f7aaea0:             super.reallocate(count);
1:f7aaea0:         }
1:f7aaea0: 
1:f7aaea0:         @Override
1:f7aaea0:         protected void reallocate(long count)
1:f7aaea0:         {
1:f7aaea0:             if (count <= 0)
1:f7aaea0:                 return;
1:f7aaea0:             Long lastSize = sizes.peekLast();
1:f7aaea0:             long newSize = calculateNewSize(count);
1:f7aaea0:             sizes.offer(newSize);
1:f7aaea0:             if (newSize > DataOutputBuffer.MAX_ARRAY_SIZE)
1:f7aaea0:                 throw new RuntimeException();
1:f7aaea0:             if (newSize < 0)
1:f7aaea0:                 throw new AssertionError();
1:f7aaea0:             if (lastSize != null && newSize <= lastSize)
1:f7aaea0:                 throw new AssertionError();
1:f7aaea0:         }
1:f7aaea0: 
1:f7aaea0:         @Override
1:f7aaea0:         protected long capacity()
1:f7aaea0:         {
1:f7aaea0:             return sizes.peekLast().intValue();
1:f7aaea0:         }
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     //Check for overflow at the max size, without actually allocating all the memory
1:f7aaea0:     @Test
1:f7aaea0:     public void testDataOutputBufferMaxSizeFake() throws IOException
1:f7aaea0:     {
1:f7aaea0:         try (DataOutputBufferSpy write = new DataOutputBufferSpy())
1:f7aaea0:         {
1:f7aaea0:             boolean threw = false;
1:f7aaea0:             try
1:f7aaea0:             {
1:f7aaea0:                 while (true)
1:f7aaea0:                     write.publicFlush();
1:f7aaea0:             }
1:f7aaea0:             catch (RuntimeException e) {
1:f7aaea0:                 if (e.getClass() == RuntimeException.class)
1:f7aaea0:                     threw = true;
1:f7aaea0:             }
1:f7aaea0:             Assert.assertTrue(threw);
1:f7aaea0:             Assert.assertTrue(write.sizes.peekLast() >= DataOutputBuffer.MAX_ARRAY_SIZE);
1:f7aaea0:         }
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     @Test
1:f7aaea0:     public void testDataOutputBufferMaxSize() throws IOException
1:f7aaea0:     {
1:f7aaea0:         //Need a lot of heap to run this test for real.
1:f7aaea0:         //Tested everything else as much as possible since we can't do it all the time
1:f7aaea0:         if (Runtime.getRuntime().maxMemory() < 5033164800L)
1:f7aaea0:             return;
1:f7aaea0: 
1:f7aaea0:         try (DataOutputBuffer write = new DataOutputBuffer())
1:f7aaea0:         {
1:f7aaea0:             //Doesn't throw up to DataOuptutBuffer.MAX_ARRAY_SIZE which is the array size limit in Java
1:f7aaea0:             for (int ii = 0; ii < DataOutputBuffer.MAX_ARRAY_SIZE / 8; ii++)
1:f7aaea0:                 write.writeLong(0);
1:f7aaea0:             write.write(new byte[7]);
1:f7aaea0: 
1:f7aaea0:             //Should fail due to validation
1:f7aaea0:             checkThrowsRuntimeException(validateReallocationCallable( write, DataOutputBuffer.MAX_ARRAY_SIZE + 1));
1:f7aaea0:             //Check that it does throw
1:f7aaea0:             checkThrowsRuntimeException(new Callable<Object>()
1:f7aaea0:             {
1:f7aaea0:                 public Object call() throws Exception
1:f7aaea0:                 {
1:f7aaea0:                     write.write(42);
1:f7aaea0:                     return null;
1:f7aaea0:                 }
1:f7aaea0:             });
1:f7aaea0:         }
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     //Can't test it for real without tons of heap so test as much validation as possible
1:f7aaea0:     @Test
1:f7aaea0:     public void testDataOutputBufferBigReallocation() throws Exception
1:f7aaea0:     {
1:f7aaea0:         //Check saturating cast behavior
1:f7aaea0:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:f7aaea0:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE));
1:f7aaea0:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:f7aaea0:         Assert.assertEquals(0, DataOutputBuffer.saturatedArraySizeCast(0));
1:f7aaea0:         Assert.assertEquals(1, DataOutputBuffer.saturatedArraySizeCast(1));
1:f7aaea0:         checkThrowsIAE(saturatedArraySizeCastCallable(-1));
1:f7aaea0: 
1:f7aaea0:         //Check checked cast behavior
1:f7aaea0:         checkThrowsIAE(checkedArraySizeCastCallable(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:f7aaea0:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.checkedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE));
1:f7aaea0:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, DataOutputBuffer.checkedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:f7aaea0:         Assert.assertEquals(0, DataOutputBuffer.checkedArraySizeCast(0));
1:f7aaea0:         Assert.assertEquals(1, DataOutputBuffer.checkedArraySizeCast(1));
1:f7aaea0:         checkThrowsIAE(checkedArraySizeCastCallable(-1));
1:f7aaea0: 
1:f7aaea0: 
1:f7aaea0:         try (DataOutputBuffer write = new DataOutputBuffer())
1:f7aaea0:         {
1:f7aaea0:             //Checked validation performed by DOB
1:f7aaea0:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:f7aaea0:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE));
1:f7aaea0:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:f7aaea0:             checkThrowsRuntimeException(validateReallocationCallable( write, 0));
1:f7aaea0:             checkThrowsRuntimeException(validateReallocationCallable( write, 1));
1:f7aaea0:             checkThrowsIAE(validateReallocationCallable( write, -1));
1:f7aaea0:         }
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     Callable<Object> saturatedArraySizeCastCallable(final long value)
1:f7aaea0:     {
1:f7aaea0:         return new Callable<Object>()
1:f7aaea0:         {
1:f7aaea0:             @Override
1:f7aaea0:             public Object call() throws Exception
1:f7aaea0:             {
1:f7aaea0:                 return DataOutputBuffer.saturatedArraySizeCast(value);
1:f7aaea0:             }
1:f7aaea0:         };
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     Callable<Object> checkedArraySizeCastCallable(final long value)
1:f7aaea0:     {
1:f7aaea0:         return new Callable<Object>()
1:f7aaea0:         {
1:f7aaea0:             @Override
1:f7aaea0:             public Object call() throws Exception
1:f7aaea0:             {
1:f7aaea0:                 return DataOutputBuffer.checkedArraySizeCast(value);
1:f7aaea0:             }
1:f7aaea0:         };
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     Callable<Object> validateReallocationCallable(final DataOutputBuffer write, final long value)
1:f7aaea0:     {
1:f7aaea0:         return new Callable<Object>()
1:f7aaea0:         {
1:f7aaea0:             @Override
1:f7aaea0:             public Object call() throws Exception
1:f7aaea0:             {
1:f7aaea0:                 return write.validateReallocation(value);
1:f7aaea0:             }
1:f7aaea0:         };
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     private static void checkThrowsIAE(Callable<Object> c)
1:f7aaea0:     {
1:f7aaea0:         checkThrowsException(c, IllegalArgumentException.class);
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     private static void checkThrowsRuntimeException(Callable<Object> c)
1:f7aaea0:     {
1:f7aaea0:         checkThrowsException(c, RuntimeException.class);
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     private static void checkThrowsException(Callable<Object> c, Class<?> exceptionClass)
1:f7aaea0:     {
1:f7aaea0:         boolean threw = false;
1:f7aaea0:         try
1:f7aaea0:         {
1:f7aaea0:             c.call();
1:f7aaea0:         }
1:f7aaea0:         catch (Throwable t)
1:f7aaea0:         {
1:f7aaea0:             if (t.getClass() == exceptionClass)
1:f7aaea0:                 threw = true;
1:f7aaea0:         }
1:f7aaea0:         Assert.assertTrue(threw);
1:f7aaea0:     }
1:f7aaea0: 
1:75508ec:     @Test
1:f3c0e11:     public void testSafeMemoryWriter() throws IOException
1:f3c0e11:     {
1:4e29b7a:         try (SafeMemoryWriter write = new SafeMemoryWriter(10))
1:4e29b7a:         {
1:f3c0e11:             DataInput canon = testWrite(write);
1:f3c0e11:             byte[] bytes = new byte[345];
1:f3c0e11:             write.currentBuffer().getBytes(0, bytes, 0, 345);
1:f3c0e11:             DataInput test = new DataInputStream(new ByteArrayInputStream(bytes));
1:f3c0e11:             testRead(test, canon);
1:f3c0e11:         }
1:4e29b7a:     }
1:f3c0e11: 
1:f3c0e11:     @Test
1:16499ca:     public void testWrappedFileOutputStream() throws IOException
1:16499ca:     {
1:16499ca:         File file = FileUtils.createTempFile("dataoutput", "test");
1:16499ca:         try
1:16499ca:         {
1:16499ca:             DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(new FileOutputStream(file));
1:16499ca:             DataInput canon = testWrite(write);
1:16499ca:             write.close();
1:16499ca:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:16499ca:             testRead(test, canon);
1:16499ca:             test.close();
1:16499ca:         }
1:16499ca:         finally
1:16499ca:         {
1:16499ca:             Assert.assertTrue(file.delete());
1:16499ca:         }
1:16499ca:     }
1:16499ca: 
1:16499ca:     @Test
1:75508ec:     public void testFileOutputStream() throws IOException
1:75508ec:     {
1:75508ec:         File file = FileUtils.createTempFile("dataoutput", "test");
1:75508ec:         try
1:75508ec:         {
1:16499ca:             DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(new FileOutputStream(file));
1:75508ec:             DataInput canon = testWrite(write);
1:75508ec:             write.close();
1:5767757:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:4e29b7a:             testRead(test, canon);
1:5767757:             test.close();
1:75508ec:         }
1:75508ec:         finally
1:75508ec:         {
1:75508ec:             Assert.assertTrue(file.delete());
1:75508ec:         }
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:75508ec:     public void testRandomAccessFile() throws IOException
1:75508ec:     {
1:75508ec:         File file = FileUtils.createTempFile("dataoutput", "test");
1:75508ec:         try
1:75508ec:         {
1:16499ca:             @SuppressWarnings("resource")
1:75508ec:             final RandomAccessFile raf = new RandomAccessFile(file, "rw");
1:16499ca:             DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(raf.getChannel());
1:75508ec:             DataInput canon = testWrite(write);
1:75508ec:             write.close();
1:5767757:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:75508ec:             testRead(test, canon);
1:5767757:             test.close();
1:75508ec:         }
1:75508ec:         finally
1:75508ec:         {
1:75508ec:             Assert.assertTrue(file.delete());
1:75508ec:         }
1:75508ec:     }
1:75508ec: 
1:75508ec:     @Test
1:75508ec:     public void testSequentialWriter() throws IOException
1:75508ec:     {
1:75508ec:         File file = FileUtils.createTempFile("dataoutput", "test");
1:fb22109:         SequentialWriterOption option = SequentialWriterOption.newBuilder().bufferSize(32).finishOnClose(true).build();
1:fb22109:         final SequentialWriter writer = new SequentialWriter(file, option);
1:fb22109:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(writer);
1:75508ec:         DataInput canon = testWrite(write);
1:75508ec:         write.flush();
1:75508ec:         write.close();
1:5767757:         DataInputStream test = new DataInputStream(new FileInputStream(file));
1:75508ec:         testRead(test, canon);
1:5767757:         test.close();
1:75508ec:         Assert.assertTrue(file.delete());
1:75508ec:     }
1:75508ec: 
1:75508ec:     private DataInput testWrite(DataOutputPlus test) throws IOException
1:75508ec:     {
1:75508ec:         final ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:75508ec:         final DataOutput canon = new DataOutputStream(bos);
1:75508ec:         Random rnd = ThreadLocalRandom.current();
1:75508ec: 
1:bc7941c:         int size = 50;
1:bc7941c:         byte[] bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithLength(bytes, test);
1:75508ec:         ByteBufferUtil.writeWithLength(bytes, canon);
1:75508ec: 
1:bc7941c:         bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithLength(wrap(bytes, false), test);
1:75508ec:         ByteBufferUtil.writeWithLength(bytes, canon);
1:75508ec: 
1:bc7941c:         bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithLength(wrap(bytes, true), test);
1:75508ec:         ByteBufferUtil.writeWithLength(bytes, canon);
1:75508ec: 
1:bc7941c:         bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithShortLength(bytes, test);
1:75508ec:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1:75508ec: 
1:bc7941c:         bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithShortLength(wrap(bytes, false), test);
1:75508ec:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1:75508ec: 
1:bc7941c:         bytes = new byte[size];
1:75508ec:         rnd.nextBytes(bytes);
1:75508ec:         ByteBufferUtil.writeWithShortLength(wrap(bytes, true), test);
1:75508ec:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1:75508ec:         // 318
1:75508ec: 
1:75508ec:         {
1:75508ec:             long v = rnd.nextLong();
1:75508ec:             test.writeLong(v);
1:75508ec:             canon.writeLong(v);
1:75508ec:         }
1:75508ec:         {
1:75508ec:             int v = rnd.nextInt();
1:75508ec:             test.writeInt(v);
1:75508ec:             canon.writeInt(v);
1:75508ec:         }
1:75508ec:         {
1:75508ec:             short v = (short) rnd.nextInt();
1:75508ec:             test.writeShort(v);
1:75508ec:             canon.writeShort(v);
1:75508ec:         }
1:75508ec:         {
1:75508ec:             byte v = (byte) rnd.nextInt();
1:75508ec:             test.write(v);
1:75508ec:             canon.write(v);
1:75508ec:         }
1:75508ec:         {
1:75508ec:             double v = rnd.nextDouble();
1:75508ec:             test.writeDouble(v);
1:75508ec:             canon.writeDouble(v);
1:75508ec:         }
1:75508ec:         {
1:75508ec:             float v = (float) rnd.nextDouble();
1:75508ec:             test.writeFloat(v);
1:75508ec:             canon.writeFloat(v);
1:75508ec:         }
1:75508ec: 
1:75508ec:         // 27
1:75508ec:         return new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:75508ec:     }
1:75508ec: 
1:75508ec:     private void testRead(DataInput test, DataInput canon) throws IOException
1:75508ec:     {
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:75508ec:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:75508ec:         assert test.readLong() == canon.readLong();
1:75508ec:         assert test.readInt() == canon.readInt();
1:75508ec:         assert test.readShort() == canon.readShort();
1:75508ec:         assert test.readByte() == canon.readByte();
1:75508ec:         assert test.readDouble() == canon.readDouble();
1:75508ec:         assert test.readFloat() == canon.readFloat();
1:75508ec:         try
1:75508ec:         {
1:75508ec:             test.readInt();
1:75508ec:             assert false;
1:75508ec:         }
1:f47863e:         catch (EOFException ignore)
1:75508ec:         {
1:f47863e:             // it worked
1:75508ec:         }
1:75508ec:     }
1:75508ec: 
1:75508ec:     private static ByteBuffer wrap(byte[] bytes, boolean direct)
1:75508ec:     {
1:75508ec:         ByteBuffer buf = direct ? ByteBuffer.allocateDirect(bytes.length + 20) : ByteBuffer.allocate(bytes.length + 20);
1:75508ec:         buf.position(10);
1:75508ec:         buf.limit(bytes.length + 10);
1:75508ec:         buf.duplicate().put(bytes);
1:75508ec:         return buf;
1:75508ec:     }
1:75508ec: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:fb22109
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         SequentialWriterOption option = SequentialWriterOption.newBuilder().bufferSize(32).finishOnClose(true).build();
1:         final SequentialWriter writer = new SequentialWriter(file, option);
1:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(writer);
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:f7aaea0
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayDeque;
1: import java.util.Deque;
1: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
1:     public void testDataOutputBufferZeroReallocate() throws IOException
1:     {
1:         try (DataOutputBufferSpy write = new DataOutputBufferSpy())
1:         {
1:             for (int ii = 0; ii < 1000000; ii++)
1:             {
1:                 write.superReallocate(0);
1:             }
1:         }
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     private static class DataOutputBufferSpy extends DataOutputBuffer
1:     {
1:         Deque<Long> sizes = new ArrayDeque<>();
1: 
1:         DataOutputBufferSpy()
1:         {
1:             sizes.offer(128L);
1:         }
1: 
1:         void publicFlush() throws IOException
1:         {
1:             //Going to allow it to double instead of specifying a count
1:             doFlush(1);
1:         }
1: 
1:         void superReallocate(int count) throws IOException
1:         {
1:             super.reallocate(count);
1:         }
1: 
1:         @Override
1:         protected void reallocate(long count)
1:         {
1:             if (count <= 0)
1:                 return;
1:             Long lastSize = sizes.peekLast();
1:             long newSize = calculateNewSize(count);
1:             sizes.offer(newSize);
1:             if (newSize > DataOutputBuffer.MAX_ARRAY_SIZE)
1:                 throw new RuntimeException();
1:             if (newSize < 0)
1:                 throw new AssertionError();
1:             if (lastSize != null && newSize <= lastSize)
1:                 throw new AssertionError();
1:         }
1: 
1:         @Override
1:         protected long capacity()
1:         {
1:             return sizes.peekLast().intValue();
1:         }
1:     }
1: 
1:     //Check for overflow at the max size, without actually allocating all the memory
1:     @Test
1:     public void testDataOutputBufferMaxSizeFake() throws IOException
1:     {
1:         try (DataOutputBufferSpy write = new DataOutputBufferSpy())
1:         {
1:             boolean threw = false;
1:             try
1:             {
1:                 while (true)
1:                     write.publicFlush();
1:             }
1:             catch (RuntimeException e) {
1:                 if (e.getClass() == RuntimeException.class)
1:                     threw = true;
1:             }
1:             Assert.assertTrue(threw);
1:             Assert.assertTrue(write.sizes.peekLast() >= DataOutputBuffer.MAX_ARRAY_SIZE);
1:         }
1:     }
1: 
1:     @Test
1:     public void testDataOutputBufferMaxSize() throws IOException
1:     {
1:         //Need a lot of heap to run this test for real.
1:         //Tested everything else as much as possible since we can't do it all the time
1:         if (Runtime.getRuntime().maxMemory() < 5033164800L)
1:             return;
1: 
1:         try (DataOutputBuffer write = new DataOutputBuffer())
1:         {
1:             //Doesn't throw up to DataOuptutBuffer.MAX_ARRAY_SIZE which is the array size limit in Java
1:             for (int ii = 0; ii < DataOutputBuffer.MAX_ARRAY_SIZE / 8; ii++)
1:                 write.writeLong(0);
1:             write.write(new byte[7]);
1: 
1:             //Should fail due to validation
1:             checkThrowsRuntimeException(validateReallocationCallable( write, DataOutputBuffer.MAX_ARRAY_SIZE + 1));
1:             //Check that it does throw
1:             checkThrowsRuntimeException(new Callable<Object>()
1:             {
1:                 public Object call() throws Exception
1:                 {
1:                     write.write(42);
1:                     return null;
1:                 }
1:             });
1:         }
1:     }
1: 
1:     //Can't test it for real without tons of heap so test as much validation as possible
1:     @Test
1:     public void testDataOutputBufferBigReallocation() throws Exception
1:     {
1:         //Check saturating cast behavior
1:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE));
1:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, DataOutputBuffer.saturatedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:         Assert.assertEquals(0, DataOutputBuffer.saturatedArraySizeCast(0));
1:         Assert.assertEquals(1, DataOutputBuffer.saturatedArraySizeCast(1));
1:         checkThrowsIAE(saturatedArraySizeCastCallable(-1));
1: 
1:         //Check checked cast behavior
1:         checkThrowsIAE(checkedArraySizeCastCallable(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, DataOutputBuffer.checkedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE));
1:         Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, DataOutputBuffer.checkedArraySizeCast(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:         Assert.assertEquals(0, DataOutputBuffer.checkedArraySizeCast(0));
1:         Assert.assertEquals(1, DataOutputBuffer.checkedArraySizeCast(1));
1:         checkThrowsIAE(checkedArraySizeCastCallable(-1));
1: 
1: 
1:         try (DataOutputBuffer write = new DataOutputBuffer())
1:         {
1:             //Checked validation performed by DOB
1:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE + 1L));
1:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE));
1:             Assert.assertEquals(DataOutputBuffer.MAX_ARRAY_SIZE - 1, write.validateReallocation(DataOutputBuffer.MAX_ARRAY_SIZE - 1));
1:             checkThrowsRuntimeException(validateReallocationCallable( write, 0));
1:             checkThrowsRuntimeException(validateReallocationCallable( write, 1));
1:             checkThrowsIAE(validateReallocationCallable( write, -1));
1:         }
1:     }
1: 
1:     Callable<Object> saturatedArraySizeCastCallable(final long value)
1:     {
1:         return new Callable<Object>()
1:         {
1:             @Override
1:             public Object call() throws Exception
1:             {
1:                 return DataOutputBuffer.saturatedArraySizeCast(value);
1:             }
1:         };
1:     }
1: 
1:     Callable<Object> checkedArraySizeCastCallable(final long value)
1:     {
1:         return new Callable<Object>()
1:         {
1:             @Override
1:             public Object call() throws Exception
1:             {
1:                 return DataOutputBuffer.checkedArraySizeCast(value);
1:             }
1:         };
1:     }
1: 
1:     Callable<Object> validateReallocationCallable(final DataOutputBuffer write, final long value)
1:     {
1:         return new Callable<Object>()
1:         {
1:             @Override
1:             public Object call() throws Exception
1:             {
1:                 return write.validateReallocation(value);
1:             }
1:         };
1:     }
1: 
1:     private static void checkThrowsIAE(Callable<Object> c)
1:     {
1:         checkThrowsException(c, IllegalArgumentException.class);
1:     }
1: 
1:     private static void checkThrowsRuntimeException(Callable<Object> c)
1:     {
1:         checkThrowsException(c, RuntimeException.class);
1:     }
1: 
1:     private static void checkThrowsException(Callable<Object> c, Class<?> exceptionClass)
1:     {
1:         boolean threw = false;
1:         try
1:         {
1:             c.call();
1:         }
1:         catch (Throwable t)
1:         {
1:             if (t.getClass() == exceptionClass)
1:                 threw = true;
1:         }
1:         Assert.assertTrue(threw);
1:     }
1: 
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1:     public void testWrappedDataOutputStreamPlus() throws IOException
1:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(bos);
1:     public void testWrappedDataOutputChannelAndChannel() throws IOException
1:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(bos);
1:     public void testBufferedDataOutputStreamPlusAndChannel() throws IOException
1:     {
1:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:         DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(Channels.newChannel(bos));
1:         DataInput canon = testWrite(write);
1:         write.close();
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus(null, buf.duplicate());
/////////////////////////////////////////////////////////////////////////
1:         BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus(null, buf.duplicate());
/////////////////////////////////////////////////////////////////////////
1:     public void testWrappedFileOutputStream() throws IOException
1:     {
1:         File file = FileUtils.createTempFile("dataoutput", "test");
1:         try
1:         {
1:             DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(new FileOutputStream(file));
1:             DataInput canon = testWrite(write);
1:             write.close();
1:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:             testRead(test, canon);
1:             test.close();
1:         }
1:         finally
1:         {
1:             Assert.assertTrue(file.delete());
1:         }
1:     }
1: 
1:     @Test
1:             DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(new FileOutputStream(file));
/////////////////////////////////////////////////////////////////////////
1:             @SuppressWarnings("resource")
1:             DataOutputStreamPlus write = new BufferedDataOutputStreamPlus(raf.getChannel());
/////////////////////////////////////////////////////////////////////////
0:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(writer);
author:Blake Eggleston
-------------------------------------------------------------------------------
commit:a3fc425
/////////////////////////////////////////////////////////////////////////
0:         DataOutputStreamPlus write = new WrappedDataOutputStreamPlus(writer.finishOnClose());
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:3adfd15
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.io.compress.BufferType;
/////////////////////////////////////////////////////////////////////////
0:         final SequentialWriter writer = new SequentialWriter(file, 32, BufferType.ON_HEAP);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:8704006
/////////////////////////////////////////////////////////////////////////
0:         writer.finish();
commit:e473ce0
commit:f3c0e11
/////////////////////////////////////////////////////////////////////////
1:     public void testSafeMemoryWriter() throws IOException
1:     {
0:         SafeMemoryWriter write = new SafeMemoryWriter(10);
1:         DataInput canon = testWrite(write);
1:         byte[] bytes = new byte[345];
1:         write.currentBuffer().getBytes(0, bytes, 0, 345);
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(bytes));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:4e29b7a
/////////////////////////////////////////////////////////////////////////
1:         try (SafeMemoryWriter write = new SafeMemoryWriter(10))
1:         {
1:             DataInput canon = testWrite(write);
0:             byte[] bytes = new byte[345];
0:             write.currentBuffer().getBytes(0, bytes, 0, 345);
0:             DataInput test = new DataInputStream(new ByteArrayInputStream(bytes));
1:             testRead(test, canon);
1:         }
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:bc7941c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final SequentialWriter writer = new SequentialWriter(file, 32, false);
/////////////////////////////////////////////////////////////////////////
1:         int size = 50;
1:         byte[] bytes = new byte[size];
1:         bytes = new byte[size];
1:         bytes = new byte[size];
1:         bytes = new byte[size];
1:         bytes = new byte[size];
1:         bytes = new byte[size];
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:f47863e
/////////////////////////////////////////////////////////////////////////
1:         catch (EOFException ignore)
1:             // it worked
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5767757
/////////////////////////////////////////////////////////////////////////
1:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:             test.close();
/////////////////////////////////////////////////////////////////////////
1:             DataInputStream test = new DataInputStream(new FileInputStream(file));
1:             test.close();
/////////////////////////////////////////////////////////////////////////
1:         DataInputStream test = new DataInputStream(new FileInputStream(file));
1:         test.close();
author:belliottsmith
-------------------------------------------------------------------------------
commit:4e95953
/////////////////////////////////////////////////////////////////////////
0:         final SequentialWriter writer = new SequentialWriter(file, 32);
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.io.util;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataInput;
1: import java.io.DataInputStream;
1: import java.io.DataOutput;
1: import java.io.DataOutputStream;
1: import java.io.EOFException;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.RandomAccessFile;
1: import java.nio.ByteBuffer;
1: import java.nio.channels.Channels;
0: import java.util.Arrays;
1: import java.util.Random;
1: import java.util.concurrent.ThreadLocalRandom;
1: 
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
0: import org.apache.avro.util.ByteBufferInputStream;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: public class DataOutputTest
1: {
1: 
1:     @Test
0:     public void testDataOutputStreamPlus() throws IOException
1:     {
1:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:         DataOutputStreamPlus write = new DataOutputStreamPlus(bos);
1:         DataInput canon = testWrite(write);
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
0:     public void testDataOutputChannelAndChannel() throws IOException
1:     {
1:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:         DataOutputStreamPlus write = new DataOutputStreamAndChannel(Channels.newChannel(bos));
1:         DataInput canon = testWrite(write);
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
1:     public void testDataOutputBuffer() throws IOException
1:     {
1:         DataOutputBuffer write = new DataOutputBuffer();
1:         DataInput canon = testWrite(write);
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(write.toByteArray()));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
1:     public void testDataOutputDirectByteBuffer() throws IOException
1:     {
1:         ByteBuffer buf = wrap(new byte[345], true);
0:         DataOutputByteBuffer write = new DataOutputByteBuffer(buf.duplicate());
1:         DataInput canon = testWrite(write);
0:         DataInput test = new DataInputStream(new ByteBufferInputStream(Arrays.asList(buf)));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
1:     public void testDataOutputHeapByteBuffer() throws IOException
1:     {
1:         ByteBuffer buf = wrap(new byte[345], false);
0:         DataOutputByteBuffer write = new DataOutputByteBuffer(buf.duplicate());
1:         DataInput canon = testWrite(write);
0:         DataInput test = new DataInputStream(new ByteBufferInputStream(Arrays.asList(buf)));
1:         testRead(test, canon);
1:     }
1: 
1:     @Test
1:     public void testFileOutputStream() throws IOException
1:     {
1:         File file = FileUtils.createTempFile("dataoutput", "test");
1:         try
1:         {
0:             DataOutputStreamAndChannel write = new DataOutputStreamAndChannel(new FileOutputStream(file));
1:             DataInput canon = testWrite(write);
1:             write.close();
0:             DataInput test = new DataInputStream(new FileInputStream(file));
1:             testRead(test, canon);
1:         }
1:         finally
1:         {
1:             Assert.assertTrue(file.delete());
1:         }
1:     }
1: 
1:     @Test
1:     public void testRandomAccessFile() throws IOException
1:     {
1:         File file = FileUtils.createTempFile("dataoutput", "test");
1:         try
1:         {
1:             final RandomAccessFile raf = new RandomAccessFile(file, "rw");
0:             DataOutputStreamAndChannel write = new DataOutputStreamAndChannel(Channels.newOutputStream(raf.getChannel()), raf.getChannel());
1:             DataInput canon = testWrite(write);
1:             write.close();
0:             DataInput test = new DataInputStream(new FileInputStream(file));
1:             testRead(test, canon);
1:         }
1:         finally
1:         {
1:             Assert.assertTrue(file.delete());
1:         }
1:     }
1: 
1:     @Test
1:     public void testSequentialWriter() throws IOException
1:     {
1:         File file = FileUtils.createTempFile("dataoutput", "test");
0:         final SequentialWriter writer = new SequentialWriter(file, 32, true);
0:         DataOutputStreamAndChannel write = new DataOutputStreamAndChannel(writer, writer);
1:         DataInput canon = testWrite(write);
1:         write.flush();
1:         write.close();
0:         DataInput test = new DataInputStream(new FileInputStream(file));
1:         testRead(test, canon);
1:         Assert.assertTrue(file.delete());
1:     }
1: 
1:     private DataInput testWrite(DataOutputPlus test) throws IOException
1:     {
1:         final ByteArrayOutputStream bos = new ByteArrayOutputStream();
1:         final DataOutput canon = new DataOutputStream(bos);
1:         Random rnd = ThreadLocalRandom.current();
1: 
0:         byte[] bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithLength(bytes, test);
1:         ByteBufferUtil.writeWithLength(bytes, canon);
1: 
0:         bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithLength(wrap(bytes, false), test);
1:         ByteBufferUtil.writeWithLength(bytes, canon);
1: 
0:         bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithLength(wrap(bytes, true), test);
1:         ByteBufferUtil.writeWithLength(bytes, canon);
1: 
0:         bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithShortLength(bytes, test);
1:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1: 
0:         bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithShortLength(wrap(bytes, false), test);
1:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1: 
0:         bytes = new byte[50];
1:         rnd.nextBytes(bytes);
1:         ByteBufferUtil.writeWithShortLength(wrap(bytes, true), test);
1:         ByteBufferUtil.writeWithShortLength(bytes, canon);
1:         // 318
1: 
1:         {
1:             long v = rnd.nextLong();
1:             test.writeLong(v);
1:             canon.writeLong(v);
1:         }
1:         {
1:             int v = rnd.nextInt();
1:             test.writeInt(v);
1:             canon.writeInt(v);
1:         }
1:         {
1:             short v = (short) rnd.nextInt();
1:             test.writeShort(v);
1:             canon.writeShort(v);
1:         }
1:         {
1:             byte v = (byte) rnd.nextInt();
1:             test.write(v);
1:             canon.write(v);
1:         }
1:         {
1:             double v = rnd.nextDouble();
1:             test.writeDouble(v);
1:             canon.writeDouble(v);
1:         }
1:         {
1:             float v = (float) rnd.nextDouble();
1:             test.writeFloat(v);
1:             canon.writeFloat(v);
1:         }
1: 
1:         // 27
1:         return new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));
1:     }
1: 
1:     private void testRead(DataInput test, DataInput canon) throws IOException
1:     {
1:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:         Assert.assertEquals(ByteBufferUtil.readWithLength(canon), ByteBufferUtil.readWithLength(test));
1:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:         Assert.assertEquals(ByteBufferUtil.readWithShortLength(canon), ByteBufferUtil.readWithShortLength(test));
1:         assert test.readLong() == canon.readLong();
1:         assert test.readInt() == canon.readInt();
1:         assert test.readShort() == canon.readShort();
1:         assert test.readByte() == canon.readByte();
1:         assert test.readDouble() == canon.readDouble();
1:         assert test.readFloat() == canon.readFloat();
1:         try
1:         {
1:             test.readInt();
1:             assert false;
1:         }
0:         catch (EOFException _)
1:         {
1:         }
1:     }
1: 
1:     private static ByteBuffer wrap(byte[] bytes, boolean direct)
1:     {
1:         ByteBuffer buf = direct ? ByteBuffer.allocateDirect(bytes.length + 20) : ByteBuffer.allocate(bytes.length + 20);
1:         buf.position(10);
1:         buf.limit(bytes.length + 10);
1:         buf.duplicate().put(bytes);
1:         return buf;
1:     }
1: }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:5baa72f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(ByteBufferUtil.getArray(buf)));
/////////////////////////////////////////////////////////////////////////
1:         DataInput test = new DataInputStream(new ByteArrayInputStream(ByteBufferUtil.getArray(buf)));
============================================================================