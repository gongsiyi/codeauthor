1:6d3a3ee: /*
1:6d3a3ee:  * Licensed to the Apache Software Foundation (ASF) under one
1:6d3a3ee:  * or more contributor license agreements.  See the NOTICE file
1:6d3a3ee:  * distributed with this work for additional information
1:6d3a3ee:  * regarding copyright ownership.  The ASF licenses this file
1:6d3a3ee:  * to you under the Apache License, Version 2.0 (the
1:6d3a3ee:  * "License"); you may not use this file except in compliance
1:6d3a3ee:  * with the License.  You may obtain a copy of the License at
1:6d3a3ee:  *
1:6d3a3ee:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6d3a3ee:  *
1:6d3a3ee:  * Unless required by applicable law or agreed to in writing, software
1:6d3a3ee:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6d3a3ee:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6d3a3ee:  * See the License for the specific language governing permissions and
1:6d3a3ee:  * limitations under the License.
1:6d3a3ee:  */
1:6d3a3ee: package org.apache.cassandra.transport;
10:6d3a3ee: 
1:68722e7: import java.io.Closeable;
1:6d3a3ee: import java.io.IOException;
1:6d3a3ee: import java.net.InetSocketAddress;
1:6d3a3ee: import java.nio.ByteBuffer;
1:4169aa3: import java.util.Collections;
1:119c726: import java.util.HashMap;
1:119c726: import java.util.List;
1:119c726: import java.util.Map;
1:119c726: import java.util.concurrent.BlockingQueue;
1:f6217ae: import java.util.concurrent.LinkedBlockingQueue;
1:119c726: import java.util.concurrent.SynchronousQueue;
1:119c726: import javax.net.ssl.SSLContext;
1:119c726: import javax.net.ssl.SSLEngine;
1:a0db8ff: 
1:119c726: import org.slf4j.Logger;
1:119c726: import org.slf4j.LoggerFactory;
1:119c726: 
1:cbf304e: import io.netty.bootstrap.Bootstrap;
1:cbf304e: import io.netty.channel.ChannelHandler;
1:cbf304e: import io.netty.channel.ChannelInitializer;
1:cbf304e: import io.netty.channel.ChannelOption;
1:cbf304e: import io.netty.channel.SimpleChannelInboundHandler;
1:cbf304e: import io.netty.channel.nio.NioEventLoopGroup;
1:cbf304e: import io.netty.util.internal.logging.InternalLoggerFactory;
1:cbf304e: import io.netty.util.internal.logging.Slf4JLoggerFactory;
1:bfd73be: import org.apache.cassandra.cql3.QueryOptions;
1:119c726: import org.apache.cassandra.db.ConsistencyLevel;
1:119c726: import org.apache.cassandra.security.SSLFactory;
1:119c726: import org.apache.cassandra.transport.messages.CredentialsMessage;
1:119c726: import org.apache.cassandra.transport.messages.ErrorMessage;
1:f6217ae: import org.apache.cassandra.transport.messages.EventMessage;
1:119c726: import org.apache.cassandra.transport.messages.ExecuteMessage;
1:119c726: import org.apache.cassandra.transport.messages.PrepareMessage;
1:119c726: import org.apache.cassandra.transport.messages.QueryMessage;
1:119c726: import org.apache.cassandra.transport.messages.ResultMessage;
1:119c726: import org.apache.cassandra.transport.messages.StartupMessage;
1:bfd73be: import org.apache.cassandra.utils.MD5Digest;
1:cbf304e: import io.netty.channel.Channel;
1:cbf304e: import io.netty.channel.ChannelFuture;
1:cbf304e: import io.netty.channel.ChannelHandlerContext;
1:cbf304e: import io.netty.channel.ChannelPipeline;
1:cbf304e: import io.netty.handler.ssl.SslHandler;
1:119c726: import static org.apache.cassandra.config.EncryptionOptions.ClientEncryptionOptions;
1:6d3a3ee: 
1:68722e7: public class SimpleClient implements Closeable
2:6d3a3ee: {
1:6d3a3ee:     static
1:6d3a3ee:     {
1:6d3a3ee:         InternalLoggerFactory.setDefaultFactory(new Slf4JLoggerFactory());
2:6d3a3ee:     }
1:6d3a3ee: 
1:119c726:     private static final Logger logger = LoggerFactory.getLogger(SimpleClient.class);
1:6d3a3ee:     public final String host;
1:6d3a3ee:     public final int port;
1:119c726:     private final ClientEncryptionOptions encryptionOptions;
1:6d3a3ee: 
1:6d3a3ee:     protected final ResponseHandler responseHandler = new ResponseHandler();
1:6d3a3ee:     protected final Connection.Tracker tracker = new ConnectionTracker();
1:e0adc16:     protected final ProtocolVersion version;
1:5a18e37:     // We don't track connection really, so we don't need one Connection per channel
1:f6217ae:     protected Connection connection;
1:cbf304e:     protected Bootstrap bootstrap;
1:6d3a3ee:     protected Channel channel;
1:6d3a3ee:     protected ChannelFuture lastWriteFuture;
1:6d3a3ee: 
1:6d3a3ee:     private final Connection.Factory connectionFactory = new Connection.Factory()
1:06699d4:     {
1:e0adc16:         public Connection newConnection(Channel channel, ProtocolVersion version)
1:119c726:         {
1:6d3a3ee:             return connection;
1:6d3a3ee:         }
1:6d3a3ee:     };
1:6d3a3ee: 
1:e0adc16:     public SimpleClient(String host, int port, ProtocolVersion version, ClientEncryptionOptions encryptionOptions)
1:6d3a3ee:     {
1:d9322a1:         this(host, port, version, false, encryptionOptions);
1:6d3a3ee:     }
1:6d3a3ee: 
1:f6217ae:     public SimpleClient(String host, int port, ClientEncryptionOptions encryptionOptions)
1:6d3a3ee:     {
1:e0adc16:         this(host, port, ProtocolVersion.CURRENT, encryptionOptions);
1:6d3a3ee:     }
1:6d3a3ee: 
1:e0adc16:     public SimpleClient(String host, int port, ProtocolVersion version)
1:6d3a3ee:     {
1:f6217ae:         this(host, port, version, new ClientEncryptionOptions());
1:6d3a3ee:     }
1:6d3a3ee: 
1:e0adc16:     public SimpleClient(String host, int port, ProtocolVersion version, boolean useBeta, ClientEncryptionOptions encryptionOptions)
1:d9322a1:     {
1:d9322a1:         this.host = host;
1:d9322a1:         this.port = port;
1:e0adc16:         if (version.isBeta() && !useBeta)
1:d9322a1:             throw new IllegalArgumentException(String.format("Beta version of server used (%s), but USE_BETA flag is not set", version));
1:d9322a1: 
1:d9322a1:         this.version = version;
1:d9322a1:         this.encryptionOptions = encryptionOptions;
1:d9322a1:     }
1:d9322a1: 
1:06699d4:     public SimpleClient(String host, int port)
1:f6217ae:     {
1:06699d4:         this(host, port, new ClientEncryptionOptions());
1:f6217ae:     }
1:f6217ae: 
1:6d3a3ee:     public void connect(boolean useCompression) throws IOException
1:f6217ae:     {
1:6d3a3ee:         establishConnection();
1:f6217ae: 
1:f6217ae:         Map<String, String> options = new HashMap<>();
1:f171179:         options.put(StartupMessage.CQL_VERSION, "3.0.0");
1:6d3a3ee:         if (useCompression)
1:6d3a3ee:         {
1:f171179:             options.put(StartupMessage.COMPRESSION, "snappy");
1:6d3a3ee:             connection.setCompressor(FrameCompressor.SnappyCompressor.instance);
1:f6217ae:         }
1:f171179:         execute(new StartupMessage(options));
1:06699d4:     }
1:06699d4: 
1:f6217ae:     public void setEventHandler(EventHandler eventHandler)
1:f6217ae:     {
1:f6217ae:         responseHandler.eventHandler = eventHandler;
1:f6217ae:     }
1:f6217ae: 
1:6d3a3ee:     protected void establishConnection() throws IOException
1:6d3a3ee:     {
1:6d3a3ee:         // Configure the client.
1:cbf304e:         bootstrap = new Bootstrap()
1:cbf304e:                     .group(new NioEventLoopGroup())
1:cbf304e:                     .channel(io.netty.channel.socket.nio.NioSocketChannel.class)
1:cbf304e:                     .option(ChannelOption.TCP_NODELAY, true);
1:6d3a3ee: 
1:6d3a3ee:         // Configure the pipeline factory.
1:119c726:         if(encryptionOptions.enabled)
1:119c726:         {
1:cbf304e:             bootstrap.handler(new SecureInitializer());
1:119c726:         }
1:119c726:         else
1:119c726:         {
1:cbf304e:             bootstrap.handler(new Initializer());
1:119c726:         }
1:6d3a3ee:         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
1:6d3a3ee: 
1:6d3a3ee:         // Wait until the connection attempt succeeds or fails.
1:cbf304e:         channel = future.awaitUninterruptibly().channel();
1:6d3a3ee:         if (!future.isSuccess())
1:6d3a3ee:         {
1:cbf304e:             bootstrap.group().shutdownGracefully();
1:cbf304e:             throw new IOException("Connection Error", future.cause());
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public void login(Map<String, String> credentials)
1:6d3a3ee:     {
1:6d3a3ee:         CredentialsMessage msg = new CredentialsMessage();
1:6d3a3ee:         msg.credentials.putAll(credentials);
1:6d3a3ee:         execute(msg);
1:6d3a3ee:     }
1:6d3a3ee: 
1:297f530:     public ResultMessage execute(String query, ConsistencyLevel consistency)
1:6d3a3ee:     {
1:4169aa3:         return execute(query, Collections.<ByteBuffer>emptyList(), consistency);
1:6d3a3ee:     }
1:6d3a3ee: 
1:df723af:     public ResultMessage execute(String query, List<ByteBuffer> values, ConsistencyLevel consistencyLevel)
1:6d3a3ee:     {
1:9872b74:         Message.Response msg = execute(new QueryMessage(query, QueryOptions.forInternalCalls(consistencyLevel, values)));
1:6d3a3ee:         assert msg instanceof ResultMessage;
1:6d3a3ee:         return (ResultMessage)msg;
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public ResultMessage.Prepared prepare(String query)
1:6d3a3ee:     {
1:6d3a3ee:         Message.Response msg = execute(new PrepareMessage(query));
1:6d3a3ee:         assert msg instanceof ResultMessage.Prepared;
1:6d3a3ee:         return (ResultMessage.Prepared)msg;
1:6d3a3ee:     }
1:6d3a3ee: 
1:297f530:     public ResultMessage executePrepared(byte[] statementId, List<ByteBuffer> values, ConsistencyLevel consistency)
1:6d3a3ee:     {
1:9872b74:         Message.Response msg = execute(new ExecuteMessage(MD5Digest.wrap(statementId), QueryOptions.forInternalCalls(consistency, values)));
1:6d3a3ee:         assert msg instanceof ResultMessage;
1:6d3a3ee:         return (ResultMessage)msg;
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public void close()
1:6d3a3ee:     {
1:6d3a3ee:         // Wait until all messages are flushed before closing the channel.
1:6d3a3ee:         if (lastWriteFuture != null)
1:6d3a3ee:             lastWriteFuture.awaitUninterruptibly();
1:6d3a3ee: 
1:6d3a3ee:         // Close the connection.  Make sure the close operation ends because
1:6d3a3ee:         // all I/O operations are asynchronous in Netty.
1:6d3a3ee:         channel.close().awaitUninterruptibly();
1:6d3a3ee: 
1:6d3a3ee:         // Shut down all thread pools to exit.
1:cbf304e:         bootstrap.group().shutdownGracefully();
1:6d3a3ee:     }
1:6d3a3ee: 
1:f6217ae:     public Message.Response execute(Message.Request request)
1:6d3a3ee:     {
1:6d3a3ee:         try
1:6d3a3ee:         {
1:6d3a3ee:             request.attach(connection);
1:cbf304e:             lastWriteFuture = channel.writeAndFlush(request);
1:6d3a3ee:             Message.Response msg = responseHandler.responses.take();
1:6d3a3ee:             if (msg instanceof ErrorMessage)
1:3a2faf9:                 throw new RuntimeException((Throwable)((ErrorMessage)msg).error);
1:6d3a3ee:             return msg;
1:6d3a3ee:         }
1:6d3a3ee:         catch (InterruptedException e)
1:6d3a3ee:         {
1:6d3a3ee:             throw new RuntimeException(e);
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:f6217ae:     public interface EventHandler
1:f6217ae:     {
1:f6217ae:         void onEvent(Event event);
1:f6217ae:     }
1:f6217ae: 
1:f6217ae:     public static class SimpleEventHandler implements EventHandler
1:f6217ae:     {
1:f6217ae:         public final LinkedBlockingQueue<Event> queue = new LinkedBlockingQueue<>();
1:f6217ae: 
1:f6217ae:         public void onEvent(Event event)
1:f6217ae:         {
1:f6217ae:             queue.add(event);
1:f6217ae:         }
1:f6217ae:     }
1:f6217ae: 
1:6d3a3ee:     // Stateless handlers
1:6d3a3ee:     private static final Message.ProtocolDecoder messageDecoder = new Message.ProtocolDecoder();
1:6d3a3ee:     private static final Message.ProtocolEncoder messageEncoder = new Message.ProtocolEncoder();
1:6d3a3ee:     private static final Frame.Decompressor frameDecompressor = new Frame.Decompressor();
1:6d3a3ee:     private static final Frame.Compressor frameCompressor = new Frame.Compressor();
1:6d3a3ee:     private static final Frame.Encoder frameEncoder = new Frame.Encoder();
1:6d3a3ee: 
1:6d3a3ee:     private static class ConnectionTracker implements Connection.Tracker
1:6d3a3ee:     {
1:6d3a3ee:         public void addConnection(Channel ch, Connection connection) {}
1:f6217ae: 
1:f6217ae:         public boolean isRegistered(Event.Type type, Channel ch)
1:f6217ae:         {
1:f6217ae:             return false;
1:f6217ae:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:cbf304e:     private class Initializer extends ChannelInitializer<Channel>
1:6d3a3ee:     {
1:cbf304e:         protected void initChannel(Channel channel) throws Exception
1:6d3a3ee:         {
1:f6217ae:             connection = new Connection(channel, version, tracker);
1:f6217ae:             channel.attr(Connection.attributeKey).set(connection);
1:f6217ae: 
1:cbf304e:             ChannelPipeline pipeline = channel.pipeline();
1:5a18e37:             pipeline.addLast("frameDecoder", new Frame.Decoder(connectionFactory));
1:6d3a3ee:             pipeline.addLast("frameEncoder", frameEncoder);
1:6d3a3ee: 
1:6d3a3ee:             pipeline.addLast("frameDecompressor", frameDecompressor);
1:6d3a3ee:             pipeline.addLast("frameCompressor", frameCompressor);
1:6d3a3ee: 
1:6d3a3ee:             pipeline.addLast("messageDecoder", messageDecoder);
1:6d3a3ee:             pipeline.addLast("messageEncoder", messageEncoder);
1:6d3a3ee: 
1:6d3a3ee:             pipeline.addLast("handler", responseHandler);
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:cbf304e:     private class SecureInitializer extends Initializer
1:6d3a3ee:     {
1:119c726:         private final SSLContext sslContext;
1:119c726: 
1:cbf304e:         public SecureInitializer() throws IOException
1:119c726:         {
1:119c726:             this.sslContext = SSLFactory.createSSLContext(encryptionOptions, true);
1:119c726:         }
1:119c726: 
1:cbf304e:         protected void initChannel(Channel channel) throws Exception
1:119c726:         {
1:cbf304e:             super.initChannel(channel);
1:119c726:             SSLEngine sslEngine = sslContext.createSSLEngine();
1:119c726:             sslEngine.setUseClientMode(true);
1:a24bd6c:             String[] suites = SSLFactory.filterCipherSuites(sslEngine.getSupportedCipherSuites(), encryptionOptions.cipher_suites);
1:a24bd6c:             sslEngine.setEnabledCipherSuites(suites);
1:cbf304e:             channel.pipeline().addFirst("ssl", new SslHandler(sslEngine));
1:119c726:         }
1:119c726:     }
1:119c726: 
1:cbf304e:     @ChannelHandler.Sharable
1:cbf304e:     private static class ResponseHandler extends SimpleChannelInboundHandler<Message.Response>
1:6d3a3ee:     {
1:f6217ae:         public final BlockingQueue<Message.Response> responses = new SynchronousQueue<>(true);
1:f6217ae:         public EventHandler eventHandler;
1:119c726: 
1:6d3a3ee:         @Override
1:cbf304e:         public void channelRead0(ChannelHandlerContext ctx, Message.Response r)
1:6d3a3ee:         {
1:6d3a3ee:             try
1:6d3a3ee:             {
1:f6217ae:                 if (r instanceof EventMessage)
1:f6217ae:                 {
1:f6217ae:                     if (eventHandler != null)
1:f6217ae:                         eventHandler.onEvent(((EventMessage) r).event);
1:f6217ae:                 }
1:f6217ae:                 else
1:f6217ae:                     responses.put(r);
1:6d3a3ee:             }
1:6d3a3ee:             catch (InterruptedException ie)
1:6d3a3ee:             {
1:6d3a3ee:                 throw new RuntimeException(ie);
1:119c726:             }
1:6d3a3ee:         }
1:119c726: 
1:cbf304e:         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
1:119c726:         {
1:cbf304e:             if (this == ctx.pipeline().last())
1:cbf304e:                 logger.error("Exception in response", cause);
1:cbf304e:             ctx.fireExceptionCaught(cause);
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1:     protected final ProtocolVersion version;
/////////////////////////////////////////////////////////////////////////
1:         public Connection newConnection(Channel channel, ProtocolVersion version)
1:     public SimpleClient(String host, int port, ProtocolVersion version, ClientEncryptionOptions encryptionOptions)
1:         this(host, port, ProtocolVersion.CURRENT, encryptionOptions);
1:     public SimpleClient(String host, int port, ProtocolVersion version)
1:     public SimpleClient(String host, int port, ProtocolVersion version, boolean useBeta, ClientEncryptionOptions encryptionOptions)
1:         if (version.isBeta() && !useBeta)
author:Alex Petrov
-------------------------------------------------------------------------------
commit:d9322a1
/////////////////////////////////////////////////////////////////////////
1:         this(host, port, version, false, encryptionOptions);
/////////////////////////////////////////////////////////////////////////
0:     public SimpleClient(String host, int port, int version, boolean useBeta, ClientEncryptionOptions encryptionOptions)
1:     {
1:         this.host = host;
1:         this.port = port;
0:         if (version == Server.BETA_VERSION && !useBeta)
1:             throw new IllegalArgumentException(String.format("Beta version of server used (%s), but USE_BETA flag is not set", version));
1: 
1:         this.version = version;
1:         this.encryptionOptions = encryptionOptions;
1:     }
1: 
author:Stefan Podkowinski
-------------------------------------------------------------------------------
commit:e4a0a4b
/////////////////////////////////////////////////////////////////////////
commit:a24bd6c
/////////////////////////////////////////////////////////////////////////
1:             String[] suites = SSLFactory.filterCipherSuites(sslEngine.getSupportedCipherSuites(), encryptionOptions.cipher_suites);
1:             sslEngine.setEnabledCipherSuites(suites);
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:68722e7
/////////////////////////////////////////////////////////////////////////
1: import java.io.Closeable;
/////////////////////////////////////////////////////////////////////////
1: public class SimpleClient implements Closeable
author:Robert Stupp
-------------------------------------------------------------------------------
commit:f6217ae
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.LinkedBlockingQueue;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.messages.EventMessage;
/////////////////////////////////////////////////////////////////////////
0:     protected final int version;
1:     protected Connection connection;
/////////////////////////////////////////////////////////////////////////
0:     public SimpleClient(String host, int port, int version, ClientEncryptionOptions encryptionOptions)
0:         this.version = version;
1:     public SimpleClient(String host, int port, ClientEncryptionOptions encryptionOptions)
1:     {
0:         this(host, port, Server.CURRENT_VERSION, encryptionOptions);
1:     }
1: 
0:     public SimpleClient(String host, int port, int version)
1:     {
1:         this(host, port, version, new ClientEncryptionOptions());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> options = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     public void setEventHandler(EventHandler eventHandler)
1:     {
1:         responseHandler.eventHandler = eventHandler;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Message.Response execute(Message.Request request)
/////////////////////////////////////////////////////////////////////////
1:     public interface EventHandler
1:     {
1:         void onEvent(Event event);
1:     }
1: 
1:     public static class SimpleEventHandler implements EventHandler
1:     {
1:         public final LinkedBlockingQueue<Event> queue = new LinkedBlockingQueue<>();
1: 
1:         public void onEvent(Event event)
1:         {
1:             queue.add(event);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         public boolean isRegistered(Event.Type type, Channel ch)
1:         {
1:             return false;
1:         }
1:             connection = new Connection(channel, version, tracker);
1:             channel.attr(Connection.attributeKey).set(connection);
1: 
/////////////////////////////////////////////////////////////////////////
1:         public final BlockingQueue<Message.Response> responses = new SynchronousQueue<>(true);
1:         public EventHandler eventHandler;
1:                 if (r instanceof EventMessage)
1:                 {
1:                     if (eventHandler != null)
1:                         eventHandler.onEvent(((EventMessage) r).event);
1:                 }
1:                 else
1:                     responses.put(r);
author:Jason Brown
-------------------------------------------------------------------------------
commit:88d4a14
commit:5615a79
commit:37d33b2
/////////////////////////////////////////////////////////////////////////
0:             sslEngine.setEnabledProtocols(SSLFactory.ACCEPTED_PROTOCOLS);
commit:e15cf78
commit:1217afb
commit:b93f48a
/////////////////////////////////////////////////////////////////////////
0:             sslEngine.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
commit:d280349
/////////////////////////////////////////////////////////////////////////
0:     protected final Connection connection = new Connection(null, Server.CURRENT_VERSION, tracker);
/////////////////////////////////////////////////////////////////////////
0:             assert version == Server.CURRENT_VERSION;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:1def02f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:95f94a4
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:         Message.Response msg = execute(new QueryMessage(query, QueryOptions.forInternalCalls(consistencyLevel, values)));
/////////////////////////////////////////////////////////////////////////
1:         Message.Response msg = execute(new ExecuteMessage(MD5Digest.wrap(statementId), QueryOptions.forInternalCalls(consistency, values)));
commit:4169aa3
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:         return execute(query, Collections.<ByteBuffer>emptyList(), consistency);
commit:bfd73be
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.QueryOptions;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.MD5Digest;
/////////////////////////////////////////////////////////////////////////
0:         Message.Response msg = execute(new QueryMessage(query, new QueryOptions(consistencyLevel, values)));
/////////////////////////////////////////////////////////////////////////
0:         Message.Response msg = execute(new ExecuteMessage(MD5Digest.wrap(statementId), new QueryOptions(consistency, values)));
commit:5a18e37
/////////////////////////////////////////////////////////////////////////
1:     // We don't track connection really, so we don't need one Connection per channel
0:     protected final Connection connection = new Connection(null, Frame.Header.CURRENT_VERSION, tracker);
0:         public Connection newConnection(Channel channel, int version)
0:             assert version == Frame.Header.CURRENT_VERSION;
/////////////////////////////////////////////////////////////////////////
1:             pipeline.addLast("frameDecoder", new Frame.Decoder(connectionFactory));
commit:dad2f11
/////////////////////////////////////////////////////////////////////////
0:         Message.Response msg = execute(new QueryMessage(query, consistencyLevel, values, -1));
commit:e48ff29
/////////////////////////////////////////////////////////////////////////
0:         Message.Response msg = execute(new QueryMessage(query, values, consistencyLevel, -1));
/////////////////////////////////////////////////////////////////////////
0:         Message.Response msg = execute(new ExecuteMessage(statementId, values, consistency, -1));
commit:06699d4
/////////////////////////////////////////////////////////////////////////
1:     public SimpleClient(String host, int port)
1:     {
1:         this(host, port, new ClientEncryptionOptions());
1:     }
1: 
commit:119c726
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.BlockingQueue;
0: import java.util.concurrent.Executors;
1: import java.util.concurrent.SynchronousQueue;
1: import javax.net.ssl.SSLContext;
1: import javax.net.ssl.SSLEngine;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.db.ConsistencyLevel;
1: import org.apache.cassandra.security.SSLFactory;
1: import org.apache.cassandra.transport.messages.CredentialsMessage;
1: import org.apache.cassandra.transport.messages.ErrorMessage;
1: import org.apache.cassandra.transport.messages.ExecuteMessage;
1: import org.apache.cassandra.transport.messages.PrepareMessage;
1: import org.apache.cassandra.transport.messages.QueryMessage;
1: import org.apache.cassandra.transport.messages.ResultMessage;
1: import org.apache.cassandra.transport.messages.StartupMessage;
0: import org.jboss.netty.channel.ChannelStateEvent;
0: import org.jboss.netty.channel.Channels;
0: import org.jboss.netty.channel.ExceptionEvent;
0: import org.jboss.netty.handler.logging.LoggingHandler;
0: import org.jboss.netty.handler.ssl.SslHandler;
1: import static org.apache.cassandra.config.EncryptionOptions.ClientEncryptionOptions;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(SimpleClient.class);
1:     private final ClientEncryptionOptions encryptionOptions;
/////////////////////////////////////////////////////////////////////////
0:     public SimpleClient(String host, int port, ClientEncryptionOptions encryptionOptions)
0:         this.encryptionOptions = encryptionOptions;
/////////////////////////////////////////////////////////////////////////
1:         if(encryptionOptions.enabled)
1:         {
0:             bootstrap.setPipelineFactory(new SecurePipelineFactory());
1:         }
1:         else
1:         {
0:             bootstrap.setPipelineFactory(new PipelineFactory());
1:         }
/////////////////////////////////////////////////////////////////////////
0:     private class SecurePipelineFactory extends PipelineFactory
1:     {
1:         private final SSLContext sslContext;
1: 
0:         public SecurePipelineFactory() throws IOException
1:         {
1:             this.sslContext = SSLFactory.createSSLContext(encryptionOptions, true);
1:         }
1: 
0:         public ChannelPipeline getPipeline() throws Exception
1:         {
1:             SSLEngine sslEngine = sslContext.createSSLEngine();
1:             sslEngine.setUseClientMode(true);
0:             sslEngine.setEnabledCipherSuites(encryptionOptions.cipher_suites);
0:             ChannelPipeline pipeline = super.getPipeline();
1: 
0:             pipeline.addFirst("ssl", new SslHandler(sslEngine));
0:             return pipeline;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception
1:         {
0:             if (this == ctx.getPipeline().getLast())
0:                 logger.error("Exception in response", e.getCause());
0:             ctx.sendUpstream(e);
1:         }
commit:a0db8ff
/////////////////////////////////////////////////////////////////////////
0:         bootstrap.setOption("tcpNoDelay", true);
1: 
commit:297f530
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.ConsistencyLevel;
/////////////////////////////////////////////////////////////////////////
1:     public ResultMessage execute(String query, ConsistencyLevel consistency)
0:         Message.Response msg = execute(new QueryMessage(query, consistency));
/////////////////////////////////////////////////////////////////////////
1:     public ResultMessage executePrepared(byte[] statementId, List<ByteBuffer> values, ConsistencyLevel consistency)
0:         Message.Response msg = execute(new ExecuteMessage(statementId, values, consistency));
commit:ccca5f1
/////////////////////////////////////////////////////////////////////////
0:     public ResultMessage executePrepared(byte[] statementId, List<ByteBuffer> values)
commit:f199fa3
/////////////////////////////////////////////////////////////////////////
0:     protected final Connection connection = new Connection(tracker);
0:         public Connection newConnection(Connection.Tracker tracker)
/////////////////////////////////////////////////////////////////////////
commit:f171179
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> options = new HashMap<String, String>();
1:         options.put(StartupMessage.CQL_VERSION, "3.0.0");
1:             options.put(StartupMessage.COMPRESSION, "snappy");
1:         execute(new StartupMessage(options));
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1:                 throw new RuntimeException((Throwable)((ErrorMessage)msg).error);
commit:6d3a3ee
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.transport;
1: 
1: import java.io.IOException;
1: import java.net.InetSocketAddress;
1: import java.nio.ByteBuffer;
0: import java.util.concurrent.*;
0: import java.util.*;
1: 
0: import com.google.common.base.Splitter;
1: 
0: import org.jboss.netty.bootstrap.ClientBootstrap;
0: import org.jboss.netty.channel.Channel;
0: import org.jboss.netty.channel.Channels;
0: import org.jboss.netty.channel.ChannelFuture;
0: import org.jboss.netty.channel.ChannelHandlerContext;
0: import org.jboss.netty.channel.ChannelPipeline;
0: import org.jboss.netty.channel.ChannelPipelineFactory;
0: import org.jboss.netty.channel.MessageEvent;
0: import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
0: import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
0: import org.jboss.netty.logging.InternalLoggerFactory;
0: import org.jboss.netty.logging.Slf4JLoggerFactory;
1: 
0: import org.apache.cassandra.transport.messages.*;
0: import org.apache.cassandra.db.marshal.*;
0: import org.apache.cassandra.service.ClientState;
0: import org.apache.cassandra.utils.SimpleCondition;
1: 
0: public class SimpleClient
1: {
1:     static
1:     {
1:         InternalLoggerFactory.setDefaultFactory(new Slf4JLoggerFactory());
1:     }
1: 
1:     public final String host;
1:     public final int port;
1: 
1:     protected final ResponseHandler responseHandler = new ResponseHandler();
0:     protected final ClientConnection connection = new ClientConnection();
1:     protected final Connection.Tracker tracker = new ConnectionTracker();
0:     protected ClientBootstrap bootstrap;
1:     protected Channel channel;
1:     protected ChannelFuture lastWriteFuture;
1: 
1:     private final Connection.Factory connectionFactory = new Connection.Factory()
1:     {
0:         public Connection newConnection()
1:         {
1:             return connection;
1:         }
1:     };
1: 
0:     public SimpleClient(String host, int port)
1:     {
0:         this.host = host;
0:         this.port = port;
1:     }
1: 
1:     public void connect(boolean useCompression) throws IOException
1:     {
1:         establishConnection();
1: 
0:         EnumMap<StartupMessage.Option, Object> options = new EnumMap<StartupMessage.Option, Object>(StartupMessage.Option.class);
1:         if (useCompression)
1:         {
0:             options.put(StartupMessage.Option.COMPRESSION, "snappy");
1:             connection.setCompressor(FrameCompressor.SnappyCompressor.instance);
1:         }
0:         execute(new StartupMessage("3.0.0", options));
1:     }
1: 
1:     protected void establishConnection() throws IOException
1:     {
1:         // Configure the client.
0:         bootstrap = new ClientBootstrap(
0:                         new NioClientSocketChannelFactory(
0:                             Executors.newCachedThreadPool(),
0:                             Executors.newCachedThreadPool()));
1: 
1:         // Configure the pipeline factory.
0:         bootstrap.setPipelineFactory(new PipelineFactory());
1:         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
1: 
1:         // Wait until the connection attempt succeeds or fails.
0:         channel = future.awaitUninterruptibly().getChannel();
1:         if (!future.isSuccess())
1:         {
0:             bootstrap.releaseExternalResources();
0:             throw new IOException("Connection Error", future.getCause());
1:         }
1:     }
1: 
1:     public void login(Map<String, String> credentials)
1:     {
1:         CredentialsMessage msg = new CredentialsMessage();
1:         msg.credentials.putAll(credentials);
1:         execute(msg);
1:     }
1: 
0:     public ResultMessage execute(String query)
1:     {
0:         Message.Response msg = execute(new QueryMessage(query));
1:         assert msg instanceof ResultMessage;
1:         return (ResultMessage)msg;
1:     }
1: 
1:     public ResultMessage.Prepared prepare(String query)
1:     {
1:         Message.Response msg = execute(new PrepareMessage(query));
1:         assert msg instanceof ResultMessage.Prepared;
1:         return (ResultMessage.Prepared)msg;
1:     }
1: 
0:     public ResultMessage executePrepared(int statementId, List<ByteBuffer> values)
1:     {
0:         Message.Response msg = execute(new ExecuteMessage(statementId, values));
1:         assert msg instanceof ResultMessage;
1:         return (ResultMessage)msg;
1:     }
1: 
1:     public void close()
1:     {
1:         // Wait until all messages are flushed before closing the channel.
1:         if (lastWriteFuture != null)
1:             lastWriteFuture.awaitUninterruptibly();
1: 
1:         // Close the connection.  Make sure the close operation ends because
1:         // all I/O operations are asynchronous in Netty.
1:         channel.close().awaitUninterruptibly();
1: 
1:         // Shut down all thread pools to exit.
0:         bootstrap.releaseExternalResources();
1:     }
1: 
0:     protected Message.Response execute(Message.Request request)
1:     {
1:         try
1:         {
1:             request.attach(connection);
0:             lastWriteFuture = channel.write(request);
1:             Message.Response msg = responseHandler.responses.take();
1:             if (msg instanceof ErrorMessage)
0:                 throw new RuntimeException(((ErrorMessage)msg).errorMsg);
1:             return msg;
1:         }
1:         catch (InterruptedException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:     protected static class ClientConnection extends Connection
1:     {
0:         public ClientState clientState()
1:         {
0:             return null;
1:         }
1: 
0:         public void validateNewMessage(Message.Type type) {}
1: 
0:         public void applyStateTransition(Message.Type requestType, Message.Type responseType) {}
1:     }
1: 
1:     // Stateless handlers
1:     private static final Message.ProtocolDecoder messageDecoder = new Message.ProtocolDecoder();
1:     private static final Message.ProtocolEncoder messageEncoder = new Message.ProtocolEncoder();
1:     private static final Frame.Decompressor frameDecompressor = new Frame.Decompressor();
1:     private static final Frame.Compressor frameCompressor = new Frame.Compressor();
1:     private static final Frame.Encoder frameEncoder = new Frame.Encoder();
1: 
1:     private static class ConnectionTracker implements Connection.Tracker
1:     {
1:         public void addConnection(Channel ch, Connection connection) {}
0:         public void closeAll() {}
1:     }
1: 
0:     private class PipelineFactory implements ChannelPipelineFactory
1:     {
0:         public ChannelPipeline getPipeline() throws Exception
1:         {
0:             ChannelPipeline pipeline = Channels.pipeline();
1: 
0:             //pipeline.addLast("debug", new LoggingHandler());
1: 
0:             pipeline.addLast("frameDecoder", new Frame.Decoder(tracker, connectionFactory));
1:             pipeline.addLast("frameEncoder", frameEncoder);
1: 
1:             pipeline.addLast("frameDecompressor", frameDecompressor);
1:             pipeline.addLast("frameCompressor", frameCompressor);
1: 
1:             pipeline.addLast("messageDecoder", messageDecoder);
1:             pipeline.addLast("messageEncoder", messageEncoder);
1: 
1:             pipeline.addLast("handler", responseHandler);
1: 
0:             return pipeline;
1:         }
1:     }
1: 
0:     private static class ResponseHandler extends SimpleChannelUpstreamHandler
1:     {
0:         public final BlockingQueue<Message.Response> responses = new SynchronousQueue<Message.Response>(true);
1: 
1:         @Override
0:         public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
1:         {
0:             assert e.getMessage() instanceof Message.Response;
1:             try
1:             {
0:                 responses.put((Message.Response)e.getMessage());
1:             }
1:             catch (InterruptedException ie)
1:             {
1:                 throw new RuntimeException(ie);
1:             }
1:         }
1:     }
1: }
author:belliottsmith
-------------------------------------------------------------------------------
commit:cbf304e
/////////////////////////////////////////////////////////////////////////
1: import io.netty.bootstrap.Bootstrap;
1: import io.netty.channel.ChannelHandler;
1: import io.netty.channel.ChannelInitializer;
1: import io.netty.channel.ChannelOption;
1: import io.netty.channel.SimpleChannelInboundHandler;
1: import io.netty.channel.nio.NioEventLoopGroup;
0: import io.netty.channel.socket.nio.NioServerSocketChannel;
1: import io.netty.util.internal.logging.InternalLoggerFactory;
1: import io.netty.util.internal.logging.Slf4JLoggerFactory;
/////////////////////////////////////////////////////////////////////////
1: import io.netty.channel.Channel;
1: import io.netty.channel.ChannelFuture;
1: import io.netty.channel.ChannelHandlerContext;
1: import io.netty.channel.ChannelPipeline;
1: import io.netty.handler.ssl.SslHandler;
/////////////////////////////////////////////////////////////////////////
1:     protected Bootstrap bootstrap;
/////////////////////////////////////////////////////////////////////////
1:         bootstrap = new Bootstrap()
1:                     .group(new NioEventLoopGroup())
1:                     .channel(io.netty.channel.socket.nio.NioSocketChannel.class)
1:                     .option(ChannelOption.TCP_NODELAY, true);
1:             bootstrap.handler(new SecureInitializer());
1:             bootstrap.handler(new Initializer());
1:         channel = future.awaitUninterruptibly().channel();
1:             bootstrap.group().shutdownGracefully();
1:             throw new IOException("Connection Error", future.cause());
/////////////////////////////////////////////////////////////////////////
1:         bootstrap.group().shutdownGracefully();
/////////////////////////////////////////////////////////////////////////
1:             lastWriteFuture = channel.writeAndFlush(request);
/////////////////////////////////////////////////////////////////////////
1:     private class Initializer extends ChannelInitializer<Channel>
1:         protected void initChannel(Channel channel) throws Exception
1:             ChannelPipeline pipeline = channel.pipeline();
/////////////////////////////////////////////////////////////////////////
1:     private class SecureInitializer extends Initializer
1:         public SecureInitializer() throws IOException
1:         protected void initChannel(Channel channel) throws Exception
1:             super.initChannel(channel);
1:             channel.pipeline().addFirst("ssl", new SslHandler(sslEngine));
1:     @ChannelHandler.Sharable
1:     private static class ResponseHandler extends SimpleChannelInboundHandler<Message.Response>
1:         public void channelRead0(ChannelHandlerContext ctx, Message.Response r)
0:                 responses.put(r);
/////////////////////////////////////////////////////////////////////////
1:         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
1:             if (this == ctx.pipeline().last())
1:                 logger.error("Exception in response", cause);
1:             ctx.fireExceptionCaught(cause);
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:df723af
/////////////////////////////////////////////////////////////////////////
1:     public ResultMessage execute(String query, List<ByteBuffer> values, ConsistencyLevel consistencyLevel)
0:     {
0:         Message.Response msg = execute(new QueryMessage(query, values, consistencyLevel));
0:         assert msg instanceof ResultMessage;
0:         return (ResultMessage)msg;
0:     }
0: 
============================================================================