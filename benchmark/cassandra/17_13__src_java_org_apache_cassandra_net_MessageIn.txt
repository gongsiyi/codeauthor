1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:066ef58:  */
1:066ef58: package org.apache.cassandra.net;
1:557bbbc: 
1:a06be23: import java.io.IOException;
1:b767bf7: import java.net.InetAddress;
1:a06be23: import java.util.Collections;
1:a06be23: import java.util.Map;
1:7e1adb4: 
1:a06be23: import com.google.common.collect.ImmutableMap;
1:8b0e186: 
1:52b6edc: import org.apache.cassandra.concurrent.Stage;
1:e6610e4: import org.apache.cassandra.config.DatabaseDescriptor;
1:9d9a1a1: import org.apache.cassandra.db.monitoring.ApproximateTime;
1:39df31a: import org.apache.cassandra.exceptions.RequestFailureReason;
1:a06be23: import org.apache.cassandra.io.IVersionedSerializer;
1:39df31a: import org.apache.cassandra.io.util.DataInputBuffer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:8b0e186: 
1:a06be23: public class MessageIn<T>
1:5f474da: {
1:a06be23:     public final InetAddress from;
1:a06be23:     public final T payload;
1:a06be23:     public final Map<String, byte[]> parameters;
1:a06be23:     public final MessagingService.Verb verb;
1:a06be23:     public final int version;
1:9d9a1a1:     public final long constructionTime;
1:7e1adb4: 
1:557bbbc:     private MessageIn(InetAddress from,
1:557bbbc:                       T payload,
1:557bbbc:                       Map<String, byte[]> parameters,
1:557bbbc:                       MessagingService.Verb verb,
1:557bbbc:                       int version,
1:9d9a1a1:                       long constructionTime)
1:5f474da:     {
1:a06be23:         this.from = from;
1:a06be23:         this.payload = payload;
1:a06be23:         this.parameters = parameters;
1:a06be23:         this.verb = verb;
1:6ab2b23:         this.version = version;
1:557bbbc:         this.constructionTime = constructionTime;
1:a06be23:     }
1:07cdfd0: 
1:557bbbc:     public static <T> MessageIn<T> create(InetAddress from,
1:557bbbc:                                           T payload,
1:557bbbc:                                           Map<String, byte[]> parameters,
1:557bbbc:                                           MessagingService.Verb verb,
1:557bbbc:                                           int version,
1:9d9a1a1:                                           long constructionTime)
1:04afa2b:     {
1:557bbbc:         return new MessageIn<>(from, payload, parameters, verb, version, constructionTime);
1:07cdfd0:     }
1:07cdfd0: 
1:9d9a1a1:     public static <T> MessageIn<T> create(InetAddress from,
1:9d9a1a1:                                           T payload,
1:9d9a1a1:                                           Map<String, byte[]> parameters,
1:9d9a1a1:                                           MessagingService.Verb verb,
1:9d9a1a1:                                           int version)
1:7e1adb4:     {
1:9d9a1a1:         return new MessageIn<>(from, payload, parameters, verb, version, ApproximateTime.currentTimeMillis());
1:2fd3268:     }
1:07cdfd0: 
1:9d9a1a1:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id) throws IOException
1:9d9a1a1:     {
1:9d9a1a1:         return read(in, version, id, ApproximateTime.currentTimeMillis());
1:9d9a1a1:     }
1:9d9a1a1: 
1:9d9a1a1:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id, long constructionTime) throws IOException
1:557bbbc:     {
1:a06be23:         InetAddress from = CompactEndpointSerializationHelper.deserialize(in);
1:07cdfd0: 
1:dc9ed46:         MessagingService.Verb verb = MessagingService.verbValues[in.readInt()];
1:a06be23:         int parameterCount = in.readInt();
1:a06be23:         Map<String, byte[]> parameters;
1:a06be23:         if (parameterCount == 0)
1:a06be23:         {
1:a06be23:             parameters = Collections.emptyMap();
1:04afa2b:         }
1:557bbbc:         else
1:a06be23:         {
1:a06be23:             ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();
1:a06be23:             for (int i = 0; i < parameterCount; i++)
1:a06be23:             {
1:a06be23:                 String key = in.readUTF();
1:a06be23:                 byte[] value = new byte[in.readInt()];
1:a06be23:                 in.readFully(value);
1:a06be23:                 builder.put(key, value);
1:557bbbc:             }
1:a06be23:             parameters = builder.build();
1:a06be23:         }
1:07cdfd0: 
1:a06be23:         int payloadSize = in.readInt();
1:a06be23:         IVersionedSerializer<T2> serializer = (IVersionedSerializer<T2>) MessagingService.verbSerializers.get(verb);
1:a06be23:         if (serializer instanceof MessagingService.CallbackDeterminedSerializer)
1:a06be23:         {
1:a06be23:             CallbackInfo callback = MessagingService.instance().getRegisteredCallback(id);
1:a06be23:             if (callback == null)
1:a06be23:             {
1:a06be23:                 // reply for expired callback.  we'll have to skip it.
1:ff27eb3:                 in.skipBytesFully(payloadSize);
1:a06be23:                 return null;
1:a06be23:             }
1:a06be23:             serializer = (IVersionedSerializer<T2>) callback.serializer;
1:a06be23:         }
1:f81cc74:         if (payloadSize == 0 || serializer == null)
1:557bbbc:             return create(from, null, parameters, verb, version, constructionTime);
1:2fd3268: 
1:a06be23:         T2 payload = serializer.deserialize(in, version);
1:557bbbc:         return MessageIn.create(from, payload, parameters, verb, version, constructionTime);
1:557bbbc:     }
1:2fd3268: 
1:9d9a1a1:     public static long readConstructionTime(InetAddress from, DataInputPlus input) throws IOException
1:557bbbc:     {
1:9d9a1a1:         long currentTime = ApproximateTime.currentTimeMillis();
1:9d9a1a1: 
1:9d9a1a1:         // Reconstruct the message construction time sent by the remote host (we sent only the lower 4 bytes, assuming the
1:9d9a1a1:         // higher 4 bytes wouldn't change between the sender and receiver)
1:9d9a1a1:         int partial = input.readInt(); // make sure to readInt, even if cross_node_to is not enabled
1:9d9a1a1:         long sentConstructionTime = (currentTime & 0xFFFFFFFF00000000L) | (((partial & 0xFFFFFFFFL) << 2) >> 2);
1:9d9a1a1: 
1:9d9a1a1:         // Because nodes may not have their clock perfectly in sync, it's actually possible the sentConstructionTime is
1:9d9a1a1:         // later than the currentTime (the received time). If that's the case, as we definitively know there is a lack
1:9d9a1a1:         // of proper synchronziation of the clock, we ignore sentConstructionTime. We also ignore that
1:9d9a1a1:         // sentConstructionTime if we're told to.
1:9d9a1a1:         long elapsed = currentTime - sentConstructionTime;
1:9d9a1a1:         if (elapsed > 0)
1:9d9a1a1:             MessagingService.instance().metrics.addTimeTaken(from, elapsed);
1:9d9a1a1: 
1:9d9a1a1:         boolean useSentTime = DatabaseDescriptor.hasCrossNodeTimeout() && elapsed > 0;
1:9d9a1a1:         return useSentTime ? sentConstructionTime : currentTime;
1:557bbbc:     }
1:2fd3268: 
1:9d9a1a1:     /**
1:9d9a1a1:      * Since how long (in milliseconds) the message has lived.
1:9d9a1a1:      */
1:9d9a1a1:     public long getLifetimeInMS()
1:557bbbc:     {
1:9d9a1a1:         return ApproximateTime.currentTimeMillis() - constructionTime;
1:9d9a1a1:     }
1:9d9a1a1: 
1:9d9a1a1:     /**
1:9d9a1a1:      * Whether the message has crossed the node boundary, that is whether it originated from another node.
1:9d9a1a1:      *
1:9d9a1a1:      */
1:9d9a1a1:     public boolean isCrossNode()
1:9d9a1a1:     {
1:9d9a1a1:         return !from.equals(DatabaseDescriptor.getBroadcastAddress());
1:557bbbc:     }
1:2fd3268: 
1:52b6edc:     public Stage getMessageType()
1:557bbbc:     {
1:a06be23:         return MessagingService.verbStages.get(verb);
1:557bbbc:     }
1:2fd3268: 
1:7e1adb4:     public boolean doCallbackOnFailure()
1:557bbbc:     {
1:7e1adb4:         return parameters.containsKey(MessagingService.FAILURE_CALLBACK_PARAM);
1:7e1adb4:     }
1:557bbbc: 
1:7e1adb4:     public boolean isFailureResponse()
1:7e1adb4:     {
1:7e1adb4:         return parameters.containsKey(MessagingService.FAILURE_RESPONSE_PARAM);
1:7e1adb4:     }
1:557bbbc: 
1:39df31a:     public boolean containsFailureReason()
1:39df31a:     {
1:39df31a:         return parameters.containsKey(MessagingService.FAILURE_REASON_PARAM);
1:39df31a:     }
1:39df31a: 
1:39df31a:     public RequestFailureReason getFailureReason()
1:39df31a:     {
1:39df31a:         if (containsFailureReason())
1:39df31a:         {
1:39df31a:             try (DataInputBuffer in = new DataInputBuffer(parameters.get(MessagingService.FAILURE_REASON_PARAM)))
1:39df31a:             {
1:39df31a:                 return RequestFailureReason.fromCode(in.readUnsignedShort());
1:39df31a:             }
1:39df31a:             catch (IOException ex)
1:39df31a:             {
1:39df31a:                 throw new RuntimeException(ex);
1:39df31a:             }
1:39df31a:         }
1:39df31a:         else
1:39df31a:         {
1:39df31a:             return RequestFailureReason.UNKNOWN;
1:39df31a:         }
1:39df31a:     }
1:39df31a: 
1:e6610e4:     public long getTimeout()
1:e6610e4:     {
1:9797511:         return verb.getTimeout();
1:e6610e4:     }
1:557bbbc: 
1:6966fcd:     public long getSlowQueryTimeout()
1:6966fcd:     {
1:6966fcd:         return DatabaseDescriptor.getSlowQueryTimeout();
1:6966fcd:     }
1:6966fcd: 
1:066ef58:     public String toString()
1:7d567af:     {
1:5c5fdd4:         StringBuilder sbuf = new StringBuilder();
1:f81cc74:         sbuf.append("FROM:").append(from).append(" TYPE:").append(getMessageType()).append(" VERB:").append(verb);
1:066ef58:         return sbuf.toString();
1:a06be23:     }
2:5f474da: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9d9a1a1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.monitoring.ApproximateTime;
/////////////////////////////////////////////////////////////////////////
1:     public final long constructionTime;
1:                       long constructionTime)
/////////////////////////////////////////////////////////////////////////
1:                                           long constructionTime)
1:     public static <T> MessageIn<T> create(InetAddress from,
1:                                           T payload,
1:                                           Map<String, byte[]> parameters,
1:                                           MessagingService.Verb verb,
1:                                           int version)
1:         return new MessageIn<>(from, payload, parameters, verb, version, ApproximateTime.currentTimeMillis());
1:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id) throws IOException
1:     {
1:         return read(in, version, id, ApproximateTime.currentTimeMillis());
1:     }
1: 
1:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id, long constructionTime) throws IOException
/////////////////////////////////////////////////////////////////////////
1:     public static long readConstructionTime(InetAddress from, DataInputPlus input) throws IOException
1:         long currentTime = ApproximateTime.currentTimeMillis();
1: 
1:         // Reconstruct the message construction time sent by the remote host (we sent only the lower 4 bytes, assuming the
1:         // higher 4 bytes wouldn't change between the sender and receiver)
1:         int partial = input.readInt(); // make sure to readInt, even if cross_node_to is not enabled
1:         long sentConstructionTime = (currentTime & 0xFFFFFFFF00000000L) | (((partial & 0xFFFFFFFFL) << 2) >> 2);
1: 
1:         // Because nodes may not have their clock perfectly in sync, it's actually possible the sentConstructionTime is
1:         // later than the currentTime (the received time). If that's the case, as we definitively know there is a lack
1:         // of proper synchronziation of the clock, we ignore sentConstructionTime. We also ignore that
1:         // sentConstructionTime if we're told to.
1:         long elapsed = currentTime - sentConstructionTime;
1:         if (elapsed > 0)
1:             MessagingService.instance().metrics.addTimeTaken(from, elapsed);
1: 
1:         boolean useSentTime = DatabaseDescriptor.hasCrossNodeTimeout() && elapsed > 0;
1:         return useSentTime ? sentConstructionTime : currentTime;
1:     /**
1:      * Since how long (in milliseconds) the message has lived.
1:      */
1:     public long getLifetimeInMS()
1:         return ApproximateTime.currentTimeMillis() - constructionTime;
1:     }
1: 
1:     /**
1:      * Whether the message has crossed the node boundary, that is whether it originated from another node.
1:      *
1:      */
1:     public boolean isCrossNode()
1:     {
1:         return !from.equals(DatabaseDescriptor.getBroadcastAddress());
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:686139a
/////////////////////////////////////////////////////////////////////////
0:             .append(separator)
0:             .append("TYPE:" + getMessageType())
0:             .append(separator)
0:             .append("VERB:" + getVerb())
0:             .append(separator);
commit:910b663
/////////////////////////////////////////////////////////////////////////
0:     final Header header;
0:     private final byte[] body;
/////////////////////////////////////////////////////////////////////////
0:         this.header = header;
0:         this.body = body;
/////////////////////////////////////////////////////////////////////////
0:         return header.getDetail(key);
0:         return new Message(header.withDetailsAdded(key, value), body, version);
0:         return new Message(header.withDetailsRemoved(key), body, version);
0:         return body;
/////////////////////////////////////////////////////////////////////////
0:         return header.getFrom();
/////////////////////////////////////////////////////////////////////////
0:         return header.getVerb();
commit:b1e6799
/////////////////////////////////////////////////////////////////////////
0:     public Message withHeaderAdded(String key, byte[] value)
0:         return new Message(header_.withDetailsAdded(key, value), body_, version);
0:     public Message withHeaderRemoved(String key)
0:         return new Message(header_.withDetailsRemoved(key), body_, version);
author:Geoffrey Yu
-------------------------------------------------------------------------------
commit:39df31a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.RequestFailureReason;
1: import org.apache.cassandra.io.util.DataInputBuffer;
/////////////////////////////////////////////////////////////////////////
1:     public boolean containsFailureReason()
1:     {
1:         return parameters.containsKey(MessagingService.FAILURE_REASON_PARAM);
1:     }
1: 
1:     public RequestFailureReason getFailureReason()
1:     {
1:         if (containsFailureReason())
1:         {
1:             try (DataInputBuffer in = new DataInputBuffer(parameters.get(MessagingService.FAILURE_REASON_PARAM)))
1:             {
1:                 return RequestFailureReason.fromCode(in.readUnsignedShort());
1:             }
1:             catch (IOException ex)
1:             {
1:                 throw new RuntimeException(ex);
1:             }
1:         }
1:         else
1:         {
1:             return RequestFailureReason.UNKNOWN;
1:         }
1:     }
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1:         return verb.getTimeout();
author:Shogo Hoshii
-------------------------------------------------------------------------------
commit:6966fcd
/////////////////////////////////////////////////////////////////////////
1:     public long getSlowQueryTimeout()
1:     {
1:         return DatabaseDescriptor.getSlowQueryTimeout();
1:     }
1: 
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1:         MessagingService.Verb verb = MessagingService.verbValues[in.readInt()];
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:5c5fdd4
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder sbuf = new StringBuilder();
author:Chris Lohfink
-------------------------------------------------------------------------------
commit:04afa2b
/////////////////////////////////////////////////////////////////////////
0:     public static ConstructionTime readTimestamp(InetAddress from, DataInputPlus input, long timestamp) throws IOException
0:         long crossNodeTimestamp = (timestamp & 0xFFFFFFFF00000000L) | (((partial & 0xFFFFFFFFL) << 2) >> 2);
0:         if (timestamp > crossNodeTimestamp)
1:         {
0:             MessagingService.instance().metrics.addTimeTaken(from, timestamp - crossNodeTimestamp);
1:         }
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.monitoring.ConstructionTime;
0: import org.apache.cassandra.db.monitoring.MonitorableImpl;
0:     public final ConstructionTime constructionTime;
1:     private MessageIn(InetAddress from,
1:                       T payload,
1:                       Map<String, byte[]> parameters,
1:                       MessagingService.Verb verb,
1:                       int version,
0:                       ConstructionTime constructionTime)
1:         this.constructionTime = constructionTime;
1:     public static <T> MessageIn<T> create(InetAddress from,
1:                                           T payload,
1:                                           Map<String, byte[]> parameters,
1:                                           MessagingService.Verb verb,
1:                                           int version,
0:                                           ConstructionTime constructionTime)
1:         return new MessageIn<>(from, payload, parameters, verb, version, constructionTime);
0:         return read(in, version, id, new ConstructionTime());
1:     }
1: 
0:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id, ConstructionTime constructionTime) throws IOException
1:     {
/////////////////////////////////////////////////////////////////////////
1:             return create(from, null, parameters, verb, version, constructionTime);
1: 
1:         return MessageIn.create(from, payload, parameters, verb, version, constructionTime);
1:     }
1: 
0:     public static ConstructionTime createTimestamp()
1:     {
0:         return new ConstructionTime();
1:     }
1: 
0:     public static ConstructionTime readTimestamp(DataInputPlus input) throws IOException
1:     {
0:         // make sure to readInt, even if cross_node_to is not enabled
0:         int partial = input.readInt();
0:         if(DatabaseDescriptor.hasCrossNodeTimeout())
1:         {
0:             long timestamp = System.currentTimeMillis();
0:             long crossNodeTimestamp = (timestamp & 0xFFFFFFFF00000000L) | (((partial & 0xFFFFFFFFL) << 2) >> 2);
0:             return new ConstructionTime(crossNodeTimestamp, timestamp != crossNodeTimestamp);
1:         }
1:         else
1:         {
0:             return new ConstructionTime();
1:         }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ff27eb3
/////////////////////////////////////////////////////////////////////////
1:                 in.skipBytesFully(payloadSize);
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:     public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id) throws IOException
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:7e1adb4
/////////////////////////////////////////////////////////////////////////
1:     public boolean doCallbackOnFailure()
1:     {
1:         return parameters.containsKey(MessagingService.FAILURE_CALLBACK_PARAM);
1:     }
1: 
1:     public boolean isFailureResponse()
1:     {
1:         return parameters.containsKey(MessagingService.FAILURE_RESPONSE_PARAM);
1:     }
1: 
commit:f81cc74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (payloadSize == 0 || serializer == null)
0:             return create(from, null, parameters, verb, version);
/////////////////////////////////////////////////////////////////////////
1:         sbuf.append("FROM:").append(from).append(" TYPE:").append(getMessageType()).append(" VERB:").append(verb);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:8b0e186
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(MessageIn.class);
1: 
commit:1936648
/////////////////////////////////////////////////////////////////////////
0:     public static <T2> MessageIn<T2> read(DataInput in, int version, int id) throws IOException
commit:e6610e4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     public long getTimeout()
1:     {
0:         return DatabaseDescriptor.getTimeout(verb);
1:     }
0: 
commit:0334861
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.FileUtils;
/////////////////////////////////////////////////////////////////////////
0:                 FileUtils.skipBytesFully(in, payloadSize);
commit:a06be23
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
1: import java.io.IOException;
1: import java.util.Collections;
1: import java.util.Map;
0: 
1: import com.google.common.collect.ImmutableMap;
1: import org.apache.cassandra.io.IVersionedSerializer;
1: public class MessageIn<T>
1:     public final InetAddress from;
1:     public final T payload;
1:     public final Map<String, byte[]> parameters;
1:     public final MessagingService.Verb verb;
1:     public final int version;
0:     private MessageIn(InetAddress from, T payload, Map<String, byte[]> parameters, MessagingService.Verb verb, int version)
1:         this.from = from;
1:         this.payload = payload;
1:         this.parameters = parameters;
1:         this.verb = verb;
0:     public static <T> MessageIn<T> create(InetAddress from, T payload, Map<String, byte[]> parameters, MessagingService.Verb verb, int version)
0:         return new MessageIn<T>(from, payload, parameters, verb, version);
0:     public static <T2> MessageIn<T2> read(DataInput in, int version, String id) throws IOException
1:         InetAddress from = CompactEndpointSerializationHelper.deserialize(in);
0:         MessagingService.Verb verb = MessagingService.Verb.values()[in.readInt()];
1:         int parameterCount = in.readInt();
1:         Map<String, byte[]> parameters;
1:         if (parameterCount == 0)
1:         {
1:             parameters = Collections.emptyMap();
1:         }
0:         else
1:         {
1:             ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();
1:             for (int i = 0; i < parameterCount; i++)
1:             {
1:                 String key = in.readUTF();
1:                 byte[] value = new byte[in.readInt()];
1:                 in.readFully(value);
1:                 builder.put(key, value);
1:             }
1:             parameters = builder.build();
1:         }
1:         int payloadSize = in.readInt();
0:         if (payloadSize == 0)
0:             return create(from, null, parameters, verb, version);
1:         IVersionedSerializer<T2> serializer = (IVersionedSerializer<T2>) MessagingService.verbSerializers.get(verb);
1:         if (serializer instanceof MessagingService.CallbackDeterminedSerializer)
1:         {
1:             CallbackInfo callback = MessagingService.instance().getRegisteredCallback(id);
1:             if (callback == null)
1:             {
1:                 // reply for expired callback.  we'll have to skip it.
0:                 in.skipBytes(payloadSize);
1:                 return null;
1:             }
1:             serializer = (IVersionedSerializer<T2>) callback.serializer;
1:         }
1:         T2 payload = serializer.deserialize(in, version);
0:         return MessageIn.create(from, payload, parameters, verb, version);
1:         return MessagingService.verbStages.get(verb);
0:         sbuf.append("FROM:").append(from)
0:             .append(separator).append("TYPE:").append(getMessageType())
0:             .append(separator).append("VERB:").append(verb)
0:         	.append(separator);
commit:021ec71
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public MessageIn(InetAddress from, MessagingService.Verb verb, byte[] body, int version)
/////////////////////////////////////////////////////////////////////////
0:         return MessagingService.verbStages.get(getVerb());
0:     public MessagingService.Verb getVerb()
commit:5d46a01
/////////////////////////////////////////////////////////////////////////
0: public class MessageIn
0:     public MessageIn(Header header, byte[] body, int version)
/////////////////////////////////////////////////////////////////////////
0:     public MessageIn(InetAddress from, StorageService.Verb verb, byte[] body, int version)
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
commit:3ada8a5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
commit:5f474da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public long getMessageTimeout()
1:     {
0:         StorageService.Verb verb = getVerb();
0:         switch (verb)
1:         {
0:             case READ:
0:                 return DatabaseDescriptor.getReadRpcTimeout();
0:             case RANGE_SLICE:
0:                 return DatabaseDescriptor.getRangeRpcTimeout();
0:             case READ_REPAIR:
0:             case BINARY:
0:             case MUTATION:
0:                 return DatabaseDescriptor.getWriteRpcTimeout();
0:             default:
0:                 return DatabaseDescriptor.getRpcTimeout();
1:         }
1:     }
0: 
commit:c5ee059
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0:     // TODO make static
0:         Header header = new Header(from, StorageService.Verb.REQUEST_RESPONSE);
0:         Header header = new Header(FBUtilities.getLocalAddress(), StorageService.Verb.INTERNAL_RESPONSE);
/////////////////////////////////////////////////////////////////////////
0:         sbuf.append("FROM:" + getFrom())
commit:7d567af
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void removeHeader(String key)
1:     {
0:         header_.removeDetail(key);
0:     }
commit:4826e8c
/////////////////////////////////////////////////////////////////////////
0:     public byte[] getHeader(String key)
/////////////////////////////////////////////////////////////////////////
commit:365f20b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, StorageService.Verb.REQUEST_RESPONSE);
0: 
0:     public Message getInternalReply(byte[] body)
0:     {
0:         Header header = new Header(getMessageId(), FBUtilities.getLocalAddress(), StorageService.Verb.INTERNAL_RESPONSE);
0:         return new Message(header, body);
0:     }
0: 
commit:4023c3b
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     public Message(InetAddress from, StorageService.Verb verb, byte[] body)
0:         this(new Header(from, verb), body);
/////////////////////////////////////////////////////////////////////////
0:         return StorageService.verbStages.get(getVerb());
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, StorageService.Verb.READ_RESPONSE);
commit:52b6edc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.concurrent.Stage;
/////////////////////////////////////////////////////////////////////////
0:     public Message(InetAddress from, Stage messageType, StorageService.Verb verb, byte[] body)
/////////////////////////////////////////////////////////////////////////
1:     public Stage getMessageType()
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, Stage.RESPONSE, StorageService.Verb.READ_RESPONSE);
commit:8f1376b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void setHeader(String key, byte[] value)
0:         header_.setDetail(key, value);
commit:ca72d17
/////////////////////////////////////////////////////////////////////////
0:     public Message(InetAddress from, String messageType, StorageService.Verb verb, byte[] body)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public StorageService.Verb getVerb()
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, StageManager.RESPONSE_STAGE, StorageService.Verb.READ_RESPONSE);
commit:944a2a1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, StageManager.RESPONSE_STAGE, StorageService.responseVerbHandler_);
commit:2826d3a
/////////////////////////////////////////////////////////////////////////
0:     private static MessageSerializer serializer_;
0:     public static MessageSerializer serializer()
commit:6b5d8bf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.StageManager;
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(getMessageId(), from, StageManager.RESPONSE_STAGE, MessagingService.responseVerbHandler_);
commit:fc518cb
/////////////////////////////////////////////////////////////////////////
0:     // TODO should take byte[] + length so we don't have to copy to a byte[] of exactly the right len
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:     public Message(InetAddress from, String messageType, String verb, byte[] body)
/////////////////////////////////////////////////////////////////////////
0:     public InetAddress getFrom()
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(InetAddress from, byte[] args)
commit:93ad8a2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     final Header header_;
0:     private final byte[] body_;
0: 
0:     Message(Header header, byte[] body)
0:         assert header != null;
0:         assert body != null;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     {
0:         Header header = new Header(getMessageId(), from, MessagingService.responseStage_, MessagingService.responseVerbHandler_);
0:         return new Message(header, args);
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.cassandra.net;
0: 
0: import java.lang.reflect.Array;
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.util.*;
0: 
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.log4j.Logger;
0: import org.apache.cassandra.utils.*;
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
1:  */
0: 
0: public class Message implements java.io.Serializable
0: {    
0:     static final long serialVersionUID = 6329198792470413221L;
0:     private static ICompactSerializer<Message> serializer_;
0:     
0:     static
0:     {
0:         serializer_ = new MessageSerializer();        
0:     }
0:     
0:     public static ICompactSerializer<Message> serializer()
0:     {
0:         return serializer_;
0:     }
0:     
0:     Header header_;
0:     private byte[] body_;
0:     
0:     protected Message(String id, EndPoint from, String messageType, String verb, byte[] body)
0:     {
0:         this(new Header(id, from, messageType, verb), body);
0:     }
0:     
0:     protected Message(Header header, byte[] body)
0:     {
0:         header_ = header;
0:         body_ = body;
0:     }
0: 
0:     public Message(EndPoint from, String messageType, String verb, byte[] body)
0:     {
0:         this(new Header(from, messageType, verb), body);
0:     }    
0:     
0:     public byte[] getHeader(Object key)
0:     {
0:         return header_.getDetail(key);
0:     }
0:     
0:     public void removeHeader(Object key)
0:     {
0:         header_.removeDetail(key);
0:     }
0:     
0:     public void setMessageType(String type)
0:     {
0:         header_.setMessageType(type);
0:     }
0: 
0:     public void setMessageVerb(String verb)
0:     {
0:         header_.setMessageVerb(verb);
0:     }
0: 
0:     public void addHeader(String key, byte[] value)
0:     {
0:         header_.addDetail(key, value);
0:     }
0:     
0:     public Map<String, byte[]> getHeaders()
0:     {
0:         return header_.getDetails();
0:     }
0: 
0:     public byte[] getMessageBody()
0:     {
0:         return body_;
0:     }
0:     
0:     public void setMessageBody(byte[] body)
0:     {
0:         body_ = body;
0:     }
0: 
0:     public EndPoint getFrom()
0:     {
0:         return header_.getFrom();
0:     }
0: 
0:     public String getMessageType()
0:     {
0:         return header_.getMessageType();
0:     }
0: 
0:     public String getVerb()
0:     {
0:         return header_.getVerb();
0:     }
0: 
0:     public String getMessageId()
0:     {
0:         return header_.getMessageId();
0:     }
0: 
0:     void setMessageId(String id)
0:     {
0:         header_.setMessageId(id);
0:     }    
0: 
0:     public Message getReply(EndPoint from, byte[] args)
0:     {        
0:         Message response = new Message(getMessageId(),
0:                                        from,
0:                                        MessagingService.responseStage_,
0:                                        MessagingService.responseVerbHandler_,
0:                                        args);
0:         return response;
0:     }
0:     
1:     public String toString()
0:     {
0:         StringBuilder sbuf = new StringBuilder("");
0:         String separator = System.getProperty("line.separator");
0:         sbuf.append("ID:" + getMessageId())
0:         	.append(separator)
0:         	.append("FROM:" + getFrom())
0:         	.append(separator)
0:         	.append("TYPE:" + getMessageType())
0:         	.append(separator)
0:         	.append("VERB:" + getVerb())
0:         	.append(separator);
1:         return sbuf.toString();
0:     }
0: }
0: 
0: class MessageSerializer implements ICompactSerializer<Message>
0: {
0:     public void serialize(Message t, DataOutputStream dos) throws IOException
0:     {
0:         Header.serializer().serialize( t.header_, dos);
0:         byte[] bytes = t.getMessageBody();
0:         dos.writeInt(bytes.length);
0:         dos.write(bytes);
0:     }
0: 
0:     public Message deserialize(DataInputStream dis) throws IOException
0:     {
0:         Header header = Header.serializer().deserialize(dis);
0:         int size = dis.readInt();
0:         byte[] bytes = new byte[size];
0:         dis.readFully(bytes);
0:         // return new Message(header.getMessageId(), header.getFrom(), header.getMessageType(), header.getVerb(), new Object[]{bytes});
0:         return new Message(header, bytes);
0:     }
0: }
commit:0172497
/////////////////////////////////////////////////////////////////////////
0:         StringBuilder sbuf = new StringBuilder("");
0:         sbuf.append("ID:" + getMessageId())
0:         	.append(separator)
0:         	.append("FROM:" + getFrom())
0:         	.append(separator)
0:         	.append("TYPE:" + getMessageType())
0:         	.append(separator)
0:         	.append("VERB:" + getVerb())
0:         	.append(separator);
commit:49211d5
/////////////////////////////////////////////////////////////////////////
0:     private byte[] body_;
0:     protected Message(String id, EndPoint from, String messageType, String verb, byte[] body)
0:     protected Message(Header header, byte[] body)
0:     public Message(EndPoint from, String messageType, String verb, byte[] body)
/////////////////////////////////////////////////////////////////////////
0:     public byte[] getMessageBody()
0:     public void setMessageBody(byte[] body)
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(EndPoint from, byte[] args)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         byte[] bytes = t.getMessageBody();
/////////////////////////////////////////////////////////////////////////
0:         return new Message(header, bytes);
commit:71739ef
commit:4cb9bf6
/////////////////////////////////////////////////////////////////////////
0:     protected Message(String id, EndPoint from, String messageType, String verb, Object... body)
0:         this(new Header(id, from, messageType, verb), body);
0:     protected Message(Header header, Object... body)
0:     public Message(EndPoint from, String messageType, String verb, Object... body)
0:         this(new Header(from, messageType, verb), body);
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(EndPoint from, Object... args)
commit:fe82573
/////////////////////////////////////////////////////////////////////////
0:     protected Message(String id, EndPoint from, String messageType, String verb, Object... body)
0:         this(new Header(id, from, messageType, verb), body);
0:     protected Message(Header header, Object... body)
0:     public Message(EndPoint from, String messageType, String verb, Object... body)
0:         this(new Header(from, messageType, verb), body);
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(EndPoint from, Object... args)
author:Brandon Williams
-------------------------------------------------------------------------------
commit:cd86121
/////////////////////////////////////////////////////////////////////////
0:     public Message(Header header, byte[] body, int version)
commit:c715b6d
/////////////////////////////////////////////////////////////////////////
0:     Message(Header header, byte[] body, int version)
/////////////////////////////////////////////////////////////////////////
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:         Header header = new Header(FBUtilities.getBroadcastAddress(), StorageService.Verb.INTERNAL_RESPONSE);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(Message t, DataOutputStream dos, int version) throws IOException
0:             assert t.getVersion() == version : "internode protocol version mismatch"; // indicates programmer error.
0:             Header.serializer().serialize( t.header_, dos, version);
0:         public Message deserialize(DataInputStream dis, int version) throws IOException
0:             Header header = Header.serializer().deserialize(dis, version);
0:             return new Message(header, bytes, version);
commit:5d02c51
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Message(InetAddress from, StorageService.Verb verb, byte[] body, int version)
0:         this(new Header(from, verb), body, version);
0:     } 
0:     
0:     public void setId(String messageId)
0:     {
0:         header_.setMessageId(messageId);
0:     }
commit:6ab2b23
/////////////////////////////////////////////////////////////////////////
0:     public static final int UNKNOWN = -1;
/////////////////////////////////////////////////////////////////////////
0:     private final transient int version;
0:     private Message(Header header, byte[] body, int version)
1:         this.version = version;
0:         this(new Header(from, verb), body, UNKNOWN);
/////////////////////////////////////////////////////////////////////////
0:     
0:     public int getVersion()
0:     {
0:         return version;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(InetAddress from, byte[] body, int version)
0:         return new Message(header, body, version);
0:     public Message getInternalReply(byte[] body, int version)
0:         return new Message(header, body, version);
/////////////////////////////////////////////////////////////////////////
0:             return new Message(header, bytes, UNKNOWN);
commit:434636a
/////////////////////////////////////////////////////////////////////////
0:     private static ICompactSerializer<Message> serializer_;
0:     public static ICompactSerializer<Message> serializer()
/////////////////////////////////////////////////////////////////////////
0:     
0:     private static class MessageSerializer implements ICompactSerializer<Message>
0:         public void serialize(Message t, DataOutputStream dos) throws IOException
0:         {
0:             Header.serializer().serialize( t.header_, dos);
0:             byte[] bytes = t.getMessageBody();
0:             dos.writeInt(bytes.length);
0:             dos.write(bytes);
0:         }
0:     
0:         public Message deserialize(DataInputStream dis) throws IOException
0:         {
0:             Header header = Header.serializer().deserialize(dis);
0:             int size = dis.readInt();
0:             byte[] bytes = new byte[size];
0:             dis.readFully(bytes);
0:             // return new Message(header.getMessageId(), header.getFrom(), header.getMessageType(), header.getVerb(), new Object[]{bytes});
0:             return new Message(header, bytes);
0:         }
author:Eric Evans
-------------------------------------------------------------------------------
commit:325a7c1
/////////////////////////////////////////////////////////////////////////
0: public class Message
0: {
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:bd884e4
/////////////////////////////////////////////////////////////////////////
0:     /* Ctor for JAXB. DO NOT DELETE */
0:     private Message()
0:     }
0: 
0:     protected Message(String id, EndPoint from, String messageType, String verb, Object[] body)
0:     {
0:         header_ = new Header(id, from, messageType, verb);
0:         body_ = body;
0:     protected Message(Header header, Object[] body)
0:     public Message(EndPoint from, String messageType, String verb, Object[] body)
0:         header_ = new Header(from, messageType, verb);
0:         body_ = body;
/////////////////////////////////////////////////////////////////////////
0:     public Message getReply(EndPoint from, Object[] args)
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.net;
0: 
0: import java.lang.reflect.Array;
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.util.*;
0: 
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.log4j.Logger;
0: import org.apache.cassandra.utils.*;
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class Message implements java.io.Serializable
0: {    
0:     static final long serialVersionUID = 6329198792470413221L;
0:     private static ICompactSerializer<Message> serializer_;
0:     
0:     static
0:     {
0:         serializer_ = new MessageSerializer();        
0:     }
0:     
0:     public static ICompactSerializer<Message> serializer()
0:     {
0:         return serializer_;
0:     }
0:     
0:     Header header_;
0:     private Object[] body_ = new Object[0];
0:     
0:     /* Ctor for JAXB. DO NOT DELETE */
0:     private Message()
0:     {
0:     }
0: 
0:     protected Message(String id, EndPoint from, String messageType, String verb, Object[] body)
0:     {
0:         header_ = new Header(id, from, messageType, verb);
0:         body_ = body;
0:     }
0:     
0:     protected Message(Header header, Object[] body)
0:     {
0:         header_ = header;
0:         body_ = body;
0:     }
0: 
0:     public Message(EndPoint from, String messageType, String verb, Object[] body)
0:     {
0:         header_ = new Header(from, messageType, verb);
0:         body_ = body;
0:     }    
0:     
0:     public byte[] getHeader(Object key)
0:     {
0:         return header_.getDetail(key);
0:     }
0:     
0:     public void removeHeader(Object key)
0:     {
0:         header_.removeDetail(key);
0:     }
0:     
0:     public void setMessageType(String type)
0:     {
0:         header_.setMessageType(type);
0:     }
0: 
0:     public void setMessageVerb(String verb)
0:     {
0:         header_.setMessageVerb(verb);
0:     }
0: 
0:     public void addHeader(String key, byte[] value)
0:     {
0:         header_.addDetail(key, value);
0:     }
0:     
0:     public Map<String, byte[]> getHeaders()
0:     {
0:         return header_.getDetails();
0:     }
0: 
0:     public Object[] getMessageBody()
0:     {
0:         return body_;
0:     }
0:     
0:     public void setMessageBody(Object[] body)
0:     {
0:         body_ = body;
0:     }
0: 
0:     public EndPoint getFrom()
0:     {
0:         return header_.getFrom();
0:     }
0: 
0:     public String getMessageType()
0:     {
0:         return header_.getMessageType();
0:     }
0: 
0:     public String getVerb()
0:     {
0:         return header_.getVerb();
0:     }
0: 
0:     public String getMessageId()
0:     {
0:         return header_.getMessageId();
0:     }
0:     
0:     public Class[] getTypes()
0:     {
0:         List<Class> types = new ArrayList<Class>();
0:         
0:         for ( int i = 0; i < body_.length; ++i )
0:         {
0:             if ( body_[i].getClass().isArray() )
0:             {
0:                 int size = Array.getLength(body_[i]);
0:                 if ( size > 0 )
0:                 {
0:                     types.add( Array.get( body_[i], 0).getClass() );
0:                 }
0:             }
0:             else
0:             {
0:                 types.add(body_[i].getClass());
0:             }
0:         }
0:         
0:         return types.toArray( new Class[0] );
0:     }    
0: 
0:     void setMessageId(String id)
0:     {
0:         header_.setMessageId(id);
0:     }    
0: 
0:     public Message getReply(EndPoint from, Object[] args)
0:     {        
0:         Message response = new Message(getMessageId(),
0:                                        from,
0:                                        MessagingService.responseStage_,
0:                                        MessagingService.responseVerbHandler_,
0:                                        args);
0:         return response;
0:     }
0:     
0:     public String toString()
0:     {
0:         StringBuffer sbuf = new StringBuffer("");
0:         String separator = System.getProperty("line.separator");
0:         sbuf.append("ID:" + getMessageId());
0:         sbuf.append(separator);
0:         sbuf.append("FROM:" + getFrom());
0:         sbuf.append(separator);
0:         sbuf.append("TYPE:" + getMessageType());
0:         sbuf.append(separator);
0:         sbuf.append("VERB:" + getVerb());
0:         sbuf.append(separator);
0:         sbuf.append("BODY TYPE:" + getBodyTypes());        
0:         sbuf.append(separator);
0:         return sbuf.toString();
0:     }
0:     
0:     private String getBodyTypes()
0:     {
0:         StringBuffer sbuf = new StringBuffer("");
0:         Class[] types = getTypes();
0:         for ( int i = 0; i < types.length; ++i )
0:         {
0:             sbuf.append(types[i].getName());
0:             sbuf.append(" ");         
0:         }
0:         return sbuf.toString();
0:     }    
0: }
0: 
0: class MessageSerializer implements ICompactSerializer<Message>
0: {
0:     public void serialize(Message t, DataOutputStream dos) throws IOException
0:     {
0:         Header.serializer().serialize( t.header_, dos);
0:         byte[] bytes = (byte[])t.getMessageBody()[0];
0:         dos.writeInt(bytes.length);
0:         dos.write(bytes);
0:     }
0: 
0:     public Message deserialize(DataInputStream dis) throws IOException
0:     {
0:         Header header = Header.serializer().deserialize(dis);
0:         int size = dis.readInt();
0:         byte[] bytes = new byte[size];
0:         dis.readFully(bytes);
0:         // return new Message(header.getMessageId(), header.getFrom(), header.getMessageType(), header.getVerb(), new Object[]{bytes});
0:         return new Message(header, new Object[]{bytes});
0:     }
0: }
============================================================================