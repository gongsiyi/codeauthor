1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:a991b64: package org.apache.cassandra.db.rows;
9:a991b64: 
1:a991b64: import java.util.*;
1:a991b64: 
1:a991b64: import com.google.common.collect.Iterators;
1:2457599: import com.google.common.collect.PeekingIterator;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:a991b64: import org.apache.cassandra.db.*;
1:2457599: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
1:d40ac78: import org.apache.cassandra.db.rows.Row.Deletion;
1:aa57626: import org.apache.cassandra.utils.MergeIterator;
1:dc9ed46: import org.apache.cassandra.utils.WrappedInt;
1:a991b64: 
1:a991b64: /**
1:a991b64:  * Static utilities to work on Row objects.
1:a991b64:  */
1:a991b64: public abstract class Rows
8:a991b64: {
1:2457599:     private Rows() {}
1:2457599: 
1:e51f83b:     public static final Row EMPTY_STATIC_ROW = BTreeRow.emptyRow(Clustering.STATIC_CLUSTERING);
1:2457599: 
1:2457599:     public static Row.Builder copy(Row row, Row.Builder builder)
1:a991b64:     {
1:2457599:         builder.newRow(row.clustering());
1:2457599:         builder.addPrimaryKeyLivenessInfo(row.primaryKeyLivenessInfo());
1:2457599:         builder.addRowDeletion(row.deletion());
2:2457599:         for (ColumnData cd : row)
1:2457599:         {
1:2457599:             if (cd.column().isSimple())
1:a991b64:             {
1:2457599:                 builder.addCell((Cell)cd);
1:2457599:             }
1:2457599:             else
1:2457599:             {
1:2457599:                 ComplexColumnData complexData = (ComplexColumnData)cd;
1:2457599:                 builder.addComplexDeletion(complexData.column(), complexData.complexDeletion());
1:2457599:                 for (Cell cell : complexData)
1:2457599:                     builder.addCell(cell);
1:2457599:             }
1:2457599:         }
1:2457599:         return builder;
7:a991b64:     }
1:2457599: 
1:2457599:     /**
1:2683806:      * Creates a new simple row builder.
1:2457599:      *
1:2683806:      * @param metadata the metadata of the table this is a row of.
1:2683806:      * @param clusteringValues the value for the clustering columns of the row to add to this build. There may be no
1:2683806:      * values if either the table has no clustering column, or if you want to edit the static row. Note that as a
1:2683806:      * shortcut it is also allowed to pass a {@code Clustering} object directly, in which case that should be the
1:2683806:      * only argument.
1:2683806:      * @return a newly created builder.
1:2683806:      */
1:2683806:     public static Row.SimpleBuilder simpleBuilder(CFMetaData metadata, Object... clusteringValues)
1:2457599:     {
1:2683806:         return new SimpleBuilders.RowBuilder(metadata, clusteringValues);
1:a991b64:     }
1:a991b64: 
1:2683806:     /**
1:85cc390:      * Collect statistics on a given row.
1:2683806:      *
1:2457599:      * @param row the row for which to collect stats.
1:2457599:      * @param collector the stats collector.
1:2457599:      * @return the total number of cells in {@code row}.
1:2457599:      */
1:2457599:     public static int collectStats(Row row, PartitionStatisticsCollector collector)
1:2457599:     {
1:2457599:         assert !row.isEmpty();
1:2457599: 
1:2457599:         collector.update(row.primaryKeyLivenessInfo());
1:665f747:         collector.update(row.deletion().time());
1:2457599: 
1:dc9ed46:         //we have to wrap these for the lambda
1:dc9ed46:         final WrappedInt columnCount = new WrappedInt(0);
1:dc9ed46:         final WrappedInt cellCount = new WrappedInt(0);
1:a991b64: 
1:dc9ed46:         row.apply(cd -> {
1:2457599:             if (cd.column().isSimple())
1:2457599:             {
1:dc9ed46:                 columnCount.increment();
1:dc9ed46:                 cellCount.increment();
1:b263af9:                 Cells.collectStats((Cell) cd, collector);
1:2457599:             }
1:2457599:             else
1:2457599:             {
1:2457599:                 ComplexColumnData complexData = (ComplexColumnData)cd;
1:2457599:                 collector.update(complexData.complexDeletion());
1:2457599:                 if (complexData.hasCells())
1:2457599:                 {
1:dc9ed46:                     columnCount.increment();
1:2457599:                     for (Cell cell : complexData)
1:2457599:                     {
1:dc9ed46:                         cellCount.increment();
1:2457599:                         Cells.collectStats(cell, collector);
1:2457599:                     }
1:2457599:                 }
1:2457599:             }
1:dc9ed46:         }, false);
1:2457599: 
1:dc9ed46:         collector.updateColumnSetPerRow(columnCount.get());
1:dc9ed46:         return cellCount.get();
1:2457599:     }
1:2457599: 
1:2457599:     /**
1:2457599:      * Given the result ({@code merged}) of merging multiple {@code inputs}, signals the difference between
1:2457599:      * each input and {@code merged} to {@code diffListener}.
1:b263af9:      * <p>
1:b263af9:      * Note that this method doesn't only emit cells etc where there's a difference. The listener is informed
1:b263af9:      * of every corresponding entity between the merged and input rows, including those that are equal.
1:2457599:      *
1:b263af9:      * @param diffListener the listener to which to signal the differences between the inputs and the merged result.
1:2457599:      * @param merged the result of merging {@code inputs}.
1:2457599:      * @param inputs the inputs whose merge yielded {@code merged}.
1:2457599:      */
1:aa57626:     public static void diff(RowDiffListener diffListener, Row merged, Row...inputs)
1:a991b64:     {
1:2457599:         Clustering clustering = merged.clustering();
1:2457599:         LivenessInfo mergedInfo = merged.primaryKeyLivenessInfo().isEmpty() ? null : merged.primaryKeyLivenessInfo();
1:665f747:         Row.Deletion mergedDeletion = merged.deletion().isLive() ? null : merged.deletion();
3:2457599:         for (int i = 0; i < inputs.length; i++)
1:2457599:         {
1:2457599:             Row input = inputs[i];
1:2457599:             LivenessInfo inputInfo = input == null || input.primaryKeyLivenessInfo().isEmpty() ? null : input.primaryKeyLivenessInfo();
1:665f747:             Row.Deletion inputDeletion = input == null || input.deletion().isLive() ? null : input.deletion();
1:2457599: 
1:2457599:             if (mergedInfo != null || inputInfo != null)
1:2457599:                 diffListener.onPrimaryKeyLivenessInfo(i, clustering, mergedInfo, inputInfo);
1:2457599:             if (mergedDeletion != null || inputDeletion != null)
1:2457599:                 diffListener.onDeletion(i, clustering, mergedDeletion, inputDeletion);
1:2457599:         }
1:2457599: 
1:aa57626:         List<Iterator<ColumnData>> inputIterators = new ArrayList<>(1 + inputs.length);
1:aa57626:         inputIterators.add(merged.iterator());
1:2457599:         for (Row row : inputs)
1:aa57626:             inputIterators.add(row == null ? Collections.emptyIterator() : row.iterator());
1:2457599: 
1:aa57626:         Iterator<?> iter = MergeIterator.get(inputIterators, ColumnData.comparator, new MergeIterator.Reducer<ColumnData, Object>()
1:2457599:         {
1:aa57626:             ColumnData mergedData;
1:aa57626:             ColumnData[] inputDatas = new ColumnData[inputs.length];
1:aa57626:             public void reduce(int idx, ColumnData current)
1:2457599:             {
1:aa57626:                 if (idx == 0)
1:aa57626:                     mergedData = current;
1:aa57626:                 else
1:aa57626:                     inputDatas[idx - 1] = current;
1:2457599:             }
1:2457599: 
1:aa57626:             protected Object getReduced()
1:2457599:             {
1:aa57626:                 for (int i = 0 ; i != inputDatas.length ; i++)
1:2457599:                 {
1:aa57626:                     ColumnData input = inputDatas[i];
1:aa57626:                     if (mergedData != null || input != null)
1:a991b64:                     {
1:aa57626:                         ColumnDefinition column = (mergedData != null ? mergedData : input).column;
1:aa57626:                         if (column.isSimple())
1:a991b64:                         {
1:aa57626:                             diffListener.onCell(i, clustering, (Cell) mergedData, (Cell) input);
1:2457599:                         }
1:aa57626:                         else
1:a991b64:                         {
1:aa57626:                             ComplexColumnData mergedData = (ComplexColumnData) this.mergedData;
1:aa57626:                             ComplexColumnData inputData = (ComplexColumnData) input;
1:2457599:                             if (mergedData == null)
1:2457599:                             {
1:2457599:                                 // Everything in inputData has been shadowed
1:2457599:                                 if (!inputData.complexDeletion().isLive())
1:2457599:                                     diffListener.onComplexDeletion(i, clustering, column, null, inputData.complexDeletion());
1:2457599:                                 for (Cell inputCell : inputData)
1:2457599:                                     diffListener.onCell(i, clustering, null, inputCell);
1:2457599:                             }
1:2457599:                             else if (inputData == null)
1:2457599:                             {
1:2457599:                                 // Everything in inputData is new
1:2457599:                                 if (!mergedData.complexDeletion().isLive())
1:2457599:                                     diffListener.onComplexDeletion(i, clustering, column, mergedData.complexDeletion(), null);
1:2457599:                                 for (Cell mergedCell : mergedData)
1:2457599:                                     diffListener.onCell(i, clustering, mergedCell, null);
1:2457599:                             }
1:2457599:                             else
1:2457599:                             {
1:2457599: 
1:b263af9:                                 if (!mergedData.complexDeletion().isLive() || !inputData.complexDeletion().isLive())
1:b263af9:                                     diffListener.onComplexDeletion(i, clustering, column, mergedData.complexDeletion(), inputData.complexDeletion());
1:a991b64: 
1:2457599:                                 PeekingIterator<Cell> mergedCells = Iterators.peekingIterator(mergedData.iterator());
1:2457599:                                 PeekingIterator<Cell> inputCells = Iterators.peekingIterator(inputData.iterator());
1:2457599:                                 while (mergedCells.hasNext() && inputCells.hasNext())
1:2457599:                                 {
1:2457599:                                     int cmp = column.cellPathComparator().compare(mergedCells.peek().path(), inputCells.peek().path());
1:2457599:                                     if (cmp == 0)
1:2457599:                                         diffListener.onCell(i, clustering, mergedCells.next(), inputCells.next());
1:2457599:                                     else if (cmp < 0)
1:2457599:                                         diffListener.onCell(i, clustering, mergedCells.next(), null);
1:2457599:                                     else // cmp > 0
1:2457599:                                         diffListener.onCell(i, clustering, null, inputCells.next());
1:2457599:                                 }
1:2457599:                                 while (mergedCells.hasNext())
1:2457599:                                     diffListener.onCell(i, clustering, mergedCells.next(), null);
1:2457599:                                 while (inputCells.hasNext())
1:2457599:                                     diffListener.onCell(i, clustering, null, inputCells.next());
1:2457599:                             }
1:a991b64:                         }
1:a991b64:                     }
1:a991b64: 
1:a991b64:                 }
4:a991b64:                 return null;
1:2457599:             }
1:2457599: 
1:aa57626:             protected void onKeyChange()
1:a991b64:             {
1:aa57626:                 mergedData = null;
1:aa57626:                 Arrays.fill(inputDatas, null);
1:2457599:             }
1:aa57626:         });
1:a991b64: 
1:aa57626:         while (iter.hasNext())
1:aa57626:             iter.next();
1:2457599:     }
1:a991b64: 
1:2457599:     public static Row merge(Row row1, Row row2, int nowInSec)
1:2457599:     {
1:aa57626:         Row.Builder builder = BTreeRow.sortedBuilder();
1:aa57626:         merge(row1, row2, builder, nowInSec);
1:2457599:         return builder.build();
1:2457599:     }
1:2457599: 
1:b263af9:     /**
1:b263af9:      * Merges two rows into the given builder, mainly for merging memtable rows. In addition to reconciling the cells
1:b263af9:      * in each row, the liveness info, and deletion times for the row and complex columns are also merged.
1:b263af9:      * <p>
1:b263af9:      * Note that this method assumes that the provided rows can meaningfully be reconciled together. That is,
1:b263af9:      * that the rows share the same clustering value, and belong to the same partition.
1:b263af9:      *
1:b263af9:      * @param existing
1:b263af9:      * @param update
1:b263af9:      * @param builder the row build to which the result of the reconciliation is written.
1:b263af9:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:b263af9:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:b263af9:      * cell is a live or not depends on the current time due to expiring cells).
1:b263af9:      *
1:b263af9:      * @return the smallest timestamp delta between corresponding rows from existing and update. A
1:b263af9:      * timestamp delta being computed as the difference between the cells and DeletionTimes from {@code existing}
1:b263af9:      * and those in {@code existing}.
1:b263af9:      */
1:a991b64:     public static long merge(Row existing,
1:a991b64:                              Row update,
1:2457599:                              Row.Builder builder,
1:0626be8:                              int nowInSec)
1:2457599:     {
1:a991b64:         Clustering clustering = existing.clustering();
1:2457599:         builder.newRow(clustering);
1:a991b64: 
1:a991b64:         LivenessInfo existingInfo = existing.primaryKeyLivenessInfo();
1:a991b64:         LivenessInfo updateInfo = update.primaryKeyLivenessInfo();
1:2457599:         LivenessInfo mergedInfo = existingInfo.supersedes(updateInfo) ? existingInfo : updateInfo;
1:a991b64: 
1:a991b64:         long timeDelta = Math.abs(existingInfo.timestamp() - mergedInfo.timestamp());
1:a991b64: 
1:665f747:         Row.Deletion rowDeletion = existing.deletion().supersedes(update.deletion()) ? existing.deletion() : update.deletion();
1:a991b64: 
1:665f747:         if (rowDeletion.deletes(mergedInfo))
1:2457599:             mergedInfo = LivenessInfo.EMPTY;
1:665f747:         else if (rowDeletion.isShadowedBy(mergedInfo))
1:665f747:             rowDeletion = Row.Deletion.LIVE;
1:a991b64: 
1:2457599:         builder.addPrimaryKeyLivenessInfo(mergedInfo);
1:665f747:         builder.addRowDeletion(rowDeletion);
1:665f747: 
1:665f747:         DeletionTime deletion = rowDeletion.time();
1:a991b64: 
1:aa57626:         Iterator<ColumnData> a = existing.iterator();
1:aa57626:         Iterator<ColumnData> b = update.iterator();
1:aa57626:         ColumnData nexta = a.hasNext() ? a.next() : null, nextb = b.hasNext() ? b.next() : null;
1:aa57626:         while (nexta != null | nextb != null)
1:a991b64:         {
1:aa57626:             int comparison = nexta == null ? 1 : nextb == null ? -1 : nexta.column.compareTo(nextb.column);
1:aa57626:             ColumnData cura = comparison <= 0 ? nexta : null;
1:aa57626:             ColumnData curb = comparison >= 0 ? nextb : null;
1:aa57626:             ColumnDefinition column = (cura != null ? cura : curb).column;
1:aa57626:             if (column.isSimple())
1:a991b64:             {
1:aa57626:                 timeDelta = Math.min(timeDelta, Cells.reconcile((Cell) cura, (Cell) curb, deletion, builder, nowInSec));
1:a991b64:             }
1:aa57626:             else
1:a991b64:             {
1:aa57626:                 ComplexColumnData existingData = (ComplexColumnData) cura;
1:aa57626:                 ComplexColumnData updateData = (ComplexColumnData) curb;
1:a991b64: 
1:2457599:                 DeletionTime existingDt = existingData == null ? DeletionTime.LIVE : existingData.complexDeletion();
1:2457599:                 DeletionTime updateDt = updateData == null ? DeletionTime.LIVE : updateData.complexDeletion();
1:a991b64:                 DeletionTime maxDt = existingDt.supersedes(updateDt) ? existingDt : updateDt;
1:a991b64:                 if (maxDt.supersedes(deletion))
1:aa57626:                     builder.addComplexDeletion(column, maxDt);
1:a991b64:                 else
1:a991b64:                     maxDt = deletion;
1:a991b64: 
1:2457599:                 Iterator<Cell> existingCells = existingData == null ? null : existingData.iterator();
1:2457599:                 Iterator<Cell> updateCells = updateData == null ? null : updateData.iterator();
1:aa57626:                 timeDelta = Math.min(timeDelta, Cells.reconcileComplex(column, existingCells, updateCells, maxDt, builder, nowInSec));
1:a991b64:             }
1:a991b64: 
1:aa57626:             if (cura != null)
1:aa57626:                 nexta = a.hasNext() ? a.next() : null;
1:aa57626:             if (curb != null)
1:aa57626:                 nextb = b.hasNext() ? b.next() : null;
1:a991b64:         }
1:a991b64:         return timeDelta;
1:a991b64:     }
1:a991b64: 
1:d40ac78:     /**
1:d40ac78:      * Returns a row that is obtained from the given existing row by removing everything that is shadowed by data in
1:d40ac78:      * the update row. In other words, produces the smallest result row such that
1:d40ac78:      * {@code merge(result, update, nowInSec) == merge(existing, update, nowInSec)} after filtering by rangeDeletion.
1:d40ac78:      *
1:d40ac78:      * @param existing source row
1:d40ac78:      * @param update shadowing row
1:d40ac78:      * @param rangeDeletion extra {@code DeletionTime} from covering tombstone
1:d40ac78:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:d40ac78:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:d40ac78:      * cell is a live or not depends on the current time due to expiring cells).
1:d40ac78:      */
1:d40ac78:     public static Row removeShadowedCells(Row existing, Row update, DeletionTime rangeDeletion, int nowInSec)
1:a991b64:     {
1:d40ac78:         Row.Builder builder = BTreeRow.sortedBuilder();
1:d40ac78:         Clustering clustering = existing.clustering();
1:d40ac78:         builder.newRow(clustering);
1:a991b64: 
1:d40ac78:         DeletionTime deletion = update.deletion().time();
1:d40ac78:         if (rangeDeletion.supersedes(deletion))
1:d40ac78:             deletion = rangeDeletion;
1:a991b64: 
1:d40ac78:         LivenessInfo existingInfo = existing.primaryKeyLivenessInfo();
1:d40ac78:         if (!deletion.deletes(existingInfo))
1:d40ac78:             builder.addPrimaryKeyLivenessInfo(existingInfo);
1:d40ac78:         Row.Deletion rowDeletion = existing.deletion();
1:d40ac78:         if (!deletion.supersedes(rowDeletion.time()))
1:d40ac78:             builder.addRowDeletion(rowDeletion);
1:a991b64: 
1:d40ac78:         Iterator<ColumnData> a = existing.iterator();
1:d40ac78:         Iterator<ColumnData> b = update.iterator();
1:d40ac78:         ColumnData nexta = a.hasNext() ? a.next() : null, nextb = b.hasNext() ? b.next() : null;
1:d40ac78:         while (nexta != null)
1:a991b64:         {
1:d40ac78:             int comparison = nextb == null ? -1 : nexta.column.compareTo(nextb.column);
1:d40ac78:             if (comparison <= 0)
1:a991b64:             {
1:d40ac78:                 ColumnData cura = nexta;
1:d40ac78:                 ColumnDefinition column = cura.column;
1:d40ac78:                 ColumnData curb = comparison == 0 ? nextb : null;
1:d40ac78:                 if (column.isSimple())
1:a991b64:                 {
1:d40ac78:                     Cells.addNonShadowed((Cell) cura, (Cell) curb, deletion, builder, nowInSec);
1:a991b64:                 }
1:d40ac78:                 else
1:a991b64:                 {
1:d40ac78:                     ComplexColumnData existingData = (ComplexColumnData) cura;
1:d40ac78:                     ComplexColumnData updateData = (ComplexColumnData) curb;
1:a991b64: 
1:d40ac78:                     DeletionTime existingDt = existingData.complexDeletion();
1:d40ac78:                     DeletionTime updateDt = updateData == null ? DeletionTime.LIVE : updateData.complexDeletion();
1:a991b64: 
1:d40ac78:                     DeletionTime maxDt = updateDt.supersedes(deletion) ? updateDt : deletion;
1:d40ac78:                     if (existingDt.supersedes(maxDt))
1:a991b64:                     {
1:d40ac78:                         builder.addComplexDeletion(column, existingDt);
1:d40ac78:                         maxDt = existingDt;
1:a991b64:                     }
1:a991b64: 
1:d40ac78:                     Iterator<Cell> existingCells = existingData.iterator();
1:d40ac78:                     Iterator<Cell> updateCells = updateData == null ? null : updateData.iterator();
1:d40ac78:                     Cells.addNonShadowedComplex(column, existingCells, updateCells, maxDt, builder, nowInSec);
1:a991b64:                 }
1:d40ac78:                 nexta = a.hasNext() ? a.next() : null;
1:d40ac78:                 if (curb != null)
1:d40ac78:                     nextb = b.hasNext() ? b.next() : null;
1:a991b64:             }
1:d40ac78:             else
1:a991b64:             {
1:d40ac78:                 nextb = b.hasNext() ? b.next() : null;
1:a991b64:             }
1:a991b64:         }
1:d40ac78:         Row row = builder.build();
1:d40ac78:         return row != null && !row.isEmpty() ? row : null;
1:a991b64:     }
1:a991b64: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4e21f72
commit:665f747
/////////////////////////////////////////////////////////////////////////
1:         collector.update(row.deletion().time());
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion mergedDeletion = merged.deletion().isLive() ? null : merged.deletion();
1:             Row.Deletion inputDeletion = input == null || input.deletion().isLive() ? null : input.deletion();
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion rowDeletion = existing.deletion().supersedes(update.deletion()) ? existing.deletion() : update.deletion();
1:         if (rowDeletion.deletes(mergedInfo))
1:         else if (rowDeletion.isShadowedBy(mergedInfo))
1:             rowDeletion = Row.Deletion.LIVE;
1:         builder.addRowDeletion(rowDeletion);
1: 
1:         DeletionTime deletion = rowDeletion.time();
commit:2457599
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.PeekingIterator;
1: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
/////////////////////////////////////////////////////////////////////////
0:     // TODO: we could have a that in a more generic place...
0:     private static final SearchIterator<ColumnDefinition, ColumnData> EMPTY_SEARCH_ITERATOR = new SearchIterator<ColumnDefinition, ColumnData>()
0:         public boolean hasNext()
0:         public ColumnData next(ColumnDefinition column)
1:     private Rows() {}
1: 
0:     public static final Row EMPTY_STATIC_ROW = ArrayBackedRow.emptyRow(Clustering.STATIC_CLUSTERING);
1: 
1:     public static Row.Builder copy(Row row, Row.Builder builder)
1:         builder.newRow(row.clustering());
1:         builder.addPrimaryKeyLivenessInfo(row.primaryKeyLivenessInfo());
1:         builder.addRowDeletion(row.deletion());
1:         for (ColumnData cd : row)
1:         {
1:             if (cd.column().isSimple())
1:             {
1:                 builder.addCell((Cell)cd);
1:             }
1:             else
1:             {
1:                 ComplexColumnData complexData = (ComplexColumnData)cd;
1:                 builder.addComplexDeletion(complexData.column(), complexData.complexDeletion());
1:                 for (Cell cell : complexData)
1:                     builder.addCell(cell);
1:             }
1:         }
1:         return builder;
1:     /**
0:      * Collect statistics ont a given row.
1:      *
1:      * @param row the row for which to collect stats.
1:      * @param collector the stats collector.
1:      * @return the total number of cells in {@code row}.
1:      */
1:     public static int collectStats(Row row, PartitionStatisticsCollector collector)
1:         assert !row.isEmpty();
1: 
1:         collector.update(row.primaryKeyLivenessInfo());
0:         collector.update(row.deletion());
1: 
0:         int columnCount = 0;
0:         int cellCount = 0;
1:         for (ColumnData cd : row)
1:         {
1:             if (cd.column().isSimple())
1:             {
0:                 ++columnCount;
0:                 ++cellCount;
0:                 Cells.collectStats((Cell)cd, collector);
1:             }
1:             else
1:             {
1:                 ComplexColumnData complexData = (ComplexColumnData)cd;
1:                 collector.update(complexData.complexDeletion());
1:                 if (complexData.hasCells())
1:                 {
0:                     ++columnCount;
1:                     for (Cell cell : complexData)
1:                     {
0:                         ++cellCount;
1:                         Cells.collectStats(cell, collector);
1:                     }
1:                 }
1:             }
1: 
1:         }
0:         collector.updateColumnSetPerRow(columnCount);
0:         return cellCount;
1:     /**
1:      * Given the result ({@code merged}) of merging multiple {@code inputs}, signals the difference between
1:      * each input and {@code merged} to {@code diffListener}.
1:      *
1:      * @param merged the result of merging {@code inputs}.
0:      * @param columns a superset of all the columns in any of {@code merged}/{@code inputs}.
1:      * @param inputs the inputs whose merge yielded {@code merged}.
0:      * @param diffListener the listener to which to signal the differences between the inputs and the merged
0:      * result.
1:      */
0:     public static void diff(Row merged, Columns columns, Row[] inputs, RowDiffListener diffListener)
1:         Clustering clustering = merged.clustering();
1:         LivenessInfo mergedInfo = merged.primaryKeyLivenessInfo().isEmpty() ? null : merged.primaryKeyLivenessInfo();
0:         DeletionTime mergedDeletion = merged.deletion().isLive() ? null : merged.deletion();
1:         for (int i = 0; i < inputs.length; i++)
1:         {
1:             Row input = inputs[i];
1:             LivenessInfo inputInfo = input == null || input.primaryKeyLivenessInfo().isEmpty() ? null : input.primaryKeyLivenessInfo();
0:             DeletionTime inputDeletion = input == null || input.deletion().isLive() ? null : input.deletion();
1: 
1:             if (mergedInfo != null || inputInfo != null)
1:                 diffListener.onPrimaryKeyLivenessInfo(i, clustering, mergedInfo, inputInfo);
1:             if (mergedDeletion != null || inputDeletion != null)
1:                 diffListener.onDeletion(i, clustering, mergedDeletion, inputDeletion);
1:         }
1: 
0:         SearchIterator<ColumnDefinition, ColumnData> mergedIterator = merged.searchIterator();
0:         List<SearchIterator<ColumnDefinition, ColumnData>> inputIterators = new ArrayList<>(inputs.length);
1: 
1:         for (Row row : inputs)
0:             inputIterators.add(row == null ? EMPTY_SEARCH_ITERATOR : row.searchIterator());
1: 
0:         Iterator<ColumnDefinition> simpleColumns = columns.simpleColumns();
0:         while (simpleColumns.hasNext())
1:         {
0:             ColumnDefinition column = simpleColumns.next();
0:             Cell mergedCell = (Cell)mergedIterator.next(column);
1:             for (int i = 0; i < inputs.length; i++)
1:             {
0:                 Cell inputCell = (Cell)inputIterators.get(i).next(column);
0:                 if (mergedCell != null || inputCell != null)
0:                     diffListener.onCell(i, clustering, mergedCell, inputCell);
1:             }
1:         }
1: 
0:         Iterator<ColumnDefinition> complexColumns = columns.complexColumns();
0:         while (complexColumns.hasNext())
1:         {
0:             ColumnDefinition column = complexColumns.next();
0:             ComplexColumnData mergedData = (ComplexColumnData)mergedIterator.next(column);
0:             // Doing one input at a time is not the most efficient, but it's a lot simpler for now
1:             for (int i = 0; i < inputs.length; i++)
1:             {
0:                 ComplexColumnData inputData = (ComplexColumnData)inputIterators.get(i).next(column);
1:                 if (mergedData == null)
1:                 {
0:                     if (inputData == null)
0:                         continue;
1: 
1:                     // Everything in inputData has been shadowed
1:                     if (!inputData.complexDeletion().isLive())
1:                         diffListener.onComplexDeletion(i, clustering, column, null, inputData.complexDeletion());
1:                     for (Cell inputCell : inputData)
1:                         diffListener.onCell(i, clustering, null, inputCell);
1:                 }
1:                 else if (inputData == null)
1:                 {
1:                     // Everything in inputData is new
1:                     if (!mergedData.complexDeletion().isLive())
1:                         diffListener.onComplexDeletion(i, clustering, column, mergedData.complexDeletion(), null);
1:                     for (Cell mergedCell : mergedData)
1:                         diffListener.onCell(i, clustering, mergedCell, null);
1:                 }
1:                 else
1:                 {
1:                     PeekingIterator<Cell> mergedCells = Iterators.peekingIterator(mergedData.iterator());
1:                     PeekingIterator<Cell> inputCells = Iterators.peekingIterator(inputData.iterator());
1:                     while (mergedCells.hasNext() && inputCells.hasNext())
1:                     {
1:                         int cmp = column.cellPathComparator().compare(mergedCells.peek().path(), inputCells.peek().path());
1:                         if (cmp == 0)
1:                             diffListener.onCell(i, clustering, mergedCells.next(), inputCells.next());
1:                         else if (cmp < 0)
1:                             diffListener.onCell(i, clustering, mergedCells.next(), null);
1:                         else // cmp > 0
1:                             diffListener.onCell(i, clustering, null, inputCells.next());
1:                     }
1:                     while (mergedCells.hasNext())
1:                         diffListener.onCell(i, clustering, mergedCells.next(), null);
1:                     while (inputCells.hasNext())
1:                         diffListener.onCell(i, clustering, null, inputCells.next());
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public static Row merge(Row row1, Row row2, int nowInSec)
1:     {
0:         Columns mergedColumns = row1.columns().mergeTo(row2.columns());
0:         Row.Builder builder = ArrayBackedRow.sortedBuilder(mergedColumns);
0:         merge(row1, row2, mergedColumns, builder, nowInSec, SecondaryIndexManager.nullUpdater);
1:         return builder.build();
1:     }
1: 
0:     public static void merge(Row row1, Row row2, Columns mergedColumns, Row.Builder builder, int nowInSec)
1:     {
0:         merge(row1, row2, mergedColumns, builder, nowInSec, SecondaryIndexManager.nullUpdater);
/////////////////////////////////////////////////////////////////////////
1:                              Row.Builder builder,
1:         builder.newRow(clustering);
1:         LivenessInfo mergedInfo = existingInfo.supersedes(updateInfo) ? existingInfo : updateInfo;
1:             mergedInfo = LivenessInfo.EMPTY;
1:         builder.addPrimaryKeyLivenessInfo(mergedInfo);
0:         builder.addRowDeletion(deletion);
/////////////////////////////////////////////////////////////////////////
0:                                                             builder,
/////////////////////////////////////////////////////////////////////////
0:             ComplexColumnData existingData = existing.getComplexColumnData(c);
0:             ComplexColumnData updateData = update.getComplexColumnData(c);
1: 
1:             DeletionTime existingDt = existingData == null ? DeletionTime.LIVE : existingData.complexDeletion();
1:             DeletionTime updateDt = updateData == null ? DeletionTime.LIVE : updateData.complexDeletion();
0:                 builder.addComplexDeletion(c, maxDt);
1:             Iterator<Cell> existingCells = existingData == null ? null : existingData.iterator();
1:             Iterator<Cell> updateCells = updateData == null ? null : updateData.iterator();
0:             timeDelta = Math.min(timeDelta, Cells.reconcileComplex(clustering, c, existingCells, updateCells, maxDt, builder, nowInSec, indexUpdater));
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.rows;
1: 
1: import java.util.*;
1: 
1: import com.google.common.collect.Iterators;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.index.SecondaryIndexManager;
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.SearchIterator;
1: 
1: /**
1:  * Static utilities to work on Row objects.
1:  */
1: public abstract class Rows
1: {
0:     private static final Logger logger = LoggerFactory.getLogger(Rows.class);
1: 
0:     private Rows() {}
1: 
0:     public static final Row EMPTY_STATIC_ROW = new AbstractRow()
1:     {
0:         public Columns columns()
1:         {
0:             return Columns.NONE;
1:         }
1: 
0:         public LivenessInfo primaryKeyLivenessInfo()
1:         {
0:             return LivenessInfo.NONE;
1:         }
1: 
0:         public DeletionTime deletion()
1:         {
0:             return DeletionTime.LIVE;
1:         }
1: 
0:         public boolean isEmpty()
1:         {
0:             return true;
1:         }
1: 
0:         public boolean hasComplexDeletion()
1:         {
0:             return false;
1:         }
1: 
0:         public Clustering clustering()
1:         {
0:             return Clustering.STATIC_CLUSTERING;
1:         }
1: 
0:         public Cell getCell(ColumnDefinition c)
1:         {
1:             return null;
1:         }
1: 
0:         public Cell getCell(ColumnDefinition c, CellPath path)
1:         {
1:             return null;
1:         }
1: 
0:         public Iterator<Cell> getCells(ColumnDefinition c)
1:         {
1:             return null;
1:         }
1: 
0:         public DeletionTime getDeletion(ColumnDefinition c)
1:         {
0:             return DeletionTime.LIVE;
1:         }
1: 
0:         public Iterator<Cell> iterator()
1:         {
0:             return Iterators.<Cell>emptyIterator();
1:         }
1: 
0:         public SearchIterator<ColumnDefinition, ColumnData> searchIterator()
1:         {
0:             return new SearchIterator<ColumnDefinition, ColumnData>()
1:             {
0:                 public boolean hasNext()
1:                 {
0:                     return false;
1:                 }
1: 
0:                 public ColumnData next(ColumnDefinition column)
1:                 {
1:                     return null;
1:                 }
0:             };
1:         }
1: 
0:         public Kind kind()
1:         {
0:             return Unfiltered.Kind.ROW;
1:         }
1: 
0:         public Row takeAlias()
1:         {
0:             return this;
1:         }
0:     };
1: 
0:     public interface SimpleMergeListener
1:     {
0:         public void onAdded(Cell newCell);
0:         public void onRemoved(Cell removedCell);
0:         public void onUpdated(Cell existingCell, Cell updatedCell);
1:     }
1: 
0:     public static void writeClustering(Clustering clustering, Row.Writer writer)
1:     {
0:         for (int i = 0; i < clustering.size(); i++)
0:             writer.writeClusteringValue(clustering.get(i));
1:     }
1: 
0:     public static void merge(Row row1, Row row2, Columns mergedColumns, Row.Writer writer, int nowInSec)
1:     {
0:         merge(row1, row2, mergedColumns, writer, nowInSec, SecondaryIndexManager.nullUpdater);
1:     }
1: 
0:     // Merge rows in memtable
0:     // Return the minimum timestamp delta between existing and update
1:     public static long merge(Row existing,
1:                              Row update,
0:                              Columns mergedColumns,
0:                              Row.Writer writer,
0:                              int nowInSec,
0:                              SecondaryIndexManager.Updater indexUpdater)
1:     {
1:         Clustering clustering = existing.clustering();
0:         writeClustering(clustering, writer);
1: 
1:         LivenessInfo existingInfo = existing.primaryKeyLivenessInfo();
1:         LivenessInfo updateInfo = update.primaryKeyLivenessInfo();
0:         LivenessInfo mergedInfo = existingInfo.mergeWith(updateInfo);
1: 
1:         long timeDelta = Math.abs(existingInfo.timestamp() - mergedInfo.timestamp());
1: 
0:         DeletionTime deletion = existing.deletion().supersedes(update.deletion()) ? existing.deletion() : update.deletion();
1: 
0:         if (deletion.deletes(mergedInfo))
0:             mergedInfo = LivenessInfo.NONE;
1: 
0:         writer.writePartitionKeyLivenessInfo(mergedInfo);
0:         writer.writeRowDeletion(deletion);
1: 
0:         indexUpdater.maybeIndex(clustering, mergedInfo.timestamp(), mergedInfo.ttl(), deletion);
1: 
0:         for (int i = 0; i < mergedColumns.simpleColumnCount(); i++)
1:         {
0:             ColumnDefinition c = mergedColumns.getSimple(i);
0:             Cell existingCell = existing.getCell(c);
0:             Cell updateCell = update.getCell(c);
0:             timeDelta = Math.min(timeDelta, Cells.reconcile(clustering,
0:                                                             existingCell,
0:                                                             updateCell,
0:                                                             deletion,
0:                                                             writer,
0:                                                             nowInSec,
0:                                                             indexUpdater));
1:         }
1: 
0:         for (int i = 0; i < mergedColumns.complexColumnCount(); i++)
1:         {
0:             ColumnDefinition c = mergedColumns.getComplex(i);
0:             DeletionTime existingDt = existing.getDeletion(c);
0:             DeletionTime updateDt = update.getDeletion(c);
1:             DeletionTime maxDt = existingDt.supersedes(updateDt) ? existingDt : updateDt;
1:             if (maxDt.supersedes(deletion))
0:                 writer.writeComplexDeletion(c, maxDt);
1:             else
1:                 maxDt = deletion;
1: 
0:             Iterator<Cell> existingCells = existing.getCells(c);
0:             Iterator<Cell> updateCells = update.getCells(c);
0:             timeDelta = Math.min(timeDelta, Cells.reconcileComplex(clustering, c, existingCells, updateCells, maxDt, writer, nowInSec, indexUpdater));
1:         }
1: 
0:         writer.endOfRow();
1:         return timeDelta;
1:     }
1: }
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:2683806
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
1:      * Creates a new simple row builder.
1:      *
1:      * @param metadata the metadata of the table this is a row of.
1:      * @param clusteringValues the value for the clustering columns of the row to add to this build. There may be no
1:      * values if either the table has no clustering column, or if you want to edit the static row. Note that as a
1:      * shortcut it is also allowed to pass a {@code Clustering} object directly, in which case that should be the
1:      * only argument.
1:      * @return a newly created builder.
1:      */
1:     public static Row.SimpleBuilder simpleBuilder(CFMetaData metadata, Object... clusteringValues)
0:     {
1:         return new SimpleBuilders.RowBuilder(metadata, clusteringValues);
0:     }
0: 
1:     /**
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:d40ac78
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.Row.Deletion;
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Returns a row that is obtained from the given existing row by removing everything that is shadowed by data in
1:      * the update row. In other words, produces the smallest result row such that
1:      * {@code merge(result, update, nowInSec) == merge(existing, update, nowInSec)} after filtering by rangeDeletion.
1:      *
1:      * @param existing source row
1:      * @param update shadowing row
1:      * @param rangeDeletion extra {@code DeletionTime} from covering tombstone
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
1:      */
1:     public static Row removeShadowedCells(Row existing, Row update, DeletionTime rangeDeletion, int nowInSec)
0:     {
1:         Row.Builder builder = BTreeRow.sortedBuilder();
1:         Clustering clustering = existing.clustering();
1:         builder.newRow(clustering);
0: 
1:         DeletionTime deletion = update.deletion().time();
1:         if (rangeDeletion.supersedes(deletion))
1:             deletion = rangeDeletion;
0: 
1:         LivenessInfo existingInfo = existing.primaryKeyLivenessInfo();
1:         if (!deletion.deletes(existingInfo))
1:             builder.addPrimaryKeyLivenessInfo(existingInfo);
1:         Row.Deletion rowDeletion = existing.deletion();
1:         if (!deletion.supersedes(rowDeletion.time()))
1:             builder.addRowDeletion(rowDeletion);
0: 
1:         Iterator<ColumnData> a = existing.iterator();
1:         Iterator<ColumnData> b = update.iterator();
1:         ColumnData nexta = a.hasNext() ? a.next() : null, nextb = b.hasNext() ? b.next() : null;
1:         while (nexta != null)
0:         {
1:             int comparison = nextb == null ? -1 : nexta.column.compareTo(nextb.column);
1:             if (comparison <= 0)
0:             {
1:                 ColumnData cura = nexta;
1:                 ColumnDefinition column = cura.column;
1:                 ColumnData curb = comparison == 0 ? nextb : null;
1:                 if (column.isSimple())
0:                 {
1:                     Cells.addNonShadowed((Cell) cura, (Cell) curb, deletion, builder, nowInSec);
0:                 }
1:                 else
0:                 {
1:                     ComplexColumnData existingData = (ComplexColumnData) cura;
1:                     ComplexColumnData updateData = (ComplexColumnData) curb;
0: 
1:                     DeletionTime existingDt = existingData.complexDeletion();
1:                     DeletionTime updateDt = updateData == null ? DeletionTime.LIVE : updateData.complexDeletion();
0: 
1:                     DeletionTime maxDt = updateDt.supersedes(deletion) ? updateDt : deletion;
1:                     if (existingDt.supersedes(maxDt))
0:                     {
1:                         builder.addComplexDeletion(column, existingDt);
1:                         maxDt = existingDt;
0:                     }
0: 
1:                     Iterator<Cell> existingCells = existingData.iterator();
1:                     Iterator<Cell> updateCells = updateData == null ? null : updateData.iterator();
1:                     Cells.addNonShadowedComplex(column, existingCells, updateCells, maxDt, builder, nowInSec);
0:                 }
1:                 nexta = a.hasNext() ? a.next() : null;
1:                 if (curb != null)
1:                     nextb = b.hasNext() ? b.next() : null;
0:             }
1:             else
0:             {
1:                 nextb = b.hasNext() ? b.next() : null;
0:             }
0:         }
1:         Row row = builder.build();
1:         return row != null && !row.isEmpty() ? row : null;
0:     }
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.WrappedInt;
/////////////////////////////////////////////////////////////////////////
1:         //we have to wrap these for the lambda
1:         final WrappedInt columnCount = new WrappedInt(0);
1:         final WrappedInt cellCount = new WrappedInt(0);
0: 
1:         row.apply(cd -> {
1:                 columnCount.increment();
1:                 cellCount.increment();
/////////////////////////////////////////////////////////////////////////
1:                     columnCount.increment();
1:                         cellCount.increment();
1:         }, false);
1:         collector.updateColumnSetPerRow(columnCount.get());
1:         return cellCount.get();
author:Alex Petrov
-------------------------------------------------------------------------------
commit:85cc390
/////////////////////////////////////////////////////////////////////////
1:      * Collect statistics on a given row.
author:Blake Eggleston
-------------------------------------------------------------------------------
commit:b263af9
/////////////////////////////////////////////////////////////////////////
1:                 Cells.collectStats((Cell) cd, collector);
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Note that this method doesn't only emit cells etc where there's a difference. The listener is informed
1:      * of every corresponding entity between the merged and input rows, including those that are equal.
1:      * @param diffListener the listener to which to signal the differences between the inputs and the merged result.
/////////////////////////////////////////////////////////////////////////
0: 
1:                                 if (!mergedData.complexDeletion().isLive() || !inputData.complexDeletion().isLive())
1:                                     diffListener.onComplexDeletion(i, clustering, column, mergedData.complexDeletion(), inputData.complexDeletion());
0: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Merges two rows into the given builder, mainly for merging memtable rows. In addition to reconciling the cells
1:      * in each row, the liveness info, and deletion times for the row and complex columns are also merged.
1:      * <p>
1:      * Note that this method assumes that the provided rows can meaningfully be reconciled together. That is,
1:      * that the rows share the same clustering value, and belong to the same partition.
1:      *
1:      * @param existing
1:      * @param update
1:      * @param builder the row build to which the result of the reconciliation is written.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
1:      *
1:      * @return the smallest timestamp delta between corresponding rows from existing and update. A
1:      * timestamp delta being computed as the difference between the cells and DeletionTimes from {@code existing}
1:      * and those in {@code existing}.
1:      */
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:aa57626
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.MergeIterator;
/////////////////////////////////////////////////////////////////////////
1:     public static void diff(RowDiffListener diffListener, Row merged, Row...inputs)
/////////////////////////////////////////////////////////////////////////
1:         List<Iterator<ColumnData>> inputIterators = new ArrayList<>(1 + inputs.length);
1:         inputIterators.add(merged.iterator());
1:             inputIterators.add(row == null ? Collections.emptyIterator() : row.iterator());
1:         Iterator<?> iter = MergeIterator.get(inputIterators, ColumnData.comparator, new MergeIterator.Reducer<ColumnData, Object>()
1:             ColumnData mergedData;
1:             ColumnData[] inputDatas = new ColumnData[inputs.length];
1:             public void reduce(int idx, ColumnData current)
1:                 if (idx == 0)
1:                     mergedData = current;
1:                     inputDatas[idx - 1] = current;
0: 
1:             protected Object getReduced()
0:             {
1:                 for (int i = 0 ; i != inputDatas.length ; i++)
0:                 {
1:                     ColumnData input = inputDatas[i];
1:                     if (mergedData != null || input != null)
0:                     {
1:                         ColumnDefinition column = (mergedData != null ? mergedData : input).column;
1:                         if (column.isSimple())
0:                         {
1:                             diffListener.onCell(i, clustering, (Cell) mergedData, (Cell) input);
0:                         }
1:                         else
0:                         {
1:                             ComplexColumnData mergedData = (ComplexColumnData) this.mergedData;
1:                             ComplexColumnData inputData = (ComplexColumnData) input;
0:                             if (mergedData == null)
0:                             {
0:                                 // Everything in inputData has been shadowed
0:                                 if (!inputData.complexDeletion().isLive())
0:                                     diffListener.onComplexDeletion(i, clustering, column, null, inputData.complexDeletion());
0:                                 for (Cell inputCell : inputData)
0:                                     diffListener.onCell(i, clustering, null, inputCell);
0:                             }
0:                             else if (inputData == null)
0:                             {
0:                                 // Everything in inputData is new
0:                                 if (!mergedData.complexDeletion().isLive())
0:                                     diffListener.onComplexDeletion(i, clustering, column, mergedData.complexDeletion(), null);
0:                                 for (Cell mergedCell : mergedData)
0:                                     diffListener.onCell(i, clustering, mergedCell, null);
0:                             }
1:                             else
0:                             {
0:                                 PeekingIterator<Cell> mergedCells = Iterators.peekingIterator(mergedData.iterator());
0:                                 PeekingIterator<Cell> inputCells = Iterators.peekingIterator(inputData.iterator());
0:                                 while (mergedCells.hasNext() && inputCells.hasNext())
0:                                 {
0:                                     int cmp = column.cellPathComparator().compare(mergedCells.peek().path(), inputCells.peek().path());
0:                                     if (cmp == 0)
0:                                         diffListener.onCell(i, clustering, mergedCells.next(), inputCells.next());
0:                                     else if (cmp < 0)
0:                                         diffListener.onCell(i, clustering, mergedCells.next(), null);
0:                                     else // cmp > 0
0:                                         diffListener.onCell(i, clustering, null, inputCells.next());
0:                                 }
0:                                 while (mergedCells.hasNext())
0:                                     diffListener.onCell(i, clustering, mergedCells.next(), null);
0:                                 while (inputCells.hasNext())
0:                                     diffListener.onCell(i, clustering, null, inputCells.next());
0:                             }
0:                         }
0:                     }
0: 
0:                 }
0:                 return null;
0:             }
0: 
1:             protected void onKeyChange()
0:             {
1:                 mergedData = null;
1:                 Arrays.fill(inputDatas, null);
0:             }
1:         });
0: 
1:         while (iter.hasNext())
1:             iter.next();
1:         Row.Builder builder = BTreeRow.sortedBuilder();
1:         merge(row1, row2, builder, nowInSec);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Iterator<ColumnData> a = existing.iterator();
1:         Iterator<ColumnData> b = update.iterator();
1:         ColumnData nexta = a.hasNext() ? a.next() : null, nextb = b.hasNext() ? b.next() : null;
1:         while (nexta != null | nextb != null)
1:             int comparison = nexta == null ? 1 : nextb == null ? -1 : nexta.column.compareTo(nextb.column);
1:             ColumnData cura = comparison <= 0 ? nexta : null;
1:             ColumnData curb = comparison >= 0 ? nextb : null;
1:             ColumnDefinition column = (cura != null ? cura : curb).column;
1:             if (column.isSimple())
0:             {
1:                 timeDelta = Math.min(timeDelta, Cells.reconcile((Cell) cura, (Cell) curb, deletion, builder, nowInSec));
0:             }
0:             {
1:                 ComplexColumnData existingData = (ComplexColumnData) cura;
1:                 ComplexColumnData updateData = (ComplexColumnData) curb;
0:                 DeletionTime existingDt = existingData == null ? DeletionTime.LIVE : existingData.complexDeletion();
0:                 DeletionTime updateDt = updateData == null ? DeletionTime.LIVE : updateData.complexDeletion();
0:                 DeletionTime maxDt = existingDt.supersedes(updateDt) ? existingDt : updateDt;
0:                 if (maxDt.supersedes(deletion))
1:                     builder.addComplexDeletion(column, maxDt);
1:                 else
0:                     maxDt = deletion;
0: 
0:                 Iterator<Cell> existingCells = existingData == null ? null : existingData.iterator();
0:                 Iterator<Cell> updateCells = updateData == null ? null : updateData.iterator();
1:                 timeDelta = Math.min(timeDelta, Cells.reconcileComplex(column, existingCells, updateCells, maxDt, builder, nowInSec));
0:             }
0: 
1:             if (cura != null)
1:                 nexta = a.hasNext() ? a.next() : null;
1:             if (curb != null)
1:                 nextb = b.hasNext() ? b.next() : null;
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1:     public static final Row EMPTY_STATIC_ROW = BTreeRow.emptyRow(Clustering.STATIC_CLUSTERING);
/////////////////////////////////////////////////////////////////////////
0:         Row.Builder builder = BTreeRow.sortedBuilder(mergedColumns);
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:     public static final Row EMPTY_STATIC_ROW = BTreeBackedRow.emptyRow(Clustering.STATIC_CLUSTERING);
/////////////////////////////////////////////////////////////////////////
0:         Row.Builder builder = BTreeBackedRow.sortedBuilder(mergedColumns);
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:0626be8
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static void diff(RowDiffListener diffListener, Row merged, Columns columns, Row...inputs)
/////////////////////////////////////////////////////////////////////////
0:         merge(row1, row2, mergedColumns, builder, nowInSec);
1:                              int nowInSec)
/////////////////////////////////////////////////////////////////////////
0:             timeDelta = Math.min(timeDelta, Cells.reconcile(existingCell,
0:                                                             nowInSec));
/////////////////////////////////////////////////////////////////////////
0:             timeDelta = Math.min(timeDelta, Cells.reconcileComplex(c, existingCells, updateCells, maxDt, builder, nowInSec));
============================================================================