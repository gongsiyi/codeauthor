1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
2:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:a991b64: package org.apache.cassandra.db.rows;
16:a991b64: 
1:a991b64: import java.util.*;
1:665f747: import java.security.MessageDigest;
1:dc9ed46: import java.util.function.Consumer;
1:a991b64: 
1:dc9ed46: import com.google.common.base.Predicate;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:a991b64: import org.apache.cassandra.db.*;
1:2457599: import org.apache.cassandra.db.filter.ColumnFilter;
1:2457599: import org.apache.cassandra.service.paxos.Commit;
1:665f747: import org.apache.cassandra.utils.FBUtilities;
1:a991b64: import org.apache.cassandra.utils.MergeIterator;
1:a991b64: import org.apache.cassandra.utils.SearchIterator;
1:639d4b2: import org.apache.cassandra.utils.btree.BTree;
1:639d4b2: import org.apache.cassandra.utils.btree.UpdateFunction;
1:a991b64: 
1:a991b64: /**
1:a991b64:  * Storage engine representation of a row.
1:a991b64:  *
1:2457599:  * A row mainly contains the following informations:
1:2457599:  *   1) Its {@code Clustering}, which holds the values for the clustering columns identifying the row.
1:2457599:  *   2) Its row level informations: the primary key liveness infos and the row deletion (see
1:2457599:  *      {@link #primaryKeyLivenessInfo()} and {@link #deletion()} for more details).
1:2457599:  *   3) Data for the columns it contains, or in other words, it's a (sorted) collection of
1:2457599:  *      {@code ColumnData}.
1:a991b64:  *
1:2457599:  * Also note that as for every other storage engine object, a {@code Row} object cannot shadow
1:2457599:  * it's own data. For instance, a {@code Row} cannot contains a cell that is deleted by its own
1:2457599:  * row deletion.
1:a991b64:  */
1:0d74c3e: public interface Row extends Unfiltered, Collection<ColumnData>
15:a991b64: {
1:a991b64:     /**
1:a991b64:      * The clustering values for this row.
1:a991b64:      */
1:a991b64:     @Override
1:a991b64:     public Clustering clustering();
1:a991b64: 
1:a991b64:     /**
1:a22db5b:      * An in-natural-order collection of the columns for which data (incl. simple tombstones)
1:a22db5b:      * is present in this row.
1:a991b64:      */
1:aa57626:     public Collection<ColumnDefinition> columns();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The row deletion.
1:a991b64:      *
1:a991b64:      * This correspond to the last row deletion done on this row.
1:a991b64:      *
1:a991b64:      * @return the row deletion.
1:a991b64:      */
1:665f747:     public Deletion deletion();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Liveness information for the primary key columns of this row.
1:a991b64:      * <p>
1:a991b64:      * As a row is uniquely identified by its primary key, all its primary key columns
1:a991b64:      * share the same {@code LivenessInfo}. This liveness information is what allows us
1:a991b64:      * to distinguish between a dead row (it has no live cells and its primary key liveness
1:2457599:      * info is empty) and a live row but where all non PK columns are null (it has no
1:2457599:      * live cells, but its primary key liveness is not empty). Please note that the liveness
1:2457599:      * info (including it's eventually ttl/local deletion time) only apply to the primary key
1:2457599:      * columns and has no impact on the row content.
1:a991b64:      * <p>
1:2457599:      * Note in particular that a row may have live cells but no PK liveness info, because the
1:2457599:      * primary key liveness informations are only set on {@code INSERT} (which makes sense
1:2457599:      * in itself, see #6782) but live cells can be added through {@code UPDATE} even if the row
1:a991b64:      * wasn't pre-existing (which users are encouraged not to do, but we can't validate).
1:a991b64:      */
1:a991b64:     public LivenessInfo primaryKeyLivenessInfo();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether the row correspond to a static row or not.
1:a991b64:      *
1:a991b64:      * @return whether the row correspond to a static row or not.
1:a991b64:      */
1:a991b64:     public boolean isStatic();
1:a991b64: 
1:a991b64:     /**
1:2457599:      * Whether the row has no information whatsoever. This means no PK liveness info, no row
1:2457599:      * deletion, no cells and no complex deletion info.
1:a991b64:      *
1:2457599:      * @return {@code true} if the row has no data, {@code false} otherwise.
1:a991b64:      */
1:a991b64:     public boolean isEmpty();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether the row has some live information (i.e. it's not just deletion informations).
1:a991b64:      */
1:a991b64:     public boolean hasLiveData(int nowInSec);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns a cell for a simple column.
1:a991b64:      *
1:a991b64:      * @param c the simple column for which to fetch the cell.
1:a991b64:      * @return the corresponding cell or {@code null} if the row has no such cell.
1:a991b64:      */
1:a991b64:     public Cell getCell(ColumnDefinition c);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Return a cell for a given complex column and cell path.
1:a991b64:      *
1:a991b64:      * @param c the complex column for which to fetch the cell.
1:a991b64:      * @param path the cell path for which to fetch the cell.
1:a991b64:      * @return the corresponding cell or {@code null} if the row has no such cell.
1:a991b64:      */
1:a991b64:     public Cell getCell(ColumnDefinition c, CellPath path);
1:a991b64: 
1:a991b64:     /**
1:2457599:      * The data for a complex column.
1:2457599:      * <p>
1:2457599:      * The returned object groups all the cells for the column, as well as it's complex deletion (if relevant).
1:a991b64:      *
1:2457599:      * @param c the complex column for which to return the complex data.
1:2457599:      * @return the data for {@code c} or {@code null} is the row has no data for this column.
1:a991b64:      */
1:2457599:     public ComplexColumnData getComplexColumnData(ColumnDefinition c);
1:a991b64: 
1:a991b64:     /**
1:2457599:      * An iterable over the cells of this row.
1:2457599:      * <p>
1:2457599:      * The iterable guarantees that cells are returned in order of {@link Cell#comparator}.
1:a991b64:      *
1:2457599:      * @return an iterable over the cells of this row.
1:a991b64:      */
1:2457599:     public Iterable<Cell> cells();
1:a991b64: 
1:a991b64:     /**
1:8c64cef:      * An iterable over the cells of this row that return cells in "legacy order".
1:8c64cef:      * <p>
1:8c64cef:      * In 3.0+, columns are sorted so that all simple columns are before all complex columns. Previously
1:8c64cef:      * however, the cells where just sorted by the column name. This iterator return cells in that
1:8c64cef:      * legacy order. It's only ever meaningful for backward/thrift compatibility code.
1:a991b64:      *
1:8c64cef:      * @param metadata the table this is a row of.
1:b99c863:      * @param reversed if cells should returned in reverse order.
1:8c64cef:      * @return an iterable over the cells of this row in "legacy order".
1:a991b64:      */
1:b99c863:     public Iterable<Cell> cellsInLegacyOrder(CFMetaData metadata, boolean reversed);
1:a991b64: 
1:dc9ed46:     /**
1:2457599:      * Whether the row stores any (non-live) complex deletion for any complex column.
1:dc9ed46:      */
1:2457599:     public boolean hasComplexDeletion();
1:2457599: 
1:2457599:     /**
1:aa57626:      * Whether the row stores any (non-RT) data for any complex column.
1:a991b64:      */
1:aa57626:     boolean hasComplex();
1:a991b64: 
1:a991b64:     /**
1:2457599:      * Whether the row has any deletion info (row deletion, cell tombstone, expired cell or complex deletion).
1:2457599:      *
1:2457599:      * @param nowInSec the current time in seconds to decid if a cell is expired.
1:2457599:      */
1:2457599:     public boolean hasDeletion(int nowInSec);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * An iterator to efficiently search data for a given column.
1:a991b64:      *
1:a991b64:      * @return a search iterator for the cells of this row.
1:a991b64:      */
1:a991b64:     public SearchIterator<ColumnDefinition, ColumnData> searchIterator();
1:a991b64: 
1:a991b64:     /**
1:2457599:      * Returns a copy of this row that:
1:2457599:      *   1) only includes the data for the column included by {@code filter}.
1:2457599:      *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
1:a991b64:      */
1:2457599:     public Row filter(ColumnFilter filter, CFMetaData metadata);
1:2457599: 
1:2457599:     /**
1:2457599:      * Returns a copy of this row that:
1:2457599:      *   1) only includes the data for the column included by {@code filter}.
1:2457599:      *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
1:2457599:      *   3) doesn't include any data that is shadowed/deleted by {@code activeDeletion}.
1:2457599:      *   4) uses {@code activeDeletion} as row deletion iff {@code setActiveDeletionToRow} and {@code activeDeletion} supersedes the row deletion.
1:2457599:      */
1:2457599:     public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setActiveDeletionToRow, CFMetaData metadata);
1:2457599: 
1:2457599:     /**
1:2457599:      * Returns a copy of this row without any deletion info that should be purged according to {@code purger}.
1:2457599:      *
1:2457599:      * @param purger the {@code DeletionPurger} to use to decide what can be purged.
1:2457599:      * @param nowInSec the current time to decide what is deleted and what isn't (in the case of expired cells).
1:979e559:      * @return this row but without any deletion info purged by {@code purger}. If the purged row is empty, returns
1:979e559:      * {@code null}.
1:2457599:      */
1:2457599:     public Row purge(DeletionPurger purger, int nowInSec);
1:2457599: 
1:2457599:     /**
1:fd74a03:      * Returns a copy of this row which only include the data queried by {@code filter}, excluding anything _fetched_ for
1:fd74a03:      * internal reasons but not queried by the user (see {@link ColumnFilter} for details).
1:fd74a03:      *
1:fd74a03:      * @param filter the {@code ColumnFilter} to use when deciding what is user queried. This should be the filter
1:fd74a03:      * that was used when querying the row on which this method is called.
1:fd74a03:      * @return the row but with all data that wasn't queried by the user skipped.
1:fd74a03:      */
1:fd74a03:     public Row withOnlyQueriedData(ColumnFilter filter);
1:fd74a03: 
1:fd74a03:     /**
1:2457599:      * Returns a copy of this row where all counter cells have they "local" shard marked for clearing.
1:2457599:      */
1:2457599:     public Row markCounterLocalToBeCleared();
1:2457599: 
1:2457599:     /**
1:979e559:      * Returns a copy of this row where all live timestamp have been replaced by {@code newTimestamp} and every deletion
1:979e559:      * timestamp by {@code newTimestamp - 1}.
1:979e559:      *
1:979e559:      * @param newTimestamp the timestamp to use for all live data in the returned row.
1:979e559:      *
1:979e559:      * @see Commit for why we need this.
1:2457599:      */
1:2457599:     public Row updateAllTimestamp(long newTimestamp);
1:2457599: 
1:86ba227:     /**
1:86ba227:      * Returns a copy of this row with the new deletion as row deletion if it is more recent
1:86ba227:      * than the current row deletion.
1:86ba227:      * <p>
1:86ba227:      * WARNING: this method <b>does not</b> check that nothing in the row is shadowed by the provided
1:86ba227:      * deletion and if that is the case, the created row will be <b>invalid</b>. It is thus up to the
1:86ba227:      * caller to verify that this is not the case and the only reasonable use case of this is probably
1:86ba227:      * when the row and the deletion comes from the same {@code UnfilteredRowIterator} since that gives
1:86ba227:      * use this guarantee.
1:86ba227:      */
1:86ba227:     public Row withRowDeletion(DeletionTime deletion);
1:86ba227: 
1:2457599:     public int dataSize();
1:2457599: 
1:2457599:     public long unsharedHeapSizeExcludingData();
1:a991b64: 
1:a991b64:     public String toString(CFMetaData metadata, boolean fullDetails);
1:a991b64: 
1:a991b64:     /**
1:dc9ed46:      * Apply a function to every column in a row
1:a991b64:      */
1:dc9ed46:     public void apply(Consumer<ColumnData> function, boolean reverse);
1:a991b64: 
1:a991b64:     /**
1:dc9ed46:      * Apply a funtion to every column in a row until a stop condition is reached
1:a991b64:      */
1:dc9ed46:     public void apply(Consumer<ColumnData> function, Predicate<ColumnData> stopCondition, boolean reverse);
1:a991b64: 
1:a991b64:     /**
1:665f747:      * A row deletion/tombstone.
1:665f747:      * <p>
1:665f747:      * A row deletion mostly consists of the time of said deletion, but there is 2 variants: shadowable
1:665f747:      * and regular row deletion.
1:665f747:      * <p>
1:86ba227:      * A shadowable row deletion only exists if the row has no timestamp. In other words, the deletion is only
1:143a7d9:      * valid as long as no newer insert is done (thus setting a row timestamp; note that if the row timestamp set
1:86ba227:      * is lower than the deletion, it is shadowed (and thus ignored) as usual).
1:86ba227:      * <p>
1:143a7d9:      * That is, if a row has a shadowable deletion with timestamp A and an update is made to that row with a
1:143a7d9:      * timestamp B such that {@code B > A} (and that update sets the row timestamp), then the shadowable deletion is 'shadowed'
1:86ba227:      * by that update. A concrete consequence is that if said update has cells with timestamp lower than A, then those
1:143a7d9:      * cells are preserved(since the deletion is removed), and this is contrary to a normal (regular) deletion where the
1:86ba227:      * deletion is preserved and such cells are removed.
1:665f747:      * <p>
1:665f747:      * Currently, the only use of shadowable row deletions is Materialized Views, see CASSANDRA-10261.
1:665f747:      */
1:665f747:     public static class Deletion
1:665f747:     {
1:665f747:         public static final Deletion LIVE = new Deletion(DeletionTime.LIVE, false);
1:665f747: 
1:665f747:         private final DeletionTime time;
1:665f747:         private final boolean isShadowable;
1:665f747: 
1:665f747:         public Deletion(DeletionTime time, boolean isShadowable)
1:665f747:         {
1:665f747:             assert !time.isLive() || !isShadowable;
1:665f747:             this.time = time;
1:665f747:             this.isShadowable = isShadowable;
1:665f747:         }
1:665f747: 
1:665f747:         public static Deletion regular(DeletionTime time)
1:665f747:         {
1:665f747:             return time.isLive() ? LIVE : new Deletion(time, false);
1:665f747:         }
1:665f747: 
1:665f747:         public static Deletion shadowable(DeletionTime time)
1:665f747:         {
1:665f747:             return new Deletion(time, true);
1:665f747:         }
1:665f747: 
1:665f747:         /**
1:665f747:          * The time of the row deletion.
1:665f747:          *
1:665f747:          * @return the time of the row deletion.
1:665f747:          */
1:665f747:         public DeletionTime time()
1:665f747:         {
1:665f747:             return time;
1:665f747:         }
1:665f747: 
1:665f747:         /**
1:665f747:          * Whether the deletion is a shadowable one or not.
1:665f747:          *
1:665f747:          * @return whether the deletion is a shadowable one. Note that if {@code isLive()}, then this is
1:665f747:          * guarantee to return {@code false}.
1:665f747:          */
1:665f747:         public boolean isShadowable()
1:665f747:         {
1:665f747:             return isShadowable;
1:665f747:         }
1:665f747: 
1:665f747:         /**
1:665f747:          * Wether the deletion is live or not, that is if its an actual deletion or not.
1:665f747:          *
1:665f747:          * @return {@code true} if this represents no deletion of the row, {@code false} if that's an actual
1:665f747:          * deletion.
1:665f747:          */
1:665f747:         public boolean isLive()
1:665f747:         {
1:665f747:             return time().isLive();
1:665f747:         }
1:665f747: 
1:665f747:         public boolean supersedes(DeletionTime that)
1:665f747:         {
1:665f747:             return time.supersedes(that);
1:665f747:         }
1:665f747: 
1:665f747:         public boolean supersedes(Deletion that)
1:665f747:         {
1:665f747:             return time.supersedes(that.time);
1:665f747:         }
1:665f747: 
1:665f747:         public boolean isShadowedBy(LivenessInfo primaryKeyLivenessInfo)
1:665f747:         {
1:665f747:             return isShadowable && primaryKeyLivenessInfo.timestamp() > time.markedForDeleteAt();
1:665f747:         }
1:665f747: 
1:665f747:         public boolean deletes(LivenessInfo info)
1:665f747:         {
1:665f747:             return time.deletes(info);
1:665f747:         }
1:665f747: 
1:86ba227:         public boolean deletes(Cell cell)
1:86ba227:         {
1:86ba227:             return time.deletes(cell);
1:86ba227:         }
1:86ba227: 
1:665f747:         public void digest(MessageDigest digest)
1:665f747:         {
1:665f747:             time.digest(digest);
1:665f747:             FBUtilities.updateWithBoolean(digest, isShadowable);
1:665f747:         }
1:665f747: 
1:665f747:         public int dataSize()
1:665f747:         {
1:665f747:             return time.dataSize() + 1;
1:665f747:         }
1:665f747: 
1:665f747:         @Override
1:665f747:         public boolean equals(Object o)
1:665f747:         {
1:665f747:             if(!(o instanceof Deletion))
1:665f747:                 return false;
1:665f747:             Deletion that = (Deletion)o;
1:665f747:             return this.time.equals(that.time) && this.isShadowable == that.isShadowable;
1:665f747:         }
1:665f747: 
1:665f747:         @Override
1:665f747:         public final int hashCode()
1:665f747:         {
1:665f747:             return Objects.hash(time, isShadowable);
1:665f747:         }
1:665f747: 
1:665f747:         @Override
1:665f747:         public String toString()
1:665f747:         {
1:665f747:             return String.format("%s%s", time, isShadowable ? "(shadowable)" : "");
1:665f747:         }
1:665f747:     }
1:665f747: 
1:665f747:     /**
1:2457599:      * Interface for building rows.
1:a991b64:      * <p>
1:2457599:      * The builder of a row should always abid to the following rules:
1:2457599:      *   1) {@link #newRow} is always called as the first thing for the row.
1:2457599:      *   2) {@link #addPrimaryKeyLivenessInfo} and {@link #addRowDeletion}, if called, are called before
1:2457599:      *      any {@link #addCell}/{@link #addComplexDeletion} call.
1:2457599:      *   3) {@link #build} is called to construct the new row. The builder can then be reused.
1:2457599:      *
1:2457599:      * There is 2 variants of a builder: sorted and unsorted ones. A sorted builder expects user to abid to the
1:2457599:      * following additional rules:
1:2457599:      *   4) Calls to {@link #addCell}/{@link #addComplexDeletion} are done in strictly increasing column order.
1:2457599:      *      In other words, all calls to these methods for a give column {@code c} are done after any call for
1:2457599:      *      any column before {@code c} and before any call for any column after {@code c}.
1:2457599:      *   5) Calls to {@link #addCell} are further done in strictly increasing cell order (the one defined by
1:2457599:      *      {@link Cell#comparator}. That is, for a give column, cells are passed in {@code CellPath} order.
1:86ba227:      *   6) No shadowed data should be added. Concretely, this means that if a a row deletion is added, it doesn't
1:86ba227:      *      deletes the row timestamp or any cell added later, and similarly no cell added is deleted by the complex
1:86ba227:      *      deletion of the column this is a cell of.
1:2457599:      *
1:2457599:      * An unsorted builder will not expect those last rules however: {@link #addCell} and {@link #addComplexDeletion}
1:2457599:      * can be done in any order. And in particular unsorted builder allows multiple calls for the same column/cell. In
1:2457599:      * that latter case, the result will follow the usual reconciliation rules (so equal cells are reconciled with
1:2457599:      * {@link Cells#reconcile} and the "biggest" of multiple complex deletion for the same column wins).
1:dc9ed46:      */
1:2457599:     public interface Builder
1:a991b64:     {
1:dc9ed46:         /**
1:2457599:          * Whether the builder is a sorted one or not.
1:a991b64:          *
1:2457599:          * @return if the builder requires calls to be done in sorted order or not (see above).
1:aa57626:          */
1:2457599:         public boolean isSorted();
1:a991b64: 
1:aa57626:         /**
1:2457599:          * Prepares the builder to build a new row of clustering {@code clustering}.
1:2457599:          * <p>
1:2457599:          * This should always be the first call for a given row.
1:2457599:          *
1:2457599:          * @param clustering the clustering for the new row.
1:2457599:          */
1:2457599:         public void newRow(Clustering clustering);
1:2457599: 
1:2457599:         /**
1:2457599:          * The clustering for the row that is currently being built.
1:2457599:          *
1:2457599:          * @return the clustering for the row that is currently being built, or {@code null} if {@link #newRow} hasn't
1:2457599:          * yet been called.
1:2457599:          */
1:2457599:         public Clustering clustering();
1:2457599: 
1:2457599:         /**
1:2457599:          * Adds the liveness information for the partition key columns of this row.
1:2457599:          *
1:2457599:          * This call is optional (skipping it is equivalent to calling {@code addPartitionKeyLivenessInfo(LivenessInfo.NONE)}).
1:2457599:          *
1:2457599:          * @param info the liveness information for the partition key columns of the built row.
1:2457599:          */
1:2457599:         public void addPrimaryKeyLivenessInfo(LivenessInfo info);
1:2457599: 
1:2457599:         /**
1:2457599:          * Adds the deletion information for this row.
1:a991b64:          *
1:a991b64:          * This call is optional and can be skipped if the row is not deleted.
1:a991b64:          *
1:665f747:          * @param deletion the row deletion time, or {@code Deletion.LIVE} if the row isn't deleted.
1:a991b64:          */
1:665f747:         public void addRowDeletion(Deletion deletion);
1:a991b64: 
1:a991b64:         /**
1:2457599:          * Adds a cell to this builder.
1:a991b64:          *
1:2457599:          * @param cell the cell to add.
1:a991b64:          */
1:2457599:         public void addCell(Cell cell);
1:a991b64: 
1:a991b64:         /**
1:2457599:          * Adds a complex deletion.
1:a991b64:          *
1:2457599:          * @param column the column for which to add the {@code complexDeletion}.
1:2457599:          * @param complexDeletion the complex deletion time to add.
1:a991b64:          */
1:2457599:         public void addComplexDeletion(ColumnDefinition column, DeletionTime complexDeletion);
1:a991b64: 
1:a991b64:         /**
1:2457599:          * Builds and return built row.
1:2457599:          *
1:2457599:          * @return the last row built by this builder.
1:a991b64:          */
1:2457599:         public Row build();
15:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:2683806:      * Row builder interface geared towards human.
1:2683806:      * <p>
1:2683806:      * Where the {@link Builder} deals with building rows efficiently from internal objects ({@code Cell}, {@code
1:2683806:      * LivenessInfo}, ...), the {@code SimpleBuilder} is geared towards building rows from string column name and
1:2683806:      * 'native' values (string for text, ints for numbers, et...). In particular, it is meant to be convenient, not
1:2683806:      * efficient, and should be used only in place where performance is not of the utmost importance (it is used to
1:2683806:      * build schema mutation for instance).
1:2683806:      * <p>
1:2683806:      * Also note that contrarily to {@link Builder}, the {@code SimpleBuilder} API has no {@code newRow()} method: it is
1:2683806:      * expected that the clustering of the row built is provided by the constructor of the builder.
1:2683806:      */
1:2683806:     public interface SimpleBuilder
1:a991b64:     {
1:2683806:         /**
1:2683806:          * Sets the timestamp to use for the following additions.
1:2683806:          * <p>
1:2683806:          * Note that the for non-compact tables, this method must be called before any column addition for this
1:2683806:          * timestamp to be used for the row {@code LivenessInfo}.
1:a991b64:          *
1:2683806:          * @param timestamp the timestamp to use for following additions. If that timestamp hasn't been set, the current
1:2683806:          * time in microseconds will be used.
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder timestamp(long timestamp);
1:a991b64: 
1:2683806:         /**
1:2683806:          * Sets the ttl to use for the following additions.
1:2683806:          * <p>
1:2683806:          * Note that the for non-compact tables, this method must be called before any column addition for this
1:2683806:          * ttl to be used for the row {@code LivenessInfo}.
1:a991b64:          *
1:2683806:          * @param ttl the ttl to use for following additions. If that ttl hasn't been set, no ttl will be used.
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder ttl(int ttl);
1:a991b64: 
1:2683806:         /**
1:2683806:          * Adds a value to a given column.
1:a991b64:          *
1:2683806:          * @param columnName the name of the column for which to add a new value.
1:2683806:          * @param value the value to add, which must be of the proper type for {@code columnName}. This can be {@code
1:2683806:          * null} in which case the this is equivalent to {@code delete(columnName)}.
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder add(String columnName, Object value);
1:a991b64: 
1:2683806:         /**
1:2683806:          * Appends new values to a given non-frozen collection column.
1:2683806:          * <p>
1:2683806:          * This method is similar to {@code add()} but the collection elements added through this method are "appended"
1:2683806:          * to any pre-exising elements. In other words, this is like {@code add()} except that it doesn't delete the
1:2683806:          * previous value of the collection. This can only be called on non-frozen collection columns.
1:2683806:          * <p>
1:2683806:          * Note that this method can be used in replacement of {@code add()} if you know that there can't be any
1:2683806:          * pre-existing value for that column, in which case this is slightly less expensive as it avoid the collection
1:2683806:          * tombstone inherent to {@code add()}.
1:a991b64:          *
1:2683806:          * @param columnName the name of the column for which to add a new value, which must be a non-frozen collection.
1:2683806:          * @param value the value to add, which must be of the proper type for {@code columnName} (in other words, it
1:2683806:          * <b>must</b> be a collection).
1:2683806:          * @return this builder.
1:a991b64:          *
1:2683806:          * @throws IllegalArgumentException if columnName is not a non-frozen collection column.
1:2683806:          */
1:2683806:         public SimpleBuilder appendAll(String columnName, Object value);
1:a991b64: 
1:2683806:         /**
1:2683806:          * Deletes the whole row.
1:2683806:          * <p>
1:2683806:          * If called, this is generally the only method called on the builder (outside of {@code timestamp()}.
1:a991b64:          *
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder delete();
1:a991b64: 
1:2683806:         /**
1:2683806:          * Removes the value for a given column (creating a tombstone).
1:a991b64:          *
1:2683806:          * @param columnName the name of the column to delete.
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder delete(String columnName);
1:a991b64: 
1:2683806:         /**
1:2683806:          * Don't include any primary key {@code LivenessInfo} in the built row.
1:a991b64:          *
1:2683806:          * @return this builder.
1:2683806:          */
1:2683806:         public SimpleBuilder noPrimaryKeyLivenessInfo();
1:a991b64: 
1:2683806:         /**
1:2683806:          * Returns the built row.
1:a991b64:          *
1:2683806:          * @return the built row.
1:2683806:          */
1:2683806:         public Row build();
1:a991b64:     }
1:a991b64: 
1:2683806:     /**
1:a991b64:      * Utility class to help merging rows from multiple inputs (UnfilteredRowIterators).
1:a991b64:      */
1:2457599:     public static class Merger
1:a991b64:     {
1:2457599:         private final Row[] rows;
1:2457599:         private final List<Iterator<ColumnData>> columnDataIterators;
1:a991b64: 
1:a991b64:         private Clustering clustering;
1:a991b64:         private int rowsToMerge;
1:2457599:         private int lastRowSet = -1;
1:a991b64: 
1:2457599:         private final List<ColumnData> dataBuffer = new ArrayList<>();
1:2457599:         private final ColumnDataReducer columnDataReducer;
1:a991b64: 
1:aa57626:         public Merger(int size, int nowInSec, boolean hasComplex)
1:a991b64:         {
1:a991b64:             this.rows = new Row[size];
1:2457599:             this.columnDataIterators = new ArrayList<>(size);
1:aa57626:             this.columnDataReducer = new ColumnDataReducer(size, nowInSec, hasComplex);
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void clear()
1:a991b64:         {
1:2457599:             dataBuffer.clear();
1:a991b64:             Arrays.fill(rows, null);
1:2457599:             columnDataIterators.clear();
1:a991b64:             rowsToMerge = 0;
1:2457599:             lastRowSet = -1;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void add(int i, Row row)
1:a991b64:         {
1:a991b64:             clustering = row.clustering();
1:a991b64:             rows[i] = row;
1:a991b64:             ++rowsToMerge;
1:2457599:             lastRowSet = i;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Row merge(DeletionTime activeDeletion)
1:a991b64:         {
1:a991b64:             // If for this clustering we have only one row version and have no activeDeletion (i.e. nothing to filter out),
1:2457599:             // then we can just return that single row
1:2457599:             if (rowsToMerge == 1 && activeDeletion.isLive())
1:a991b64:             {
1:2457599:                 Row row = rows[lastRowSet];
1:2457599:                 assert row != null;
1:2457599:                 return row;
1:a991b64:             }
1:a991b64: 
1:2457599:             LivenessInfo rowInfo = LivenessInfo.EMPTY;
1:665f747:             Deletion rowDeletion = Deletion.LIVE;
1:2457599:             for (Row row : rows)
1:a991b64:             {
1:2457599:                 if (row == null)
2:a991b64:                     continue;
1:a991b64: 
1:2457599:                 if (row.primaryKeyLivenessInfo().supersedes(rowInfo))
1:2457599:                     rowInfo = row.primaryKeyLivenessInfo();
1:2457599:                 if (row.deletion().supersedes(rowDeletion))
1:2457599:                     rowDeletion = row.deletion();
1:a991b64:             }
1:a991b64: 
1:665f747:             if (rowDeletion.isShadowedBy(rowInfo))
1:665f747:                 rowDeletion = Deletion.LIVE;
1:665f747: 
1:665f747:             if (rowDeletion.supersedes(activeDeletion))
1:665f747:                 activeDeletion = rowDeletion.time();
1:2457599:             else
1:665f747:                 rowDeletion = Deletion.LIVE;
1:a991b64: 
1:a991b64:             if (activeDeletion.deletes(rowInfo))
1:2457599:                 rowInfo = LivenessInfo.EMPTY;
1:a991b64: 
1:2457599:             for (Row row : rows)
1:2457599:                 columnDataIterators.add(row == null ? Collections.emptyIterator() : row.iterator());
1:a991b64: 
1:2457599:             columnDataReducer.setActiveDeletion(activeDeletion);
1:2457599:             Iterator<ColumnData> merged = MergeIterator.get(columnDataIterators, ColumnData.comparator, columnDataReducer);
1:2457599:             while (merged.hasNext())
1:a991b64:             {
1:2457599:                 ColumnData data = merged.next();
1:2457599:                 if (data != null)
1:2457599:                     dataBuffer.add(data);
1:a991b64:             }
1:a991b64: 
1:2457599:             // Because some data might have been shadowed by the 'activeDeletion', we could have an empty row
1:2457599:             return rowInfo.isEmpty() && rowDeletion.isLive() && dataBuffer.isEmpty()
1:2457599:                  ? null
1:aa57626:                  : BTreeRow.create(clustering, rowInfo, rowDeletion, BTree.build(dataBuffer, UpdateFunction.<ColumnData>noOp()));
1:a991b64:         }
1:a991b64: 
1:2457599:         public Clustering mergedClustering()
1:a991b64:         {
1:2457599:             return clustering;
1:a991b64:         }
1:a991b64: 
1:2457599:         public Row[] mergedRows()
1:a991b64:         {
1:2457599:             return rows;
1:a991b64:         }
1:a991b64: 
1:2457599:         private static class ColumnDataReducer extends MergeIterator.Reducer<ColumnData, ColumnData>
1:a991b64:         {
1:2457599:             private final int nowInSec;
1:a991b64: 
1:a991b64:             private ColumnDefinition column;
1:2457599:             private final List<ColumnData> versions;
1:a991b64: 
1:2457599:             private DeletionTime activeDeletion;
1:2457599: 
1:2457599:             private final ComplexColumnData.Builder complexBuilder;
1:2457599:             private final List<Iterator<Cell>> complexCells;
1:2457599:             private final CellReducer cellReducer;
1:2457599: 
1:2457599:             public ColumnDataReducer(int size, int nowInSec, boolean hasComplex)
1:a991b64:             {
1:2457599:                 this.nowInSec = nowInSec;
1:2457599:                 this.versions = new ArrayList<>(size);
1:2457599:                 this.complexBuilder = hasComplex ? ComplexColumnData.builder() : null;
1:2457599:                 this.complexCells = hasComplex ? new ArrayList<>(size) : null;
1:2457599:                 this.cellReducer = new CellReducer(nowInSec);
1:a991b64:             }
1:a991b64: 
1:2457599:             public void setActiveDeletion(DeletionTime activeDeletion)
1:a991b64:             {
1:2457599:                 this.activeDeletion = activeDeletion;
1:2457599:             }
1:2457599: 
1:2457599:             public void reduce(int idx, ColumnData data)
1:2457599:             {
1:2457599:                 column = data.column();
1:2457599:                 versions.add(data);
1:2457599:             }
1:2457599: 
1:2457599:             protected ColumnData getReduced()
1:2457599:             {
1:2457599:                 if (column.isSimple())
1:2457599:                 {
1:2457599:                     Cell merged = null;
1:2457599:                     for (ColumnData data : versions)
1:2457599:                     {
1:2457599:                         Cell cell = (Cell)data;
1:2457599:                         if (!activeDeletion.deletes(cell))
1:2457599:                             merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);
1:2457599:                     }
1:2457599:                     return merged;
1:2457599:                 }
1:2457599:                 else
1:2457599:                 {
1:2457599:                     complexBuilder.newColumn(column);
1:2457599:                     complexCells.clear();
1:2457599:                     DeletionTime complexDeletion = DeletionTime.LIVE;
1:2457599:                     for (ColumnData data : versions)
1:2457599:                     {
1:2457599:                         ComplexColumnData cd = (ComplexColumnData)data;
1:2457599:                         if (cd.complexDeletion().supersedes(complexDeletion))
1:2457599:                             complexDeletion = cd.complexDeletion();
1:2457599:                         complexCells.add(cd.iterator());
1:2457599:                     }
1:2457599: 
1:2457599:                     if (complexDeletion.supersedes(activeDeletion))
1:2457599:                     {
1:2457599:                         cellReducer.setActiveDeletion(complexDeletion);
1:2457599:                         complexBuilder.addComplexDeletion(complexDeletion);
1:2457599:                     }
1:2457599:                     else
1:2457599:                     {
1:2457599:                         cellReducer.setActiveDeletion(activeDeletion);
1:2457599:                     }
1:2457599: 
1:6818ba9:                     Iterator<Cell> cells = MergeIterator.get(complexCells, Cell.comparator, cellReducer);
1:2457599:                     while (cells.hasNext())
1:2457599:                     {
1:2457599:                         Cell merged = cells.next();
1:2457599:                         if (merged != null)
1:2457599:                             complexBuilder.addCell(merged);
1:2457599:                     }
1:2457599:                     return complexBuilder.build();
1:2457599:                 }
1:a991b64:             }
1:a991b64: 
1:a991b64:             protected void onKeyChange()
1:a991b64:             {
1:2457599:                 versions.clear();
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:2457599:         private static class CellReducer extends MergeIterator.Reducer<Cell, Cell>
1:a991b64:         {
1:2457599:             private final int nowInSec;
1:a991b64: 
1:2457599:             private DeletionTime activeDeletion;
1:2457599:             private Cell merged;
1:2457599: 
1:2457599:             public CellReducer(int nowInSec)
1:a991b64:             {
1:2457599:                 this.nowInSec = nowInSec;
1:a991b64:             }
1:a991b64: 
1:2457599:             public void setActiveDeletion(DeletionTime activeDeletion)
1:a991b64:             {
1:2457599:                 this.activeDeletion = activeDeletion;
1:2457599:                 onKeyChange();
1:a991b64:             }
1:a991b64: 
1:2457599:             public void reduce(int idx, Cell cell)
1:a991b64:             {
1:2457599:                 if (!activeDeletion.deletes(cell))
1:2457599:                     merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);
1:a991b64:             }
1:a991b64: 
1:2457599:             protected Cell getReduced()
1:a991b64:             {
1:2457599:                 return merged;
1:a991b64:             }
1:a991b64: 
1:2457599:             protected void onKeyChange()
1:a991b64:             {
1:2457599:                 merged = null;
1:a991b64:             }
1:a991b64:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:143a7d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * valid as long as no newer insert is done (thus setting a row timestamp; note that if the row timestamp set
1:      * That is, if a row has a shadowable deletion with timestamp A and an update is made to that row with a
1:      * timestamp B such that {@code B > A} (and that update sets the row timestamp), then the shadowable deletion is 'shadowed'
1:      * cells are preserved(since the deletion is removed), and this is contrary to a normal (regular) deletion where the
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4e21f72
commit:b603720
commit:43d726b
commit:979e559
/////////////////////////////////////////////////////////////////////////
1:      * @return this row but without any deletion info purged by {@code purger}. If the purged row is empty, returns
1:      * {@code null}.
/////////////////////////////////////////////////////////////////////////
1:      * Returns a copy of this row where all live timestamp have been replaced by {@code newTimestamp} and every deletion
1:      * timestamp by {@code newTimestamp - 1}.
1:      *
1:      * @param newTimestamp the timestamp to use for all live data in the returned row.
0:      * @param a copy of this row with timestamp updated using {@code newTimestamp}. This can return {@code null} in the
0:      * rare where the row only as a shadowable row deletion and the new timestamp supersedes it.
1:      *
1:      * @see Commit for why we need this.
commit:a87fd71
commit:86ba227
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a copy of this row with the new deletion as row deletion if it is more recent
1:      * than the current row deletion.
1:      * <p>
1:      * WARNING: this method <b>does not</b> check that nothing in the row is shadowed by the provided
1:      * deletion and if that is the case, the created row will be <b>invalid</b>. It is thus up to the
1:      * caller to verify that this is not the case and the only reasonable use case of this is probably
1:      * when the row and the deletion comes from the same {@code UnfilteredRowIterator} since that gives
1:      * use this guarantee.
1:      */
1:     public Row withRowDeletion(DeletionTime deletion);
1: 
/////////////////////////////////////////////////////////////////////////
1:      * A shadowable row deletion only exists if the row has no timestamp. In other words, the deletion is only
0:      * valid as long as no newer insert is done (thus setting a row timestap; note that if the row timestamp set
1:      * is lower than the deletion, it is shadowed (and thus ignored) as usual).
1:      * <p>
0:      * That is, if a row has a shadowable deletion with timestamp A and an update is madeto that row with a
0:      * timestamp B such that B > A (and that update sets the row timestamp), then the shadowable deletion is 'shadowed'
1:      * by that update. A concrete consequence is that if said update has cells with timestamp lower than A, then those
0:      * cells are preserved(since the deletion is removed), and this contrarily to a normal (regular) deletion where the
1:      * deletion is preserved and such cells are removed.
/////////////////////////////////////////////////////////////////////////
1:         public boolean deletes(Cell cell)
1:         {
1:             return time.deletes(cell);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      *   6) No shadowed data should be added. Concretely, this means that if a a row deletion is added, it doesn't
1:      *      deletes the row timestamp or any cell added later, and similarly no cell added is deleted by the complex
1:      *      deletion of the column this is a cell of.
commit:fd74a03
/////////////////////////////////////////////////////////////////////////
1:      * Returns a copy of this row which only include the data queried by {@code filter}, excluding anything _fetched_ for
1:      * internal reasons but not queried by the user (see {@link ColumnFilter} for details).
1:      *
1:      * @param filter the {@code ColumnFilter} to use when deciding what is user queried. This should be the filter
1:      * that was used when querying the row on which this method is called.
1:      * @return the row but with all data that wasn't queried by the user skipped.
1:      */
1:     public Row withOnlyQueriedData(ColumnFilter filter);
1: 
1:     /**
commit:12b6c0a
/////////////////////////////////////////////////////////////////////////
0:          * Adds the liveness information for the primary key columns of this row.
0:          * @param info the liveness information for the primary key columns of the built row.
commit:b99c863
/////////////////////////////////////////////////////////////////////////
1:      * @param reversed if cells should returned in reverse order.
1:     public Iterable<Cell> cellsInLegacyOrder(CFMetaData metadata, boolean reversed);
commit:665f747
/////////////////////////////////////////////////////////////////////////
1: import java.security.MessageDigest;
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
1:     public Deletion deletion();
/////////////////////////////////////////////////////////////////////////
1:      * A row deletion/tombstone.
1:      * <p>
1:      * A row deletion mostly consists of the time of said deletion, but there is 2 variants: shadowable
1:      * and regular row deletion.
1:      * <p>
0:      * A shadowable row deletion only exists if the row timestamp ({@code primaryKeyLivenessInfo().timestamp()})
0:      * is lower than the deletion timestamp. That is, if a row has a shadowable deletion with timestamp A and an update is made
0:      * to that row with a timestamp B such that B > A, then the shadowable deletion is 'shadowed' by that update. A concrete
0:      * consequence is that if said update has cells with timestamp lower than A, then those cells are preserved
0:      * (since the deletion is removed), and this contrarily to a normal (regular) deletion where the deletion is preserved
0:      * and such cells are removed.
1:      * <p>
1:      * Currently, the only use of shadowable row deletions is Materialized Views, see CASSANDRA-10261.
1:      */
1:     public static class Deletion
1:     {
1:         public static final Deletion LIVE = new Deletion(DeletionTime.LIVE, false);
1: 
1:         private final DeletionTime time;
1:         private final boolean isShadowable;
1: 
1:         public Deletion(DeletionTime time, boolean isShadowable)
1:         {
1:             assert !time.isLive() || !isShadowable;
1:             this.time = time;
1:             this.isShadowable = isShadowable;
1:         }
1: 
1:         public static Deletion regular(DeletionTime time)
1:         {
1:             return time.isLive() ? LIVE : new Deletion(time, false);
1:         }
1: 
1:         public static Deletion shadowable(DeletionTime time)
1:         {
1:             return new Deletion(time, true);
1:         }
1: 
1:         /**
1:          * The time of the row deletion.
1:          *
1:          * @return the time of the row deletion.
1:          */
1:         public DeletionTime time()
1:         {
1:             return time;
1:         }
1: 
1:         /**
1:          * Whether the deletion is a shadowable one or not.
1:          *
1:          * @return whether the deletion is a shadowable one. Note that if {@code isLive()}, then this is
1:          * guarantee to return {@code false}.
1:          */
1:         public boolean isShadowable()
1:         {
1:             return isShadowable;
1:         }
1: 
1:         /**
1:          * Wether the deletion is live or not, that is if its an actual deletion or not.
1:          *
1:          * @return {@code true} if this represents no deletion of the row, {@code false} if that's an actual
1:          * deletion.
1:          */
1:         public boolean isLive()
1:         {
1:             return time().isLive();
1:         }
1: 
1:         public boolean supersedes(DeletionTime that)
1:         {
1:             return time.supersedes(that);
1:         }
1: 
1:         public boolean supersedes(Deletion that)
1:         {
1:             return time.supersedes(that.time);
1:         }
1: 
1:         public boolean isShadowedBy(LivenessInfo primaryKeyLivenessInfo)
1:         {
1:             return isShadowable && primaryKeyLivenessInfo.timestamp() > time.markedForDeleteAt();
1:         }
1: 
1:         public boolean deletes(LivenessInfo info)
1:         {
1:             return time.deletes(info);
1:         }
1: 
1:         public void digest(MessageDigest digest)
1:         {
1:             time.digest(digest);
1:             FBUtilities.updateWithBoolean(digest, isShadowable);
1:         }
1: 
1:         public int dataSize()
1:         {
1:             return time.dataSize() + 1;
1:         }
1: 
1:         @Override
1:         public boolean equals(Object o)
1:         {
1:             if(!(o instanceof Deletion))
1:                 return false;
1:             Deletion that = (Deletion)o;
1:             return this.time.equals(that.time) && this.isShadowable == that.isShadowable;
1:         }
1: 
1:         @Override
1:         public final int hashCode()
1:         {
1:             return Objects.hash(time, isShadowable);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return String.format("%s%s", time, isShadowable ? "(shadowable)" : "");
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:          * @param deletion the row deletion time, or {@code Deletion.LIVE} if the row isn't deleted.
1:         public void addRowDeletion(Deletion deletion);
/////////////////////////////////////////////////////////////////////////
1:             Deletion rowDeletion = Deletion.LIVE;
/////////////////////////////////////////////////////////////////////////
1:             if (rowDeletion.isShadowedBy(rowInfo))
1:                 rowDeletion = Deletion.LIVE;
1: 
1:             if (rowDeletion.supersedes(activeDeletion))
1:                 activeDeletion = rowDeletion.time();
1:                 rowDeletion = Deletion.LIVE;
commit:2457599
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.filter.ColumnFilter;
1: import org.apache.cassandra.service.paxos.Commit;
1:  * A row mainly contains the following informations:
1:  *   1) Its {@code Clustering}, which holds the values for the clustering columns identifying the row.
1:  *   2) Its row level informations: the primary key liveness infos and the row deletion (see
1:  *      {@link #primaryKeyLivenessInfo()} and {@link #deletion()} for more details).
1:  *   3) Data for the columns it contains, or in other words, it's a (sorted) collection of
1:  *      {@code ColumnData}.
1:  * Also note that as for every other storage engine object, a {@code Row} object cannot shadow
1:  * it's own data. For instance, a {@code Row} cannot contains a cell that is deleted by its own
1:  * row deletion.
0: public interface Row extends Unfiltered, Iterable<ColumnData>
/////////////////////////////////////////////////////////////////////////
1:      * info is empty) and a live row but where all non PK columns are null (it has no
1:      * live cells, but its primary key liveness is not empty). Please note that the liveness
1:      * info (including it's eventually ttl/local deletion time) only apply to the primary key
1:      * columns and has no impact on the row content.
1:      * Note in particular that a row may have live cells but no PK liveness info, because the
1:      * primary key liveness informations are only set on {@code INSERT} (which makes sense
1:      * in itself, see #6782) but live cells can be added through {@code UPDATE} even if the row
/////////////////////////////////////////////////////////////////////////
1:      * Whether the row has no information whatsoever. This means no PK liveness info, no row
1:      * deletion, no cells and no complex deletion info.
1:      * @return {@code true} if the row has no data, {@code false} otherwise.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * The data for a complex column.
1:      * <p>
1:      * The returned object groups all the cells for the column, as well as it's complex deletion (if relevant).
1:      * @param c the complex column for which to return the complex data.
1:      * @return the data for {@code c} or {@code null} is the row has no data for this column.
1:     public ComplexColumnData getComplexColumnData(ColumnDefinition c);
1:      * An iterable over the cells of this row.
1:      * <p>
1:      * The iterable guarantees that cells are returned in order of {@link Cell#comparator}.
1:      * @return an iterable over the cells of this row.
1:     public Iterable<Cell> cells();
1:      * Whether the row stores any (non-live) complex deletion for any complex column.
1:     public boolean hasComplexDeletion();
1: 
1:     /**
1:      * Whether the row has any deletion info (row deletion, cell tombstone, expired cell or complex deletion).
1:      *
1:      * @param nowInSec the current time in seconds to decid if a cell is expired.
1:      */
1:     public boolean hasDeletion(int nowInSec);
/////////////////////////////////////////////////////////////////////////
1:      * Returns a copy of this row that:
1:      *   1) only includes the data for the column included by {@code filter}.
1:      *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
1:     public Row filter(ColumnFilter filter, CFMetaData metadata);
1: 
1:     /**
1:      * Returns a copy of this row that:
1:      *   1) only includes the data for the column included by {@code filter}.
1:      *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
1:      *   3) doesn't include any data that is shadowed/deleted by {@code activeDeletion}.
1:      *   4) uses {@code activeDeletion} as row deletion iff {@code setActiveDeletionToRow} and {@code activeDeletion} supersedes the row deletion.
1:      */
1:     public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setActiveDeletionToRow, CFMetaData metadata);
1: 
1:     /**
1:      * Returns a copy of this row without any deletion info that should be purged according to {@code purger}.
1:      *
1:      * @param purger the {@code DeletionPurger} to use to decide what can be purged.
1:      * @param nowInSec the current time to decide what is deleted and what isn't (in the case of expired cells).
0:      * @return this row but without any deletion info purged by {@code purger}.
1:      */
1:     public Row purge(DeletionPurger purger, int nowInSec);
1: 
1:     /**
1:      * Returns a copy of this row where all counter cells have they "local" shard marked for clearing.
1:      */
1:     public Row markCounterLocalToBeCleared();
1: 
1:     /**
0:      * returns a copy of this row where all live timestamp have been replaced by {@code newTimestamp} and every deletion timestamp
0:      * by {@code newTimestamp - 1}. See {@link Commit} for why we need this.
1:      */
1:     public Row updateAllTimestamp(long newTimestamp);
1: 
1:     public int dataSize();
1: 
1:     public long unsharedHeapSizeExcludingData();
1:      * Interface for building rows.
1:      * The builder of a row should always abid to the following rules:
1:      *   1) {@link #newRow} is always called as the first thing for the row.
1:      *   2) {@link #addPrimaryKeyLivenessInfo} and {@link #addRowDeletion}, if called, are called before
1:      *      any {@link #addCell}/{@link #addComplexDeletion} call.
1:      *   3) {@link #build} is called to construct the new row. The builder can then be reused.
1:      *
1:      * There is 2 variants of a builder: sorted and unsorted ones. A sorted builder expects user to abid to the
1:      * following additional rules:
1:      *   4) Calls to {@link #addCell}/{@link #addComplexDeletion} are done in strictly increasing column order.
1:      *      In other words, all calls to these methods for a give column {@code c} are done after any call for
1:      *      any column before {@code c} and before any call for any column after {@code c}.
1:      *   5) Calls to {@link #addCell} are further done in strictly increasing cell order (the one defined by
1:      *      {@link Cell#comparator}. That is, for a give column, cells are passed in {@code CellPath} order.
1:      *
1:      * An unsorted builder will not expect those last rules however: {@link #addCell} and {@link #addComplexDeletion}
1:      * can be done in any order. And in particular unsorted builder allows multiple calls for the same column/cell. In
1:      * that latter case, the result will follow the usual reconciliation rules (so equal cells are reconciled with
1:      * {@link Cells#reconcile} and the "biggest" of multiple complex deletion for the same column wins).
1:     public interface Builder
1:          * Whether the builder is a sorted one or not.
1:          * @return if the builder requires calls to be done in sorted order or not (see above).
1:         public boolean isSorted();
1:          * Prepares the builder to build a new row of clustering {@code clustering}.
1:          * <p>
1:          * This should always be the first call for a given row.
1:          *
1:          * @param clustering the clustering for the new row.
1:          */
1:         public void newRow(Clustering clustering);
1: 
1:         /**
1:          * The clustering for the row that is currently being built.
1:          *
1:          * @return the clustering for the row that is currently being built, or {@code null} if {@link #newRow} hasn't
1:          * yet been called.
1:          */
1:         public Clustering clustering();
1: 
1:         /**
1:          * Adds the liveness information for the partition key columns of this row.
1:          *
1:          * This call is optional (skipping it is equivalent to calling {@code addPartitionKeyLivenessInfo(LivenessInfo.NONE)}).
1:          *
1:          * @param info the liveness information for the partition key columns of the built row.
1:          */
1:         public void addPrimaryKeyLivenessInfo(LivenessInfo info);
1: 
1:         /**
1:          * Adds the deletion information for this row.
0:         public void addRowDeletion(DeletionTime deletion);
1:          * Adds a cell to this builder.
1:          * @param cell the cell to add.
1:         public void addCell(Cell cell);
1:          * Adds a complex deletion.
1:          * @param column the column for which to add the {@code complexDeletion}.
1:          * @param complexDeletion the complex deletion time to add.
1:         public void addComplexDeletion(ColumnDefinition column, DeletionTime complexDeletion);
1:          * Builds and return built row.
1:          *
1:          * @return the last row built by this builder.
1:         public Row build();
1:     public static class Merger
1:         private final Row[] rows;
1:         private final List<Iterator<ColumnData>> columnDataIterators;
1:         private int lastRowSet = -1;
1:         private final List<ColumnData> dataBuffer = new ArrayList<>();
1:         private final ColumnDataReducer columnDataReducer;
0:         public Merger(int size, int nowInSec, Columns columns)
1:             this.columnDataIterators = new ArrayList<>(size);
0:             this.columnDataReducer = new ColumnDataReducer(size, nowInSec, columns.hasComplex());
1:             dataBuffer.clear();
1:             columnDataIterators.clear();
1:             lastRowSet = -1;
/////////////////////////////////////////////////////////////////////////
1:             lastRowSet = i;
1:             // then we can just return that single row
1:             if (rowsToMerge == 1 && activeDeletion.isLive())
1:                 Row row = rows[lastRowSet];
1:                 assert row != null;
1:                 return row;
1:             LivenessInfo rowInfo = LivenessInfo.EMPTY;
0:             DeletionTime rowDeletion = DeletionTime.LIVE;
1:             for (Row row : rows)
1:                 if (row == null)
1:                 if (row.primaryKeyLivenessInfo().supersedes(rowInfo))
1:                     rowInfo = row.primaryKeyLivenessInfo();
1:                 if (row.deletion().supersedes(rowDeletion))
1:                     rowDeletion = row.deletion();
0:             if (activeDeletion.supersedes(rowDeletion))
0:                 rowDeletion = DeletionTime.LIVE;
1:             else
1:                 rowInfo = LivenessInfo.EMPTY;
1:             for (Row row : rows)
1:                 columnDataIterators.add(row == null ? Collections.emptyIterator() : row.iterator());
1:             columnDataReducer.setActiveDeletion(activeDeletion);
1:             Iterator<ColumnData> merged = MergeIterator.get(columnDataIterators, ColumnData.comparator, columnDataReducer);
1:             while (merged.hasNext())
1:                 ColumnData data = merged.next();
1:                 if (data != null)
1:                     dataBuffer.add(data);
1:             // Because some data might have been shadowed by the 'activeDeletion', we could have an empty row
1:             return rowInfo.isEmpty() && rowDeletion.isLive() && dataBuffer.isEmpty()
1:                  ? null
0:                  : ArrayBackedRow.create(clustering, columns, rowInfo, rowDeletion, dataBuffer.size(), dataBuffer.toArray(new ColumnData[dataBuffer.size()]));
1:         public Clustering mergedClustering()
1:             return clustering;
1:         public Row[] mergedRows()
1:             return rows;
1:         private static class ColumnDataReducer extends MergeIterator.Reducer<ColumnData, ColumnData>
1:             private final int nowInSec;
1:             private final List<ColumnData> versions;
1:             private DeletionTime activeDeletion;
1: 
1:             private final ComplexColumnData.Builder complexBuilder;
1:             private final List<Iterator<Cell>> complexCells;
1:             private final CellReducer cellReducer;
1: 
1:             public ColumnDataReducer(int size, int nowInSec, boolean hasComplex)
1:                 this.nowInSec = nowInSec;
1:                 this.versions = new ArrayList<>(size);
1:                 this.complexBuilder = hasComplex ? ComplexColumnData.builder() : null;
1:                 this.complexCells = hasComplex ? new ArrayList<>(size) : null;
1:                 this.cellReducer = new CellReducer(nowInSec);
1:             public void setActiveDeletion(DeletionTime activeDeletion)
1:                 this.activeDeletion = activeDeletion;
1:             }
1: 
1:             public void reduce(int idx, ColumnData data)
1:             {
1:                 column = data.column();
1:                 versions.add(data);
1:             }
1: 
1:             protected ColumnData getReduced()
1:             {
1:                 if (column.isSimple())
1:                 {
1:                     Cell merged = null;
1:                     for (ColumnData data : versions)
1:                     {
1:                         Cell cell = (Cell)data;
1:                         if (!activeDeletion.deletes(cell))
1:                             merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);
1:                     }
1:                     return merged;
1:                 }
1:                 else
1:                 {
1:                     complexBuilder.newColumn(column);
1:                     complexCells.clear();
1:                     DeletionTime complexDeletion = DeletionTime.LIVE;
1:                     for (ColumnData data : versions)
1:                     {
1:                         ComplexColumnData cd = (ComplexColumnData)data;
1:                         if (cd.complexDeletion().supersedes(complexDeletion))
1:                             complexDeletion = cd.complexDeletion();
1:                         complexCells.add(cd.iterator());
1:                     }
1: 
1:                     if (complexDeletion.supersedes(activeDeletion))
1:                     {
1:                         cellReducer.setActiveDeletion(complexDeletion);
1:                         complexBuilder.addComplexDeletion(complexDeletion);
1:                     }
1:                     else
1:                     {
1:                         cellReducer.setActiveDeletion(activeDeletion);
1:                     }
1: 
0:                     Iterator<Cell> cells = MergeIterator.get(complexCells, ColumnData.cellComparator, cellReducer);
1:                     while (cells.hasNext())
1:                     {
1:                         Cell merged = cells.next();
1:                         if (merged != null)
1:                             complexBuilder.addCell(merged);
1:                     }
1:                     return complexBuilder.build();
1:                 }
1:                 versions.clear();
1:         private static class CellReducer extends MergeIterator.Reducer<Cell, Cell>
1:             private final int nowInSec;
1:             private DeletionTime activeDeletion;
1:             private Cell merged;
1: 
1:             public CellReducer(int nowInSec)
1:                 this.nowInSec = nowInSec;
1:             public void setActiveDeletion(DeletionTime activeDeletion)
1:                 this.activeDeletion = activeDeletion;
1:                 onKeyChange();
1:             public void reduce(int idx, Cell cell)
1:                 if (!activeDeletion.deletes(cell))
1:                     merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);
1:             protected Cell getReduced()
1:                 return merged;
1:             protected void onKeyChange()
1:                 merged = null;
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.rows;
1: 
0: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
0: import com.google.common.collect.Iterators;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.utils.MergeIterator;
1: import org.apache.cassandra.utils.SearchIterator;
1: 
1: /**
1:  * Storage engine representation of a row.
1:  *
0:  * A row is identified by it's clustering column values (it's an Unfiltered),
0:  * has row level informations (deletion and partition key liveness infos (see below))
0:  * and contains data (Cells) regarding the columns it contains.
1:  *
0:  * A row implements {@code WithLivenessInfo} and has thus a timestamp, ttl and
0:  * local deletion time. Those information do not apply to the row content, they
0:  * apply to the partition key columns. In other words, the timestamp is the
0:  * timestamp for the partition key columns: it is what allows to distinguish
0:  * between a dead row, and a live row but for which only the partition key columns
0:  * are set. The ttl and local deletion time information are for the case where
0:  * a TTL is set on those partition key columns. Note however that a row can have
0:  * live cells but no partition key columns timestamp, because said timestamp (and
0:  * its corresponding ttl) is only set on INSERT (not UPDATE).
1:  */
0: public interface Row extends Unfiltered, Iterable<Cell>, Aliasable<Row>
1: {
1:     /**
1:      * The clustering values for this row.
1:      */
1:     @Override
1:     public Clustering clustering();
1: 
1:     /**
0:      * The columns this row contains.
1:      *
0:      * Note that this is actually a superset of the columns the row contains. The row
0:      * may not have values for each of those columns, but it can't have values for other
0:      * columns.
1:      *
0:      * @return a superset of the columns contained in this row.
1:      */
0:     public Columns columns();
1: 
1:     /**
1:      * The row deletion.
1:      *
1:      * This correspond to the last row deletion done on this row.
1:      *
1:      * @return the row deletion.
1:      */
0:     public DeletionTime deletion();
1: 
1:     /**
1:      * Liveness information for the primary key columns of this row.
1:      * <p>
1:      * As a row is uniquely identified by its primary key, all its primary key columns
1:      * share the same {@code LivenessInfo}. This liveness information is what allows us
1:      * to distinguish between a dead row (it has no live cells and its primary key liveness
0:      * info has no timestamp) and a live row but where all non PK columns are null (it has no
0:      * live cells, but its primary key liveness has a timestamp). Please note that the ttl
0:      * (and local deletion time) of the PK liveness information only apply to the
0:      * liveness info timestamp, and not to the content of the row. Also note that because
0:      * in practice there is not way to only delete the primary key columns (without deleting
0:      * the row itself), the returned {@code LivenessInfo} can only have a local deletion time
0:      * if it has a TTL.
1:      * <p>
0:      * Lastly, note that it is possible for a row to have live cells but no PK liveness
0:      * info timestamp, because said timestamp is only set on {@code INSERT} (which makes sense
0:      * in itself, see #6782) but live cells can be add through {@code UPDATE} even if the row
1:      * wasn't pre-existing (which users are encouraged not to do, but we can't validate).
1:      */
1:     public LivenessInfo primaryKeyLivenessInfo();
1: 
1:     /**
1:      * Whether the row correspond to a static row or not.
1:      *
1:      * @return whether the row correspond to a static row or not.
1:      */
1:     public boolean isStatic();
1: 
1:     /**
0:      * Whether the row has no information whatsoever. This means no row infos
0:      * (timestamp, ttl, deletion), no cells and no complex deletion info.
1:      *
0:      * @return {@code true} if the row has no data whatsoever, {@code false} otherwise.
1:      */
1:     public boolean isEmpty();
1: 
1:     /**
1:      * Whether the row has some live information (i.e. it's not just deletion informations).
1:      */
1:     public boolean hasLiveData(int nowInSec);
1: 
1:     /**
0:      * Whether or not this row contains any deletion for a complex column. That is if
0:      * there is at least one column for which {@code getDeletion} returns a non
0:      * live deletion time.
1:      */
0:     public boolean hasComplexDeletion();
1: 
1:     /**
1:      * Returns a cell for a simple column.
1:      *
0:      * Calls to this method are allowed to return the same Cell object, and hence the returned
0:      * object is only valid until the next getCell/getCells call on the same Row object. You will need
0:      * to copy the returned data if you plan on using a reference to the Cell object
0:      * longer than that.
1:      *
1:      * @param c the simple column for which to fetch the cell.
1:      * @return the corresponding cell or {@code null} if the row has no such cell.
1:      */
1:     public Cell getCell(ColumnDefinition c);
1: 
1:     /**
1:      * Return a cell for a given complex column and cell path.
1:      *
0:      * Calls to this method are allowed to return the same Cell object, and hence the returned
0:      * object is only valid until the next getCell/getCells call on the same Row object. You will need
0:      * to copy the returned data if you plan on using a reference to the Cell object
0:      * longer than that.
1:      *
1:      * @param c the complex column for which to fetch the cell.
1:      * @param path the cell path for which to fetch the cell.
1:      * @return the corresponding cell or {@code null} if the row has no such cell.
1:      */
1:     public Cell getCell(ColumnDefinition c, CellPath path);
1: 
1:     /**
0:      * Returns an iterator on the cells of a complex column c.
1:      *
0:      * Calls to this method are allowed to return the same iterator object, and
0:      * hence the returned object is only valid until the next getCell/getCells call
0:      * on the same Row object. You will need to copy the returned data if you
0:      * plan on using a reference to the Cell object longer than that.
1:      *
0:      * @param c the complex column for which to fetch the cells.
0:      * @return an iterator on the cells of complex column {@code c} or {@code null} if the row has no
0:      * cells for that column.
1:      */
0:     public Iterator<Cell> getCells(ColumnDefinition c);
1: 
1:     /**
0:      * Deletion informations for complex columns.
1:      *
0:      * @param c the complex column for which to fetch deletion info.
0:      * @return the deletion time for complex column {@code c} in this row.
1:      */
0:     public DeletionTime getDeletion(ColumnDefinition c);
1: 
1:     /**
0:      * An iterator over the cells of this row.
1:      *
0:      * The iterator guarantees that for 2 rows of the same partition, columns
0:      * are returned in a consistent order in the sense that if the cells for
0:      * column c1 is returned before the cells for column c2 by the first iterator,
0:      * it is also the case for the 2nd iterator.
1:      *
0:      * The object returned by a call to next() is only guaranteed to be valid until
0:      * the next call to hasNext() or next(). If a consumer wants to keep a
0:      * reference on the returned Cell objects for longer than the iteration, it must
0:      * make a copy of it explicitly.
1:      *
0:      * @return an iterator over the cells of this row.
1:      */
0:     public Iterator<Cell> iterator();
1: 
1:     /**
1:      * An iterator to efficiently search data for a given column.
1:      *
1:      * @return a search iterator for the cells of this row.
1:      */
1:     public SearchIterator<ColumnDefinition, ColumnData> searchIterator();
1: 
1:     /**
0:      * Copy this row to the provided writer.
1:      *
0:      * @param writer the row writer to write this row to.
1:      */
0:     public void copyTo(Row.Writer writer);
1: 
1:     public String toString(CFMetaData metadata, boolean fullDetails);
1: 
1:     /**
0:      * Interface for writing a row.
1:      * <p>
0:      * Clients of this interface should abid to the following assumptions:
0:      *   1) if the row has a non empty clustering (it's not a static one and it doesn't belong to a table without
0:      *      clustering columns), then that clustering should be the first thing written (through
0:      *      {@link ClusteringPrefix.Writer#writeClusteringValue})).
0:      *   2) for a given complex column, calls to {@link #writeCell} are performed consecutively (without
0:      *      any call to {@code writeCell} for another column intermingled) and in {@code CellPath} order.
0:      *   3) {@link #endOfRow} is always called to end the writing of a given row.
1:      */
0:     public interface Writer extends ClusteringPrefix.Writer
1:     {
1:         /**
0:          * Writes the livness information for the partition key columns of this row.
1:          *
0:          * This call is optional: skipping it is equivalent to calling {@code writePartitionKeyLivenessInfo(LivenessInfo.NONE)}.
1:          *
0:          * @param info the liveness information for the partition key columns of the written row.
1:          */
0:         public void writePartitionKeyLivenessInfo(LivenessInfo info);
1: 
1:         /**
0:          * Writes the deletion information for this row.
1:          *
1:          * This call is optional and can be skipped if the row is not deleted.
1:          *
0:          * @param deletion the row deletion time, or {@code DeletionTime.LIVE} if the row isn't deleted.
1:          */
0:         public void writeRowDeletion(DeletionTime deletion);
1: 
1:         /**
0:          * Writes a cell to the writer.
1:          *
0:          * As mentionned above, add cells for a given column should be added consecutively (and in {@code CellPath} order for complex columns).
1:          *
0:          * @param column the column for the written cell.
0:          * @param isCounter whether or not this is a counter cell.
0:          * @param value the value for the cell. For tombstones, which don't have values, this should be an empty buffer.
0:          * @param info the cell liveness information.
0:          * @param path the {@link CellPath} for complex cells and {@code null} for regular cells.
1:          */
0:         public void writeCell(ColumnDefinition column, boolean isCounter, ByteBuffer value, LivenessInfo info, CellPath path);
1: 
1:         /**
0:          * Writes a deletion for a complex column, that is one that apply to all cells of the complex column.
1:          *
0:          * @param column the (complex) column this is a deletion for.
0:          * @param complexDeletion the deletion time.
1:          */
0:         public void writeComplexDeletion(ColumnDefinition column, DeletionTime complexDeletion);
1: 
1:         /**
0:          * Should be called to indicates that the row has been fully written.
1:          */
0:         public void endOfRow();
1:     }
1: 
1:     /**
1:      * Utility class to help merging rows from multiple inputs (UnfilteredRowIterators).
1:      */
0:     public abstract static class Merger
1:     {
0:         private final CFMetaData metadata;
0:         private final int nowInSec;
0:         private final UnfilteredRowIterators.MergeListener listener;
0:         private final Columns columns;
1: 
1:         private Clustering clustering;
0:         private final Row[] rows;
1:         private int rowsToMerge;
1: 
0:         private LivenessInfo rowInfo = LivenessInfo.NONE;
0:         private DeletionTime rowDeletion = DeletionTime.LIVE;
1: 
0:         private final Cell[] cells;
0:         private final List<Iterator<Cell>> complexCells;
0:         private final ComplexColumnReducer complexReducer = new ComplexColumnReducer();
1: 
0:         // For the sake of the listener if there is one
0:         private final DeletionTime[] complexDelTimes;
1: 
0:         private boolean signaledListenerForRow;
1: 
0:         public static Merger createStatic(CFMetaData metadata, int size, int nowInSec, Columns columns, UnfilteredRowIterators.MergeListener listener)
1:         {
0:             return new StaticMerger(metadata, size, nowInSec, columns, listener);
1:         }
1: 
0:         public static Merger createRegular(CFMetaData metadata, int size, int nowInSec, Columns columns, UnfilteredRowIterators.MergeListener listener)
1:         {
0:             return new RegularMerger(metadata, size, nowInSec, columns, listener);
1:         }
1: 
0:         protected Merger(CFMetaData metadata, int size, int nowInSec, Columns columns, UnfilteredRowIterators.MergeListener listener)
1:         {
0:             this.metadata = metadata;
0:             this.nowInSec = nowInSec;
0:             this.listener = listener;
0:             this.columns = columns;
1:             this.rows = new Row[size];
0:             this.complexCells = new ArrayList<>(size);
1: 
0:             this.cells = new Cell[size];
0:             this.complexDelTimes = listener == null ? null : new DeletionTime[size];
1:         }
1: 
1:         public void clear()
1:         {
1:             Arrays.fill(rows, null);
0:             Arrays.fill(cells, null);
0:             if (complexDelTimes != null)
0:                 Arrays.fill(complexDelTimes, null);
0:             complexCells.clear();
1:             rowsToMerge = 0;
1: 
0:             rowInfo = LivenessInfo.NONE;
0:             rowDeletion = DeletionTime.LIVE;
1: 
0:             signaledListenerForRow = false;
1:         }
1: 
1:         public void add(int i, Row row)
1:         {
1:             clustering = row.clustering();
1:             rows[i] = row;
1:             ++rowsToMerge;
1:         }
1: 
0:         protected abstract Row.Writer getWriter();
0:         protected abstract Row getRow();
1: 
1:         public Row merge(DeletionTime activeDeletion)
1:         {
1:             // If for this clustering we have only one row version and have no activeDeletion (i.e. nothing to filter out),
0:             // then we can just return that single row (we also should have no listener)
0:             if (rowsToMerge == 1 && activeDeletion.isLive() && listener == null)
1:             {
0:                 for (int i = 0; i < rows.length; i++)
0:                     if (rows[i] != null)
0:                         return rows[i];
0:                 throw new AssertionError();
1:             }
1: 
0:             Row.Writer writer = getWriter();
0:             Rows.writeClustering(clustering, writer);
1: 
0:             for (int i = 0; i < rows.length; i++)
1:             {
0:                 if (rows[i] == null)
1:                     continue;
1: 
0:                 rowInfo = rowInfo.mergeWith(rows[i].primaryKeyLivenessInfo());
1: 
0:                 if (rows[i].deletion().supersedes(rowDeletion))
0:                     rowDeletion = rows[i].deletion();
1:             }
1: 
0:             if (rowDeletion.supersedes(activeDeletion))
0:                 activeDeletion = rowDeletion;
1: 
1:             if (activeDeletion.deletes(rowInfo))
0:                 rowInfo = LivenessInfo.NONE;
1: 
0:             writer.writePartitionKeyLivenessInfo(rowInfo);
0:             writer.writeRowDeletion(rowDeletion);
1: 
0:             for (int i = 0; i < columns.simpleColumnCount(); i++)
1:             {
0:                 ColumnDefinition c = columns.getSimple(i);
0:                 for (int j = 0; j < rows.length; j++)
0:                     cells[j] = rows[j] == null ? null : rows[j].getCell(c);
1: 
0:                 reconcileCells(activeDeletion, writer);
1:             }
1: 
0:             complexReducer.activeDeletion = activeDeletion;
0:             complexReducer.writer = writer;
0:             for (int i = 0; i < columns.complexColumnCount(); i++)
1:             {
0:                 ColumnDefinition c = columns.getComplex(i);
1: 
0:                 DeletionTime maxComplexDeletion = DeletionTime.LIVE;
0:                 for (int j = 0; j < rows.length; j++)
1:                 {
0:                     if (rows[j] == null)
1:                         continue;
1: 
0:                     DeletionTime dt = rows[j].getDeletion(c);
0:                     if (complexDelTimes != null)
0:                         complexDelTimes[j] = dt;
1: 
0:                     if (dt.supersedes(maxComplexDeletion))
0:                         maxComplexDeletion = dt;
1:                 }
1: 
0:                 boolean overrideActive = maxComplexDeletion.supersedes(activeDeletion);
0:                 maxComplexDeletion =  overrideActive ? maxComplexDeletion : DeletionTime.LIVE;
0:                 writer.writeComplexDeletion(c, maxComplexDeletion);
0:                 if (listener != null)
0:                     listener.onMergedComplexDeletion(c, maxComplexDeletion, complexDelTimes);
1: 
0:                 mergeComplex(overrideActive ? maxComplexDeletion : activeDeletion, c);
1:             }
0:             writer.endOfRow();
1: 
0:             Row row = getRow();
0:             // Because shadowed cells are skipped, the row could be empty. In which case
0:             // we return null (we also don't want to signal anything in that case since that
0:             // means everything in the row was shadowed and the listener will have been signalled
0:             // for whatever shadows it).
0:             if (row.isEmpty())
0:                 return null;
1: 
0:             maybeSignalEndOfRow();
0:             return row;
1:         }
1: 
0:         private void maybeSignalListenerForRow()
1:         {
0:             if (listener != null && !signaledListenerForRow)
1:             {
0:                 listener.onMergingRows(clustering, rowInfo, rowDeletion, rows);
0:                 signaledListenerForRow = true;
1:             }
1:         }
1: 
0:         private void maybeSignalListenerForCell(Cell merged, Cell[] versions)
1:         {
0:             if (listener != null)
1:             {
0:                 maybeSignalListenerForRow();
0:                 listener.onMergedCells(merged, versions);
1:             }
1:         }
1: 
0:         private void maybeSignalEndOfRow()
1:         {
0:             if (listener != null)
1:             {
0:                 // If we haven't signaled the listener yet (we had no cells but some deletion info), do it now
0:                 maybeSignalListenerForRow();
0:                 listener.onRowDone();
1:             }
1:         }
1: 
0:         private void reconcileCells(DeletionTime activeDeletion, Row.Writer writer)
1:         {
0:             Cell reconciled = null;
0:             for (int j = 0; j < cells.length; j++)
1:             {
0:                 Cell cell = cells[j];
0:                 if (cell != null && !activeDeletion.deletes(cell.livenessInfo()))
0:                     reconciled = Cells.reconcile(reconciled, cell, nowInSec);
1:             }
1: 
0:             if (reconciled != null)
1:             {
0:                 reconciled.writeTo(writer);
0:                 maybeSignalListenerForCell(reconciled, cells);
1:             }
1:         }
1: 
0:         private void mergeComplex(DeletionTime activeDeletion, ColumnDefinition c)
1:         {
0:             complexCells.clear();
0:             for (int j = 0; j < rows.length; j++)
1:             {
0:                 Row row = rows[j];
0:                 Iterator<Cell> iter = row == null ? null : row.getCells(c);
0:                 complexCells.add(iter == null ? Iterators.<Cell>emptyIterator() : iter);
1:             }
1: 
0:             complexReducer.column = c;
0:             complexReducer.activeDeletion = activeDeletion;
1: 
0:             // Note that we use the mergeIterator only to group cells to merge, but we
0:             // write the result to the writer directly in the reducer, so all we care
0:             // about is iterating over the result.
0:             Iterator<Void> iter = MergeIterator.get(complexCells, c.cellComparator(), complexReducer);
0:             while (iter.hasNext())
0:                 iter.next();
1:         }
1: 
0:         private class ComplexColumnReducer extends MergeIterator.Reducer<Cell, Void>
1:         {
0:             private DeletionTime activeDeletion;
0:             private Row.Writer writer;
1:             private ColumnDefinition column;
1: 
0:             public void reduce(int idx, Cell current)
1:             {
0:                 cells[idx] = current;
1:             }
1: 
0:             protected Void getReduced()
1:             {
0:                 reconcileCells(activeDeletion, writer);
0:                 return null;
1:             }
1: 
1:             protected void onKeyChange()
1:             {
0:                 Arrays.fill(cells, null);
1:             }
1:         }
1: 
0:         private static class StaticMerger extends Merger
1:         {
0:             private final StaticRow.Builder builder;
1: 
0:             private StaticMerger(CFMetaData metadata, int size, int nowInSec, Columns columns, UnfilteredRowIterators.MergeListener listener)
1:             {
0:                 super(metadata, size, nowInSec, columns, listener);
0:                 this.builder = StaticRow.builder(columns, true, metadata.isCounter());
1:             }
1: 
0:             protected Row.Writer getWriter()
1:             {
0:                 return builder;
1:             }
1: 
0:             protected Row getRow()
1:             {
0:                 return builder.build();
1:             }
1:         }
1: 
0:         private static class RegularMerger extends Merger
1:         {
0:             private final ReusableRow row;
1: 
0:             private RegularMerger(CFMetaData metadata, int size, int nowInSec, Columns columns, UnfilteredRowIterators.MergeListener listener)
1:             {
0:                 super(metadata, size, nowInSec, columns, listener);
0:                 this.row = new ReusableRow(metadata.clusteringColumns().size(), columns, true, metadata.isCounter());
1:             }
1: 
0:             protected Row.Writer getWriter()
1:             {
0:                 return row.writer();
1:             }
1: 
0:             protected Row getRow()
1:             {
0:                 return row;
1:             }
1:         }
1:     }
1: }
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:2683806
/////////////////////////////////////////////////////////////////////////
1:      * Row builder interface geared towards human.
1:      * <p>
1:      * Where the {@link Builder} deals with building rows efficiently from internal objects ({@code Cell}, {@code
1:      * LivenessInfo}, ...), the {@code SimpleBuilder} is geared towards building rows from string column name and
1:      * 'native' values (string for text, ints for numbers, et...). In particular, it is meant to be convenient, not
1:      * efficient, and should be used only in place where performance is not of the utmost importance (it is used to
1:      * build schema mutation for instance).
1:      * <p>
1:      * Also note that contrarily to {@link Builder}, the {@code SimpleBuilder} API has no {@code newRow()} method: it is
1:      * expected that the clustering of the row built is provided by the constructor of the builder.
1:      */
1:     public interface SimpleBuilder
0:     {
1:         /**
1:          * Sets the timestamp to use for the following additions.
1:          * <p>
1:          * Note that the for non-compact tables, this method must be called before any column addition for this
1:          * timestamp to be used for the row {@code LivenessInfo}.
0:          *
1:          * @param timestamp the timestamp to use for following additions. If that timestamp hasn't been set, the current
1:          * time in microseconds will be used.
1:          * @return this builder.
1:          */
1:         public SimpleBuilder timestamp(long timestamp);
0: 
1:         /**
1:          * Sets the ttl to use for the following additions.
1:          * <p>
1:          * Note that the for non-compact tables, this method must be called before any column addition for this
1:          * ttl to be used for the row {@code LivenessInfo}.
0:          *
1:          * @param ttl the ttl to use for following additions. If that ttl hasn't been set, no ttl will be used.
1:          * @return this builder.
1:          */
1:         public SimpleBuilder ttl(int ttl);
0: 
1:         /**
1:          * Adds a value to a given column.
0:          *
1:          * @param columnName the name of the column for which to add a new value.
1:          * @param value the value to add, which must be of the proper type for {@code columnName}. This can be {@code
1:          * null} in which case the this is equivalent to {@code delete(columnName)}.
1:          * @return this builder.
1:          */
1:         public SimpleBuilder add(String columnName, Object value);
0: 
1:         /**
1:          * Appends new values to a given non-frozen collection column.
1:          * <p>
1:          * This method is similar to {@code add()} but the collection elements added through this method are "appended"
1:          * to any pre-exising elements. In other words, this is like {@code add()} except that it doesn't delete the
1:          * previous value of the collection. This can only be called on non-frozen collection columns.
1:          * <p>
1:          * Note that this method can be used in replacement of {@code add()} if you know that there can't be any
1:          * pre-existing value for that column, in which case this is slightly less expensive as it avoid the collection
1:          * tombstone inherent to {@code add()}.
0:          *
1:          * @param columnName the name of the column for which to add a new value, which must be a non-frozen collection.
1:          * @param value the value to add, which must be of the proper type for {@code columnName} (in other words, it
1:          * <b>must</b> be a collection).
1:          * @return this builder.
0:          *
1:          * @throws IllegalArgumentException if columnName is not a non-frozen collection column.
1:          */
1:         public SimpleBuilder appendAll(String columnName, Object value);
0: 
1:         /**
1:          * Deletes the whole row.
1:          * <p>
1:          * If called, this is generally the only method called on the builder (outside of {@code timestamp()}.
0:          *
1:          * @return this builder.
1:          */
1:         public SimpleBuilder delete();
0: 
1:         /**
1:          * Removes the value for a given column (creating a tombstone).
0:          *
1:          * @param columnName the name of the column to delete.
1:          * @return this builder.
1:          */
1:         public SimpleBuilder delete(String columnName);
0: 
1:         /**
1:          * Don't include any primary key {@code LivenessInfo} in the built row.
0:          *
1:          * @return this builder.
1:          */
1:         public SimpleBuilder noPrimaryKeyLivenessInfo();
0: 
1:         /**
1:          * Returns the built row.
0:          *
1:          * @return the built row.
1:          */
1:         public Row build();
0:     }
0: 
1:     /**
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: import java.util.function.Consumer;
0: 
1: import com.google.common.base.Predicate;
/////////////////////////////////////////////////////////////////////////
1:      * Apply a function to every column in a row
1:      */
1:     public void apply(Consumer<ColumnData> function, boolean reverse);
0: 
1:     /**
1:      * Apply a funtion to every column in a row until a stop condition is reached
1:      */
1:     public void apply(Consumer<ColumnData> function, Predicate<ColumnData> stopCondition, boolean reverse);
0: 
1:     /**
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:a22db5b
/////////////////////////////////////////////////////////////////////////
1:      * An in-natural-order collection of the columns for which data (incl. simple tombstones)
1:      * is present in this row.
commit:aa57626
/////////////////////////////////////////////////////////////////////////
1:     public Collection<ColumnDefinition> columns();
/////////////////////////////////////////////////////////////////////////
1:      * Whether the row stores any (non-RT) data for any complex column.
1:      */
1:     boolean hasComplex();
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public Merger(int size, int nowInSec, boolean hasComplex)
1:             this.columnDataReducer = new ColumnDataReducer(size, nowInSec, hasComplex);
/////////////////////////////////////////////////////////////////////////
1:                  : BTreeRow.create(clustering, rowInfo, rowDeletion, BTree.build(dataBuffer, UpdateFunction.<ColumnData>noOp()));
commit:0d74c3e
/////////////////////////////////////////////////////////////////////////
1: public interface Row extends Unfiltered, Collection<ColumnData>
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
0:                  : BTreeRow.create(clustering, columns, rowInfo, rowDeletion, BTree.build(dataBuffer, UpdateFunction.<ColumnData>noOp()));
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.btree.BTree;
1: import org.apache.cassandra.utils.btree.UpdateFunction;
/////////////////////////////////////////////////////////////////////////
0:                  : BTreeBackedRow.create(clustering, columns, rowInfo, rowDeletion, BTree.build(dataBuffer, UpdateFunction.<ColumnData>noOp()));
/////////////////////////////////////////////////////////////////////////
0:                     Iterator<Cell> cells = MergeIterator.get(complexCells, ColumnData.comparator, cellReducer);
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
1:      * An iterable over the cells of this row that return cells in "legacy order".
1:      * <p>
1:      * In 3.0+, columns are sorted so that all simple columns are before all complex columns. Previously
1:      * however, the cells where just sorted by the column name. This iterator return cells in that
1:      * legacy order. It's only ever meaningful for backward/thrift compatibility code.
0:      *
1:      * @param metadata the table this is a row of.
1:      * @return an iterable over the cells of this row in "legacy order".
0:      */
0:     public Iterable<Cell> cellsInLegacyOrder(CFMetaData metadata);
0: 
0:     /**
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:6818ba9
/////////////////////////////////////////////////////////////////////////
1:                     Iterator<Cell> cells = MergeIterator.get(complexCells, Cell.comparator, cellReducer);
============================================================================