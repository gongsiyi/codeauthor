1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:021ab75:  */
1:066ef58: package org.apache.cassandra.dht;
17:066ef58: 
1:4a6b002: import java.math.BigInteger;
1:e7a385a: import java.nio.ByteBuffer;
1:9c0ad81: import java.nio.charset.CharacterCodingException;
1:2564647: import java.util.*;
1:47d3b7e: import java.util.concurrent.ThreadLocalRandom;
1:2d9b4ba: 
1:7b532bc: import org.apache.cassandra.config.*;
1:c8b1ab4: import org.apache.cassandra.db.DecoratedKey;
1:18d8f26: import org.apache.cassandra.db.CachedHashDecoratedKey;
1:a67f779: import org.apache.cassandra.db.marshal.AbstractType;
1:a67f779: import org.apache.cassandra.db.marshal.UTF8Type;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:6a9a336: import org.apache.cassandra.gms.VersionedValue;
1:2564647: import org.apache.cassandra.service.StorageService;
1:2d9b4ba: import org.apache.cassandra.utils.ByteBufferUtil;
1:4a6b002: import org.apache.cassandra.utils.FBUtilities;
1:4b54b8a: import org.apache.cassandra.utils.ObjectSizes;
1:4a6b002: import org.apache.cassandra.utils.Pair;
1:f8fa6d2: 
1:066ef58: public class OrderPreservingPartitioner implements IPartitioner
1:021ab75: {
1:47d3b7e:     private static final String rndchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
1:47d3b7e: 
1:f8fa6d2:     public static final StringToken MINIMUM = new StringToken("");
1:f8fa6d2: 
1:4a6b002:     public static final BigInteger CHAR_MASK = new BigInteger("65535");
1:4a6b002: 
1:4b54b8a:     private static final long EMPTY_SIZE = ObjectSizes.measure(MINIMUM);
1:4b54b8a: 
1:07893d7:     public static final OrderPreservingPartitioner instance = new OrderPreservingPartitioner();
1:f8fa6d2: 
1:7e4ef1c:     public DecoratedKey decorateKey(ByteBuffer key)
1:021ab75:     {
1:18d8f26:         return new CachedHashDecoratedKey(getToken(key), key);
1:021ab75:     }
1:4a6b002: 
1:e7a385a:     public StringToken midpoint(Token ltoken, Token rtoken)
1:4b54b8a:     {
1:e7a385a:         int sigchars = Math.max(((StringToken)ltoken).token.length(), ((StringToken)rtoken).token.length());
1:e7a385a:         BigInteger left = bigForString(((StringToken)ltoken).token, sigchars);
1:e7a385a:         BigInteger right = bigForString(((StringToken)rtoken).token, sigchars);
1:c8b1ab4: 
1:4a6b002:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 16*sigchars);
1:4a6b002:         return new StringToken(stringForBig(midpair.left, sigchars, midpair.right));
1:4a6b002:     }
1:4a6b002: 
1:e2a0d75:     public Token split(Token left, Token right, double ratioToLeft)
1:e2a0d75:     {
1:e2a0d75:         throw new UnsupportedOperationException();
1:e2a0d75:     }
1:e2a0d75: 
1:4a6b002:     /**
1:4a6b002:      * Copies the characters of the given string into a BigInteger.
1:4a6b002:      *
1:4a6b002:      * TODO: Does not acknowledge any codepoints above 0xFFFF... problem?
1:4a6b002:      */
1:4a6b002:     private static BigInteger bigForString(String str, int sigchars)
1:4a6b002:     {
1:4a6b002:         assert str.length() <= sigchars;
1:4a6b002: 
1:4a6b002:         BigInteger big = BigInteger.ZERO;
1:4a6b002:         for (int i = 0; i < str.length(); i++)
1:4a6b002:         {
1:4a6b002:             int charpos = 16 * (sigchars - (i + 1));
1:4a6b002:             BigInteger charbig = BigInteger.valueOf(str.charAt(i) & 0xFFFF);
1:4a6b002:             big = big.or(charbig.shiftLeft(charpos));
1:4a6b002:         }
1:4a6b002:         return big;
1:4a6b002:     }
1:4a6b002: 
1:4a6b002:     /**
1:4a6b002:      * Convert a (positive) BigInteger into a String.
1:4a6b002:      * If remainder is true, an additional char with the high order bit enabled
1:4a6b002:      * will be added to the end of the String.
1:4a6b002:      */
1:4a6b002:     private String stringForBig(BigInteger big, int sigchars, boolean remainder)
1:4a6b002:     {
1:4a6b002:         char[] chars = new char[sigchars + (remainder ? 1 : 0)];
1:4a6b002:         if (remainder)
1:4a6b002:             // remaining bit is the most significant in the last char
1:4a6b002:             chars[sigchars] |= 0x8000;
1:4a6b002:         for (int i = 0; i < sigchars; i++)
1:4a6b002:         {
1:4a6b002:             int maskpos = 16 * (sigchars - (i + 1));
1:4a6b002:             // apply bitmask and get char value
1:4a6b002:             chars[i] = (char)(big.and(CHAR_MASK.shiftLeft(maskpos)).shiftRight(maskpos).intValue() & 0xFFFF);
1:4a6b002:         }
1:4a6b002:         return new String(chars);
1:c8b1ab4:     }
1:c8b1ab4: 
1:f8fa6d2:     public StringToken getMinimumToken()
1:c8b1ab4:     {
1:f8fa6d2:         return MINIMUM;
1:c8b1ab4:     }
1:c8b1ab4: 
1:e946c63:     public StringToken getRandomToken()
1:c8b1ab4:     {
1:47d3b7e:         return getRandomToken(ThreadLocalRandom.current());
1:47d3b7e:     }
1:47d3b7e: 
1:47d3b7e:     public StringToken getRandomToken(Random random)
1:47d3b7e:     {
1:066ef58:         StringBuilder buffer = new StringBuilder();
1:47d3b7e:         for (int j = 0; j < 16; j++)
1:47d3b7e:             buffer.append(rndchars.charAt(random.nextInt(rndchars.length())));
1:066ef58:         return new StringToken(buffer.toString());
1:c8b1ab4:     }
1:021ab75: 
1:ad84e4d:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:2d9b4ba:     {
1:ad84e4d:         public ByteBuffer toByteArray(Token token)
1:c8b1ab4:         {
1:ad84e4d:             StringToken stringToken = (StringToken) token;
1:ec26ee7:             return ByteBufferUtil.bytes(stringToken.token);
1:021ab75:         }
1:021ab75: 
1:ad84e4d:         public Token fromByteArray(ByteBuffer bytes)
1:021ab75:         {
1:46ea05f:             try
1:46ea05f:             {
1:ec26ee7:                 return new StringToken(ByteBufferUtil.string(bytes));
1:46ea05f:             }
1:46ea05f:             catch (CharacterCodingException e)
1:46ea05f:             {
1:46ea05f:                 throw new RuntimeException(e);
1:46ea05f:             }
1:021ab75:         }
1:021ab75: 
1:ad84e4d:         public String toString(Token token)
1:021ab75:         {
1:ad84e4d:             StringToken stringToken = (StringToken) token;
1:066ef58:             return stringToken.token;
1:021ab75:         }
1:021ab75: 
1:6a9a336:         public void validate(String token) throws ConfigurationException
1:6a9a336:         {
1:6a9a336:             if (token.contains(VersionedValue.DELIMITER_STR))
1:6a9a336:                 throw new ConfigurationException("Tokens may not contain the character " + VersionedValue.DELIMITER_STR);
1:6a9a336:         }
1:6a9a336: 
1:ad84e4d:         public Token fromString(String string)
1:021ab75:         {
1:066ef58:             return new StringToken(string);
1:021ab75:         }
1:c8b1ab4:     };
1:67ae1ee: 
1:ad84e4d:     public Token.TokenFactory getTokenFactory()
1:67ae1ee:     {
1:066ef58:         return tokenFactory;
1:67ae1ee:     }
1:021ab75: 
1:f8fa6d2:     public boolean preservesOrder()
1:021ab75:     {
1:f8fa6d2:         return true;
1:021ab75:     }
1:021ab75: 
1:07893d7:     public static class StringToken extends ComparableObjectToken<String>
1:021ab75:     {
1:07893d7:         static final long serialVersionUID = 5464084395277974963L;
1:021ab75: 
1:07893d7:         public StringToken(String token)
1:021ab75:         {
1:07893d7:             super(token);
1:021ab75:         }
1:021ab75: 
1:07893d7:         @Override
1:07893d7:         public IPartitioner getPartitioner()
1:021ab75:         {
1:07893d7:             return instance;
1:021ab75:         }
1:021ab75: 
1:07893d7:         @Override
1:07893d7:         public long getHeapSize()
1:f8fa6d2:         {
1:07893d7:             return EMPTY_SIZE + ObjectSizes.sizeOf(token);
1:021ab75:         }
1:f8fa6d2:     }
1:021ab75: 
1:e7a385a:     public StringToken getToken(ByteBuffer key)
1:f8fa6d2:     {
1:9c0ad81:         String skey;
1:9c0ad81:         try
1:9c0ad81:         {
1:ec26ee7:             skey = ByteBufferUtil.string(key);
1:9c0ad81:         }
1:9c0ad81:         catch (CharacterCodingException e)
1:9c0ad81:         {
1:2ccbe3c:             skey = ByteBufferUtil.bytesToHex(key);
1:9c0ad81:         }
1:9c0ad81:         return new StringToken(skey);
1:4b54b8a:     }
1:4b54b8a: 
1:2564647:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
13:066ef58:     {
1:c1f3c9e:         // allTokens will contain the count and be returned, sorted_ranges is shorthand for token<->token math.
1:c1f3c9e:         Map<Token, Float> allTokens = new HashMap<Token, Float>();
1:38ee718:         List<Range<Token>> sortedRanges = new ArrayList<Range<Token>>(sortedTokens.size());
1:021ab75: 
1:2564647:         // this initializes the counts to 0 and calcs the ranges in order.
1:c1f3c9e:         Token lastToken = sortedTokens.get(sortedTokens.size() - 1);
1:2564647:         for (Token node : sortedTokens)
1:066ef58:         {
1:c1f3c9e:             allTokens.put(node, new Float(0.0));
1:554223b:             sortedRanges.add(new Range<Token>(lastToken, node));
1:c1f3c9e:             lastToken = node;
1:f8fa6d2:         }
1:021ab75: 
1:0e96e58:         for (String ks : Schema.instance.getKeyspaces())
1:066ef58:         {
1:a3a8dbc:             for (CFMetaData cfmd : Schema.instance.getTablesAndViews(ks))
1:066ef58:             {
1:554223b:                 for (Range<Token> r : sortedRanges)
1:066ef58:                 {
1:2564647:                     // Looping over every KS:CF:Range, get the splits size and add it to the count
1:b31845c:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, cfmd.params.minIndexInterval).size());
1:f8fa6d2:                 }
1:fa53f58:             }
16:066ef58:         }
1:021ab75: 
1:2564647:         // Sum every count up and divide count/total for the fractional ownership.
1:2564647:         Float total = new Float(0.0);
1:c1f3c9e:         for (Float f : allTokens.values())
1:c1f3c9e:             total += f;
1:c1f3c9e:         for (Map.Entry<Token, Float> row : allTokens.entrySet())
1:c1f3c9e:             allTokens.put(row.getKey(), row.getValue() / total);
1:c1f3c9e: 
1:c1f3c9e:         return allTokens;
1:066ef58:     }
1:021ab75: 
1:a67f779:     public AbstractType<?> getTokenValidator()
1:066ef58:     {
1:69f77cb:         return UTF8Type.instance;
1:066ef58:     }
1:0a08525: 
1:0a08525:     public AbstractType<?> partitionOrdering()
1:0a08525:     {
1:0a08525:         return UTF8Type.instance;
1:0a08525:     }
1:066ef58: }
============================================================================
author:Dikang Gu
-------------------------------------------------------------------------------
commit:e2a0d75
/////////////////////////////////////////////////////////////////////////
1:     public Token split(Token left, Token right, double ratioToLeft)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:47d3b7e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ThreadLocalRandom;
/////////////////////////////////////////////////////////////////////////
1:     private static final String rndchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
1: 
/////////////////////////////////////////////////////////////////////////
1:         return getRandomToken(ThreadLocalRandom.current());
1:     }
1: 
1:     public StringToken getRandomToken(Random random)
1:     {
1:         for (int j = 0; j < 16; j++)
1:             buffer.append(rndchars.charAt(random.nextInt(rndchars.length())));
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:a3a8dbc
/////////////////////////////////////////////////////////////////////////
1:             for (CFMetaData cfmd : Schema.instance.getTablesAndViews(ks))
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:b31845c
/////////////////////////////////////////////////////////////////////////
1:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, cfmd.params.minIndexInterval).size());
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: 
1:     public AbstractType<?> partitionOrdering()
1:     {
1:         return UTF8Type.instance;
1:     }
commit:6e1033b
/////////////////////////////////////////////////////////////////////////
0:             for (CFMetaData cfmd : Schema.instance.getTables(ks))
commit:ee477cc
/////////////////////////////////////////////////////////////////////////
0:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, cfmd.getMinIndexInterval(), cfmd).size());
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1:         for (String ks : Schema.instance.getKeyspaces())
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ObjectSizes;
/////////////////////////////////////////////////////////////////////////
1:     private static final long EMPTY_SIZE = ObjectSizes.measure(MINIMUM);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(StringToken token)
1:     {
0:         return EMPTY_SIZE + ObjectSizes.sizeOf(token.token);
1:     }
1: 
commit:cb981e6
commit:2ccbe3c
/////////////////////////////////////////////////////////////////////////
1:             skey = ByteBufferUtil.bytesToHex(key);
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
commit:6a5c9ed
/////////////////////////////////////////////////////////////////////////
0:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, cfmd.getIndexInterval(), cfmd).size());
commit:5613f8f
commit:7e4ef1c
/////////////////////////////////////////////////////////////////////////
1:     public DecoratedKey decorateKey(ByteBuffer key)
0:         return new DecoratedKey(getToken(key), key);
0:     public DecoratedKey convertFromDiskFormat(ByteBuffer key)
0:         return new DecoratedKey(getToken(key), key);
commit:38ee718
/////////////////////////////////////////////////////////////////////////
1:         List<Range<Token>> sortedRanges = new ArrayList<Range<Token>>(sortedTokens.size());
commit:6a9a336
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.gms.VersionedValue;
/////////////////////////////////////////////////////////////////////////
1:         public void validate(String token) throws ConfigurationException
1:         {
1:             if (token.contains(VersionedValue.DELIMITER_STR))
1:                 throw new ConfigurationException("Tokens may not contain the character " + VersionedValue.DELIMITER_STR);
1:         }
1: 
commit:ec26ee7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return ByteBufferUtil.bytes(stringToken.token);
1:                 return new StringToken(ByteBufferUtil.string(bytes));
/////////////////////////////////////////////////////////////////////////
1:             skey = ByteBufferUtil.string(key);
commit:46ea05f
/////////////////////////////////////////////////////////////////////////
1:             try
1:             {
0:                 return new StringToken(ByteBufferUtil.string(bytes, Charsets.UTF_8));
1:             }
1:             catch (CharacterCodingException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             skey = ByteBufferUtil.string(key, Charsets.UTF_8);
commit:c1f3c9e
/////////////////////////////////////////////////////////////////////////
1:         // allTokens will contain the count and be returned, sorted_ranges is shorthand for token<->token math.
1:         Map<Token, Float> allTokens = new HashMap<Token, Float>();
0:         List<Range> sortedRanges = new ArrayList<Range>();
1:         Token lastToken = sortedTokens.get(sortedTokens.size() - 1);
1:             allTokens.put(node, new Float(0.0));
0:             sortedRanges.add(new Range(lastToken, node));
1:             lastToken = node;
0:         for (String ks : DatabaseDescriptor.getTables())
0:                 for (Range r : sortedRanges)
0:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, 1).size());
1:         for (Float f : allTokens.values())
1:             total += f;
1:         for (Map.Entry<Token, Float> row : allTokens.entrySet())
1:             allTokens.put(row.getKey(), row.getValue() / total);
1: 
1:         return allTokens;
commit:cdb07b1
/////////////////////////////////////////////////////////////////////////
commit:2d9b4ba
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Charsets;
1: 
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:     private final Token.TokenFactory<String> tokenFactory = new Token.TokenFactory<String>()
1:     {
0:             return ByteBuffer.wrap(stringToken.token.getBytes(Charsets.UTF_8));
0:             return new StringToken(ByteBufferUtil.string(bytes, Charsets.UTF_8));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<StringToken> decorateKey(ByteBuffer key)
0:     public DecoratedKey<StringToken> convertFromDiskFormat(ByteBuffer key)
1:     public StringToken midpoint(Token ltoken, Token rtoken)
1:         int sigchars = Math.max(((StringToken)ltoken).token.length(), ((StringToken)rtoken).token.length());
1:         BigInteger left = bigForString(((StringToken)ltoken).token, sigchars);
1:         BigInteger right = bigForString(((StringToken)rtoken).token, sigchars);
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer toByteArray(Token<String> stringToken)
0:                 return ByteBuffer.wrap(stringToken.token.getBytes("UTF-8"));
/////////////////////////////////////////////////////////////////////////
0:         public Token<String> fromByteArray(ByteBuffer bytes)
0:                 return new StringToken(new String(bytes.array(),bytes.position()+bytes.arrayOffset(),bytes.limit(), "UTF-8"));
/////////////////////////////////////////////////////////////////////////
1:     public StringToken getToken(ByteBuffer key)
commit:b6b1053
/////////////////////////////////////////////////////////////////////////
commit:9c0ad81
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
1:         String skey;
1:         try
1:         {
0:             skey = FBUtilities.decodeToUTF8(key);
1:         }
1:         catch (CharacterCodingException e)
1:         {
0:             throw new RuntimeException("The provided key was not UTF8 encoded.", e);
1:         }
1:         return new StringToken(skey);
commit:b4cae03
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4a6b002
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigInteger;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.Pair;
1:     public static final BigInteger CHAR_MASK = new BigInteger("65535");
1: 
/////////////////////////////////////////////////////////////////////////
0:         int sigchars = Math.max(ltoken.token.length(), rtoken.token.length());
0:         BigInteger left = bigForString(ltoken.token, sigchars);
0:         BigInteger right = bigForString(rtoken.token, sigchars);
1: 
1:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 16*sigchars);
1:         return new StringToken(stringForBig(midpair.left, sigchars, midpair.right));
1:     }
1: 
1:     /**
1:      * Copies the characters of the given string into a BigInteger.
1:      *
1:      * TODO: Does not acknowledge any codepoints above 0xFFFF... problem?
1:      */
1:     private static BigInteger bigForString(String str, int sigchars)
1:     {
1:         assert str.length() <= sigchars;
1: 
1:         BigInteger big = BigInteger.ZERO;
1:         for (int i = 0; i < str.length(); i++)
1:         {
1:             int charpos = 16 * (sigchars - (i + 1));
1:             BigInteger charbig = BigInteger.valueOf(str.charAt(i) & 0xFFFF);
1:             big = big.or(charbig.shiftLeft(charpos));
1:         }
1:         return big;
1:     }
1: 
1:     /**
1:      * Convert a (positive) BigInteger into a String.
1:      * If remainder is true, an additional char with the high order bit enabled
1:      * will be added to the end of the String.
1:      */
1:     private String stringForBig(BigInteger big, int sigchars, boolean remainder)
1:     {
1:         char[] chars = new char[sigchars + (remainder ? 1 : 0)];
1:         if (remainder)
1:             // remaining bit is the most significant in the last char
1:             chars[sigchars] |= 0x8000;
1:         for (int i = 0; i < sigchars; i++)
1:         {
1:             int maskpos = 16 * (sigchars - (i + 1));
1:             // apply bitmask and get char value
1:             chars[i] = (char)(big.and(CHAR_MASK.shiftLeft(maskpos)).shiftRight(maskpos).intValue() & 0xFFFF);
1:         }
1:         return new String(chars);
commit:e946c63
/////////////////////////////////////////////////////////////////////////
0:         return new DecoratedKey<StringToken>(new StringToken(key), key);
0:         return new DecoratedKey<StringToken>(new StringToken(key), key);
/////////////////////////////////////////////////////////////////////////
1:     public StringToken getRandomToken()
commit:67ae1ee
/////////////////////////////////////////////////////////////////////////
0:     private static final Comparator<DecoratedKey<StringToken>> comparator =
0:     public DecoratedKey<StringToken> decorateKey(String key)
0:     public DecoratedKey<StringToken> convertFromDiskFormat(String key)
0:         return new DecoratedKey<StringToken>(null, key);
0:     public String convertToDiskFormat(DecoratedKey<StringToken> key)
1:     {
0:         return key.key;
1:     }
1: 
0:     public Comparator<DecoratedKey<StringToken>> getDecoratedKeyComparator()
/////////////////////////////////////////////////////////////////////////
commit:a215c38
/////////////////////////////////////////////////////////////////////////
0:             return o1.key.compareTo(o2.key);
commit:c8b1ab4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.DecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:     private static final Comparator<DecoratedKey<StringToken>> objComparator = 
0:         new Comparator<DecoratedKey<StringToken>>() {
0:         public int compare(DecoratedKey<StringToken> o1, DecoratedKey<StringToken> o2)
1:         {
0:             return o1.getKey().compareTo(o2.getKey());
1:         }
1:     };      
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<StringToken> decorateKeyObj(String key)
1:     {
0:         return new DecoratedKey<StringToken>(null, key);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:     public Comparator<DecoratedKey<StringToken>> getDecoratedKeyObjComparator()
1:     {
0:         return objComparator;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
commit:021ab75
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Copies the given string into a char array, padding the end
0:      * with empty chars up to length.
1:      */
0:     private static char[] getChars(String str, int length)
1:     {
0:         char[] chars;
0:         if (str.length() < length)
1:         {
0:             chars = new char[length];
0:             str.getChars(0, str.length(), chars, 0);
1:         }
0:         else if (str.length() == length)
1:         {
0:             chars = str.toCharArray();
1:         }
0:         else
0:             throw new RuntimeException("Cannot truncate string of length " + str.length() + " to length " + length);
0:         return chars;
1:     }
1: 
0:     /**
0:      * @return A new String array that will compare
0:      * approximately halfway between the parameters.
1:      */
0:     private static String midpoint(String left, String right)
1:     {
0:         int inlength;
0:         char[] lchars;
0:         char[] rchars;
0:         int comparison = left.compareTo(right);
0:         if (comparison < 0)
1:         {
0:             inlength = Math.max(left.length(), right.length());
0:             lchars = getChars(left, inlength);
0:             rchars = getChars(right, inlength);
1:         }
0:         else
1:         {
0:             // wrapping range must involve the minimum token
0:             assert MINIMUM.token.equals(right);
1:             
0:             inlength = Math.max(left.length(), 1);
0:             lchars = getChars(left, inlength);
0:             rchars = new char[inlength];
0:             Arrays.fill(rchars, (char)0xFFFF);
1:         }
1: 
1: 
0:         // if the lsbits of the two inputs are not equal we have to extend
0:         // the result array to make room for a carried bit during the right shift
0:         int outlength = (((int)lchars[inlength-1] & 0x0001) == ((int)rchars[inlength-1] & 0x0001))
0:                         ? inlength
0:                         : inlength+1;
0:         char[] result = new char[outlength];
0:         boolean carrying = false;
1: 
0:         // perform the addition
0:         for (int i = inlength-1; i >= 0; i--)
1:         {
0:             // initialize the lsbit if we're carrying
0:             int sum = carrying ? 0x0001 : 0x0000;
1: 
0:             // remove the sign bit, and sum left and right
0:             sum += (lchars[i] & 0xFFFF) + (rchars[i] & 0xFFFF);
1:             
0:             // see if we'll need to carry
0:             carrying = sum > 0xFFFF;
1: 
0:             // set to the sum (truncating the msbit)
0:             result[i] = (char)sum;
1:         }
0:         // the carried bit from addition will be shifted in as the msbit
1: 
0:         // perform the division (as a right shift)
0:         for (int i = 0; i < inlength; i++)
1:         {
0:             // initialize the msbit if we're carrying
0:             char shifted = (char)(carrying ? 0x8000 : 0x0000);
1: 
0:             // check the lsbit to see if we'll need to continue carrying
0:             carrying = (result[i] & 0x0001) == 0x0001;
1: 
0:             // OR the right shifted value into the result char
0:             result[i] = (char)(shifted | ((result[i] & 0xFFFF) >>> 1));
1:         }
1: 
0:         if (carrying)
0:             // the last char in the result array
0:             result[inlength] |= 0x8000;
0:         return new String(result);
1:     }
1: 
0:     public StringToken midpoint(StringToken ltoken, StringToken rtoken)
1:     {
0:         return new StringToken(midpoint(ltoken.token, rtoken.token));
1:     }
1: 
commit:f8fa6d2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: public class OrderPreservingPartitioner implements IPartitioner<StringToken>
1:     public static final StringToken MINIMUM = new StringToken("");
1: 
0:     /**
0:      * Comparators for decorated keys.
0:      */
/////////////////////////////////////////////////////////////////////////
1:     public StringToken getMinimumToken()
1:     {
1:         return MINIMUM;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean preservesOrder()
1:     {
1:         return true;
1:     }
1: 
0:     public StringToken getToken(String key)
1: }
commit:e959b2c
/////////////////////////////////////////////////////////////////////////
0:     public Token getToken(String key)
commit:fa53f58
/////////////////////////////////////////////////////////////////////////
0:             return o1.compareTo(o2);
0:             return o2.compareTo(o1);
/////////////////////////////////////////////////////////////////////////
1: }
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: 
1: package org.apache.cassandra.dht;
1: 
0: import java.io.UnsupportedEncodingException;
0: import java.text.Collator;
0: import java.util.Comparator;
0: import java.util.Locale;
0: import java.util.Random;
1: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: 
1: public class OrderPreservingPartitioner implements IPartitioner
1: {
0:     // TODO make locale configurable.  But don't just leave it up to the OS or you could really screw
0:     // people over if they deploy on nodes with different OS locales.
0:     static final Collator collator = Collator.getInstance(new Locale("en", "US")); 
1: 
0:     private static final Comparator<String> comparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
1:         {
0:             return collator.compare(o1, o2);
1:         }
0:     };
0:     private static final Comparator<String> reverseComparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
1:         {
0:             return -comparator.compare(o1, o2);
1:         }
0:     };
1: 
0:     public String decorateKey(String key)
1:     {
0:         return key;
1:     }
1: 
0:     public String undecorateKey(String decoratedKey)
1:     {
0:         return decoratedKey;
1:     }
1: 
0:     public Comparator<String> getDecoratedKeyComparator()
1:     {
0:         return comparator;
1:     }
1: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
1:     {
0:         return reverseComparator;
1:     }
1: 
0:     public StringToken getDefaultToken()
1:     {
0:         String initialToken = DatabaseDescriptor.getInitialToken();
0:         if (initialToken != null)
0:             return new StringToken(initialToken);
1: 
0:         // generate random token
0:         String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
0:         Random r = new Random();
1:         StringBuilder buffer = new StringBuilder();
0:         for (int j = 0; j < 16; j++) {
0:             buffer.append(chars.charAt(r.nextInt(chars.length())));
1:         }
1:         return new StringToken(buffer.toString());
1:     }
1: 
0:     private final Token.TokenFactory<String> tokenFactory = new Token.TokenFactory<String>() {
0:         public byte[] toByteArray(Token<String> stringToken)
1:         {
0:             try
1:             {
0:                 return stringToken.token.getBytes("UTF-8");
1:             }
0:             catch (UnsupportedEncodingException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public Token<String> fromByteArray(byte[] bytes)
1:         {
0:             try
1:             {
0:                 return new StringToken(new String(bytes, "UTF-8"));
1:             }
0:             catch (UnsupportedEncodingException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public String toString(Token<String> stringToken)
1:         {
1:             return stringToken.token;
1:         }
1: 
0:         public Token<String> fromString(String string)
1:         {
1:             return new StringToken(string);
1:         }
0:     };
1: 
0:     public Token.TokenFactory<String> getTokenFactory()
1:     {
1:         return tokenFactory;
1:     }
1: 
0:     public Token getInitialToken(String key)
1:     {
0:         return new StringToken(key);
1:     }
1: }
commit:0172497
/////////////////////////////////////////////////////////////////////////
0:         StringBuilder buffer = new StringBuilder();
commit:324c3c3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: 
/////////////////////////////////////////////////////////////////////////
0:         String initialToken = DatabaseDescriptor.getInitialToken();
0:         if (initialToken != null)
0:             return new StringToken(initialToken);
0: 
0:         // generate random token
commit:ec29172
/////////////////////////////////////////////////////////////////////////
0:         public String toString(Token<String> stringToken)
0:         {
0:             return stringToken.token;
0:         }
0: 
commit:71739ef
commit:bfb2e95
/////////////////////////////////////////////////////////////////////////
0:     public Token getInitialToken(String key)
commit:907d92e
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.dht;
0: 
0: import java.io.UnsupportedEncodingException;
0: import java.text.Collator;
0: import java.util.Comparator;
0: import java.util.Locale;
0: import java.util.Random;
0: 
0: public class OrderPreservingPartitioner implements IPartitioner
0: {
0:     // TODO make locale configurable.  But don't just leave it up to the OS or you could really screw
0:     // people over if they deploy on nodes with different OS locales.
0:     static final Collator collator = Collator.getInstance(new Locale("en", "US")); 
0: 
0:     private static final Comparator<String> comparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:             return collator.compare(o1, o2);
0:         }
0:     };
0:     private static final Comparator<String> reverseComparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:             return -comparator.compare(o1, o2);
0:         }
0:     };
0: 
0:     public String decorateKey(String key)
0:     {
0:         return key;
0:     }
0: 
0:     public String undecorateKey(String decoratedKey)
0:     {
0:         return decoratedKey;
0:     }
0: 
0:     public Comparator<String> getDecoratedKeyComparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return reverseComparator;
0:     }
0: 
0:     public StringToken getDefaultToken()
0:     {
0:         String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
0:         Random r = new Random();
0:         StringBuffer buffer = new StringBuffer();
0:         for (int j = 0; j < 16; j++) {
0:             buffer.append(chars.charAt(r.nextInt(chars.length())));
0:         }
0:         return new StringToken(buffer.toString());
0:     }
0: 
0:     private final Token.TokenFactory<String> tokenFactory = new Token.TokenFactory<String>() {
0:         public byte[] toByteArray(Token<String> stringToken)
0:         {
0:             try
0:             {
0:                 return stringToken.token.getBytes("UTF-8");
0:             }
0:             catch (UnsupportedEncodingException e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0: 
0:         public Token<String> fromByteArray(byte[] bytes)
0:         {
0:             try
0:             {
0:                 return new StringToken(new String(bytes, "UTF-8"));
0:             }
0:             catch (UnsupportedEncodingException e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0: 
0:         public Token<String> fromString(String string)
0:         {
0:             return new StringToken(string);
0:         }
0:     };
0: 
0:     public Token.TokenFactory<String> getTokenFactory()
0:     {
0:         return tokenFactory;
0:     }
0: 
0:     public Token getTokenForKey(String key)
0:     {
0:         return new StringToken(key);
0:     }
0: }
commit:dd61d51
/////////////////////////////////////////////////////////////////////////
0: import java.text.Collator;
0: import java.util.Locale;
0:     // TODO make locale configurable.  But don't just leave it up to the OS or you could really screw
0:     // people over if they deploy on nodes with different OS locales.
0:     static final Collator collator = Collator.getInstance(new Locale("en", "US")); 
0: 
0:             return collator.compare(o1, o2);
0:         }
0:     };
0:     private static final Comparator<String> reverseComparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:             return -comparator.compare(o1, o2);
/////////////////////////////////////////////////////////////////////////
0:     public Comparator<String> getDecoratedKeyComparator()
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return reverseComparator;
0:     }
0: 
commit:20e081f
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.dht;
0: 
0: import java.io.UnsupportedEncodingException;
0: import java.util.Comparator;
0: import java.util.Random;
0: 
0: public class OrderPreservingPartitioner implements IPartitioner
0: {
0:     private static final Comparator<String> comparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:             return o2.compareTo(o1);
0:         }
0:     };
0: 
0:     public String decorateKey(String key)
0:     {
0:         return key;
0:     }
0: 
0:     public String undecorateKey(String decoratedKey)
0:     {
0:         return decoratedKey;
0:     }
0: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     public StringToken getDefaultToken()
0:     {
0:         String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
0:         Random r = new Random();
0:         StringBuffer buffer = new StringBuffer();
0:         for (int j = 0; j < 16; j++) {
0:             buffer.append(chars.charAt(r.nextInt(chars.length())));
0:         }
0:         return new StringToken(buffer.toString());
0:     }
0: 
0:     private final Token.TokenFactory<String> tokenFactory = new Token.TokenFactory<String>() {
0:         public byte[] toByteArray(Token<String> stringToken)
0:         {
0:             try
0:             {
0:                 return stringToken.token.getBytes("UTF-8");
0:             }
0:             catch (UnsupportedEncodingException e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0: 
0:         public Token<String> fromByteArray(byte[] bytes)
0:         {
0:             try
0:             {
0:                 return new StringToken(new String(bytes, "UTF-8"));
0:             }
0:             catch (UnsupportedEncodingException e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0: 
0:         public Token<String> fromString(String string)
0:         {
0:             return new StringToken(string);
0:         }
0:     };
0: 
0:     public Token.TokenFactory<String> getTokenFactory()
0:     {
0:         return tokenFactory;
0:     }
0: 
0:     public Token getTokenForKey(String key)
0:     {
0:         return new StringToken(key);
0:     }
0: }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: 
0:     public AbstractType<?> partitionOrdering()
0:     {
1:         return UTF8Type.instance;
0:     }
commit:07893d7
/////////////////////////////////////////////////////////////////////////
0: public class OrderPreservingPartitioner implements IPartitioner
/////////////////////////////////////////////////////////////////////////
1:     public static final OrderPreservingPartitioner instance = new OrderPreservingPartitioner();
0: 
/////////////////////////////////////////////////////////////////////////
1:     public static class StringToken extends ComparableObjectToken<String>
0:     {
1:         static final long serialVersionUID = 5464084395277974963L;
0: 
1:         public StringToken(String token)
0:         {
1:             super(token);
0:         }
0: 
1:         @Override
1:         public IPartitioner getPartitioner()
0:         {
1:             return instance;
0:         }
0: 
1:         @Override
1:         public long getHeapSize()
0:         {
1:             return EMPTY_SIZE + ObjectSizes.sizeOf(token);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
0: public class OrderPreservingPartitioner extends AbstractPartitioner
/////////////////////////////////////////////////////////////////////////
1:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:         public ByteBuffer toByteArray(Token token)
1:             StringToken stringToken = (StringToken) token;
1:         public Token fromByteArray(ByteBuffer bytes)
/////////////////////////////////////////////////////////////////////////
1:         public String toString(Token token)
1:             StringToken stringToken = (StringToken) token;
/////////////////////////////////////////////////////////////////////////
1:         public Token fromString(String string)
1:     public Token.TokenFactory getTokenFactory()
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(Token token)
0:         return EMPTY_SIZE + ObjectSizes.sizeOf(((StringToken) token).token);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:18d8f26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.CachedHashDecoratedKey;
/////////////////////////////////////////////////////////////////////////
1:         return new CachedHashDecoratedKey(getToken(key), key);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.BufferDecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:         return new BufferDecoratedKey(getToken(key), key);
commit:7b532bc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.*;
/////////////////////////////////////////////////////////////////////////
0:         for (String ks : Schema.instance.getTables())
0:             for (CFMetaData cfmd : Schema.instance.getKSMetaData(ks).cfMetaData().values())
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9ef8815
/////////////////////////////////////////////////////////////////////////
0:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, cfmd.getMinIndexInterval()).size());
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:d66630d
commit:a67f779
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.UTF8Type;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public AbstractType<?> getTokenValidator()
0:     {
0:         return UTF8Type.instance;
0:     }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
commit:5f43a69
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:554223b
/////////////////////////////////////////////////////////////////////////
0: public class OrderPreservingPartitioner extends AbstractPartitioner<StringToken>
/////////////////////////////////////////////////////////////////////////
0:         List<Range<Token>> sortedRanges = new ArrayList<Range<Token>>();
1:             sortedRanges.add(new Range<Token>(lastToken, node));
/////////////////////////////////////////////////////////////////////////
1:                 for (Range<Token> r : sortedRanges)
commit:0b0d7ea
/////////////////////////////////////////////////////////////////////////
0:                     allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, DatabaseDescriptor.getIndexInterval()).size());
author:Brandon Williams
-------------------------------------------------------------------------------
commit:2564647
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
0:     {
0:         // alltokens will contain the count and be returned, sorted_ranges is shorthand for token<->token math.
0:         Map<Token, Float> alltokens = new HashMap<Token, Float>();
0:         List<Range> sorted_ranges = new ArrayList<Range>();
0: 
1:         // this initializes the counts to 0 and calcs the ranges in order.
0:         Token last_t = sortedTokens.get(sortedTokens.size()-1);
1:         for (Token node : sortedTokens)
0:         {
0:             alltokens.put(node, new Float(0.0));
0:             sorted_ranges.add(new Range(last_t, node));
0:             last_t = node;
0:         }
0: 
0:         for(String ks : DatabaseDescriptor.getTables())
0:         {
0:             for (CFMetaData cfmd : DatabaseDescriptor.getKSMetaData(ks).cfMetaData().values())
0:             {
0:                 for (Range r : sorted_ranges)
0:                 {
1:                     // Looping over every KS:CF:Range, get the splits size and add it to the count
0:                     alltokens.put(r.right, alltokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, 1).size());
0:                 }
0:             }
0:         }
0: 
1:         // Sum every count up and divide count/total for the fractional ownership.
1:         Float total = new Float(0.0);
0:         for (Float f : alltokens.values()) { total += f; }
0:         for (Map.Entry<Token, Float> row : alltokens.entrySet()) {
0:             alltokens.put(row.getKey(), row.getValue() / total);
0:         }
0:         
0:         return alltokens;
0:     }
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<StringToken> decorateKey(byte[] key)
0:         return new DecoratedKey<StringToken>(getToken(key), key);
0:     public DecoratedKey<StringToken> convertFromDiskFormat(byte[] key)
0:         return new DecoratedKey<StringToken>(getToken(key), key);
/////////////////////////////////////////////////////////////////////////
0:     public StringToken getToken(byte[] key)
0:         return new StringToken(new String(key, FBUtilities.UTF8));
commit:f3bb9ac
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<StringToken> convertFromDiskFormat(byte[] fromdisk)
0:         String key = new String(fromdisk, FBUtilities.UTF8);
0:         return new DecoratedKey<StringToken>(new StringToken(key), fromdisk);
0:     public byte[] convertToDiskFormat(DecoratedKey<StringToken> key)
0:         return key.key;
commit:c1d34fb
/////////////////////////////////////////////////////////////////////////
0:         // FIXME
0:         return new String(key.key, FBUtilities.UTF8);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:bd884e4
/////////////////////////////////////////////////////////////////////////
============================================================================