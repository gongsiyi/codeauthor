1:9f14856: /*
1:9f14856:  * 
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:9f14856:  * 
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9f14856:  * 
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:9f14856:  * 
1:9f14856:  */
1:92cb551: package org.apache.cassandra.stress.settings;
1:9f14856: 
1:2e1e98a: import java.io.Serializable;
1:2e1e98a: import java.nio.ByteBuffer;
1:a16c4fe: import java.nio.charset.CharacterCodingException;
1:2e1e98a: import java.util.*;
13:2e1e98a: 
1:a16c4fe: import com.datastax.driver.core.exceptions.AlreadyExistsException;
1:a16c4fe: import org.apache.cassandra.stress.util.JavaDriverClient;
1:f42e235: import org.apache.cassandra.stress.util.ResultLogger;
1:2e1e98a: import org.apache.cassandra.thrift.*;
1:2e1e98a: import org.apache.cassandra.utils.ByteBufferUtil;
1:2e1e98a: 
1:2e1e98a: public class SettingsSchema implements Serializable
13:2e1e98a: {
1:2e1e98a: 
1:2e1e98a:     public static final String DEFAULT_VALIDATOR  = "BytesType";
1:2e1e98a: 
1:2e1e98a:     private final String replicationStrategy;
1:2e1e98a:     private final Map<String, String> replicationStrategyOptions;
1:2e1e98a: 
1:2e1e98a:     private final String compression;
1:2e1e98a:     private final String compactionStrategy;
1:8e360f8:     private final Map<String, String> compactionStrategyOptions;
1:2e1e98a:     public final String keyspace;
1:7536429: 
1:7536429:     public SettingsSchema(Options options, SettingsCommand command)
1:7536429:     {
1:7536429:         if (command instanceof SettingsCommandUser)
1:7536429:             keyspace = ((SettingsCommandUser) command).profile.keyspaceName;
2:7536429:         else
1:7536429:             keyspace = options.keyspace.value();
1:7536429: 
1:2e1e98a:         replicationStrategy = options.replication.getStrategy();
1:2e1e98a:         replicationStrategyOptions = options.replication.getOptions();
1:2e1e98a:         compression = options.compression.value();
1:8e360f8:         compactionStrategy = options.compaction.getStrategy();
1:8e360f8:         compactionStrategyOptions = options.compaction.getOptions();
1:7536429:     }
1:2e1e98a: 
1:2e1e98a:     public void createKeySpaces(StressSettings settings)
1:7536429:     {
1:a16c4fe:         if (settings.mode.api != ConnectionAPI.JAVA_DRIVER_NATIVE)
1:a16c4fe:         {
1:a16c4fe:             createKeySpacesThrift(settings);
1:a16c4fe:         }
1:a16c4fe:         else
1:a16c4fe:         {
1:a16c4fe:             createKeySpacesNative(settings);
1:a16c4fe:         }
1:7536429:     }
1:a16c4fe: 
1:a16c4fe:     /**
1:a16c4fe:      * Create Keyspace with Standard and Super/Counter column families
1:a16c4fe:      */
1:a16c4fe:     public void createKeySpacesNative(StressSettings settings)
1:a16c4fe:     {
1:a16c4fe: 
1:a16c4fe:         JavaDriverClient client  = settings.getJavaDriverClient(false);
1:a16c4fe: 
1:a16c4fe:         try
1:a16c4fe:         {
1:a16c4fe:             //Keyspace
1:a16c4fe:             client.execute(createKeyspaceStatementCQL3(), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1:a16c4fe: 
1:a16c4fe:             client.execute("USE \""+keyspace+"\"", org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1:a16c4fe: 
1:a16c4fe:             //Add standard1 and counter1
1:a16c4fe:             client.execute(createStandard1StatementCQL3(settings), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1:a16c4fe:             client.execute(createCounter1StatementCQL3(settings), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1:a16c4fe: 
1:a16c4fe:             System.out.println(String.format("Created keyspaces. Sleeping %ss for propagation.", settings.node.nodes.size()));
1:9499f7c:             Thread.sleep(settings.node.nodes.size() * 1000L); // seconds
1:a16c4fe:         }
1:a16c4fe:         catch (AlreadyExistsException e)
1:a16c4fe:         {
1:a16c4fe:             //Ok.
1:a16c4fe:         }
1:a16c4fe:         catch (Exception e)
1:a16c4fe:         {
1:a16c4fe:             throw new RuntimeException("Encountered exception creating schema", e);
1:a16c4fe:         }
1:a16c4fe:     }
1:a16c4fe: 
1:a16c4fe:     String createKeyspaceStatementCQL3()
1:a16c4fe:     {
1:a16c4fe:         StringBuilder b = new StringBuilder();
1:a16c4fe: 
1:a16c4fe:         //Create Keyspace
1:a16c4fe:         b.append("CREATE KEYSPACE IF NOT EXISTS \"")
1:a16c4fe:          .append(keyspace)
1:a16c4fe:          .append("\" WITH replication = {'class': '")
1:a16c4fe:          .append(replicationStrategy)
1:a16c4fe:          .append("'");
1:a16c4fe: 
1:a16c4fe:         if (replicationStrategyOptions.isEmpty())
1:a16c4fe:         {
1:a16c4fe:             b.append(", 'replication_factor': '1'}");
1:a16c4fe:         }
1:a16c4fe:         else
1:a16c4fe:         {
1:a16c4fe:             for(Map.Entry<String, String> entry : replicationStrategyOptions.entrySet())
1:a16c4fe:             {
1:a16c4fe:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1:a16c4fe:             }
1:a16c4fe: 
1:a16c4fe:             b.append("}");
1:a16c4fe:         }
1:a16c4fe: 
1:a16c4fe:         b.append(" AND durable_writes = true;\n");
1:a16c4fe: 
1:a16c4fe:         return b.toString();
1:a16c4fe:     }
1:a16c4fe: 
1:a16c4fe:     String createStandard1StatementCQL3(StressSettings settings)
1:a16c4fe:     {
1:a16c4fe: 
1:a16c4fe:         StringBuilder b = new StringBuilder();
1:a16c4fe: 
1:a16c4fe:         b.append("CREATE TABLE IF NOT EXISTS ")
1:a16c4fe:          .append("standard1 (key blob PRIMARY KEY ");
1:a16c4fe: 
1:a16c4fe:         try
1:a16c4fe:         {
1:a16c4fe:             for (ByteBuffer name : settings.columns.names)
1:a16c4fe:                 b.append("\n, \"").append(ByteBufferUtil.string(name)).append("\" blob");
1:a16c4fe:         }
1:a16c4fe:         catch (CharacterCodingException e)
1:a16c4fe:         {
1:a16c4fe:             throw new RuntimeException(e);
1:a16c4fe:         }
1:a16c4fe: 
1:a16c4fe:         //Compression
1:a16c4fe:         b.append(") WITH COMPACT STORAGE AND compression = {");
1:a16c4fe:         if (compression != null)
1:a16c4fe:             b.append("'sstable_compression' : '").append(compression).append("'");
1:a16c4fe: 
1:a16c4fe:         b.append("}");
1:a16c4fe: 
1:a16c4fe:         //Compaction
1:a16c4fe:         if (compactionStrategy != null)
1:a16c4fe:         {
1:a16c4fe:             b.append(" AND compaction = { 'class' : '").append(compactionStrategy).append("'");
1:a16c4fe: 
1:a16c4fe:             for (Map.Entry<String, String> entry : compactionStrategyOptions.entrySet())
1:a16c4fe:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1:a16c4fe: 
1:a16c4fe:             b.append("}");
1:a16c4fe:         }
1:a16c4fe: 
1:a16c4fe:         b.append(";\n");
1:a16c4fe: 
1:a16c4fe:         return b.toString();
1:a16c4fe:     }
1:a16c4fe: 
1:a16c4fe:     String createCounter1StatementCQL3(StressSettings settings)
1:a16c4fe:     {
1:a16c4fe: 
1:a16c4fe:         StringBuilder b = new StringBuilder();
1:a16c4fe: 
1:a16c4fe:         b.append("CREATE TABLE IF NOT EXISTS ")
1:a16c4fe:          .append("counter1 (key blob PRIMARY KEY,");
1:a16c4fe: 
1:a16c4fe:         try
1:a16c4fe:         {
1:a16c4fe:             for (ByteBuffer name : settings.columns.names)
1:a16c4fe:                 b.append("\n, \"").append(ByteBufferUtil.string(name)).append("\" counter");
1:a16c4fe:         }
1:a16c4fe:         catch (CharacterCodingException e)
1:a16c4fe:         {
1:a16c4fe:             throw new RuntimeException(e);
1:a16c4fe:         }
1:a16c4fe: 
1:a16c4fe:         //Compression
1:a16c4fe:         b.append(") WITH COMPACT STORAGE AND compression = {");
1:a16c4fe:         if (compression != null)
1:a16c4fe:             b.append("'sstable_compression' : '").append(compression).append("'");
1:a16c4fe: 
1:a16c4fe:         b.append("}");
1:a16c4fe: 
1:a16c4fe:         //Compaction
1:a16c4fe:         if (compactionStrategy != null)
1:a16c4fe:         {
1:a16c4fe:             b.append(" AND compaction = { 'class' : '").append(compactionStrategy).append("'");
1:a16c4fe: 
1:a16c4fe:             for (Map.Entry<String, String> entry : compactionStrategyOptions.entrySet())
1:a16c4fe:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1:a16c4fe: 
1:a16c4fe:             b.append("}");
1:a16c4fe:         }
1:a16c4fe: 
1:a16c4fe:         b.append(";\n");
1:2e1e98a: 
1:a16c4fe:         return b.toString();
1:a16c4fe:     }
1:2e1e98a: 
1:2e1e98a:     /**
1:2e1e98a:      * Create Keyspace with Standard and Super/Counter column families
1:2e1e98a:      */
1:2e1e98a:     public void createKeySpacesThrift(StressSettings settings)
1:7536429:     {
1:2e1e98a:         KsDef ksdef = new KsDef();
1:2e1e98a: 
1:2e1e98a:         // column family for standard columns
1:f0767fd:         CfDef standardCfDef = new CfDef(keyspace, "standard1");
1:7536429:         Map<String, String> compressionOptions = new HashMap<>();
1:2e1e98a:         if (compression != null)
1:2e1e98a:             compressionOptions.put("sstable_compression", compression);
1:2e1e98a: 
1:2e1e98a:         String comparator = settings.columns.comparator;
1:2e1e98a:         standardCfDef.setComparator_type(comparator)
2:2e1e98a:                 .setDefault_validation_class(DEFAULT_VALIDATOR)
3:2e1e98a:                 .setCompression_options(compressionOptions);
1:2e1e98a: 
1:7536429:         for (int i = 0; i < settings.columns.names.size(); i++)
1:7536429:             standardCfDef.addToColumn_metadata(new ColumnDef(settings.columns.names.get(i), "BytesType"));
1:2e1e98a: 
1:2e1e98a:         // column family for standard counters
1:f0767fd:         CfDef counterCfDef = new CfDef(keyspace, "counter1")
2:2e1e98a:                 .setComparator_type(comparator)
2:2e1e98a:                 .setDefault_validation_class("CounterColumnType")
1:2e1e98a:                 .setCompression_options(compressionOptions);
1:2e1e98a: 
1:2e1e98a:         ksdef.setName(keyspace);
1:2e1e98a:         ksdef.setStrategy_class(replicationStrategy);
1:2e1e98a: 
1:2e1e98a:         if (!replicationStrategyOptions.isEmpty())
1:2e1e98a:         {
1:2e1e98a:             ksdef.setStrategy_options(replicationStrategyOptions);
1:7536429:         }
1:2e1e98a: 
2:2e1e98a:         if (compactionStrategy != null)
1:2e1e98a:         {
1:2e1e98a:             standardCfDef.setCompaction_strategy(compactionStrategy);
1:2e1e98a:             counterCfDef.setCompaction_strategy(compactionStrategy);
1:8e360f8:             if (!compactionStrategyOptions.isEmpty())
1:8e360f8:             {
1:8e360f8:                 standardCfDef.setCompaction_strategy_options(compactionStrategyOptions);
1:8e360f8:                 counterCfDef.setCompaction_strategy_options(compactionStrategyOptions);
1:8e360f8:             }
12:2e1e98a:         }
1:2e1e98a: 
1:7536429:         ksdef.setCf_defs(new ArrayList<>(Arrays.asList(standardCfDef, counterCfDef)));
1:2e1e98a: 
1:2e1e98a:         Cassandra.Client client = settings.getRawThriftClient(false);
1:2e1e98a: 
2:2e1e98a:         try
1:2e1e98a:         {
1:2e1e98a:             client.system_add_keyspace(ksdef);
1:2e1e98a:             client.set_keyspace(keyspace);
1:2e1e98a: 
1:2e1e98a:             System.out.println(String.format("Created keyspaces. Sleeping %ss for propagation.", settings.node.nodes.size()));
1:a16c4fe:             Thread.sleep(settings.node.nodes.size() * 1000L); // seconds
1:2e1e98a:         }
1:2e1e98a:         catch (InvalidRequestException e)
1:2e1e98a:         {
1:2e1e98a:             System.err.println("Unable to create stress keyspace: " + e.getWhy());
1:2e1e98a:         }
1:2e1e98a:         catch (Exception e)
1:2e1e98a:         {
1:2e1e98a:             System.err.println("!!!! " + e.getMessage());
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a: 
1:2e1e98a:     // Option Declarations
1:2e1e98a: 
1:2e1e98a:     private static final class Options extends GroupedOptions
1:2e1e98a:     {
1:2e1e98a:         final OptionReplication replication = new OptionReplication();
1:8e360f8:         final OptionCompaction compaction = new OptionCompaction();
1:f0767fd:         final OptionSimple keyspace = new OptionSimple("keyspace=", ".*", "keyspace1", "The keyspace name to use", false);
1:2e1e98a:         final OptionSimple compression = new OptionSimple("compression=", ".*", null, "Specify the compression to use for sstable, default:no compression", false);
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public List<? extends Option> options()
1:2e1e98a:         {
1:7536429:             return Arrays.asList(replication, keyspace, compaction, compression);
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     // CLI Utility Methods
1:f42e235:     public void printSettings(ResultLogger out)
1:938faa2:     {
1:938faa2:         out.println("  Keyspace: " + keyspace);
1:938faa2:         out.println("  Replication Strategy: " + replicationStrategy);
1:938faa2:         out.println("  Replication Strategy Pptions: " + replicationStrategyOptions);
1:938faa2: 
1:938faa2:         out.println("  Table Compression: " + compression);
1:938faa2:         out.println("  Table Compaction Strategy: " + compactionStrategy);
1:938faa2:         out.println("  Table Compaction Strategy Options: " + compactionStrategyOptions);
1:938faa2:     }
1:938faa2: 
1:938faa2: 
1:7536429:     public static SettingsSchema get(Map<String, String[]> clArgs, SettingsCommand command)
1:2e1e98a:     {
1:2e1e98a:         String[] params = clArgs.remove("-schema");
1:2e1e98a:         if (params == null)
1:7536429:             return new SettingsSchema(new Options(), command);
1:2e1e98a: 
1:0580fb2:         if (command instanceof SettingsCommandUser)
1:0580fb2:             throw new IllegalArgumentException("-schema can only be provided with predefined operations insert, read, etc.; the 'user' command requires a schema yaml instead");
1:0580fb2: 
1:2e1e98a:         GroupedOptions options = GroupedOptions.select(params, new Options());
1:2e1e98a:         if (options == null)
1:2e1e98a:         {
1:2e1e98a:             printHelp();
1:2e1e98a:             System.out.println("Invalid -schema options provided, see output for valid options");
1:2e1e98a:             System.exit(1);
1:2e1e98a:         }
1:7536429:         return new SettingsSchema((Options) options, command);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public static void printHelp()
1:2e1e98a:     {
1:2e1e98a:         GroupedOptions.printOptions(System.out, "-schema", new Options());
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public static Runnable helpPrinter()
1:2e1e98a:     {
1:2e1e98a:         return new Runnable()
1:2e1e98a:         {
1:2e1e98a:             @Override
1:2e1e98a:             public void run()
1:2e1e98a:             {
1:2e1e98a:                 printHelp();
1:2e1e98a:             }
1:2e1e98a:         };
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a: }
============================================================================
author:Christopher Batey
-------------------------------------------------------------------------------
commit:f42e235
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.stress.util.ResultLogger;
/////////////////////////////////////////////////////////////////////////
1:     public void printSettings(ResultLogger out)
/////////////////////////////////////////////////////////////////////////
author:Ben Slater
-------------------------------------------------------------------------------
commit:938faa2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.stress.util.MultiPrintStream;
/////////////////////////////////////////////////////////////////////////
0:     public void printSettings(MultiPrintStream out)
1:     {
1:         out.println("  Keyspace: " + keyspace);
1:         out.println("  Replication Strategy: " + replicationStrategy);
1:         out.println("  Replication Strategy Pptions: " + replicationStrategyOptions);
1: 
1:         out.println("  Table Compression: " + compression);
1:         out.println("  Table Compaction Strategy: " + compactionStrategy);
1:         out.println("  Table Compaction Strategy Options: " + compactionStrategyOptions);
1: 
1:     }
1: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:9499f7c
/////////////////////////////////////////////////////////////////////////
1:             Thread.sleep(settings.node.nodes.size() * 1000L); // seconds
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:a16c4fe
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.CharacterCodingException;
1: import com.datastax.driver.core.exceptions.AlreadyExistsException;
1: import org.apache.cassandra.stress.util.JavaDriverClient;
0: import org.apache.cassandra.thrift.ConsistencyLevel;
/////////////////////////////////////////////////////////////////////////
1:         if (settings.mode.api != ConnectionAPI.JAVA_DRIVER_NATIVE)
1:         {
1:             createKeySpacesThrift(settings);
1:         }
1:         else
1:         {
1:             createKeySpacesNative(settings);
1:         }
1:     /**
1:      * Create Keyspace with Standard and Super/Counter column families
1:      */
1:     public void createKeySpacesNative(StressSettings settings)
1:     {
1: 
1:         JavaDriverClient client  = settings.getJavaDriverClient(false);
1: 
1:         try
1:         {
1:             //Keyspace
1:             client.execute(createKeyspaceStatementCQL3(), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1: 
1:             client.execute("USE \""+keyspace+"\"", org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1: 
1:             //Add standard1 and counter1
1:             client.execute(createStandard1StatementCQL3(settings), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1:             client.execute(createCounter1StatementCQL3(settings), org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE);
1: 
1:             System.out.println(String.format("Created keyspaces. Sleeping %ss for propagation.", settings.node.nodes.size()));
1:             Thread.sleep(settings.node.nodes.size() * 1000L); // seconds
1:         }
1:         catch (AlreadyExistsException e)
1:         {
1:             //Ok.
1:         }
1:         catch (Exception e)
1:         {
1:             throw new RuntimeException("Encountered exception creating schema", e);
1:         }
1:     }
1: 
1:     String createKeyspaceStatementCQL3()
1:     {
1:         StringBuilder b = new StringBuilder();
1: 
1:         //Create Keyspace
1:         b.append("CREATE KEYSPACE IF NOT EXISTS \"")
1:          .append(keyspace)
1:          .append("\" WITH replication = {'class': '")
1:          .append(replicationStrategy)
1:          .append("'");
1: 
1:         if (replicationStrategyOptions.isEmpty())
1:         {
1:             b.append(", 'replication_factor': '1'}");
1:         }
1:         else
1:         {
1:             for(Map.Entry<String, String> entry : replicationStrategyOptions.entrySet())
1:             {
1:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1:             }
1: 
1:             b.append("}");
1:         }
1: 
1:         b.append(" AND durable_writes = true;\n");
1: 
1:         return b.toString();
1:     }
1: 
1:     String createStandard1StatementCQL3(StressSettings settings)
1:     {
1: 
1:         StringBuilder b = new StringBuilder();
1: 
1:         b.append("CREATE TABLE IF NOT EXISTS ")
1:          .append("standard1 (key blob PRIMARY KEY ");
1: 
1:         try
1:         {
1:             for (ByteBuffer name : settings.columns.names)
1:                 b.append("\n, \"").append(ByteBufferUtil.string(name)).append("\" blob");
1:         }
1:         catch (CharacterCodingException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1: 
1:         //Compression
1:         b.append(") WITH COMPACT STORAGE AND compression = {");
1:         if (compression != null)
1:             b.append("'sstable_compression' : '").append(compression).append("'");
1: 
1:         b.append("}");
1: 
1:         //Compaction
1:         if (compactionStrategy != null)
1:         {
1:             b.append(" AND compaction = { 'class' : '").append(compactionStrategy).append("'");
1: 
1:             for (Map.Entry<String, String> entry : compactionStrategyOptions.entrySet())
1:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1: 
1:             b.append("}");
1:         }
1: 
1:         b.append(";\n");
1: 
1:         return b.toString();
1:     }
1: 
1:     String createCounter1StatementCQL3(StressSettings settings)
1:     {
1: 
1:         StringBuilder b = new StringBuilder();
1: 
1:         b.append("CREATE TABLE IF NOT EXISTS ")
1:          .append("counter1 (key blob PRIMARY KEY,");
1: 
1:         try
1:         {
1:             for (ByteBuffer name : settings.columns.names)
1:                 b.append("\n, \"").append(ByteBufferUtil.string(name)).append("\" counter");
1:         }
1:         catch (CharacterCodingException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1: 
1:         //Compression
1:         b.append(") WITH COMPACT STORAGE AND compression = {");
1:         if (compression != null)
1:             b.append("'sstable_compression' : '").append(compression).append("'");
1: 
1:         b.append("}");
1: 
1:         //Compaction
1:         if (compactionStrategy != null)
1:         {
1:             b.append(" AND compaction = { 'class' : '").append(compactionStrategy).append("'");
1: 
1:             for (Map.Entry<String, String> entry : compactionStrategyOptions.entrySet())
1:                 b.append(", '").append(entry.getKey()).append("' : '").append(entry.getValue()).append("'");
1: 
1:             b.append("}");
1:         }
1: 
1:         b.append(";\n");
1: 
1:         return b.toString();
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f0767fd
/////////////////////////////////////////////////////////////////////////
1:         CfDef standardCfDef = new CfDef(keyspace, "standard1");
/////////////////////////////////////////////////////////////////////////
1:         CfDef counterCfDef = new CfDef(keyspace, "counter1")
/////////////////////////////////////////////////////////////////////////
1:         final OptionSimple keyspace = new OptionSimple("keyspace=", ".*", "keyspace1", "The keyspace name to use", false);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:6c579a0
/////////////////////////////////////////////////////////////////////////
commit:0580fb2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         createKeySpacesThrift(settings);
/////////////////////////////////////////////////////////////////////////
1:         if (command instanceof SettingsCommandUser)
1:             throw new IllegalArgumentException("-schema can only be provided with predefined operations insert, read, etc.; the 'user' command requires a schema yaml instead");
1: 
commit:7536429
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.thrift.ConsistencyLevel;
1:     public SettingsSchema(Options options, SettingsCommand command)
1:         if (command instanceof SettingsCommandUser)
1:         {
0:             if (options.compaction.setByUser() || options.keyspace.setByUser() || options.compression.setByUser() || options.replication.setByUser())
0:                 throw new IllegalArgumentException("Cannot provide command line schema settings if a user profile is provided");
1: 
1:             keyspace = ((SettingsCommandUser) command).profile.keyspaceName;
1:         }
1:         else
1:             keyspace = options.keyspace.value();
1: 
0:         if (!(settings.command instanceof SettingsCommandUser))
1:         {
0:             createKeySpacesThrift(settings);
1:         }
1:         else
1:         {
0:             ((SettingsCommandUser) settings.command).profile.maybeCreateSchema(settings);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> compressionOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < settings.columns.names.size(); i++)
1:             standardCfDef.addToColumn_metadata(new ColumnDef(settings.columns.names.get(i), "BytesType"));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ksdef.setCf_defs(new ArrayList<>(Arrays.asList(standardCfDef, counterCfDef)));
/////////////////////////////////////////////////////////////////////////
1:             return Arrays.asList(replication, keyspace, compaction, compression);
1:     public static SettingsSchema get(Map<String, String[]> clArgs, SettingsCommand command)
1:             return new SettingsSchema(new Options(), command);
/////////////////////////////////////////////////////////////////////////
1:         return new SettingsSchema((Options) options, command);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:92cb551
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.stress.settings;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return Arrays.asList(replication, index, keyspace, compaction, compression);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:3e2c610
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         CfDef standardCfDef = new CfDef(keyspace, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:             return Arrays.asList(replication, index, keyspace, compaction, noReplicateOnWrite, compression);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:8e360f8
/////////////////////////////////////////////////////////////////////////
1:     private final Map<String, String> compactionStrategyOptions;
/////////////////////////////////////////////////////////////////////////
1:         compactionStrategy = options.compaction.getStrategy();
1:         compactionStrategyOptions = options.compaction.getOptions();
/////////////////////////////////////////////////////////////////////////
1:             if (!compactionStrategyOptions.isEmpty())
1:             {
1:                 standardCfDef.setCompaction_strategy_options(compactionStrategyOptions);
0:                 superCfDef.setCompaction_strategy_options(compactionStrategyOptions);
1:                 counterCfDef.setCompaction_strategy_options(compactionStrategyOptions);
0:                 counterSuperCfDef.setCompaction_strategy_options(compactionStrategyOptions);
1:             }
0:         ksdef.setCf_defs(new ArrayList<>(Arrays.asList(standardCfDef, superCfDef, counterCfDef, counterSuperCfDef)));
/////////////////////////////////////////////////////////////////////////
1:         final OptionCompaction compaction = new OptionCompaction();
0:             return Arrays.asList(replication, index, keyspace, columnFamily, compaction, noReplicateOnWrite, compression);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  * 
1:  */
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:2e1e98a
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.stress.settings;
1: 
1: import java.io.Serializable;
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.thrift.*;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: public class SettingsSchema implements Serializable
1: {
1: 
0:     public static final String DEFAULT_COMPARATOR = "AsciiType";
1:     public static final String DEFAULT_VALIDATOR  = "BytesType";
1: 
1:     private final String replicationStrategy;
1:     private final Map<String, String> replicationStrategyOptions;
1: 
0:     private final IndexType indexType;
0:     private final boolean replicateOnWrite;
1:     private final String compression;
1:     private final String compactionStrategy;
1:     public final String keyspace;
0:     public final String columnFamily;
1: 
0:     public SettingsSchema(Options options)
1:     {
0:         replicateOnWrite = !options.noReplicateOnWrite.setByUser();
1:         replicationStrategy = options.replication.getStrategy();
1:         replicationStrategyOptions = options.replication.getOptions();
0:         if (options.index.setByUser())
0:             indexType = IndexType.valueOf(options.index.value().toUpperCase());
0:         else
0:             indexType = null;
1:         compression = options.compression.value();
0:         compactionStrategy = options.compactionStrategy.value();
1:         if (compactionStrategy != null)
1:         {
1:             try
1:             {
0:                 CFMetaData.createCompactionStrategy(compactionStrategy);
0:             } catch (ConfigurationException e)
1:             {
0:                 throw new IllegalArgumentException("Invalid compaction strategy: " + compactionStrategy);
1:             }
1:         }
0:         keyspace = options.keyspace.value();
0:         columnFamily = options.columnFamily.value();
1:     }
1: 
0:     private void createKeyspacesCql3(StressSettings settings)
1:     {
0: //        settings.getJavaDriverClient().execute("create table Standard1")
1:     }
1: 
1:     public void createKeySpaces(StressSettings settings)
1:     {
0:         createKeySpacesThrift(settings);
1:     }
1: 
1: 
1:     /**
1:      * Create Keyspace with Standard and Super/Counter column families
1:      */
1:     public void createKeySpacesThrift(StressSettings settings)
1:     {
1:         KsDef ksdef = new KsDef();
1: 
1:         // column family for standard columns
0:         CfDef standardCfDef = new CfDef(keyspace, columnFamily);
0:         Map<String, String> compressionOptions = new HashMap<String, String>();
1:         if (compression != null)
1:             compressionOptions.put("sstable_compression", compression);
1: 
1:         String comparator = settings.columns.comparator;
1:         standardCfDef.setComparator_type(comparator)
1:                 .setDefault_validation_class(DEFAULT_VALIDATOR)
1:                 .setCompression_options(compressionOptions);
1: 
0:         if (!settings.columns.useTimeUUIDComparator)
1:         {
0:             for (int i = 0; i < settings.columns.maxColumnsPerKey; i++)
1:             {
0:                 standardCfDef.addToColumn_metadata(new ColumnDef(ByteBufferUtil.bytes("C" + i), "BytesType"));
1:             }
1:         }
1: 
0:         if (indexType != null)
1:         {
0:             ColumnDef standardColumn = new ColumnDef(ByteBufferUtil.bytes("C1"), "BytesType");
0:             standardColumn.setIndex_type(indexType).setIndex_name("Idx1");
0:             standardCfDef.setColumn_metadata(Arrays.asList(standardColumn));
1:         }
1: 
0:         // column family with super columns
0:         CfDef superCfDef = new CfDef(keyspace, "Super1")
0:                 .setColumn_type("Super");
0:         superCfDef.setComparator_type(DEFAULT_COMPARATOR)
0:                 .setSubcomparator_type(comparator)
1:                 .setDefault_validation_class(DEFAULT_VALIDATOR)
1:                 .setCompression_options(compressionOptions);
1: 
1:         // column family for standard counters
0:         CfDef counterCfDef = new CfDef(keyspace, "Counter1")
1:                 .setComparator_type(comparator)
1:                 .setDefault_validation_class("CounterColumnType")
0:                 .setReplicate_on_write(replicateOnWrite)
1:                 .setCompression_options(compressionOptions);
1: 
0:         // column family with counter super columns
0:         CfDef counterSuperCfDef = new CfDef(keyspace, "SuperCounter1")
1:                 .setComparator_type(comparator)
1:                 .setDefault_validation_class("CounterColumnType")
0:                 .setReplicate_on_write(replicateOnWrite)
0:                 .setColumn_type("Super")
1:                 .setCompression_options(compressionOptions);
1: 
1:         ksdef.setName(keyspace);
1:         ksdef.setStrategy_class(replicationStrategy);
1: 
1:         if (!replicationStrategyOptions.isEmpty())
1:         {
1:             ksdef.setStrategy_options(replicationStrategyOptions);
1:         }
1: 
1:         if (compactionStrategy != null)
1:         {
1:             standardCfDef.setCompaction_strategy(compactionStrategy);
0:             superCfDef.setCompaction_strategy(compactionStrategy);
1:             counterCfDef.setCompaction_strategy(compactionStrategy);
0:             counterSuperCfDef.setCompaction_strategy(compactionStrategy);
1:         }
1: 
0:         ksdef.setCf_defs(new ArrayList<CfDef>(Arrays.asList(standardCfDef, superCfDef, counterCfDef, counterSuperCfDef)));
1: 
1:         Cassandra.Client client = settings.getRawThriftClient(false);
1: 
1:         try
1:         {
1:             client.system_add_keyspace(ksdef);
1: 
0:             /* CQL3 counter cf */
0:             client.set_cql_version("3.0.0"); // just to create counter cf for cql3
1: 
1:             client.set_keyspace(keyspace);
0:             client.execute_cql3_query(createCounterCFStatementForCQL3(settings), Compression.NONE, ConsistencyLevel.ONE);
1: 
0:             if (settings.mode.cqlVersion.isCql())
0:                 client.set_cql_version(settings.mode.cqlVersion.connectVersion);
0:             /* end */
1: 
1:             System.out.println(String.format("Created keyspaces. Sleeping %ss for propagation.", settings.node.nodes.size()));
0:             Thread.sleep(settings.node.nodes.size() * 1000); // seconds
1:         }
1:         catch (InvalidRequestException e)
1:         {
1:             System.err.println("Unable to create stress keyspace: " + e.getWhy());
1:         }
1:         catch (Exception e)
1:         {
1:             System.err.println("!!!! " + e.getMessage());
1:         }
1:     }
1: 
0:     private ByteBuffer createCounterCFStatementForCQL3(StressSettings options)
1:     {
0:         StringBuilder counter3 = new StringBuilder("CREATE TABLE \"Counter3\" (KEY blob PRIMARY KEY, ");
1: 
0:         for (int i = 0; i < options.columns.maxColumnsPerKey; i++)
1:         {
0:             counter3.append("c").append(i).append(" counter");
0:             if (i != options.columns.maxColumnsPerKey - 1)
0:                 counter3.append(", ");
1:         }
0:         counter3.append(");");
1: 
0:         return ByteBufferUtil.bytes(counter3.toString());
1:     }
1: 
1:     // Option Declarations
1: 
1:     private static final class Options extends GroupedOptions
1:     {
1:         final OptionReplication replication = new OptionReplication();
0:         final OptionSimple index = new OptionSimple("index=", "KEYS|CUSTOM|COMPOSITES", null, "Type of index to create on needed column families (KEYS)", false);
0:         final OptionSimple keyspace = new OptionSimple("keyspace=", ".*", "Keyspace1", "The keyspace name to use", false);
0:         final OptionSimple columnFamily = new OptionSimple("columnfamily=", ".*", "Standard1", "The column family name to use", false);
0:         final OptionSimple compactionStrategy = new OptionSimple("compaction=", ".*", null, "The compaction strategy to use", false);
0:         final OptionSimple noReplicateOnWrite = new OptionSimple("no-replicate-on-write", "", null, "Set replicate_on_write to false for counters. Only counter add with CL=ONE will work", false);
1:         final OptionSimple compression = new OptionSimple("compression=", ".*", null, "Specify the compression to use for sstable, default:no compression", false);
1: 
1:         @Override
1:         public List<? extends Option> options()
1:         {
0:             return Arrays.asList(replication, index, keyspace, columnFamily, compactionStrategy, noReplicateOnWrite, compression);
1:         }
1:     }
1: 
1:     // CLI Utility Methods
1: 
0:     public static SettingsSchema get(Map<String, String[]> clArgs)
1:     {
1:         String[] params = clArgs.remove("-schema");
1:         if (params == null)
0:             return new SettingsSchema(new Options());
1: 
1:         GroupedOptions options = GroupedOptions.select(params, new Options());
1:         if (options == null)
1:         {
1:             printHelp();
1:             System.out.println("Invalid -schema options provided, see output for valid options");
1:             System.exit(1);
1:         }
0:         return new SettingsSchema((Options) options);
1:     }
1: 
1:     public static void printHelp()
1:     {
1:         GroupedOptions.printOptions(System.out, "-schema", new Options());
1:     }
1: 
1:     public static Runnable helpPrinter()
1:     {
1:         return new Runnable()
1:         {
1:             @Override
1:             public void run()
1:             {
1:                 printHelp();
1:             }
1:         };
1:     }
1: 
1: }
============================================================================