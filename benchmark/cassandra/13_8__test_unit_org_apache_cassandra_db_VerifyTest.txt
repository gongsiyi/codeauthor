1:2d7909d: /*
1:2d7909d:  * Licensed to the Apache Software Foundation (ASF) under one
1:2d7909d:  * or more contributor license agreements.  See the NOTICE file
1:2d7909d:  * distributed with this work for additional information
1:2d7909d:  * regarding copyright ownership.  The ASF licenses this file
1:2d7909d:  * to you under the Apache License, Version 2.0 (the
1:2d7909d:  * "License"); you may not use this file except in compliance
1:2d7909d:  * with the License.  You may obtain a copy of the License at
3:2d7909d:  *
1:2d7909d:  *   http://www.apache.org/licenses/LICENSE-2.0
1:2d7909d:  *
1:2d7909d:  * Unless required by applicable law or agreed to in writing,
1:2d7909d:  * software distributed under the License is distributed on an
1:2d7909d:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:2d7909d:  * KIND, either express or implied.  See the License for the
1:2d7909d:  * specific language governing permissions and limitations
1:2d7909d:  * under the License.
1:2d7909d:  */
1:31e3f61: package org.apache.cassandra.db;
3:2d7909d: 
1:2d7909d: import com.google.common.base.Charsets;
1:5baf28d: 
1:2d7909d: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1:2d7909d: import org.apache.cassandra.SchemaLoader;
1:2d7909d: import org.apache.cassandra.Util;
1:30bb255: import org.apache.cassandra.cache.ChunkCache;
1:a991b64: import org.apache.cassandra.UpdateBuilder;
1:2d7909d: import org.apache.cassandra.db.compaction.CompactionManager;
1:2d7909d: import org.apache.cassandra.db.compaction.Verifier;
1:2d7909d: import org.apache.cassandra.db.marshal.UUIDType;
1:2d7909d: import org.apache.cassandra.exceptions.ConfigurationException;
1:2d7909d: import org.apache.cassandra.exceptions.WriteTimeoutException;
1:2d7909d: import org.apache.cassandra.io.FSWriteError;
1:2d7909d: import org.apache.cassandra.io.sstable.CorruptSSTableException;
1:2d7909d: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:2d7909d: import org.apache.cassandra.io.util.FileUtils;
1:b31845c: import org.apache.cassandra.schema.CompressionParams;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:2d7909d: import org.apache.cassandra.utils.ByteBufferUtil;
1:2d7909d: import org.apache.commons.lang3.StringUtils;
1:2d7909d: import org.junit.BeforeClass;
1:2d7909d: import org.junit.Test;
1:2d7909d: import org.junit.runner.RunWith;
1:2d7909d: 
1:2d7909d: import java.io.*;
1:2d7909d: import java.nio.file.Files;
1:5baf28d: import java.util.zip.CRC32;
1:2d7909d: import java.util.zip.CheckedInputStream;
1:2d7909d: 
1:2d7909d: import static org.junit.Assert.fail;
1:2d7909d: 
1:2d7909d: @RunWith(OrderedJUnit4ClassRunner.class)
1:2d7909d: public class VerifyTest
5:2d7909d: {
1:2d7909d:     public static final String KEYSPACE = "Keyspace1";
1:2d7909d:     public static final String CF = "Standard1";
1:2d7909d:     public static final String CF2 = "Standard2";
1:2d7909d:     public static final String CF3 = "Standard3";
1:2d7909d:     public static final String CF4 = "Standard4";
1:2d7909d:     public static final String COUNTER_CF = "Counter1";
1:2d7909d:     public static final String COUNTER_CF2 = "Counter2";
1:2d7909d:     public static final String COUNTER_CF3 = "Counter3";
1:2d7909d:     public static final String COUNTER_CF4 = "Counter4";
1:2d7909d:     public static final String CORRUPT_CF = "Corrupt1";
1:2d7909d:     public static final String CORRUPT_CF2 = "Corrupt2";
1:2d7909d:     public static final String CORRUPTCOUNTER_CF = "CounterCorrupt1";
1:2d7909d:     public static final String CORRUPTCOUNTER_CF2 = "CounterCorrupt2";
1:2d7909d: 
1:2d7909d:     public static final String CF_UUID = "UUIDKeys";
1:2d7909d: 
1:2d7909d:     @BeforeClass
1:2d7909d:     public static void defineSchema() throws ConfigurationException
1:2d7909d:     {
1:b31845c:         CompressionParams compressionParameters = CompressionParams.snappy(32768);
1:2d7909d: 
1:2d7909d:         SchemaLoader.loadSchema();
1:2d7909d:         SchemaLoader.createKeyspace(KEYSPACE,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:b31845c:                                     SchemaLoader.standardCFMD(KEYSPACE, CF).compression(compressionParameters),
1:b31845c:                                     SchemaLoader.standardCFMD(KEYSPACE, CF2).compression(compressionParameters),
1:2d7909d:                                     SchemaLoader.standardCFMD(KEYSPACE, CF3),
1:2d7909d:                                     SchemaLoader.standardCFMD(KEYSPACE, CF4),
1:2d7909d:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF),
1:2d7909d:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF2),
1:b31845c:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF).compression(compressionParameters),
1:b31845c:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF2).compression(compressionParameters),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF3),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF4),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE, CORRUPTCOUNTER_CF),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE, CORRUPTCOUNTER_CF2),
1:a991b64:                                     SchemaLoader.standardCFMD(KEYSPACE, CF_UUID, 0, UUIDType.instance));
4:2d7909d:     }
1:2d7909d: 
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyCorrect() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
2:2d7909d:             verifier.verify(false);
1:2d7909d:         }
3:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyCounterCorrect() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF);
1:2d7909d: 
1:a991b64:         fillCounterCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(false);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testExtendedVerifyCorrect() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF2);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
2:2d7909d:             verifier.verify(true);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testExtendedVerifyCounterCorrect() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF2);
1:2d7909d: 
1:a991b64:         fillCounterCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(true);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyCorrectUncompressed() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF3);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(false);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyCounterCorrectUncompressed() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF3);
1:2d7909d: 
1:a991b64:         fillCounterCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(false);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testExtendedVerifyCorrectUncompressed() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF4);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(true);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testExtendedVerifyCounterCorrectUncompressed() throws IOException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF4);
1:2d7909d: 
1:a991b64:         fillCounterCF(cfs, 2);
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(true);
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err)
1:2d7909d:         {
1:2d7909d:             fail("Unexpected CorruptSSTableException");
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyIncorrectDigest() throws IOException, WriteTimeoutException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:a991b64:         Util.getAll(Util.cmd(cfs).build());
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:2d7909d: 
1:9484783:         try (RandomAccessFile file = new RandomAccessFile(sstable.descriptor.filenameFor(sstable.descriptor.digestComponent), "rw"))
1:9484783:         {
1:9484783:             Long correctChecksum = Long.valueOf(file.readLine());
1:9484783:     
1:9484783:             writeChecksum(++correctChecksum, sstable.descriptor.filenameFor(sstable.descriptor.digestComponent));
1:9484783:         }
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:2d7909d:         {
1:2d7909d:             verifier.verify(false);
2:2d7909d:             fail("Expected a CorruptSSTableException to be thrown");
1:2d7909d:         }
1:2d7909d:         catch (CorruptSSTableException err) {}
1:2d7909d:     }
1:2d7909d: 
1:2d7909d: 
1:2d7909d:     @Test
1:2d7909d:     public void testVerifyCorruptRowCorrectDigest() throws IOException, WriteTimeoutException
1:2d7909d:     {
1:2d7909d:         CompactionManager.instance.disableAutoCompaction();
1:2d7909d:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:2d7909d:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF2);
1:2d7909d: 
1:a991b64:         fillCF(cfs, 2);
1:2d7909d: 
1:a991b64:         Util.getAll(Util.cmd(cfs).build());
1:2d7909d: 
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:2d7909d: 
1:2d7909d:         // overwrite one row with garbage
1:69f77cb:         long row0Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("0"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
1:69f77cb:         long row1Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("1"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
1:2d7909d:         long startPosition = row0Start < row1Start ? row0Start : row1Start;
1:2d7909d:         long endPosition = row0Start < row1Start ? row1Start : row0Start;
1:2d7909d: 
1:2d7909d:         RandomAccessFile file = new RandomAccessFile(sstable.getFilename(), "rw");
1:2d7909d:         file.seek(startPosition);
1:2d7909d:         file.writeBytes(StringUtils.repeat('z', (int) 2));
2:2d7909d:         file.close();
1:30bb255:         if (ChunkCache.instance != null)
1:30bb255:             ChunkCache.instance.invalidateFile(sstable.getFilename());
1:2d7909d: 
1:2d7909d:         // Update the Digest to have the right Checksum
1:0600d7d:         writeChecksum(simpleFullChecksum(sstable.getFilename()), sstable.descriptor.filenameFor(sstable.descriptor.digestComponent));
1:2d7909d: 
1:a991b64:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:a991b64:         {
1:a991b64:             // First a simple verify checking digest, which should succeed
1:a991b64:             try
1:a991b64:             {
1:a991b64:                 verifier.verify(false);
1:a991b64:             }
1:a991b64:             catch (CorruptSSTableException err)
1:a991b64:             {
1:a991b64:                 fail("Simple verify should have succeeded as digest matched");
1:a991b64:             }
1:2d7909d: 
1:a991b64:             // Now try extended verify
1:a991b64:             try
1:a991b64:             {
1:a991b64:                 verifier.verify(true);
1:2d7909d: 
1:a991b64:             }
1:a991b64:             catch (CorruptSSTableException err)
1:a991b64:             {
1:a991b64:                 return;
1:a991b64:             }
1:a991b64:             fail("Expected a CorruptSSTableException to be thrown");
1:2d7909d:         }
1:2d7909d: 
1:2d7909d:     }
1:2d7909d: 
1:a991b64:     protected void fillCF(ColumnFamilyStore cfs, int partitionsPerSSTable)
1:2d7909d:     {
1:a991b64:         for (int i = 0; i < partitionsPerSSTable; i++)
1:2d7909d:         {
1:a991b64:             UpdateBuilder.create(cfs.metadata, String.valueOf(i))
1:a991b64:                          .newRow("c1").add("val", "1")
1:a991b64:                          .newRow("c2").add("val", "2")
1:a991b64:                          .apply();
1:2d7909d:         }
1:2d7909d: 
1:2d7909d:         cfs.forceBlockingFlush();
1:2d7909d:     }
1:2d7909d: 
1:a991b64:     protected void fillCounterCF(ColumnFamilyStore cfs, int partitionsPerSSTable) throws WriteTimeoutException
1:2d7909d:     {
1:a991b64:         for (int i = 0; i < partitionsPerSSTable; i++)
1:2d7909d:         {
1:a991b64:             UpdateBuilder.create(cfs.metadata, String.valueOf(i))
1:a991b64:                          .newRow("c1").add("val", 100L)
1:a991b64:                          .apply();
1:2d7909d:         }
1:2d7909d: 
1:2d7909d:         cfs.forceBlockingFlush();
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     protected long simpleFullChecksum(String filename) throws IOException
1:2d7909d:     {
1:9484783:         try (FileInputStream inputStream = new FileInputStream(filename))
1:9484783:         {
1:9484783:             CRC32 checksum = new CRC32();
1:9484783:             CheckedInputStream cinStream = new CheckedInputStream(inputStream, checksum);
1:9484783:             byte[] b = new byte[128];
1:9484783:             while (cinStream.read(b) >= 0) {
1:9484783:             }
1:9484783:             return cinStream.getChecksum().getValue();
1:2d7909d:         }
1:2d7909d:     }
1:2d7909d: 
1:2d7909d:     protected void writeChecksum(long checksum, String filePath)
1:2d7909d:     {
1:2d7909d:         File outFile = new File(filePath);
1:2d7909d:         BufferedWriter out = null;
12:2d7909d:         try
1:2d7909d:         {
1:2d7909d:             out = Files.newBufferedWriter(outFile.toPath(), Charsets.UTF_8);
1:2d7909d:             out.write(String.valueOf(checksum));
1:2d7909d:             out.flush();
1:2d7909d:             out.close();
1:2d7909d:         }
1:2d7909d:         catch (IOException e)
1:2d7909d:         {
1:2d7909d:             throw new FSWriteError(e, outFile);
1:2d7909d:         }
1:2d7909d:         finally
1:2d7909d:         {
1:2d7909d:             FileUtils.closeQuietly(out);
1:2d7909d:         }
1:2d7909d: 
1:2d7909d:     }
1:2d7909d: 
1:2d7909d: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9484783
/////////////////////////////////////////////////////////////////////////
1:         try (RandomAccessFile file = new RandomAccessFile(sstable.descriptor.filenameFor(sstable.descriptor.digestComponent), "rw"))
1:         {
1:             Long correctChecksum = Long.valueOf(file.readLine());
1:     
1:             writeChecksum(++correctChecksum, sstable.descriptor.filenameFor(sstable.descriptor.digestComponent));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (FileInputStream inputStream = new FileInputStream(filename))
1:         {
1:             CRC32 checksum = new CRC32();
1:             CheckedInputStream cinStream = new CheckedInputStream(inputStream, checksum);
1:             byte[] b = new byte[128];
1:             while (cinStream.read(b) >= 0) {
1:             }
1:             return cinStream.getChecksum().getValue();
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:30bb255
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cache.ChunkCache;
/////////////////////////////////////////////////////////////////////////
1:         if (ChunkCache.instance != null)
1:             ChunkCache.instance.invalidateFile(sstable.getFilename());
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
1:         long row0Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("0"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
1:         long row1Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("1"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0600d7d
/////////////////////////////////////////////////////////////////////////
0:         RandomAccessFile file = new RandomAccessFile(sstable.descriptor.filenameFor(sstable.descriptor.digestComponent), "rw");
0:         writeChecksum(++correctChecksum, sstable.descriptor.filenameFor(sstable.descriptor.digestComponent));
/////////////////////////////////////////////////////////////////////////
1:         writeChecksum(simpleFullChecksum(sstable.getFilename()), sstable.descriptor.filenameFor(sstable.descriptor.digestComponent));
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:5baf28d
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import java.util.zip.CRC32;
/////////////////////////////////////////////////////////////////////////
0:         CRC32 checksum = new CRC32();
0:         CheckedInputStream cinStream = new CheckedInputStream(inputStream, checksum);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:b31845c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.CompressionParams;
/////////////////////////////////////////////////////////////////////////
1:         CompressionParams compressionParameters = CompressionParams.snappy(32768);
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CF).compression(compressionParameters),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CF2).compression(compressionParameters),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF).compression(compressionParameters),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF2).compression(compressionParameters),
commit:0a08525
/////////////////////////////////////////////////////////////////////////
0:         long row0Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("0"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
0:         long row1Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("1"), cfs.getPartitioner()), SSTableReader.Operator.EQ).position;
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.db;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0:         long row0Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("0"), sstable.partitioner), SSTableReader.Operator.EQ).position;
0:         long row1Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("1"), sstable.partitioner), SSTableReader.Operator.EQ).position;
commit:b25adc7
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
author:blerer
-------------------------------------------------------------------------------
commit:056115f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         CompressionParameters compressionParameters = CompressionParameters.snappy(32768);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.UpdateBuilder;
0: import org.apache.cassandra.db.partitions.PartitionIterator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF).compressionParameters(compressionParameters),
0:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF2).compressionParameters(compressionParameters),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF3),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, COUNTER_CF4),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, CORRUPTCOUNTER_CF),
1:                                     SchemaLoader.counterCFMD(KEYSPACE, CORRUPTCOUNTER_CF2),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CF_UUID, 0, UUIDType.instance));
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCounterCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCounterCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCounterCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCounterCF(cfs, 2);
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         Util.getAll(Util.cmd(cfs).build());
/////////////////////////////////////////////////////////////////////////
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
/////////////////////////////////////////////////////////////////////////
1:         fillCF(cfs, 2);
1:         Util.getAll(Util.cmd(cfs).build());
0:         long row0Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("0"), sstable.partitioner), SSTableReader.Operator.EQ).position;
0:         long row1Start = sstable.getPosition(PartitionPosition.ForKey.get(ByteBufferUtil.bytes("1"), sstable.partitioner), SSTableReader.Operator.EQ).position;
/////////////////////////////////////////////////////////////////////////
1:         try (Verifier verifier = new Verifier(cfs, sstable, false))
1:         {
1:             // First a simple verify checking digest, which should succeed
1:             try
1:             {
1:                 verifier.verify(false);
1:             }
1:             catch (CorruptSSTableException err)
1:             {
1:                 fail("Simple verify should have succeeded as digest matched");
1:             }
1:             // Now try extended verify
1:             try
1:             {
1:                 verifier.verify(true);
1:             }
1:             catch (CorruptSSTableException err)
1:             {
1:                 return;
1:             }
1:             fail("Expected a CorruptSSTableException to be thrown");
1:     protected void fillCF(ColumnFamilyStore cfs, int partitionsPerSSTable)
1:         for (int i = 0; i < partitionsPerSSTable; i++)
1:             UpdateBuilder.create(cfs.metadata, String.valueOf(i))
1:                          .newRow("c1").add("val", "1")
1:                          .newRow("c2").add("val", "2")
1:                          .apply();
1:     protected void fillCounterCF(ColumnFamilyStore cfs, int partitionsPerSSTable) throws WriteTimeoutException
1:         for (int i = 0; i < partitionsPerSSTable; i++)
1:             UpdateBuilder.create(cfs.metadata, String.valueOf(i))
1:                          .newRow("c1").add("val", 100L)
1:                          .apply();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5de72e5
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.standardCFMD(KEYSPACE, COUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, COUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, COUNTER_CF3, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, COUNTER_CF4, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPTCOUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPTCOUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance),
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:4e29b7a
/////////////////////////////////////////////////////////////////////////
0:         try(Verifier verifier = new Verifier(cfs, sstable, false))
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:2d7909d
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
1: /*
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  *
1:  */
1: 
1: import com.google.common.base.Charsets;
1: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.Util;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
1: import org.apache.cassandra.db.compaction.CompactionManager;
1: import org.apache.cassandra.db.compaction.Verifier;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
1: import org.apache.cassandra.db.marshal.UUIDType;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.WriteTimeoutException;
1: import org.apache.cassandra.io.FSWriteError;
0: import org.apache.cassandra.io.compress.*;
0: import org.apache.cassandra.io.sstable.Component;
1: import org.apache.cassandra.io.sstable.CorruptSSTableException;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
1: import org.apache.cassandra.io.util.FileUtils;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.commons.lang3.StringUtils;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: 
1: import java.io.*;
1: import java.nio.file.Files;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.zip.Adler32;
1: import java.util.zip.CheckedInputStream;
1: 
0: import static org.apache.cassandra.Util.cellname;
0: import static org.apache.cassandra.Util.column;
1: import static org.junit.Assert.fail;
1: 
1: @RunWith(OrderedJUnit4ClassRunner.class)
1: public class VerifyTest
1: {
1:     public static final String KEYSPACE = "Keyspace1";
1:     public static final String CF = "Standard1";
1:     public static final String CF2 = "Standard2";
1:     public static final String CF3 = "Standard3";
1:     public static final String CF4 = "Standard4";
1:     public static final String COUNTER_CF = "Counter1";
1:     public static final String COUNTER_CF2 = "Counter2";
1:     public static final String COUNTER_CF3 = "Counter3";
1:     public static final String COUNTER_CF4 = "Counter4";
1:     public static final String CORRUPT_CF = "Corrupt1";
1:     public static final String CORRUPT_CF2 = "Corrupt2";
1:     public static final String CORRUPTCOUNTER_CF = "CounterCorrupt1";
1:     public static final String CORRUPTCOUNTER_CF2 = "CounterCorrupt2";
1: 
1:     public static final String CF_UUID = "UUIDKeys";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
0:         CompressionParameters compressionParameters = new CompressionParameters(SnappyCompressor.instance, 32768, new HashMap<String, String>());
1: 
1:         SchemaLoader.loadSchema();
1:         SchemaLoader.createKeyspace(KEYSPACE,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF).compressionParameters(compressionParameters),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF2).compressionParameters(compressionParameters),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CF3),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CF4),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF2),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF3, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF4, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, CORRUPTCOUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, CORRUPTCOUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF_UUID).keyValidator(UUIDType.instance));
1:     }
1: 
1: 
1:     @Test
1:     public void testVerifyCorrect() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF);
1: 
0:         fillCF(cfs, KEYSPACE, CF, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(false);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testVerifyCounterCorrect() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF);
1: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(false);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testExtendedVerifyCorrect() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF2);
1: 
0:         fillCF(cfs, KEYSPACE, CF2, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(true);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testExtendedVerifyCounterCorrect() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF2);
1: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF2, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(true);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testVerifyCorrectUncompressed() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF3);
1: 
0:         fillCF(cfs, KEYSPACE, CF3, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(false);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testVerifyCounterCorrectUncompressed() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF3);
1: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF3, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(false);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testExtendedVerifyCorrectUncompressed() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF4);
1: 
0:         fillCF(cfs, KEYSPACE, CF4, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(true);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1:     @Test
1:     public void testExtendedVerifyCounterCorrectUncompressed() throws IOException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF4);
1: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF4, 2);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(true);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
1:             fail("Unexpected CorruptSSTableException");
1:         }
1:     }
1: 
1: 
1:     @Test
1:     public void testVerifyIncorrectDigest() throws IOException, WriteTimeoutException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF);
1: 
0:         fillCF(cfs, KEYSPACE, CORRUPT_CF, 2);
1: 
0:         List<Row> rows = cfs.getRangeSlice(Util.range("", ""), null, new IdentityQueryFilter(), 1000);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
1: 
0:         RandomAccessFile file = new RandomAccessFile(sstable.descriptor.filenameFor(Component.DIGEST), "rw");
0:         Long correctChecksum = Long.parseLong(file.readLine());
1:         file.close();
1: 
0:         writeChecksum(++correctChecksum, sstable.descriptor.filenameFor(Component.DIGEST));
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1:         try
1:         {
1:             verifier.verify(false);
1:             fail("Expected a CorruptSSTableException to be thrown");
1:         }
1:         catch (CorruptSSTableException err) {}
1:     }
1: 
1: 
1:     @Test
1:     public void testVerifyCorruptRowCorrectDigest() throws IOException, WriteTimeoutException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF2);
1: 
0:         fillCF(cfs, KEYSPACE, CORRUPT_CF2, 2);
1: 
0:         List<Row> rows = cfs.getRangeSlice(Util.range("", ""), null, new IdentityQueryFilter(), 1000);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1: 
1:         // overwrite one row with garbage
0:         long row0Start = sstable.getPosition(RowPosition.ForKey.get(ByteBufferUtil.bytes("0"), sstable.partitioner), SSTableReader.Operator.EQ).position;
0:         long row1Start = sstable.getPosition(RowPosition.ForKey.get(ByteBufferUtil.bytes("1"), sstable.partitioner), SSTableReader.Operator.EQ).position;
1:         long startPosition = row0Start < row1Start ? row0Start : row1Start;
1:         long endPosition = row0Start < row1Start ? row1Start : row0Start;
1: 
1:         RandomAccessFile file = new RandomAccessFile(sstable.getFilename(), "rw");
1:         file.seek(startPosition);
1:         file.writeBytes(StringUtils.repeat('z', (int) 2));
1:         file.close();
1: 
1:         // Update the Digest to have the right Checksum
0:         writeChecksum(simpleFullChecksum(sstable.getFilename()), sstable.descriptor.filenameFor(Component.DIGEST));
1: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
1: 
0:         // First a simple verify checking digest, which should succeed
1:         try
1:         {
1:             verifier.verify(false);
1:         }
1:         catch (CorruptSSTableException err)
1:         {
0:             fail("Simple verify should have succeeded as digest matched");
1:         }
1: 
0:         // Now try extended verify
1:         try
1:         {
1:             verifier.verify(true);
1: 
1:         }
1:         catch (CorruptSSTableException err)
1:         {
0:             return;
1:         }
1:         fail("Expected a CorruptSSTableException to be thrown");
1: 
1:     }
1: 
0:     protected void fillCF(ColumnFamilyStore cfs, String keyspace, String columnFamily, int rowsPerSSTable)
1:     {
0:         for (int i = 0; i < rowsPerSSTable; i++)
1:         {
0:             String key = String.valueOf(i);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(keyspace, columnFamily);
0:             cf.addColumn(column("c1", "1", 1L));
0:             cf.addColumn(column("c2", "2", 1L));
0:             Mutation rm = new Mutation(keyspace, ByteBufferUtil.bytes(key), cf);
0:             rm.apply();
1:         }
1: 
1:         cfs.forceBlockingFlush();
1:     }
1: 
0:     protected void fillCounterCF(ColumnFamilyStore cfs, String keyspace, String columnFamily, int rowsPerSSTable) throws WriteTimeoutException
1:     {
0:         for (int i = 0; i < rowsPerSSTable; i++)
1:         {
0:             String key = String.valueOf(i);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(keyspace, columnFamily);
0:             Mutation rm = new Mutation(keyspace, ByteBufferUtil.bytes(key), cf);
0:             rm.addCounter(columnFamily, cellname("Column1"), 100);
0:             CounterMutation cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:             cm.apply();
1:         }
1: 
1:         cfs.forceBlockingFlush();
1:     }
1: 
1:     protected long simpleFullChecksum(String filename) throws IOException
1:     {
0:         FileInputStream inputStream = new FileInputStream(filename);
0:         Adler32 adlerChecksum = new Adler32();
0:         CheckedInputStream cinStream = new CheckedInputStream(inputStream, adlerChecksum);
0:         byte[] b = new byte[128];
0:         while (cinStream.read(b) >= 0) {
1:         }
0:         return cinStream.getChecksum().getValue();
1:     }
1: 
1:     protected void writeChecksum(long checksum, String filePath)
1:     {
1:         File outFile = new File(filePath);
1:         BufferedWriter out = null;
1:         try
1:         {
1:             out = Files.newBufferedWriter(outFile.toPath(), Charsets.UTF_8);
1:             out.write(String.valueOf(checksum));
1:             out.flush();
1:             out.close();
1:         }
1:         catch (IOException e)
1:         {
1:             throw new FSWriteError(e, outFile);
1:         }
1:         finally
1:         {
1:             FileUtils.closeQuietly(out);
1:         }
1: 
1:     }
1: 
1: }
author:Jeff Jirsa
-------------------------------------------------------------------------------
commit:21bdf87
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: /*
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  *
0:  */
0: 
0: import com.google.common.base.Charsets;
0: import org.apache.cassandra.OrderedJUnit4ClassRunner;
0: import org.apache.cassandra.SchemaLoader;
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
0: import org.apache.cassandra.db.compaction.CompactionManager;
0: import org.apache.cassandra.db.compaction.Verifier;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
0: import org.apache.cassandra.db.marshal.UUIDType;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.exceptions.WriteTimeoutException;
0: import org.apache.cassandra.io.FSWriteError;
0: import org.apache.cassandra.io.compress.*;
0: import org.apache.cassandra.io.sstable.Component;
0: import org.apache.cassandra.io.sstable.CorruptSSTableException;
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.io.util.FileUtils;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.commons.lang3.StringUtils;
0: import org.junit.BeforeClass;
0: import org.junit.Test;
0: import org.junit.runner.RunWith;
0: 
0: import java.io.*;
0: import java.nio.file.Files;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.zip.Adler32;
0: import java.util.zip.CheckedInputStream;
0: 
0: import static org.apache.cassandra.Util.cellname;
0: import static org.apache.cassandra.Util.column;
0: import static org.junit.Assert.fail;
0: 
0: @RunWith(OrderedJUnit4ClassRunner.class)
0: public class VerifyTest
0: {
0:     public static final String KEYSPACE = "Keyspace1";
0:     public static final String CF = "Standard1";
0:     public static final String CF2 = "Standard2";
0:     public static final String CF3 = "Standard3";
0:     public static final String CF4 = "Standard4";
0:     public static final String COUNTER_CF = "Counter1";
0:     public static final String COUNTER_CF2 = "Counter2";
0:     public static final String COUNTER_CF3 = "Counter3";
0:     public static final String COUNTER_CF4 = "Counter4";
0:     public static final String CORRUPT_CF = "Corrupt1";
0:     public static final String CORRUPT_CF2 = "Corrupt2";
0:     public static final String CORRUPTCOUNTER_CF = "CounterCorrupt1";
0:     public static final String CORRUPTCOUNTER_CF2 = "CounterCorrupt2";
0: 
0:     public static final String CF_UUID = "UUIDKeys";
0: 
0:     @BeforeClass
0:     public static void defineSchema() throws ConfigurationException
0:     {
0:         CompressionParameters compressionParameters = new CompressionParameters(SnappyCompressor.instance, 32768, new HashMap<String, String>());
0: 
0:         SchemaLoader.loadSchema();
0:         SchemaLoader.createKeyspace(KEYSPACE,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF).compressionParameters(compressionParameters),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF2).compressionParameters(compressionParameters),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF3),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF4),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CORRUPT_CF2),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance).compressionParameters(compressionParameters),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF3, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, COUNTER_CF4, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, CORRUPTCOUNTER_CF, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE, CORRUPTCOUNTER_CF2, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE, CF_UUID).keyValidator(UUIDType.instance));
0:     }
0: 
0: 
0:     @Test
0:     public void testVerifyCorrect() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF);
0: 
0:         fillCF(cfs, KEYSPACE, CF, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(false);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testVerifyCounterCorrect() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF);
0: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(false);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testExtendedVerifyCorrect() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF2);
0: 
0:         fillCF(cfs, KEYSPACE, CF2, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(true);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testExtendedVerifyCounterCorrect() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF2);
0: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF2, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(true);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testVerifyCorrectUncompressed() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF3);
0: 
0:         fillCF(cfs, KEYSPACE, CF3, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(false);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testVerifyCounterCorrectUncompressed() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF3);
0: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF3, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(false);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testExtendedVerifyCorrectUncompressed() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF4);
0: 
0:         fillCF(cfs, KEYSPACE, CF4, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(true);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0:     @Test
0:     public void testExtendedVerifyCounterCorrectUncompressed() throws IOException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(COUNTER_CF4);
0: 
0:         fillCounterCF(cfs, KEYSPACE, COUNTER_CF4, 2);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(true);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Unexpected CorruptSSTableException");
0:         }
0:     }
0: 
0: 
0:     @Test
0:     public void testVerifyIncorrectDigest() throws IOException, WriteTimeoutException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF);
0: 
0:         fillCF(cfs, KEYSPACE, CORRUPT_CF, 2);
0: 
0:         List<Row> rows = cfs.getRangeSlice(Util.range("", ""), null, new IdentityQueryFilter(), 1000);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0: 
0:         RandomAccessFile file = new RandomAccessFile(sstable.descriptor.filenameFor(Component.DIGEST), "rw");
0:         Long correctChecksum = Long.parseLong(file.readLine());
0:         file.close();
0: 
0:         writeChecksum(++correctChecksum, sstable.descriptor.filenameFor(Component.DIGEST));
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0:         try
0:         {
0:             verifier.verify(false);
0:             fail("Expected a CorruptSSTableException to be thrown");
0:         }
0:         catch (CorruptSSTableException err) {}
0:     }
0: 
0: 
0:     @Test
0:     public void testVerifyCorruptRowCorrectDigest() throws IOException, WriteTimeoutException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Keyspace keyspace = Keyspace.open(KEYSPACE);
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CORRUPT_CF2);
0: 
0:         fillCF(cfs, KEYSPACE, CORRUPT_CF2, 2);
0: 
0:         List<Row> rows = cfs.getRangeSlice(Util.range("", ""), null, new IdentityQueryFilter(), 1000);
0: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
0: 
0:         // overwrite one row with garbage
0:         long row0Start = sstable.getPosition(RowPosition.ForKey.get(ByteBufferUtil.bytes("0"), sstable.partitioner), SSTableReader.Operator.EQ).position;
0:         long row1Start = sstable.getPosition(RowPosition.ForKey.get(ByteBufferUtil.bytes("1"), sstable.partitioner), SSTableReader.Operator.EQ).position;
0:         long startPosition = row0Start < row1Start ? row0Start : row1Start;
0:         long endPosition = row0Start < row1Start ? row1Start : row0Start;
0: 
0:         RandomAccessFile file = new RandomAccessFile(sstable.getFilename(), "rw");
0:         file.seek(startPosition);
0:         file.writeBytes(StringUtils.repeat('z', (int) 2));
0:         file.close();
0: 
0:         // Update the Digest to have the right Checksum
0:         writeChecksum(simpleFullChecksum(sstable.getFilename()), sstable.descriptor.filenameFor(Component.DIGEST));
0: 
0:         Verifier verifier = new Verifier(cfs, sstable, false);
0: 
0:         // First a simple verify checking digest, which should succeed
0:         try
0:         {
0:             verifier.verify(false);
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             fail("Simple verify should have succeeded as digest matched");
0:         }
0: 
0:         // Now try extended verify
0:         try
0:         {
0:             verifier.verify(true);
0: 
0:         }
0:         catch (CorruptSSTableException err)
0:         {
0:             return;
0:         }
0:         fail("Expected a CorruptSSTableException to be thrown");
0: 
0:     }
0: 
0:     protected void fillCF(ColumnFamilyStore cfs, String keyspace, String columnFamily, int rowsPerSSTable)
0:     {
0:         for (int i = 0; i < rowsPerSSTable; i++)
0:         {
0:             String key = String.valueOf(i);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(keyspace, columnFamily);
0:             cf.addColumn(column("c1", "1", 1L));
0:             cf.addColumn(column("c2", "2", 1L));
0:             Mutation rm = new Mutation(keyspace, ByteBufferUtil.bytes(key), cf);
0:             rm.apply();
0:         }
0: 
0:         cfs.forceBlockingFlush();
0:     }
0: 
0:     protected void fillCounterCF(ColumnFamilyStore cfs, String keyspace, String columnFamily, int rowsPerSSTable) throws WriteTimeoutException
0:     {
0:         for (int i = 0; i < rowsPerSSTable; i++)
0:         {
0:             String key = String.valueOf(i);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(keyspace, columnFamily);
0:             Mutation rm = new Mutation(keyspace, ByteBufferUtil.bytes(key), cf);
0:             rm.addCounter(columnFamily, cellname("Column1"), 100);
0:             CounterMutation cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:             cm.apply();
0:         }
0: 
0:         cfs.forceBlockingFlush();
0:     }
0: 
0:     protected long simpleFullChecksum(String filename) throws IOException
0:     {
0:         FileInputStream inputStream = new FileInputStream(filename);
0:         Adler32 adlerChecksum = new Adler32();
0:         CheckedInputStream cinStream = new CheckedInputStream(inputStream, adlerChecksum);
0:         byte[] b = new byte[128];
0:         while (cinStream.read(b) >= 0) {
0:         }
0:         return cinStream.getChecksum().getValue();
0:     }
0: 
0:     protected void writeChecksum(long checksum, String filePath)
0:     {
0:         File outFile = new File(filePath);
0:         BufferedWriter out = null;
0:         try
0:         {
0:             out = Files.newBufferedWriter(outFile.toPath(), Charsets.UTF_8);
0:             out.write(String.valueOf(checksum));
0:             out.flush();
0:             out.close();
0:         }
0:         catch (IOException e)
0:         {
0:             throw new FSWriteError(e, outFile);
0:         }
0:         finally
0:         {
0:             FileUtils.closeQuietly(out);
0:         }
0: 
0:     }
0: 
0: }
============================================================================