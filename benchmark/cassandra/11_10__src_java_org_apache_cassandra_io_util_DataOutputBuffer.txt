1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:9252ee9:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
3:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:066ef58:  */
1:dc6e4fe: package org.apache.cassandra.io.util;
1:f7aaea0: 
1:9252ee9: import java.io.IOException;
1:75508ec: import java.nio.ByteBuffer;
1:16499ca: import java.nio.channels.WritableByteChannel;
1:7ed395d: 
1:f7aaea0: import com.google.common.annotations.VisibleForTesting;
1:f7aaea0: import com.google.common.base.Preconditions;
1:f7aaea0: 
1:dc9ed46: import io.netty.util.concurrent.FastThreadLocal;
1:1e92ce4: import org.apache.cassandra.config.Config;
1:1e92ce4: 
3:066ef58: /**
1:9252ee9:  * An implementation of the DataOutputStream interface using a FastByteArrayOutputStream and exposing
1:9252ee9:  * its buffer so copies can be avoided.
1:f44110c:  *
1:9252ee9:  * This class is completely thread unsafe.
1:066ef58:  */
1:16499ca: public class DataOutputBuffer extends BufferedDataOutputStreamPlus
1:16499ca: {
1:f7aaea0:     /*
1:f7aaea0:      * Threshold at which resizing transitions from doubling to increasing by 50%
1:f7aaea0:      */
1:f7aaea0:     private static final long DOUBLING_THRESHOLD = Long.getLong(Config.PROPERTY_PREFIX + "DOB_DOUBLING_THRESHOLD_MB", 64);
1:7ed395d: 
1:eb5a59a:     /*
1:eb5a59a:      * Only recycle OutputBuffers up to 1Mb. Larger buffers will be trimmed back to this size.
1:eb5a59a:      */
1:dc9ed46:     private static final int MAX_RECYCLE_BUFFER_SIZE = Integer.getInteger(Config.PROPERTY_PREFIX + "dob_max_recycle_bytes", 1024 * 1024);
1:7ed395d: 
1:eb5a59a:     private static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;
1:eb5a59a: 
1:dc9ed46:     /**
1:dc9ed46:      * Scratch buffers used mostly for serializing in memory. It's important to call #recycle() when finished
1:dc9ed46:      * to keep the memory overhead from being too large in the system.
1:dc9ed46:      */
1:dc9ed46:     public static final FastThreadLocal<DataOutputBuffer> scratchBuffer = new FastThreadLocal<DataOutputBuffer>()
1:1e92ce4:     {
1:dc9ed46:         protected DataOutputBuffer initialValue() throws Exception
1:1e92ce4:         {
1:05660a5:             return new DataOutputBuffer()
1:05660a5:             {
1:05660a5:                 public void close()
1:05660a5:                 {
1:05660a5:                     if (buffer.capacity() <= MAX_RECYCLE_BUFFER_SIZE)
1:05660a5:                     {
1:05660a5:                         buffer.clear();
1:05660a5:                     }
1:05660a5:                     else
1:05660a5:                     {
1:05660a5:                         buffer = ByteBuffer.allocate(DEFAULT_INITIAL_BUFFER_SIZE);
1:05660a5:                     }
1:05660a5:                 }
1:05660a5:             };
1:1e92ce4:         }
1:1e92ce4:     };
1:1e92ce4: 
1:066ef58:     public DataOutputBuffer()
1:1e92ce4:     {
1:eb5a59a:         this(DEFAULT_INITIAL_BUFFER_SIZE);
1:1e92ce4:     }
1:1e92ce4: 
1:c2d748c:     public DataOutputBuffer(int size)
1:1e92ce4:     {
1:dc9ed46:         super(ByteBuffer.allocate(size));
1:1e92ce4:     }
1:1e92ce4: 
1:dc9ed46:     public DataOutputBuffer(ByteBuffer buffer)
1:7ed395d:     {
1:16499ca:         super(buffer);
1:dc9ed46:     }
1:1e92ce4: 
1:16499ca:     @Override
1:16499ca:     public void flush() throws IOException
1:dc9ed46:     {
1:16499ca:         throw new UnsupportedOperationException();
1:1e92ce4:     }
1:1e92ce4: 
1:f7aaea0:     //The actual value observed in Hotspot is only -2
1:f7aaea0:     //ByteArrayOutputStream uses -8
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
1:1e92ce4: 
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     static int saturatedArraySizeCast(long size)
1:1e92ce4:     {
1:f7aaea0:         Preconditions.checkArgument(size >= 0);
1:f7aaea0:         return (int)Math.min(MAX_ARRAY_SIZE, size);
1:7ed395d:     }
1:7ed395d: 
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     static int checkedArraySizeCast(long size)
1:7ed395d:     {
1:f7aaea0:         Preconditions.checkArgument(size >= 0);
1:f7aaea0:         Preconditions.checkArgument(size <= MAX_ARRAY_SIZE);
1:f7aaea0:         return (int)size;
1:063e917:     }
1:7ed395d: 
1:f7aaea0:     @Override
1:f7aaea0:     protected void doFlush(int count) throws IOException
1:063e917:     {
1:f7aaea0:         reallocate(count);
1:578c85d:     }
1:7ed395d: 
1:f7aaea0:     //Hack for test, make it possible to override checking the buffer capacity
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     long capacity()
1:578c85d:     {
1:f7aaea0:         return buffer.capacity();
1:f7aaea0:     }
1:7ed395d: 
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     long validateReallocation(long newSize)
1:f7aaea0:     {
1:f7aaea0:         int saturatedSize = saturatedArraySizeCast(newSize);
1:f7aaea0:         if (saturatedSize <= capacity())
1:f7aaea0:             throw new RuntimeException();
1:f7aaea0:         return saturatedSize;
1:f7aaea0:     }
1:7ed395d: 
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     long calculateNewSize(long count)
1:f7aaea0:     {
1:f7aaea0:         long capacity = capacity();
1:f7aaea0:         //Both sides of this max expression need to use long arithmetic to avoid integer overflow
1:f7aaea0:         //count and capacity are longs so that ensures it right now.
1:f7aaea0:         long newSize = capacity + count;
1:eb5a59a: 
1:f7aaea0:         //For large buffers don't double, increase by 50%
1:f7aaea0:         if (capacity > 1024L * 1024L * DOUBLING_THRESHOLD)
1:f7aaea0:             newSize = Math.max((capacity * 3L) / 2L, newSize);
1:dc9ed46:         else
1:f7aaea0:             newSize = Math.max(capacity * 2L, newSize);
1:eb5a59a: 
1:f7aaea0:         return validateReallocation(newSize);
1:f7aaea0:     }
1:f7aaea0: 
1:f7aaea0:     protected void reallocate(long count)
1:f7aaea0:     {
1:f7aaea0:         if (count <= 0)
1:f7aaea0:             return;
1:f7aaea0:         ByteBuffer newBuffer = ByteBuffer.allocate(checkedArraySizeCast(calculateNewSize(count)));
1:16499ca:         buffer.flip();
1:16499ca:         newBuffer.put(buffer);
1:16499ca:         buffer = newBuffer;
1:f7aaea0:     }
1:f7aaea0: 
1:16499ca:     @Override
1:16499ca:     protected WritableByteChannel newDefaultChannel()
1:f7aaea0:     {
1:16499ca:         return new GrowingChannel();
1:f7aaea0:     }
1:f7aaea0: 
1:ae4d705:     public void clear()
1:ae4d705:     {
1:dc9ed46:         buffer.clear();
1:ae4d705:     }
1:ae4d705: 
1:f7aaea0:     @VisibleForTesting
1:f7aaea0:     final class GrowingChannel implements WritableByteChannel
1:f7aaea0:     {
1:16499ca:         public int write(ByteBuffer src) throws IOException
1:16499ca:         {
1:16499ca:             int count = src.remaining();
1:f7aaea0:             reallocate(count);
1:16499ca:             buffer.put(src);
1:16499ca:             return count;
1:16499ca:         }
1:f7aaea0: 
1:16499ca:         public boolean isOpen()
1:16499ca:         {
1:16499ca:             return true;
1:16499ca:         }
1:f7aaea0: 
1:7aafe05:         public void close()
1:16499ca:         {
1:16499ca:         }
1:16499ca:     }
1:f7aaea0: 
2:9252ee9:     @Override
1:f55a4f4:     public void close()
1:16499ca:     {
1:16499ca:     }
1:f7aaea0: 
1:16499ca:     public ByteBuffer buffer()
1:16499ca:     {
1:16499ca:         ByteBuffer result = buffer.duplicate();
1:16499ca:         result.flip();
1:16499ca:         return result;
1:16499ca:     }
1:f7aaea0: 
2:066ef58:     public byte[] getData()
1:75508ec:     {
1:1db386e:         assert buffer.arrayOffset() == 0;
1:16499ca:         return buffer.array();
1:16499ca:     }
8:16499ca: 
1:16499ca:     public int getLength()
1:16499ca:     {
1:16499ca:         return buffer.position();
1:51b1a1c:     }
1:51b1a1c: 
1:753a943:     public boolean hasPosition()
1:51b1a1c:     {
1:51b1a1c:         return true;
1:51b1a1c:     }
1:51b1a1c: 
1:753a943:     public long position()
1:51b1a1c:     {
1:7ed395d:         return getLength();
1:7ed395d:     }
1:7ed395d: 
1:063e917:     public ByteBuffer asNewBuffer()
1:7ed395d:     {
1:063e917:         return ByteBuffer.wrap(getData(), 0, getLength());
1:7ed395d:     }
1:063e917: 
1:75508ec:     public byte[] toByteArray()
2:75508ec:     {
1:16499ca:         ByteBuffer buffer = buffer();
1:16499ca:         byte[] result = new byte[buffer.remaining()];
1:16499ca:         buffer.get(result);
1:16499ca:         return result;
1:75508ec:     }
2:75508ec: }
============================================================================
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:05660a5
/////////////////////////////////////////////////////////////////////////
1:             return new DataOutputBuffer()
1:             {
1:                 public void close()
1:                 {
1:                     if (buffer.capacity() <= MAX_RECYCLE_BUFFER_SIZE)
1:                     {
1:                         buffer.clear();
1:                     }
1:                     else
1:                     {
1:                         buffer = ByteBuffer.allocate(DEFAULT_INITIAL_BUFFER_SIZE);
1:                     }
1:                 }
1:             };
/////////////////////////////////////////////////////////////////////////
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: import io.netty.util.concurrent.FastThreadLocal;
/////////////////////////////////////////////////////////////////////////
1:     private static final int MAX_RECYCLE_BUFFER_SIZE = Integer.getInteger(Config.PROPERTY_PREFIX + "dob_max_recycle_bytes", 1024 * 1024);
1:     /**
1:      * Scratch buffers used mostly for serializing in memory. It's important to call #recycle() when finished
1:      * to keep the memory overhead from being too large in the system.
1:      */
1:     public static final FastThreadLocal<DataOutputBuffer> scratchBuffer = new FastThreadLocal<DataOutputBuffer>()
1:         protected DataOutputBuffer initialValue() throws Exception
0:             return new DataOutputBuffer();
/////////////////////////////////////////////////////////////////////////
1:         super(ByteBuffer.allocate(size));
1:     public DataOutputBuffer(ByteBuffer buffer)
0:         if (buffer.capacity() <= MAX_RECYCLE_BUFFER_SIZE)
1:             buffer.clear();
1:         }
1:         else
1:         {
0:             buffer = ByteBuffer.allocate(DEFAULT_INITIAL_BUFFER_SIZE);
commit:1e92ce4
/////////////////////////////////////////////////////////////////////////
0: import io.netty.util.Recycler;
1: import org.apache.cassandra.config.Config;
1: 
/////////////////////////////////////////////////////////////////////////
0:     public static final Recycler<DataOutputBuffer> RECYCLER = new Recycler<DataOutputBuffer>()
1:     {
0:         protected DataOutputBuffer newObject(Handle handle)
1:         {
0:             return new DataOutputBuffer(handle);
1:         }
1:     };
1: 
0:     private final Recycler.Handle handle;
1: 
0:     private DataOutputBuffer(Recycler.Handle handle)
1:     {
0:         this(128, handle);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         this(size, null);
0:     protected DataOutputBuffer(int size, Recycler.Handle handle)
1:     {
0:         this(ByteBuffer.allocate(size), handle);
1:     }
1: 
0:     protected DataOutputBuffer(ByteBuffer buffer, Recycler.Handle handle)
0:         this.handle = handle;
1:     }
1: 
0:     public void recycle()
1:     {
0:         assert handle != null;
0:         buffer.rewind();
1: 
0:         RECYCLER.recycle(this, handle);
commit:6bf1f75
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
1:     public void close()
commit:7ed395d
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
1: 
0: import org.apache.cassandra.utils.Pair;
0: public final class DataOutputBuffer extends DataOutputStream implements PageCacheInformer
0:     private List<Pair<Integer, Integer>> pageCacheMarkers;
1: 
/////////////////////////////////////////////////////////////////////////
0:         pageCacheMarkers = null;
1: 
1: 
0:     /** {@InheritDoc} */
0:     public void keepCacheWindow(long startAt)
1:     {
0:         if (pageCacheMarkers == null)
0:             pageCacheMarkers = new ArrayList<Pair<Integer,Integer>>();
1: 
0:         long endAt = getCurrentPosition();
1: 
0:         assert startAt <= endAt;
1: 
0:         pageCacheMarkers.add(new Pair<Integer,Integer>((int) startAt, (int) (endAt - startAt)));
1:     }
1: 
0:     /** {@InheritDoc} */
0:     public long getCurrentPosition()
1:     {
1:         return getLength();
1:     }
1: 
0:     public final List<Pair<Integer,Integer>> getPageCacheMarkers()
1:     {
0:         return pageCacheMarkers;
1:     }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:ae4d705
/////////////////////////////////////////////////////////////////////////
1:     public void clear()
1:     {
0:         buffer.clear();
1:     }
1: 
commit:063e917
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer asNewBuffer()
1:     {
1:         return ByteBuffer.wrap(getData(), 0, getLength());
1:     }
1: 
commit:cdaba04
commit:753a943
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasPosition()
1:     public long position()
commit:acb8fbb
commit:51b1a1c
/////////////////////////////////////////////////////////////////////////
0:     public boolean hasFilePointer()
1:     {
1:         return true;
1:     }
1: 
0:     public long getFilePointer()
1:     {
0:         return getLength();
1:     }
1: 
author:Alex Petrov
-------------------------------------------------------------------------------
commit:578c85d
/////////////////////////////////////////////////////////////////////////
0:         if (buffer().capacity() <= MAX_RECYCLE_BUFFER_SIZE)
1:         {
0:             buffer.rewind();
0:             RECYCLER.recycle(this, handle);
1:         }
commit:eb5a59a
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Only recycle OutputBuffers up to 1Mb. Larger buffers will be trimmed back to this size.
1:      */
0:     private static final int MAX_RECYCLE_BUFFER_SIZE = 1024 * 1024;
1: 
1:     private static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;
1: 
/////////////////////////////////////////////////////////////////////////
0:         this(DEFAULT_INITIAL_BUFFER_SIZE, handle);
1:         this(DEFAULT_INITIAL_BUFFER_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         // Avoid throwing away instances that are too large, trim large buffers to default size instead.
0:         // See CASSANDRA-11838 for details.
0:         if (buffer().capacity() > MAX_RECYCLE_BUFFER_SIZE)
0:             buffer = ByteBuffer.allocate(DEFAULT_INITIAL_BUFFER_SIZE);
1: 
0:         buffer.rewind();
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:f7aaea0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Config;
1: 
1: import com.google.common.annotations.VisibleForTesting;
1: import com.google.common.base.Preconditions;
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Threshold at which resizing transitions from doubling to increasing by 50%
1:      */
1:     private static final long DOUBLING_THRESHOLD = Long.getLong(Config.PROPERTY_PREFIX + "DOB_DOUBLING_THRESHOLD_MB", 64);
1: 
/////////////////////////////////////////////////////////////////////////
1:     //The actual value observed in Hotspot is only -2
1:     //ByteArrayOutputStream uses -8
1:     @VisibleForTesting
1:     static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
1: 
1:     @VisibleForTesting
1:     static int saturatedArraySizeCast(long size)
1:         Preconditions.checkArgument(size >= 0);
1:         return (int)Math.min(MAX_ARRAY_SIZE, size);
1:     @VisibleForTesting
1:     static int checkedArraySizeCast(long size)
1:         Preconditions.checkArgument(size >= 0);
1:         Preconditions.checkArgument(size <= MAX_ARRAY_SIZE);
1:         return (int)size;
1:     }
1: 
1:     @Override
1:     protected void doFlush(int count) throws IOException
1:     {
1:         reallocate(count);
1:     }
1: 
1:     //Hack for test, make it possible to override checking the buffer capacity
1:     @VisibleForTesting
1:     long capacity()
1:     {
1:         return buffer.capacity();
1:     }
1: 
1:     @VisibleForTesting
1:     long validateReallocation(long newSize)
1:     {
1:         int saturatedSize = saturatedArraySizeCast(newSize);
1:         if (saturatedSize <= capacity())
1:             throw new RuntimeException();
1:         return saturatedSize;
1:     }
1: 
1:     @VisibleForTesting
1:     long calculateNewSize(long count)
1:     {
1:         long capacity = capacity();
1:         //Both sides of this max expression need to use long arithmetic to avoid integer overflow
1:         //count and capacity are longs so that ensures it right now.
1:         long newSize = capacity + count;
1: 
1:         //For large buffers don't double, increase by 50%
1:         if (capacity > 1024L * 1024L * DOUBLING_THRESHOLD)
1:             newSize = Math.max((capacity * 3L) / 2L, newSize);
0:         else
1:             newSize = Math.max(capacity * 2L, newSize);
1: 
1:         return validateReallocation(newSize);
1:     }
1: 
1:     protected void reallocate(long count)
1:     {
1:         if (count <= 0)
1:             return;
1:         ByteBuffer newBuffer = ByteBuffer.allocate(checkedArraySizeCast(calculateNewSize(count)));
/////////////////////////////////////////////////////////////////////////
1:     @VisibleForTesting
1:     final class GrowingChannel implements WritableByteChannel
1:             reallocate(count);
commit:1db386e
/////////////////////////////////////////////////////////////////////////
1:         assert buffer.arrayOffset() == 0;
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1: import java.nio.channels.WritableByteChannel;
/////////////////////////////////////////////////////////////////////////
1: public class DataOutputBuffer extends BufferedDataOutputStreamPlus
/////////////////////////////////////////////////////////////////////////
0:         super(ByteBuffer.allocate(size));
1:     }
1: 
0:     protected DataOutputBuffer(ByteBuffer buffer)
1:     {
1:         super(buffer);
1:     public void flush() throws IOException
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
0:     protected void doFlush() throws IOException
1:     {
0:         reallocate(buffer.capacity() * 2);
1:     }
1: 
0:     protected void reallocate(long newSize)
1:     {
0:         assert newSize <= Integer.MAX_VALUE;
0:         ByteBuffer newBuffer = ByteBuffer.allocate((int) newSize);
1:         buffer.flip();
1:         newBuffer.put(buffer);
1:         buffer = newBuffer;
1:     }
1: 
1:     @Override
1:     protected WritableByteChannel newDefaultChannel()
1:     {
1:         return new GrowingChannel();
1:     }
1: 
0:     private final class GrowingChannel implements WritableByteChannel
1:     {
1:         public int write(ByteBuffer src) throws IOException
1:             int count = src.remaining();
0:             reallocate(Math.max((buffer.capacity() * 3) / 2, buffer.capacity() + count));
1:             buffer.put(src);
1:             return count;
1: 
1:         public boolean isOpen()
1:             return true;
1:         }
1: 
0:         public void close() throws IOException
1:         {
0:     public void close() throws IOException
1:     public ByteBuffer buffer()
1:         ByteBuffer result = buffer.duplicate();
1:         result.flip();
1:         return result;
1:         return buffer.array();
1:     }
1: 
1:     public int getLength()
1:     {
1:         return buffer.position();
1:         ByteBuffer buffer = buffer();
1:         byte[] result = new byte[buffer.remaining()];
1:         buffer.get(result);
1:         return result;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:f55a4f4
/////////////////////////////////////////////////////////////////////////
1:         public void close()
commit:f44110c
/////////////////////////////////////////////////////////////////////////
1:      * 
0:      * @return the buffer contents
/////////////////////////////////////////////////////////////////////////
0:     /** @return the length of the valid data currently in the buffer. */
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0: public final class DataOutputBuffer extends DataOutputStreamPlus
/////////////////////////////////////////////////////////////////////////
0:     public void write(ByteBuffer buffer) throws IOException
1:     {
0:         ((FastByteArrayOutputStream) out).write(buffer);
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public byte[] toByteArray()
1:     {
0:         FastByteArrayOutputStream out = (FastByteArrayOutputStream) this.out;
0:         return Arrays.copyOfRange(out.buf, 0, out.count);
0: 
1:     }
0: 
0:     public ByteBuffer asByteBuffer()
1:     {
0:         FastByteArrayOutputStream out = (FastByteArrayOutputStream) this.out;
0:         return ByteBuffer.wrap(out.buf, 0, out.count);
1:     }
0: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:ad37161
commit:9252ee9
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1:  * An implementation of the DataOutputStream interface using a FastByteArrayOutputStream and exposing
1:  * its buffer so copies can be avoided.
1:  *
1:  * This class is completely thread unsafe.
/////////////////////////////////////////////////////////////////////////
0:         super(new FastByteArrayOutputStream(size));
1:     @Override
0:     public void write(int b)
0:         try
0:         {
0:             super.write(b);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new AssertionError(e); // FBOS does not throw IOE
0:         }
0:     }
0: 
1:     @Override
0:     public void write(byte[] b, int off, int len)
0:     {
0:         try
0:         {
0:             super.write(b, off, len);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new AssertionError(e); // FBOS does not throw IOE
0:         }
/////////////////////////////////////////////////////////////////////////
0:         return ((FastByteArrayOutputStream) out).buf;
0:         return ((FastByteArrayOutputStream) out).count;
commit:b15070c
/////////////////////////////////////////////////////////////////////////
commit:fc4502a
/////////////////////////////////////////////////////////////////////////
0: public final class DataOutputBuffer extends DataOutputStream
/////////////////////////////////////////////////////////////////////////
commit:ef25537
/////////////////////////////////////////////////////////////////////////
commit:5be6ca1
/////////////////////////////////////////////////////////////////////////
commit:dc6e4fe
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.io.util;
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:066ef58
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
0: package org.apache.cassandra.io;
0: 
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInput;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: 
0: 
1: /**
0:  * An implementation of the DataOutputStream interface. This class is completely thread
0:  * unsafe.
1:  * 
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
1:  */
0: public class DataOutputBuffer extends DataOutputStream
0: {
0:     private static class Buffer extends ByteArrayOutputStream
0:     {
1:         public byte[] getData()
0:         {
0:             return buf;
0:         }
0:         
0:         public int getLength()
0:         {
0:             return count;
0:         }
0:         
0:         public void reset()
0:         {
0:             count = 0;
0:         }
0:         
0:         public void write(DataInput in, int len) throws IOException
0:         {
0:             int newcount = count + len;
0:             if (newcount > buf.length)
0:             {
0:                 byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
0:                 System.arraycopy(buf, 0, newbuf, 0, count);
0:                 buf = newbuf;
0:             }
0:             in.readFully(buf, count, len);
0:             count = newcount;
0:         }
0:     }
0:     
0:     private Buffer buffer;
0:     
0:     /** Constructs a new empty buffer. */
1:     public DataOutputBuffer()
0:     {
0:         this(new Buffer());
0:     }
0:     
0:     private DataOutputBuffer(Buffer buffer)
0:     {
0:         super(buffer);
0:         this.buffer = buffer;
0:     }
0:     
1:     /**
0:      * Returns the current contents of the buffer. Data is only valid to
0:      * {@link #getLength()}.
1:      */
1:     public byte[] getData()
0:     {
0:         return buffer.getData();
0:     }
0:     
0:     /** Returns the length of the valid data currently in the buffer. */
0:     public int getLength()
0:     {
0:         return buffer.getLength();
0:     }
0:     
0:     /** Resets the buffer to empty. */
0:     public DataOutputBuffer reset()
0:     {
0:         this.written = 0;
0:         buffer.reset();
0:         return this;
0:     }
0:     
0:     /** Writes bytes from a DataInput directly into the buffer. */
0:     public void write(DataInput in, int length) throws IOException
0:     {
0:         buffer.write(in, length);
0:     }   
0: }
commit:88edbed
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInput;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
commit:71739ef
commit:7bb094f
/////////////////////////////////////////////////////////////////////////
0:     private static class Buffer extends ByteArrayOutputStream
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:c2d748c
/////////////////////////////////////////////////////////////////////////
0: public final class DataOutputBuffer extends DataOutputStream
0:         this(128);
1:     public DataOutputBuffer(int size)
0:         super(new OutputBuffer(size));
0:     }
0:     
0:     private OutputBuffer buffer()
0:     {
0:         return (OutputBuffer)out;
0:     }
0: 
0:     /**
0:      * @return The valid contents of the buffer, possibly by copying: only safe for one-time-use buffers.
0:      */
0:     public byte[] asByteArray()
0:     {
0:         return buffer().asByteArray();
/////////////////////////////////////////////////////////////////////////
0:         return buffer().getData();
0:         return buffer().getLength();
0:         buffer().reset();
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.io;
0: 
0: import java.io.*;
0: import java.nio.ByteBuffer;
0: import java.nio.MappedByteBuffer;
0: import java.nio.channels.FileChannel;
0: import java.util.Arrays;
0: 
0: import org.apache.cassandra.continuations.Suspendable;
0: 
0: 
0: /**
0:  * An implementation of the DataOutputStream interface. This class is completely thread
0:  * unsafe.
0:  * 
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: public class DataOutputBuffer extends DataOutputStream
0: {
0:     /*
0:      * This is a clone of the ByteArrayOutputStream but w/o the unnecessary
0:      * synchronized keyword usage.
0:     */
0:     public static class FastByteArrayOutputStream extends OutputStream
0:     {
0:         
0:         /**
0:          * The buffer where data is stored.
0:          */
0:         protected byte buf[];
0:         
0:         /**
0:          * The number of valid bytes in the buffer.
0:          */
0:         protected int count;
0:         
0:         /**
0:          * Creates a new byte array output stream. The buffer capacity is
0:          * initially 32 bytes, though its size increases if necessary.
0:          */
0:         public FastByteArrayOutputStream()
0:         {
0:             this(32);
0:         }
0:         
0:         /**
0:          * Creates a new byte array output stream, with a buffer capacity of the
0:          * specified size, in bytes.
0:          * 
0:          * @param size
0:          *            the initial size.
0:          * @exception IllegalArgumentException
0:          *                if size is negative.
0:          */
0:         public FastByteArrayOutputStream(int size)
0:         {
0:             if (size < 0)
0:             {
0:                 throw new IllegalArgumentException("Negative initial size: "
0:                         + size);
0:             }
0:             buf = new byte[size];
0:         }
0:         
0:         /**
0:          * Writes the specified byte to this byte array output stream.
0:          * 
0:          * @param b
0:          *            the byte to be written.
0:          */
0:         public void write(int b)
0:         {
0:             int newcount = count + 1;
0:             if (newcount > buf.length)
0:             {
0:                 buf = Arrays.copyOf(buf, Math.max(buf.length << 1, newcount));
0:             }
0:             buf[count] = (byte) b;
0:             count = newcount;
0:         }
0:         
0:         /**
0:          * Writes <code>len</code> bytes from the specified byte array
0:          * starting at offset <code>off</code> to this byte array output
0:          * stream.
0:          * 
0:          * @param b
0:          *            the data.
0:          * @param off
0:          *            the start offset in the data.
0:          * @param len
0:          *            the number of bytes to write.
0:          */
0:         public void write(byte b[], int off, int len)
0:         {
0:             if ((off < 0) || (off > b.length) || (len < 0)
0:                     || ((off + len) > b.length) || ((off + len) < 0))
0:             {
0:                 throw new IndexOutOfBoundsException();
0:             }
0:             else if (len == 0)
0:             {
0:                 return;
0:             }
0:             int newcount = count + len;
0:             if (newcount > buf.length)
0:             {
0:                 buf = Arrays.copyOf(buf, Math.max(buf.length << 1, newcount));
0:             }
0:             System.arraycopy(b, off, buf, count, len);
0:             count = newcount;
0:         }
0:         
0:         /**
0:          * Writes the complete contents of this byte array output stream to the
0:          * specified output stream argument, as if by calling the output
0:          * stream's write method using <code>out.write(buf, 0, count)</code>.
0:          * 
0:          * @param out
0:          *            the output stream to which to write the data.
0:          * @exception IOException
0:          *                if an I/O error occurs.
0:          */
0:         public void writeTo(OutputStream out) throws IOException
0:         {
0:             out.write(buf, 0, count);
0:         }
0:         
0:         /**
0:          * Resets the <code>count</code> field of this byte array output
0:          * stream to zero, so that all currently accumulated output in the
0:          * output stream is discarded. The output stream can be used again,
0:          * reusing the already allocated buffer space.
0:          * 
0:          * @see java.io.ByteArrayInputStream#count
0:          */
0:         public void reset()
0:         {
0:             count = 0;
0:         }
0:         
0:         /**
0:          * Creates a newly allocated byte array. Its size is the current size of
0:          * this output stream and the valid contents of the buffer have been
0:          * copied into it.
0:          * 
0:          * @return the current contents of this output stream, as a byte array.
0:          * @see java.io.ByteArrayOutputStream#size()
0:          */
0:         public byte toByteArray()[]
0:         {
0:             return Arrays.copyOf(buf, count);
0:         }
0:         
0:         /**
0:          * Returns the current size of the buffer.
0:          * 
0:          * @return the value of the <code>count</code> field, which is the
0:          *         number of valid bytes in this output stream.
0:          * @see java.io.ByteArrayOutputStream#count
0:          */
0:         public int size()
0:         {
0:             return count;
0:         }
0:         
0:         /**
0:          * Converts the buffer's contents into a string decoding bytes using the
0:          * platform's default character set. The length of the new
0:          * <tt>String</tt> is a function of the character set, and hence may
0:          * not be equal to the size of the buffer.
0:          * 
0:          * <p>
0:          * This method always replaces malformed-input and unmappable-character
0:          * sequences with the default replacement string for the platform's
0:          * default character set. The
0:          * {@linkplain java.nio.charset.CharsetDecoder} class should be used
0:          * when more control over the decoding process is required.
0:          * 
0:          * @return String decoded from the buffer's contents.
0:          * @since JDK1.1
0:          */
0:         public String toString()
0:         {
0:             return new String(buf, 0, count);
0:         }
0:         
0:         /**
0:          * Converts the buffer's contents into a string by decoding the bytes
0:          * using the specified {@link java.nio.charset.Charset charsetName}.
0:          * The length of the new <tt>String</tt> is a function of the charset,
0:          * and hence may not be equal to the length of the byte array.
0:          * 
0:          * <p>
0:          * This method always replaces malformed-input and unmappable-character
0:          * sequences with this charset's default replacement string. The {@link
0:          * java.nio.charset.CharsetDecoder} class should be used when more
0:          * control over the decoding process is required.
0:          * 
0:          * @param charsetName
0:          *            the name of a supported
0:          *            {@linkplain java.nio.charset.Charset </code>charset<code>}
0:          * @return String decoded from the buffer's contents.
0:          * @exception UnsupportedEncodingException
0:          *                If the named charset is not supported
0:          * @since JDK1.1
0:          */
0:         public String toString(String charsetName) throws UnsupportedEncodingException
0:         {
0:             return new String(buf, 0, count, charsetName);
0:         }
0:         
0:         /**
0:          * Creates a newly allocated string. Its size is the current size of the
0:          * output stream and the valid contents of the buffer have been copied
0:          * into it. Each character <i>c</i> in the resulting string is
0:          * constructed from the corresponding element <i>b</i> in the byte
0:          * array such that: <blockquote>
0:          * 
0:          * <pre>
0:          * c == (char) (((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
0:          * </pre>
0:          * 
0:          * </blockquote>
0:          * 
0:          * @deprecated This method does not properly convert bytes into
0:          *             characters. As of JDK&nbsp;1.1, the preferred way to do
0:          *             this is via the <code>toString(String enc)</code>
0:          *             method, which takes an encoding-name argument, or the
0:          *             <code>toString()</code> method, which uses the
0:          *             platform's default character encoding.
0:          * 
0:          * @param hibyte
0:          *            the high byte of each resulting Unicode character.
0:          * @return the current contents of the output stream, as a string.
0:          * @see java.io.ByteArrayOutputStream#size()
0:          * @see java.io.ByteArrayOutputStream#toString(String)
0:          * @see java.io.ByteArrayOutputStream#toString()
0:          */
0:         @Deprecated
0:         public String toString(int hibyte)
0:         {
0:             return new String(buf, hibyte, 0, count);
0:         }
0:         
0:         /**
0:          * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods
0:          * in this class can be called after the stream has been closed without
0:          * generating an <tt>IOException</tt>.
0:          * <p>
0:          * 
0:          */
0:         public void close() throws IOException
0:         {
0:         }
0:         
0:     }
0:       
0:     private static class Buffer extends FastByteArrayOutputStream
0:     {
0:         public byte[] getData()
0:         {
0:             return buf;
0:         }
0:         
0:         public int getLength()
0:         {
0:             return count;
0:         }
0:         
0:         public void reset()
0:         {
0:             count = 0;
0:         }
0:         
0:         public void write(DataInput in, int len) throws IOException
0:         {
0:             int newcount = count + len;
0:             if (newcount > buf.length)
0:             {
0:                 byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
0:                 System.arraycopy(buf, 0, newbuf, 0, count);
0:                 buf = newbuf;
0:             }
0:             long start = System.currentTimeMillis();
0:             in.readFully(buf, count, len);
0:             count = newcount;
0:         }
0:         
0:         public void write(ByteBuffer buffer, int len) throws IOException
0:         {
0:             int newcount = count + len;
0:             if (newcount > buf.length)
0:             {
0:                 byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
0:                 System.arraycopy(buf, 0, newbuf, 0, count);
0:                 buf = newbuf;
0:             }
0:             long start = System.currentTimeMillis();
0:             buffer.get(buf, count, len);            
0:             count = newcount;
0:         }
0:     }
0:     
0:     private Buffer buffer;
0:     
0:     /** Constructs a new empty buffer. */
0:     public DataOutputBuffer()
0:     {
0:         this(new Buffer());
0:     }
0:     
0:     private DataOutputBuffer(Buffer buffer)
0:     {
0:         super(buffer);
0:         this.buffer = buffer;
0:     }
0:     
0:     /**
0:      * Returns the current contents of the buffer. Data is only valid to
0:      * {@link #getLength()}.
0:      */
0:     public byte[] getData()
0:     {
0:         return buffer.getData();
0:     }
0:     
0:     /** Returns the length of the valid data currently in the buffer. */
0:     public int getLength()
0:     {
0:         return buffer.getLength();
0:     }
0:     
0:     /** Resets the buffer to empty. */
0:     public DataOutputBuffer reset()
0:     {
0:         this.written = 0;
0:         buffer.reset();
0:         return this;
0:     }
0:     
0:     /** Writes bytes from a DataInput directly into the buffer. */
0:     public void write(DataInput in, int length) throws IOException
0:     {
0:         buffer.write(in, length);
0:     }   
0:     
0:     /** Writes bytes from a ByteBuffer directly into the buffer. */
0:     public void write(ByteBuffer in, int length) throws IOException
0:     {
0:         buffer.write(in, length);
0:     }   
0: }
============================================================================