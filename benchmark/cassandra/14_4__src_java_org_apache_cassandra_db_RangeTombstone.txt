2:4d34917: /*
1:4d34917:  * Licensed to the Apache Software Foundation (ASF) under one
1:4d34917:  * or more contributor license agreements.  See the NOTICE file
1:4d34917:  * distributed with this work for additional information
1:4d34917:  * regarding copyright ownership.  The ASF licenses this file
1:4d34917:  * to you under the Apache License, Version 2.0 (the
1:4d34917:  * "License"); you may not use this file except in compliance
1:4d34917:  * with the License.  You may obtain a copy of the License at
1:b0dbea3:  *
1:4d34917:  *     http://www.apache.org/licenses/LICENSE-2.0
1:b0dbea3:  *
1:4d34917:  * Unless required by applicable law or agreed to in writing, software
1:4d34917:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4d34917:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4d34917:  * See the License for the specific language governing permissions and
1:4d34917:  * limitations under the License.
1:b0dbea3:  */
1:4d34917: package org.apache.cassandra.db;
1:2457599: 
1:2e3727e: import java.util.Objects;
1:2e3727e: 
1:2457599: import org.apache.cassandra.db.rows.RangeTombstoneMarker;
1:2457599: 
1:2457599: 
1:a991b64: /**
1:a991b64:  * A range tombstone is a tombstone that covers a slice/range of rows.
1:a991b64:  * <p>
1:a991b64:  * Note that in most of the storage engine, a range tombstone is actually represented by its separated
1:a991b64:  * opening and closing bound, see {@link RangeTombstoneMarker}. So in practice, this is only used when
1:a991b64:  * full partitions are materialized in memory in a {@code Partition} object, and more precisely through
1:a991b64:  * the use of a {@code RangeTombstoneList} in a {@code DeletionInfo} object.
1:a991b64:  */
1:a991b64: public class RangeTombstone
1:2457599: {
1:a991b64:     private final Slice slice;
1:a991b64:     private final DeletionTime deletion;
1:2457599: 
1:a991b64:     public RangeTombstone(Slice slice, DeletionTime deletion)
1:2457599:     {
1:a991b64:         this.slice = slice;
1:2457599:         this.deletion = deletion;
1:fe37e06:     }
1:fe37e06: 
2:b0dbea3:     /**
1:a991b64:      * The slice of rows that is deleted by this range tombstone.
1:a991b64:      *
1:a991b64:      * @return the slice of rows that is deleted by this range tombstone.
1:b0dbea3:      */
1:a991b64:     public Slice deletedSlice()
1:fe37e06:     {
1:a991b64:         return slice;
1:ef5bbed:     }
1:ef5bbed: 
1:a991b64:     /**
1:a991b64:      * The deletion time for this (range) tombstone.
1:a991b64:      *
1:a991b64:      * @return the deletion time for this range tombstone.
1:a991b64:      */
1:a991b64:     public DeletionTime deletionTime()
1:ef5bbed:     {
1:a991b64:         return deletion;
1:2457599:     }
1:ef5bbed: 
1:7813dee:     public String toString(ClusteringComparator comparator)
1:2457599:     {
1:2457599:         return slice.toString(comparator) + '@' + deletion;
1:2457599:     }
1:2457599: 
2:a991b64:     @Override
1:a991b64:     public boolean equals(Object other)
1:2457599:     {
1:a991b64:         if(!(other instanceof RangeTombstone))
2:4d34917:             return false;
1:2457599: 
1:a991b64:         RangeTombstone that = (RangeTombstone)other;
1:a991b64:         return this.deletedSlice().equals(that.deletedSlice())
1:a991b64:             && this.deletionTime().equals(that.deletionTime());
1:2457599:     }
1:2457599: 
1:a991b64:     @Override
1:a991b64:     public int hashCode()
1:2457599:     {
1:a991b64:         return Objects.hash(deletedSlice(), deletionTime());
1:2457599:     }
1:2457599: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:fe37e06
/////////////////////////////////////////////////////////////////////////
0:                 return deserializeValues(in, kind, version, types);
1:             }
1: 
0:             public RangeTombstone.Bound deserializeValues(DataInputPlus in, Kind kind, int version,
0:                     List<AbstractType<?>> types) throws IOException
1:             {
author:Robert Stupp
-------------------------------------------------------------------------------
commit:ef5bbed
/////////////////////////////////////////////////////////////////////////
0:             public void skipValues(DataInputPlus in, Kind kind, int version,
0:                                                           List<AbstractType<?>> types) throws IOException
1:             {
0:                 int size = in.readUnsignedShort();
0:                 if (size == 0)
0:                     return;
1: 
0:                 ClusteringPrefix.serializer.skipValuesWithoutSize(in, size, version, types);
1:             }
1: 
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
1: import java.util.Objects;
/////////////////////////////////////////////////////////////////////////
1: 
commit:2248780
/////////////////////////////////////////////////////////////////////////
0:             // If the max equals the min.end(), we can avoid keeping an extra ByteBuffer in memory by using
0:             // min.end() instead of max
0:             Composite minEnd = min.end();
0:             max = minEnd.equals(max) ? minEnd : max;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.RangeTombstoneMarker;
0: import org.apache.cassandra.io.util.DataInputPlus;
0: import org.apache.cassandra.utils.memory.AbstractAllocator;
/////////////////////////////////////////////////////////////////////////
1:         this.deletion = deletion;
/////////////////////////////////////////////////////////////////////////
1:         return slice.toString(comparator) + '@' + deletion;
/////////////////////////////////////////////////////////////////////////
0:         /** The smallest start bound, i.e. the one that starts before any row. */
0:         public static final Bound BOTTOM = new Bound(Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY);
0:         /** The biggest end bound, i.e. the one that ends after any row. */
0:         public static final Bound TOP = new Bound(Kind.INCL_END_BOUND, EMPTY_VALUES_ARRAY);
1: 
0:             assert values.length > 0 || !kind.isBoundary();
1:         }
1: 
0:         public boolean isBoundary()
1:         {
0:             return kind.isBoundary();
1:         }
1: 
0:         public boolean isOpen(boolean reversed)
1:         {
0:             return kind.isOpen(reversed);
1:         }
1: 
0:         public boolean isClose(boolean reversed)
1:         {
0:             return kind.isClose(reversed);
/////////////////////////////////////////////////////////////////////////
0:         public static RangeTombstone.Bound fromSliceBound(Slice.Bound sliceBound)
1:         {
0:             return new RangeTombstone.Bound(sliceBound.kind(), sliceBound.getRawValues());
1:         }
1: 
0:         public RangeTombstone.Bound copy(AbstractAllocator allocator)
1:         {
0:             ByteBuffer[] newValues = new ByteBuffer[size()];
0:             for (int i = 0; i < size(); i++)
0:                 newValues[i] = allocator.clone(get(i));
0:             return new Bound(kind(), newValues);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             public RangeTombstone.Bound deserialize(DataInputPlus in, int version, List<AbstractType<?>> types) throws IOException
0:                 if (size == 0)
0:                     return kind.isStart() ? BOTTOM : TOP;
1: 
0:                 ByteBuffer[] values = ClusteringPrefix.serializer.deserializeValuesWithoutSize(in, size, version, types);
0:                 return new RangeTombstone.Bound(kind, values);
commit:7813dee
/////////////////////////////////////////////////////////////////////////
1:     public String toString(ClusteringComparator comparator)
0:     {
0:         return slice.toString(comparator) + "@" + deletion;
0:     }
0: 
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import org.apache.cassandra.db.marshal.AbstractType;
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * A range tombstone is a tombstone that covers a slice/range of rows.
1:  * <p>
1:  * Note that in most of the storage engine, a range tombstone is actually represented by its separated
1:  * opening and closing bound, see {@link RangeTombstoneMarker}. So in practice, this is only used when
1:  * full partitions are materialized in memory in a {@code Partition} object, and more precisely through
1:  * the use of a {@code RangeTombstoneList} in a {@code DeletionInfo} object.
1:  */
1: public class RangeTombstone
1:     private final Slice slice;
1:     private final DeletionTime deletion;
1:     public RangeTombstone(Slice slice, DeletionTime deletion)
1:         this.slice = slice;
0:         this.deletion = deletion.takeAlias();
1:      * The slice of rows that is deleted by this range tombstone.
1:      *
1:      * @return the slice of rows that is deleted by this range tombstone.
1:     public Slice deletedSlice()
1:         return slice;
0:     }
0: 
1:     /**
1:      * The deletion time for this (range) tombstone.
1:      *
1:      * @return the deletion time for this range tombstone.
1:      */
1:     public DeletionTime deletionTime()
0:     {
1:         return deletion;
0:     }
0: 
1:     @Override
1:     public boolean equals(Object other)
0:     {
1:         if(!(other instanceof RangeTombstone))
1:         RangeTombstone that = (RangeTombstone)other;
1:         return this.deletedSlice().equals(that.deletedSlice())
1:             && this.deletionTime().equals(that.deletionTime());
1:     @Override
1:     public int hashCode()
1:         return Objects.hash(deletedSlice(), deletionTime());
0:      * The bound of a range tombstone.
0:      * This is the same than for a slice but it includes "boundaries" between ranges. A boundary simply condensed
0:      * a close and an opening "bound" into a single object. There is 2 main reasons for these "shortcut" boundaries:
0:      *   1) When merging multiple iterators having range tombstones (that are represented by their start and end markers),
0:      *      we need to know when a range is close on an iterator, if it is reopened right away. Otherwise, we cannot
0:      *      easily produce the markers on the merged iterators within risking to fail the sorting guarantees of an
0:      *      iterator. See this comment for more details: https://goo.gl/yyB5mR.
0:      *   2) This saves some storage space.
0:     public static class Bound extends Slice.Bound
0:         public static final Serializer serializer = new Serializer();
0:         public Bound(Kind kind, ByteBuffer[] values)
0:             super(kind, values);
0:         public static RangeTombstone.Bound inclusiveOpen(boolean reversed, ByteBuffer[] boundValues)
0:             return new Bound(reversed ? Kind.INCL_END_BOUND : Kind.INCL_START_BOUND, boundValues);
0:         }
0:         public static RangeTombstone.Bound exclusiveOpen(boolean reversed, ByteBuffer[] boundValues)
0:         {
0:             return new Bound(reversed ? Kind.EXCL_END_BOUND : Kind.EXCL_START_BOUND, boundValues);
0:         }
0: 
0:         public static RangeTombstone.Bound inclusiveClose(boolean reversed, ByteBuffer[] boundValues)
0:         {
0:             return new Bound(reversed ? Kind.INCL_START_BOUND : Kind.INCL_END_BOUND, boundValues);
0:         }
0: 
0:         public static RangeTombstone.Bound exclusiveClose(boolean reversed, ByteBuffer[] boundValues)
0:         {
0:             return new Bound(reversed ? Kind.EXCL_START_BOUND : Kind.EXCL_END_BOUND, boundValues);
0:         }
0: 
0:         public static RangeTombstone.Bound inclusiveCloseExclusiveOpen(boolean reversed, ByteBuffer[] boundValues)
0:         {
0:             return new Bound(reversed ? Kind.EXCL_END_INCL_START_BOUNDARY : Kind.INCL_END_EXCL_START_BOUNDARY, boundValues);
0:         }
0: 
0:         public static RangeTombstone.Bound exclusiveCloseInclusiveOpen(boolean reversed, ByteBuffer[] boundValues)
0:         {
0:             return new Bound(reversed ? Kind.INCL_END_EXCL_START_BOUNDARY : Kind.EXCL_END_INCL_START_BOUNDARY, boundValues);
0:         }
0: 
1:         @Override
0:         public Bound withNewKind(Kind kind)
0:         {
0:             return new Bound(kind, values);
0:         }
0: 
0:         public static class Serializer
0:         {
0:             public void serialize(RangeTombstone.Bound bound, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException
0:                 out.writeByte(bound.kind().ordinal());
0:                 out.writeShort(bound.size());
0:                 ClusteringPrefix.serializer.serializeValuesWithoutSize(bound, out, version, types);
0:             public long serializedSize(RangeTombstone.Bound bound, int version, List<AbstractType<?>> types, TypeSizes sizes)
0:                 return 1 // kind ordinal
0:                      + sizes.sizeof((short)bound.size())
0:                      + ClusteringPrefix.serializer.valuesWithoutSizeSerializedSize(bound, version, types, sizes);
0:             public Kind deserialize(DataInput in, int version, List<AbstractType<?>> types, Writer writer) throws IOException
0:                 Kind kind = Kind.values()[in.readByte()];
0:                 writer.writeBoundKind(kind);
0:                 int size = in.readUnsignedShort();
0:                 ClusteringPrefix.serializer.deserializeValuesWithoutSize(in, size, version, types, writer);
0:                 return kind;
commit:4c53dc3
commit:655f056
commit:b0dbea3
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Tracks opened RangeTombstones when iterating over a partition.
0:      * <p>
0:      * This tracker must be provided all the atoms of a given partition in
0:      * order (to the {@code update} method). Given this, it keeps enough
0:      * information to be able to decide if one of an atom is deleted (shadowed)
0:      * by a previously open RT. One the tracker can prove a given range
0:      * tombstone cannot be useful anymore (that is, as soon as we've seen an
0:      * atom that is after the end of that RT), it discards this RT. In other
0:      * words, the maximum memory used by this object should be proportional to
0:      * the maximum number of RT that can be simultaneously open (and this
0:      * should fairly low in practice).
1:      */
0: 
0:         // A list the currently open RTs. We keep the list sorted in order of growing end bounds as for a
0:         // new atom, this allows to efficiently find the RTs that are now useless (if any). Also note that because
0:         // atom are passed to the tracker in order, any RT that is tracked can be assumed as opened, i.e. we
0:         // never have to test the RTs start since it's always assumed to be less than what we have.
0:         // Also note that this will store expired RTs (#7810). Those will be of type ExpiredRangeTombstone and
0:         // will be ignored by writeOpenedMarker.
0:         private final List<RangeTombstone> openedTombstones = new LinkedList<RangeTombstone>();
0: 
0:         // Total number of atoms written by writeOpenedMarker().
1:         /**
0:          * Creates a new tracker given the table comparator.
1:          *
0:          * @param comparator the comparator for the table this will track atoms
0:          * for. The tracker assumes that atoms will be later provided to the
0:          * tracker in {@code comparator} order.
1:          */
0:          * Computes the RangeTombstone that are needed at the beginning of an index
1:          *
0:          * @return the total serialized size of said tombstones and write them to
0:          * {@code out} it if isn't null.
0:             if (openedTombstones.isEmpty())
0:              * Compute the markers that needs to be written at the beginning of
0:              * this block. We need to write one if it is the more recent
0:             for (RangeTombstone tombstone : openedTombstones)
0:                 // If the first column is outside the range, skip it (in case update() hasn't been called yet)
0:                 if (tombstone instanceof ExpiredRangeTombstone)
/////////////////////////////////////////////////////////////////////////
0:         /**
0:          * The total number of atoms written by calls to the method {@link #writeOpenedMarker}.
0:          */
/////////////////////////////////////////////////////////////////////////
0:          * <p>
0:          * This method first test if some range tombstone can be discarded due
0:          * to the knowledge of that new atom. Then, if it's a range tombstone,
0:          * it adds it to the tracker.
0:          * <p>
0:          * Note that this method should be called on *every* atom of a partition for
0:          * the tracker to work as efficiently as possible (#9486).
0:             // Get rid of now useless RTs
0:             ListIterator<RangeTombstone> iterator = openedTombstones.listIterator();
0:             while (iterator.hasNext())
0:             {
0:                 // If this tombstone stops before the new atom, it is now useless since it cannot cover this or any future
0:                 // atoms. Otherwise, if a RT ends after the new atom, then we know that's true of any following atom too
0:                 // since maxOrderingSet is sorted by end bounds
0:                 RangeTombstone t = iterator.next();
0:                 if (comparator.compare(atom.name(), t.max) > 0)
0:                 {
0:                     iterator.remove();
0:                 }
0:                 else
0:                 {
0:                     // If the atom is a RT, we'll add it next and for that we want to start by looking at the atom we just
0:                     // returned, so rewind the iterator.
0:                     iterator.previous();
0:                     break;
0:                 }
0:             }
0: 
0:             // If it's a RT, adds it.
0:                 RangeTombstone toAdd = (RangeTombstone)atom;
0:                     toAdd = new ExpiredRangeTombstone(toAdd);
0: 
0:                 // We want to maintain openedTombstones in end bounds order so we find where to insert the new element
0:                 // and add it. While doing so, we also check if that new tombstone fully shadow or is fully shadowed
0:                 // by an existing tombstone so we avoid tracking more tombstone than necessary (and we know this will
0:                 // at least happend for start-of-index-block repeated range tombstones).
0:                 while (iterator.hasNext())
0:                     RangeTombstone existing = iterator.next();
0:                     int cmp = comparator.compare(toAdd.max, existing.max);
0:                     if (cmp > 0)
0:                         // the new one covers more than the existing one. If the new one happens to also supersedes
0:                         // the existing one, remove the existing one. In any case, we're not done yet.
0:                         if (toAdd.data.supersedes(existing.data))
0:                             iterator.remove();
0:                         // the new one is included in the existing one. If the new one supersedes the existing one,
0:                         // then we add the new one (and if the new one ends like the existing one, we can actually remove
0:                         // the existing one), otherwise we can actually ignore it. In any case, we're done.
0:                         if (toAdd.data.supersedes(existing.data))
0:                         {
0:                             if (cmp == 0)
0:                                 iterator.set(toAdd);
0:                             else
0:                                 insertBefore(toAdd, iterator);
0:                         }
0:                 // If we reach here, either we had no tombstones and the new one ends after all existing ones.
0:                 iterator.add(toAdd);
0:         /**
0:          * Adds the provided {@code tombstone} _before_ the last element returned by {@code iterator.next()}.
0:          * <p>
0:          * This method assumes that {@code iterator.next()} has been called prior to this method call, i.e. that
0:          * {@code iterator.hasPrevious() == true}.
0:          */
0:         private static void insertBefore(RangeTombstone tombstone, ListIterator<RangeTombstone> iterator)
0:         {
0:             assert iterator.hasPrevious();
0:             iterator.previous();
0:             iterator.add(tombstone);
0:             iterator.next();
0:         }
0: 
0:         /**
0:          * Tests if the provided column is deleted by one of the tombstone
0:          * tracked by this tracker.
0:          * <p>
0:          * This method should be called on columns in the same order than for the update()
0:          * method. Note that this method does not update the tracker so the update() method
0:          * should still be called on {@code column} (it doesn't matter if update is called
0:          * before or after this call).
0:          */
0:             // We know every tombstone kept are "open", start before the column. So the
0:             // column is deleted if any of the tracked tombstone ends after the column
0:             // (this will be the case of every RT if update() has been called before this
0:             // method, but we might have a few RT to skip otherwise) and the RT deletion is
0:             // actually more recent than the column timestamp.
0:             for (RangeTombstone tombstone : openedTombstones)
0:                 if (comparator.compare(column.name(), tombstone.max) <= 0
0: 
0:         /**
0:          * The tracker needs to track expired range tombstone but keep tracks that they are
0:          * expired, so this is what this class is used for.
0:          */
0:         private static class ExpiredRangeTombstone extends RangeTombstone
0:         {
0:             private ExpiredRangeTombstone(RangeTombstone tombstone)
0:             {
0:                 super(tombstone.min, tombstone.max, tombstone.data);
0:             }
0:         }
commit:74258e2
/////////////////////////////////////////////////////////////////////////
0:     public boolean includes(Comparator<Composite> comparator, Composite name)
0:     {
0:         return comparator.compare(name, min) >= 0 && comparator.compare(name, max) <= 0;
0:     }
0: 
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:          * If column is a Cell, check if any tracked range is useless and
/////////////////////////////////////////////////////////////////////////
0:                 assert atom instanceof Cell;
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Cell cell)
0:                 if (comparator.compare(cell.name(), tombstone.min) >= 0
0:                     && comparator.compare(cell.name(), tombstone.max) <= 0
0:                     && tombstone.maxTimestamp() >= cell.timestamp())
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.CType;
0: import org.apache.cassandra.db.composites.Composite;
0: public class RangeTombstone extends Interval<Composite, DeletionTime> implements OnDiskAtom
0:     public RangeTombstone(Composite start, Composite stop, long markedForDeleteAt, int localDeletionTime)
0:     public RangeTombstone(Composite start, Composite stop, DeletionTime delTime)
0:     public Composite name()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         digest.update(min.toByteBuffer().duplicate());
0:         digest.update(max.toByteBuffer().duplicate());
/////////////////////////////////////////////////////////////////////////
0:     public boolean supersedes(RangeTombstone rt, Comparator<Composite> comparator)
/////////////////////////////////////////////////////////////////////////
0:         private final Comparator<Composite> comparator;
/////////////////////////////////////////////////////////////////////////
0:         public Tracker(Comparator<Composite> comparator)
/////////////////////////////////////////////////////////////////////////
0:                 size += atomSerializer.serializedSizeForSSTable(tombstone);
/////////////////////////////////////////////////////////////////////////
0:         private final CType type;
0: 
0:         public Serializer(CType type)
0:         {
0:             this.type = type;
0:         }
0: 
0:             type.serializer().serialize(t.min, out);
0:             type.serializer().serialize(t.max, out);
0:             Composite min = type.serializer().deserialize(in);
0:         public RangeTombstone deserializeBody(DataInput in, Composite min, Descriptor.Version version) throws IOException
0:             Composite max = type.serializer().deserialize(in);
0: 
0:         public void skipBody(DataInput in, Descriptor.Version version) throws IOException
0:         {
0:             type.serializer().skip(in);
0:             DeletionTime.serializer.skip(in);
0:         }
0: 
0:         public long serializedSizeForSSTable(RangeTombstone t)
0:         {
0:             TypeSizes typeSizes = TypeSizes.NATIVE;
0:             return type.serializer().serializedSize(t.min, typeSizes)
0:                  + 1 // serialization flag
0:                  + type.serializer().serializedSize(t.max, typeSizes)
0:                  + DeletionTime.serializer.serializedSize(t.data, typeSizes);
0:         }
commit:6cc5094
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.MarshalException;
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.MarshalException;
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0:         metadata.comparator.validate(min);
0:         metadata.comparator.validate(max);
/////////////////////////////////////////////////////////////////////////
0:          * If column is a Column, check if any tracked range is useless and
/////////////////////////////////////////////////////////////////////////
0:                 assert atom instanceof Column;
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Column column)
commit:4d34917
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.db;
0: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.security.MessageDigest;
0: import java.util.*;
0: 
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.MarshalException;
0: import org.apache.cassandra.io.ISSTableSerializer;
0: import org.apache.cassandra.io.sstable.Descriptor;
0: import org.apache.cassandra.io.util.DataOutputBuffer;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.Interval;
0: 
0: public class RangeTombstone extends Interval<ByteBuffer, DeletionTime> implements OnDiskAtom
0: {
0:     public static final Serializer serializer = new Serializer();
0: 
0:     public RangeTombstone(ByteBuffer start, ByteBuffer stop, long markedForDeleteAt, int localDeletionTime)
0:     {
0:         this(start, stop, new DeletionTime(markedForDeleteAt, localDeletionTime));
0:     }
0: 
0:     public RangeTombstone(ByteBuffer start, ByteBuffer stop, DeletionTime delTime)
0:     {
0:         super(start, stop, delTime);
0:     }
0: 
0:     public ByteBuffer name()
0:     {
0:         return min;
0:     }
0: 
0:     public int getLocalDeletionTime()
0:     {
0:         return data.localDeletionTime;
0:     }
0: 
0:     public long maxTimestamp()
0:     {
0:         return data.markedForDeleteAt;
0:     }
0: 
0:     public int serializedSize(TypeSizes typeSizes)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     public long serializedSizeForSSTable()
0:     {
0:         TypeSizes typeSizes = TypeSizes.NATIVE;
0:         return typeSizes.sizeof((short)min.remaining()) + min.remaining()
0:              + 1 // serialization flag
0:              + typeSizes.sizeof((short)max.remaining()) + max.remaining()
0:              + DeletionTime.serializer.serializedSize(data, typeSizes);
0:     }
0: 
0:     public void validateFields(CFMetaData metadata) throws MarshalException
0:     {
0:         AbstractType<?> nameValidator = metadata.cfType == ColumnFamilyType.Super ? metadata.subcolumnComparator : metadata.comparator;
0:         nameValidator.validate(min);
0:         nameValidator.validate(max);
0:     }
0: 
0:     public void updateDigest(MessageDigest digest)
0:     {
0:         digest.update(min.duplicate());
0:         digest.update(max.duplicate());
0:         DataOutputBuffer buffer = new DataOutputBuffer();
0:         try
0:         {
0:             buffer.writeLong(data.markedForDeleteAt);
0:             buffer.writeInt(data.localDeletionTime);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:         digest.update(buffer.getData(), 0, buffer.getLength());
0:     }
0: 
0:     /**
0:      * This tombstone supersedes another one if it is more recent and cover a
0:      * bigger range than rt.
0:      */
0:     public boolean supersedes(RangeTombstone rt, Comparator<ByteBuffer> comparator)
0:     {
0:         if (rt.data.markedForDeleteAt > data.markedForDeleteAt)
1:             return false;
0: 
0:         return comparator.compare(min, rt.min) <= 0 && comparator.compare(max, rt.max) >= 0;
0:     }
0: 
0:     public static class Tracker
0:     {
0:         private final Comparator<ByteBuffer> comparator;
0:         private final Deque<RangeTombstone> ranges = new ArrayDeque<RangeTombstone>();
0:         private final SortedSet<RangeTombstone> maxOrderingSet = new TreeSet<RangeTombstone>(new Comparator<RangeTombstone>()
0:         {
0:             public int compare(RangeTombstone t1, RangeTombstone t2)
0:             {
0:                 return comparator.compare(t1.max, t2.max);
0:             }
0:         });
0:         private int atomCount;
0: 
0:         public Tracker(Comparator<ByteBuffer> comparator)
0:         {
0:             this.comparator = comparator;
0:         }
0: 
0:         /**
0:          * Compute RangeTombstone that are needed at the beginning of an index
0:          * block starting with {@code firstColumn}.
0:          * Returns the total serialized size of said tombstones and write them
0:          * to {@code out} it if isn't null.
0:          */
0:         public long writeOpenedMarker(OnDiskAtom firstColumn, DataOutput out, OnDiskAtom.Serializer atomSerializer) throws IOException
0:         {
0:             long size = 0;
0:             if (ranges.isEmpty())
0:                 return size;
0: 
1:             /*
0:              * Compute the marker that needs to be written at the beginning of
0:              * this block. We need to write one if it the more recent
0:              * (opened) tombstone for at least some part of its range.
0:              */
0:             List<RangeTombstone> toWrite = new LinkedList<RangeTombstone>();
0:             outer:
0:             for (RangeTombstone tombstone : ranges)
0:             {
0:                 // If ever the first column is outside the range, skip it (in
0:                 // case update() hasn't been called yet)
0:                 if (comparator.compare(firstColumn.name(), tombstone.max) > 0)
0:                     continue;
0: 
0:                 RangeTombstone updated = new RangeTombstone(firstColumn.name(), tombstone.max, tombstone.data);
0: 
0:                 Iterator<RangeTombstone> iter = toWrite.iterator();
0:                 while (iter.hasNext())
0:                 {
0:                     RangeTombstone other = iter.next();
0:                     if (other.supersedes(updated, comparator))
0:                         break outer;
0:                     if (updated.supersedes(other, comparator))
0:                         iter.remove();
0:                 }
0:                 toWrite.add(tombstone);
0:             }
0: 
0:             TypeSizes typeSizes = TypeSizes.NATIVE;
0:             for (RangeTombstone tombstone : toWrite)
0:             {
0:                 size += tombstone.serializedSize(typeSizes);
0:                 atomCount++;
0:                 if (out != null)
0:                     atomSerializer.serializeForSSTable(tombstone, out);
0:             }
0:             return size;
0:         }
0: 
0:         public int writtenAtom()
0:         {
0:             return atomCount;
0:         }
0: 
0:         /**
0:          * Update this tracker given an {@code atom}.
0:          * If column is a IColumn, check if any tracked range is useless and
0:          * can be removed. If it is a RangeTombstone, add it to this tracker.
0:          */
0:         public void update(OnDiskAtom atom)
0:         {
0:             if (atom instanceof RangeTombstone)
0:             {
0:                 RangeTombstone t = (RangeTombstone)atom;
0:                 // This could be a repeated marker already. If so, we already have a range in which it is
0:                 // fully included. While keeping both would be ok functionaly, we could end up with a lot of
0:                 // useless marker after a few compaction, so avoid this.
0:                 for (RangeTombstone tombstone : maxOrderingSet.tailSet(t))
0:                 {
0:                     // We only care about tombstone have the same max than t
0:                     if (comparator.compare(t.max, tombstone.max) > 0)
0:                         break;
0: 
0:                     // Since it is assume tombstones are passed to this method in growing min order, it's enough to
0:                     // check for the data to know is the current tombstone is included in a previous one
0:                     if (tombstone.data.equals(t.data))
0:                         return;
0:                 }
0:                 ranges.addLast(t);
0:                 maxOrderingSet.add(t);
0:             }
0:             else
0:             {
0:                 assert atom instanceof IColumn;
0:                 Iterator<RangeTombstone> iter = maxOrderingSet.iterator();
0:                 while (iter.hasNext())
0:                 {
0:                     RangeTombstone tombstone = iter.next();
0:                     if (comparator.compare(atom.name(), tombstone.max) > 0)
0:                     {
0:                         // That tombstone is now useless
0:                         iter.remove();
0:                         ranges.remove(tombstone);
0:                     }
0:                     else
0:                     {
0:                         // Since we're iterating by growing end bound, if the current range
0:                         // includes the column, so does all the next ones
0:                         return;
0:                     }
0:                 }
0:             }
0:         }
0: 
0:         public boolean isDeleted(IColumn column)
0:         {
0:             for (RangeTombstone tombstone : ranges)
0:             {
0:                 if (comparator.compare(column.name(), tombstone.max) <= 0 && tombstone.data.isDeleted(column))
0:                     return true;
0:             }
1:             return false;
0:         }
0:     }
0: 
0:     public static class Serializer implements ISSTableSerializer<RangeTombstone>
0:     {
0:         public void serializeForSSTable(RangeTombstone t, DataOutput dos) throws IOException
0:         {
0:             ByteBufferUtil.writeWithShortLength(t.min, dos);
0:             dos.writeByte(ColumnSerializer.RANGE_TOMBSTONE_MASK);
0:             ByteBufferUtil.writeWithShortLength(t.max, dos);
0:             DeletionTime.serializer.serialize(t.data, dos);
0:         }
0: 
0:         public RangeTombstone deserializeFromSSTable(DataInput dis, Descriptor.Version version) throws IOException
0:         {
0:             ByteBuffer min = ByteBufferUtil.readWithShortLength(dis);
0:             if (min.remaining() <= 0)
0:                 throw ColumnSerializer.CorruptColumnException.create(dis, min);
0: 
0:             int b = dis.readUnsignedByte();
0:             assert (b & ColumnSerializer.RANGE_TOMBSTONE_MASK) != 0;
0:             return deserializeBody(dis, min, version);
0:         }
0: 
0:         public RangeTombstone deserializeBody(DataInput dis, ByteBuffer min, Descriptor.Version version) throws IOException
0:         {
0:             ByteBuffer max = ByteBufferUtil.readWithShortLength(dis);
0:             if (max.remaining() <= 0)
0:                 throw ColumnSerializer.CorruptColumnException.create(dis, max);
0: 
0:             DeletionTime dt = DeletionTime.serializer.deserialize(dis);
0:             return new RangeTombstone(min, max, dt);
0:         }
0:     }
0: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0:             public long serializedSize(RangeTombstone.Bound bound, int version, List<AbstractType<?>> types)
0:                      + TypeSizes.sizeof((short)bound.size())
0:                      + ClusteringPrefix.serializer.valuesWithoutSizeSerializedSize(bound, version, types);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:76b5f30
commit:8a2a0c3
/////////////////////////////////////////////////////////////////////////
0:     public long timestamp()
/////////////////////////////////////////////////////////////////////////
0:                     && tombstone.timestamp() >= cell.timestamp())
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Column column, long now)
0:                 if (comparator.compare(column.name(), tombstone.max) <= 0 && tombstone.data.isDeleted(column, now))
author:Dave Brosius
-------------------------------------------------------------------------------
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:43e113b
/////////////////////////////////////////////////////////////////////////
0: 
0:         try (DataOutputBuffer buffer = new DataOutputBuffer())
0:             digest.update(buffer.getData(), 0, buffer.getLength());
commit:1def02f
/////////////////////////////////////////////////////////////////////////
commit:bc6b5f4
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.Version;
/////////////////////////////////////////////////////////////////////////
0:         public RangeTombstone deserializeFromSSTable(DataInput in, Version version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public RangeTombstone deserializeBody(DataInput in, Composite min, Version version) throws IOException
0:         public void skipBody(DataInput in, Version version) throws IOException
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:f18108d
commit:049762b
commit:29befa1
commit:7f9e9a8
/////////////////////////////////////////////////////////////////////////
0:         public final Set<RangeTombstone> expired = new HashSet<RangeTombstone>();
/////////////////////////////////////////////////////////////////////////
0:                 if (expired.contains(tombstone))
0:                     continue;
0: 
/////////////////////////////////////////////////////////////////////////
0:         public void update(OnDiskAtom atom, boolean isExpired)
/////////////////////////////////////////////////////////////////////////
0:                 if (isExpired)
0:                     expired.add(t);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public long writeOpenedMarker(OnDiskAtom firstColumn, DataOutputPlus out, OnDiskAtom.Serializer atomSerializer) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public void serializeForSSTable(RangeTombstone t, DataOutputPlus out) throws IOException
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:ed4a067
/////////////////////////////////////////////////////////////////////////
0:                 if (comparator.compare(column.name(), tombstone.min) >= 0
0:                     && comparator.compare(column.name(), tombstone.max) <= 0
0:                     && tombstone.maxTimestamp() >= column.timestamp())
0:                 {
0:                 }
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:         public void serializeForSSTable(RangeTombstone t, DataOutput out) throws IOException
0:             ByteBufferUtil.writeWithShortLength(t.min, out);
0:             out.writeByte(ColumnSerializer.RANGE_TOMBSTONE_MASK);
0:             ByteBufferUtil.writeWithShortLength(t.max, out);
0:             DeletionTime.serializer.serialize(t.data, out);
0:         public RangeTombstone deserializeFromSSTable(DataInput in, Descriptor.Version version) throws IOException
0:             ByteBuffer min = ByteBufferUtil.readWithShortLength(in);
0:                 throw ColumnSerializer.CorruptColumnException.create(in, min);
0:             int b = in.readUnsignedByte();
0:             return deserializeBody(in, min, version);
0:         public RangeTombstone deserializeBody(DataInput in, ByteBuffer min, Descriptor.Version version) throws IOException
0:             ByteBuffer max = ByteBufferUtil.readWithShortLength(in);
0:                 throw ColumnSerializer.CorruptColumnException.create(in, max);
0:             DeletionTime dt = DeletionTime.serializer.deserialize(in);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:2fc450a
commit:074f4be
/////////////////////////////////////////////////////////////////////////
0:                 size += tombstone.serializedSizeForSSTable();
author:Christian Spriegel
-------------------------------------------------------------------------------
commit:c48c7ef
/////////////////////////////////////////////////////////////////////////
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:ac9f478
/////////////////////////////////////////////////////////////////////////
0:     public long minTimestamp()
0:     {
0:         return data.markedForDeleteAt;
0:     }
0: 
============================================================================