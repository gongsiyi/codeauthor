1:2e1e98a: package org.apache.cassandra.stress.settings;
1:9f14856: /*
1:9f14856:  * 
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:9f14856:  * 
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9f14856:  * 
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:9f14856:  * 
1:9f14856:  */
1:9f14856: 
2:2e1e98a: 
1:2e1e98a: import java.util.*;
1:2e1e98a: import java.util.regex.Matcher;
1:2e1e98a: import java.util.regex.Pattern;
1:0580fb2: 
1:0580fb2: import com.google.common.base.Function;
1:2e1e98a: import org.apache.commons.math3.distribution.ExponentialDistribution;
1:2e1e98a: import org.apache.commons.math3.distribution.NormalDistribution;
1:2e1e98a: import org.apache.commons.math3.distribution.UniformRealDistribution;
1:2e1e98a: import org.apache.commons.math3.distribution.WeibullDistribution;
1:7536429: import org.apache.commons.math3.random.JDKRandomGenerator;
1:2e1e98a: 
1:6c579a0: import org.apache.cassandra.stress.generate.*;
1:6c579a0: 
1:2e1e98a: /**
1:2e1e98a:  * For selecting a mathematical distribution
1:2e1e98a:  */
1:7536429: public class OptionDistribution extends Option
1:2e1e98a: {
1:2e1e98a: 
1:0580fb2:     public static final Function<String, DistributionFactory> BUILDER = new Function<String, DistributionFactory>()
1:0580fb2:     {
1:0580fb2:         public DistributionFactory apply(String s)
1:0580fb2:         {
1:0580fb2:             return get(s);
1:0580fb2:         }
1:0580fb2:     };
1:0580fb2: 
1:7536429:     private static final Pattern FULL = Pattern.compile("(~?)([A-Z]+)\\((.+)\\)", Pattern.CASE_INSENSITIVE);
1:2e1e98a:     private static final Pattern ARGS = Pattern.compile("[^,]+");
1:2e1e98a: 
1:2e1e98a:     final String prefix;
1:2e1e98a:     private String spec;
1:2e1e98a:     private final String defaultSpec;
1:3e2c610:     private final String description;
1:0580fb2:     private final boolean required;
1:2e1e98a: 
1:3e2c610:     public OptionDistribution(String prefix, String defaultSpec, String description)
1:2e1e98a:     {
1:0580fb2:         this(prefix, defaultSpec, description, defaultSpec == null);
1:0580fb2:     }
1:0580fb2: 
1:0580fb2:     public OptionDistribution(String prefix, String defaultSpec, String description, boolean required)
1:0580fb2:     {
1:2e1e98a:         this.prefix = prefix;
1:2e1e98a:         this.defaultSpec = defaultSpec;
1:3e2c610:         this.description = description;
1:0580fb2:         this.required = required;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     @Override
1:2e1e98a:     public boolean accept(String param)
1:2e1e98a:     {
1:2e1e98a:         if (!param.toLowerCase().startsWith(prefix))
1:2e1e98a:             return false;
1:2e1e98a:         spec = param.substring(prefix.length());
1:2e1e98a:         return true;
1:2e1e98a:     }
1:2e1e98a: 
1:7536429:     public static DistributionFactory get(String spec)
1:2e1e98a:     {
1:2e1e98a:         Matcher m = FULL.matcher(spec);
1:2e1e98a:         if (!m.matches())
1:2e1e98a:             throw new IllegalArgumentException("Illegal distribution specification: " + spec);
1:7536429:         boolean inverse = m.group(1).equals("~");
1:7536429:         String name = m.group(2);
1:2e1e98a:         Impl impl = LOOKUP.get(name.toLowerCase());
1:2e1e98a:         if (impl == null)
1:2e1e98a:             throw new IllegalArgumentException("Illegal distribution type: " + name);
1:2e1e98a:         List<String> params = new ArrayList<>();
1:7536429:         m = ARGS.matcher(m.group(3));
1:2e1e98a:         while (m.find())
1:2e1e98a:             params.add(m.group());
1:7536429:         DistributionFactory factory = impl.getFactory(params);
1:7536429:         return inverse ? new InverseFactory(factory) : factory;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public DistributionFactory get()
1:2e1e98a:     {
1:0580fb2:         return spec != null ? get(spec) : defaultSpec != null ? get(defaultSpec) : null;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     @Override
1:2e1e98a:     public boolean happy()
1:2e1e98a:     {
1:0580fb2:         return !required || spec != null;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public String longDisplay()
1:2e1e98a:     {
1:3e2c610:         return shortDisplay() + ": " + description;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     @Override
1:2e1e98a:     public List<String> multiLineDisplay()
1:2e1e98a:     {
1:2e1e98a:         return Arrays.asList(
1:2e1e98a:                 GroupedOptions.formatMultiLine("EXP(min..max)", "An exponential distribution over the range [min..max]"),
1:2e1e98a:                 GroupedOptions.formatMultiLine("EXTREME(min..max,shape)", "An extreme value (Weibull) distribution over the range [min..max]"),
1:0580fb2:                 GroupedOptions.formatMultiLine("QEXTREME(min..max,shape,quantas)", "An extreme value, split into quantas, within which the chance of selection is uniform"),
1:2e1e98a:                 GroupedOptions.formatMultiLine("GAUSSIAN(min..max,stdvrng)", "A gaussian/normal distribution, where mean=(min+max)/2, and stdev is (mean-min)/stdvrng"),
1:2e1e98a:                 GroupedOptions.formatMultiLine("GAUSSIAN(min..max,mean,stdev)", "A gaussian/normal distribution, with explicitly defined mean and stdev"),
1:2e1e98a:                 GroupedOptions.formatMultiLine("UNIFORM(min..max)", "A uniform distribution over the range [min, max]"),
1:2e1e98a:                 GroupedOptions.formatMultiLine("FIXED(val)", "A fixed distribution, always returning the same value"),
1:7c759e2:                 GroupedOptions.formatMultiLine("SEQ(min..max)", "A fixed sequence, returning values in the range min to max sequentially (starting based on seed), wrapping if necessary."),
1:7536429:                 "Preceding the name with ~ will invert the distribution, e.g. ~exp(1..10) will yield 10 most, instead of least, often",
1:0580fb2:                 "Aliases: extr, qextr, gauss, normal, norm, weibull"
1:2e1e98a:         );
1:2e1e98a:     }
1:2e1e98a: 
1:3e2c610:     boolean setByUser()
1:3e2c610:     {
1:3e2c610:         return spec != null;
1:3e2c610:     }
1:3e2c610: 
1:6bbfb55:     boolean present()
1:6bbfb55:     {
1:6bbfb55:         return setByUser() || defaultSpec != null;
1:6bbfb55:     }
1:6bbfb55: 
1:2e1e98a:     @Override
1:2e1e98a:     public String shortDisplay()
1:2e1e98a:     {
1:3e2c610:         return (defaultSpec != null ? "[" : "") + prefix + "DIST(?)" + (defaultSpec != null ? "]" : "");
1:2e1e98a:     }
1:2e1e98a: 
1:938faa2:     public String getOptionAsString()
1:938faa2:     {
1:938faa2:         return prefix + (spec == null ? defaultSpec : spec);
1:938faa2:     }
1:938faa2: 
1:2e1e98a:     private static final Map<String, Impl> LOOKUP;
1:2e1e98a:     static
1:2e1e98a:     {
1:2e1e98a:         final Map<String, Impl> lookup = new HashMap<>();
1:2e1e98a:         lookup.put("exp", new ExponentialImpl());
1:2e1e98a:         lookup.put("extr", new ExtremeImpl());
1:0580fb2:         lookup.put("qextr", new QuantizedExtremeImpl());
1:0580fb2:         lookup.put("extreme", lookup.get("extr"));
1:0580fb2:         lookup.put("qextreme", lookup.get("qextr"));
1:2e1e98a:         lookup.put("weibull", lookup.get("weibull"));
1:2e1e98a:         lookup.put("gaussian", new GaussianImpl());
1:2e1e98a:         lookup.put("normal", lookup.get("gaussian"));
1:2e1e98a:         lookup.put("gauss", lookup.get("gaussian"));
1:2e1e98a:         lookup.put("norm", lookup.get("gaussian"));
1:2e1e98a:         lookup.put("uniform", new UniformImpl());
1:2e1e98a:         lookup.put("fixed", new FixedImpl());
1:e4f6045:         lookup.put("seq", new SequenceImpl());
1:2e1e98a:         LOOKUP = lookup;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     // factory builders
1:2e1e98a: 
1:2e1e98a:     private static interface Impl
1:2e1e98a:     {
1:2e1e98a:         public DistributionFactory getFactory(List<String> params);
1:2e1e98a:     }
1:2e1e98a: 
1:7536429:     public static long parseLong(String value)
1:7536429:     {
1:7536429:         long multiplier = 1;
1:7536429:         value = value.trim().toLowerCase();
1:7536429:         switch (value.charAt(value.length() - 1))
1:7536429:         {
1:7536429:             case 'b':
1:7536429:                 multiplier *= 1000;
1:7536429:             case 'm':
1:7536429:                 multiplier *= 1000;
1:7536429:             case 'k':
1:7536429:                 multiplier *= 1000;
1:7536429:                 value = value.substring(0, value.length() - 1);
1:7536429:         }
1:7536429:         return Long.parseLong(value) * multiplier;
1:7536429:     }
1:7536429: 
1:2e1e98a:     private static final class GaussianImpl implements Impl
1:2e1e98a:     {
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public DistributionFactory getFactory(List<String> params)
1:2e1e98a:         {
1:2e1e98a:             if (params.size() > 3 || params.size() < 1)
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for gaussian distribution: " + params);
1:2e1e98a:             try
1:2e1e98a:             {
1:2e1e98a:                 String[] bounds = params.get(0).split("\\.\\.+");
1:7536429:                 final long min = parseLong(bounds[0]);
1:7536429:                 final long max = parseLong(bounds[1]);
1:2e1e98a:                 final double mean, stdev;
1:2e1e98a:                 if (params.size() == 3)
1:2e1e98a:                 {
1:2e1e98a:                     mean = Double.parseDouble(params.get(1));
1:2e1e98a:                     stdev = Double.parseDouble(params.get(2));
1:2e1e98a:                 }
1:2e1e98a:                 else
1:2e1e98a:                 {
1:2e1e98a:                     final double stdevsToEdge = params.size() == 1 ? 3d : Double.parseDouble(params.get(1));
1:2e1e98a:                     mean = (min + max) / 2d;
1:2e1e98a:                     stdev = ((max - min) / 2d) / stdevsToEdge;
1:2e1e98a:                 }
1:6b979f3:                 if (min == max)
1:6b979f3:                     return new FixedFactory(min);
1:2e1e98a:                 return new GaussianFactory(min, max, mean, stdev);
1:6bbfb55:             } catch (Exception ignore)
1:2e1e98a:             {
3:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:2e1e98a:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static final class ExponentialImpl implements Impl
1:2e1e98a:     {
1:2e1e98a:         @Override
1:2e1e98a:         public DistributionFactory getFactory(List<String> params)
1:2e1e98a:         {
1:2e1e98a:             if (params.size() != 1)
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for gaussian distribution: " + params);
1:2e1e98a:             try
1:2e1e98a:             {
1:2e1e98a:                 String[] bounds = params.get(0).split("\\.\\.+");
1:7536429:                 final long min = parseLong(bounds[0]);
1:7536429:                 final long max = parseLong(bounds[1]);
1:6b979f3:                 if (min == max)
1:6b979f3:                     return new FixedFactory(min);
1:2e1e98a:                 ExponentialDistribution findBounds = new ExponentialDistribution(1d);
1:2e1e98a:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:2e1e98a:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:2e1e98a:                 final double mean = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:2e1e98a:                 return new ExpFactory(min, max, mean);
1:6bbfb55:             } catch (Exception ignore)
1:2e1e98a:             {
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:2e1e98a:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static final class ExtremeImpl implements Impl
1:2e1e98a:     {
1:2e1e98a:         @Override
1:2e1e98a:         public DistributionFactory getFactory(List<String> params)
1:2e1e98a:         {
1:2e1e98a:             if (params.size() != 2)
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for extreme (Weibull) distribution: " + params);
1:2e1e98a:             try
1:2e1e98a:             {
1:2e1e98a:                 String[] bounds = params.get(0).split("\\.\\.+");
1:7536429:                 final long min = parseLong(bounds[0]);
1:7536429:                 final long max = parseLong(bounds[1]);
1:6b979f3:                 if (min == max)
1:6b979f3:                     return new FixedFactory(min);
1:2e1e98a:                 final double shape = Double.parseDouble(params.get(1));
1:2e1e98a:                 WeibullDistribution findBounds = new WeibullDistribution(shape, 1d);
1:2e1e98a:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:2e1e98a:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:2e1e98a:                 final double scale = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:2e1e98a:                 return new ExtremeFactory(min, max, shape, scale);
1:6bbfb55:             } catch (Exception ignore)
1:2e1e98a:             {
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for extreme (Weibull) distribution: " + params);
1:2e1e98a:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:0580fb2:     private static final class QuantizedExtremeImpl implements Impl
1:0580fb2:     {
1:0580fb2:         @Override
1:0580fb2:         public DistributionFactory getFactory(List<String> params)
1:0580fb2:         {
1:0580fb2:             if (params.size() != 3)
1:0580fb2:                 throw new IllegalArgumentException("Invalid parameter list for quantized extreme (Weibull) distribution: " + params);
1:0580fb2:             try
1:0580fb2:             {
1:0580fb2:                 String[] bounds = params.get(0).split("\\.\\.+");
1:0580fb2:                 final long min = parseLong(bounds[0]);
1:0580fb2:                 final long max = parseLong(bounds[1]);
1:0580fb2:                 final double shape = Double.parseDouble(params.get(1));
1:0580fb2:                 final int quantas = Integer.parseInt(params.get(2));
1:0580fb2:                 WeibullDistribution findBounds = new WeibullDistribution(shape, 1d);
1:0580fb2:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:0580fb2:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:0580fb2:                 final double scale = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:6b979f3:                 if (min == max)
1:6b979f3:                     return new FixedFactory(min);
1:0580fb2:                 return new QuantizedExtremeFactory(min, max, shape, scale, quantas);
1:6bbfb55:             } catch (Exception ignore)
1:0580fb2:             {
1:0580fb2:                 throw new IllegalArgumentException("Invalid parameter list for quantized extreme (Weibull) distribution: " + params);
1:0580fb2:             }
1:0580fb2:         }
1:0580fb2:     }
1:0580fb2: 
1:2e1e98a:     private static final class UniformImpl implements Impl
1:2e1e98a:     {
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public DistributionFactory getFactory(List<String> params)
1:2e1e98a:         {
1:2e1e98a:             if (params.size() != 1)
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:2e1e98a:             try
1:2e1e98a:             {
1:2e1e98a:                 String[] bounds = params.get(0).split("\\.\\.+");
1:7536429:                 final long min = parseLong(bounds[0]);
1:7536429:                 final long max = parseLong(bounds[1]);
1:6b979f3:                 if (min == max)
1:6b979f3:                     return new FixedFactory(min);
1:2e1e98a:                 return new UniformFactory(min, max);
1:6bbfb55:             } catch (Exception ignore)
1:2e1e98a:             {
1:2e1e98a:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:2e1e98a:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static final class FixedImpl implements Impl
1:2e1e98a:     {
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public DistributionFactory getFactory(List<String> params)
1:2e1e98a:         {
1:2e1e98a:             if (params.size() != 1)
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for fixed distribution: " + params);
1:2e1e98a:             try
1:2e1e98a:             {
1:7536429:                 final long key = parseLong(params.get(0));
1:2e1e98a:                 return new FixedFactory(key);
1:6bbfb55:             } catch (Exception ignore)
1:2e1e98a:             {
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for fixed distribution: " + params);
1:2e1e98a:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:e4f6045:     private static final class SequenceImpl implements Impl
1:e4f6045:     {
1:e4f6045: 
1:e4f6045:         @Override
1:e4f6045:         public DistributionFactory getFactory(List<String> params)
1:e4f6045:         {
1:e4f6045:             if (params.size() != 1)
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution: " + params);
1:e4f6045:             final long min;
1:e4f6045:             final long max;
1:e4f6045:             try
1:e4f6045:             {
1:e4f6045:                 String[] bounds = params.get(0).split("\\.\\.+");
1:e4f6045:                 min = parseLong(bounds[0]);
1:e4f6045:                 max = parseLong(bounds[1]);
1:e4f6045:             } catch (Exception ignore)
1:e4f6045:             {
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution: " + params);
1:e4f6045:             }
1:e4f6045:             if (min == max)
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution (min==max): " + params);
1:e4f6045: 
1:e4f6045:             if (min > max)
1:e4f6045:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution (min>max): " + params);
1:e4f6045: 
1:e4f6045:             return new SequenceFactory(min, max);
1:e4f6045: 
1:e4f6045:         }
1:e4f6045:     }
1:e4f6045: 
1:e4f6045: 
1:7536429:     private static final class InverseFactory implements DistributionFactory
1:7536429:     {
1:7536429:         final DistributionFactory wrapped;
1:7536429:         private InverseFactory(DistributionFactory wrapped)
1:7536429:         {
1:7536429:             this.wrapped = wrapped;
1:7536429:         }
1:7536429: 
1:7536429:         public Distribution get()
1:7536429:         {
1:7536429:             return new DistributionInverted(wrapped.get());
1:7536429:         }
1:938faa2:         public String getConfigAsString(){return "Inverse: " + wrapped.getConfigAsString();};
1:938faa2: 
1:7536429:     }
1:7536429: 
1:2e1e98a:     // factories
1:2e1e98a: 
1:2e1e98a:     private static final class ExpFactory implements DistributionFactory
1:2e1e98a:     {
1:2e1e98a:         final long min, max;
1:2e1e98a:         final double mean;
1:2e1e98a:         private ExpFactory(long min, long max, double mean)
1:2e1e98a:         {
1:2e1e98a:             this.min = min;
1:2e1e98a:             this.max = max;
1:2e1e98a:             this.mean = mean;
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public Distribution get()
1:2e1e98a:         {
1:7536429:             return new DistributionOffsetApache(new ExponentialDistribution(new JDKRandomGenerator(), mean, ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
1:2e1e98a:         }
1:938faa2: 
1:938faa2:         @Override
1:938faa2:         public String getConfigAsString(){return String.format("Exponential:  min=%d,max=%d,mean=%f", min, max, mean);}
1:938faa2: 
1:2e1e98a:     }
1:2e1e98a: 
1:0580fb2:     private static class ExtremeFactory implements DistributionFactory
1:2e1e98a:     {
1:2e1e98a:         final long min, max;
1:2e1e98a:         final double shape, scale;
1:2e1e98a:         private ExtremeFactory(long min, long max, double shape, double scale)
1:2e1e98a:         {
1:2e1e98a:             this.min = min;
1:2e1e98a:             this.max = max;
1:2e1e98a:             this.shape = shape;
1:2e1e98a:             this.scale = scale;
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public Distribution get()
1:2e1e98a:         {
1:7536429:             return new DistributionOffsetApache(new WeibullDistribution(new JDKRandomGenerator(), shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
1:2e1e98a:         }
1:938faa2: 
1:938faa2:         @Override
1:938faa2:         public String getConfigAsString(){return String.format("Extreme:  min=%d,max=%d,shape=%f, scale=%f", min, max, shape, scale);}
1:938faa2: 
1:2e1e98a:     }
1:2e1e98a: 
1:0580fb2:     private static final class QuantizedExtremeFactory extends ExtremeFactory
1:0580fb2:     {
1:0580fb2:         final int quantas;
1:0580fb2:         private QuantizedExtremeFactory(long min, long max, double shape, double scale, int quantas)
1:0580fb2:         {
1:0580fb2:             super(min, max, shape, scale);
1:0580fb2:             this.quantas = quantas;
1:0580fb2:         }
1:0580fb2: 
1:0580fb2:         @Override
1:0580fb2:         public Distribution get()
1:0580fb2:         {
1:0580fb2:             return new DistributionQuantized(new DistributionOffsetApache(new WeibullDistribution(new JDKRandomGenerator(), shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max), quantas);
1:0580fb2:         }
1:0580fb2:     }
1:0580fb2: 
1:2e1e98a:     private static final class GaussianFactory implements DistributionFactory
1:2e1e98a:     {
1:2e1e98a:         final long min, max;
1:2e1e98a:         final double mean, stdev;
1:2e1e98a:         private GaussianFactory(long min, long max, double mean, double stdev)
1:2e1e98a:         {
1:2e1e98a:             this.min = min;
1:2e1e98a:             this.max = max;
1:2e1e98a:             this.stdev = stdev;
1:2e1e98a:             this.mean = mean;
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public Distribution get()
1:2e1e98a:         {
1:7536429:             return new DistributionBoundApache(new NormalDistribution(new JDKRandomGenerator(), mean, stdev, NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
1:2e1e98a:         }
1:938faa2: 
1:938faa2:         @Override
1:11aeeea:         public String getConfigAsString(){return String.format("Gaussian:  min=%d,max=%d,mean=%f,stdev=%f", min, max, mean, stdev);}
1:938faa2: 
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static final class UniformFactory implements DistributionFactory
1:2e1e98a:     {
1:2e1e98a:         final long min, max;
1:2e1e98a:         private UniformFactory(long min, long max)
1:2e1e98a:         {
1:2e1e98a:             this.min = min;
1:2e1e98a:             this.max = max;
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public Distribution get()
1:2e1e98a:         {
1:7536429:             return new DistributionBoundApache(new UniformRealDistribution(new JDKRandomGenerator(), min, max + 1), min, max);
1:2e1e98a:         }
1:938faa2: 
1:938faa2:         @Override
1:938faa2:         public String getConfigAsString(){return String.format("Uniform:  min=%d,max=%d", min, max);}
1:938faa2: 
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static final class FixedFactory implements DistributionFactory
1:2e1e98a:     {
1:2e1e98a:         final long key;
1:2e1e98a:         private FixedFactory(long key)
1:2e1e98a:         {
1:2e1e98a:             this.key = key;
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         @Override
1:2e1e98a:         public Distribution get()
1:2e1e98a:         {
1:2e1e98a:             return new DistributionFixed(key);
1:2e1e98a:         }
1:938faa2: 
1:938faa2:         @Override
1:938faa2:         public String getConfigAsString(){return String.format("Fixed:  key=%d", key);}
1:938faa2: 
1:2e1e98a:     }
1:2e1e98a: 
1:e4f6045:     private static final class SequenceFactory implements DistributionFactory
1:e4f6045:     {
1:e4f6045:         final long start;
1:e4f6045:         final long end;
1:e4f6045: 
1:e4f6045:         private SequenceFactory(long start, long end)
1:e4f6045:         {
1:e4f6045:             this.start=start;
1:e4f6045:             this.end = end;
1:e4f6045:         }
1:e4f6045: 
1:e4f6045:         @Override
1:e4f6045:         public Distribution get()
1:e4f6045:         {
1:e4f6045:             return new DistributionSequence(start, end);
1:e4f6045:         }
1:e4f6045: 
1:e4f6045:         @Override
1:e4f6045:         public String getConfigAsString(){return String.format("Sequence:  start=%d,end=%d", start, end);}
1:e4f6045: 
1:e4f6045:     }
1:e4f6045: 
1:e4f6045: 
1:2e1e98a:     @Override
1:2e1e98a:     public int hashCode()
1:2e1e98a:     {
1:2e1e98a:         return prefix.hashCode();
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     @Override
1:2e1e98a:     public boolean equals(Object that)
1:2e1e98a:     {
1:2e1e98a:         return super.equals(that) && ((OptionDistribution) that).prefix.equals(this.prefix);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a: }
============================================================================
author:Ben Slater
-------------------------------------------------------------------------------
commit:7c759e2
/////////////////////////////////////////////////////////////////////////
1:                 GroupedOptions.formatMultiLine("SEQ(min..max)", "A fixed sequence, returning values in the range min to max sequentially (starting based on seed), wrapping if necessary."),
commit:11aeeea
/////////////////////////////////////////////////////////////////////////
1:         public String getConfigAsString(){return String.format("Gaussian:  min=%d,max=%d,mean=%f,stdev=%f", min, max, mean, stdev);}
commit:e4f6045
/////////////////////////////////////////////////////////////////////////
0:                 GroupedOptions.formatMultiLine("SEQ(min..max)", "A fixed sequence, returning values from min to max sequentially, wrapping if necessary."),
/////////////////////////////////////////////////////////////////////////
1:         lookup.put("seq", new SequenceImpl());
/////////////////////////////////////////////////////////////////////////
1:                 throw new IllegalArgumentException("Invalid parameter list for fixed distribution: " + params);
1:                 throw new IllegalArgumentException("Invalid parameter list for fixed distribution: " + params);
1:     private static final class SequenceImpl implements Impl
1:     {
1: 
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 1)
1:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution: " + params);
1:             final long min;
1:             final long max;
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
1:                 min = parseLong(bounds[0]);
1:                 max = parseLong(bounds[1]);
1:             } catch (Exception ignore)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution: " + params);
1:             }
1:             if (min == max)
1:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution (min==max): " + params);
1: 
1:             if (min > max)
1:                 throw new IllegalArgumentException("Invalid parameter list for sequence distribution (min>max): " + params);
1: 
1:             return new SequenceFactory(min, max);
1: 
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static final class SequenceFactory implements DistributionFactory
1:     {
1:         final long start;
1:         final long end;
1: 
1:         private SequenceFactory(long start, long end)
1:         {
1:             this.start=start;
1:             this.end = end;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
1:             return new DistributionSequence(start, end);
1:         }
1: 
1:         @Override
1:         public String getConfigAsString(){return String.format("Sequence:  start=%d,end=%d", start, end);}
1: 
1:     }
1: 
1: 
commit:938faa2
/////////////////////////////////////////////////////////////////////////
1:     public String getOptionAsString()
1:     {
1:         return prefix + (spec == null ? defaultSpec : spec);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public String getConfigAsString(){return "Inverse: " + wrapped.getConfigAsString();};
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public String getConfigAsString(){return String.format("Exponential:  min=%d,max=%d,mean=%f", min, max, mean);}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public String getConfigAsString(){return String.format("Extreme:  min=%d,max=%d,shape=%f, scale=%f", min, max, shape, scale);}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
0:         public String getConfigAsString(){return String.format("Gaussian:  min=%d,max=%d,mean=%f,stdev=%f", min, max, stdev, mean);}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public String getConfigAsString(){return String.format("Uniform:  min=%d,max=%d", min, max);}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public String getConfigAsString(){return String.format("Fixed:  key=%d", key);}
1: 
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:6b979f3
/////////////////////////////////////////////////////////////////////////
1:                 if (min == max)
1:                     return new FixedFactory(min);
/////////////////////////////////////////////////////////////////////////
1:                 if (min == max)
1:                     return new FixedFactory(min);
/////////////////////////////////////////////////////////////////////////
1:                 if (min == max)
1:                     return new FixedFactory(min);
/////////////////////////////////////////////////////////////////////////
1:                 if (min == max)
1:                     return new FixedFactory(min);
/////////////////////////////////////////////////////////////////////////
1:                 if (min == max)
1:                     return new FixedFactory(min);
commit:6bbfb55
/////////////////////////////////////////////////////////////////////////
1:     boolean present()
1:     {
1:         return setByUser() || defaultSpec != null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception ignore)
commit:6c579a0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.stress.generate.*;
1: 
commit:0580fb2
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Function;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static final Function<String, DistributionFactory> BUILDER = new Function<String, DistributionFactory>()
1:     {
1:         public DistributionFactory apply(String s)
1:         {
1:             return get(s);
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:     private final boolean required;
1:         this(prefix, defaultSpec, description, defaultSpec == null);
1:     }
1: 
1:     public OptionDistribution(String prefix, String defaultSpec, String description, boolean required)
1:     {
1:         this.required = required;
/////////////////////////////////////////////////////////////////////////
1:         return spec != null ? get(spec) : defaultSpec != null ? get(defaultSpec) : null;
1:         return !required || spec != null;
/////////////////////////////////////////////////////////////////////////
1:                 GroupedOptions.formatMultiLine("QEXTREME(min..max,shape,quantas)", "An extreme value, split into quantas, within which the chance of selection is uniform"),
1:                 "Aliases: extr, qextr, gauss, normal, norm, weibull"
/////////////////////////////////////////////////////////////////////////
1:         lookup.put("qextr", new QuantizedExtremeImpl());
1:         lookup.put("extreme", lookup.get("extr"));
1:         lookup.put("qextreme", lookup.get("qextr"));
/////////////////////////////////////////////////////////////////////////
1:     private static final class QuantizedExtremeImpl implements Impl
1:     {
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 3)
1:                 throw new IllegalArgumentException("Invalid parameter list for quantized extreme (Weibull) distribution: " + params);
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
1:                 final long min = parseLong(bounds[0]);
1:                 final long max = parseLong(bounds[1]);
1:                 final double shape = Double.parseDouble(params.get(1));
1:                 final int quantas = Integer.parseInt(params.get(2));
1:                 WeibullDistribution findBounds = new WeibullDistribution(shape, 1d);
1:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:                 final double scale = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:                 return new QuantizedExtremeFactory(min, max, shape, scale, quantas);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for quantized extreme (Weibull) distribution: " + params);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static class ExtremeFactory implements DistributionFactory
/////////////////////////////////////////////////////////////////////////
1:     private static final class QuantizedExtremeFactory extends ExtremeFactory
1:     {
1:         final int quantas;
1:         private QuantizedExtremeFactory(long min, long max, double shape, double scale, int quantas)
1:         {
1:             super(min, max, shape, scale);
1:             this.quantas = quantas;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
1:             return new DistributionQuantized(new DistributionOffsetApache(new WeibullDistribution(new JDKRandomGenerator(), shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max), quantas);
1:         }
1:     }
1: 
commit:7536429
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.stress.generate.*;
1: import org.apache.commons.math3.random.JDKRandomGenerator;
1: public class OptionDistribution extends Option
1:     private static final Pattern FULL = Pattern.compile("(~?)([A-Z]+)\\((.+)\\)", Pattern.CASE_INSENSITIVE);
/////////////////////////////////////////////////////////////////////////
1:     public static DistributionFactory get(String spec)
1:         boolean inverse = m.group(1).equals("~");
1:         String name = m.group(2);
1:         m = ARGS.matcher(m.group(3));
1:         DistributionFactory factory = impl.getFactory(params);
1:         return inverse ? new InverseFactory(factory) : factory;
/////////////////////////////////////////////////////////////////////////
1:                 "Preceding the name with ~ will invert the distribution, e.g. ~exp(1..10) will yield 10 most, instead of least, often",
/////////////////////////////////////////////////////////////////////////
1:     public static long parseLong(String value)
1:     {
1:         long multiplier = 1;
1:         value = value.trim().toLowerCase();
1:         switch (value.charAt(value.length() - 1))
1:         {
1:             case 'b':
1:                 multiplier *= 1000;
1:             case 'm':
1:                 multiplier *= 1000;
1:             case 'k':
1:                 multiplier *= 1000;
1:                 value = value.substring(0, value.length() - 1);
1:         }
1:         return Long.parseLong(value) * multiplier;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 final long min = parseLong(bounds[0]);
1:                 final long max = parseLong(bounds[1]);
/////////////////////////////////////////////////////////////////////////
1:                 final long min = parseLong(bounds[0]);
1:                 final long max = parseLong(bounds[1]);
/////////////////////////////////////////////////////////////////////////
1:                 final long min = parseLong(bounds[0]);
1:                 final long max = parseLong(bounds[1]);
/////////////////////////////////////////////////////////////////////////
1:                 final long min = parseLong(bounds[0]);
1:                 final long max = parseLong(bounds[1]);
/////////////////////////////////////////////////////////////////////////
1:                 final long key = parseLong(params.get(0));
/////////////////////////////////////////////////////////////////////////
1:     private static final class InverseFactory implements DistributionFactory
1:     {
1:         final DistributionFactory wrapped;
1:         private InverseFactory(DistributionFactory wrapped)
1:         {
1:             this.wrapped = wrapped;
1:         }
1: 
1:         public Distribution get()
1:         {
1:             return new DistributionInverted(wrapped.get());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             return new DistributionOffsetApache(new ExponentialDistribution(new JDKRandomGenerator(), mean, ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
/////////////////////////////////////////////////////////////////////////
1:             return new DistributionOffsetApache(new WeibullDistribution(new JDKRandomGenerator(), shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
/////////////////////////////////////////////////////////////////////////
1:             return new DistributionBoundApache(new NormalDistribution(new JDKRandomGenerator(), mean, stdev, NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY), min, max);
/////////////////////////////////////////////////////////////////////////
1:             return new DistributionBoundApache(new UniformRealDistribution(new JDKRandomGenerator(), min, max + 1), min, max);
commit:53e2212
/////////////////////////////////////////////////////////////////////////
0:             return new DistributionBoundApache(new UniformRealDistribution(min, max + 1), min, max);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:3e2c610
/////////////////////////////////////////////////////////////////////////
1:     private final String description;
1:     public OptionDistribution(String prefix, String defaultSpec, String description)
1:         this.description = description;
/////////////////////////////////////////////////////////////////////////
1:         return shortDisplay() + ": " + description;
/////////////////////////////////////////////////////////////////////////
1:     boolean setByUser()
1:     {
1:         return spec != null;
1:     }
1: 
1:         return (defaultSpec != null ? "[" : "") + prefix + "DIST(?)" + (defaultSpec != null ? "]" : "");
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  * 
1:  */
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:2e1e98a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.stress.settings;
1: 
1: import java.util.*;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: 
0: import org.apache.cassandra.stress.generatedata.*;
1: import org.apache.commons.math3.distribution.ExponentialDistribution;
1: import org.apache.commons.math3.distribution.NormalDistribution;
1: import org.apache.commons.math3.distribution.UniformRealDistribution;
1: import org.apache.commons.math3.distribution.WeibullDistribution;
1: 
1: /**
1:  * For selecting a mathematical distribution
1:  */
0: class OptionDistribution extends Option
1: {
1: 
0:     private static final Pattern FULL = Pattern.compile("([A-Z]+)\\((.+)\\)", Pattern.CASE_INSENSITIVE);
1:     private static final Pattern ARGS = Pattern.compile("[^,]+");
1: 
1:     final String prefix;
1:     private String spec;
1:     private final String defaultSpec;
1: 
0:     public OptionDistribution(String prefix, String defaultSpec)
1:     {
1:         this.prefix = prefix;
1:         this.defaultSpec = defaultSpec;
1:     }
1: 
1:     @Override
1:     public boolean accept(String param)
1:     {
1:         if (!param.toLowerCase().startsWith(prefix))
1:             return false;
1:         spec = param.substring(prefix.length());
1:         return true;
1:     }
1: 
0:     private static DistributionFactory get(String spec)
1:     {
1:         Matcher m = FULL.matcher(spec);
1:         if (!m.matches())
1:             throw new IllegalArgumentException("Illegal distribution specification: " + spec);
0:         String name = m.group(1);
1:         Impl impl = LOOKUP.get(name.toLowerCase());
1:         if (impl == null)
1:             throw new IllegalArgumentException("Illegal distribution type: " + name);
1:         List<String> params = new ArrayList<>();
0:         m = ARGS.matcher(m.group(2));
1:         while (m.find())
1:             params.add(m.group());
0:         return impl.getFactory(params);
1:     }
1: 
1:     public DistributionFactory get()
1:     {
0:         return spec != null ? get(spec) : get(defaultSpec);
1:     }
1: 
1:     @Override
1:     public boolean happy()
1:     {
0:         return spec != null || defaultSpec != null;
1:     }
1: 
1:     public String longDisplay()
1:     {
0:         return shortDisplay() + ": Specify a mathematical distribution";
1:     }
1: 
1:     @Override
1:     public List<String> multiLineDisplay()
1:     {
1:         return Arrays.asList(
1:                 GroupedOptions.formatMultiLine("EXP(min..max)", "An exponential distribution over the range [min..max]"),
1:                 GroupedOptions.formatMultiLine("EXTREME(min..max,shape)", "An extreme value (Weibull) distribution over the range [min..max]"),
1:                 GroupedOptions.formatMultiLine("GAUSSIAN(min..max,stdvrng)", "A gaussian/normal distribution, where mean=(min+max)/2, and stdev is (mean-min)/stdvrng"),
1:                 GroupedOptions.formatMultiLine("GAUSSIAN(min..max,mean,stdev)", "A gaussian/normal distribution, with explicitly defined mean and stdev"),
1:                 GroupedOptions.formatMultiLine("UNIFORM(min..max)", "A uniform distribution over the range [min, max]"),
1:                 GroupedOptions.formatMultiLine("FIXED(val)", "A fixed distribution, always returning the same value"),
0:                 "Aliases: extr, gauss, normal, norm, weibull"
1:         );
1:     }
1: 
1:     @Override
1:     public String shortDisplay()
1:     {
0:         return prefix + "DIST(?)";
1:     }
1: 
1:     private static final Map<String, Impl> LOOKUP;
1:     static
1:     {
1:         final Map<String, Impl> lookup = new HashMap<>();
1:         lookup.put("exp", new ExponentialImpl());
1:         lookup.put("extr", new ExtremeImpl());
0:         lookup.put("extreme", lookup.get("extreme"));
1:         lookup.put("weibull", lookup.get("weibull"));
1:         lookup.put("gaussian", new GaussianImpl());
1:         lookup.put("normal", lookup.get("gaussian"));
1:         lookup.put("gauss", lookup.get("gaussian"));
1:         lookup.put("norm", lookup.get("gaussian"));
1:         lookup.put("uniform", new UniformImpl());
1:         lookup.put("fixed", new FixedImpl());
1:         LOOKUP = lookup;
1:     }
1: 
1:     // factory builders
1: 
1:     private static interface Impl
1:     {
1:         public DistributionFactory getFactory(List<String> params);
1:     }
1: 
1:     private static final class GaussianImpl implements Impl
1:     {
1: 
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() > 3 || params.size() < 1)
1:                 throw new IllegalArgumentException("Invalid parameter list for gaussian distribution: " + params);
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
0:                 final long min = Long.parseLong(bounds[0]);
0:                 final long max = Long.parseLong(bounds[1]);
1:                 final double mean, stdev;
1:                 if (params.size() == 3)
1:                 {
1:                     mean = Double.parseDouble(params.get(1));
1:                     stdev = Double.parseDouble(params.get(2));
1:                 }
1:                 else
1:                 {
1:                     final double stdevsToEdge = params.size() == 1 ? 3d : Double.parseDouble(params.get(1));
1:                     mean = (min + max) / 2d;
1:                     stdev = ((max - min) / 2d) / stdevsToEdge;
1:                 }
1:                 return new GaussianFactory(min, max, mean, stdev);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             }
1:         }
1:     }
1: 
1:     private static final class ExponentialImpl implements Impl
1:     {
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 1)
1:                 throw new IllegalArgumentException("Invalid parameter list for gaussian distribution: " + params);
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
0:                 final long min = Long.parseLong(bounds[0]);
0:                 final long max = Long.parseLong(bounds[1]);
1:                 ExponentialDistribution findBounds = new ExponentialDistribution(1d);
1:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:                 final double mean = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:                 return new ExpFactory(min, max, mean);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             }
1:         }
1:     }
1: 
1:     private static final class ExtremeImpl implements Impl
1:     {
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 2)
1:                 throw new IllegalArgumentException("Invalid parameter list for extreme (Weibull) distribution: " + params);
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
0:                 final long min = Long.parseLong(bounds[0]);
0:                 final long max = Long.parseLong(bounds[1]);
1:                 final double shape = Double.parseDouble(params.get(1));
1:                 WeibullDistribution findBounds = new WeibullDistribution(shape, 1d);
1:                 // max probability should be roughly equal to accuracy of (max-min) to ensure all values are visitable,
1:                 // over entire range, but this results in overly skewed distribution, so take sqrt
1:                 final double scale = (max - min) / findBounds.inverseCumulativeProbability(1d - Math.sqrt(1d/(max-min)));
1:                 return new ExtremeFactory(min, max, shape, scale);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for extreme (Weibull) distribution: " + params);
1:             }
1:         }
1:     }
1: 
1:     private static final class UniformImpl implements Impl
1:     {
1: 
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 1)
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             try
1:             {
1:                 String[] bounds = params.get(0).split("\\.\\.+");
0:                 final long min = Long.parseLong(bounds[0]);
0:                 final long max = Long.parseLong(bounds[1]);
1:                 return new UniformFactory(min, max);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             }
1:         }
1:     }
1: 
1:     private static final class FixedImpl implements Impl
1:     {
1: 
1:         @Override
1:         public DistributionFactory getFactory(List<String> params)
1:         {
1:             if (params.size() != 1)
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             try
1:             {
0:                 final long key = Long.parseLong(params.get(0));
1:                 return new FixedFactory(key);
0:             } catch (Exception _)
1:             {
1:                 throw new IllegalArgumentException("Invalid parameter list for uniform distribution: " + params);
1:             }
1:         }
1:     }
1: 
1:     // factories
1: 
1:     private static final class ExpFactory implements DistributionFactory
1:     {
1:         final long min, max;
1:         final double mean;
1:         private ExpFactory(long min, long max, double mean)
1:         {
1:             this.min = min;
1:             this.max = max;
1:             this.mean = mean;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
0:             return new DistributionOffsetApache(new ExponentialDistribution(mean), min, max);
1:         }
1:     }
1: 
0:     private static final class ExtremeFactory implements DistributionFactory
1:     {
1:         final long min, max;
1:         final double shape, scale;
1:         private ExtremeFactory(long min, long max, double shape, double scale)
1:         {
1:             this.min = min;
1:             this.max = max;
1:             this.shape = shape;
1:             this.scale = scale;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
0:             return new DistributionOffsetApache(new WeibullDistribution(shape, scale), min, max);
1:         }
1:     }
1: 
1:     private static final class GaussianFactory implements DistributionFactory
1:     {
1:         final long min, max;
1:         final double mean, stdev;
1:         private GaussianFactory(long min, long max, double mean, double stdev)
1:         {
1:             this.min = min;
1:             this.max = max;
1:             this.stdev = stdev;
1:             this.mean = mean;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
0:             return new DistributionBoundApache(new NormalDistribution(mean, stdev), min, max);
1:         }
1:     }
1: 
1:     private static final class UniformFactory implements DistributionFactory
1:     {
1:         final long min, max;
1:         private UniformFactory(long min, long max)
1:         {
1:             this.min = min;
1:             this.max = max;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
0:             return new DistributionBoundApache(new UniformRealDistribution(min, max), min, max);
1:         }
1:     }
1: 
1:     private static final class FixedFactory implements DistributionFactory
1:     {
1:         final long key;
1:         private FixedFactory(long key)
1:         {
1:             this.key = key;
1:         }
1: 
1:         @Override
1:         public Distribution get()
1:         {
1:             return new DistributionFixed(key);
1:         }
1:     }
1: 
1:     @Override
1:     public int hashCode()
1:     {
1:         return prefix.hashCode();
1:     }
1: 
1:     @Override
1:     public boolean equals(Object that)
1:     {
1:         return super.equals(that) && ((OptionDistribution) that).prefix.equals(this.prefix);
1:     }
1: 
1: }
============================================================================