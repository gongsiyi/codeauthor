1:07cf56f: /*
1:c8afd76:  * Licensed to the Apache Software Foundation (ASF) under one
1:c8afd76:  * or more contributor license agreements.  See the NOTICE file
1:c8afd76:  * distributed with this work for additional information
1:c8afd76:  * regarding copyright ownership.  The ASF licenses this file
1:c8afd76:  * to you under the Apache License, Version 2.0 (the
1:c8afd76:  * "License"); you may not use this file except in compliance
1:c8afd76:  * with the License.  You may obtain a copy of the License at
1:f44110c:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
2:c8afd76:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:c8afd76:  */
1:b31845c: package org.apache.cassandra.schema;
1:7f747c9: 
1:21aef92: import java.io.IOException;
1:c8afd76: import java.lang.reflect.InvocationTargetException;
1:c8afd76: import java.lang.reflect.Method;
1:41731b8: import java.util.Collections;
1:41731b8: import java.util.HashMap;
1:41731b8: import java.util.Map;
1:1a66ee9: 
1:056115f: import com.google.common.collect.ImmutableMap;
1:bffd9ea: import org.apache.commons.lang3.builder.EqualsBuilder;
1:bffd9ea: import org.apache.commons.lang3.builder.HashCodeBuilder;
1:1a66ee9: import org.slf4j.Logger;
1:41731b8: import org.slf4j.LoggerFactory;
1:b31845c: 
1:8a03181: import org.apache.cassandra.config.ParameterizedClass;
1:21aef92: import org.apache.cassandra.db.TypeSizes;
1:44f8254: import org.apache.cassandra.exceptions.ConfigurationException;
1:21aef92: import org.apache.cassandra.io.IVersionedSerializer;
1:b31845c: import org.apache.cassandra.io.compress.*;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:056115f: 
1:b31845c: import static java.lang.String.format;
1:b31845c: 
1:b31845c: @SuppressWarnings("deprecation")
1:b31845c: public final class CompressionParams
15:c8afd76: {
1:b31845c:     private static final Logger logger = LoggerFactory.getLogger(CompressionParams.class);
1:1a66ee9: 
1:b31845c:     private static volatile boolean hasLoggedSsTableCompressionWarning;
1:b31845c:     private static volatile boolean hasLoggedChunkLengthWarning;
1:e25453b:     private static volatile boolean hasLoggedCrcCheckChanceWarning;
1:056115f: 
1:b31845c:     public static final int DEFAULT_CHUNK_LENGTH = 65536;
1:b31845c:     public static final IVersionedSerializer<CompressionParams> serializer = new Serializer();
1:056115f: 
1:056115f:     public static final String CLASS = "class";
1:056115f:     public static final String CHUNK_LENGTH_IN_KB = "chunk_length_in_kb";
1:056115f:     public static final String ENABLED = "enabled";
1:b31845c: 
1:e06d411:     public static final CompressionParams DEFAULT = new CompressionParams(LZ4Compressor.create(Collections.<String, String>emptyMap()),
1:b31845c:                                                                           DEFAULT_CHUNK_LENGTH,
1:b31845c:                                                                           Collections.emptyMap());
1:b31845c: 
1:e25453b:     private static final String CRC_CHECK_CHANCE_WARNING = "The option crc_check_chance was deprecated as a compression option. " +
1:e25453b:                                                            "You should specify it as a top-level table option instead";
1:e25453b: 
1:b31845c:     @Deprecated public static final String SSTABLE_COMPRESSION = "sstable_compression";
1:b31845c:     @Deprecated public static final String CHUNK_LENGTH_KB = "chunk_length_kb";
1:e25453b:     @Deprecated public static final String CRC_CHECK_CHANCE = "crc_check_chance";
1:b31845c: 
1:056115f:     private final ICompressor sstableCompressor;
1:3e77792:     private final Integer chunkLength;
1:e25453b:     private final ImmutableMap<String, String> otherOptions; // Unrecognized options, can be used by the compressor
1:ac9cfbd: 
1:bc89bc6:     private volatile double crcCheckChance = 1.0;
1:bc89bc6: 
1:b31845c:     public static CompressionParams fromMap(Map<String, String> opts)
1:c8afd76:     {
1:3e77792:         Map<String, String> options = copyOptions(opts);
1:056115f: 
1:056115f:         String sstableCompressionClass;
1:056115f: 
1:b31845c:         if (!opts.isEmpty() && isEnabled(opts) && !containsSstableCompressionClass(opts))
1:b31845c:             throw new ConfigurationException(format("Missing sub-option '%s' for the 'compression' option.", CLASS));
1:b31845c: 
1:056115f:         if (!removeEnabled(options))
1:056115f:         {
1:056115f:             sstableCompressionClass = null;
1:056115f: 
1:056115f:             if (!options.isEmpty())
1:b31845c:                 throw new ConfigurationException(format("If the '%s' option is set to false no other options must be specified", ENABLED));
1:056115f:         }
1:056115f:         else
1:1c686b2:         {
1:b31845c:             sstableCompressionClass = removeSstableCompressionClass(options);
1:056115f:         }
1:056115f: 
1:056115f:         Integer chunkLength = removeChunkLength(options);
1:056115f: 
1:b31845c:         CompressionParams cp = new CompressionParams(sstableCompressionClass, chunkLength, options);
1:7f747c9:         cp.validate();
1:056115f: 
1:3e77792:         return cp;
1:056115f:     }
1:056115f: 
1:b31845c:     public Class<? extends ICompressor> klass()
1:056115f:     {
1:b31845c:         return sstableCompressor.getClass();
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams noCompression()
1:b31845c:     {
1:b31845c:         return new CompressionParams((ICompressor) null, DEFAULT_CHUNK_LENGTH, Collections.emptyMap());
1:b31845c:     }
1:b31845c: 
1:b31845c:     public static CompressionParams snappy()
1:056115f:     {
1:056115f:         return snappy(null);
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams snappy(Integer chunkLength)
1:056115f:     {
1:b31845c:         return new CompressionParams(SnappyCompressor.instance, chunkLength, Collections.emptyMap());
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams deflate()
1:056115f:     {
1:056115f:         return deflate(null);
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams deflate(Integer chunkLength)
1:056115f:     {
1:b31845c:         return new CompressionParams(DeflateCompressor.instance, chunkLength, Collections.emptyMap());
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams lz4()
1:056115f:     {
1:056115f:         return lz4(null);
1:056115f:     }
1:056115f: 
1:b31845c:     public static CompressionParams lz4(Integer chunkLength)
1:056115f:     {
1:e06d411:         return new CompressionParams(LZ4Compressor.create(Collections.emptyMap()), chunkLength, Collections.emptyMap());
1:056115f:     }
1:056115f: 
1:b31845c:     public CompressionParams(String sstableCompressorClass, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
1:056115f:     {
1:3e77792:         this(createCompressor(parseCompressorClass(sstableCompressorClass), otherOptions), chunkLength, otherOptions);
1:62db20a:     }
1:44f8254: 
1:b31845c:     private CompressionParams(ICompressor sstableCompressor, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
1:056115f:     {
1:1a66ee9:         this.sstableCompressor = sstableCompressor;
1:c8afd76:         this.chunkLength = chunkLength;
1:056115f:         this.otherOptions = ImmutableMap.copyOf(otherOptions);
1:1a66ee9:     }
1:1a66ee9: 
1:b31845c:     public CompressionParams copy()
1:1a66ee9:     {
1:b31845c:         return new CompressionParams(sstableCompressor, chunkLength, otherOptions);
1:1a66ee9:     }
1:1a66ee9: 
1:056115f:     /**
1:056115f:      * Checks if compression is enabled.
1:b31845c:      * @return {@code true} if compression is enabled, {@code false} otherwise.
1:056115f:      */
1:056115f:     public boolean isEnabled()
1:1a66ee9:     {
1:056115f:         return sstableCompressor != null;
1:1a66ee9:     }
1:1a66ee9: 
1:056115f:     /**
1:056115f:      * Returns the SSTable compressor.
1:b31845c:      * @return the SSTable compressor or {@code null} if compression is disabled.
1:056115f:      */
1:056115f:     public ICompressor getSstableCompressor()
1:1a66ee9:     {
1:056115f:         return sstableCompressor;
1:056115f:     }
1:056115f: 
1:056115f:     public ImmutableMap<String, String> getOtherOptions()
1:056115f:     {
1:056115f:         return otherOptions;
1:056115f:     }
1:056115f: 
1:3e77792:     public int chunkLength()
1:056115f:     {
1:3e77792:         return chunkLength == null ? DEFAULT_CHUNK_LENGTH : chunkLength;
1:3e77792:     }
1:62db20a: 
1:44f8254:     private static Class<?> parseCompressorClass(String className) throws ConfigurationException
1:62db20a:     {
1:6c70b83:         if (className == null || className.isEmpty())
1:c8afd76:             return null;
1:62db20a: 
1:c8afd76:         className = className.contains(".") ? className : "org.apache.cassandra.io.compress." + className;
1:1c686b2:         try
1:1c686b2:         {
1:44f8254:             return Class.forName(className);
1:1c686b2:         }
1:c8afd76:         catch (Exception e)
1:3e77792:         {
1:3e77792:             throw new ConfigurationException("Could not create Compression for type " + className, e);
1:3e77792:         }
15:c8afd76:     }
1:3e77792: 
1:44f8254:     private static ICompressor createCompressor(Class<?> compressorClass, Map<String, String> compressionOptions) throws ConfigurationException
1:3e77792:     {
1:c8afd76:         if (compressorClass == null)
1:4885bfc:         {
1:4885bfc:             if (!compressionOptions.isEmpty())
1:4885bfc:                 throw new ConfigurationException("Unknown compression options (" + compressionOptions.keySet() + ") since no compression class found");
1:c8afd76:             return null;
1:4885bfc:         }
1:3e77792: 
1:e25453b:         if (compressionOptions.containsKey(CRC_CHECK_CHANCE))
1:e25453b:         {
1:e25453b:             if (!hasLoggedCrcCheckChanceWarning)
1:e25453b:             {
1:e25453b:                 logger.warn(CRC_CHECK_CHANCE_WARNING);
1:e25453b:                 hasLoggedCrcCheckChanceWarning = true;
1:e25453b:             }
1:e25453b:             compressionOptions.remove(CRC_CHECK_CHANCE);
1:e25453b:         }
1:e25453b: 
1:21aef92:         try
1:3e77792:         {
1:c8afd76:             Method method = compressorClass.getMethod("create", Map.class);
1:820411f:             ICompressor compressor = (ICompressor)method.invoke(null, compressionOptions);
1:820411f:             // Check for unknown options
1:820411f:             for (String provided : compressionOptions.keySet())
1:e25453b:                 if (!compressor.supportedOptions().contains(provided))
1:820411f:                     throw new ConfigurationException("Unknown compression options " + provided);
1:820411f:             return compressor;
1:c8afd76:         }
1:c8afd76:         catch (NoSuchMethodException e)
1:21aef92:         {
1:c8afd76:             throw new ConfigurationException("create method not found", e);
1:c8afd76:         }
1:c8afd76:         catch (SecurityException e)
1:c8afd76:         {
1:c8afd76:             throw new ConfigurationException("Access forbiden", e);
1:c8afd76:         }
1:c8afd76:         catch (IllegalAccessException e)
1:c8afd76:         {
1:c8afd76:             throw new ConfigurationException("Cannot access method create in " + compressorClass.getName(), e);
1:c8afd76:         }
1:c8afd76:         catch (InvocationTargetException e)
1:c8afd76:         {
1:b31845c:             if (e.getTargetException() instanceof ConfigurationException)
1:b31845c:                 throw (ConfigurationException) e.getTargetException();
1:b31845c: 
1:b31845c:             Throwable cause = e.getCause() == null
1:b31845c:                             ? e
1:b31845c:                             : e.getCause();
1:b31845c: 
1:b31845c:             throw new ConfigurationException(format("%s.create() threw an error: %s %s",
1:b31845c:                                                     compressorClass.getSimpleName(),
1:b31845c:                                                     cause.getClass().getName(),
1:b31845c:                                                     cause.getMessage()),
1:0d805c7:                                              e);
1:c8afd76:         }
1:c8afd76:         catch (ExceptionInInitializerError e)
1:c8afd76:         {
1:c8afd76:             throw new ConfigurationException("Cannot initialize class " + compressorClass.getName());
1:c8afd76:         }
1:c8afd76:     }
1:3e77792: 
1:68d2526:     public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException
1:68d2526:     {
1:44f8254:         return createCompressor(parseCompressorClass(compression.class_name), copyOptions(compression.parameters));
1:44f8254:     }
1:44f8254: 
1:c8afd76:     private static Map<String, String> copyOptions(Map<? extends CharSequence, ? extends CharSequence> co)
1:c8afd76:     {
1:c8afd76:         if (co == null || co.isEmpty())
1:e06d411:             return Collections.emptyMap();
1:3e77792: 
1:b31845c:         Map<String, String> compressionOptions = new HashMap<>();
1:c8afd76:         for (Map.Entry<? extends CharSequence, ? extends CharSequence> entry : co.entrySet())
1:c8afd76:             compressionOptions.put(entry.getKey().toString(), entry.getValue().toString());
1:c8afd76:         return compressionOptions;
1:c8afd76:     }
1:3e77792: 
1:d8f5842:     /**
1:d8f5842:      * Parse the chunk length (in KB) and returns it as bytes.
1:68d2526:      *
1:f44110c:      * @param chLengthKB the length of the chunk to parse
1:f44110c:      * @return the chunk length in bytes
1:f44110c:      * @throws ConfigurationException if the chunk size is too large
1:d8f5842:      */
1:056115f:     private static Integer parseChunkLength(String chLengthKB) throws ConfigurationException
1:c8afd76:     {
1:09ac4bc:         if (chLengthKB == null)
1:3e77792:             return null;
1:3e77792: 
1:3e77792:         try
1:c8afd76:         {
1:be53b6d:             int parsed = Integer.parseInt(chLengthKB);
1:be53b6d:             if (parsed > Integer.MAX_VALUE / 1024)
1:b31845c:                 throw new ConfigurationException(format("Value of %s is too large (%s)", CHUNK_LENGTH_IN_KB,parsed));
1:be53b6d:             return 1024 * parsed;
1:c8afd76:         }
1:1a66ee9:         catch (NumberFormatException e)
1:3e77792:         {
1:056115f:             throw new ConfigurationException("Invalid value for " + CHUNK_LENGTH_IN_KB, e);
1:3e77792:         }
1:c8afd76:     }
1:3e77792: 
1:056115f:     /**
1:056115f:      * Removes the chunk length option from the specified set of option.
1:056115f:      *
1:056115f:      * @param options the options
1:056115f:      * @return the chunk length value
1:056115f:      */
1:056115f:     private static Integer removeChunkLength(Map<String, String> options)
1:056115f:     {
1:056115f:         if (options.containsKey(CHUNK_LENGTH_IN_KB))
1:056115f:         {
1:056115f:             if (options.containsKey(CHUNK_LENGTH_KB))
1:056115f:             {
1:b31845c:                 throw new ConfigurationException(format("The '%s' option must not be used if the chunk length is already specified by the '%s' option",
1:b31845c:                                                         CHUNK_LENGTH_KB,
1:b31845c:                                                         CHUNK_LENGTH_IN_KB));
1:056115f:             }
1:056115f: 
1:056115f:             return parseChunkLength(options.remove(CHUNK_LENGTH_IN_KB));
1:056115f:         }
1:056115f: 
1:056115f:         if (options.containsKey(CHUNK_LENGTH_KB))
1:056115f:         {
1:e25453b:             if (!hasLoggedChunkLengthWarning)
1:056115f:             {
1:056115f:                 hasLoggedChunkLengthWarning = true;
1:2dc2bb8:                 logger.warn("The {} option has been deprecated. You should use {} instead",
1:b31845c:                                    CHUNK_LENGTH_KB,
1:2dc2bb8:                                    CHUNK_LENGTH_IN_KB);
1:056115f:             }
1:056115f: 
1:056115f:             return parseChunkLength(options.remove(CHUNK_LENGTH_KB));
1:056115f:         }
1:056115f: 
1:056115f:         return null;
1:056115f:     }
1:056115f: 
1:056115f:     /**
1:b31845c:      * Returns {@code true} if the specified options contains the name of the compression class to be used,
1:b31845c:      * {@code false} otherwise.
1:056115f:      *
1:056115f:      * @param options the options
1:b31845c:      * @return {@code true} if the specified options contains the name of the compression class to be used,
1:b31845c:      * {@code false} otherwise.
1:056115f:      */
1:056115f:     public static boolean containsSstableCompressionClass(Map<String, String> options)
1:056115f:     {
1:b31845c:         return options.containsKey(CLASS) || options.containsKey(SSTABLE_COMPRESSION);
1:056115f:     }
1:056115f: 
1:056115f:     /**
1:056115f:      * Removes the option specifying the name of the compression class
1:056115f:      *
1:056115f:      * @param options the options
1:056115f:      * @return the name of the compression class
1:056115f:      */
1:056115f:     private static String removeSstableCompressionClass(Map<String, String> options)
1:056115f:     {
1:056115f:         if (options.containsKey(CLASS))
1:056115f:         {
1:056115f:             if (options.containsKey(SSTABLE_COMPRESSION))
1:b31845c:                 throw new ConfigurationException(format("The '%s' option must not be used if the compression algorithm is already specified by the '%s' option",
1:b31845c:                                                         SSTABLE_COMPRESSION,
1:b31845c:                                                         CLASS));
1:056115f: 
1:056115f:             String clazz = options.remove(CLASS);
1:056115f:             if (clazz.isEmpty())
1:b31845c:                 throw new ConfigurationException(format("The '%s' option must not be empty. To disable compression use 'enabled' : false", CLASS));
1:056115f: 
1:056115f:             return clazz;
1:056115f:         }
1:056115f: 
1:056115f:         if (options.containsKey(SSTABLE_COMPRESSION) && !hasLoggedSsTableCompressionWarning)
1:056115f:         {
1:056115f:             hasLoggedSsTableCompressionWarning = true;
1:2dc2bb8:             logger.warn("The {} option has been deprecated. You should use {} instead",
1:b31845c:                                SSTABLE_COMPRESSION,
1:2dc2bb8:                                CLASS);
1:056115f:         }
1:056115f: 
1:056115f:         return options.remove(SSTABLE_COMPRESSION);
1:056115f:     }
1:056115f: 
1:056115f:     /**
1:b31845c:      * Returns {@code true} if the options contains the {@code enabled} option and that its value is
1:b31845c:      * {@code true}, otherwise returns {@code false}.
1:056115f:      *
1:056115f:      * @param options the options
1:b31845c:      * @return {@code true} if the options contains the {@code enabled} option and that its value is
1:b31845c:      * {@code true}, otherwise returns {@code false}.
1:056115f:      */
1:056115f:     public static boolean isEnabled(Map<String, String> options)
1:056115f:     {
1:056115f:         String enabled = options.get(ENABLED);
1:056115f:         return enabled == null || Boolean.parseBoolean(enabled);
1:056115f:     }
1:056115f: 
1:056115f:     /**
1:b31845c:      * Removes the {@code enabled} option from the specified options.
1:056115f:      *
1:056115f:      * @param options the options
1:b31845c:      * @return the value of the {@code enabled} option
1:056115f:      */
1:056115f:     private static boolean removeEnabled(Map<String, String> options)
1:056115f:     {
1:056115f:         String enabled = options.remove(ENABLED);
1:056115f:         return enabled == null || Boolean.parseBoolean(enabled);
1:056115f:     }
1:056115f: 
1:c8afd76:     // chunkLength must be a power of 2 because we assume so when
1:c8afd76:     // computing the chunk number from an uncompressed file offset (see
1:c8afd76:     // CompressedRandomAccessReader.decompresseChunk())
1:36ef643:     public void validate() throws ConfigurationException
1:c8afd76:     {
1:7f747c9:         // if chunk length was not set (chunkLength == null), this is fine, default will be used
2:3e77792:         if (chunkLength != null)
1:c8afd76:         {
1:7f747c9:             if (chunkLength <= 0)
1:056115f:                 throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH_IN_KB);
1:21aef92: 
1:7f747c9:             int c = chunkLength;
1:7f747c9:             boolean found = false;
1:7f747c9:             while (c != 0)
1:c8afd76:             {
1:7f747c9:                 if ((c & 0x01) != 0)
1:7f747c9:                 {
1:7f747c9:                     if (found)
1:056115f:                         throw new ConfigurationException(CHUNK_LENGTH_IN_KB + " must be a power of 2");
1:7f747c9:                     else
1:7f747c9:                         found = true;
1:7f747c9:                 }
1:7f747c9:                 c >>= 1;
1:c8afd76:             }
1:c8afd76:         }
1:c8afd76:     }
1:7f747c9: 
1:056115f:     public Map<String, String> asMap()
1:c8afd76:     {
1:056115f:         if (!isEnabled())
1:056115f:             return Collections.singletonMap(ENABLED, "false");
22:c8afd76: 
1:b31845c:         Map<String, String> options = new HashMap<>(otherOptions);
1:056115f:         options.put(CLASS, sstableCompressor.getClass().getName());
1:056115f:         options.put(CHUNK_LENGTH_IN_KB, chunkLengthInKB());
1:b31845c: 
4:3e77792:         return options;
1:3e77792:     }
1:3e77792: 
1:056115f:     public String chunkLengthInKB()
1:09ac4bc:     {
1:09ac4bc:         return String.valueOf(chunkLength() / 1024);
1:09ac4bc:     }
1:3e77792: 
1:bc89bc6:     public void setCrcCheckChance(double crcCheckChance)
1:bc89bc6:     {
1:bc89bc6:         this.crcCheckChance = crcCheckChance;
1:bc89bc6:     }
1:bc89bc6: 
1:bc89bc6:     public double getCrcCheckChance()
1:bc89bc6:     {
1:bc89bc6:         return crcCheckChance;
1:bc89bc6:     }
1:bc89bc6: 
1:c8afd76:     @Override
1:c8afd76:     public boolean equals(Object obj)
1:1a66ee9:     {
1:c8afd76:         if (obj == this)
1:1a66ee9:         {
1:c8afd76:             return true;
1:1a66ee9:         }
1:c8afd76:         else if (obj == null || obj.getClass() != getClass())
1:1a66ee9:         {
1:c8afd76:             return false;
1:1a66ee9:         }
1:1a66ee9: 
1:b31845c:         CompressionParams cp = (CompressionParams) obj;
1:c8afd76:         return new EqualsBuilder()
1:3e77792:             .append(sstableCompressor, cp.sstableCompressor)
1:056115f:             .append(chunkLength(), cp.chunkLength())
1:3e77792:             .append(otherOptions, cp.otherOptions)
1:c8afd76:             .isEquals();
1:1a66ee9:     }
1:09ac4bc: 
1:c8afd76:     @Override
1:c8afd76:     public int hashCode()
1:c8afd76:     {
1:c8afd76:         return new HashCodeBuilder(29, 1597)
1:3e77792:             .append(sstableCompressor)
1:056115f:             .append(chunkLength())
1:3e77792:             .append(otherOptions)
1:c8afd76:             .toHashCode();
1:21aef92:     }
1:21aef92: 
1:b31845c:     static class Serializer implements IVersionedSerializer<CompressionParams>
1:21aef92:     {
1:b31845c:         public void serialize(CompressionParams parameters, DataOutputPlus out, int version) throws IOException
1:21aef92:         {
1:21aef92:             out.writeUTF(parameters.sstableCompressor.getClass().getSimpleName());
1:21aef92:             out.writeInt(parameters.otherOptions.size());
1:21aef92:             for (Map.Entry<String, String> entry : parameters.otherOptions.entrySet())
1:21aef92:             {
1:21aef92:                 out.writeUTF(entry.getKey());
1:21aef92:                 out.writeUTF(entry.getValue());
1:21aef92:             }
1:21aef92:             out.writeInt(parameters.chunkLength());
1:21aef92:         }
1:21aef92: 
1:b31845c:         public CompressionParams deserialize(DataInputPlus in, int version) throws IOException
1:21aef92:         {
1:21aef92:             String compressorName = in.readUTF();
1:21aef92:             int optionCount = in.readInt();
1:b31845c:             Map<String, String> options = new HashMap<>();
1:21aef92:             for (int i = 0; i < optionCount; ++i)
1:21aef92:             {
1:21aef92:                 String key = in.readUTF();
1:21aef92:                 String value = in.readUTF();
1:21aef92:                 options.put(key, value);
1:21aef92:             }
1:21aef92:             int chunkLength = in.readInt();
1:b31845c:             CompressionParams parameters;
1:1a66ee9:             try
1:21aef92:             {
1:b31845c:                 parameters = new CompressionParams(compressorName, chunkLength, options);
1:21aef92:             }
1:1c686b2:             catch (ConfigurationException e)
1:1c686b2:             {
1:b31845c:                 throw new RuntimeException("Cannot create CompressionParams for parameters", e);
1:1c686b2:             }
1:21aef92:             return parameters;
1:1c686b2:         }
1:1c686b2: 
1:b31845c:         public long serializedSize(CompressionParams parameters, int version)
1:21aef92:         {
1:03f72ac:             long size = TypeSizes.sizeof(parameters.sstableCompressor.getClass().getSimpleName());
1:03f72ac:             size += TypeSizes.sizeof(parameters.otherOptions.size());
1:21aef92:             for (Map.Entry<String, String> entry : parameters.otherOptions.entrySet())
1:21aef92:             {
1:03f72ac:                 size += TypeSizes.sizeof(entry.getKey());
1:03f72ac:                 size += TypeSizes.sizeof(entry.getValue());
1:21aef92:             }
1:03f72ac:             size += TypeSizes.sizeof(parameters.chunkLength());
1:21aef92:             return size;
1:21aef92:         }
1:21aef92:     }
1:21aef92: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:2dc2bb8
/////////////////////////////////////////////////////////////////////////
1:                 logger.warn("The {} option has been deprecated. You should use {} instead",
1:                                    CHUNK_LENGTH_IN_KB);
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("The {} option has been deprecated. You should use {} instead",
1:                                CLASS);
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:     public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException
1:     {
/////////////////////////////////////////////////////////////////////////
1:      *
commit:f44110c
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param chLengthKB the length of the chunk to parse
1:      * @return the chunk length in bytes
1:      * @throws ConfigurationException if the chunk size is too large
commit:36ef643
/////////////////////////////////////////////////////////////////////////
0:     public static Integer parseChunkLength(String chLengthKB) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:     public void validate() throws ConfigurationException
author:Michael Kjellman
-------------------------------------------------------------------------------
commit:e06d411
/////////////////////////////////////////////////////////////////////////
1:     public static final CompressionParams DEFAULT = new CompressionParams(LZ4Compressor.create(Collections.<String, String>emptyMap()),
/////////////////////////////////////////////////////////////////////////
1:         return new CompressionParams(LZ4Compressor.create(Collections.emptyMap()), chunkLength, Collections.emptyMap());
/////////////////////////////////////////////////////////////////////////
1:             return Collections.emptyMap();
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:bc89bc6
/////////////////////////////////////////////////////////////////////////
1:     private volatile double crcCheckChance = 1.0;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setCrcCheckChance(double crcCheckChance)
1:     {
1:         this.crcCheckChance = crcCheckChance;
1:     }
1: 
1:     public double getCrcCheckChance()
1:     {
1:         return crcCheckChance;
1:     }
1: 
commit:41731b8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Map;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
author:Paulo Motta
-------------------------------------------------------------------------------
commit:e25453b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.ClientWarn;
0: import org.apache.cassandra.utils.NoSpamLogger;
/////////////////////////////////////////////////////////////////////////
1:     private static volatile boolean hasLoggedCrcCheckChanceWarning;
/////////////////////////////////////////////////////////////////////////
1:     private static final String CRC_CHECK_CHANCE_WARNING = "The option crc_check_chance was deprecated as a compression option. " +
1:                                                            "You should specify it as a top-level table option instead";
1: 
1:     @Deprecated public static final String CRC_CHECK_CHANCE = "crc_check_chance";
1:     private final ImmutableMap<String, String> otherOptions; // Unrecognized options, can be used by the compressor
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (compressionOptions.containsKey(CRC_CHECK_CHANCE))
1:         {
1:             if (!hasLoggedCrcCheckChanceWarning)
1:             {
1:                 logger.warn(CRC_CHECK_CHANCE_WARNING);
1:                 hasLoggedCrcCheckChanceWarning = true;
1:             }
1:             compressionOptions.remove(CRC_CHECK_CHANCE);
1:         }
1: 
1:                 if (!compressor.supportedOptions().contains(provided))
/////////////////////////////////////////////////////////////////////////
1:             if (!hasLoggedChunkLengthWarning)
/////////////////////////////////////////////////////////////////////////
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:b31845c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.schema;
0: import java.util.*;
1: 
1: import org.apache.cassandra.io.compress.*;
1: import static java.lang.String.format;
1: 
1: @SuppressWarnings("deprecation")
1: public final class CompressionParams
1:     private static final Logger logger = LoggerFactory.getLogger(CompressionParams.class);
1:     private static volatile boolean hasLoggedSsTableCompressionWarning;
1:     private static volatile boolean hasLoggedChunkLengthWarning;
1:     public static final int DEFAULT_CHUNK_LENGTH = 65536;
0:     public static final double DEFAULT_CRC_CHECK_CHANCE = 1.0;
1:     public static final IVersionedSerializer<CompressionParams> serializer = new Serializer();
1: 
0:     public static final CompressionParams DEFAULT = new CompressionParams(LZ4Compressor.instance,
1:                                                                           DEFAULT_CHUNK_LENGTH,
1:                                                                           Collections.emptyMap());
1: 
1:     @Deprecated public static final String SSTABLE_COMPRESSION = "sstable_compression";
1:     @Deprecated public static final String CHUNK_LENGTH_KB = "chunk_length_kb";
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static CompressionParams fromMap(Map<String, String> opts)
1:         if (!opts.isEmpty() && isEnabled(opts) && !containsSstableCompressionClass(opts))
1:             throw new ConfigurationException(format("Missing sub-option '%s' for the 'compression' option.", CLASS));
1: 
1:                 throw new ConfigurationException(format("If the '%s' option is set to false no other options must be specified", ENABLED));
1:             sstableCompressionClass = removeSstableCompressionClass(options);
1:         CompressionParams cp = new CompressionParams(sstableCompressionClass, chunkLength, options);
1:     public Class<? extends ICompressor> klass()
1:         return sstableCompressor.getClass();
1:     public static CompressionParams noCompression()
1:     {
1:         return new CompressionParams((ICompressor) null, DEFAULT_CHUNK_LENGTH, Collections.emptyMap());
1:     }
1: 
1:     public static CompressionParams snappy()
1:     public static CompressionParams snappy(Integer chunkLength)
1:         return new CompressionParams(SnappyCompressor.instance, chunkLength, Collections.emptyMap());
1:     public static CompressionParams deflate()
1:     public static CompressionParams deflate(Integer chunkLength)
1:         return new CompressionParams(DeflateCompressor.instance, chunkLength, Collections.emptyMap());
1:     public static CompressionParams lz4()
1:     public static CompressionParams lz4(Integer chunkLength)
0:         return new CompressionParams(LZ4Compressor.instance, chunkLength, Collections.emptyMap());
1:     public CompressionParams(String sstableCompressorClass, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
1:     private CompressionParams(ICompressor sstableCompressor, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:     public CompressionParams copy()
1:         return new CompressionParams(sstableCompressor, chunkLength, otherOptions);
/////////////////////////////////////////////////////////////////////////
0:         if (liveMetadata != null && this != liveMetadata.params.compression)
0:             liveMetadata.params.compression.setCrcCheckChance(crcCheckChance);
1:      * @return {@code true} if compression is enabled, {@code false} otherwise.
/////////////////////////////////////////////////////////////////////////
1:      * @return the SSTable compressor or {@code null} if compression is disabled.
/////////////////////////////////////////////////////////////////////////
0:         return liveMetadata == null ? this.crcCheckChance : liveMetadata.params.compression.crcCheckChance;
/////////////////////////////////////////////////////////////////////////
1:             if (e.getTargetException() instanceof ConfigurationException)
1:                 throw (ConfigurationException) e.getTargetException();
1: 
1:             Throwable cause = e.getCause() == null
1:                             ? e
1:                             : e.getCause();
1: 
1:             throw new ConfigurationException(format("%s.create() threw an error: %s %s",
1:                                                     compressorClass.getSimpleName(),
1:                                                     cause.getClass().getName(),
1:                                                     cause.getMessage()),
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> compressionOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                 throw new ConfigurationException(format("Value of %s is too large (%s)", CHUNK_LENGTH_IN_KB,parsed));
/////////////////////////////////////////////////////////////////////////
1:                 throw new ConfigurationException(format("The '%s' option must not be used if the chunk length is already specified by the '%s' option",
1:                                                         CHUNK_LENGTH_KB,
1:                                                         CHUNK_LENGTH_IN_KB));
/////////////////////////////////////////////////////////////////////////
0:                 logger.warn(format("The %s option has been deprecated. You should use %s instead",
1:                                    CHUNK_LENGTH_KB,
0:                                    CHUNK_LENGTH_IN_KB));
/////////////////////////////////////////////////////////////////////////
1:      * Returns {@code true} if the specified options contains the name of the compression class to be used,
1:      * {@code false} otherwise.
1:      * @return {@code true} if the specified options contains the name of the compression class to be used,
1:      * {@code false} otherwise.
1:         return options.containsKey(CLASS) || options.containsKey(SSTABLE_COMPRESSION);
/////////////////////////////////////////////////////////////////////////
1:                 throw new ConfigurationException(format("The '%s' option must not be used if the compression algorithm is already specified by the '%s' option",
1:                                                         SSTABLE_COMPRESSION,
1:                                                         CLASS));
1:                 throw new ConfigurationException(format("The '%s' option must not be empty. To disable compression use 'enabled' : false", CLASS));
/////////////////////////////////////////////////////////////////////////
0:             logger.warn(format("The %s option has been deprecated. You should use %s instead",
1:                                SSTABLE_COMPRESSION,
0:                                CLASS));
1:      * Returns {@code true} if the options contains the {@code enabled} option and that its value is
1:      * {@code true}, otherwise returns {@code false}.
1:      * @return {@code true} if the options contains the {@code enabled} option and that its value is
1:      * {@code true}, otherwise returns {@code false}.
/////////////////////////////////////////////////////////////////////////
1:      * Removes the {@code enabled} option from the specified options.
1:      * @return the value of the {@code enabled} option
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> options = new HashMap<>(otherOptions);
1: 
/////////////////////////////////////////////////////////////////////////
1:         CompressionParams cp = (CompressionParams) obj;
/////////////////////////////////////////////////////////////////////////
1:     static class Serializer implements IVersionedSerializer<CompressionParams>
1:         public void serialize(CompressionParams parameters, DataOutputPlus out, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         public CompressionParams deserialize(DataInputPlus in, int version) throws IOException
1:             Map<String, String> options = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:             CompressionParams parameters;
1:                 parameters = new CompressionParams(compressorName, chunkLength, options);
1:                 throw new RuntimeException("Cannot create CompressionParams for parameters", e);
1:         public long serializedSize(CompressionParams parameters, int version)
commit:bffd9ea
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.lang3.builder.EqualsBuilder;
1: import org.apache.commons.lang3.builder.HashCodeBuilder;
commit:1c686b2
/////////////////////////////////////////////////////////////////////////
0:     public CompressionParameters copy()
1:     {
1:         try
1:         {
0:             return new CompressionParameters(sstableCompressor, chunkLength, new HashMap<>(otherOptions));
1:         }
1:         catch (ConfigurationException e)
1:         {
0:             throw new AssertionError(e); // can't happen at this point.
1:         }
1:     }
1: 
commit:620a4b7
commit:1a66ee9
/////////////////////////////////////////////////////////////////////////
0: import java.util.AbstractSet;
0: import com.google.common.collect.ImmutableSet;
0: import com.google.common.collect.Sets;
1: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0:     private static final Logger logger = LoggerFactory.getLogger(CompressionParameters.class);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public static final Set<String> GLOBAL_OPTIONS = ImmutableSet.of(CRC_CHECK_CHANCE);
1: 
0:     private volatile double crcCheckChance;
/////////////////////////////////////////////////////////////////////////
0:         // can't try/catch as first statement in the constructor, thus repeating constructor code here.
1:         this.sstableCompressor = sstableCompressor;
0:         chunkLength = null;
0:         otherOptions = Collections.emptyMap();
0:         crcCheckChance = DEFAULT_CRC_CHECK_CHANCE;
0:     public CompressionParameters(ICompressor sstableCompressor, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
0:         this.crcCheckChance = otherOptions.get(CRC_CHECK_CHANCE) == null
0:                               ? DEFAULT_CRC_CHECK_CHANCE
0:                               : parseCrcCheckChance(otherOptions.get(CRC_CHECK_CHANCE));
1:     }
1: 
0:     public void setCrcCheckChance(double crcCheckChance) throws ConfigurationException
1:     {
0:         validateCrcCheckChance(crcCheckChance);
0:         logger.debug("Setting crcCheckChance to {}", crcCheckChance);
0:         this.crcCheckChance = crcCheckChance;
1:     }
1: 
0:     public double getCrcCheckChance()
1:     {
0:         return this.crcCheckChance;
1:     }
1: 
0:     private static double parseCrcCheckChance(String crcCheckChance) throws ConfigurationException
1:     {
1:         try
1:         {
0:             double chance = Double.parseDouble(crcCheckChance);
0:             validateCrcCheckChance(chance);
0:             return chance;
1:         }
1:         catch (NumberFormatException e)
1:         {
0:             throw new ConfigurationException("crc_check_chance should be a double");
1:         }
1:     }
1: 
0:     private static void validateCrcCheckChance(double crcCheckChance) throws ConfigurationException
1:     {
0:         if (crcCheckChance < 0.0d || crcCheckChance > 1.0d)
0:             throw new ConfigurationException("crc_check_chance should be between 0.0 and 1.0");
/////////////////////////////////////////////////////////////////////////
0:             AbstractSet<String> supportedOpts =  Sets.union(compressor.supportedOptions(), GLOBAL_OPTIONS);
/////////////////////////////////////////////////////////////////////////
0:         validateCrcCheckChance(crcCheckChance);
commit:ab071c5
author:blerer
-------------------------------------------------------------------------------
commit:056115f
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.ImmutableMap;
1: 
0: import org.slf4j.LoggerFactory;
0: import org.slf4j.Logger;
/////////////////////////////////////////////////////////////////////////
0:     private final static Logger LOGGER = LoggerFactory.getLogger(CompressionParameters.class);
1: 
0:     private volatile static boolean hasLoggedSsTableCompressionWarning;
0:     private volatile static boolean hasLoggedChunkLengthWarning;
1: 
1:     public static final String CLASS = "class";
1:     public static final String CHUNK_LENGTH_IN_KB = "chunk_length_in_kb";
1:     public static final String ENABLED = "enabled";
0:     @Deprecated
0:     @Deprecated
1:     private final ICompressor sstableCompressor;
0:     private final ImmutableMap<String, String> otherOptions; // Unrecognized options, can be use by the compressor
0:     public static CompressionParameters fromMap(Map<? extends CharSequence, ? extends CharSequence> opts)
1: 
1:         String sstableCompressionClass;
1: 
1:         if (!removeEnabled(options))
1:         {
1:             sstableCompressionClass = null;
1: 
1:             if (!options.isEmpty())
0:                 throw new ConfigurationException("If the '" + ENABLED + "' option is set to false"
0:                                                   + " no other options must be specified");
1:         }
1:         else
1:         {
0:             sstableCompressionClass= removeSstableCompressionClass(options);
1:         }
1: 
1:         Integer chunkLength = removeChunkLength(options);
1: 
0:         CompressionParameters cp = new CompressionParameters(sstableCompressionClass, chunkLength, options);
1: 
0:     public static CompressionParameters noCompression()
1:     {
0:         return new CompressionParameters((ICompressor) null, DEFAULT_CHUNK_LENGTH, Collections.emptyMap());
1:     }
1: 
0:     public static CompressionParameters snappy()
1:     {
1:         return snappy(null);
1:     }
1: 
0:     public static CompressionParameters snappy(Integer chunkLength)
1:     {
0:         return new CompressionParameters(SnappyCompressor.instance, chunkLength, Collections.emptyMap());
1:     }
1: 
0:     public static CompressionParameters deflate()
1:     {
1:         return deflate(null);
1:     }
1: 
0:     public static CompressionParameters deflate(Integer chunkLength)
1:     {
0:         return new CompressionParameters(DeflateCompressor.instance, chunkLength, Collections.emptyMap());
1:     }
1: 
0:     public static CompressionParameters lz4()
1:     {
1:         return lz4(null);
1:     }
1: 
0:     public static CompressionParameters lz4(Integer chunkLength)
1:     {
0:         return new CompressionParameters(LZ4Compressor.instance, chunkLength, Collections.emptyMap());
1:     }
1: 
0:     CompressionParameters(String sstableCompressorClass, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
0:     private CompressionParameters(ICompressor sstableCompressor, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
1:         this.otherOptions = ImmutableMap.copyOf(otherOptions);
0:         return new CompressionParameters(sstableCompressor, chunkLength, otherOptions);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks if compression is enabled.
0:      * @return <code>true</code> if compression is enabled, <code>false</code> otherwise.
1:      */
1:     public boolean isEnabled()
1:     {
1:         return sstableCompressor != null;
1:     }
1: 
1:     /**
1:      * Returns the SSTable compressor.
0:      * @return the SSTable compressor or <code>null</code> if compression is disabled.
1:      */
1:     public ICompressor getSstableCompressor()
1:     {
1:         return sstableCompressor;
1:     }
1: 
1:     public ImmutableMap<String, String> getOtherOptions()
1:     {
1:         return otherOptions;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static Integer parseChunkLength(String chLengthKB) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:                 throw new ConfigurationException("Value of " + CHUNK_LENGTH_IN_KB + " is too large (" + parsed + ")");
1:             throw new ConfigurationException("Invalid value for " + CHUNK_LENGTH_IN_KB, e);
1:     /**
1:      * Removes the chunk length option from the specified set of option.
1:      *
1:      * @param options the options
1:      * @return the chunk length value
1:      */
1:     private static Integer removeChunkLength(Map<String, String> options)
1:     {
1:         if (options.containsKey(CHUNK_LENGTH_IN_KB))
1:         {
1:             if (options.containsKey(CHUNK_LENGTH_KB))
1:             {
0:                 throw new ConfigurationException(String.format("The '%s' option must not be used if the chunk length is already specified by the '%s' option",
0:                                                                CHUNK_LENGTH_KB,
0:                                                                CHUNK_LENGTH_IN_KB));
1:             }
1: 
1:             return parseChunkLength(options.remove(CHUNK_LENGTH_IN_KB));
1:         }
1: 
1:         if (options.containsKey(CHUNK_LENGTH_KB))
1:         {
0:             if (options.containsKey(CHUNK_LENGTH_KB) && !hasLoggedChunkLengthWarning)
1:             {
1:                 hasLoggedChunkLengthWarning = true;
0:                 LOGGER.warn(String.format("The %s option has been deprecated. You should use %s instead",
0:                                           CHUNK_LENGTH_KB,
0:                                           CHUNK_LENGTH_IN_KB));
1:             }
1: 
1:             return parseChunkLength(options.remove(CHUNK_LENGTH_KB));
1:         }
1: 
1:         return null;
1:     }
1: 
1:     /**
0:      * Returns <code>true</code> if the specified options contains the name of the compression class to be used,
0:      * <code>false</code> otherwise.
1:      *
1:      * @param options the options
0:      * @return <code>true</code> if the specified options contains the name of the compression class to be used,
0:      * <code>false</code> otherwise.
1:      */
1:     public static boolean containsSstableCompressionClass(Map<String, String> options)
1:     {
0:         return options.containsKey(CLASS)
0:                 || options.containsKey(SSTABLE_COMPRESSION);
1:     }
1: 
1:     /**
1:      * Removes the option specifying the name of the compression class
1:      *
1:      * @param options the options
1:      * @return the name of the compression class
1:      */
1:     private static String removeSstableCompressionClass(Map<String, String> options)
1:     {
1:         if (options.containsKey(CLASS))
1:         {
1:             if (options.containsKey(SSTABLE_COMPRESSION))
0:                 throw new ConfigurationException(String.format("The '%s' option must not be used if the compression algorithm is already specified by the '%s' option",
0:                                                                SSTABLE_COMPRESSION,
0:                                                                CLASS));
1: 
1:             String clazz = options.remove(CLASS);
1:             if (clazz.isEmpty())
0:                 throw new ConfigurationException(String.format("The '%s' option must not be empty. To disable compression use 'enabled' : false", CLASS));
1: 
1:             return clazz;
1:         }
1: 
1:         if (options.containsKey(SSTABLE_COMPRESSION) && !hasLoggedSsTableCompressionWarning)
1:         {
1:             hasLoggedSsTableCompressionWarning = true;
0:             LOGGER.warn(String.format("The %s option has been deprecated. You should use %s instead",
0:                                       SSTABLE_COMPRESSION,
0:                                       CLASS));
1:         }
1: 
1:         return options.remove(SSTABLE_COMPRESSION);
1:     }
1: 
1:     /**
0:      * Returns <code>true</code> if the options contains the <code>enabled</code> option and that its value is
0:      * <code>true</code>, otherwise returns <code>false</code>.
1:      *
1:      * @param options the options
0:      * @return <code>true</code> if the options contains the <code>enabled</code> option and that its value is
0:      * <code>true</code>, otherwise returns <code>false</code>.
1:      */
1:     public static boolean isEnabled(Map<String, String> options)
1:     {
1:         String enabled = options.get(ENABLED);
1:         return enabled == null || Boolean.parseBoolean(enabled);
1:     }
1: 
1:     /**
0:      * Removes the <code>enabled</code> option from the specified options.
1:      *
1:      * @param options the options
0:      * @return the value of the <code>enabled</code> option
1:      */
1:     private static boolean removeEnabled(Map<String, String> options)
1:     {
1:         String enabled = options.remove(ENABLED);
1:         return enabled == null || Boolean.parseBoolean(enabled);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH_IN_KB);
/////////////////////////////////////////////////////////////////////////
1:                         throw new ConfigurationException(CHUNK_LENGTH_IN_KB + " must be a power of 2");
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, String> asMap()
1:         if (!isEnabled())
1:             return Collections.singletonMap(ENABLED, "false");
0:         Map<String, String> options = new HashMap<String, String>(otherOptions);
1:         options.put(CLASS, sstableCompressor.getClass().getName());
1:         options.put(CHUNK_LENGTH_IN_KB, chunkLengthInKB());
1:     public String chunkLengthInKB()
/////////////////////////////////////////////////////////////////////////
1:             .append(chunkLength(), cp.chunkLength())
/////////////////////////////////////////////////////////////////////////
1:             .append(chunkLength())
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public CompressionParameters deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             long size = TypeSizes.sizeof(parameters.sstableCompressor.getClass().getSimpleName());
1:             size += TypeSizes.sizeof(parameters.otherOptions.size());
1:                 size += TypeSizes.sizeof(entry.getKey());
1:                 size += TypeSizes.sizeof(entry.getValue());
1:             size += TypeSizes.sizeof(parameters.chunkLength());
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:6fe6c99
commit:fb1eaab
commit:04eba90
/////////////////////////////////////////////////////////////////////////
0:         if (liveMetadata != null && this != liveMetadata.compressionParameters)
commit:3bfe4b6
commit:80c5191
commit:a85e731
/////////////////////////////////////////////////////////////////////////
commit:c2b26e5
commit:cd714a1
commit:ac9cfbd
/////////////////////////////////////////////////////////////////////////
0:         if (liveMetadata == null)
0:             return;
1: 
author:blambov
-------------------------------------------------------------------------------
commit:8a03181
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ParameterizedClass;
/////////////////////////////////////////////////////////////////////////
0:     public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException {
commit:44f8254
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
1: 
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.ParametrizedClass;
1: import org.apache.cassandra.exceptions.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
1:     private static Class<?> parseCompressorClass(String className) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:             return Class.forName(className);
/////////////////////////////////////////////////////////////////////////
1:     private static ICompressor createCompressor(Class<?> compressorClass, Map<String, String> compressionOptions) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:     public static ICompressor createCompressor(ParametrizedClass compression) throws ConfigurationException {
1:         return createCompressor(parseCompressorClass(compression.class_name), copyOptions(compression.parameters));
1:     }
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:1762424
/////////////////////////////////////////////////////////////////////////
0:         return new CompressionParameters(sstableCompressor, chunkLength, new HashMap<>(otherOptions));
author:Jake Luciani
-------------------------------------------------------------------------------
commit:3fd90ae
commit:62db20a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
0:     private CFMetaData liveMetadata;
/////////////////////////////////////////////////////////////////////////
0:     public void setLiveMetadata(final CFMetaData liveMetadata)
1:     {
0:         assert this.liveMetadata == null || this.liveMetadata == liveMetadata;
0:         this.liveMetadata = liveMetadata;
1:     }
1: 
1: 
0:         if (liveMetadata != null)
0:             liveMetadata.compressionParameters.setCrcCheckChance(crcCheckChance);
0:         return liveMetadata == null ? this.crcCheckChance : liveMetadata.compressionParameters.crcCheckChance;
commit:248d626
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         otherOptions.remove(CRC_CHECK_CHANCE);
commit:5a90123
/////////////////////////////////////////////////////////////////////////
0:         options.remove(CRC_CHECK_CHANCE);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(CompressionParameters parameters, DataOutputPlus out, int version) throws IOException
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4885bfc
/////////////////////////////////////////////////////////////////////////
1:         {
1:             if (!compressionOptions.isEmpty())
1:                 throw new ConfigurationException("Unknown compression options (" + compressionOptions.keySet() + ") since no compression class found");
1:         }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
commit:820411f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:             ICompressor compressor = (ICompressor)method.invoke(null, compressionOptions);
1:             // Check for unknown options
0:             Set<String> supportedOpts = compressor.supportedOptions();
1:             for (String provided : compressionOptions.keySet())
0:                 if (!supportedOpts.contains(provided))
1:                     throw new ConfigurationException("Unknown compression options " + provided);
1:             return compressor;
commit:bc577ba
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:d8f5842
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Parse the chunk length (in KB) and returns it as bytes.
1:      */
/////////////////////////////////////////////////////////////////////////
0:             return 1024 * Integer.parseInt(chLength);
commit:3e77792
/////////////////////////////////////////////////////////////////////////
0: import org.apache.avro.util.Utf8;
/////////////////////////////////////////////////////////////////////////
0:     public static final String SSTABLE_COMPRESSION = "sstable_compression";
0:     public static final String CHUNK_LENGTH = "chunk_length_kb";
0:     public final ICompressor sstableCompressor;
1:     private final Integer chunkLength;
0:     public final Map<String, String> otherOptions; // Unrecognized options, can be use by the compressor
0:     public static CompressionParameters create(Map<? extends CharSequence, ? extends CharSequence> opts) throws ConfigurationException
1:         Map<String, String> options = copyOptions(opts);
0:         String sstableCompressionClass = options.get(SSTABLE_COMPRESSION);
0:         String chunkLength = options.get(CHUNK_LENGTH);
0:         options.remove(SSTABLE_COMPRESSION);
0:         options.remove(CHUNK_LENGTH);
0:         CompressionParameters cp = new CompressionParameters(sstableCompressionClass, parseChunkLength(chunkLength), options);
0:         cp.validateChunkLength();
1:         return cp;
0:     public CompressionParameters(String sstableCompressorClass, Integer chunkLength, Map<String, String> otherOptions) throws ConfigurationException
1:         this(createCompressor(parseCompressorClass(sstableCompressorClass), otherOptions), chunkLength, otherOptions);
0:     public CompressionParameters(ICompressor sstableCompressor)
0:         this(sstableCompressor, null, Collections.<String, String>emptyMap());
0:     public CompressionParameters(ICompressor sstableCompressor, Integer chunkLength, Map<String, String> otherOptions)
0:         this.sstableCompressor = sstableCompressor;
0:         this.otherOptions = otherOptions;
1:     public int chunkLength()
1:         return chunkLength == null ? DEFAULT_CHUNK_LENGTH : chunkLength;
1:     }
1: 
1: 
0:     private static Class<? extends ICompressor> parseCompressorClass(String className) throws ConfigurationException
1:     {
0:         if (className == null)
/////////////////////////////////////////////////////////////////////////
1:             throw new ConfigurationException("Could not create Compression for type " + className, e);
/////////////////////////////////////////////////////////////////////////
0:     private static Integer parseChunkLength(String chLength) throws ConfigurationException
0:         if (chLength == null)
1:             return null;
1: 
1:         try
0:             return Integer.parseInt(chLength);
0:         catch (NumberFormatException e)
1:         {
0:             throw new ConfigurationException("Invalid value for " + CHUNK_LENGTH, e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (chunkLength == null)
0:             return; // chunk length not set, this is fine, default will be used
1: 
0:             throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH);
/////////////////////////////////////////////////////////////////////////
0:                     throw new ConfigurationException(CHUNK_LENGTH + " must be a power of 2");
/////////////////////////////////////////////////////////////////////////
0:     public Map<CharSequence, CharSequence> asAvroOptions()
1:     {
0:         Map<CharSequence, CharSequence> options = new HashMap<CharSequence, CharSequence>();
0:         for (Map.Entry<String, String> entry : otherOptions.entrySet())
0:             options.put(new Utf8(entry.getKey()), new Utf8(entry.getValue()));
1: 
0:         if (sstableCompressor == null)
1:             return options;
1: 
0:         options.put(new Utf8(SSTABLE_COMPRESSION), new Utf8(sstableCompressor.getClass().getName()));
1:         if (chunkLength != null)
0:             options.put(new Utf8(CHUNK_LENGTH), new Utf8(chunkLength.toString()));
1:         return options;
1:     }
1: 
0:     public Map<String, String> asThriftOptions()
1:     {
0:         Map<String, String> options = new HashMap<String, String>(otherOptions);
0:         if (sstableCompressor == null)
1:             return options;
1: 
0:         options.put(SSTABLE_COMPRESSION, sstableCompressor.getClass().getName());
1:         if (chunkLength != null)
0:             options.put(CHUNK_LENGTH, chunkLength.toString());
1:         return options;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             .append(sstableCompressor, cp.sstableCompressor)
0:             .append(chunkLength, cp.chunkLength)
1:             .append(otherOptions, cp.otherOptions)
/////////////////////////////////////////////////////////////////////////
1:             .append(sstableCompressor)
0:             .append(chunkLength)
1:             .append(otherOptions)
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:21aef92
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.TypeSizes;
1: import org.apache.cassandra.io.IVersionedSerializer;
0:     public final static IVersionedSerializer<CompressionParameters> serializer = new Serializer();
/////////////////////////////////////////////////////////////////////////
1: 
0:     static class Serializer implements IVersionedSerializer<CompressionParameters>
1:     {
0:         public void serialize(CompressionParameters parameters, DataOutput out, int version) throws IOException
1:         {
1:             out.writeUTF(parameters.sstableCompressor.getClass().getSimpleName());
1:             out.writeInt(parameters.otherOptions.size());
1:             for (Map.Entry<String, String> entry : parameters.otherOptions.entrySet())
1:             {
1:                 out.writeUTF(entry.getKey());
1:                 out.writeUTF(entry.getValue());
1:             }
1:             out.writeInt(parameters.chunkLength());
1:         }
1: 
0:         public CompressionParameters deserialize(DataInput in, int version) throws IOException
1:         {
1:             String compressorName = in.readUTF();
1:             int optionCount = in.readInt();
0:             Map<String, String> options = new HashMap<String, String>();
1:             for (int i = 0; i < optionCount; ++i)
1:             {
1:                 String key = in.readUTF();
1:                 String value = in.readUTF();
1:                 options.put(key, value);
1:             }
1:             int chunkLength = in.readInt();
0:             CompressionParameters parameters;
1:             try
1:             {
0:                 parameters = new CompressionParameters(compressorName, chunkLength, options);
1:             }
0:             catch (ConfigurationException e)
1:             {
0:                 throw new RuntimeException("Cannot create CompressionParameters for parameters", e);
1:             }
1:             return parameters;
1:         }
1: 
0:         public long serializedSize(CompressionParameters parameters, int version)
1:         {
0:             long size = TypeSizes.NATIVE.sizeof(parameters.sstableCompressor.getClass().getSimpleName());
0:             size += TypeSizes.NATIVE.sizeof(parameters.otherOptions.size());
1:             for (Map.Entry<String, String> entry : parameters.otherOptions.entrySet())
1:             {
0:                 size += TypeSizes.NATIVE.sizeof(entry.getKey());
0:                 size += TypeSizes.NATIVE.sizeof(entry.getValue());
1:             }
0:             size += TypeSizes.NATIVE.sizeof(parameters.chunkLength());
1:             return size;
1:         }
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:6e8c237
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
commit:be53b6d
/////////////////////////////////////////////////////////////////////////
1:             int parsed = Integer.parseInt(chLengthKB);
1:             if (parsed > Integer.MAX_VALUE / 1024)
0:                 throw new ConfigurationException("Value of " + CHUNK_LENGTH_KB + " is too large (" + parsed + ")");
1:             return 1024 * parsed;
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:6c70b83
/////////////////////////////////////////////////////////////////////////
1:         if (className == null || className.isEmpty())
commit:7f747c9
/////////////////////////////////////////////////////////////////////////
0:     public final static double DEFAULT_CRC_CHECK_CHANCE = 1.0;
0:     public static final String CRC_CHECK_CHANCE = "crc_check_chance";
0:     public final double crcChance;
/////////////////////////////////////////////////////////////////////////
1:         cp.validate();
/////////////////////////////////////////////////////////////////////////
0:         String chance = otherOptions.get(CRC_CHECK_CHANCE);
0:         this.crcChance = (chance == null) ? DEFAULT_CRC_CHECK_CHANCE : Double.parseDouble(chance);
/////////////////////////////////////////////////////////////////////////
0:     private void validate() throws ConfigurationException
1:         // if chunk length was not set (chunkLength == null), this is fine, default will be used
0:         if (chunkLength != null)
1:             if (chunkLength <= 0)
0:                 throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH_KB);
1: 
1:             int c = chunkLength;
1:             boolean found = false;
1:             while (c != 0)
1:                 if ((c & 0x01) != 0)
1:                 {
1:                     if (found)
0:                         throw new ConfigurationException(CHUNK_LENGTH_KB + " must be a power of 2");
1:                     else
1:                         found = true;
1:                 }
1:                 c >>= 1;
1: 
0:         if (crcChance > 1.0d || crcChance < 0.0d)
0:             throw new ConfigurationException("crc_check_chance should be between 0.0 to 1.0");
commit:09ac4bc
/////////////////////////////////////////////////////////////////////////
0:     public static final String CHUNK_LENGTH_KB = "chunk_length_kb";
/////////////////////////////////////////////////////////////////////////
0:         String chunkLength = options.get(CHUNK_LENGTH_KB);
0:         options.remove(CHUNK_LENGTH_KB);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static Integer parseChunkLength(String chLengthKB) throws ConfigurationException
1:         if (chLengthKB == null)
0:             return 1024 * Integer.parseInt(chLengthKB);
0:             throw new ConfigurationException("Invalid value for " + CHUNK_LENGTH_KB, e);
/////////////////////////////////////////////////////////////////////////
0:             throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH_KB);
/////////////////////////////////////////////////////////////////////////
0:                     throw new ConfigurationException(CHUNK_LENGTH_KB + " must be a power of 2");
/////////////////////////////////////////////////////////////////////////
0:             options.put(new Utf8(CHUNK_LENGTH_KB), new Utf8(chunkLengthInKB()));
/////////////////////////////////////////////////////////////////////////
0:             options.put(CHUNK_LENGTH_KB, chunkLengthInKB());
0:     private String chunkLengthInKB()
1:     {
1:         return String.valueOf(chunkLength() / 1024);
1:     }
1: 
commit:0d805c7
/////////////////////////////////////////////////////////////////////////
0:             Throwable cause = e.getCause();
0:             throw new ConfigurationException(String.format("%s.create() threw an error: %s",
0:                                              compressorClass.getSimpleName(),
0:                                              cause == null ? e.getClass().getName() + " " + e.getMessage() : cause.getClass().getName() + " " + cause.getMessage()),
1:                                              e);
commit:c8afd76
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
0: package org.apache.cassandra.io.compress;
1: 
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.Map;
1: 
0: import org.apache.commons.lang.builder.EqualsBuilder;
0: import org.apache.commons.lang.builder.HashCodeBuilder;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
1: 
0: public class CompressionParameters
1: {
0:     public final static int DEFAULT_CHUNK_LENGTH = 65536;
0:     public static final String CHUNK_LENGTH_PARAMETER = "chunk_length_kb";
1: 
0:     public final Class<? extends ICompressor> compressorClass;
0:     public final Map<String, String> compressionOptions;
1: 
0:     public final transient ICompressor compressor;
0:     public final transient int chunkLength;
1: 
0:     public CompressionParameters(CharSequence compressorClassName, Map<? extends CharSequence, ? extends CharSequence> options) throws ConfigurationException
1:     {
0:         this(compressorClassName, copyOptions(options), -1);
1:     }
1: 
0:     public CompressionParameters(CharSequence compressorClassName, Map<String, String> options, int chunkLength) throws ConfigurationException
1:     {
0:         this(createCompressor(parseCompressorClass(compressorClassName), options), options, chunkLength < 0 ? getChunkLength(options) : chunkLength);
0:         validateChunkLength();
1:     }
1: 
0:     public CompressionParameters(ICompressor compressor)
1:     {
0:         this(compressor, null, DEFAULT_CHUNK_LENGTH);
1:     }
1: 
0:     public CompressionParameters(ICompressor compressor, Map<String, String> compressionOptions, int chunkLength)
1:     {
0:         this.compressorClass = compressor == null ? null : compressor.getClass();
0:         this.compressionOptions = compressor == null ? null : (compressionOptions == null ? Collections.<String, String>emptyMap() : compressionOptions);
1:         this.chunkLength = chunkLength;
0:         this.compressor = compressor;
1:     }
1: 
0:     private static Class<? extends ICompressor> parseCompressorClass(CharSequence cc) throws ConfigurationException
1:     {
0:         if (cc == null)
1:             return null;
1: 
0:         String className = cc.toString();
1:         className = className.contains(".") ? className : "org.apache.cassandra.io.compress." + className;
0:         try
1:         {
0:             return (Class<? extends ICompressor>)Class.forName(className);
1:         }
1:         catch (Exception e)
1:         {
0:             throw new ConfigurationException("Could not create Compression for type " + cc.toString(), e);
1:         }
1:     }
1: 
0:     private static ICompressor createCompressor(Class<? extends ICompressor> compressorClass, Map<String, String> compressionOptions) throws ConfigurationException
1:     {
1:         if (compressorClass == null)
1:             return null;
1: 
0:         try
1:         {
1:             Method method = compressorClass.getMethod("create", Map.class);
0:             return (ICompressor)method.invoke(null, compressionOptions);
1:         }
1:         catch (NoSuchMethodException e)
1:         {
1:             throw new ConfigurationException("create method not found", e);
1:         }
1:         catch (SecurityException e)
1:         {
1:             throw new ConfigurationException("Access forbiden", e);
1:         }
1:         catch (IllegalAccessException e)
1:         {
1:             throw new ConfigurationException("Cannot access method create in " + compressorClass.getName(), e);
1:         }
1:         catch (InvocationTargetException e)
1:         {
0:             throw new ConfigurationException(compressorClass.getSimpleName() + ".create() throwed an error", e);
1:         }
1:         catch (ExceptionInInitializerError e)
1:         {
1:             throw new ConfigurationException("Cannot initialize class " + compressorClass.getName());
1:         }
1:     }
1: 
1:     private static Map<String, String> copyOptions(Map<? extends CharSequence, ? extends CharSequence> co)
1:     {
1:         if (co == null || co.isEmpty())
0:             return Collections.<String, String>emptyMap();
1: 
0:         Map<String, String> compressionOptions = new HashMap<String, String>();
1:         for (Map.Entry<? extends CharSequence, ? extends CharSequence> entry : co.entrySet())
1:         {
1:             compressionOptions.put(entry.getKey().toString(), entry.getValue().toString());
1:         }
1:         return compressionOptions;
1:     }
1: 
0:     private static int getChunkLength(Map<String, String> options) throws ConfigurationException
1:     {
0:         int chunkLength = DEFAULT_CHUNK_LENGTH;
0:         if (options != null && options.containsKey(CHUNK_LENGTH_PARAMETER))
1:         {
0:             try
1:             {
0:                 chunkLength = Integer.parseInt(options.get(CHUNK_LENGTH_PARAMETER));
1:             }
0:             catch (NumberFormatException e)
1:             {
0:                 throw new ConfigurationException("Invalid value for " + CHUNK_LENGTH_PARAMETER, e);
1:             }
1:         }
0:         return chunkLength;
1:     }
1: 
1:     // chunkLength must be a power of 2 because we assume so when
1:     // computing the chunk number from an uncompressed file offset (see
1:     // CompressedRandomAccessReader.decompresseChunk())
0:     private void validateChunkLength() throws ConfigurationException
1:     {
0:         if (chunkLength <= 0)
0:             throw new ConfigurationException("Invalid negative or null " + CHUNK_LENGTH_PARAMETER);
1: 
0:         int c = chunkLength;
0:         boolean found = false;
0:         while (c != 0)
1:         {
0:             if ((c & 0x01) != 0)
1:             {
0:                 if (found)
0:                     throw new ConfigurationException(CHUNK_LENGTH_PARAMETER + " must be a power of 2");
0:                 else
0:                     found = true;
1:             }
0:             c >>= 1;
1:         }
1:     }
1: 
1:     @Override
1:     public boolean equals(Object obj)
1:     {
1:         if (obj == this)
1:         {
1:             return true;
1:         }
1:         else if (obj == null || obj.getClass() != getClass())
1:         {
1:             return false;
1:         }
1: 
0:         CompressionParameters cp = (CompressionParameters) obj;
1:         return new EqualsBuilder()
0:             .append(compressorClass, cp.compressorClass)
0:             .append(compressionOptions, cp.compressionOptions)
1:             .isEquals();
1:     }
1: 
1:     @Override
1:     public int hashCode()
1:     {
1:         return new HashCodeBuilder(29, 1597)
0:             .append(compressorClass)
0:             .append(compressionOptions)
1:             .toHashCode();
1:     }
1: }
============================================================================