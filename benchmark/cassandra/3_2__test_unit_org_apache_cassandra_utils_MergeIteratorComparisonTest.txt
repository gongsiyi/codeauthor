1:c29001b: /*
1:c29001b: * Licensed to the Apache Software Foundation (ASF) under one
1:c29001b: * or more contributor license agreements.  See the NOTICE file
1:c29001b: * distributed with this work for additional information
1:c29001b: * regarding copyright ownership.  The ASF licenses this file
1:c29001b: * to you under the Apache License, Version 2.0 (the
1:c29001b: * "License"); you may not use this file except in compliance
1:c29001b: * with the License.  You may obtain a copy of the License at
1:c29001b: *
1:c29001b: *    http://www.apache.org/licenses/LICENSE-2.0
1:c29001b: *
1:c29001b: * Unless required by applicable law or agreed to in writing,
1:c29001b: * software distributed under the License is distributed on an
1:c29001b: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:c29001b: * KIND, either express or implied.  See the License for the
1:c29001b: * specific language governing permissions and limitations
1:c29001b: * under the License.
1:c29001b: */
1:c29001b: package org.apache.cassandra.utils;
1:c29001b: 
1:c29001b: import java.nio.ByteBuffer;
1:c29001b: import java.util.*;
1:c29001b: 
1:c29001b: import com.google.common.base.Function;
1:c29001b: import com.google.common.base.Objects;
1:489a9e8: import org.apache.cassandra.utils.AbstractIterator;
1:c29001b: import com.google.common.collect.ImmutableSet;
1:c29001b: import com.google.common.collect.Iterators;
1:c29001b: import com.google.common.collect.Lists;
1:c29001b: import com.google.common.collect.Ordering;
1:c29001b: import com.google.common.collect.Sets;
1:c29001b: 
1:c29001b: import org.junit.Assert;
1:c29001b: import org.junit.Test;
1:c29001b: 
1:c29001b: import org.apache.cassandra.db.marshal.AbstractType;
1:c29001b: import org.apache.cassandra.db.marshal.TimeUUIDType;
1:c29001b: import org.apache.cassandra.db.marshal.UUIDType;
1:c29001b: import org.apache.cassandra.utils.MergeIterator.Reducer;
1:c29001b: 
1:c29001b: public class MergeIteratorComparisonTest
1:c29001b: {
1:c29001b:     private static class CountingComparator<T> implements Comparator<T>
1:c29001b:     {
1:c29001b:         final Comparator<T> wrapped;
1:c29001b:         int count = 0;
1:c29001b: 
1:c29001b:         protected CountingComparator(Comparator<T> wrapped)
1:c29001b:         {
1:c29001b:             this.wrapped = wrapped;
1:c29001b:         }
1:c29001b: 
1:c29001b:         public int compare(T o1, T o2)
1:c29001b:         {
1:c29001b:             count++;
1:c29001b:             return wrapped.compare(o1, o2);
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     static int ITERATOR_COUNT = 15;
1:c29001b:     static int LIST_LENGTH = 15000;
1:c29001b:     static boolean BENCHMARK = false;
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testRandomInts()
1:c29001b:     {
1:c29001b:         System.out.println("testRandomInts");
1:c29001b:         final Random r = new Random();
1:c29001b:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1:c29001b: 
1:c29001b:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public Integer next()
1:c29001b:             {
1:c29001b:                 return r.nextInt(5 * LIST_LENGTH);
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b:     
1:c29001b:     @Test
1:c29001b:     public void testNonOverlapInts()
1:c29001b:     {
1:c29001b:         System.out.println("testNonOverlapInts");
1:c29001b:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1:c29001b: 
1:c29001b:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 1;
1:c29001b:             @Override
1:c29001b:             public Integer next()
1:c29001b:             {
1:c29001b:                 return next++;
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testCombinationInts()
1:c29001b:     {
1:c29001b:         System.out.println("testCombinationInts");
1:c29001b:         final Random r = new Random();
1:c29001b:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1:c29001b: 
1:c29001b:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 1;
1:c29001b:             @Override
1:c29001b:             public Integer next()
1:c29001b:             {
1:c29001b:                 return r.nextBoolean() ? r.nextInt(5 * LIST_LENGTH) : next++;
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testLCSTotalOverlap()
1:c29001b:     {
1:c29001b:         testLCS(2, LIST_LENGTH / 100, 1f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 1f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 1f, 10, LIST_LENGTH);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 1f);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 1f, 10, LIST_LENGTH);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testLCSPartialOverlap()
1:c29001b:     {
1:c29001b:         testLCS(2, LIST_LENGTH / 100, 0.5f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 0.5f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 0.5f, 10, LIST_LENGTH);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 0.5f);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 0.5f, 10, LIST_LENGTH);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testLCSNoOverlap()
1:c29001b:     {
1:c29001b:         testLCS(2, LIST_LENGTH / 100, 0f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 0f);
1:c29001b:         testLCS(3, LIST_LENGTH / 100, 0f, 10, LIST_LENGTH);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 0f);
1:c29001b:         testLCS(4, LIST_LENGTH / 100, 0f, 10, LIST_LENGTH);
1:c29001b:     }
1:c29001b: 
1:c29001b:     public void testLCS(int levelCount, int levelMultiplier, float levelOverlap)
1:c29001b:     {
1:c29001b:         testLCS(levelCount, levelMultiplier, levelOverlap, 0, 0);
1:c29001b:     }
1:c29001b:     public void testLCS(int levelCount, int levelMultiplier, float levelOverlap, int countOfL0, int sizeOfL0)
1:c29001b:     {
1:c29001b:         System.out.printf("testLCS(lc=%d,lm=%d,o=%.2f,L0=%d*%d)\n", levelCount, levelMultiplier, levelOverlap, countOfL0, countOfL0 == 0 ? 0 : sizeOfL0 / countOfL0);
1:c29001b:         final Random r = new Random();
1:c29001b:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1:c29001b:         List<List<Integer>> lists = new LCSGenerator<Integer>(Ordering.<Integer>natural(), levelCount, levelMultiplier, levelOverlap) {
1:c29001b:             @Override
1:c29001b:             public Integer newItem()
1:c29001b:             {
1:c29001b:                 return r.nextInt();
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         if (sizeOfL0 > 0 && countOfL0 > 0)
1:c29001b:             lists.addAll(new NaturalListGenerator<Integer>(countOfL0, sizeOfL0 / countOfL0)
1:c29001b:             {
1:c29001b:                 Integer next()
1:c29001b:                 {
1:c29001b:                     return r.nextInt();
1:c29001b:                 }
1:c29001b:             }.result);
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testRandomStrings()
1:c29001b:     {
1:c29001b:         System.out.println("testRandomStrings");
1:c29001b:         final Random r = new Random();
1:c29001b:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1:c29001b: 
1:c29001b:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public String next()
1:c29001b:             {
1:c29001b:                 return "longish_prefix_" + r.nextInt(5 * LIST_LENGTH);
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b:     
1:c29001b:     @Test
1:c29001b:     public void testNonOverlapStrings()
1:c29001b:     {
1:c29001b:         System.out.println("testNonOverlapStrings");
1:c29001b:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1:c29001b: 
1:c29001b:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 1;
1:c29001b:             @Override
1:c29001b:             public String next()
1:c29001b:             {
1:c29001b:                 return "longish_prefix_" + next++;
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testCombinationStrings()
1:c29001b:     {
1:c29001b:         System.out.println("testCombinationStrings");
1:c29001b:         final Random r = new Random();
1:c29001b:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1:c29001b: 
1:c29001b:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 1;
1:c29001b:             public String next()
1:c29001b:             {
1:c29001b:                 return "longish_prefix_" + (r.nextBoolean() ? r.nextInt(5 * LIST_LENGTH) : next++);
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testTimeUuids()
1:c29001b:     {
1:c29001b:         System.out.println("testTimeUuids");
1:c29001b:         Reducer<UUID, Counted<UUID>> reducer = new Counter<UUID>();
1:c29001b: 
1:c29001b:         List<List<UUID>> lists = new NaturalListGenerator<UUID>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public UUID next()
1:c29001b:             {
1:c29001b:                 return UUIDGen.getTimeUUID();
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testRandomUuids()
1:c29001b:     {
1:c29001b:         System.out.println("testRandomUuids");
1:c29001b:         Reducer<UUID, Counted<UUID>> reducer = new Counter<UUID>();
1:c29001b: 
1:c29001b:         List<List<UUID>> lists = new NaturalListGenerator<UUID>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public UUID next()
1:c29001b:             {
1:c29001b:                 return UUID.randomUUID();
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testTimeUuidType()
1:c29001b:     {
1:c29001b:         System.out.println("testTimeUuidType");
1:c29001b:         final AbstractType<UUID> type = TimeUUIDType.instance;
1:c29001b:         Reducer<ByteBuffer, Counted<ByteBuffer>> reducer = new Counter<ByteBuffer>();
1:c29001b: 
1:c29001b:         List<List<ByteBuffer>> lists = new SimpleListGenerator<ByteBuffer>(type, ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public ByteBuffer next()
1:c29001b:             {
1:c29001b:                 return type.decompose(UUIDGen.getTimeUUID());
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists, type);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testUuidType()
1:c29001b:     {
1:c29001b:         System.out.println("testUuidType");
1:c29001b:         final AbstractType<UUID> type = UUIDType.instance;
1:c29001b:         Reducer<ByteBuffer, Counted<ByteBuffer>> reducer = new Counter<ByteBuffer>();
1:c29001b: 
1:c29001b:         List<List<ByteBuffer>> lists = new SimpleListGenerator<ByteBuffer>(type, ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public ByteBuffer next()
1:c29001b:             {
1:c29001b:                 return type.decompose(UUIDGen.getTimeUUID());
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists, type);
1:c29001b:     }
1:c29001b: 
1:c29001b:     
1:c29001b:     @Test
1:c29001b:     public void testSets()
1:c29001b:     {
1:c29001b:         System.out.println("testSets");
1:c29001b:         final Random r = new Random();
1:c29001b: 
1:c29001b:         Reducer<KeyedSet<Integer, UUID>, KeyedSet<Integer, UUID>> reducer = new Union<Integer, UUID>();
1:c29001b: 
1:c29001b:         List<List<KeyedSet<Integer, UUID>>> lists = new NaturalListGenerator<KeyedSet<Integer, UUID>>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             @Override
1:c29001b:             public KeyedSet<Integer, UUID> next()
1:c29001b:             {
1:c29001b:                 return new KeyedSet<>(r.nextInt(5 * LIST_LENGTH), UUIDGen.getTimeUUID());
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b:     /* */
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testLimitedOverlapStrings2()
1:c29001b:     {
1:c29001b:         System.out.println("testLimitedOverlapStrings2");
1:c29001b:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1:c29001b: 
1:c29001b:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 0;
1:c29001b:             @Override
1:c29001b:             public String next()
1:c29001b:             {
1:c29001b:                 ++next;
1:c29001b:                 int list = next / LIST_LENGTH;
1:c29001b:                 int id = next % LIST_LENGTH;
1:c29001b:                 return "longish_prefix_" + (id + list * LIST_LENGTH / 2);
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     @Test
1:c29001b:     public void testLimitedOverlapStrings3()
1:c29001b:     {
1:c29001b:         System.out.println("testLimitedOverlapStrings3");
1:c29001b:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1:c29001b: 
1:c29001b:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:c29001b:             int next = 0;
1:c29001b:             @Override
1:c29001b:             public String next()
1:c29001b:             {
1:c29001b:                 ++next;
1:c29001b:                 int list = next / LIST_LENGTH;
1:c29001b:                 int id = next % LIST_LENGTH;
1:c29001b:                 return "longish_prefix_" + (id + list * LIST_LENGTH / 3);
1:c29001b:             }
1:c29001b:         }.result;
1:c29001b:         testMergeIterator(reducer, lists);
1:c29001b:     }
1:c29001b: 
1:c29001b:     private static abstract class ListGenerator<T>
1:c29001b:     {
1:c29001b:         abstract boolean hasMoreItems();
1:c29001b:         abstract boolean hasMoreLists();
1:c29001b:         abstract T next();
1:c29001b: 
1:c29001b:         final Comparator<T> comparator;
1:c29001b:         final List<List<T>> result = Lists.newArrayList();
1:c29001b: 
1:c29001b:         protected ListGenerator(Comparator<T> comparator)
1:c29001b:         {
1:c29001b:             this.comparator = comparator;
1:c29001b:         }
1:c29001b: 
1:c29001b:         void build()
1:c29001b:         {
1:c29001b:             while (hasMoreLists())
1:c29001b:             {
1:c29001b:                 List<T> l = Lists.newArrayList();
1:c29001b:                 while (hasMoreItems())
1:c29001b:                     l.add(next());
1:c29001b:                 Collections.sort(l, comparator);
1:c29001b:                 result.add(l);
1:c29001b:             }
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     private static abstract class NaturalListGenerator<T extends Comparable<T>> extends SimpleListGenerator<T>
1:c29001b:     {
1:c29001b:         private NaturalListGenerator(int listCount, int perListCount)
1:c29001b:         {
1:c29001b:             super(Ordering.natural(), listCount, perListCount);
1:c29001b:         }
1:c29001b:     }
1:c29001b:     private static abstract class SimpleListGenerator<T> extends ListGenerator<T>
1:c29001b:     {
1:c29001b:         final int listCount;
1:c29001b:         final int perListCount;
1:c29001b: 
1:c29001b:         int listIdx = 0, itemIdx = 0;
1:c29001b: 
1:c29001b:         private SimpleListGenerator(Comparator<T> comparator, int listCount, int perListCount)
1:c29001b:         {
1:c29001b:             super(comparator);
1:c29001b:             this.listCount = listCount;
1:c29001b:             this.perListCount = perListCount;
1:c29001b:             build();
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean hasMoreItems()
1:c29001b:         {
1:c29001b:             return itemIdx++ < perListCount;
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean hasMoreLists()
1:c29001b:         {
1:c29001b:             itemIdx = 0;
1:c29001b:             return listIdx++ < listCount;
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     private static abstract class LCSGenerator<T> extends ListGenerator<T>
1:c29001b:     {
1:c29001b:         final int levelCount;
1:c29001b:         final int itemMultiplier;
1:c29001b:         final float levelOverlap;
1:c29001b: 
1:c29001b:         int levelIdx, itemIdx;
1:c29001b:         int levelItems, overlapItems, runningTotalItems;
1:c29001b:         final Random random = new Random();
1:c29001b: 
1:c29001b:         public LCSGenerator(Comparator<T> comparator, int levelCount, int l1Items, float levelOverlap)
1:c29001b:         {
1:c29001b:             super(comparator);
1:c29001b:             this.levelCount = levelCount;
1:c29001b:             this.itemMultiplier = l1Items;
1:c29001b:             this.levelOverlap = levelOverlap;
1:c29001b:             build();
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean hasMoreItems()
1:c29001b:         {
1:c29001b:             return itemIdx++ < levelItems;
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean hasMoreLists()
1:c29001b:         {
1:c29001b:             if (result.size() > 0)
1:c29001b:                 runningTotalItems += result.get(result.size() - 1).size();
1:c29001b:             itemIdx = 0;
1:c29001b:             levelItems = itemMultiplier * (int)Math.pow(10, levelCount - levelIdx);
1:c29001b:             overlapItems = levelIdx == 0 ? 0 : (int) (levelItems * levelOverlap);
1:c29001b:             return levelIdx++ < levelCount;
1:c29001b:         }
1:c29001b: 
1:c29001b:         abstract T newItem();
1:c29001b: 
1:c29001b:         T next()
1:c29001b:         {
1:c29001b:             if (itemIdx < overlapItems)
1:c29001b:             {
1:c29001b:                 int item = random.nextInt(runningTotalItems);
1:c29001b:                 for (List<T> list : result)
1:c29001b:                 {
1:c29001b:                     if (item < list.size()) return list.get(item);
1:c29001b:                     else item -= list.size();
1:c29001b:                 }
1:c29001b:             }
1:c29001b:             return newItem();
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     public <T extends Comparable<T>> void testMergeIterator(Reducer<T, ?> reducer, List<List<T>> lists)
1:c29001b:     {
1:c29001b:         testMergeIterator(reducer, lists, Ordering.natural());
1:c29001b:     }
1:c29001b:     public <T> void testMergeIterator(Reducer<T, ?> reducer, List<List<T>> lists, Comparator<T> comparator)
1:c29001b:     {
1:c29001b:         {
1:c29001b:             IMergeIterator<T,?> tested = MergeIterator.get(closeableIterators(lists), comparator, reducer);
1:c29001b:             IMergeIterator<T,?> base = new MergeIteratorPQ<>(closeableIterators(lists), comparator, reducer);
1:c29001b:             // If test fails, try the version below for improved reporting:
1:c29001b:             Object[] basearr = Iterators.toArray(base, Object.class);
1:c29001b:             Assert.assertArrayEquals(basearr, Iterators.toArray(tested, Object.class));
1:c29001b:             //Assert.assertTrue(Iterators.elementsEqual(base, tested));
1:c29001b:             if (!BENCHMARK)
1:c29001b:                 return;
1:c29001b:         }
1:c29001b: 
1:c29001b:         CountingComparator<T> cmp, cmpb;
1:c29001b:         cmp = new CountingComparator<>(comparator); cmpb = new CountingComparator<>(comparator);
1:c29001b:         System.out.println();
1:c29001b:         for (int i=0; i<10; ++i) {
1:c29001b:             benchmarkIterator(MergeIterator.get(closeableIterators(lists), cmp, reducer), cmp);
1:c29001b:             benchmarkIterator(new MergeIteratorPQ<>(closeableIterators(lists), cmpb, reducer), cmpb);
1:c29001b:         }
1:c29001b:         System.out.format("MI: %.2f\n", cmp.count / (double) cmpb.count);
1:c29001b:     }
1:c29001b:     
1:c29001b:     public <T> void benchmarkIterator(IMergeIterator<T, ?> it, CountingComparator<T> comparator)
1:c29001b:     {
1:c29001b:         System.out.format("Testing %30s... ", it.getClass().getSimpleName());
1:c29001b:         long time = System.currentTimeMillis();
1:c29001b:         Object value = null;
1:c29001b:         while (it.hasNext())
1:c29001b:             value = it.next();
1:c29001b:         time = System.currentTimeMillis() - time;
1:c29001b:         String type = "";
1:c29001b:         if (value instanceof Counted<?>)
1:c29001b:         {
1:c29001b:             type = "type " + ((Counted<?>)value).item.getClass().getSimpleName();
1:c29001b:         }
1:c29001b:         System.out.format("%15s time %5dms; comparisons: %d\n", type, time, comparator.count);
1:c29001b:     }
1:c29001b: 
1:c29001b:     public <T> List<CloseableIterator<T>> closeableIterators(List<List<T>> iterators)
1:c29001b:     {
1:c29001b:         return Lists.transform(iterators, new Function<List<T>, CloseableIterator<T>>() {
1:c29001b: 
1:c29001b:             @Override
1:c29001b:             public CloseableIterator<T> apply(List<T> arg)
1:c29001b:             {
1:c29001b:                 return new CLI<T>(arg.iterator());
1:c29001b:             }
1:c29001b:         });
1:c29001b:     }
1:c29001b: 
1:c29001b:     static class Counted<T> {
1:c29001b:         T item;
1:c29001b:         int count;
1:c29001b:         
1:c29001b:         Counted(T item) {
1:c29001b:             this.item = item;
1:c29001b:             count = 0;
1:c29001b:         }
1:c29001b: 
1:c29001b:         public boolean equals(Object obj)
1:c29001b:         {
1:c29001b:             if (obj == null || !(obj instanceof Counted))
1:c29001b:                 return false;
1:c29001b:             Counted<?> c = (Counted<?>) obj;
1:c29001b:             return Objects.equal(item, c.item) && count == c.count;
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         public String toString()
1:c29001b:         {
1:c29001b:             return item.toString() + "x" + count;
1:c29001b:         }
1:c29001b:     }
1:c29001b:     
1:c29001b:     static class Counter<T> extends Reducer<T, Counted<T>> {
1:c29001b:         Counted<T> current = null;
1:c29001b:         boolean read = true;
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         public void reduce(int idx, T next)
1:c29001b:         {
1:c29001b:             if (current == null)
1:c29001b:                 current = new Counted<T>(next);
1:c29001b:             assert current.item.equals(next);
1:c29001b:             ++current.count;
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         protected void onKeyChange()
1:c29001b:         {
1:c29001b:             assert read;
1:c29001b:             current = null;
1:c29001b:             read = false;
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         protected Counted<T> getReduced()
1:c29001b:         {
1:c29001b:             assert current != null;
1:c29001b:             read = true;
1:c29001b:             return current;
1:c29001b:         }
1:c29001b:     }
1:c29001b:     
1:c29001b:     static class KeyedSet<K extends Comparable<? super K>, V> extends Pair<K, Set<V>> implements Comparable<KeyedSet<K, V>>
1:c29001b:     {
1:c29001b:         protected KeyedSet(K left, V right)
1:c29001b:         {
1:c29001b:             super(left, ImmutableSet.of(right));
1:c29001b:         }
1:c29001b:         
1:c29001b:         protected KeyedSet(K left, Collection<V> right)
1:c29001b:         {
1:c29001b:             super(left, Sets.newHashSet(right));
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         public int compareTo(KeyedSet<K, V> o)
1:c29001b:         {
1:c29001b:             return left.compareTo(o.left);
1:c29001b:         }
1:c29001b:     }
1:c29001b:     
1:c29001b:     static class Union<K extends Comparable<K>, V> extends Reducer<KeyedSet<K, V>, KeyedSet<K, V>> {
1:c29001b:         KeyedSet<K, V> current = null;
1:c29001b:         boolean read = true;
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         public void reduce(int idx, KeyedSet<K, V> next)
1:c29001b:         {
1:c29001b:             if (current == null)
1:c29001b:                 current = new KeyedSet<>(next.left, next.right);
1:c29001b:             else {
1:c29001b:                 assert current.left.equals(next.left);
1:c29001b:                 current.right.addAll(next.right);
1:c29001b:             }
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         protected void onKeyChange()
1:c29001b:         {
1:c29001b:             assert read;
1:c29001b:             current = null;
1:c29001b:             read = false;
1:c29001b:         }
1:c29001b: 
1:c29001b:         @Override
1:c29001b:         protected KeyedSet<K, V> getReduced()
1:c29001b:         {
1:c29001b:             assert current != null;
1:c29001b:             read = true;
1:c29001b:             return current;
1:c29001b:         }
1:c29001b:     }
1:c29001b:     
1:c29001b:     // closeable list iterator
1:c29001b:     public static class CLI<E> extends AbstractIterator<E> implements CloseableIterator<E>
1:c29001b:     {
1:c29001b:         Iterator<E> iter;
1:c29001b:         boolean closed = false;
1:c29001b:         public CLI(Iterator<E> items)
1:c29001b:         {
1:c29001b:             this.iter = items;
1:c29001b:         }
1:c29001b: 
1:c29001b:         protected E computeNext()
1:c29001b:         {
1:c29001b:             if (!iter.hasNext()) return endOfData();
1:c29001b:             return iter.next();
1:c29001b:         }
1:c29001b: 
1:c29001b:         public void close()
1:c29001b:         {
1:c29001b:             assert !this.closed;
1:c29001b:             this.closed = true;
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     // Old MergeIterator implementation for comparison.
1:c29001b:     public class MergeIteratorPQ<In,Out> extends MergeIterator<In,Out> implements IMergeIterator<In, Out>
1:c29001b:     {
1:c29001b:         // a queue for return: all candidates must be open and have at least one item
1:c29001b:         protected final PriorityQueue<CandidatePQ<In>> queue;
1:c29001b:         // a stack of the last consumed candidates, so that we can lazily call 'advance()'
1:c29001b:         // TODO: if we had our own PriorityQueue implementation we could stash items
1:c29001b:         // at the end of its array, so we wouldn't need this storage
1:c29001b:         protected final ArrayDeque<CandidatePQ<In>> candidates;
1:c29001b:         public MergeIteratorPQ(List<? extends Iterator<In>> iters, Comparator<In> comp, Reducer<In, Out> reducer)
1:c29001b:         {
1:c29001b:             super(iters, reducer);
1:c29001b:             this.queue = new PriorityQueue<>(Math.max(1, iters.size()));
1:c29001b:             for (int i = 0; i < iters.size(); i++)
1:c29001b:             {
1:c29001b:                 CandidatePQ<In> candidate = new CandidatePQ<>(i, iters.get(i), comp);
1:c29001b:                 if (!candidate.advance())
1:c29001b:                     // was empty
1:c29001b:                     continue;
1:c29001b:                 this.queue.add(candidate);
1:c29001b:             }
1:c29001b:             this.candidates = new ArrayDeque<>(queue.size());
1:c29001b:         }
1:c29001b: 
1:c29001b:         protected final Out computeNext()
1:c29001b:         {
1:c29001b:             advance();
1:c29001b:             return consume();
1:c29001b:         }
1:c29001b: 
1:c29001b:         /** Consume values by sending them to the reducer while they are equal. */
1:c29001b:         protected final Out consume()
1:c29001b:         {
1:c29001b:             CandidatePQ<In> candidate = queue.peek();
1:c29001b:             if (candidate == null)
1:c29001b:                 return endOfData();
1:c29001b:             reducer.onKeyChange();
1:c29001b:             do
1:c29001b:             {
1:c29001b:                 candidate = queue.poll();
1:c29001b:                 candidates.push(candidate);
1:c29001b:                 reducer.reduce(candidate.idx, candidate.item);
1:c29001b:             }
1:c29001b:             while (queue.peek() != null && queue.peek().compareTo(candidate) == 0);
1:c29001b:             return reducer.getReduced();
1:c29001b:         }
1:c29001b: 
1:c29001b:         /** Advance and re-enqueue all items we consumed in the last iteration. */
1:c29001b:         protected final void advance()
1:c29001b:         {
1:c29001b:             CandidatePQ<In> candidate;
1:c29001b:             while ((candidate = candidates.pollFirst()) != null)
1:c29001b:                 if (candidate.advance())
1:c29001b:                     queue.add(candidate);
1:c29001b:         }
1:c29001b:     }
1:c29001b: 
1:c29001b:     // Holds and is comparable by the head item of an iterator it owns
1:c29001b:     protected static final class CandidatePQ<In> implements Comparable<CandidatePQ<In>>
1:c29001b:     {
1:c29001b:         private final Iterator<? extends In> iter;
1:c29001b:         private final Comparator<? super In> comp;
1:c29001b:         private final int idx;
1:c29001b:         private In item;
1:c29001b:         boolean equalParent;
1:c29001b: 
1:c29001b:         public CandidatePQ(int idx, Iterator<? extends In> iter, Comparator<? super In> comp)
1:c29001b:         {
1:c29001b:             this.iter = iter;
1:c29001b:             this.comp = comp;
1:c29001b:             this.idx = idx;
1:c29001b:         }
1:c29001b: 
1:c29001b:         /** @return true if our iterator had an item, and it is now available */
1:c29001b:         protected boolean advance()
1:c29001b:         {
1:c29001b:             if (!iter.hasNext())
1:c29001b:                 return false;
1:c29001b:             item = iter.next();
1:c29001b:             return true;
1:c29001b:         }
1:c29001b: 
1:c29001b:         public int compareTo(CandidatePQ<In> that)
1:c29001b:         {
1:c29001b:             return comp.compare(this.item, that.item);
1:c29001b:         }
1:c29001b:     }
1:c29001b: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AbstractIterator;
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:c29001b
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.utils;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import com.google.common.base.Function;
1: import com.google.common.base.Objects;
0: import com.google.common.collect.AbstractIterator;
1: import com.google.common.collect.ImmutableSet;
1: import com.google.common.collect.Iterators;
1: import com.google.common.collect.Lists;
1: import com.google.common.collect.Ordering;
1: import com.google.common.collect.Sets;
1: 
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.TimeUUIDType;
1: import org.apache.cassandra.db.marshal.UUIDType;
0: import org.apache.cassandra.utils.MergeIterator.Candidate;
1: import org.apache.cassandra.utils.MergeIterator.Reducer;
1: 
1: public class MergeIteratorComparisonTest
1: {
1:     private static class CountingComparator<T> implements Comparator<T>
1:     {
1:         final Comparator<T> wrapped;
1:         int count = 0;
1: 
1:         protected CountingComparator(Comparator<T> wrapped)
1:         {
1:             this.wrapped = wrapped;
1:         }
1: 
1:         public int compare(T o1, T o2)
1:         {
1:             count++;
1:             return wrapped.compare(o1, o2);
1:         }
1:     }
1: 
1:     static int ITERATOR_COUNT = 15;
1:     static int LIST_LENGTH = 15000;
1:     static boolean BENCHMARK = false;
1: 
1:     @Test
1:     public void testRandomInts()
1:     {
1:         System.out.println("testRandomInts");
1:         final Random r = new Random();
1:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1: 
1:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public Integer next()
1:             {
1:                 return r.nextInt(5 * LIST_LENGTH);
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1:     
1:     @Test
1:     public void testNonOverlapInts()
1:     {
1:         System.out.println("testNonOverlapInts");
1:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1: 
1:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 1;
1:             @Override
1:             public Integer next()
1:             {
1:                 return next++;
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testCombinationInts()
1:     {
1:         System.out.println("testCombinationInts");
1:         final Random r = new Random();
1:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1: 
1:         List<List<Integer>> lists = new NaturalListGenerator<Integer>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 1;
1:             @Override
1:             public Integer next()
1:             {
1:                 return r.nextBoolean() ? r.nextInt(5 * LIST_LENGTH) : next++;
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testLCSTotalOverlap()
1:     {
1:         testLCS(2, LIST_LENGTH / 100, 1f);
1:         testLCS(3, LIST_LENGTH / 100, 1f);
1:         testLCS(3, LIST_LENGTH / 100, 1f, 10, LIST_LENGTH);
1:         testLCS(4, LIST_LENGTH / 100, 1f);
1:         testLCS(4, LIST_LENGTH / 100, 1f, 10, LIST_LENGTH);
1:     }
1: 
1:     @Test
1:     public void testLCSPartialOverlap()
1:     {
1:         testLCS(2, LIST_LENGTH / 100, 0.5f);
1:         testLCS(3, LIST_LENGTH / 100, 0.5f);
1:         testLCS(3, LIST_LENGTH / 100, 0.5f, 10, LIST_LENGTH);
1:         testLCS(4, LIST_LENGTH / 100, 0.5f);
1:         testLCS(4, LIST_LENGTH / 100, 0.5f, 10, LIST_LENGTH);
1:     }
1: 
1:     @Test
1:     public void testLCSNoOverlap()
1:     {
1:         testLCS(2, LIST_LENGTH / 100, 0f);
1:         testLCS(3, LIST_LENGTH / 100, 0f);
1:         testLCS(3, LIST_LENGTH / 100, 0f, 10, LIST_LENGTH);
1:         testLCS(4, LIST_LENGTH / 100, 0f);
1:         testLCS(4, LIST_LENGTH / 100, 0f, 10, LIST_LENGTH);
1:     }
1: 
1:     public void testLCS(int levelCount, int levelMultiplier, float levelOverlap)
1:     {
1:         testLCS(levelCount, levelMultiplier, levelOverlap, 0, 0);
1:     }
1:     public void testLCS(int levelCount, int levelMultiplier, float levelOverlap, int countOfL0, int sizeOfL0)
1:     {
1:         System.out.printf("testLCS(lc=%d,lm=%d,o=%.2f,L0=%d*%d)\n", levelCount, levelMultiplier, levelOverlap, countOfL0, countOfL0 == 0 ? 0 : sizeOfL0 / countOfL0);
1:         final Random r = new Random();
1:         Reducer<Integer, Counted<Integer>> reducer = new Counter<Integer>();
1:         List<List<Integer>> lists = new LCSGenerator<Integer>(Ordering.<Integer>natural(), levelCount, levelMultiplier, levelOverlap) {
1:             @Override
1:             public Integer newItem()
1:             {
1:                 return r.nextInt();
1:             }
1:         }.result;
1:         if (sizeOfL0 > 0 && countOfL0 > 0)
1:             lists.addAll(new NaturalListGenerator<Integer>(countOfL0, sizeOfL0 / countOfL0)
1:             {
1:                 Integer next()
1:                 {
1:                     return r.nextInt();
1:                 }
1:             }.result);
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testRandomStrings()
1:     {
1:         System.out.println("testRandomStrings");
1:         final Random r = new Random();
1:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1: 
1:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public String next()
1:             {
1:                 return "longish_prefix_" + r.nextInt(5 * LIST_LENGTH);
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1:     
1:     @Test
1:     public void testNonOverlapStrings()
1:     {
1:         System.out.println("testNonOverlapStrings");
1:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1: 
1:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 1;
1:             @Override
1:             public String next()
1:             {
1:                 return "longish_prefix_" + next++;
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testCombinationStrings()
1:     {
1:         System.out.println("testCombinationStrings");
1:         final Random r = new Random();
1:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1: 
1:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 1;
1:             public String next()
1:             {
1:                 return "longish_prefix_" + (r.nextBoolean() ? r.nextInt(5 * LIST_LENGTH) : next++);
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testTimeUuids()
1:     {
1:         System.out.println("testTimeUuids");
1:         Reducer<UUID, Counted<UUID>> reducer = new Counter<UUID>();
1: 
1:         List<List<UUID>> lists = new NaturalListGenerator<UUID>(ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public UUID next()
1:             {
1:                 return UUIDGen.getTimeUUID();
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testRandomUuids()
1:     {
1:         System.out.println("testRandomUuids");
1:         Reducer<UUID, Counted<UUID>> reducer = new Counter<UUID>();
1: 
1:         List<List<UUID>> lists = new NaturalListGenerator<UUID>(ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public UUID next()
1:             {
1:                 return UUID.randomUUID();
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testTimeUuidType()
1:     {
1:         System.out.println("testTimeUuidType");
1:         final AbstractType<UUID> type = TimeUUIDType.instance;
1:         Reducer<ByteBuffer, Counted<ByteBuffer>> reducer = new Counter<ByteBuffer>();
1: 
1:         List<List<ByteBuffer>> lists = new SimpleListGenerator<ByteBuffer>(type, ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public ByteBuffer next()
1:             {
1:                 return type.decompose(UUIDGen.getTimeUUID());
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists, type);
1:     }
1: 
1:     @Test
1:     public void testUuidType()
1:     {
1:         System.out.println("testUuidType");
1:         final AbstractType<UUID> type = UUIDType.instance;
1:         Reducer<ByteBuffer, Counted<ByteBuffer>> reducer = new Counter<ByteBuffer>();
1: 
1:         List<List<ByteBuffer>> lists = new SimpleListGenerator<ByteBuffer>(type, ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public ByteBuffer next()
1:             {
1:                 return type.decompose(UUIDGen.getTimeUUID());
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists, type);
1:     }
1: 
1:     
1:     @Test
1:     public void testSets()
1:     {
1:         System.out.println("testSets");
1:         final Random r = new Random();
1: 
1:         Reducer<KeyedSet<Integer, UUID>, KeyedSet<Integer, UUID>> reducer = new Union<Integer, UUID>();
1: 
1:         List<List<KeyedSet<Integer, UUID>>> lists = new NaturalListGenerator<KeyedSet<Integer, UUID>>(ITERATOR_COUNT, LIST_LENGTH) {
1:             @Override
1:             public KeyedSet<Integer, UUID> next()
1:             {
1:                 return new KeyedSet<>(r.nextInt(5 * LIST_LENGTH), UUIDGen.getTimeUUID());
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1:     /* */
1: 
1:     @Test
1:     public void testLimitedOverlapStrings2()
1:     {
1:         System.out.println("testLimitedOverlapStrings2");
1:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1: 
1:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 0;
1:             @Override
1:             public String next()
1:             {
1:                 ++next;
1:                 int list = next / LIST_LENGTH;
1:                 int id = next % LIST_LENGTH;
1:                 return "longish_prefix_" + (id + list * LIST_LENGTH / 2);
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     @Test
1:     public void testLimitedOverlapStrings3()
1:     {
1:         System.out.println("testLimitedOverlapStrings3");
1:         Reducer<String, Counted<String>> reducer = new Counter<String>();
1: 
1:         List<List<String>> lists = new NaturalListGenerator<String>(ITERATOR_COUNT, LIST_LENGTH) {
1:             int next = 0;
1:             @Override
1:             public String next()
1:             {
1:                 ++next;
1:                 int list = next / LIST_LENGTH;
1:                 int id = next % LIST_LENGTH;
1:                 return "longish_prefix_" + (id + list * LIST_LENGTH / 3);
1:             }
1:         }.result;
1:         testMergeIterator(reducer, lists);
1:     }
1: 
1:     private static abstract class ListGenerator<T>
1:     {
1:         abstract boolean hasMoreItems();
1:         abstract boolean hasMoreLists();
1:         abstract T next();
1: 
1:         final Comparator<T> comparator;
1:         final List<List<T>> result = Lists.newArrayList();
1: 
1:         protected ListGenerator(Comparator<T> comparator)
1:         {
1:             this.comparator = comparator;
1:         }
1: 
1:         void build()
1:         {
1:             while (hasMoreLists())
1:             {
1:                 List<T> l = Lists.newArrayList();
1:                 while (hasMoreItems())
1:                     l.add(next());
1:                 Collections.sort(l, comparator);
1:                 result.add(l);
1:             }
1:         }
1:     }
1: 
1:     private static abstract class NaturalListGenerator<T extends Comparable<T>> extends SimpleListGenerator<T>
1:     {
1:         private NaturalListGenerator(int listCount, int perListCount)
1:         {
1:             super(Ordering.natural(), listCount, perListCount);
1:         }
1:     }
1:     private static abstract class SimpleListGenerator<T> extends ListGenerator<T>
1:     {
1:         final int listCount;
1:         final int perListCount;
1: 
1:         int listIdx = 0, itemIdx = 0;
1: 
1:         private SimpleListGenerator(Comparator<T> comparator, int listCount, int perListCount)
1:         {
1:             super(comparator);
1:             this.listCount = listCount;
1:             this.perListCount = perListCount;
1:             build();
1:         }
1: 
1:         public boolean hasMoreItems()
1:         {
1:             return itemIdx++ < perListCount;
1:         }
1: 
1:         public boolean hasMoreLists()
1:         {
1:             itemIdx = 0;
1:             return listIdx++ < listCount;
1:         }
1:     }
1: 
1:     private static abstract class LCSGenerator<T> extends ListGenerator<T>
1:     {
1:         final int levelCount;
1:         final int itemMultiplier;
1:         final float levelOverlap;
1: 
1:         int levelIdx, itemIdx;
1:         int levelItems, overlapItems, runningTotalItems;
1:         final Random random = new Random();
1: 
1:         public LCSGenerator(Comparator<T> comparator, int levelCount, int l1Items, float levelOverlap)
1:         {
1:             super(comparator);
1:             this.levelCount = levelCount;
1:             this.itemMultiplier = l1Items;
1:             this.levelOverlap = levelOverlap;
1:             build();
1:         }
1: 
1:         public boolean hasMoreItems()
1:         {
1:             return itemIdx++ < levelItems;
1:         }
1: 
1:         public boolean hasMoreLists()
1:         {
1:             if (result.size() > 0)
1:                 runningTotalItems += result.get(result.size() - 1).size();
1:             itemIdx = 0;
1:             levelItems = itemMultiplier * (int)Math.pow(10, levelCount - levelIdx);
1:             overlapItems = levelIdx == 0 ? 0 : (int) (levelItems * levelOverlap);
1:             return levelIdx++ < levelCount;
1:         }
1: 
1:         abstract T newItem();
1: 
1:         T next()
1:         {
1:             if (itemIdx < overlapItems)
1:             {
1:                 int item = random.nextInt(runningTotalItems);
1:                 for (List<T> list : result)
1:                 {
1:                     if (item < list.size()) return list.get(item);
1:                     else item -= list.size();
1:                 }
1:             }
1:             return newItem();
1:         }
1:     }
1: 
1:     public <T extends Comparable<T>> void testMergeIterator(Reducer<T, ?> reducer, List<List<T>> lists)
1:     {
1:         testMergeIterator(reducer, lists, Ordering.natural());
1:     }
1:     public <T> void testMergeIterator(Reducer<T, ?> reducer, List<List<T>> lists, Comparator<T> comparator)
1:     {
1:         {
1:             IMergeIterator<T,?> tested = MergeIterator.get(closeableIterators(lists), comparator, reducer);
1:             IMergeIterator<T,?> base = new MergeIteratorPQ<>(closeableIterators(lists), comparator, reducer);
1:             // If test fails, try the version below for improved reporting:
1:             Object[] basearr = Iterators.toArray(base, Object.class);
1:             Assert.assertArrayEquals(basearr, Iterators.toArray(tested, Object.class));
1:             //Assert.assertTrue(Iterators.elementsEqual(base, tested));
1:             if (!BENCHMARK)
1:                 return;
1:         }
1: 
1:         CountingComparator<T> cmp, cmpb;
1:         cmp = new CountingComparator<>(comparator); cmpb = new CountingComparator<>(comparator);
1:         System.out.println();
1:         for (int i=0; i<10; ++i) {
1:             benchmarkIterator(MergeIterator.get(closeableIterators(lists), cmp, reducer), cmp);
1:             benchmarkIterator(new MergeIteratorPQ<>(closeableIterators(lists), cmpb, reducer), cmpb);
1:         }
1:         System.out.format("MI: %.2f\n", cmp.count / (double) cmpb.count);
1:     }
1:     
1:     public <T> void benchmarkIterator(IMergeIterator<T, ?> it, CountingComparator<T> comparator)
1:     {
1:         System.out.format("Testing %30s... ", it.getClass().getSimpleName());
1:         long time = System.currentTimeMillis();
1:         Object value = null;
1:         while (it.hasNext())
1:             value = it.next();
1:         time = System.currentTimeMillis() - time;
1:         String type = "";
1:         if (value instanceof Counted<?>)
1:         {
1:             type = "type " + ((Counted<?>)value).item.getClass().getSimpleName();
1:         }
1:         System.out.format("%15s time %5dms; comparisons: %d\n", type, time, comparator.count);
1:     }
1: 
1:     public <T> List<CloseableIterator<T>> closeableIterators(List<List<T>> iterators)
1:     {
1:         return Lists.transform(iterators, new Function<List<T>, CloseableIterator<T>>() {
1: 
1:             @Override
1:             public CloseableIterator<T> apply(List<T> arg)
1:             {
1:                 return new CLI<T>(arg.iterator());
1:             }
1:         });
1:     }
1: 
1:     static class Counted<T> {
1:         T item;
1:         int count;
1:         
1:         Counted(T item) {
1:             this.item = item;
1:             count = 0;
1:         }
1: 
1:         public boolean equals(Object obj)
1:         {
1:             if (obj == null || !(obj instanceof Counted))
1:                 return false;
1:             Counted<?> c = (Counted<?>) obj;
1:             return Objects.equal(item, c.item) && count == c.count;
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return item.toString() + "x" + count;
1:         }
1:     }
1:     
1:     static class Counter<T> extends Reducer<T, Counted<T>> {
1:         Counted<T> current = null;
1:         boolean read = true;
1: 
1:         @Override
1:         public void reduce(int idx, T next)
1:         {
1:             if (current == null)
1:                 current = new Counted<T>(next);
1:             assert current.item.equals(next);
1:             ++current.count;
1:         }
1: 
1:         @Override
1:         protected void onKeyChange()
1:         {
1:             assert read;
1:             current = null;
1:             read = false;
1:         }
1: 
1:         @Override
1:         protected Counted<T> getReduced()
1:         {
1:             assert current != null;
1:             read = true;
1:             return current;
1:         }
1:     }
1:     
1:     static class KeyedSet<K extends Comparable<? super K>, V> extends Pair<K, Set<V>> implements Comparable<KeyedSet<K, V>>
1:     {
1:         protected KeyedSet(K left, V right)
1:         {
1:             super(left, ImmutableSet.of(right));
1:         }
1:         
1:         protected KeyedSet(K left, Collection<V> right)
1:         {
1:             super(left, Sets.newHashSet(right));
1:         }
1: 
1:         @Override
1:         public int compareTo(KeyedSet<K, V> o)
1:         {
1:             return left.compareTo(o.left);
1:         }
1:     }
1:     
1:     static class Union<K extends Comparable<K>, V> extends Reducer<KeyedSet<K, V>, KeyedSet<K, V>> {
1:         KeyedSet<K, V> current = null;
1:         boolean read = true;
1: 
1:         @Override
1:         public void reduce(int idx, KeyedSet<K, V> next)
1:         {
1:             if (current == null)
1:                 current = new KeyedSet<>(next.left, next.right);
1:             else {
1:                 assert current.left.equals(next.left);
1:                 current.right.addAll(next.right);
1:             }
1:         }
1: 
1:         @Override
1:         protected void onKeyChange()
1:         {
1:             assert read;
1:             current = null;
1:             read = false;
1:         }
1: 
1:         @Override
1:         protected KeyedSet<K, V> getReduced()
1:         {
1:             assert current != null;
1:             read = true;
1:             return current;
1:         }
1:     }
1:     
1:     // closeable list iterator
1:     public static class CLI<E> extends AbstractIterator<E> implements CloseableIterator<E>
1:     {
1:         Iterator<E> iter;
1:         boolean closed = false;
1:         public CLI(Iterator<E> items)
1:         {
1:             this.iter = items;
1:         }
1: 
1:         protected E computeNext()
1:         {
1:             if (!iter.hasNext()) return endOfData();
1:             return iter.next();
1:         }
1: 
1:         public void close()
1:         {
1:             assert !this.closed;
1:             this.closed = true;
1:         }
1:     }
1: 
1:     // Old MergeIterator implementation for comparison.
1:     public class MergeIteratorPQ<In,Out> extends MergeIterator<In,Out> implements IMergeIterator<In, Out>
1:     {
1:         // a queue for return: all candidates must be open and have at least one item
1:         protected final PriorityQueue<CandidatePQ<In>> queue;
1:         // a stack of the last consumed candidates, so that we can lazily call 'advance()'
1:         // TODO: if we had our own PriorityQueue implementation we could stash items
1:         // at the end of its array, so we wouldn't need this storage
1:         protected final ArrayDeque<CandidatePQ<In>> candidates;
1:         public MergeIteratorPQ(List<? extends Iterator<In>> iters, Comparator<In> comp, Reducer<In, Out> reducer)
1:         {
1:             super(iters, reducer);
1:             this.queue = new PriorityQueue<>(Math.max(1, iters.size()));
1:             for (int i = 0; i < iters.size(); i++)
1:             {
1:                 CandidatePQ<In> candidate = new CandidatePQ<>(i, iters.get(i), comp);
1:                 if (!candidate.advance())
1:                     // was empty
1:                     continue;
1:                 this.queue.add(candidate);
1:             }
1:             this.candidates = new ArrayDeque<>(queue.size());
1:         }
1: 
1:         protected final Out computeNext()
1:         {
1:             advance();
1:             return consume();
1:         }
1: 
1:         /** Consume values by sending them to the reducer while they are equal. */
1:         protected final Out consume()
1:         {
1:             CandidatePQ<In> candidate = queue.peek();
1:             if (candidate == null)
1:                 return endOfData();
1:             reducer.onKeyChange();
1:             do
1:             {
1:                 candidate = queue.poll();
1:                 candidates.push(candidate);
1:                 reducer.reduce(candidate.idx, candidate.item);
1:             }
1:             while (queue.peek() != null && queue.peek().compareTo(candidate) == 0);
1:             return reducer.getReduced();
1:         }
1: 
1:         /** Advance and re-enqueue all items we consumed in the last iteration. */
1:         protected final void advance()
1:         {
1:             CandidatePQ<In> candidate;
1:             while ((candidate = candidates.pollFirst()) != null)
1:                 if (candidate.advance())
1:                     queue.add(candidate);
1:         }
1:     }
1: 
1:     // Holds and is comparable by the head item of an iterator it owns
1:     protected static final class CandidatePQ<In> implements Comparable<CandidatePQ<In>>
1:     {
1:         private final Iterator<? extends In> iter;
1:         private final Comparator<? super In> comp;
1:         private final int idx;
1:         private In item;
1:         boolean equalParent;
1: 
1:         public CandidatePQ(int idx, Iterator<? extends In> iter, Comparator<? super In> comp)
1:         {
1:             this.iter = iter;
1:             this.comp = comp;
1:             this.idx = idx;
1:         }
1: 
1:         /** @return true if our iterator had an item, and it is now available */
1:         protected boolean advance()
1:         {
1:             if (!iter.hasNext())
1:                 return false;
1:             item = iter.next();
1:             return true;
1:         }
1: 
1:         public int compareTo(CandidatePQ<In> that)
1:         {
1:             return comp.compare(this.item, that.item);
1:         }
1:     }
1: }
============================================================================