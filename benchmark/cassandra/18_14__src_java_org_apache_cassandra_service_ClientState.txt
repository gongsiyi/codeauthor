1:07cf56f: /*
1:2a2c4ce:  * Licensed to the Apache Software Foundation (ASF) under one
1:2a2c4ce:  * or more contributor license agreements.  See the NOTICE file
1:2a2c4ce:  * distributed with this work for additional information
1:2a2c4ce:  * regarding copyright ownership.  The ASF licenses this file
1:2a2c4ce:  * to you under the Apache License, Version 2.0 (the
1:2a2c4ce:  * "License"); you may not use this file except in compliance
1:2a2c4ce:  * with the License.  You may obtain a copy of the License at
1:45b4fd8:  *
1:2a2c4ce:  *     http://www.apache.org/licenses/LICENSE-2.0
2:2a2c4ce:  *
1:2a2c4ce:  * Unless required by applicable law or agreed to in writing, software
1:2a2c4ce:  * distributed under the License is distributed on an "AS IS" BASIS,
1:2a2c4ce:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2a2c4ce:  * See the License for the specific language governing permissions and
1:2a2c4ce:  * limitations under the License.
1:cec1d51:  */
1:2a2c4ce: package org.apache.cassandra.service;
1:07cdfd0: 
1:814bd32: import java.net.InetSocketAddress;
1:326d545: import java.net.SocketAddress;
1:879b694: import java.util.Arrays;
1:879b694: import java.util.HashSet;
1:879b694: import java.util.Set;
1:85ea373: import java.util.concurrent.atomic.AtomicLong;
1:2fd3268: 
1:485feef: import org.slf4j.Logger;
1:485feef: import org.slf4j.LoggerFactory;
1:655ccc3: 
1:5a3eb1a: import org.apache.cassandra.auth.*;
1:2d991a7: import org.apache.cassandra.config.CFMetaData;
1:2a2c4ce: import org.apache.cassandra.config.DatabaseDescriptor;
1:372a3ad: import org.apache.cassandra.config.Schema;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:485feef: import org.apache.cassandra.cql3.QueryHandler;
1:2621707: import org.apache.cassandra.cql3.QueryProcessor;
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:0e96e58: import org.apache.cassandra.db.SystemKeyspace;
1:bddfa9e: import org.apache.cassandra.exceptions.AuthenticationException;
1:3a2faf9: import org.apache.cassandra.exceptions.InvalidRequestException;
1:3a2faf9: import org.apache.cassandra.exceptions.UnauthorizedException;
1:7d6c876: import org.apache.cassandra.schema.SchemaKeyspace;
1:7171b7a: import org.apache.cassandra.thrift.ThriftValidation;
1:5c94432: import org.apache.cassandra.utils.FBUtilities;
1:f25da97: import org.apache.cassandra.utils.JVMStabilityInspector;
1:2385dc2: import org.apache.cassandra.utils.CassandraVersion;
1:326d545: 
1:326d545: /**
1:45b4fd8:  * State related to a client connection.
1:326d545:  */
1:2a2c4ce: public class ClientState
1:655ccc3: {
1:5a6e2b0:     private static final Logger logger = LoggerFactory.getLogger(ClientState.class);
1:2385dc2:     public static final CassandraVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
1:cb5897f: 
1:326d545:     private static final Set<IResource> READABLE_SYSTEM_RESOURCES = new HashSet<>();
1:326d545:     private static final Set<IResource> PROTECTED_AUTH_RESOURCES = new HashSet<>();
1:879b694:     private static final Set<String> ALTERABLE_SYSTEM_KEYSPACES = new HashSet<>();
1:879b694:     private static final Set<IResource> DROPPABLE_SYSTEM_TABLES = new HashSet<>();
1:5a3eb1a:     static
1:0c0f1ff:     {
1:62db990:         // We want these system cfs to be always readable to authenticated users since many tools rely on them
1:62db990:         // (nodetool, cqlsh, bulkloader, etc.)
1:7d6c876:         for (String cf : Arrays.asList(SystemKeyspace.LOCAL, SystemKeyspace.PEERS))
1:9797511:             READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SYSTEM_KEYSPACE_NAME, cf));
1:cb5897f: 
1:9797511:         SchemaKeyspace.ALL.forEach(table -> READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SCHEMA_KEYSPACE_NAME, table)));
1:7d6c876: 
1:9797511:         // neither clients nor tools need authentication/authorization
1:29239c7:         if (DatabaseDescriptor.isDaemonInitialized())
1:d0f7e9e:         {
1:0c0f1ff:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthenticator().protectedResources());
1:0c0f1ff:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthorizer().protectedResources());
1:0c0f1ff:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getRoleManager().protectedResources());
1:0c0f1ff:         }
1:6d3a3ee: 
1:879b694:         // allow users with sufficient privileges to alter KS level options on AUTH_KS and
1:879b694:         // TRACING_KS, and also to drop legacy tables (users, credentials, permissions) from
1:879b694:         // AUTH_KS
1:9797511:         ALTERABLE_SYSTEM_KEYSPACES.add(SchemaConstants.AUTH_KEYSPACE_NAME);
1:9797511:         ALTERABLE_SYSTEM_KEYSPACES.add(SchemaConstants.TRACE_KEYSPACE_NAME);
1:9797511:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, PasswordAuthenticator.LEGACY_CREDENTIALS_TABLE));
1:9797511:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, CassandraRoleManager.LEGACY_USERS_TABLE));
1:9797511:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, CassandraAuthorizer.USER_PERMISSIONS));
1:6d3a3ee:     }
1:3fdc86c: 
1:2a2c4ce:     // Current user for the session
1:bddfa9e:     private volatile AuthenticatedUser user;
1:326d545:     private volatile String keyspace;
1:07cdfd0: 
1:485feef:     private static final QueryHandler cqlQueryHandler;
1:485feef:     static
1:6d3a3ee:     {
1:485feef:         QueryHandler handler = QueryProcessor.instance;
1:485feef:         String customHandlerClass = System.getProperty("cassandra.custom_query_handler_class");
1:485feef:         if (customHandlerClass != null)
1:3fdc86c:         {
1:655ccc3:             try
1:655ccc3:             {
1:814bd32:                 handler = FBUtilities.construct(customHandlerClass, "QueryHandler");
1:485feef:                 logger.info("Using {} as query handler for native protocol queries (as requested with -Dcassandra.custom_query_handler_class)", customHandlerClass);
1:3fdc86c:             }
1:485feef:             catch (Exception e)
1:655ccc3:             {
1:f25da97:                 JVMStabilityInspector.inspectThrowable(e);
1:485feef:                 logger.info("Cannot use class {} as query handler ({}), ignoring by defaulting on normal query handling", customHandlerClass, e.getMessage());
1:655ccc3:             }
1:655ccc3:         }
1:485feef:         cqlQueryHandler = handler;
1:655ccc3:     }
1:07cdfd0: 
1:326d545:     // isInternal is used to mark ClientState as used by some internal component
1:326d545:     // that should have an ability to modify system keyspace.
1:19c6cc1:     public final boolean isInternal;
1:2fd3268: 
1:326d545:     // The remote address of the client - null for internal clients.
1:814bd32:     private final InetSocketAddress remoteAddress;
1:85ea373: 
1:720870b:     // The biggest timestamp that was returned by getTimestamp/assigned to a query. This is global to ensure that the
1:720870b:     // timestamp assigned are strictly monotonic on a node, which is likely what user expect intuitively (more likely,
1:720870b:     // most new user will intuitively expect timestamp to be strictly monotonic cluster-wise, but while that last part
1:720870b:     // is unrealistic expectation, doing it node-wise is easy).
1:fe65707:     private static final AtomicLong lastTimestampMicros = new AtomicLong(0);
1:2fd3268: 
1:85ea373:     /**
1:326d545:      * Construct a new, empty ClientState for internal calls.
1:3fdc86c:      */
1:326d545:     private ClientState()
1:655ccc3:     {
1:326d545:         this.isInternal = true;
1:326d545:         this.remoteAddress = null;
1:655ccc3:     }
1:655ccc3: 
1:814bd32:     protected ClientState(InetSocketAddress remoteAddress)
1:326d545:     {
1:326d545:         this.isInternal = false;
1:326d545:         this.remoteAddress = remoteAddress;
1:326d545:         if (!DatabaseDescriptor.getAuthenticator().requireAuthentication())
1:326d545:             this.user = AuthenticatedUser.ANONYMOUS_USER;
1:326d545:     }
1:655ccc3: 
1:3fdc86c:     /**
1:326d545:      * @return a ClientState object for internal C* calls (not limited by any kind of auth).
1:7316f18:      */
1:326d545:     public static ClientState forInternalCalls()
1:d0f7e9e:     {
1:326d545:         return new ClientState();
1:326d545:     }
1:655ccc3: 
1:326d545:     /**
1:326d545:      * @return a ClientState object for external clients (thrift/native protocol users).
1:326d545:      */
1:326d545:     public static ClientState forExternalCalls(SocketAddress remoteAddress)
1:326d545:     {
1:814bd32:         return new ClientState((InetSocketAddress)remoteAddress);
1:326d545:     }
1:655ccc3: 
1:7316f18:     /**
1:85ea373:      * This clock guarantees that updates for the same ClientState will be ordered
1:85ea373:      * in the sequence seen, even if multiple updates happen in the same millisecond.
1:85ea373:      */
1:85ea373:     public long getTimestamp()
1:85ea373:     {
1:85ea373:         while (true)
1:85ea373:         {
1:85ea373:             long current = System.currentTimeMillis() * 1000;
1:85ea373:             long last = lastTimestampMicros.get();
1:fe65707:             long tstamp = last >= current ? last + 1 : current;
1:fe65707:             if (lastTimestampMicros.compareAndSet(last, tstamp))
1:85ea373:                 return tstamp;
1:85ea373:         }
1:85ea373:     }
1:85ea373: 
1:85ea373:     /**
1:720870b:      * Returns a timestamp suitable for paxos given the timestamp of the last known commit (or in progress update).
1:720870b:      * <p>
1:720870b:      * Paxos ensures that the timestamp it uses for commits respects the serial order of those commits. It does so
1:720870b:      * by having each replica reject any proposal whose timestamp is not strictly greater than the last proposal it
1:720870b:      * accepted. So in practice, which timestamp we use for a given proposal doesn't affect correctness but it does
1:720870b:      * affect the chance of making progress (if we pick a timestamp lower than what has been proposed before, our
1:720870b:      * new proposal will just get rejected).
1:720870b:      * <p>
1:720870b:      * As during the prepared phase replica send us the last propose they accepted, a first option would be to take
1:720870b:      * the maximum of those last accepted proposal timestamp plus 1 (and use a default value, say 0, if it's the
1:720870b:      * first known proposal for the partition). This would most work (giving commits the timestamp 0, 1, 2, ...
1:720870b:      * in the order they are commited) up to 2 important caveats:
1:720870b:      *   1) it would give a very poor experience when Paxos and non-Paxos updates are mixed in the same partition,
1:720870b:      *      since paxos operations wouldn't be using microseconds timestamps. And while you shouldn't theoretically
1:720870b:      *      mix the 2 kind of operations, this would still be pretty unintuitive. And what if you started writing
1:720870b:      *      normal updates and realize later you should switch to Paxos to enforce a property you want?
1:720870b:      *   2) this wouldn't actually be safe due to the expiration set on the Paxos state table.
1:720870b:      * <p>
1:720870b:      * So instead, we initially chose to use the current time in microseconds as for normal update. Which works in
1:720870b:      * general but mean that clock skew creates unavailability periods for Paxos updates (either a node has his clock
1:720870b:      * in the past and he may no be able to get commit accepted until its clock catch up, or a node has his clock in
1:720870b:      * the future and then once one of its commit his accepted, other nodes ones won't be until they catch up). This
1:720870b:      * is ok for small clock skew (few ms) but can be pretty bad for large one.
1:720870b:      * <p>
1:720870b:      * Hence our current solution: we mix both approaches. That is, we compare the timestamp of the last known
1:720870b:      * accepted proposal and the local time. If the local time is greater, we use it, thus keeping paxos timestamps
1:720870b:      * locked to the current time in general (making mixing Paxos and non-Paxos more friendly, and behaving correctly
1:720870b:      * when the paxos state expire (as long as your maximum clock skew is lower than the Paxos state expiration
1:720870b:      * time)). Otherwise (the local time is lower than the last proposal, meaning that this last proposal was done
1:720870b:      * with a clock in the future compared to the local one), we use the last proposal timestamp plus 1, ensuring
1:720870b:      * progress.
1:720870b:      *
1:720870b:      * @param minTimestampToUse the max timestamp of the last proposal accepted by replica having responded
1:720870b:      * to the prepare phase of the paxos round this is for. In practice, that's the minimum timestamp this method
1:720870b:      * may return.
1:720870b:      * @return a timestamp suitable for a Paxos proposal (using the reasoning described above). Note that
1:720870b:      * contrarily to the {@link #getTimestamp()} method, the return value is not guaranteed to be unique (nor
1:720870b:      * monotonic) across calls since it can return it's argument (so if the same argument is passed multiple times,
1:720870b:      * it may be returned multiple times). Note that we still ensure Paxos "ballot" are unique (for different
1:720870b:      * proposal) by (securely) randomizing the non-timestamp part of the UUID.
1:85ea373:      */
1:720870b:     public long getTimestampForPaxos(long minTimestampToUse)
1:85ea373:     {
1:85ea373:         while (true)
1:85ea373:         {
1:fe65707:             long current = Math.max(System.currentTimeMillis() * 1000, minTimestampToUse);
1:85ea373:             long last = lastTimestampMicros.get();
1:85ea373:             long tstamp = last >= current ? last + 1 : current;
1:720870b:             // Note that if we ended up picking minTimestampMicrosToUse (it was "in the future"), we don't
1:720870b:             // want to change the local clock, otherwise a single node in the future could corrupt the clock
1:720870b:             // of all nodes and for all inserts (since non-paxos inserts also use lastTimestampMicros).
1:720870b:             // See CASSANDRA-11991
1:720870b:             if (tstamp == minTimestampToUse || lastTimestampMicros.compareAndSet(last, tstamp))
1:fe65707:                 return tstamp;
1:85ea373:         }
1:85ea373:     }
1:85ea373: 
1:485feef:     public static QueryHandler getCQLQueryHandler()
1:326d545:     {
1:485feef:         return cqlQueryHandler;
1:d0f7e9e:     }
1:655ccc3: 
1:814bd32:     public InetSocketAddress getRemoteAddress()
1:d0f7e9e:     {
1:326d545:         return remoteAddress;
1:d0f7e9e:     }
1:879b694: 
1:25faad4:     public String getRawKeyspace()
1:d0f7e9e:     {
1:5d79a29:         return keyspace;
1:d0f7e9e:     }
1:326d545: 
1:718954f:     public String getKeyspace() throws InvalidRequestException
1:5a3eb1a:     {
1:718954f:         if (keyspace == null)
1:d96485f:             throw new InvalidRequestException("No keyspace has been specified. USE a keyspace, or explicitly specify keyspace.tablename");
1:25faad4:         return keyspace;
1:5a3eb1a:     }
1:326d545: 
1:372a3ad:     public void setKeyspace(String ks) throws InvalidRequestException
1:5a3eb1a:     {
1:698fc44:         // Skip keyspace validation for non-authenticated users. Apparently, some client libraries
1:698fc44:         // call set_keyspace() before calling login(), and we have to handle that.
1:698fc44:         if (user != null && Schema.instance.getKSMetaData(ks) == null)
1:372a3ad:             throw new InvalidRequestException("Keyspace '" + ks + "' does not exist");
1:5d79a29:         keyspace = ks;
1:5a3eb1a:     }
1:326d545: 
1:c293406:     /**
1:401b46b:      * Attempts to login the given user.
1:c293406:      */
1:401b46b:     public void login(AuthenticatedUser user) throws AuthenticationException
3:5c94432:     {
1:879b694:         // Login privilege is not inherited via granted roles, so just
1:879b694:         // verify that the role with the credentials that were actually
1:879b694:         // supplied has it
1:217721a:         if (user.isAnonymous() || DatabaseDescriptor.getRoleManager().canLogin(user.getPrimaryRole()))
1:879b694:             this.user = user;
1:655ccc3:         else
1:879b694:             throw new AuthenticationException(String.format("%s is not permitted to log in", user.getName()));
1:655ccc3:     }
1:655ccc3: 
1:5b0ec50:     public void hasAllKeyspacesAccess(Permission perm) throws UnauthorizedException
1:655ccc3:     {
1:326d545:         if (isInternal)
1:85ea373:             return;
1:5a3eb1a:         validateLogin();
1:5a3eb1a:         ensureHasPermission(perm, DataResource.root());
1:655ccc3:     }
1:07cdfd0: 
1:bcec7a5:     public void hasKeyspaceAccess(String keyspace, Permission perm) throws UnauthorizedException, InvalidRequestException
1:655ccc3:     {
1:5a3eb1a:         hasAccess(keyspace, perm, DataResource.keyspace(keyspace));
1:655ccc3:     }
1:07cdfd0: 
1:5a3eb1a:     public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permission perm)
1:5a3eb1a:     throws UnauthorizedException, InvalidRequestException
1:5a3eb1a:     {
1:7171b7a:         ThriftValidation.validateColumnFamily(keyspace, columnFamily);
1:879b694:         hasAccess(keyspace, perm, DataResource.table(keyspace, columnFamily));
1:5a3eb1a:     }
1:2fd3268: 
1:2d991a7:     public void hasColumnFamilyAccess(CFMetaData cfm, Permission perm)
1:2d991a7:     throws UnauthorizedException, InvalidRequestException
1:2d991a7:     {
1:2d991a7:         hasAccess(cfm.ksName, perm, cfm.resource);
1:2d991a7:     }
1:2d991a7: 
1:5a3eb1a:     private void hasAccess(String keyspace, Permission perm, DataResource resource)
1:5a3eb1a:     throws UnauthorizedException, InvalidRequestException
1:5a3eb1a:     {
1:3fdc86c:         validateKeyspace(keyspace);
1:326d545:         if (isInternal)
1:5a3eb1a:             return;
1:5a3eb1a:         validateLogin();
1:2659640:         preventSystemKSSchemaModification(keyspace, resource, perm);
1:2c3f9ba:         if ((perm == Permission.SELECT) && READABLE_SYSTEM_RESOURCES.contains(resource))
1:5a3eb1a:             return;
1:5a3eb1a:         if (PROTECTED_AUTH_RESOURCES.contains(resource))
1:2c3f9ba:             if ((perm == Permission.CREATE) || (perm == Permission.ALTER) || (perm == Permission.DROP))
1:0b83682:                 throw new UnauthorizedException(String.format("%s schema is protected", resource));
1:5a3eb1a:         ensureHasPermission(perm, resource);
1:5a3eb1a:     }
1:2fd3268: 
1:5a3eb1a:     public void ensureHasPermission(Permission perm, IResource resource) throws UnauthorizedException
1:5a3eb1a:     {
1:f54eab7:         if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())
1:cb5897f:             return;
1:655ccc3: 
1:cb5897f:         // Access to built in functions is unrestricted
1:cb5897f:         if(resource instanceof FunctionResource && resource.hasParent())
1:9797511:             if (((FunctionResource)resource).getKeyspace().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME))
1:cb5897f:                 return;
1:655ccc3: 
1:cb5897f:         checkPermissionOnResourceChain(perm, resource);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     // Convenience method called from checkAccess method of CQLStatement
1:cb5897f:     // Also avoids needlessly creating lots of FunctionResource objects
1:cb5897f:     public void ensureHasPermission(Permission permission, Function function)
1:cb5897f:     {
1:cb5897f:         // Save creating a FunctionResource is we don't need to
1:f54eab7:         if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())
1:cb5897f:             return;
1:cb5897f: 
1:cb5897f:         // built in functions are always available to all
1:cb5897f:         if (function.isNative())
1:cb5897f:             return;
1:cb5897f: 
1:cb5897f:         checkPermissionOnResourceChain(permission, FunctionResource.function(function.name().keyspace,
1:cb5897f:                                                                              function.name().name,
1:cb5897f:                                                                              function.argTypes()));
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void checkPermissionOnResourceChain(Permission perm, IResource resource)
1:cb5897f:     {
1:5a3eb1a:         for (IResource r : Resources.chain(resource))
1:5a3eb1a:             if (authorize(r).contains(perm))
1:5a3eb1a:                 return;
1:326d545: 
1:5a3eb1a:         throw new UnauthorizedException(String.format("User %s has no %s permission on %s or any of its parents",
1:bddfa9e:                                                       user.getName(),
1:3a2faf9:                                                       perm,
1:5a3eb1a:                                                       resource));
1:5a3eb1a:     }
1:d0f7e9e: 
1:2659640:     private void preventSystemKSSchemaModification(String keyspace, DataResource resource, Permission perm) throws UnauthorizedException
1:5a3eb1a:     {
1:2659640:         // we only care about schema modification.
1:2c3f9ba:         if (!((perm == Permission.ALTER) || (perm == Permission.DROP) || (perm == Permission.CREATE)))
1:2659640:             return;
1:2659640: 
1:88944ff:         // prevent system keyspace modification
1:9797511:         if (SchemaConstants.isSystemKeyspace(keyspace))
1:5a3eb1a:             throw new UnauthorizedException(keyspace + " keyspace is not user-modifiable.");
1:2659640: 
1:879b694:         // allow users with sufficient privileges to alter KS level options on AUTH_KS and
1:879b694:         // TRACING_KS, and also to drop legacy tables (users, credentials, permissions) from
1:879b694:         // AUTH_KS
1:879b694:         if (ALTERABLE_SYSTEM_KEYSPACES.contains(resource.getKeyspace().toLowerCase())
1:879b694:            && ((perm == Permission.ALTER && !resource.isKeyspaceLevel())
1:879b694:                || (perm == Permission.DROP && !DROPPABLE_SYSTEM_TABLES.contains(resource))))
1:879b694:         {
1:2659640:             throw new UnauthorizedException(String.format("Cannot %s %s", perm, resource));
1:879b694:         }
1:5a3eb1a:     }
1:d0f7e9e: 
1:bddfa9e:     public void validateLogin() throws UnauthorizedException
1:5c94432:     {
1:cec1d51:         if (user == null)
1:bddfa9e:             throw new UnauthorizedException("You have not logged in");
1:bddfa9e:     }
1:07cdfd0: 
1:bddfa9e:     public void ensureNotAnonymous() throws UnauthorizedException
1:bddfa9e:     {
1:bddfa9e:         validateLogin();
1:bddfa9e:         if (user.isAnonymous())
1:0b83682:             throw new UnauthorizedException("You have to be logged in and not anonymous to perform this request");
3:5c94432:     }
1:2fd3268: 
1:edc7531:     public void ensureIsSuper(String message) throws UnauthorizedException
1:edc7531:     {
1:edc7531:         if (DatabaseDescriptor.getAuthenticator().requireAuthentication() && (user == null || !user.isSuper()))
1:edc7531:             throw new UnauthorizedException(message);
1:edc7531:     }
1:edc7531: 
1:3fdc86c:     private static void validateKeyspace(String keyspace) throws InvalidRequestException
1:5c94432:     {
1:c293406:         if (keyspace == null)
1:2a2c4ce:             throw new InvalidRequestException("You have not set a keyspace for this session");
1:5c94432:     }
1:d0f7e9e: 
1:bddfa9e:     public AuthenticatedUser getUser()
1:bddfa9e:     {
1:bddfa9e:         return user;
1:bddfa9e:     }
1:d0f7e9e: 
1:2385dc2:     public static CassandraVersion[] getCQLSupportedVersion()
1:5c94432:     {
1:2385dc2:         return new CassandraVersion[]{ QueryProcessor.CQL_VERSION };
1:5c94432:     }
1:d0f7e9e: 
1:bddfa9e:     private Set<Permission> authorize(IResource resource)
1:d0f7e9e:     {
1:b32ce68:         return user.getPermissions(resource);
1:d0f7e9e:     }
1:5c94432: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:29239c7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (DatabaseDescriptor.isDaemonInitialized())
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SYSTEM_KEYSPACE_NAME, cf));
1:         SchemaKeyspace.ALL.forEach(table -> READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SCHEMA_KEYSPACE_NAME, table)));
1:         // neither clients nor tools need authentication/authorization
0:         if (!Config.isClientOrToolsMode())
/////////////////////////////////////////////////////////////////////////
1:         ALTERABLE_SYSTEM_KEYSPACES.add(SchemaConstants.AUTH_KEYSPACE_NAME);
1:         ALTERABLE_SYSTEM_KEYSPACES.add(SchemaConstants.TRACE_KEYSPACE_NAME);
1:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, PasswordAuthenticator.LEGACY_CREDENTIALS_TABLE));
1:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, CassandraRoleManager.LEGACY_USERS_TABLE));
1:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(SchemaConstants.AUTH_KEYSPACE_NAME, CassandraAuthorizer.USER_PERMISSIONS));
/////////////////////////////////////////////////////////////////////////
1:             if (((FunctionResource)resource).getKeyspace().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME))
/////////////////////////////////////////////////////////////////////////
1:         if (SchemaConstants.isSystemKeyspace(keyspace))
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:484e1c4
commit:969f797
commit:b3dd05e
commit:720870b
/////////////////////////////////////////////////////////////////////////
1:     // The biggest timestamp that was returned by getTimestamp/assigned to a query. This is global to ensure that the
1:     // timestamp assigned are strictly monotonic on a node, which is likely what user expect intuitively (more likely,
1:     // most new user will intuitively expect timestamp to be strictly monotonic cluster-wise, but while that last part
1:     // is unrealistic expectation, doing it node-wise is easy).
/////////////////////////////////////////////////////////////////////////
1:      * Returns a timestamp suitable for paxos given the timestamp of the last known commit (or in progress update).
1:      * <p>
1:      * Paxos ensures that the timestamp it uses for commits respects the serial order of those commits. It does so
1:      * by having each replica reject any proposal whose timestamp is not strictly greater than the last proposal it
1:      * accepted. So in practice, which timestamp we use for a given proposal doesn't affect correctness but it does
1:      * affect the chance of making progress (if we pick a timestamp lower than what has been proposed before, our
1:      * new proposal will just get rejected).
1:      * <p>
1:      * As during the prepared phase replica send us the last propose they accepted, a first option would be to take
1:      * the maximum of those last accepted proposal timestamp plus 1 (and use a default value, say 0, if it's the
1:      * first known proposal for the partition). This would most work (giving commits the timestamp 0, 1, 2, ...
1:      * in the order they are commited) up to 2 important caveats:
1:      *   1) it would give a very poor experience when Paxos and non-Paxos updates are mixed in the same partition,
1:      *      since paxos operations wouldn't be using microseconds timestamps. And while you shouldn't theoretically
1:      *      mix the 2 kind of operations, this would still be pretty unintuitive. And what if you started writing
1:      *      normal updates and realize later you should switch to Paxos to enforce a property you want?
1:      *   2) this wouldn't actually be safe due to the expiration set on the Paxos state table.
1:      * <p>
1:      * So instead, we initially chose to use the current time in microseconds as for normal update. Which works in
1:      * general but mean that clock skew creates unavailability periods for Paxos updates (either a node has his clock
1:      * in the past and he may no be able to get commit accepted until its clock catch up, or a node has his clock in
1:      * the future and then once one of its commit his accepted, other nodes ones won't be until they catch up). This
1:      * is ok for small clock skew (few ms) but can be pretty bad for large one.
1:      * <p>
1:      * Hence our current solution: we mix both approaches. That is, we compare the timestamp of the last known
1:      * accepted proposal and the local time. If the local time is greater, we use it, thus keeping paxos timestamps
1:      * locked to the current time in general (making mixing Paxos and non-Paxos more friendly, and behaving correctly
1:      * when the paxos state expire (as long as your maximum clock skew is lower than the Paxos state expiration
1:      * time)). Otherwise (the local time is lower than the last proposal, meaning that this last proposal was done
1:      * with a clock in the future compared to the local one), we use the last proposal timestamp plus 1, ensuring
1:      * progress.
1:      *
1:      * @param minTimestampToUse the max timestamp of the last proposal accepted by replica having responded
1:      * to the prepare phase of the paxos round this is for. In practice, that's the minimum timestamp this method
1:      * may return.
1:      * @return a timestamp suitable for a Paxos proposal (using the reasoning described above). Note that
1:      * contrarily to the {@link #getTimestamp()} method, the return value is not guaranteed to be unique (nor
1:      * monotonic) across calls since it can return it's argument (so if the same argument is passed multiple times,
1:      * it may be returned multiple times). Note that we still ensure Paxos "ballot" are unique (for different
1:      * proposal) by (securely) randomizing the non-timestamp part of the UUID.
1:     public long getTimestampForPaxos(long minTimestampToUse)
1:             // Note that if we ended up picking minTimestampMicrosToUse (it was "in the future"), we don't
1:             // want to change the local clock, otherwise a single node in the future could corrupt the clock
1:             // of all nodes and for all inserts (since non-paxos inserts also use lastTimestampMicros).
1:             // See CASSANDRA-11991
1:             if (tstamp == minTimestampToUse || lastTimestampMicros.compareAndSet(last, tstamp))
commit:2d991a7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
1:     public void hasColumnFamilyAccess(CFMetaData cfm, Permission perm)
1:     throws UnauthorizedException, InvalidRequestException
1:     {
1:         hasAccess(cfm.ksName, perm, cfm.resource);
1:     }
1: 
commit:75e85b9
commit:fe65707
/////////////////////////////////////////////////////////////////////////
0:     // The biggest timestamp that was returned by getTimestamp/assigned to a query. This is global to the VM
0:     // for the sake of paxos (see #9649).
1:     private static final AtomicLong lastTimestampMicros = new AtomicLong(0);
/////////////////////////////////////////////////////////////////////////
0:      * This is the same than {@link #getTimestamp()} but this guarantees that the returned timestamp
0:      * will not be smaller than the provided {@code minTimestampToUse}.
0:     public long getTimestamp(long minTimestampToUse)
1:             long current = Math.max(System.currentTimeMillis() * 1000, minTimestampToUse);
1:             long tstamp = last >= current ? last + 1 : current;
1:             if (lastTimestampMicros.compareAndSet(last, tstamp))
1:                 return tstamp;
commit:d5b2fa2
commit:85ea373
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0:     // The biggest timestamp that was returned by getTimestamp/assigned to a query
0:     private final AtomicLong lastTimestampMicros = new AtomicLong(0);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This clock guarantees that updates for the same ClientState will be ordered
1:      * in the sequence seen, even if multiple updates happen in the same millisecond.
1:      */
1:     public long getTimestamp()
1:     {
1:         while (true)
1:         {
1:             long current = System.currentTimeMillis() * 1000;
1:             long last = lastTimestampMicros.get();
1:             long tstamp = last >= current ? last + 1 : current;
0:             if (lastTimestampMicros.compareAndSet(last, tstamp))
1:                 return tstamp;
1:         }
1:     }
1: 
1:     /**
0:      * Can be use when a timestamp has been assigned by a query, but that timestamp is
0:      * not directly one returned by getTimestamp() (see SP.beginAndRepairPaxos()).
0:      * This ensure following calls to getTimestamp() will return a timestamp strictly
0:      * greated than the one provided to this method.
1:      */
0:     public void updateLastTimestamp(long tstampMicros)
1:     {
1:         while (true)
1:         {
1:             long last = lastTimestampMicros.get();
0:             if (tstampMicros <= last || lastTimestampMicros.compareAndSet(last, tstampMicros))
1:                 return;
1:         }
1:     }
1: 
commit:a0817d5
commit:5284e12
commit:7171b7a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.thrift.ThriftValidation;
/////////////////////////////////////////////////////////////////////////
1:         ThriftValidation.validateColumnFamily(keyspace, columnFamily);
commit:401b46b
/////////////////////////////////////////////////////////////////////////
1:      * Attempts to login the given user.
1:     public void login(AuthenticatedUser user) throws AuthenticationException
commit:85443ec
/////////////////////////////////////////////////////////////////////////
0:     private SemanticVersion cqlVersion;
commit:45b4fd8
/////////////////////////////////////////////////////////////////////////
1:  * State related to a client connection.
1:  *
/////////////////////////////////////////////////////////////////////////
0:         this.user = DatabaseDescriptor.getAuthenticator().defaultUser();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ccca5f1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2a0389e
/////////////////////////////////////////////////////////////////////////
0:         // We've made some backward incompatible changes between CQL3 beta1 and the final.
0:         // It's ok because it was a beta, but it still mean we don't support 3.0.0-beta1 so reject it.
0:         SemanticVersion cql3Beta = new SemanticVersion("3.0.0-beta1");
0:         if (version.equals(cql3Beta))
0:             throw new InvalidRequestException(String.format("There has been a few syntax breaking changes between 3.0.0-beta1 and 3.0.0 "
0:                                                            + "(mainly the syntax for options of CREATE KEYSPACE and CREATE TABLE). 3.0.0-beta1 "
0:                                                            + " is not supported; please upgrade to 3.0.0"));
commit:500a529
/////////////////////////////////////////////////////////////////////////
0:     public static final SemanticVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.InvalidRequestException;
1: import org.apache.cassandra.exceptions.UnauthorizedException;
/////////////////////////////////////////////////////////////////////////
0:     public void hasKeyspaceSchemaAccess(Permission perm) throws UnauthorizedException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:     public void hasColumnFamilySchemaAccess(Permission perm) throws UnauthorizedException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:     public void hasColumnFamilySchemaAccess(String keyspace, Permission perm) throws UnauthorizedException, InvalidRequestException
0:             throw new UnauthorizedException("system keyspace is not user-modifiable");
/////////////////////////////////////////////////////////////////////////
0:     public void hasColumnFamilyAccess(String columnFamily, Permission perm) throws UnauthorizedException, InvalidRequestException
0:     public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permission perm) throws UnauthorizedException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:     private static void hasAccess(AuthenticatedUser user, Set<Permission> perms, Permission perm, List<Object> resource) throws UnauthorizedException
0:         throw new UnauthorizedException(String.format("%s does not have permission %s for %s",
0:                                                       user,
1:                                                       perm,
0:                                                        Resources.toString(resource)));
commit:6d3a3ee
/////////////////////////////////////////////////////////////////////////
0:     public boolean isLogged()
1:     {
0:         return user != null;
1:     }
1: 
commit:dc920ab
commit:3fdc86c
/////////////////////////////////////////////////////////////////////////
0:         hasColumnFamilySchemaAccess(keyspace, perm);
1:     }
1: 
1:     /**
0:      * Confirms that the client thread has the given Permission for the ColumnFamily list of
0:      * the provided keyspace.
1:      */
0:     public void hasColumnFamilySchemaAccess(String keyspace, Permission perm) throws InvalidRequestException
1:     {
1:         validateKeyspace(keyspace);
/////////////////////////////////////////////////////////////////////////
0:         validateKeyspace(keyspace);
/////////////////////////////////////////////////////////////////////////
1:     private static void validateKeyspace(String keyspace) throws InvalidRequestException
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(ClientState.class);
/////////////////////////////////////////////////////////////////////////
0:     private final Map<Integer, CQLStatement> prepared = new LinkedHashMap<Integer, CQLStatement>(16, 0.75f, true) {
0:     private final Map<Integer, org.apache.cassandra.cql3.CQLStatement> cql3Prepared = new LinkedHashMap<Integer, org.apache.cassandra.cql3.CQLStatement>(16, 0.75f, true) {
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Sets;
0: import org.apache.commons.lang.StringUtils;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.SemanticVersion;
/////////////////////////////////////////////////////////////////////////
0:     public static final SemanticVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
0:     private SemanticVersion cqlVersion = DEFAULT_CQL_VERSION;
/////////////////////////////////////////////////////////////////////////
0:     private Map<Integer, org.apache.cassandra.cql3.CQLStatement> cql3Prepared = new LinkedHashMap<Integer, org.apache.cassandra.cql3.CQLStatement>(16, 0.75f, true) {
0:         protected boolean removeEldestEntry(Map.Entry<Integer, org.apache.cassandra.cql3.CQLStatement> eldest) {
0:             return size() > MAX_CACHE_PREPARED;
1:         }
0:     };
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public Map<Integer, org.apache.cassandra.cql3.CQLStatement> getCQL3Prepared()
1:     {
0:         return cql3Prepared;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         cql3Prepared.clear();
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void setCQLVersion(String str) throws InvalidRequestException
1:     {
0:         SemanticVersion version;
1:         try
1:         {
0:             version = new SemanticVersion(str);
1:         }
0:         catch (IllegalArgumentException e)
1:         {
0:             throw new InvalidRequestException(e.getMessage());
1:         }
1: 
0:         SemanticVersion cql = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
0:         SemanticVersion cql3 = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
1: 
0:         if (version.isSupportedBy(cql))
0:             cqlVersion = cql;
0:         else if (version.isSupportedBy(cql3))
0:             cqlVersion = cql3;
1:         else
0:             throw new InvalidRequestException(String.format("Provided version %s is not supported by this server (supported: %s)",
0:                                                             version,
0:                                                             StringUtils.join(getCQLSupportedVersion(), ", ")));
1:     }
1: 
0:     public SemanticVersion getCQLVersion()
1:     {
0:         return cqlVersion;
1:     }
1: 
0:     public static SemanticVersion[] getCQLSupportedVersion()
1:     {
0:         SemanticVersion cql = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
0:         SemanticVersion cql3 = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
1: 
0:         return new SemanticVersion[]{ cql, cql3 };
1:     }
author:Mike Adamson
-------------------------------------------------------------------------------
commit:f54eab7
/////////////////////////////////////////////////////////////////////////
1:         if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())
/////////////////////////////////////////////////////////////////////////
1:         if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())
commit:465d520
/////////////////////////////////////////////////////////////////////////
0:                                        SystemKeyspace.SCHEMA_COLUMNS_CF,
0:                                        SystemKeyspace.SCHEMA_USER_TYPES_CF};
commit:3d2da79
/////////////////////////////////////////////////////////////////////////
0:                                        SystemKeyspace.SCHEMA_COLUMNS_CF,
0:                                        SystemKeyspace.SCHEMA_USER_TYPES_CF};
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:3818d30
commit:0c0f1ff
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Config;
/////////////////////////////////////////////////////////////////////////
0:         if (!Config.isClientMode())
1:         {
1:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthenticator().protectedResources());
1:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthorizer().protectedResources());
1:             PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getRoleManager().protectedResources());
1:         }
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.functions.Function;
/////////////////////////////////////////////////////////////////////////
0:         if (DatabaseDescriptor.getAuthorizer() instanceof AllowAllAuthorizer)
1:             return;
1: 
1:         // Access to built in functions is unrestricted
1:         if(resource instanceof FunctionResource && resource.hasParent())
0:             if (((FunctionResource)resource).getKeyspace().equals(SystemKeyspace.NAME))
1:                 return;
1: 
1:         checkPermissionOnResourceChain(perm, resource);
1:     }
1: 
1:     // Convenience method called from checkAccess method of CQLStatement
1:     // Also avoids needlessly creating lots of FunctionResource objects
1:     public void ensureHasPermission(Permission permission, Function function)
1:     {
1:         // Save creating a FunctionResource is we don't need to
0:         if (DatabaseDescriptor.getAuthorizer() instanceof AllowAllAuthorizer)
1:             return;
1: 
1:         // built in functions are always available to all
1:         if (function.isNative())
1:             return;
1: 
1:         checkPermissionOnResourceChain(permission, FunctionResource.function(function.name().keyspace,
1:                                                                              function.name().name,
1:                                                                              function.argTypes()));
1:     }
1: 
1:     private void checkPermissionOnResourceChain(Permission perm, IResource resource)
1:     {
commit:b32ce68
/////////////////////////////////////////////////////////////////////////
1:         return user.getPermissions(resource);
commit:217721a
/////////////////////////////////////////////////////////////////////////
1:         if (user.isAnonymous() || DatabaseDescriptor.getRoleManager().canLogin(user.getPrimaryRole()))
commit:879b694
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.LegacySchemaTables;
0: import org.apache.cassandra.tracing.TraceKeyspace;
/////////////////////////////////////////////////////////////////////////
1:     private static final Set<String> ALTERABLE_SYSTEM_KEYSPACES = new HashSet<>();
1:     private static final Set<IResource> DROPPABLE_SYSTEM_TABLES = new HashSet<>();
0:             READABLE_SYSTEM_RESOURCES.add(DataResource.table(SystemKeyspace.NAME, cf));
0:         PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getRoleManager().protectedResources());
1: 
1:         // allow users with sufficient privileges to alter KS level options on AUTH_KS and
1:         // TRACING_KS, and also to drop legacy tables (users, credentials, permissions) from
1:         // AUTH_KS
0:         ALTERABLE_SYSTEM_KEYSPACES.add(AuthKeyspace.NAME);
0:         ALTERABLE_SYSTEM_KEYSPACES.add(TraceKeyspace.NAME);
0:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(AuthKeyspace.NAME, PasswordAuthenticator.LEGACY_CREDENTIALS_TABLE));
0:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(AuthKeyspace.NAME, CassandraRoleManager.LEGACY_USERS_TABLE));
0:         DROPPABLE_SYSTEM_TABLES.add(DataResource.table(AuthKeyspace.NAME, CassandraAuthorizer.USER_PERMISSIONS));
/////////////////////////////////////////////////////////////////////////
1:         // Login privilege is not inherited via granted roles, so just
1:         // verify that the role with the credentials that were actually
1:         // supplied has it
0:         if (user.isAnonymous() || DatabaseDescriptor.getRoleManager().canLogin(user.getName()))
1:             this.user = user;
0:         else
1:             throw new AuthenticationException(String.format("%s is not permitted to log in", user.getName()));
/////////////////////////////////////////////////////////////////////////
1:         hasAccess(keyspace, perm, DataResource.table(keyspace, columnFamily));
/////////////////////////////////////////////////////////////////////////
1:         // allow users with sufficient privileges to alter KS level options on AUTH_KS and
1:         // TRACING_KS, and also to drop legacy tables (users, credentials, permissions) from
1:         // AUTH_KS
1:         if (ALTERABLE_SYSTEM_KEYSPACES.contains(resource.getKeyspace().toLowerCase())
1:            && ((perm == Permission.ALTER && !resource.isKeyspaceLevel())
1:                || (perm == Permission.DROP && !DROPPABLE_SYSTEM_TABLES.contains(resource))))
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         return AuthenticatedUser.getPermissions(user, resource);
commit:e750ab2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return Auth.getPermissions(user, resource);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:7d6c876
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.SchemaKeyspace;
/////////////////////////////////////////////////////////////////////////
1:         for (String cf : Arrays.asList(SystemKeyspace.LOCAL, SystemKeyspace.PEERS))
0:         SchemaKeyspace.ALL.forEach(table -> READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaKeyspace.NAME, table)));
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (Schema.isSystemKeyspace(keyspace))
commit:2fc3a89
commit:8c5a959
commit:3e9d345
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.LegacySchemaTables;
/////////////////////////////////////////////////////////////////////////
0:         for (String cf : Iterables.concat(Arrays.asList(SystemKeyspace.LOCAL, SystemKeyspace.PEERS), LegacySchemaTables.ALL))
commit:611d1ba
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.tracing.TraceKeyspace;
/////////////////////////////////////////////////////////////////////////
0:         for (String cf : Iterables.concat(Arrays.asList(SystemKeyspace.LOCAL_TABLE, SystemKeyspace.PEERS_TABLE), SystemKeyspace.ALL_SCHEMA_TABLES))
0:             READABLE_SYSTEM_RESOURCES.add(DataResource.columnFamily(SystemKeyspace.NAME, cf));
/////////////////////////////////////////////////////////////////////////
0:         if (SystemKeyspace.NAME.equalsIgnoreCase(keyspace))
0:         Set<String> allowAlter = Sets.newHashSet(Auth.AUTH_KS, TraceKeyspace.NAME);
commit:6748083
commit:dfe1f23
commit:62db990
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Iterables;
/////////////////////////////////////////////////////////////////////////
1:         // We want these system cfs to be always readable to authenticated users since many tools rely on them
1:         // (nodetool, cqlsh, bulkloader, etc.)
0:         for (String cf : Iterables.concat(Arrays.asList(SystemKeyspace.LOCAL_CF, SystemKeyspace.PEERS_CF), SystemKeyspace.allSchemaCfs))
commit:9c9fa14
commit:2621707
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.QueryProcessor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new SemanticVersion[]{ QueryProcessor.CQL_VERSION };
commit:326d545
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketAddress;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final Set<IResource> READABLE_SYSTEM_RESOURCES = new HashSet<>();
1:     private static final Set<IResource> PROTECTED_AUTH_RESOURCES = new HashSet<>();
/////////////////////////////////////////////////////////////////////////
1:     private volatile String keyspace;
1:     // isInternal is used to mark ClientState as used by some internal component
1:     // that should have an ability to modify system keyspace.
0:     private final boolean isInternal;
1:     // The remote address of the client - null for internal clients.
0:     private final SocketAddress remoteAddress;
1: 
1:     /**
1:      * Construct a new, empty ClientState for internal calls.
1:      */
1:     private ClientState()
1:         this.isInternal = true;
1:         this.remoteAddress = null;
1:     }
1: 
0:     protected ClientState(SocketAddress remoteAddress)
1:     {
1:         this.isInternal = false;
1:         this.remoteAddress = remoteAddress;
1:         if (!DatabaseDescriptor.getAuthenticator().requireAuthentication())
1:             this.user = AuthenticatedUser.ANONYMOUS_USER;
1:      * @return a ClientState object for internal C* calls (not limited by any kind of auth).
1:     public static ClientState forInternalCalls()
1:         return new ClientState();
1:     }
1: 
1:     /**
1:      * @return a ClientState object for external clients (thrift/native protocol users).
1:      */
1:     public static ClientState forExternalCalls(SocketAddress remoteAddress)
1:     {
0:         return new ClientState(remoteAddress);
1:     }
1: 
0:     public SocketAddress getRemoteAddress()
1:     {
1:         return remoteAddress;
/////////////////////////////////////////////////////////////////////////
1:         if (isInternal)
/////////////////////////////////////////////////////////////////////////
1:         if (isInternal)
/////////////////////////////////////////////////////////////////////////
1: 
commit:edc7531
/////////////////////////////////////////////////////////////////////////
1:     public void ensureIsSuper(String message) throws UnauthorizedException
1:     {
1:         if (DatabaseDescriptor.getAuthenticator().requireAuthentication() && (user == null || !user.isSuper()))
1:             throw new UnauthorizedException(message);
1:     }
1: 
commit:bffd9ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang3.StringUtils;
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Keyspace;
1: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
0:         String[] cfs =  new String[] { SystemKeyspace.LOCAL_CF,
0:                                        SystemKeyspace.PEERS_CF,
0:                                        SystemKeyspace.SCHEMA_KEYSPACES_CF,
0:                                        SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF,
0:                                        SystemKeyspace.SCHEMA_COLUMNS_CF };
0:             READABLE_SYSTEM_RESOURCES.add(DataResource.columnFamily(Keyspace.SYSTEM_KS, cf));
commit:698fc44
/////////////////////////////////////////////////////////////////////////
1:         // Skip keyspace validation for non-authenticated users. Apparently, some client libraries
1:         // call set_keyspace() before calling login(), and we have to handle that.
1:         if (user != null && Schema.instance.getKSMetaData(ks) == null)
commit:0b83682
/////////////////////////////////////////////////////////////////////////
0:             if (perm.equals(Permission.CREATE) || perm.equals(Permission.ALTER) || perm.equals(Permission.DROP))
1:                 throw new UnauthorizedException(String.format("%s schema is protected", resource));
/////////////////////////////////////////////////////////////////////////
1:             throw new UnauthorizedException("You have to be logged in and not anonymous to perform this request");
commit:2659640
/////////////////////////////////////////////////////////////////////////
1:         preventSystemKSSchemaModification(keyspace, resource, perm);
/////////////////////////////////////////////////////////////////////////
1:     private void preventSystemKSSchemaModification(String keyspace, DataResource resource, Permission perm) throws UnauthorizedException
1:         // we only care about schema modification.
0:         if (!(perm.equals(Permission.ALTER) || perm.equals(Permission.DROP) || perm.equals(Permission.CREATE)))
1:             return;
1: 
0:         if (Schema.systemKeyspaceNames.contains(keyspace.toLowerCase()))
1: 
0:         // we want to allow altering AUTH_KS itself.
0:         if (keyspace.equals(Auth.AUTH_KS) && !(resource.isKeyspaceLevel() && perm.equals(Permission.ALTER)))
1:             throw new UnauthorizedException(String.format("Cannot %s %s", perm, resource));
commit:d0f7e9e
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutionException;
0: import java.util.concurrent.TimeUnit;
0: import com.google.common.cache.CacheBuilder;
0: import com.google.common.cache.CacheLoader;
0: import com.google.common.cache.LoadingCache;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.Pair;
/////////////////////////////////////////////////////////////////////////
0:     // User-level permissions cache.
0:     private static final LoadingCache<Pair<AuthenticatedUser, IResource>, Set<Permission>> permissionsCache = initPermissionsCache();
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static LoadingCache<Pair<AuthenticatedUser, IResource>, Set<Permission>> initPermissionsCache()
1:     {
0:         if (DatabaseDescriptor.getAuthorizer() instanceof AllowAllAuthorizer)
0:             return null;
1: 
0:         int validityPeriod = DatabaseDescriptor.getPermissionsValidity();
0:         if (validityPeriod <= 0)
0:             return null;
1: 
0:         return CacheBuilder.newBuilder().expireAfterWrite(validityPeriod, TimeUnit.MILLISECONDS)
0:                                         .build(new CacheLoader<Pair<AuthenticatedUser, IResource>, Set<Permission>>()
1:                                         {
0:                                             public Set<Permission> load(Pair<AuthenticatedUser, IResource> userResource)
1:                                             {
0:                                                 return DatabaseDescriptor.getAuthorizer().authorize(userResource.left,
0:                                                                                                     userResource.right);
1:                                             }
0:                                         });
1:     }
1: 
0:         // AllowAllAuthorizer or manually disabled caching.
0:         if (permissionsCache == null)
0:             return DatabaseDescriptor.getAuthorizer().authorize(user, resource);
1: 
0:         try
1:         {
0:             return permissionsCache.get(Pair.create(user, resource));
1:         }
0:         catch (ExecutionException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
commit:b8d8802
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSSchemaModification(keyspace, perm);
/////////////////////////////////////////////////////////////////////////
0:     private void preventSystemKSSchemaModification(String keyspace, Permission perm) throws UnauthorizedException
0:         if (Schema.systemKeyspaceNames.contains(keyspace.toLowerCase()) && !(perm.equals(Permission.SELECT) || perm.equals(Permission.MODIFY)))
commit:bddfa9e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.AuthenticationException;
/////////////////////////////////////////////////////////////////////////
0:         PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthenticator().protectedResources());
1:     private volatile AuthenticatedUser user;
/////////////////////////////////////////////////////////////////////////
0:         if (!DatabaseDescriptor.getAuthenticator().requireAuthentication())
0:             this.user = AuthenticatedUser.ANONYMOUS_USER;
/////////////////////////////////////////////////////////////////////////
0:     public void login(Map<String, String> credentials) throws AuthenticationException
0:         AuthenticatedUser user = DatabaseDescriptor.getAuthenticator().authenticate(credentials);
0: 
0:         if (!user.isAnonymous() && !Auth.isExistingUser(user.getName()))
0:            throw new AuthenticationException(String.format("User %s doesn't exist - create it with CREATE USER query first",
0:                                                            user.getName()));
0: 
0:         this.user = user;
/////////////////////////////////////////////////////////////////////////
1:                                                       user.getName(),
/////////////////////////////////////////////////////////////////////////
1:     public void validateLogin() throws UnauthorizedException
1:             throw new UnauthorizedException("You have not logged in");
1:     }
0: 
1:     public void ensureNotAnonymous() throws UnauthorizedException
1:     {
1:         validateLogin();
1:         if (user.isAnonymous())
0:             throw new UnauthorizedException("You have to be logged in to perform this query");
/////////////////////////////////////////////////////////////////////////
1:     public AuthenticatedUser getUser()
1:     {
1:         return user;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     private Set<Permission> authorize(IResource resource)
commit:5a3eb1a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.auth.*;
0: import org.apache.cassandra.db.SystemTable;
/////////////////////////////////////////////////////////////////////////
0:     private static final Set<IResource> READABLE_SYSTEM_RESOURCES = new HashSet<IResource>(5);
0:     private static final Set<IResource> PROTECTED_AUTH_RESOURCES = new HashSet<IResource>();
0: 
1:     static
1:     {
0:         // We want these system cfs to be always readable since many tools rely on them (nodetool, cqlsh, bulkloader, etc.)
0:         String[] cfs =  new String[] { SystemTable.LOCAL_CF,
0:                                        SystemTable.PEERS_CF,
0:                                        SystemTable.SCHEMA_KEYSPACES_CF,
0:                                        SystemTable.SCHEMA_COLUMNFAMILIES_CF,
0:                                        SystemTable.SCHEMA_COLUMNS_CF };
0:         for (String cf : cfs)
0:             READABLE_SYSTEM_RESOURCES.add(DataResource.columnFamily(Table.SYSTEM_KS, cf));
0: 
0:         PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthorizer().protectedResources());
0:         // TODO: the same with IAuthenticator once it's done.
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public void hasAllKeyspacesAccess(Permission perm) throws UnauthorizedException, InvalidRequestException
0:         if (internalCall)
1:             return;
1:         validateLogin();
1:         ensureHasPermission(perm, DataResource.root());
1:         hasAccess(keyspace, perm, DataResource.keyspace(keyspace));
1:     public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permission perm)
1:     throws UnauthorizedException, InvalidRequestException
0:         hasAccess(keyspace, perm, DataResource.columnFamily(keyspace, columnFamily));
1:     }
0: 
1:     private void hasAccess(String keyspace, Permission perm, DataResource resource)
1:     throws UnauthorizedException, InvalidRequestException
1:     {
0:         if (internalCall)
1:         validateLogin();
0:         preventSystemKSSModification(keyspace, perm);
0:         if (perm.equals(Permission.SELECT) && READABLE_SYSTEM_RESOURCES.contains(resource))
1:             return;
1:         if (PROTECTED_AUTH_RESOURCES.contains(resource))
0:             throw new UnauthorizedException(String.format("Resource %s is inaccessible", resource));
1:         ensureHasPermission(perm, resource);
1:     }
1:     public void ensureHasPermission(Permission perm, IResource resource) throws UnauthorizedException
1:     {
1:         for (IResource r : Resources.chain(resource))
1:         {
1:             if (authorize(r).contains(perm))
1:                 return;
1:         }
1:         throw new UnauthorizedException(String.format("User %s has no %s permission on %s or any of its parents",
0:                                                       user.username,
0:                                                       perm,
1:                                                       resource));
1:     }
0:     private void preventSystemKSSModification(String keyspace, Permission perm) throws UnauthorizedException
1:     {
0:         if (Schema.systemKeyspaceNames.contains(keyspace.toLowerCase()) && !perm.equals(Permission.SELECT))
1:             throw new UnauthorizedException(keyspace + " keyspace is not user-modifiable.");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public Set<Permission> authorize(IResource resource)
0:         return DatabaseDescriptor.getAuthorizer().authorize(user, resource);
0: 
1:     }
0:     public void grantPermission(Set<Permission> permissions, IResource resource, String to)
0:     throws UnauthorizedException, InvalidRequestException
1:     {
0:         DatabaseDescriptor.getAuthorizer().grant(user, permissions, resource, to);
0:     public void revokePermission(Set<Permission> permissions, IResource resource, String from)
0:     throws UnauthorizedException, InvalidRequestException
0:         DatabaseDescriptor.getAuthorizer().revoke(user, permissions, resource, from);
0:     public Set<PermissionDetails> listPermissions(Set<Permission> permissions, IResource resource, String of)
0:     throws UnauthorizedException, InvalidRequestException
0:         return DatabaseDescriptor.getAuthorizer().listPermissions(user, permissions, resource, of);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:2385dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.CassandraVersion;
/////////////////////////////////////////////////////////////////////////
1:     public static final CassandraVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
/////////////////////////////////////////////////////////////////////////
1:     public static CassandraVersion[] getCQLSupportedVersion()
1:         return new CassandraVersion[]{ QueryProcessor.CQL_VERSION };
commit:f1bd50c
commit:ce357d9
commit:d96485f
/////////////////////////////////////////////////////////////////////////
1:             throw new InvalidRequestException("No keyspace has been specified. USE a keyspace, or explicitly specify keyspace.tablename");
commit:88944ff
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Sets;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.tracing.Tracing;
/////////////////////////////////////////////////////////////////////////
1:         // prevent system keyspace modification
0:         if (Keyspace.SYSTEM_KS.equalsIgnoreCase(keyspace))
0:         // we want to allow altering AUTH_KS and TRACING_KS.
0:         Set<String> allowAlter = Sets.newHashSet(Auth.AUTH_KS, Tracing.TRACE_KS);
0:         if (allowAlter.contains(keyspace.toLowerCase()) && !(resource.isKeyspaceLevel() && perm.equals(Permission.ALTER)))
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:814bd32
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetSocketAddress;
/////////////////////////////////////////////////////////////////////////
1:                 handler = FBUtilities.construct(customHandlerClass, "QueryHandler");
/////////////////////////////////////////////////////////////////////////
1:     private final InetSocketAddress remoteAddress;
/////////////////////////////////////////////////////////////////////////
1:     protected ClientState(InetSocketAddress remoteAddress)
/////////////////////////////////////////////////////////////////////////
1:         return new ClientState((InetSocketAddress)remoteAddress);
/////////////////////////////////////////////////////////////////////////
1:     public InetSocketAddress getRemoteAddress()
author:Dave Brosius
-------------------------------------------------------------------------------
commit:2c3f9ba
/////////////////////////////////////////////////////////////////////////
1:         if ((perm == Permission.SELECT) && READABLE_SYSTEM_RESOURCES.contains(resource))
1:             if ((perm == Permission.CREATE) || (perm == Permission.ALTER) || (perm == Permission.DROP))
/////////////////////////////////////////////////////////////////////////
1:         if (!((perm == Permission.ALTER) || (perm == Permission.DROP) || (perm == Permission.CREATE)))
/////////////////////////////////////////////////////////////////////////
0:         if (allowAlter.contains(keyspace.toLowerCase()) && !(resource.isKeyspaceLevel() && (perm == Permission.ALTER)))
commit:1def02f
/////////////////////////////////////////////////////////////////////////
commit:5b0ec50
/////////////////////////////////////////////////////////////////////////
1:     public void hasAllKeyspacesAccess(Permission perm) throws UnauthorizedException
commit:52ecf41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.user = DatabaseDescriptor.getAuthenticator().authenticate(credentials);
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:0705e8a
commit:f25da97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.JVMStabilityInspector;
/////////////////////////////////////////////////////////////////////////
1:                 JVMStabilityInspector.inspectThrowable(e);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:381ff18
commit:ace937e
commit:549f035
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (Auth.permissionsCache == null)
0:             return Auth.permissionsCache.get(Pair.create(user, resource));
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:f19b4cb
/////////////////////////////////////////////////////////////////////////
0:     private final boolean isInternal;
author:Robbie Strickland
-------------------------------------------------------------------------------
commit:19c6cc1
/////////////////////////////////////////////////////////////////////////
1:     public final boolean isInternal;
author:Jake Luciani
-------------------------------------------------------------------------------
commit:a22dd29
commit:42b91d4
/////////////////////////////////////////////////////////////////////////
0:     public final boolean isInternal;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:3e91cb6
commit:b59ae73
/////////////////////////////////////////////////////////////////////////
0:             throw new InvalidRequestException("No keyspace has been specified. USE a keyspace, or explicity specify keyspace.tablename");
commit:f32110c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm.equals(Permission.WRITE))
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // check if the user has the perm on the keyspace (which means same permission on the contained cfs).
0:         if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(perm))
/////////////////////////////////////////////////////////////////////////
0:         if (perms.contains(perm))
0:             return;
/////////////////////////////////////////////////////////////////////////
commit:e8438b8
/////////////////////////////////////////////////////////////////////////
0:      * Construct a new, empty ClientState
0: 
0:         user = DatabaseDescriptor.getAuthenticator().defaultUser();
0:         resourceClear();
0:         prepared.clear();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9a0d9e5
commit:5b151f3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.auth.AuthenticatedUser;
0: import org.apache.cassandra.auth.Permission;
0: import org.apache.cassandra.auth.PermissionDenied;
0: import org.apache.cassandra.auth.Resources;
0: import org.apache.cassandra.cql3.CFName;
0: import org.apache.cassandra.thrift.CqlResult;
/////////////////////////////////////////////////////////////////////////
0:         cqlVersion = DEFAULT_CQL_VERSION;
commit:5c94432
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FBUtilities;
0: import static org.apache.cassandra.tracing.Tracing.instance;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private UUID preparedTracingSession;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public boolean traceNextQuery()
1:     {
0:         if (preparedTracingSession != null)
1:         {
0:             return true;
1:         }
0: 
0:         double tracingProbability = StorageService.instance.getTracingProbability();
0:         return tracingProbability != 0 && FBUtilities.threadLocalRandom().nextDouble() < tracingProbability;
1:     }
0: 
0:     public void prepareTracingSession(UUID sessionId)
1:     {
0:         this.preparedTracingSession = sessionId;
1:     }
0: 
0:     public void createSession()
1:     {
0:         if (this.preparedTracingSession == null)
1:         {
0:             instance().newSession();
1:         }
0:         else
1:         {
0:             UUID session = this.preparedTracingSession;
0:             this.preparedTracingSession = null;
0:             instance().newSession(session);
1:         }
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         preparedTracingSession = null;
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_KS) && perm == Permission.WRITE)
commit:671a0c9
/////////////////////////////////////////////////////////////////////////
commit:372a3ad
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
1:     public void setKeyspace(String ks) throws InvalidRequestException
0:         if (Schema.instance.getKSMetaData(ks) == null)
1:             throw new InvalidRequestException("Keyspace '" + ks + "' does not exist");
commit:f6edaa8
/////////////////////////////////////////////////////////////////////////
0:         // hardcode disallowing messing with system keyspace
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
0:             throw new InvalidRequestException("system keyspace is not user-modifiable");
0: 
commit:3416110
/////////////////////////////////////////////////////////////////////////
0:         // hardcode disallowing messing with system keyspace
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
0:             throw new InvalidRequestException("system keyspace is not user-modifiable");
0: 
commit:7316f18
/////////////////////////////////////////////////////////////////////////
0:     private long clock;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
0:      * This clock guarantees that updates from a given client will be ordered in the sequence seen,
0:      * even if multiple updates happen in the same millisecond.  This can be useful when a client
0:      * wants to perform multiple updates to a single column.
1:      */
0:     public long getTimestamp()
0:     {
0:         long current = System.currentTimeMillis() * 1000;
0:         clock = clock >= current ? clock + 1 : current;
0:         return clock;
0:     }
commit:e7dc05c
commit:b111610
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
commit:93d3a22
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public String getSchedulingValue()
0:         String schedulingValue = "default";
0:         switch(DatabaseDescriptor.getRequestSchedulerId())
0:         {
0:             case keyspace:
0:                 schedulingValue = keyspace.get();
0:                 break;
0:         }
0:         return schedulingValue;
author:beobal
-------------------------------------------------------------------------------
commit:485feef
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.apache.cassandra.cql3.QueryHandler;
0: import org.apache.cassandra.cql3.QueryProcessor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(ClientState.class);
/////////////////////////////////////////////////////////////////////////
1:     private static final QueryHandler cqlQueryHandler;
1:     static
0:     {
1:         QueryHandler handler = QueryProcessor.instance;
1:         String customHandlerClass = System.getProperty("cassandra.custom_query_handler_class");
1:         if (customHandlerClass != null)
0:         {
0:             try
0:             {
0:                 handler = (QueryHandler)FBUtilities.construct(customHandlerClass, "QueryHandler");
1:                 logger.info("Using {} as query handler for native protocol queries (as requested with -Dcassandra.custom_query_handler_class)", customHandlerClass);
0:             }
1:             catch (Exception e)
0:             {
1:                 logger.info("Cannot use class {} as query handler ({}), ignoring by defaulting on normal query handling", customHandlerClass, e.getMessage());
0:             }
0:         }
1:         cqlQueryHandler = handler;
0:     }
/////////////////////////////////////////////////////////////////////////
1:     public static QueryHandler getCQLQueryHandler()
0:     {
1:         return cqlQueryHandler;
0:     }
0: 
author:Eric Evans
-------------------------------------------------------------------------------
commit:487c916
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSSchemaModification(keyspace, perm);
/////////////////////////////////////////////////////////////////////////
0:     private void preventSystemKSSchemaModification(String keyspace, Permission perm) throws InvalidRequestException
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && !Permission.ALLOWED_SYSTEM_ACTIONS.contains(perm))
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSSchemaModification(keyspace, perm);
commit:e63a1ae
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSSchemaModification(keyspace, perm);
/////////////////////////////////////////////////////////////////////////
0:     private void preventSystemKSSchemaModification(String keyspace, Permission perm) throws InvalidRequestException
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_KS) && !Permission.ALLOWED_SYSTEM_ACTIONS.contains(perm))
/////////////////////////////////////////////////////////////////////////
0:             preventSystemKSSchemaModification(keyspace, perm);
commit:16da34e
/////////////////////////////////////////////////////////////////////////
0:     private static final int MAX_CACHE_PREPARED = 10000;    // Enough to keep buggy clients from OOM'ing us
/////////////////////////////////////////////////////////////////////////
0:     private Map<Integer, CQLStatement> prepared = new LinkedHashMap<Integer, CQLStatement>(16, 0.75f, true) {
commit:ef2c94a
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashMap;
/////////////////////////////////////////////////////////////////////////
0:     private static final int MAX_CACHE_PREPARED = 50;   // Ridiculously large, right?
/////////////////////////////////////////////////////////////////////////
0:     // An LRU map of prepared statements
0:     private Map<Integer, CQLStatement> prepared = new HashMap<Integer, CQLStatement>() {
0:         protected boolean removeEldestEntry(Map.Entry<Integer, CQLStatement> eldest) {
0:             return size() > MAX_CACHE_PREPARED;
0:         }
0:     };
commit:9bec1e4
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql.CQLStatement;
/////////////////////////////////////////////////////////////////////////
0:     // a map of prepared statements index by an integer
0:     private Map<Integer,CQLStatement> prepared = new HashMap<Integer,CQLStatement>();
0: 
/////////////////////////////////////////////////////////////////////////
0:     public Map<Integer, CQLStatement> getPrepared()
0:     {
0:         return prepared;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         prepared.clear();
commit:718954f
/////////////////////////////////////////////////////////////////////////
1:     public String getKeyspace() throws InvalidRequestException
1:         if (keyspace == null)
0:             throw new InvalidRequestException("no keyspace has been specified");
commit:f177a43
/////////////////////////////////////////////////////////////////////////
0:     // Reusable array for authorization
0:     private final List<Object> resource = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
0:     private void resourceClear()
0:     {
0:         resource.clear();
0:         resource.add(Resources.ROOT);
0:         resource.add(Resources.KEYSPACES);
0:     }
0: 
0:         resourceClear();
/////////////////////////////////////////////////////////////////////////
0:         resourceClear();
/////////////////////////////////////////////////////////////////////////
0:         resourceClear();
0:         resource.add(keyspace);
/////////////////////////////////////////////////////////////////////////
0:         resourceClear();
0:         resource.add(keyspace);
0:         resource.add(columnFamily);
commit:c293406
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         validateLogin();
0:         
0:     
0:      * Confirms that the client thread has the given Permission for the ColumnFamily list of
0:      * the current keyspace.
0:     public void hasColumnFamilyListAccess(Permission perm) throws InvalidRequestException
0:     {
0:         validateLogin();
0:         validateKeyspace();
0:         
0:         List<Object> resource = Arrays.<Object>asList(Resources.ROOT, Resources.KEYSPACES, keyspace);
0:         Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
0:         
0:         hasAccess(user, perms, perm, resource);
0:     }
0:     
1:     /**
0:      * Confirms that the client thread has the given Permission in the context of the given
0:      * ColumnFamily and the current keyspace.
1:      */
0:     public void hasColumnFamilyAccess(String columnFamily, Permission perm) throws InvalidRequestException
0:     {
0:         validateLogin();
0:         validateKeyspace();
0:         
0:         List<Object> resource = Arrays.<Object>asList(Resources.ROOT, Resources.KEYSPACES, keyspace, columnFamily);
0:         Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
0:         
0:         hasAccess(user, perms, perm, resource);
0:     }
0: 
0:     private void validateLogin() throws InvalidRequestException
0:     }
0:     
0:     private void validateKeyspace() throws InvalidRequestException
0:     {
1:         if (keyspace == null)
commit:cec1d51
/////////////////////////////////////////////////////////////////////////
0:      * Confirms that the client thread has the given Permission for the Keyspace list.
1:      */
0:     public void hasKeyspaceListAccess(Permission perm) throws InvalidRequestException
0:     {
1:         if (user == null)
0:             throw new InvalidRequestException("You have not logged in");
0:         List<Object> resource = Arrays.<Object>asList(Resources.ROOT, Resources.KEYSPACES);
0:         Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
0: 
0:         hasAccess(user, perms, perm, resource);
0:     }
0: 
0:     /**
/////////////////////////////////////////////////////////////////////////
0: 
0:         hasAccess(user, keyspaceAccess, perm, resource);
0:     }
0: 
0:     private static void hasAccess(AuthenticatedUser user, Set<Permission> perms, Permission perm, List<Object> resource) throws InvalidRequestException
0:     {
0:         if (perms.contains(perm))
0:             return;
0:         throw new InvalidRequestException(String.format("%s does not have permission %s for %s",
0:                                                         user,
0:                                                         perm,
0:                                                         Resources.toString(resource)));
commit:d4f24ac
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
0: import org.apache.cassandra.auth.Resources;
/////////////////////////////////////////////////////////////////////////
0:     private List<Object> resource = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
0:         {
0:             resource.clear();
0:             resource.add(Resources.ROOT);
0:             resource.add(Resources.KEYSPACES);
0:             resource.add(keyspace);
0:             keyspaceAccess = DatabaseDescriptor.getAuthority().authorize(user, resource);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         resource.clear();
commit:5d79a29
/////////////////////////////////////////////////////////////////////////
0:     private AuthenticatedUser user;
0:     private String keyspace;
0:     private Set<Permission> keyspaceAccess;
0:     /**
0:      * Construct a new, empty ClientState: can be reused after logout() or reset().
0:      */
0:     public ClientState()
0:     {
0:         reset();
0:     }
0:         if (user == null || keyspace == null)
0:             keyspaceAccess = null;
0:             keyspaceAccess = DatabaseDescriptor.getAuthority().authorize(user, keyspace);
1:         return keyspace;
1:         keyspace = ks;
0:             case keyspace: return keyspace;
0:         return "default";
/////////////////////////////////////////////////////////////////////////
0:         this.user = user;
0:             logger.debug("logged out: {}", user);
0:         reset();
0:     }
0: 
0:     public void reset()
0:     {
0:         user = DatabaseDescriptor.getAuthenticator().defaultUser();
0:         keyspace = null;
0:         keyspaceAccess = null;
/////////////////////////////////////////////////////////////////////////
0:         if (user == null)
0:         if (keyspaceAccess == null)
0:         if (!keyspaceAccess.contains(perm))
0:             throw new InvalidRequestException(String.format("You (%s) do not have permission %s for %s", user, perm, keyspace));
commit:94c45e7
/////////////////////////////////////////////////////////////////////////
0:     public void login(Map<? extends CharSequence,? extends CharSequence> credentials) throws AuthenticationException
commit:799ca24
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import org.apache.cassandra.auth.Permission;
/////////////////////////////////////////////////////////////////////////
0:     // Keyspace and keyspace Permissions associated with the session
0:     private final ThreadLocal<Set<Permission>> keyspaceAccess = new ThreadLocal<Set<Permission>>();
/////////////////////////////////////////////////////////////////////////
0:      * Confirms that the client thread has the given Permission in the context of the current Keyspace.
0:     public void hasKeyspaceAccess(Permission perm) throws InvalidRequestException
0:         if (!keyspaceAccess.get().contains(perm))
0:             throw new InvalidRequestException(String.format("You (%s) do not have permission %s for %s", user, perm, keyspace.get()));
commit:2a2c4ce
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.cassandra.service;
0: 
0: import java.util.Map;
0: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.cassandra.auth.AuthenticatedUser;
0: import org.apache.cassandra.config.Config.RequestSchedulerId;
1: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.thrift.AccessLevel;
0: import org.apache.cassandra.thrift.AuthenticationException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: 
0: /**
0:  * A container for per-client, thread-local state that Avro/Thrift threads must hold.
0:  * TODO: Kill thrift exceptions
0:  */
1: public class ClientState
0: {
0:     private static Logger logger = LoggerFactory.getLogger(ClientState.class);
0:     
0:     // true if the keyspace should be used as the scheduling id
0:     private final boolean SCHEDULE_ON_KEYSPACE = DatabaseDescriptor.getRequestSchedulerId().equals(RequestSchedulerId.keyspace);
0: 
1:     // Current user for the session
0:     private final ThreadLocal<AuthenticatedUser> user = new ThreadLocal<AuthenticatedUser>()
0:     {
0:         @Override
0:         public AuthenticatedUser initialValue()
0:         {
0:             return DatabaseDescriptor.getAuthenticator().defaultUser();
0:         }
0:     };
0: 
0:     // Keyspace and keyspace AccessLevels associated with the session
0:     private final ThreadLocal<String> keyspace = new ThreadLocal<String>();
0:     private final ThreadLocal<AccessLevel> keyspaceAccess = new ThreadLocal<AccessLevel>();
0: 
0:     /**
0:      * Called when the keyspace or user have changed.
0:      */
0:     private void updateKeyspaceAccess()
0:     {
0:         if (user.get() == null || keyspace.get() == null)
0:             // user is not logged in or keyspace is not set
0:             keyspaceAccess.set(null);
0:         else
0:             // authorize the user for the current keyspace
0:             keyspaceAccess.set(DatabaseDescriptor.getAuthority().authorize(user.get(), keyspace.get()));
0:     }
0: 
0:     public String getKeyspace()
0:     {
0:         return keyspace.get();
0:     }
0: 
0:     public void setKeyspace(String ks)
0:     {
0:         keyspace.set(ks);
0:         updateKeyspaceAccess();
0:     }
0: 
0:     public String getSchedulingId()
0:     {
0:         if (SCHEDULE_ON_KEYSPACE)
0:             return keyspace.get();
0:         return "default";
0:     }
0: 
0:     /**
0:      * Attempts to login this client with the given credentials map.
0:      */
0:     public void login(Map<String,String> credentials) throws AuthenticationException
0:     {
0:         AuthenticatedUser user = DatabaseDescriptor.getAuthenticator().authenticate(credentials);
0:         if (logger.isDebugEnabled())
0:             logger.debug("logged in: {}", user);
0:         this.user.set(user);
0:         updateKeyspaceAccess();
0:     }
0: 
0:     public void logout()
0:     {
0:         if (logger.isDebugEnabled())
0:             logger.debug("logged out: {}", user.get());
0:         user.remove();
0:         keyspace.remove();
0:         keyspaceAccess.remove();
0:     }
0: 
0:     /**
0:      * Confirms that the client thread has the given AccessLevel in the context of the current Keyspace.
0:      */
0:     public void hasKeyspaceAccess(AccessLevel level) throws InvalidRequestException
0:     {
0:         if (user.get() == null)
0:             throw new InvalidRequestException("You have not logged in");
0:         if (keyspaceAccess.get() == null)
1:             throw new InvalidRequestException("You have not set a keyspace for this session");
0:         if (keyspaceAccess.get().ordinal() < level.ordinal())
0:             throw new InvalidRequestException(String.format("Your user (%s) does not have permission to perform %s operations", user, level));
0:     }
0: }
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:98eb543
/////////////////////////////////////////////////////////////////////////
0:     // internalCall is used to mark ClientState as used by some internal component
0:     // that should have an ability to modify system keyspace
0:     private final boolean internalCall;
0: 
0:     public ClientState()
0:     {
0:         this(false);
0:     }
0: 
0:     public ClientState(boolean internalCall)
0:         this.internalCall = internalCall;
/////////////////////////////////////////////////////////////////////////
0:         if (!internalCall)
0:             preventSystemKSModification(keyspace, perm);
commit:59a905c
commit:117d91a
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSModification(keyspace, perm);
/////////////////////////////////////////////////////////////////////////
0:     private void preventSystemKSModification(String keyspace, Permission perm) throws InvalidRequestException
0:     {
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm != Permission.SELECT && perm != Permission.DESCRIBE)
0:             throw new InvalidRequestException("system keyspace is not user-modifiable.");
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         preventSystemKSModification(keyspace, perm);
0: 
commit:c4692a1
commit:e172a9b
/////////////////////////////////////////////////////////////////////////
0:         // check if keyspace access is set to Permission.FULL_ACCESS
0:         if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(Permission.FULL_ACCESS))
commit:bcec7a5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.auth.*;
0: import org.apache.cassandra.cql3.CFName;
0: import org.apache.cassandra.thrift.CqlResult;
0: import org.apache.cassandra.transport.messages.ResultMessage;
/////////////////////////////////////////////////////////////////////////
1:     public void hasKeyspaceAccess(String keyspace, Permission perm) throws UnauthorizedException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_KS) && (perm != Permission.USE))
0:             throw new InvalidRequestException("system keyspace is not user-modifiable");
/////////////////////////////////////////////////////////////////////////
0: 
0:         // check if keyspace access is set to Permission.ALL
0:         // (which means that user has all access on keyspace and it's underlying elements)
0:         if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(Permission.FULL_ACCESS))
0:             return;
0: 
/////////////////////////////////////////////////////////////////////////
0:         {
0:         }
0:         if (perms.contains(Permission.FULL_ACCESS))
0:             return; // full access
0: 
0:         if (perms.contains(Permission.NO_ACCESS))
0:             throw new UnauthorizedException(String.format("%s does not have permission %s for %s",
0:                                                           user,
0:                                                           perm,
0:                                                           Resources.toString(resource)));
0: 
0:         boolean granular = false;
0: 
0:         for (Permission p : perms)
0:         {
0:             // mixing of old and granular permissions is denied by IAuthorityContainer
0:             // and CQL grammar so it's name to assume that once a granular permission is found
0:             // all other permissions are going to be a subset of Permission.GRANULAR_PERMISSIONS
0:             if (Permission.GRANULAR_PERMISSIONS.contains(p))
0:             {
0:                 granular = true;
0:                 break;
0:             }
0:         }
0: 
0:         if (granular)
0:         {
0:             if (perms.contains(perm))
0:                 return; // user has a given permission, perm is always one of Permission.GRANULAR_PERMISSIONS
0:         }
0:         else
0:         {
0:             for (Permission p : perms)
0:             {
0:                 if (Permission.oldToNew.get(p).contains(perm))
0:                     return;
0:             }
0:         }
0: 
0:                                                       Resources.toString(resource)));
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void grantPermission(Permission permission, String to, CFName on, boolean grantOption) throws UnauthorizedException, InvalidRequestException
0:     {
0:         DatabaseDescriptor.getAuthorityContainer().grant(user, permission, to, on, grantOption);
0:     }
0: 
0:     public void revokePermission(Permission permission, String from, CFName resource) throws UnauthorizedException, InvalidRequestException
0:     {
0:         DatabaseDescriptor.getAuthorityContainer().revoke(user, permission, from, resource);
0:     }
0: 
0:     public ResultMessage listPermissions(String username) throws UnauthorizedException, InvalidRequestException
0:     {
0:         return DatabaseDescriptor.getAuthorityContainer().listPermissions(username);
0:     }
commit:aba5a37
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.auth.*;
0: import org.apache.cassandra.cql3.CFName;
0: import org.apache.cassandra.thrift.CqlResult;
/////////////////////////////////////////////////////////////////////////
0:     public void hasKeyspaceAccess(String keyspace, Permission perm) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && (perm != Permission.USE))
/////////////////////////////////////////////////////////////////////////
0: 
0:         // check if keyspace access is set to Permission.ALL
0:         // (which means that user has all access on keyspace and it's underlying elements)
0:         if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(Permission.ALL))
0:             return;
0: 
/////////////////////////////////////////////////////////////////////////
0:         {
0:         }
0:     private static void hasAccess(AuthenticatedUser user, Set<Permission> perms, Permission perm, List<Object> resource) throws PermissionDenied
0:         if (perms.contains(Permission.FULL_ACCESS))
0:             return; // full access
0: 
0:         if (perms.contains(Permission.NO_ACCESS))
0:             throw new PermissionDenied(String.format("%s does not have permission %s for %s",
0:                                                      user,
0:                                                      perm,
0:                                                      Resources.toString(resource)));
0: 
0:         boolean granular = false;
0: 
0:         for (Permission p : perms)
0:         {
0:             // mixing of old and granular permissions is denied by IAuthorityContainer
0:             // and CQL grammar so it's name to assume that once a granular permission is found
0:             // all other permissions are going to be a subset of Permission.GRANULAR_PERMISSIONS
0:             if (Permission.GRANULAR_PERMISSIONS.contains(p))
0:             {
0:                 granular = true;
0:                 break;
0:             }
0:         }
0: 
0:         if (granular)
0:         {
0:             if (perms.contains(perm))
0:                 return; // user has a given permission, perm is always one of Permission.GRANULAR_PERMISSIONS
0:         }
0:         else
0:         {
0:             for (Permission p : perms)
0:             {
0:                 if (Permission.oldToNew.get(p).contains(perm))
0:                     return;
0:             }
0:         }
0: 
0:         throw new PermissionDenied(String.format("%s does not have permission %s for %s",
0:                                                   user,
0:                                                   perm,
0:                                                   Resources.toString(resource)));
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void grantPermission(Permission permission, String to, CFName on, boolean grantOption) throws InvalidRequestException
0:     {
0:         DatabaseDescriptor.getAuthorityContainer().grant(user, permission, to, on, grantOption);
0:     }
0: 
0:     public void revokePermission(Permission permission, String from, CFName resource) throws InvalidRequestException
0:     {
0:         DatabaseDescriptor.getAuthorityContainer().revoke(user, permission, from, resource);
0:     }
0: 
0:     public CqlResult listPermissions(String username) throws InvalidRequestException
0:     {
0:         return DatabaseDescriptor.getAuthorityContainer().listPermissions(username);
0:     }
commit:e594e0d
commit:b318404
/////////////////////////////////////////////////////////////////////////
commit:7c37454
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace != null && keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
commit:2f115d4
/////////////////////////////////////////////////////////////////////////
0:         if (keyspace != null && keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
commit:25faad4
/////////////////////////////////////////////////////////////////////////
0: 
1:     public String getRawKeyspace()
0:     {
1:         return keyspace;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         hasColumnFamilyAccess(keyspace, columnFamily, perm);
0:     }
0: 
0:     public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permission perm) throws InvalidRequestException
0:     {
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:de5715e
/////////////////////////////////////////////////////////////////////////
commit:da2d195
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.service;
0: 
0: import java.util.Map;
0: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.cassandra.auth.AuthenticatedUser;
0: import org.apache.cassandra.avro.AccessLevel;
0: import org.apache.cassandra.config.Config.RequestSchedulerId;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.thrift.AuthenticationException;
0: import org.apache.cassandra.thrift.AuthorizationException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: 
0: /**
0:  * A container for per-client, thread-local state that Avro/Thrift threads must hold.
0:  */
0: public class ClientState
0: {
0:     private static Logger logger = LoggerFactory.getLogger(ClientState.class);
0:     
0:     // true if the keyspace should be used as the scheduling id
0:     private final boolean SCHEDULE_ON_KEYSPACE = DatabaseDescriptor.getRequestSchedulerId().equals(RequestSchedulerId.keyspace);
0: 
0:     // Current user for the session
0:     private final ThreadLocal<AuthenticatedUser> user = new ThreadLocal<AuthenticatedUser>()
0:     {
0:         @Override
0:         public AuthenticatedUser initialValue()
0:         {
0:             return DatabaseDescriptor.getAuthenticator().defaultUser();
0:         }
0:     };
0: 
0:     // Keyspace and keyspace AccessLevels associated with the session
0:     private final ThreadLocal<String> keyspace = new ThreadLocal<String>();
0:     private final ThreadLocal<AccessLevel> keyspaceAccess = new ThreadLocal<AccessLevel>();
0: 
0:     /**
0:      * Called when the keyspace or user have changed.
0:      */
0:     private void updateKeyspaceAccess()
0:     {
0:         if (user.get() == null)
0:             // user is not logged in
0:             keyspaceAccess.set(null);
0:         else if (user.get().isSuper)
0:             // super user
0:             keyspaceAccess.set(AccessLevel.FULL);
0:         else if (keyspace.get() != null)
0:         {
0:             // lookup the access level for the user in the current keyspace
0:             KSMetaData ksm = DatabaseDescriptor.getTableDefinition(keyspace.get());
0:             keyspaceAccess.set(user.get().levelFor(ksm.usersAccess, ksm.groupsAccess));
0:         }
0:         else
0:             // user is logged in, but no keyspace is set
0:             keyspaceAccess.set(null);
0:     }
0: 
0:     public String getKeyspace()
0:     {
0:         return keyspace.get();
0:     }
0: 
0:     public void setKeyspace(String ks)
0:     {
0:         keyspace.set(ks);
0:         updateKeyspaceAccess();
0:     }
0: 
0:     public String getSchedulingId()
0:     {
0:         if (SCHEDULE_ON_KEYSPACE)
0:             return keyspace.get();
0:         return "default";
0:     }
0: 
0:     /**
0:      * Attempts to login this client with the given credentials map.
0:      * TODO: Kill thrift exceptions
0:      */
0:     public void login(Map<String,String> credentials) throws AuthenticationException, AuthorizationException
0:     {
0:         AuthenticatedUser user = DatabaseDescriptor.getAuthenticator().login(credentials);
0:         if (logger.isDebugEnabled())
0:             logger.debug("logged in: {}", user);
0:         this.user.set(user);
0:         updateKeyspaceAccess();
0:     }
0: 
0:     public void logout()
0:     {
0:         if (logger.isDebugEnabled())
0:             logger.debug("logged out: {}", user.get());
0:         user.remove();
0:         keyspace.remove();
0:         keyspaceAccess.remove();
0:     }
0: 
0:     /**
0:      * Confirms that the client thread has the given AccessLevel in the 'base' context (where Keyspace
0:      * management occurs).
0:      */
0:     public void hasBaseAccess(AccessLevel level) throws InvalidRequestException
0:     {
0:         if (user.get() == null)
0:             throw new InvalidRequestException("You have not logged in");
0:         // FIXME: only checking for the super user until 1271 lands
0:         if (!user.get().isSuper)
0:             throw new InvalidRequestException("Only a 'super' user may modify keyspaces");
0:     }
0: 
0:     /**
0:      * Confirms that the client thread has the given AccessLevel in the context of the current Keyspace.
0:      */
0:     public void hasKeyspaceAccess(AccessLevel level) throws InvalidRequestException
0:     {
0:         if (user.get() == null)
0:             throw new InvalidRequestException("You have not logged in");
0:         if (keyspaceAccess.get() == null)
0:             throw new InvalidRequestException("You have not set a keyspace for this session");
0:         if (keyspaceAccess.get().ordinal() < level.ordinal())
0:             throw new InvalidRequestException(String.format("Your user (%s) does not have permission to perform %s operations", user, level));
0:     }
0: }
============================================================================