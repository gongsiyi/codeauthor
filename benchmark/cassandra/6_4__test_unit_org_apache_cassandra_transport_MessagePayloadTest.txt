1:789aa72: /*
1:789aa72:  * Licensed to the Apache Software Foundation (ASF) under one
1:789aa72:  * or more contributor license agreements.  See the NOTICE file
1:789aa72:  * distributed with this work for additional information
1:789aa72:  * regarding copyright ownership.  The ASF licenses this file
1:789aa72:  * to you under the Apache License, Version 2.0 (the
1:789aa72:  * "License"); you may not use this file except in compliance
1:789aa72:  * with the License.  You may obtain a copy of the License at
1:789aa72:  *
1:789aa72:  *     http://www.apache.org/licenses/LICENSE-2.0
1:789aa72:  *
1:789aa72:  * Unless required by applicable law or agreed to in writing, software
1:789aa72:  * distributed under the License is distributed on an "AS IS" BASIS,
1:789aa72:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:789aa72:  * See the License for the specific language governing permissions and
1:789aa72:  * limitations under the License.
1:789aa72:  */
1:789aa72: package org.apache.cassandra.transport;
7:789aa72: 
1:789aa72: import java.lang.reflect.Field;
1:789aa72: import java.lang.reflect.Modifier;
1:789aa72: import java.nio.ByteBuffer;
1:789aa72: import java.util.Collections;
1:789aa72: import java.util.Map;
1:789aa72: 
1:f6217ae: import org.junit.After;
1:082dedf: import org.junit.AfterClass;
1:789aa72: import org.junit.Assert;
1:789aa72: import org.junit.BeforeClass;
1:789aa72: import org.junit.Test;
1:789aa72: 
1:789aa72: import org.apache.cassandra.cql3.BatchQueryOptions;
1:789aa72: import org.apache.cassandra.cql3.CQLStatement;
1:789aa72: import org.apache.cassandra.cql3.QueryHandler;
1:789aa72: import org.apache.cassandra.cql3.QueryOptions;
1:789aa72: import org.apache.cassandra.cql3.QueryProcessor;
1:789aa72: import org.apache.cassandra.cql3.statements.BatchStatement;
1:789aa72: import org.apache.cassandra.cql3.statements.ParsedStatement;
1:01115f7: import org.apache.cassandra.cql3.CQLTester;
1:789aa72: import org.apache.cassandra.exceptions.RequestExecutionException;
1:789aa72: import org.apache.cassandra.exceptions.RequestValidationException;
1:789aa72: import org.apache.cassandra.service.ClientState;
1:789aa72: import org.apache.cassandra.service.QueryState;
1:789aa72: import org.apache.cassandra.transport.messages.BatchMessage;
1:789aa72: import org.apache.cassandra.transport.messages.ExecuteMessage;
1:789aa72: import org.apache.cassandra.transport.messages.PrepareMessage;
1:789aa72: import org.apache.cassandra.transport.messages.QueryMessage;
1:789aa72: import org.apache.cassandra.transport.messages.ResultMessage;
1:789aa72: import org.apache.cassandra.utils.MD5Digest;
1:789aa72: 
1:6f93bd1: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1:6f93bd1: 
1:789aa72: public class MessagePayloadTest extends CQLTester
5:789aa72: {
1:6f93bd1:     public static Map<String, ByteBuffer> requestPayload;
1:6f93bd1:     public static Map<String, ByteBuffer> responsePayload;
1:01115f7: 
1:789aa72:     private static Field cqlQueryHandlerField;
1:789aa72:     private static boolean modifiersAccessible;
1:789aa72: 
2:789aa72:     @BeforeClass
1:789aa72:     public static void makeCqlQueryHandlerAccessible()
1:789aa72:     {
1:789aa72:         try
1:789aa72:         {
1:789aa72:             cqlQueryHandlerField = ClientState.class.getDeclaredField("cqlQueryHandler");
1:789aa72:             cqlQueryHandlerField.setAccessible(true);
1:789aa72: 
1:789aa72:             Field modifiersField = Field.class.getDeclaredField("modifiers");
1:789aa72:             modifiersAccessible = modifiersField.isAccessible();
1:082dedf:             modifiersField.setAccessible(true);
1:789aa72:             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() & ~Modifier.FINAL);
5:789aa72:         }
1:789aa72:         catch (IllegalAccessException | NoSuchFieldException e)
1:789aa72:         {
1:789aa72:             throw new RuntimeException(e);
1:789aa72:         }
1:789aa72:     }
1:789aa72: 
1:082dedf:     @AfterClass
1:789aa72:     public static void resetCqlQueryHandlerField()
1:789aa72:     {
1:789aa72:         if (cqlQueryHandlerField == null)
1:789aa72:             return;
1:789aa72:         try
1:789aa72:         {
1:789aa72:             Field modifiersField = Field.class.getDeclaredField("modifiers");
1:789aa72:             modifiersField.setAccessible(true);
1:789aa72:             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() | Modifier.FINAL);
1:f6217ae: 
1:f6217ae:             cqlQueryHandlerField.setAccessible(false);
1:f6217ae: 
1:789aa72:             modifiersField.setAccessible(modifiersAccessible);
1:789aa72:         }
1:789aa72:         catch (IllegalAccessException | NoSuchFieldException e)
1:789aa72:         {
1:789aa72:             throw new RuntimeException(e);
1:789aa72:         }
1:789aa72:     }
1:789aa72: 
1:f6217ae:     @After
1:f6217ae:     public void dropCreatedTable()
1:f6217ae:     {
1:f6217ae:         try
1:f6217ae:         {
1:f6217ae:             QueryProcessor.executeOnceInternal("DROP TABLE " + KEYSPACE + ".atable");
1:f6217ae:         }
1:f6217ae:         catch (Throwable t)
1:f6217ae:         {
1:f6217ae:             // ignore
1:f6217ae:         }
1:f6217ae:     }
1:f6217ae: 
1:f6217ae:     @Test
1:789aa72:     public void testMessagePayload() throws Throwable
1:f6217ae:     {
1:789aa72:         QueryHandler queryHandler = (QueryHandler) cqlQueryHandlerField.get(null);
1:789aa72:         cqlQueryHandlerField.set(null, new TestQueryHandler());
1:789aa72:         try
1:789aa72:         {
1:789aa72:             requireNetwork();
1:789aa72: 
1:789aa72:             Assert.assertSame(TestQueryHandler.class, ClientState.getCQLQueryHandler().getClass());
1:789aa72: 
1:789aa72:             SimpleClient client = new SimpleClient(nativeAddr.getHostAddress(), nativePort);
1:789aa72:             try
1:789aa72:             {
1:789aa72:                 client.connect(false);
1:f6217ae: 
1:6f93bd1:                 Map<String, ByteBuffer> reqMap;
1:6f93bd1:                 Map<String, ByteBuffer> respMap;
1:789aa72: 
1:789aa72:                 QueryMessage queryMessage = new QueryMessage(
1:789aa72:                                                             "CREATE TABLE " + KEYSPACE + ".atable (pk int PRIMARY KEY, v text)",
1:789aa72:                                                             QueryOptions.DEFAULT
1:789aa72:                 );
1:789aa72:                 PrepareMessage prepareMessage = new PrepareMessage("SELECT * FROM " + KEYSPACE + ".atable");
1:789aa72: 
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(42));
1:6f93bd1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(42));
1:789aa72:                 queryMessage.setCustomPayload(reqMap);
1:789aa72:                 Message.Response queryResponse = client.execute(queryMessage);
1:789aa72:                 payloadEquals(reqMap, requestPayload);
1:789aa72:                 payloadEquals(respMap, queryResponse.getCustomPayload());
1:789aa72: 
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(43));
1:6f93bd1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(43));
1:789aa72:                 prepareMessage.setCustomPayload(reqMap);
1:789aa72:                 ResultMessage.Prepared prepareResponse = (ResultMessage.Prepared) client.execute(prepareMessage);
1:789aa72:                 payloadEquals(reqMap, requestPayload);
1:789aa72:                 payloadEquals(respMap, prepareResponse.getCustomPayload());
1:789aa72: 
1:789aa72:                 ExecuteMessage executeMessage = new ExecuteMessage(prepareResponse.statementId, QueryOptions.DEFAULT);
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(44));
1:6f93bd1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(44));
1:789aa72:                 executeMessage.setCustomPayload(reqMap);
1:789aa72:                 Message.Response executeResponse = client.execute(executeMessage);
1:789aa72:                 payloadEquals(reqMap, requestPayload);
1:789aa72:                 payloadEquals(respMap, executeResponse.getCustomPayload());
1:789aa72: 
1:789aa72:                 BatchMessage batchMessage = new BatchMessage(BatchStatement.Type.UNLOGGED,
1:789aa72:                                                              Collections.<Object>singletonList("INSERT INTO " + KEYSPACE + ".atable (pk,v) VALUES (1, 'foo')"),
1:789aa72:                                                              Collections.singletonList(Collections.<ByteBuffer>emptyList()),
1:789aa72:                                                              QueryOptions.DEFAULT);
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(45));
1:6f93bd1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(45));
1:789aa72:                 batchMessage.setCustomPayload(reqMap);
1:789aa72:                 Message.Response batchResponse = client.execute(batchMessage);
1:789aa72:                 payloadEquals(reqMap, requestPayload);
1:789aa72:                 payloadEquals(respMap, batchResponse.getCustomPayload());
1:f6217ae:             }
1:789aa72:             finally
1:789aa72:             {
1:789aa72:                 client.close();
1:789aa72:             }
1:789aa72:         }
1:789aa72:         finally
1:789aa72:         {
1:789aa72:             cqlQueryHandlerField.set(null, queryHandler);
1:789aa72:         }
1:789aa72:     }
1:789aa72: 
1:789aa72:     @Test
1:f6217ae:     public void testMessagePayloadVersion3() throws Throwable
1:f6217ae:     {
1:f6217ae:         QueryHandler queryHandler = (QueryHandler) cqlQueryHandlerField.get(null);
1:f6217ae:         cqlQueryHandlerField.set(null, new TestQueryHandler());
1:f6217ae:         try
1:f6217ae:         {
1:f6217ae:             requireNetwork();
1:f6217ae: 
1:f6217ae:             Assert.assertSame(TestQueryHandler.class, ClientState.getCQLQueryHandler().getClass());
1:f6217ae: 
1:e0adc16:             SimpleClient client = new SimpleClient(nativeAddr.getHostAddress(), nativePort, ProtocolVersion.V3);
1:f6217ae:             try
1:f6217ae:             {
1:f6217ae:                 client.connect(false);
1:f6217ae: 
1:6f93bd1:                 Map<String, ByteBuffer> reqMap;
1:f6217ae: 
1:f6217ae:                 QueryMessage queryMessage = new QueryMessage(
1:f6217ae:                                                             "CREATE TABLE " + KEYSPACE + ".atable (pk int PRIMARY KEY, v text)",
1:f6217ae:                                                             QueryOptions.DEFAULT
1:f6217ae:                 );
1:f6217ae:                 PrepareMessage prepareMessage = new PrepareMessage("SELECT * FROM " + KEYSPACE + ".atable");
1:789aa72: 
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(42));
1:6f93bd1:                 responsePayload = Collections.singletonMap("bar", bytes(42));
1:f6217ae:                 queryMessage.setCustomPayload(reqMap);
1:f6217ae:                 try
1:789aa72:                 {
1:f6217ae:                     client.execute(queryMessage);
1:f6217ae:                     Assert.fail();
1:f6217ae:                 }
1:70b51ff:                 catch (RuntimeException e)
1:f6217ae:                 {
1:70b51ff:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
1:f6217ae:                 }
1:f6217ae:                 queryMessage.setCustomPayload(null);
1:f6217ae:                 client.execute(queryMessage);
1:f6217ae: 
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(43));
1:6f93bd1:                 responsePayload = Collections.singletonMap("bar", bytes(43));
1:f6217ae:                 prepareMessage.setCustomPayload(reqMap);
1:f6217ae:                 try
1:f6217ae:                 {
1:f6217ae:                     client.execute(prepareMessage);
1:f6217ae:                     Assert.fail();
1:f6217ae:                 }
1:70b51ff:                 catch (RuntimeException e)
1:f6217ae:                 {
1:70b51ff:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
1:f6217ae:                 }
1:f6217ae:                 prepareMessage.setCustomPayload(null);
1:f6217ae:                 ResultMessage.Prepared prepareResponse = (ResultMessage.Prepared) client.execute(prepareMessage);
1:f6217ae: 
1:f6217ae:                 ExecuteMessage executeMessage = new ExecuteMessage(prepareResponse.statementId, QueryOptions.DEFAULT);
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(44));
1:6f93bd1:                 responsePayload = Collections.singletonMap("bar", bytes(44));
1:f6217ae:                 executeMessage.setCustomPayload(reqMap);
1:f6217ae:                 try
1:f6217ae:                 {
1:f6217ae:                     client.execute(executeMessage);
1:f6217ae:                     Assert.fail();
1:f6217ae:                 }
1:70b51ff:                 catch (RuntimeException e)
1:f6217ae:                 {
1:70b51ff:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
1:f6217ae:                 }
1:f6217ae: 
1:f6217ae:                 BatchMessage batchMessage = new BatchMessage(BatchStatement.Type.UNLOGGED,
1:f6217ae:                                                              Collections.<Object>singletonList("INSERT INTO " + KEYSPACE + ".atable (pk,v) VALUES (1, 'foo')"),
1:f6217ae:                                                              Collections.singletonList(Collections.<ByteBuffer>emptyList()),
1:f6217ae:                                                              QueryOptions.DEFAULT);
1:6f93bd1:                 reqMap = Collections.singletonMap("foo", bytes(45));
1:6f93bd1:                 responsePayload = Collections.singletonMap("bar", bytes(45));
1:f6217ae:                 batchMessage.setCustomPayload(reqMap);
1:f6217ae:                 try
1:f6217ae:                 {
1:f6217ae:                     client.execute(batchMessage);
1:f6217ae:                     Assert.fail();
1:f6217ae:                 }
1:70b51ff:                 catch (RuntimeException e)
1:f6217ae:                 {
1:70b51ff:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
1:f6217ae:                 }
1:f6217ae:             }
1:f6217ae:             finally
1:f6217ae:             {
1:f6217ae:                 client.close();
1:f6217ae:             }
1:f6217ae:         }
1:f6217ae:         finally
1:f6217ae:         {
1:f6217ae:             cqlQueryHandlerField.set(null, queryHandler);
1:f6217ae:         }
1:789aa72:     }
1:f6217ae: 
1:6f93bd1:     private static void payloadEquals(Map<String, ByteBuffer> map1, Map<String, ByteBuffer> map2)
1:789aa72:     {
1:789aa72:         Assert.assertNotNull(map1);
1:789aa72:         Assert.assertNotNull(map2);
1:789aa72:         Assert.assertEquals(map1.keySet(), map2.keySet());
1:6f93bd1:         for (Map.Entry<String, ByteBuffer> e : map1.entrySet())
1:6f93bd1:             Assert.assertEquals(e.getValue(), map2.get(e.getKey()));
1:789aa72:     }
1:789aa72: 
1:789aa72:     public static class TestQueryHandler implements QueryHandler
1:789aa72:     {
1:789aa72:         public ParsedStatement.Prepared getPrepared(MD5Digest id)
1:789aa72:         {
1:789aa72:             return QueryProcessor.instance.getPrepared(id);
1:789aa72:         }
1:789aa72: 
1:789aa72:         public ParsedStatement.Prepared getPreparedForThrift(Integer id)
1:789aa72:         {
1:789aa72:             return QueryProcessor.instance.getPreparedForThrift(id);
1:789aa72:         }
1:789aa72: 
1:6f93bd1:         public ResultMessage.Prepared prepare(String query,
1:6f93bd1:                                               QueryState state,
1:6f93bd1:                                               Map<String, ByteBuffer> customPayload)
1:6f93bd1:                                                       throws RequestValidationException
1:789aa72:         {
1:789aa72:             if (customPayload != null)
1:789aa72:                 requestPayload = customPayload;
1:789aa72:             ResultMessage.Prepared result = QueryProcessor.instance.prepare(query, state, customPayload);
1:789aa72:             if (customPayload != null)
1:789aa72:             {
1:789aa72:                 result.setCustomPayload(responsePayload);
1:789aa72:                 responsePayload = null;
1:789aa72:             }
1:789aa72:             return result;
1:789aa72:         }
1:789aa72: 
1:6f93bd1:         public ResultMessage process(String query,
1:6f93bd1:                                      QueryState state,
1:6f93bd1:                                      QueryOptions options,
1:aa83c94:                                      Map<String, ByteBuffer> customPayload,
1:aa83c94:                                      long queryStartNanoTime)
1:aa83c94:                                             throws RequestExecutionException, RequestValidationException
1:789aa72:         {
1:789aa72:             if (customPayload != null)
1:789aa72:                 requestPayload = customPayload;
1:aa83c94:             ResultMessage result = QueryProcessor.instance.process(query, state, options, customPayload, queryStartNanoTime);
1:789aa72:             if (customPayload != null)
1:789aa72:             {
1:789aa72:                 result.setCustomPayload(responsePayload);
1:789aa72:                 responsePayload = null;
1:789aa72:             }
1:789aa72:             return result;
1:789aa72:         }
1:789aa72: 
1:6f93bd1:         public ResultMessage processBatch(BatchStatement statement,
1:6f93bd1:                                           QueryState state,
1:6f93bd1:                                           BatchQueryOptions options,
1:aa83c94:                                           Map<String, ByteBuffer> customPayload,
1:aa83c94:                                           long queryStartNanoTime)
1:6f93bd1:                                                   throws RequestExecutionException, RequestValidationException
1:789aa72:         {
1:789aa72:             if (customPayload != null)
1:789aa72:                 requestPayload = customPayload;
1:aa83c94:             ResultMessage result = QueryProcessor.instance.processBatch(statement, state, options, customPayload, queryStartNanoTime);
1:789aa72:             if (customPayload != null)
1:789aa72:             {
1:789aa72:                 result.setCustomPayload(responsePayload);
1:789aa72:                 responsePayload = null;
1:789aa72:             }
1:789aa72:             return result;
1:789aa72:         }
1:789aa72: 
1:6f93bd1:         public ResultMessage processPrepared(CQLStatement statement,
1:6f93bd1:                                              QueryState state,
1:6f93bd1:                                              QueryOptions options,
1:aa83c94:                                              Map<String, ByteBuffer> customPayload,
1:aa83c94:                                              long queryStartNanoTime)
1:aa83c94:                                                     throws RequestExecutionException, RequestValidationException
1:789aa72:         {
1:789aa72:             if (customPayload != null)
1:789aa72:                 requestPayload = customPayload;
1:aa83c94:             ResultMessage result = QueryProcessor.instance.processPrepared(statement, state, options, customPayload, queryStartNanoTime);
1:789aa72:             if (customPayload != null)
1:789aa72:             {
1:789aa72:                 result.setCustomPayload(responsePayload);
1:789aa72:                 responsePayload = null;
1:789aa72:             }
1:789aa72:             return result;
1:789aa72:         }
1:789aa72:     }
1:789aa72: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1:             SimpleClient client = new SimpleClient(nativeAddr.getHostAddress(), nativePort, ProtocolVersion.V3);
commit:01115f7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.cql3.CQLTester;
0: import org.apache.cassandra.dht.ByteOrderedPartitioner;
/////////////////////////////////////////////////////////////////////////
0:             DatabaseDescriptor.setPartitioner(ByteOrderedPartitioner.instance);
1: 
author:Geoffrey Yu
-------------------------------------------------------------------------------
commit:aa83c94
/////////////////////////////////////////////////////////////////////////
1:                                      Map<String, ByteBuffer> customPayload,
1:                                      long queryStartNanoTime)
1:                                             throws RequestExecutionException, RequestValidationException
1:             ResultMessage result = QueryProcessor.instance.process(query, state, options, customPayload, queryStartNanoTime);
/////////////////////////////////////////////////////////////////////////
1:                                           Map<String, ByteBuffer> customPayload,
1:                                           long queryStartNanoTime)
1:             ResultMessage result = QueryProcessor.instance.processBatch(statement, state, options, customPayload, queryStartNanoTime);
/////////////////////////////////////////////////////////////////////////
1:                                              Map<String, ByteBuffer> customPayload,
1:                                              long queryStartNanoTime)
1:                                                     throws RequestExecutionException, RequestValidationException
1:             ResultMessage result = QueryProcessor.instance.processPrepared(statement, state, options, customPayload, queryStartNanoTime);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:6f93bd1
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1: 
1:     public static Map<String, ByteBuffer> requestPayload;
1:     public static Map<String, ByteBuffer> responsePayload;
/////////////////////////////////////////////////////////////////////////
1:                 Map<String, ByteBuffer> reqMap;
1:                 Map<String, ByteBuffer> respMap;
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(42));
1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(42));
1:                 reqMap = Collections.singletonMap("foo", bytes(43));
1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(43));
1:                 reqMap = Collections.singletonMap("foo", bytes(44));
1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(44));
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(45));
1:                 responsePayload = respMap = Collections.singletonMap("bar", bytes(45));
/////////////////////////////////////////////////////////////////////////
1:                 Map<String, ByteBuffer> reqMap;
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(42));
1:                 responsePayload = Collections.singletonMap("bar", bytes(42));
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(43));
1:                 responsePayload = Collections.singletonMap("bar", bytes(43));
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(44));
1:                 responsePayload = Collections.singletonMap("bar", bytes(44));
/////////////////////////////////////////////////////////////////////////
1:                 reqMap = Collections.singletonMap("foo", bytes(45));
1:                 responsePayload = Collections.singletonMap("bar", bytes(45));
/////////////////////////////////////////////////////////////////////////
1:     private static void payloadEquals(Map<String, ByteBuffer> map1, Map<String, ByteBuffer> map2)
1:         for (Map.Entry<String, ByteBuffer> e : map1.entrySet())
1:             Assert.assertEquals(e.getValue(), map2.get(e.getKey()));
/////////////////////////////////////////////////////////////////////////
1:         public ResultMessage.Prepared prepare(String query,
1:                                               QueryState state,
1:                                               Map<String, ByteBuffer> customPayload)
1:                                                       throws RequestValidationException
/////////////////////////////////////////////////////////////////////////
1:         public ResultMessage process(String query,
1:                                      QueryState state,
1:                                      QueryOptions options,
0:                                      Map<String, ByteBuffer> customPayload)
1:                                              throws RequestExecutionException, RequestValidationException
/////////////////////////////////////////////////////////////////////////
1:         public ResultMessage processBatch(BatchStatement statement,
1:                                           QueryState state,
1:                                           BatchQueryOptions options,
0:                                           Map<String, ByteBuffer> customPayload)
0:                                                   throws RequestExecutionException, RequestValidationException
/////////////////////////////////////////////////////////////////////////
1:         public ResultMessage processPrepared(CQLStatement statement,
1:                                              QueryState state,
1:                                              QueryOptions options,
0:                                              Map<String, ByteBuffer> customPayload)
0:                                                      throws RequestExecutionException, RequestValidationException
author:Robert Stupp
-------------------------------------------------------------------------------
commit:70b51ff
/////////////////////////////////////////////////////////////////////////
1:                 catch (RuntimeException e)
1:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
/////////////////////////////////////////////////////////////////////////
1:                 catch (RuntimeException e)
1:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
/////////////////////////////////////////////////////////////////////////
1:                 catch (RuntimeException e)
1:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
/////////////////////////////////////////////////////////////////////////
1:                 catch (RuntimeException e)
1:                     Assert.assertTrue(e.getCause() instanceof ProtocolException);
commit:f6217ae
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
/////////////////////////////////////////////////////////////////////////
1: 
1:             cqlQueryHandlerField.setAccessible(false);
1: 
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void dropCreatedTable()
1:     {
1:         try
1:         {
1:             QueryProcessor.executeOnceInternal("DROP TABLE " + KEYSPACE + ".atable");
1:         }
1:         catch (Throwable t)
1:         {
1:             // ignore
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testMessagePayloadVersion3() throws Throwable
1:     {
1:         QueryHandler queryHandler = (QueryHandler) cqlQueryHandlerField.get(null);
1:         cqlQueryHandlerField.set(null, new TestQueryHandler());
1:         try
1:         {
1:             requireNetwork();
1: 
1:             Assert.assertSame(TestQueryHandler.class, ClientState.getCQLQueryHandler().getClass());
1: 
0:             SimpleClient client = new SimpleClient(nativeAddr.getHostAddress(), nativePort, Server.VERSION_3);
1:             try
1:             {
1:                 client.connect(false);
1: 
0:                 Map<String, byte[]> reqMap;
1: 
1:                 QueryMessage queryMessage = new QueryMessage(
1:                                                             "CREATE TABLE " + KEYSPACE + ".atable (pk int PRIMARY KEY, v text)",
1:                                                             QueryOptions.DEFAULT
1:                 );
1:                 PrepareMessage prepareMessage = new PrepareMessage("SELECT * FROM " + KEYSPACE + ".atable");
1: 
0:                 reqMap = Collections.singletonMap("foo", "42".getBytes());
0:                 responsePayload = Collections.singletonMap("bar", "42".getBytes());
1:                 queryMessage.setCustomPayload(reqMap);
1:                 try
1:                 {
1:                     client.execute(queryMessage);
1:                     Assert.fail();
1:                 }
0:                 catch (ProtocolException e)
1:                 {
0:                     // that's what we want
1:                 }
1:                 queryMessage.setCustomPayload(null);
1:                 client.execute(queryMessage);
1: 
0:                 reqMap = Collections.singletonMap("foo", "43".getBytes());
0:                 responsePayload = Collections.singletonMap("bar", "43".getBytes());
1:                 prepareMessage.setCustomPayload(reqMap);
1:                 try
1:                 {
1:                     client.execute(prepareMessage);
1:                     Assert.fail();
1:                 }
0:                 catch (ProtocolException e)
1:                 {
0:                     // that's what we want
1:                 }
1:                 prepareMessage.setCustomPayload(null);
1:                 ResultMessage.Prepared prepareResponse = (ResultMessage.Prepared) client.execute(prepareMessage);
1: 
1:                 ExecuteMessage executeMessage = new ExecuteMessage(prepareResponse.statementId, QueryOptions.DEFAULT);
0:                 reqMap = Collections.singletonMap("foo", "44".getBytes());
0:                 responsePayload = Collections.singletonMap("bar", "44".getBytes());
1:                 executeMessage.setCustomPayload(reqMap);
1:                 try
1:                 {
1:                     client.execute(executeMessage);
1:                     Assert.fail();
1:                 }
0:                 catch (ProtocolException e)
1:                 {
0:                     // that's what we want
1:                 }
1: 
1:                 BatchMessage batchMessage = new BatchMessage(BatchStatement.Type.UNLOGGED,
1:                                                              Collections.<Object>singletonList("INSERT INTO " + KEYSPACE + ".atable (pk,v) VALUES (1, 'foo')"),
1:                                                              Collections.singletonList(Collections.<ByteBuffer>emptyList()),
1:                                                              QueryOptions.DEFAULT);
0:                 reqMap = Collections.singletonMap("foo", "45".getBytes());
0:                 responsePayload = Collections.singletonMap("bar", "45".getBytes());
1:                 batchMessage.setCustomPayload(reqMap);
1:                 try
1:                 {
1:                     client.execute(batchMessage);
1:                     Assert.fail();
1:                 }
0:                 catch (ProtocolException e)
1:                 {
0:                     // that's what we want
1:                 }
1:             }
1:             finally
1:             {
1:                 client.close();
1:             }
1:         }
1:         finally
1:         {
1:             cqlQueryHandlerField.set(null, queryHandler);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:082dedf
/////////////////////////////////////////////////////////////////////////
1: import org.junit.AfterClass;
/////////////////////////////////////////////////////////////////////////
1:     @AfterClass
/////////////////////////////////////////////////////////////////////////
1:             modifiersField.setAccessible(true);
commit:789aa72
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.transport;
1: 
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Modifier;
1: import java.nio.ByteBuffer;
1: import java.util.Collections;
1: import java.util.Map;
1: 
1: import org.junit.Assert;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.cql3.BatchQueryOptions;
1: import org.apache.cassandra.cql3.CQLStatement;
0: import org.apache.cassandra.cql3.CQLTester;
1: import org.apache.cassandra.cql3.QueryHandler;
1: import org.apache.cassandra.cql3.QueryOptions;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.statements.BatchStatement;
1: import org.apache.cassandra.cql3.statements.ParsedStatement;
1: import org.apache.cassandra.exceptions.RequestExecutionException;
1: import org.apache.cassandra.exceptions.RequestValidationException;
1: import org.apache.cassandra.service.ClientState;
1: import org.apache.cassandra.service.QueryState;
1: import org.apache.cassandra.transport.messages.BatchMessage;
1: import org.apache.cassandra.transport.messages.ExecuteMessage;
1: import org.apache.cassandra.transport.messages.PrepareMessage;
1: import org.apache.cassandra.transport.messages.QueryMessage;
1: import org.apache.cassandra.transport.messages.ResultMessage;
1: import org.apache.cassandra.utils.MD5Digest;
1: 
1: public class MessagePayloadTest extends CQLTester
1: {
0:     public static Map<String, byte[]> requestPayload;
0:     public static Map<String, byte[]> responsePayload;
1: 
1:     private static Field cqlQueryHandlerField;
1:     private static boolean modifiersAccessible;
1: 
1:     @BeforeClass
1:     public static void makeCqlQueryHandlerAccessible()
1:     {
1:         try
1:         {
1:             cqlQueryHandlerField = ClientState.class.getDeclaredField("cqlQueryHandler");
1:             cqlQueryHandlerField.setAccessible(true);
1: 
1:             Field modifiersField = Field.class.getDeclaredField("modifiers");
1:             modifiersAccessible = modifiersField.isAccessible();
1:             modifiersField.setAccessible(true);
1:             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() & ~Modifier.FINAL);
1:         }
1:         catch (IllegalAccessException | NoSuchFieldException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     @BeforeClass
1:     public static void resetCqlQueryHandlerField()
1:     {
1:         if (cqlQueryHandlerField == null)
1:             return;
1:         try
1:         {
0:             cqlQueryHandlerField.setAccessible(false);
1: 
1:             Field modifiersField = Field.class.getDeclaredField("modifiers");
1:             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() | Modifier.FINAL);
1:             modifiersField.setAccessible(modifiersAccessible);
1:         }
1:         catch (IllegalAccessException | NoSuchFieldException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     @Test
1:     public void testMessagePayload() throws Throwable
1:     {
1:         QueryHandler queryHandler = (QueryHandler) cqlQueryHandlerField.get(null);
1:         cqlQueryHandlerField.set(null, new TestQueryHandler());
1:         try
1:         {
1:             requireNetwork();
1: 
1:             Assert.assertSame(TestQueryHandler.class, ClientState.getCQLQueryHandler().getClass());
1: 
1:             SimpleClient client = new SimpleClient(nativeAddr.getHostAddress(), nativePort);
1:             try
1:             {
1:                 client.connect(false);
1: 
0:                 Map<String, byte[]> reqMap;
0:                 Map<String, byte[]> respMap;
1: 
1:                 QueryMessage queryMessage = new QueryMessage(
1:                                                             "CREATE TABLE " + KEYSPACE + ".atable (pk int PRIMARY KEY, v text)",
1:                                                             QueryOptions.DEFAULT
1:                 );
1:                 PrepareMessage prepareMessage = new PrepareMessage("SELECT * FROM " + KEYSPACE + ".atable");
1: 
0:                 reqMap = Collections.singletonMap("foo", "42".getBytes());
0:                 responsePayload = respMap = Collections.singletonMap("bar", "42".getBytes());
1:                 queryMessage.setCustomPayload(reqMap);
1:                 Message.Response queryResponse = client.execute(queryMessage);
1:                 payloadEquals(reqMap, requestPayload);
1:                 payloadEquals(respMap, queryResponse.getCustomPayload());
1: 
0:                 reqMap = Collections.singletonMap("foo", "43".getBytes());
0:                 responsePayload = respMap = Collections.singletonMap("bar", "43".getBytes());
1:                 prepareMessage.setCustomPayload(reqMap);
1:                 ResultMessage.Prepared prepareResponse = (ResultMessage.Prepared) client.execute(prepareMessage);
1:                 payloadEquals(reqMap, requestPayload);
1:                 payloadEquals(respMap, prepareResponse.getCustomPayload());
1: 
1:                 ExecuteMessage executeMessage = new ExecuteMessage(prepareResponse.statementId, QueryOptions.DEFAULT);
0:                 reqMap = Collections.singletonMap("foo", "44".getBytes());
0:                 responsePayload = respMap = Collections.singletonMap("bar", "44".getBytes());
1:                 executeMessage.setCustomPayload(reqMap);
1:                 Message.Response executeResponse = client.execute(executeMessage);
1:                 payloadEquals(reqMap, requestPayload);
1:                 payloadEquals(respMap, executeResponse.getCustomPayload());
1: 
1:                 BatchMessage batchMessage = new BatchMessage(BatchStatement.Type.UNLOGGED,
1:                                                              Collections.<Object>singletonList("INSERT INTO " + KEYSPACE + ".atable (pk,v) VALUES (1, 'foo')"),
1:                                                              Collections.singletonList(Collections.<ByteBuffer>emptyList()),
1:                                                              QueryOptions.DEFAULT);
0:                 reqMap = Collections.singletonMap("foo", "45".getBytes());
0:                 responsePayload = respMap = Collections.singletonMap("bar", "45".getBytes());
1:                 batchMessage.setCustomPayload(reqMap);
1:                 Message.Response batchResponse = client.execute(batchMessage);
1:                 payloadEquals(reqMap, requestPayload);
1:                 payloadEquals(respMap, batchResponse.getCustomPayload());
1:             }
1:             finally
1:             {
1:                 client.close();
1:             }
1:         }
1:         finally
1:         {
1:             cqlQueryHandlerField.set(null, queryHandler);
1:         }
1:     }
1: 
0:     private static void payloadEquals(Map<String, byte[]> map1, Map<String, byte[]> map2)
1:     {
1:         Assert.assertNotNull(map1);
1:         Assert.assertNotNull(map2);
1:         Assert.assertEquals(map1.keySet(), map2.keySet());
0:         for (Map.Entry<String, byte[]> e : map1.entrySet())
0:             Assert.assertArrayEquals(e.getValue(), map2.get(e.getKey()));
1:     }
1: 
1:     public static class TestQueryHandler implements QueryHandler
1:     {
1:         public ParsedStatement.Prepared getPrepared(MD5Digest id)
1:         {
1:             return QueryProcessor.instance.getPrepared(id);
1:         }
1: 
1:         public ParsedStatement.Prepared getPreparedForThrift(Integer id)
1:         {
1:             return QueryProcessor.instance.getPreparedForThrift(id);
1:         }
1: 
0:         public ResultMessage processPrepared(CQLStatement statement, QueryState state, QueryOptions options) throws RequestExecutionException, RequestValidationException
1:         {
0:             return processPrepared(statement, state, options, null);
1:         }
1: 
0:         public ResultMessage processBatch(BatchStatement statement, QueryState state, BatchQueryOptions options) throws RequestExecutionException, RequestValidationException
1:         {
0:             return processBatch(statement, state, options, null);
1:         }
1: 
0:         public ResultMessage process(String query, QueryState state, QueryOptions options) throws RequestExecutionException, RequestValidationException
1:         {
0:             return process(query, state, options, null);
1:         }
1: 
0:         public ResultMessage.Prepared prepare(String query, QueryState state) throws RequestValidationException
1:         {
0:             return prepare(query, state, null);
1:         }
1: 
0:         public ResultMessage.Prepared prepare(String query, QueryState state, Map<String, byte[]> customPayload) throws RequestValidationException
1:         {
1:             if (customPayload != null)
1:                 requestPayload = customPayload;
1:             ResultMessage.Prepared result = QueryProcessor.instance.prepare(query, state, customPayload);
1:             if (customPayload != null)
1:             {
1:                 result.setCustomPayload(responsePayload);
1:                 responsePayload = null;
1:             }
1:             return result;
1:         }
1: 
0:         public ResultMessage process(String query, QueryState state, QueryOptions options, Map<String, byte[]> customPayload) throws RequestExecutionException, RequestValidationException
1:         {
1:             if (customPayload != null)
1:                 requestPayload = customPayload;
0:             ResultMessage result = QueryProcessor.instance.process(query, state, options, customPayload);
1:             if (customPayload != null)
1:             {
1:                 result.setCustomPayload(responsePayload);
1:                 responsePayload = null;
1:             }
1:             return result;
1:         }
1: 
0:         public ResultMessage processBatch(BatchStatement statement, QueryState state, BatchQueryOptions options, Map<String, byte[]> customPayload) throws RequestExecutionException, RequestValidationException
1:         {
1:             if (customPayload != null)
1:                 requestPayload = customPayload;
0:             ResultMessage result = QueryProcessor.instance.processBatch(statement, state, options, customPayload);
1:             if (customPayload != null)
1:             {
1:                 result.setCustomPayload(responsePayload);
1:                 responsePayload = null;
1:             }
1:             return result;
1:         }
1: 
0:         public ResultMessage processPrepared(CQLStatement statement, QueryState state, QueryOptions options, Map<String, byte[]> customPayload) throws RequestExecutionException, RequestValidationException
1:         {
1:             if (customPayload != null)
1:                 requestPayload = customPayload;
0:             ResultMessage result = QueryProcessor.instance.processPrepared(statement, state, options, customPayload);
1:             if (customPayload != null)
1:             {
1:                 result.setCustomPayload(responsePayload);
1:                 responsePayload = null;
1:             }
1:             return result;
1:         }
1:     }
1: }
============================================================================