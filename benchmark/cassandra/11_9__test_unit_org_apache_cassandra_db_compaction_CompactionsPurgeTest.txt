1:b7a173a: /*
1:b7a173a: * Licensed to the Apache Software Foundation (ASF) under one
1:b7a173a: * or more contributor license agreements.  See the NOTICE file
1:b7a173a: * distributed with this work for additional information
1:b7a173a: * regarding copyright ownership.  The ASF licenses this file
1:b7a173a: * to you under the Apache License, Version 2.0 (the
1:b7a173a: * "License"); you may not use this file except in compliance
1:b7a173a: * with the License.  You may obtain a copy of the License at
1:b7a173a: *
1:b7a173a: *    http://www.apache.org/licenses/LICENSE-2.0
1:b7a173a: *
1:b7a173a: * Unless required by applicable law or agreed to in writing,
1:b7a173a: * software distributed under the License is distributed on an
1:b7a173a: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:b7a173a: * KIND, either express or implied.  See the License for the
1:b7a173a: * specific language governing permissions and limitations
1:b7a173a: * under the License.
1:b7a173a: */
1:b7a173a: package org.apache.cassandra.db.compaction;
1:36cdf34: 
1:b7a173a: import java.util.Collection;
1:5a7ff5e: import java.util.List;
1:b7a173a: import java.util.concurrent.ExecutionException;
1:6bbb13b: 
1:d2a3827: import org.junit.BeforeClass;
1:b7a173a: import org.junit.Test;
1:3edb62b: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:b7a173a: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.cql3.QueryProcessor;
1:a991b64: import org.apache.cassandra.cql3.UntypedResultSet;
1:6bbb13b: import org.apache.cassandra.db.*;
1:e51f83b: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:a991b64: import org.apache.cassandra.db.partitions.PartitionUpdate;
1:a991b64: import org.apache.cassandra.exceptions.ConfigurationException;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:b31845c: import org.apache.cassandra.schema.CachingParams;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:b7a173a: import org.apache.cassandra.utils.ByteBufferUtil;
1:c45ed17: import org.apache.cassandra.utils.FBUtilities;
16:b7a173a: 
1:a991b64: import static org.junit.Assert.*;
1:b31845c: import static org.apache.cassandra.Util.dk;
1:a991b64: 
1:d2a3827: public class CompactionsPurgeTest
6:b7a173a: {
1:d2a3827:     private static final String KEYSPACE1 = "CompactionsPurgeTest1";
1:d2a3827:     private static final String CF_STANDARD1 = "Standard1";
1:d2a3827:     private static final String CF_STANDARD2 = "Standard2";
1:d2a3827:     private static final String KEYSPACE2 = "CompactionsPurgeTest2";
1:d2a3827:     private static final String KEYSPACE_CACHED = "CompactionsPurgeTestCached";
1:d2a3827:     private static final String CF_CACHED = "CachedCF";
1:d2a3827:     private static final String KEYSPACE_CQL = "cql_keyspace";
1:d2a3827:     private static final String CF_CQL = "table1";
1:d2a3827: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:d2a3827:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:31e3f61:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
1:31e3f61:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2));
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE2,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:31e3f61:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE_CACHED,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:b31845c:                                     SchemaLoader.standardCFMD(KEYSPACE_CACHED, CF_CACHED).caching(CachingParams.CACHE_EVERYTHING));
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE_CQL,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:31e3f61:                                     CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
1:31e3f61:                                             + "k int PRIMARY KEY,"
1:31e3f61:                                             + "v1 text,"
1:31e3f61:                                             + "v2 int"
1:31e3f61:                                             + ")", KEYSPACE_CQL));
1:d2a3827:     }
1:2c8d201: 
1:2c8d201:     @Test
1:c87b6a3:     public void testMajorCompactionPurge()
1:2c8d201:     {
1:2c8d201:         CompactionManager.instance.disableAutoCompaction();
1:2c8d201: 
1:0e96e58:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:2c8d201:         String cfName = "Standard1";
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:2c8d201: 
1:a991b64:         String key = "key1";
1:2c8d201: 
1:2c8d201:         // inserts
1:2c8d201:         for (int i = 0; i < 10; i++)
1:2c8d201:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:a991b64:             builder.clustering(String.valueOf(i))
1:a991b64:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                     .build().applyUnsafe();
1:2c8d201:         }
1:a991b64: 
1:2c8d201:         cfs.forceBlockingFlush();
1:7bc8b02: 
1:b7a173a:         // deletes
3:b7a173a:         for (int i = 0; i < 10; i++)
1:3edb62b:         {
1:a991b64:             RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
7:b7a173a:         }
1:b7a173a:         cfs.forceBlockingFlush();
1:2c8d201: 
1:b7a173a:         // resurrect one column
1:a991b64:         RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 2, key);
1:a991b64:         builder.clustering(String.valueOf(5))
1:a991b64:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                 .build().applyUnsafe();
1:a991b64: 
1:b7a173a:         cfs.forceBlockingFlush();
1:2c8d201: 
1:b7a173a:         // major compact and test that all columns but the resurrected one is completely gone
1:910170c:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, Integer.MAX_VALUE, false));
1:a991b64:         cfs.invalidateCachedPartition(dk(key));
1:a991b64: 
1:e51f83b:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:a991b64:         assertEquals(1, partition.rowCount());
1:b7a173a:     }
1:2c8d201: 
1:b7a173a:     @Test
1:9639f95:     public void testMinorCompactionPurge()
1:b7a173a:     {
1:b7a173a:         CompactionManager.instance.disableAutoCompaction();
1:b7a173a: 
1:0e96e58:         Keyspace keyspace = Keyspace.open(KEYSPACE2);
1:b7a173a:         String cfName = "Standard1";
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:b7a173a: 
1:b7a173a:         for (int k = 1; k <= 2; ++k) {
1:a991b64:             String key = "key" + k;
1:a991b64: 
1:b7a173a:             // inserts
1:b7a173a:             for (int i = 0; i < 10; i++)
1:b7a173a:             {
1:a991b64:                 RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:a991b64:                 builder.clustering(String.valueOf(i))
1:a991b64:                         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                         .build().applyUnsafe();
1:b7a173a:             }
1:b7a173a:             cfs.forceBlockingFlush();
1:b7a173a: 
1:b7a173a:             // deletes
1:b7a173a:             for (int i = 0; i < 10; i++)
1:b7a173a:             {
1:a991b64:                 RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
1:b7a173a:             }
1:b7a173a: 
1:b7a173a:             cfs.forceBlockingFlush();
1:b7a173a:         }
1:b7a173a: 
1:b7a173a:         DecoratedKey key1 = Util.dk("key1");
1:b7a173a:         DecoratedKey key2 = Util.dk("key2");
1:b7a173a: 
1:b7a173a:         // flush, remember the current sstable and then resurrect one column
1:b7a173a:         // for first key. Then submit minor compaction on remembered sstables.
1:b7a173a:         cfs.forceBlockingFlush();
1:ad8cad7:         Collection<SSTableReader> sstablesIncomplete = cfs.getLiveSSTables();
1:a991b64: 
1:a991b64:         RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 2, "key1");
1:a991b64:         builder.clustering(String.valueOf(5))
1:a991b64:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                 .build().applyUnsafe();
1:a991b64: 
1:b7a173a:         cfs.forceBlockingFlush();
1:5a7ff5e:         List<AbstractCompactionTask> tasks = cfs.getCompactionStrategyManager().getUserDefinedTasks(sstablesIncomplete, Integer.MAX_VALUE);
1:5a7ff5e:         assertEquals(1, tasks.size());
1:5a7ff5e:         tasks.get(0).execute(null);
1:b7a173a: 
1:b7a173a:         // verify that minor compaction does GC when key is provably not
1:b7a173a:         // present in a non-compacted sstable
1:a991b64:         Util.assertEmpty(Util.cmd(cfs, key2).build());
1:068b53d: 
1:068b53d:         // verify that minor compaction still GC when key is present
1:068b53d:         // in a non-compacted sstable but the timestamp ensures we won't miss anything
1:e51f83b:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key1).build());
1:a991b64:         assertEquals(1, partition.rowCount());
1:b7a173a:     }
1:b7a173a: 
1:36cdf34:     /**
1:36cdf34:      * verify that we don't drop tombstones during a minor compaction that might still be relevant
1:36cdf34:      */
1:b7a173a:     @Test
1:9639f95:     public void testMinTimestampPurge()
1:b7a173a:     {
1:b7a173a:         CompactionManager.instance.disableAutoCompaction();
1:36cdf34: 
1:0e96e58:         Keyspace keyspace = Keyspace.open(KEYSPACE2);
1:b7a173a:         String cfName = "Standard1";
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:a991b64:         String key3 = "key3";
1:36cdf34: 
1:b7a173a:         // inserts
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 8, key3)
1:a991b64:             .clustering("c1")
1:a991b64:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:             .build().applyUnsafe();
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 8, key3)
1:a991b64:         .clustering("c2")
1:a991b64:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:         .build().applyUnsafe();
1:a991b64: 
1:b7a173a:         cfs.forceBlockingFlush();
1:36cdf34:         // delete c1
1:a991b64:         RowUpdateBuilder.deleteRow(cfs.metadata, 10, key3, "c1").applyUnsafe();
1:a991b64: 
2:ac9f478:         cfs.forceBlockingFlush();
1:ad8cad7:         Collection<SSTableReader> sstablesIncomplete = cfs.getLiveSSTables();
1:b7a173a: 
1:36cdf34:         // delete c2 so we have new delete in a diffrent SSTable
1:a991b64:         RowUpdateBuilder.deleteRow(cfs.metadata, 9, key3, "c2").applyUnsafe();
1:ac9f478:         cfs.forceBlockingFlush();
1:36cdf34: 
1:36cdf34:         // compact the sstables with the c1/c2 data and the c1 tombstone
1:5a7ff5e:         List<AbstractCompactionTask> tasks = cfs.getCompactionStrategyManager().getUserDefinedTasks(sstablesIncomplete, Integer.MAX_VALUE);
1:5a7ff5e:         assertEquals(1, tasks.size());
1:5a7ff5e:         tasks.get(0).execute(null);
1:b7a173a: 
1:36cdf34:         // We should have both the c1 and c2 tombstones still. Since the min timestamp in the c2 tombstone
1:36cdf34:         // sstable is older than the c1 tombstone, it is invalid to throw out the c1 tombstone.
1:e51f83b:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key3).build());
1:a991b64:         assertEquals(2, partition.rowCount());
1:a991b64:         for (Row row : partition)
1:a991b64:             assertFalse(row.hasLiveData(FBUtilities.nowInSeconds()));
1:b7a173a:     }
1:b7a173a: 
1:b7a173a:     @Test
1:9639f95:     public void testCompactionPurgeOneFile() throws ExecutionException, InterruptedException
1:b7a173a:     {
1:b7a173a:         CompactionManager.instance.disableAutoCompaction();
1:b7a173a: 
1:0e96e58:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:b7a173a:         String cfName = "Standard2";
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:b7a173a: 
1:a991b64:         String key = "key1";
1:b7a173a: 
1:b7a173a:         // inserts
1:2c8d201:         for (int i = 0; i < 5; i++)
1:2c8d201:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:a991b64:             builder.clustering(String.valueOf(i))
1:a991b64:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                    .build().applyUnsafe();
1:2c8d201:         }
1:2c8d201: 
1:b7a173a:         // deletes
2:b7a173a:         for (int i = 0; i < 5; i++)
1:2c8d201:         {
1:a991b64:             RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
1:2c8d201:         }
1:b7a173a:         cfs.forceBlockingFlush();
1:ad8cad7:         assertEquals(String.valueOf(cfs.getLiveSSTables()), 1, cfs.getLiveSSTables().size()); // inserts & deletes were in the same memtable -> only deletes in sstable
1:2c8d201: 
1:b7a173a:         // compact and test that the row is completely gone
1:3edb62b:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
1:ad8cad7:         assertTrue(cfs.getLiveSSTables().isEmpty());
1:a991b64: 
1:a991b64:         Util.assertEmpty(Util.cmd(cfs, key).build());
1:2c8d201:     }
1:a991b64: 
1:2c8d201: 
1:2c8d201:     @Test
1:9639f95:     public void testCompactionPurgeCachedRow() throws ExecutionException, InterruptedException
1:2c8d201:     {
1:2c8d201:         CompactionManager.instance.disableAutoCompaction();
1:2c8d201: 
1:d2a3827:         String keyspaceName = KEYSPACE_CACHED;
1:d2a3827:         String cfName = CF_CACHED;
1:0e96e58:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:2c8d201: 
1:a991b64:         String key = "key3";
1:a991b64: 
1:2c8d201:         // inserts
1:2c8d201:         for (int i = 0; i < 10; i++)
1:a991b64:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:a991b64:             builder.clustering(String.valueOf(i))
1:a991b64:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                    .build().applyUnsafe();
1:b7a173a:         }
1:2c8d201: 
1:a991b64:         // deletes partition
1:a991b64:         Mutation rm = new Mutation(KEYSPACE_CACHED, dk(key));
1:a991b64:         rm.add(PartitionUpdate.fullPartitionDelete(cfs.metadata, dk(key), 1, FBUtilities.nowInSeconds()));
1:b453f08:         rm.applyUnsafe();
1:2c8d201: 
1:a991b64:         // Adds another unrelated partition so that the sstable is not considered fully expired. We do not
1:a991b64:         // invalidate the row cache in that latter case.
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 0, "key4").clustering("c").add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER).build().applyUnsafe();
1:2c8d201: 
1:a991b64:         // move the key up in row cache (it should not be empty since we have the partition deletion info)
1:a991b64:         assertFalse(Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build()).isEmpty());
1:b7a173a: 
1:2c8d201:         // flush and major compact
1:b7a173a:         cfs.forceBlockingFlush();
1:3edb62b:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
1:b7a173a: 
1:a991b64:         // Since we've force purging (by passing MAX_VALUE for gc_before), the row should have been invalidated and we should have no deletion info anymore
1:a991b64:         Util.assertEmpty(Util.cmd(cfs, key).build());
1:2c8d201:     }
1:b7a173a: 
1:b7a173a:     @Test
1:9639f95:     public void testCompactionPurgeTombstonedRow() throws ExecutionException, InterruptedException
1:b7a173a:     {
1:b7a173a:         CompactionManager.instance.disableAutoCompaction();
1:b7a173a: 
1:d2a3827:         String keyspaceName = KEYSPACE1;
1:ac9f478:         String cfName = "Standard1";
1:0e96e58:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:a991b64:         String key = "key3";
1:b7a173a: 
1:b7a173a:         // inserts
1:b7a173a:         for (int i = 0; i < 10; i++)
1:b7a173a:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, i, key);
1:a991b64:             builder.clustering(String.valueOf(i))
1:a991b64:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                    .build().applyUnsafe();
1:a991b64:         }
1:a991b64: 
1:a991b64:         // deletes partition with timestamp such that not all columns are deleted
1:a991b64:         Mutation rm = new Mutation(KEYSPACE1, dk(key));
1:a991b64:         rm.add(PartitionUpdate.fullPartitionDelete(cfs.metadata, dk(key), 4, FBUtilities.nowInSeconds()));
2:b453f08:         rm.applyUnsafe();
1:b7a173a: 
1:e51f83b:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:a991b64:         assertFalse(partition.partitionLevelDeletion().isLive());
1:b7a173a: 
1:2c8d201:         // flush and major compact (with tombstone purging)
1:2c8d201:         cfs.forceBlockingFlush();
1:3edb62b:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
1:a991b64:         assertFalse(Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build()).isEmpty());
1:2c8d201: 
2:2c8d201:         // re-inserts with timestamp lower than delete
1:2c8d201:         for (int i = 0; i < 5; i++)
1:a991b64:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, i, key);
1:a991b64:             builder.clustering(String.valueOf(i))
1:a991b64:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                    .build().applyUnsafe();
1:a991b64:         }
1:2c8d201: 
1:3edb62b:         // Check that the second insert went in
1:a991b64:         partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:a991b64:         assertEquals(10, partition.rowCount());
1:2c8d201:     }
1:a991b64: 
1:3edb62b: 
1:3edb62b:     @Test
1:c87b6a3:     public void testRowTombstoneObservedBeforePurging()
1:2c8d201:     {
1:3edb62b:         String keyspace = "cql_keyspace";
1:3edb62b:         String table = "table1";
1:3edb62b:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:3edb62b:         cfs.disableAutoCompaction();
1:3edb62b: 
1:3edb62b:         // write a row out to one sstable
1:a991b64:         QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
1:a991b64:                                                      keyspace, table, 1, "foo", 1));
1:3edb62b:         cfs.forceBlockingFlush();
1:3edb62b: 
1:a991b64:         UntypedResultSet result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         assertEquals(1, result.size());
1:3edb62b: 
1:3edb62b:         // write a row tombstone out to a second sstable
1:a991b64:         QueryProcessor.executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         cfs.forceBlockingFlush();
1:3edb62b: 
1:3edb62b:         // basic check that the row is considered deleted
1:ad8cad7:         assertEquals(2, cfs.getLiveSSTables().size());
1:a991b64:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         assertEquals(0, result.size());
1:3edb62b: 
1:3edb62b:         // compact the two sstables with a gcBefore that does *not* allow the row tombstone to be purged
1:910170c:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) - 10000, false));
1:3edb62b: 
1:3edb62b:         // the data should be gone, but the tombstone should still exist
1:ad8cad7:         assertEquals(1, cfs.getLiveSSTables().size());
1:a991b64:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         assertEquals(0, result.size());
1:3edb62b: 
1:3edb62b:         // write a row out to one sstable
1:a991b64:         QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
1:a991b64:                                                      keyspace, table, 1, "foo", 1));
1:3edb62b:         cfs.forceBlockingFlush();
1:ad8cad7:         assertEquals(2, cfs.getLiveSSTables().size());
1:a991b64:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         assertEquals(1, result.size());
1:3edb62b: 
1:3edb62b:         // write a row tombstone out to a different sstable
1:a991b64:         QueryProcessor.executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         cfs.forceBlockingFlush();
1:3edb62b: 
1:3edb62b:         // compact the two sstables with a gcBefore that *does* allow the row tombstone to be purged
1:910170c:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) + 10000, false));
1:3edb62b: 
1:3edb62b:         // both the data and the tombstone should be gone this time
1:ad8cad7:         assertEquals(0, cfs.getLiveSSTables().size());
1:a991b64:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:3edb62b:         assertEquals(0, result.size());
1:362cc05:     }
1:3edb62b: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:5a7ff5e
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         List<AbstractCompactionTask> tasks = cfs.getCompactionStrategyManager().getUserDefinedTasks(sstablesIncomplete, Integer.MAX_VALUE);
1:         assertEquals(1, tasks.size());
1:         tasks.get(0).execute(null);
/////////////////////////////////////////////////////////////////////////
1:         List<AbstractCompactionTask> tasks = cfs.getCompactionStrategyManager().getUserDefinedTasks(sstablesIncomplete, Integer.MAX_VALUE);
1:         assertEquals(1, tasks.size());
1:         tasks.get(0).execute(null);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
/////////////////////////////////////////////////////////////////////////
1:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
/////////////////////////////////////////////////////////////////////////
1:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key1).build());
/////////////////////////////////////////////////////////////////////////
1:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key3).build());
/////////////////////////////////////////////////////////////////////////
1:         ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1:         Collection<SSTableReader> sstablesIncomplete = cfs.getLiveSSTables();
/////////////////////////////////////////////////////////////////////////
1:         Collection<SSTableReader> sstablesIncomplete = cfs.getLiveSSTables();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(String.valueOf(cfs.getLiveSSTables()), 1, cfs.getLiveSSTables().size()); // inserts & deletes were in the same memtable -> only deletes in sstable
1:         assertTrue(cfs.getLiveSSTables().isEmpty());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, cfs.getLiveSSTables().size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, cfs.getLiveSSTables().size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, cfs.getLiveSSTables().size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, cfs.getLiveSSTables().size());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:b31845c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.CachingParams;
1: import static org.apache.cassandra.Util.dk;
/////////////////////////////////////////////////////////////////////////
1:                                     SchemaLoader.standardCFMD(KEYSPACE_CACHED, CF_CACHED).caching(CachingParams.CACHE_EVERYTHING));
commit:a89597d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2));
1:                                     KeyspaceParams.simple(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
1:                                     KeyspaceParams.simple(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE_CACHED, CF_CACHED).caching(CachingOptions.ALL));
1:                                     KeyspaceParams.simple(1),
1:                                     CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
1:                                             + "k int PRIMARY KEY,"
1:                                             + "v1 text,"
1:                                             + "v2 int"
1:                                             + ")", KEYSPACE_CQL));
commit:b35486a
commit:4485e6d
/////////////////////////////////////////////////////////////////////////
0:         assertFalse(cf.getColumn(cellname("c2")).isLive());
/////////////////////////////////////////////////////////////////////////
0:             assert c.isLive();
/////////////////////////////////////////////////////////////////////////
0:             assert c.isLive();
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.*;
1: 
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:             rm = new Mutation(KEYSPACE1, key.key);
0:         rm = new Mutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:             rm = new Mutation(KEYSPACE2, key.key);
/////////////////////////////////////////////////////////////////////////
0:                 rm = new Mutation(KEYSPACE2, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE2, key1.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation(KEYSPACE2, key3.key);
0:         rm = new Mutation(KEYSPACE2, key3.key);
0:         rm = new Mutation(KEYSPACE2, key3.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:             rm = new Mutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation(keyspaceName, key.key);
0:         rm = new Mutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.key);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.db.KeyspaceTest.assertColumns;
0:     public static final String KEYSPACE1 = "Keyspace1";
0:     public static final String KEYSPACE2 = "Keyspace2";
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:         rm = new RowMutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:             rm = new RowMutation(KEYSPACE1, key.key);
0:         rm = new RowMutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE2);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:             rm = new RowMutation(KEYSPACE2, key.key);
/////////////////////////////////////////////////////////////////////////
0:                 rm = new RowMutation(KEYSPACE2, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation(KEYSPACE2, key1.key);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE2);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:         rm = new RowMutation(KEYSPACE2, key3.key);
0:         rm = new RowMutation(KEYSPACE2, key3.key);
0:         rm = new RowMutation(KEYSPACE2, key3.key);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:         rm = new RowMutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:             rm = new RowMutation(KEYSPACE1, key.key);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = keyspace.getColumnFamilyStore(cfName).getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         String keyspaceName = "RowCacheSpace";
1:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:         rm = new RowMutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         String keyspaceName = "Keyspace1";
1:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
0:         rm = new RowMutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation(keyspaceName, key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation(keyspaceName, key.key);
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key2, cfName, System.currentTimeMillis()));
0:         cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key1, cfName, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, cfName, System.currentTimeMillis()));
0:         Assert.assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive(System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = table.getColumnFamilyStore(cfName).getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
0:             assert !c.isMarkedForDelete(System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis()));
0:             assert !c.isMarkedForDelete(System.currentTimeMillis());
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cache.CachingOptions;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.UntypedResultSet;
0: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.db.rows.Row;
0: import org.apache.cassandra.db.partitions.ArrayBackedPartition;
1: import org.apache.cassandra.db.partitions.PartitionUpdate;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: import static org.apache.cassandra.Util.dk;
1: import static org.junit.Assert.*;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 SimpleStrategy.class,
0:                 KSMetaData.optsWithRF(1),
0:                 SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
0:                 SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2));
0:                 SimpleStrategy.class,
0:                 KSMetaData.optsWithRF(1),
0:                 SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
0:                 SimpleStrategy.class,
0:                 KSMetaData.optsWithRF(1),
0:                 SchemaLoader.standardCFMD(KEYSPACE_CACHED, CF_CACHED).caching(CachingOptions.ALL));
0:                 SimpleStrategy.class,
0:                 KSMetaData.optsWithRF(1),
0:                 CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
0:                         + "k int PRIMARY KEY,"
0:                         + "v1 text,"
0:                         + "v2 int"
0:                         + ")", KEYSPACE_CQL));
/////////////////////////////////////////////////////////////////////////
1:         String key = "key1";
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:             builder.clustering(String.valueOf(i))
1:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                     .build().applyUnsafe();
1: 
1:             RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
1:         RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 2, key);
1:         builder.clustering(String.valueOf(5))
1:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                 .build().applyUnsafe();
1: 
1:         cfs.invalidateCachedPartition(dk(key));
1: 
0:         ArrayBackedPartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:         assertEquals(1, partition.rowCount());
/////////////////////////////////////////////////////////////////////////
1:             String key = "key" + k;
1:                 RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:                 builder.clustering(String.valueOf(i))
1:                         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                         .build().applyUnsafe();
1:                 RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 2, "key1");
1:         builder.clustering(String.valueOf(5))
1:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                 .build().applyUnsafe();
1: 
1:         Util.assertEmpty(Util.cmd(cfs, key2).build());
0:         ArrayBackedPartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key1).build());
1:         assertEquals(1, partition.rowCount());
/////////////////////////////////////////////////////////////////////////
1:         String key3 = "key3";
1:         new RowUpdateBuilder(cfs.metadata, 8, key3)
1:             .clustering("c1")
1:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:             .build().applyUnsafe();
1: 
1:         new RowUpdateBuilder(cfs.metadata, 8, key3)
1:         .clustering("c2")
1:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:         .build().applyUnsafe();
1: 
1:         RowUpdateBuilder.deleteRow(cfs.metadata, 10, key3, "c1").applyUnsafe();
1: 
1:         RowUpdateBuilder.deleteRow(cfs.metadata, 9, key3, "c2").applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         ArrayBackedPartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key3).build());
1:         assertEquals(2, partition.rowCount());
1:         for (Row row : partition)
1:             assertFalse(row.hasLiveData(FBUtilities.nowInSeconds()));
/////////////////////////////////////////////////////////////////////////
1:         String key = "key1";
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:             builder.clustering(String.valueOf(i))
1:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                    .build().applyUnsafe();
1:             RowUpdateBuilder.deleteRow(cfs.metadata, 1, key, String.valueOf(i)).applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1: 
1:         Util.assertEmpty(Util.cmd(cfs, key).build());
1: 
/////////////////////////////////////////////////////////////////////////
1:         String key = "key3";
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0, key);
1:             builder.clustering(String.valueOf(i))
1:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                    .build().applyUnsafe();
1: 
1:         // deletes partition
1:         Mutation rm = new Mutation(KEYSPACE_CACHED, dk(key));
1:         rm.add(PartitionUpdate.fullPartitionDelete(cfs.metadata, dk(key), 1, FBUtilities.nowInSeconds()));
1:         // Adds another unrelated partition so that the sstable is not considered fully expired. We do not
1:         // invalidate the row cache in that latter case.
1:         new RowUpdateBuilder(cfs.metadata, 0, "key4").clustering("c").add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER).build().applyUnsafe();
1:         // move the key up in row cache (it should not be empty since we have the partition deletion info)
1:         assertFalse(Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build()).isEmpty());
1:         // Since we've force purging (by passing MAX_VALUE for gc_before), the row should have been invalidated and we should have no deletion info anymore
1:         Util.assertEmpty(Util.cmd(cfs, key).build());
/////////////////////////////////////////////////////////////////////////
1:         String key = "key3";
1:         {
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, i, key);
1:             builder.clustering(String.valueOf(i))
1:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                    .build().applyUnsafe();
1:         }
1: 
1:         // deletes partition with timestamp such that not all columns are deleted
1:         Mutation rm = new Mutation(KEYSPACE1, dk(key));
1:         rm.add(PartitionUpdate.fullPartitionDelete(cfs.metadata, dk(key), 4, FBUtilities.nowInSeconds()));
0:         ArrayBackedPartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:         assertFalse(partition.partitionLevelDeletion().isLive());
1:         assertFalse(Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build()).isEmpty());
1:         {
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, i, key);
1:             builder.clustering(String.valueOf(i))
1:                    .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                    .build().applyUnsafe();
1:         }
1:         partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:         assertEquals(10, partition.rowCount());
1: 
/////////////////////////////////////////////////////////////////////////
1:         QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
1:                                                      keyspace, table, 1, "foo", 1));
1:         UntypedResultSet result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         QueryProcessor.executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
/////////////////////////////////////////////////////////////////////////
1:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
1:                                                      keyspace, table, 1, "foo", 1));
1:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         QueryProcessor.executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
/////////////////////////////////////////////////////////////////////////
1:         result = QueryProcessor.executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
commit:5f643ff
commit:1147ee3
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
/////////////////////////////////////////////////////////////////////////
0:         executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
0:         UntypedResultSet result = executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
0:         executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
0:         result = executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
/////////////////////////////////////////////////////////////////////////
0:         result = executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
0:         executeInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
0:         result = executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
0:         executeInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
/////////////////////////////////////////////////////////////////////////
0:         result = executeInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
commit:7d7610f
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Cell;
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf)
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf)
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.cellname;
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.delete(cfName, cellname(String.valueOf(i)), 1);
0:         rm.add(cfName, cellname(String.valueOf(5)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
/////////////////////////////////////////////////////////////////////////
0:         assert cf.getColumn(cellname(String.valueOf(5))) != null;
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:                 rm.delete(cfName, cellname(String.valueOf(i)), 1);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, cellname(String.valueOf(5)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, cellname("c1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.add(cfName, cellname("c2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.delete(cfName, cellname("c1"), 10);
0:         rm.delete(cfName, cellname("c2"), 9);
/////////////////////////////////////////////////////////////////////////
0:         assertFalse(cf.getColumn(cellname("c2")).isLive(System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.delete(cfName, cellname(String.valueOf(i)), 1);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, cellname(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
/////////////////////////////////////////////////////////////////////////
1: }
commit:068b53d
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key2, new QueryPath(cfName)));
1: 
1:         // verify that minor compaction still GC when key is present
1:         // in a non-compacted sstable but the timestamp ensures we won't miss anything
0:         cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key1, new QueryPath(cfName)));
0:         Assert.assertEquals(1, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals(2, cf.getColumnCount());
commit:7bc8b02
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key2, cfName));
1: 
0:         // verify that minor compaction still GC when key is present
0:         // in a non-compacted sstable but the timestamp ensures we won't miss anything
0:         cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key1, cfName));
0:         Assert.assertEquals(1, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals(2, cf.getColumnCount());
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Column;
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.delete(cfName, ByteBufferUtil.bytes(String.valueOf(i)), 1);
0:         rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(5)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName));
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:                 rm.delete(cfName, ByteBufferUtil.bytes(String.valueOf(i)), 1);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(5)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key1, cfName));
0:         cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key2, cfName));
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, ByteBufferUtil.bytes("c1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.add(cfName, ByteBufferUtil.bytes("c2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.delete(cfName, ByteBufferUtil.bytes("c1"), 10);
0:         rm.delete(cfName, ByteBufferUtil.bytes("c2"), 9);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, cfName));
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
/////////////////////////////////////////////////////////////////////////
0:             rm.delete(cfName, ByteBufferUtil.bytes(String.valueOf(i)), 1);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = table.getColumnFamilyStore(cfName).getColumnFamily(QueryFilter.getIdentityFilter(key, cfName));
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
0:         cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName));
0:         rm.delete(cfName, 1);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName));
0:         for (Column c : cf)
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
0:         rm.delete(cfName, 4);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(cfName, ByteBufferUtil.bytes(String.valueOf(i)), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, cfName));
0:         for (Column c : cf)
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class CompactionsPurgeTest extends SchemaLoader
commit:2c8d201
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SuperColumn;
/////////////////////////////////////////////////////////////////////////
0:     public void testCompactionPurgeCachedRow() throws IOException, ExecutionException, InterruptedException
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testCompactionPurgeTombstonedRow() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         String tableName = "Keyspace1";
1:         String cfName = "Standard1";
0:         Table table = Table.open(tableName);
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         DecoratedKey key = Util.dk("key3");
0:         RowMutation rm;
1: 
1:         // inserts
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
1:         }
0:         rm.apply();
1: 
0:         // deletes row with timestamp such that not all columns are deleted
0:         rm = new RowMutation(tableName, key.key);
0:         rm.delete(new QueryPath(cfName, null, null), 4);
0:         rm.apply();
1: 
1:         // flush and major compact (with tombstone purging)
1:         cfs.forceBlockingFlush();
0:         Util.compactAll(cfs).get();
1: 
1:         // re-inserts with timestamp lower than delete
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 5; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
1:         }
0:         rm.apply();
1: 
0:         // Check that the second insert did went in
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
0:         assertEquals(10, cf.getColumnCount());
0:         for (IColumn c : cf)
0:             assert !c.isMarkedForDelete();
1:     }
1: 
1:     @Test
0:     public void testCompactionPurgeTombstonedSuperColumn() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         String tableName = "Keyspace1";
0:         String cfName = "Super5";
0:         Table table = Table.open(tableName);
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         DecoratedKey key = Util.dk("key5");
0:         RowMutation rm;
1: 
0:         ByteBuffer scName = ByteBufferUtil.bytes("sc");
1: 
1:         // inserts
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm.add(new QueryPath(cfName, scName, ByteBuffer.wrap(String.valueOf(i).getBytes())), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
1:         }
0:         rm.apply();
1: 
0:         // deletes supercolumn with timestamp such that not all columns go
0:         rm = new RowMutation(tableName, key.key);
0:         rm.delete(new QueryPath(cfName, scName, null), 4);
0:         rm.apply();
1: 
1:         // flush and major compact
1:         cfs.forceBlockingFlush();
0:         Util.compactAll(cfs).get();
1: 
1:         // re-inserts with timestamp lower than delete
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 5; i++)
1:         {
0:             rm.add(new QueryPath(cfName, scName, ByteBuffer.wrap(String.valueOf(i).getBytes())), ByteBufferUtil.EMPTY_BYTE_BUFFER, i);
1:         }
0:         rm.apply();
1: 
0:         // Check that the second insert did went in
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
0:         SuperColumn sc = (SuperColumn)cf.getColumn(scName);
0:         assert sc != null;
0:         assertEquals(10, sc.getColumnCount());
1:     }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:7df3a5c
/////////////////////////////////////////////////////////////////////////
0:         cfs.getCompactionStrategyManager().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
/////////////////////////////////////////////////////////////////////////
0:         cfs.getCompactionStrategyManager().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
commit:910170c
/////////////////////////////////////////////////////////////////////////
1:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, Integer.MAX_VALUE, false));
/////////////////////////////////////////////////////////////////////////
1:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) - 10000, false));
/////////////////////////////////////////////////////////////////////////
1:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) + 10000, false));
commit:31099a1
commit:c45ed17
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, Integer.MAX_VALUE));
/////////////////////////////////////////////////////////////////////////
0:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) - 10000));
/////////////////////////////////////////////////////////////////////////
0:         FBUtilities.waitOnFutures(CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) + 10000));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:c87b6a3
/////////////////////////////////////////////////////////////////////////
1:     public void testMajorCompactionPurge()
/////////////////////////////////////////////////////////////////////////
1:     public void testRowTombstoneObservedBeforePurging()
commit:630d3b9
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
/////////////////////////////////////////////////////////////////////////
0:         assertNotNull(cf.getColumn(cellname(String.valueOf(5))));
/////////////////////////////////////////////////////////////////////////
0:         assertNull(cf);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(String.valueOf(cfs.getSSTables()), 1, cfs.getSSTables().size()); // inserts & deletes were in the same memtable -> only deletes in sstable
0:         assertTrue(cfs.getSSTables().isEmpty());
0:         assertNull(String.valueOf(cf), cf);
/////////////////////////////////////////////////////////////////////////
0:             assertFalse(c.isMarkedForDelete(System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:             assertFalse(c.isMarkedForDelete(System.currentTimeMillis()));
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void testMajorCompactionPurge() throws ExecutionException, InterruptedException
/////////////////////////////////////////////////////////////////////////
1:     public void testMinorCompactionPurge()
/////////////////////////////////////////////////////////////////////////
1:     public void testMinTimestampPurge()
/////////////////////////////////////////////////////////////////////////
1:     public void testCompactionPurgeOneFile() throws ExecutionException, InterruptedException
/////////////////////////////////////////////////////////////////////////
1:     public void testCompactionPurgeCachedRow() throws ExecutionException, InterruptedException
/////////////////////////////////////////////////////////////////////////
1:     public void testCompactionPurgeTombstonedRow() throws ExecutionException, InterruptedException
/////////////////////////////////////////////////////////////////////////
0:     public void testRowTombstoneObservedBeforePurging() throws InterruptedException, ExecutionException
/////////////////////////////////////////////////////////////////////////
0:         Future<?> future = CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) - 10000);
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Assert;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
commit:bc6b5f4
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
/////////////////////////////////////////////////////////////////////////
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
1:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1:             rm.applyUnsafe();
1:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:                 rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cache.CachingOptions;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1: public class CompactionsPurgeTest
1:     private static final String KEYSPACE1 = "CompactionsPurgeTest1";
1:     private static final String CF_STANDARD1 = "Standard1";
1:     private static final String CF_STANDARD2 = "Standard2";
1:     private static final String KEYSPACE2 = "CompactionsPurgeTest2";
1:     private static final String KEYSPACE_CACHED = "CompactionsPurgeTestCached";
1:     private static final String CF_CACHED = "CachedCF";
1:     private static final String KEYSPACE_CQL = "cql_keyspace";
1:     private static final String CF_CQL = "table1";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2));
1:         SchemaLoader.createKeyspace(KEYSPACE2,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
1:         SchemaLoader.createKeyspace(KEYSPACE_CACHED,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE_CACHED, CF_CACHED).caching(CachingOptions.ALL));
1:         SchemaLoader.createKeyspace(KEYSPACE_CQL,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
0:                                                      + "k int PRIMARY KEY,"
0:                                                      + "v1 text,"
0:                                                      + "v2 int"
0:                                                      + ")", KEYSPACE_CQL));
1:     }
/////////////////////////////////////////////////////////////////////////
1:         String keyspaceName = KEYSPACE_CACHED;
1:         String cfName = CF_CACHED;
/////////////////////////////////////////////////////////////////////////
1:         String keyspaceName = KEYSPACE1;
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:             rm = new Mutation(KEYSPACE1, key.getKey());
0:         rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:             rm = new Mutation(KEYSPACE2, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:                 rm = new Mutation(KEYSPACE2, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE2, key1.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE2, key3.getKey());
0:         rm = new Mutation(KEYSPACE2, key3.getKey());
0:         rm = new Mutation(KEYSPACE2, key3.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:             rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.getKey());
0:         rm = new Mutation(keyspaceName, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(keyspaceName, key.getKey());
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:d53c838
commit:3edb62b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Future;
0: import org.apache.cassandra.cql3.UntypedResultSet;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertTrue;
0: import static org.apache.cassandra.cql3.QueryProcessor.processInternal;
1: 
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(1, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
0:         assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive(System.currentTimeMillis()));
0:         assertEquals(2, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
1:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
/////////////////////////////////////////////////////////////////////////
1:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter filter = QueryFilter.getIdentityFilter(key, cfName, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(filter);
0:         assertTrue(cf.isMarkedForDelete());
1:         Util.compactAll(cfs, Integer.MAX_VALUE).get();
0:         assertFalse(cfs.getColumnFamily(filter).isMarkedForDelete());
/////////////////////////////////////////////////////////////////////////
1:         // Check that the second insert went in
0:         cf = cfs.getColumnFamily(filter);
1: 
1:     @Test
0:     public void testRowTombstoneObservedBeforePurging() throws InterruptedException, ExecutionException, IOException
1:     {
1:         String keyspace = "cql_keyspace";
1:         String table = "table1";
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:         cfs.disableAutoCompaction();
1: 
1:         // write a row out to one sstable
0:         processInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
0:                                       keyspace, table, 1, "foo", 1));
1:         cfs.forceBlockingFlush();
1: 
0:         UntypedResultSet result = processInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         assertEquals(1, result.size());
1: 
1:         // write a row tombstone out to a second sstable
0:         processInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         cfs.forceBlockingFlush();
1: 
1:         // basic check that the row is considered deleted
0:         assertEquals(2, cfs.getSSTables().size());
0:         result = processInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         assertEquals(0, result.size());
1: 
1:         // compact the two sstables with a gcBefore that does *not* allow the row tombstone to be purged
0:         Future future = CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) - 10000);
0:         future.get();
1: 
1:         // the data should be gone, but the tombstone should still exist
0:         assertEquals(1, cfs.getSSTables().size());
0:         result = processInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         assertEquals(0, result.size());
1: 
1:         // write a row out to one sstable
0:         processInternal(String.format("INSERT INTO %s.%s (k, v1, v2) VALUES (%d, '%s', %d)",
0:                                       keyspace, table, 1, "foo", 1));
1:         cfs.forceBlockingFlush();
0:         assertEquals(2, cfs.getSSTables().size());
0:         result = processInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         assertEquals(1, result.size());
1: 
1:         // write a row tombstone out to a different sstable
0:         processInternal(String.format("DELETE FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         cfs.forceBlockingFlush();
1: 
1:         // compact the two sstables with a gcBefore that *does* allow the row tombstone to be purged
0:         future = CompactionManager.instance.submitMaximal(cfs, (int) (System.currentTimeMillis() / 1000) + 10000);
0:         future.get();
1: 
1:         // both the data and the tombstone should be gone this time
0:         assertEquals(0, cfs.getSSTables().size());
0:         result = processInternal(String.format("SELECT * FROM %s.%s WHERE k = %d", keyspace, table, 1));
1:         assertEquals(0, result.size());
1:     }
commit:36cdf34
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertFalse;
1: 
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(1, cf.getColumnCount());
1:     /**
1:      * verify that we don't drop tombstones during a minor compaction that might still be relevant
1:      */
1: 
1: 
1:         // delete c1
1:         // delete c2 so we have new delete in a diffrent SSTable
1: 
1:         // compact the sstables with the c1/c2 data and the c1 tombstone
1:         // We should have both the c1 and c2 tombstones still. Since the min timestamp in the c2 tombstone
1:         // sstable is older than the c1 tombstone, it is invalid to throw out the c1 tombstone.
0:         assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive(System.currentTimeMillis()));
0:         assertEquals(2, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Check that the second insert went in
commit:9190751
/////////////////////////////////////////////////////////////////////////
0:         // verify that we don't drop tombstones during a minor compaction that might still be relevant
/////////////////////////////////////////////////////////////////////////
0:         // we should have both the c1 and c2 tombstones still, since the c2 timestamp is older than the c1 tombstone
0:         // so it would be invalid to assume we can throw out the c1 entry.
0:         Assert.assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());
commit:a143966
/////////////////////////////////////////////////////////////////////////
0:         // verify that we don't drop tombstones during a minor compaction that might still be relevant
/////////////////////////////////////////////////////////////////////////
0:         // we should have both the c1 and c2 tombstones still, since the c2 timestamp is older than the c1 tombstone
0:         // so it would be invalid to assume we can throw out the c1 entry.
0:         Assert.assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());
commit:4042ef2
commit:686f516
/////////////////////////////////////////////////////////////////////////
0:         cfs.getCompactionStrategy().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
/////////////////////////////////////////////////////////////////////////
0:         cfs.getCompactionStrategy().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
commit:e70e733
/////////////////////////////////////////////////////////////////////////
0:         CompactionManager.instance.submitMaximal(cfs, Integer.MAX_VALUE).get();
commit:129d80a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         CompactionManager.instance.submitMajor(cfs, Integer.MAX_VALUE).get();
/////////////////////////////////////////////////////////////////////////
0:         new CompactionTask(cfs, sstablesIncomplete, Integer.MAX_VALUE).execute(null);
commit:b7a173a
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db.compaction;
1: 
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
1: import java.util.Collection;
0: import java.util.Collections;
1: import java.util.concurrent.ExecutionException;
1: 
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.db.IColumn;
0: import org.apache.cassandra.db.Table;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.RowMutation;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.filter.QueryFilter;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.io.sstable.Descriptor;
0: import org.apache.cassandra.io.sstable.SSTableReader;
1: import org.apache.cassandra.Util;
1: 
0: import static junit.framework.Assert.assertEquals;
0: import static org.apache.cassandra.db.TableTest.assertColumns;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: 
0: public class CompactionsPurgeTest extends CleanupHelper
1: {
0:     public static final String TABLE1 = "Keyspace1";
0:     public static final String TABLE2 = "Keyspace2";
1: 
1:     @Test
0:     public void testMajorCompactionPurge() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         Table table = Table.open(TABLE1);
1:         String cfName = "Standard1";
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         DecoratedKey key = Util.dk("key1");
0:         RowMutation rm;
1: 
1:         // inserts
0:         rm = new RowMutation(TABLE1, key.key);
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:         }
0:         rm.apply();
1:         cfs.forceBlockingFlush();
1: 
1:         // deletes
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm = new RowMutation(TABLE1, key.key);
0:             rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), 1);
0:             rm.apply();
1:         }
1:         cfs.forceBlockingFlush();
1: 
1:         // resurrect one column
0:         rm = new RowMutation(TABLE1, key.key);
0:         rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(5))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
0:         rm.apply();
1:         cfs.forceBlockingFlush();
1: 
1:         // major compact and test that all columns but the resurrected one is completely gone
0:         CompactionManager.instance.submitMajor(cfs, 0, Integer.MAX_VALUE).get();
0:         cfs.invalidateCachedRow(key);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
0:         assertColumns(cf, "5");
0:         assert cf.getColumn(ByteBufferUtil.bytes(String.valueOf(5))) != null;
1:     }
1: 
1:     @Test
0:     public void testMinorCompactionPurge() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         Table table = Table.open(TABLE2);
1:         String cfName = "Standard1";
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         RowMutation rm;
1:         for (int k = 1; k <= 2; ++k) {
0:             DecoratedKey key = Util.dk("key" + k);
1: 
1:             // inserts
0:             rm = new RowMutation(TABLE2, key.key);
1:             for (int i = 0; i < 10; i++)
1:             {
0:                 rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:             }
0:             rm.apply();
1:             cfs.forceBlockingFlush();
1: 
1:             // deletes
1:             for (int i = 0; i < 10; i++)
1:             {
0:                 rm = new RowMutation(TABLE2, key.key);
0:                 rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), 1);
0:                 rm.apply();
1:             }
1:             cfs.forceBlockingFlush();
1:         }
1: 
1:         DecoratedKey key1 = Util.dk("key1");
1:         DecoratedKey key2 = Util.dk("key2");
1: 
1:         // flush, remember the current sstable and then resurrect one column
1:         // for first key. Then submit minor compaction on remembered sstables.
1:         cfs.forceBlockingFlush();
0:         Collection<SSTableReader> sstablesIncomplete = cfs.getSSTables();
0:         rm = new RowMutation(TABLE2, key1.key);
0:         rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(5))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
0:         rm.apply();
1:         cfs.forceBlockingFlush();
0:         CompactionManager.instance.doCompaction(cfs, sstablesIncomplete, Integer.MAX_VALUE);
1: 
0:         // verify that minor compaction does not GC when key is present
0:         // in a non-compacted sstable
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key1, new QueryPath(cfName)));
0:         assert cf.getColumnCount() == 10;
1: 
1:         // verify that minor compaction does GC when key is provably not
1:         // present in a non-compacted sstable
0:         cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key2, new QueryPath(cfName)));
0:         assert cf == null;
1:     }
1: 
1:     @Test
0:     public void testCompactionPurgeOneFile() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         Table table = Table.open(TABLE1);
1:         String cfName = "Standard2";
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         DecoratedKey key = Util.dk("key1");
0:         RowMutation rm;
1: 
1:         // inserts
0:         rm = new RowMutation(TABLE1, key.key);
1:         for (int i = 0; i < 5; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:         }
0:         rm.apply();
1: 
1:         // deletes
1:         for (int i = 0; i < 5; i++)
1:         {
0:             rm = new RowMutation(TABLE1, key.key);
0:             rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), 1);
0:             rm.apply();
1:         }
1:         cfs.forceBlockingFlush();
0:         assert cfs.getSSTables().size() == 1 : cfs.getSSTables(); // inserts & deletes were in the same memtable -> only deletes in sstable
1: 
1:         // compact and test that the row is completely gone
0:         Util.compactAll(cfs).get();
0:         assert cfs.getSSTables().isEmpty();
0:         ColumnFamily cf = table.getColumnFamilyStore(cfName).getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
0:         assert cf == null : cf;
1:     }
1: 
1:     @Test
0:     public void testCompactionPurgeTombstonedRow() throws IOException, ExecutionException, InterruptedException
1:     {
1:         CompactionManager.instance.disableAutoCompaction();
1: 
0:         String tableName = "RowCacheSpace";
0:         String cfName = "CachedCF";
0:         Table table = Table.open(tableName);
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
0:         DecoratedKey key = Util.dk("key3");
0:         RowMutation rm;
1: 
1:         // inserts
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:         }
0:         rm.apply();
1: 
0:         // move the key up in row cache
0:         cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
1: 
0:         // deletes row
0:         rm = new RowMutation(tableName, key.key);
0:         rm.delete(new QueryPath(cfName, null, null), 1);
0:         rm.apply();
1: 
0:         // flush and major compact
1:         cfs.forceBlockingFlush();
0:         Util.compactAll(cfs).get();
1: 
0:         // re-inserts with timestamp lower than delete
0:         rm = new RowMutation(tableName, key.key);
1:         for (int i = 0; i < 10; i++)
1:         {
0:             rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(i))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:         }
0:         rm.apply();
1: 
0:         // Check that the second insert did went in
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
0:         assertEquals(10, cf.getColumnCount());
0:         for (IColumn c : cf)
0:             assert !c.isMarkedForDelete();
1:     }
1: }
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:ac9f478
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.Assert;
0: 
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals(10, cf.getColumnCount());
/////////////////////////////////////////////////////////////////////////
0:     public void testMinTimestampPurge() throws IOException, ExecutionException, InterruptedException
0:     {
0:         CompactionManager.instance.disableAutoCompaction();
0:         Table table = Table.open(TABLE2);
1:         String cfName = "Standard1";
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
0: 
0:         RowMutation rm;
0:         DecoratedKey key3 = Util.dk("key3");
0:         // inserts
0:         rm = new RowMutation(TABLE2, key3.key);
0:         rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("c1")), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("c2")), ByteBufferUtil.EMPTY_BYTE_BUFFER, 8);
0:         rm.apply();
1:         cfs.forceBlockingFlush();
0:         // deletes
0:         rm = new RowMutation(TABLE2, key3.key);
0:         rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes("c1")), 10);
0:         rm.apply();
1:         cfs.forceBlockingFlush();
0:         Collection<SSTableReader> sstablesIncomplete = cfs.getSSTables();
0: 
0:         // delete so we have new delete in a diffrent SST.
0:         rm = new RowMutation(TABLE2, key3.key);
0:         rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes("c2")), 9);
0:         rm.apply();
1:         cfs.forceBlockingFlush();
0:         new CompactionTask(cfs, sstablesIncomplete, Integer.MAX_VALUE).execute(null);
0: 
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, new QueryPath(cfName)));
0:         Assert.assertTrue(!cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());
0:         Assert.assertEquals(1, cf.getColumnCount());
0:     }
0: 
0:     @Test
============================================================================