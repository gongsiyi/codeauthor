2:91bdf7f: /*
1:91bdf7f:  * Licensed to the Apache Software Foundation (ASF) under one
1:91bdf7f:  * or more contributor license agreements.  See the NOTICE file
1:91bdf7f:  * distributed with this work for additional information
1:91bdf7f:  * regarding copyright ownership.  The ASF licenses this file
1:91bdf7f:  * to you under the Apache License, Version 2.0 (the
1:91bdf7f:  * "License"); you may not use this file except in compliance
1:91bdf7f:  * with the License.  You may obtain a copy of the License at
1:91bdf7f:  *
1:91bdf7f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:91bdf7f:  *
1:91bdf7f:  * Unless required by applicable law or agreed to in writing, software
1:91bdf7f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:91bdf7f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:91bdf7f:  * See the License for the specific language governing permissions and
1:91bdf7f:  * limitations under the License.
2:91bdf7f:  */
1:91bdf7f: package org.apache.cassandra.db.marshal;
16:91bdf7f: 
1:91bdf7f: import java.nio.ByteBuffer;
1:91bdf7f: import java.util.*;
1:91bdf7f: 
1:b7be198: import org.apache.cassandra.cql3.Json;
1:c7b02d1: import org.apache.cassandra.cql3.Lists;
1:c7b02d1: import org.apache.cassandra.cql3.Term;
1:a991b64: import org.apache.cassandra.db.rows.Cell;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:3b299c4: import org.apache.cassandra.serializers.CollectionSerializer;
1:c7b02d1: import org.apache.cassandra.serializers.MarshalException;
1:fc8b76f: import org.apache.cassandra.serializers.ListSerializer;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:c7b02d1: 
1:ee55f36: import org.slf4j.Logger;
1:ee55f36: import org.slf4j.LoggerFactory;
1:91bdf7f: 
1:5e5fbc6: public class ListType<T> extends CollectionType<List<T>>
22:91bdf7f: {
1:ee55f36:     private static final Logger logger = LoggerFactory.getLogger(ListType.class);
1:f634ac7: 
1:ee55f36:     // interning instances
1:ee55f36:     private static final Map<AbstractType<?>, ListType> instances = new HashMap<>();
1:ee55f36:     private static final Map<AbstractType<?>, ListType> frozenInstances = new HashMap<>();
1:ee55f36: 
1:ee55f36:     private final AbstractType<T> elements;
1:daff1fc:     public final ListSerializer<T> serializer;
1:ee55f36:     private final boolean isMultiCell;
1:91bdf7f: 
1:3a2faf9:     public static ListType<?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:8b00f3a:     {
1:91bdf7f:         List<AbstractType<?>> l = parser.getTypeParameters();
1:91bdf7f:         if (l.size() != 1)
1:91bdf7f:             throw new ConfigurationException("ListType takes exactly 1 type parameter");
1:91bdf7f: 
1:ee55f36:         return getInstance(l.get(0), true);
1:e9c6742:     }
1:e9c6742: 
1:ee55f36:     public static synchronized <T> ListType<T> getInstance(AbstractType<T> elements, boolean isMultiCell)
1:e9c6742:     {
1:ee55f36:         Map<AbstractType<?>, ListType> internMap = isMultiCell ? instances : frozenInstances;
1:ee55f36:         ListType<T> t = internMap.get(elements);
1:91bdf7f:         if (t == null)
1:8b00f3a:         {
1:ee55f36:             t = new ListType<T>(elements, isMultiCell);
1:ee55f36:             internMap.put(elements, t);
1:8b00f3a:         }
1:91bdf7f:         return t;
1:8b00f3a:     }
1:91bdf7f: 
1:ee55f36:     private ListType(AbstractType<T> elements, boolean isMultiCell)
1:91bdf7f:     {
1:07594ee:         super(ComparisonType.CUSTOM, Kind.LIST);
1:91bdf7f:         this.elements = elements;
1:daff1fc:         this.serializer = ListSerializer.getInstance(elements.getSerializer());
1:ee55f36:         this.isMultiCell = isMultiCell;
1:ee55f36:     }
1:ee55f36: 
1:98c4a7c:     @Override
1:7a3c3ab:     public boolean referencesUserType(String userTypeName)
1:d62b2cf:     {
1:7a3c3ab:         return getElementsType().referencesUserType(userTypeName);
1:98c4a7c:     }
1:98c4a7c: 
1:ecf05b8:     @Override
1:ecf05b8:     public boolean referencesDuration()
1:ecf05b8:     {
1:ecf05b8:         return getElementsType().referencesDuration();
1:ecf05b8:     }
1:ecf05b8: 
1:ee55f36:     public AbstractType<T> getElementsType()
1:ee55f36:     {
1:ee55f36:         return elements;
22:91bdf7f:     }
1:91bdf7f: 
1:5e5fbc6:     public AbstractType<UUID> nameComparator()
1:98c4a7c:     {
1:91bdf7f:         return TimeUUIDType.instance;
1:91bdf7f:     }
1:91bdf7f: 
1:5e5fbc6:     public AbstractType<T> valueComparator()
1:91bdf7f:     {
1:91bdf7f:         return elements;
1:91bdf7f:     }
1:91bdf7f: 
1:9872b74:     public ListSerializer<T> getSerializer()
1:91bdf7f:     {
1:daff1fc:         return serializer;
1:91bdf7f:     }
1:91bdf7f: 
1:f4b9f16:     @Override
1:ee55f36:     public AbstractType<?> freeze()
1:ee55f36:     {
1:ee55f36:         if (isMultiCell)
1:ee55f36:             return getInstance(this.elements, false);
1:d62b2cf:         else
1:ee55f36:             return this;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:dee84cc:     public AbstractType<?> freezeNestedMulticellTypes()
1:f4b9f16:     {
1:dee84cc:         if (!isMultiCell())
1:dee84cc:             return this;
1:dee84cc: 
1:dee84cc:         if (elements.isFreezable() && elements.isMultiCell())
1:d62b2cf:             return getInstance(elements.freeze(), isMultiCell);
1:dee84cc: 
1:dee84cc:         return getInstance(elements.freezeNestedMulticellTypes(), isMultiCell);
1:d62b2cf:     }
1:d62b2cf: 
1:d62b2cf:     @Override
1:ee55f36:     public boolean isMultiCell()
1:ee55f36:     {
1:ee55f36:         return isMultiCell;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:ee55f36:     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
1:ee55f36:     {
1:ee55f36:         assert !isMultiCell;
1:ee55f36:         return this.elements.isCompatibleWith(((ListType) previous).elements);
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:ee55f36:     public boolean isValueCompatibleWithFrozen(CollectionType<?> previous)
1:ee55f36:     {
1:ee55f36:         assert !isMultiCell;
1:ee55f36:         return this.elements.isValueCompatibleWithInternal(((ListType) previous).elements);
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:07594ee:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
1:91bdf7f:     {
1:f4b9f16:         return compareListOrSet(elements, o1, o2);
1:f4b9f16:     }
1:f4b9f16: 
1:f4b9f16:     static int compareListOrSet(AbstractType<?> elementsComparator, ByteBuffer o1, ByteBuffer o2)
1:f4b9f16:     {
1:ee55f36:         // Note that this is only used if the collection is frozen
1:acf1b18:         if (!o1.hasRemaining() || !o2.hasRemaining())
1:acf1b18:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
1:f4b9f16: 
1:f4b9f16:         ByteBuffer bb1 = o1.duplicate();
1:f4b9f16:         ByteBuffer bb2 = o2.duplicate();
1:f4b9f16: 
1:e0adc16:         int size1 = CollectionSerializer.readCollectionSize(bb1, ProtocolVersion.V3);
1:e0adc16:         int size2 = CollectionSerializer.readCollectionSize(bb2, ProtocolVersion.V3);
1:f4b9f16: 
1:f4b9f16:         for (int i = 0; i < Math.min(size1, size2); i++)
1:f4b9f16:         {
1:e0adc16:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, ProtocolVersion.V3);
1:e0adc16:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, ProtocolVersion.V3);
1:f4b9f16:             int cmp = elementsComparator.compare(v1, v2);
1:f4b9f16:             if (cmp != 0)
1:f4b9f16:                 return cmp;
1:f4b9f16:         }
1:f4b9f16: 
1:f4b9f16:         return size1 == size2 ? 0 : (size1 < size2 ? -1 : 1);
1:f4b9f16:     }
1:f4b9f16: 
1:ee55f36:     @Override
1:ee55f36:     public String toString(boolean ignoreFreezing)
1:91bdf7f:     {
1:ee55f36:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
1:ee55f36: 
1:ee55f36:         StringBuilder sb = new StringBuilder();
1:ee55f36:         if (includeFrozenType)
1:ee55f36:             sb.append(FrozenType.class.getName()).append("(");
1:ee55f36:         sb.append(getClass().getName());
1:ee55f36:         sb.append(TypeParser.stringifyTypeParameters(Collections.<AbstractType<?>>singletonList(elements), ignoreFreezing || !isMultiCell));
1:ee55f36:         if (includeFrozenType)
1:ee55f36:             sb.append(")");
1:ee55f36:         return sb.toString();
1:91bdf7f:     }
1:91bdf7f: 
1:a991b64:     public List<ByteBuffer> serializedValues(Iterator<Cell> cells)
1:91bdf7f:     {
1:ee55f36:         assert isMultiCell;
1:a991b64:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>();
1:a991b64:         while (cells.hasNext())
1:a991b64:             bbs.add(cells.next().value());
1:9872b74:         return bbs;
1:91bdf7f:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:c7b02d1:     public Term fromJSONObject(Object parsed) throws MarshalException
1:c7b02d1:     {
1:b7be198:         if (parsed instanceof String)
1:b7be198:             parsed = Json.decodeJson((String) parsed);
1:b7be198: 
1:c7b02d1:         if (!(parsed instanceof List))
1:c7b02d1:             throw new MarshalException(String.format(
1:c7b02d1:                     "Expected a list, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
1:c7b02d1: 
1:c7b02d1:         List list = (List) parsed;
1:c7b02d1:         List<Term> terms = new ArrayList<>(list.size());
1:c7b02d1:         for (Object element : list)
1:c7b02d1:         {
1:c7b02d1:             if (element == null)
1:c7b02d1:                 throw new MarshalException("Invalid null element in list");
1:c7b02d1:             terms.add(elements.fromJSONObject(element));
1:c7b02d1:         }
1:c7b02d1: 
1:c7b02d1:         return new Lists.DelayedValue(terms);
1:c7b02d1:     }
1:c7b02d1: 
1:e0adc16:     public static String setOrListToJsonString(ByteBuffer buffer, AbstractType elementsType, ProtocolVersion protocolVersion)
1:c7b02d1:     {
1:c7b02d1:         StringBuilder sb = new StringBuilder("[");
1:c7b02d1:         int size = CollectionSerializer.readCollectionSize(buffer, protocolVersion);
1:c7b02d1:         for (int i = 0; i < size; i++)
1:c7b02d1:         {
1:c7b02d1:             if (i > 0)
1:c7b02d1:                 sb.append(", ");
1:c7b02d1:             sb.append(elementsType.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
1:c7b02d1:         }
1:c7b02d1:         return sb.append("]").toString();
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:e0adc16:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:c7b02d1:     {
1:c7b02d1:         return setOrListToJsonString(buffer, elements, protocolVersion);
1:c7b02d1:     }
1:91bdf7f: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         int size1 = CollectionSerializer.readCollectionSize(bb1, ProtocolVersion.V3);
1:         int size2 = CollectionSerializer.readCollectionSize(bb2, ProtocolVersion.V3);
1:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, ProtocolVersion.V3);
1:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, ProtocolVersion.V3);
/////////////////////////////////////////////////////////////////////////
1:     public static String setOrListToJsonString(ByteBuffer buffer, AbstractType elementsType, ProtocolVersion protocolVersion)
/////////////////////////////////////////////////////////////////////////
1:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesDuration()
1:     {
1:         return getElementsType().referencesDuration();
1:     }
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:dee84cc
/////////////////////////////////////////////////////////////////////////
1:     public AbstractType<?> freezeNestedMulticellTypes()
1:         if (!isMultiCell())
1:             return this;
1: 
1:         if (elements.isFreezable() && elements.isMultiCell())
1: 
1:         return getInstance(elements.freezeNestedMulticellTypes(), isMultiCell);
commit:d62b2cf
/////////////////////////////////////////////////////////////////////////
0:     public AbstractType<?> freezeNestedUDTs()
1:     {
0:         if (elements.isUDT() && elements.isMultiCell())
1:             return getInstance(elements.freeze(), isMultiCell);
1:         else
0:             return getInstance(elements.freezeNestedUDTs(), isMultiCell);
1:     }
1: 
1:     @Override
commit:b7be198
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Json;
/////////////////////////////////////////////////////////////////////////
1:         if (parsed instanceof String)
1:             parsed = Json.decodeJson((String) parsed);
1: 
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Lists;
1: import org.apache.cassandra.cql3.Term;
1: import org.apache.cassandra.serializers.MarshalException;
1: 
0: import org.apache.cassandra.transport.Server;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public Term fromJSONObject(Object parsed) throws MarshalException
1:     {
1:         if (!(parsed instanceof List))
1:             throw new MarshalException(String.format(
1:                     "Expected a list, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
1: 
1:         List list = (List) parsed;
1:         List<Term> terms = new ArrayList<>(list.size());
1:         for (Object element : list)
1:         {
1:             if (element == null)
1:                 throw new MarshalException("Invalid null element in list");
1:             terms.add(elements.fromJSONObject(element));
1:         }
1: 
1:         return new Lists.DelayedValue(terms);
1:     }
1: 
0:     public static String setOrListToJsonString(ByteBuffer buffer, AbstractType elementsType, int protocolVersion)
1:     {
1:         StringBuilder sb = new StringBuilder("[");
1:         int size = CollectionSerializer.readCollectionSize(buffer, protocolVersion);
1:         for (int i = 0; i < size; i++)
1:         {
1:             if (i > 0)
1:                 sb.append(", ");
1:             sb.append(elementsType.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
1:         }
1:         return sb.append("]").toString();
1:     }
1: 
1:     @Override
0:     public String toJSONString(ByteBuffer buffer, int protocolVersion)
1:     {
1:         return setOrListToJsonString(buffer, elements, protocolVersion);
1:     }
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger logger = LoggerFactory.getLogger(ListType.class);
1:     // interning instances
1:     private static final Map<AbstractType<?>, ListType> instances = new HashMap<>();
1:     private static final Map<AbstractType<?>, ListType> frozenInstances = new HashMap<>();
1: 
1:     private final AbstractType<T> elements;
1:     private final boolean isMultiCell;
/////////////////////////////////////////////////////////////////////////
1:         return getInstance(l.get(0), true);
1:     public static synchronized <T> ListType<T> getInstance(AbstractType<T> elements, boolean isMultiCell)
1:         Map<AbstractType<?>, ListType> internMap = isMultiCell ? instances : frozenInstances;
1:         ListType<T> t = internMap.get(elements);
1:             t = new ListType<T>(elements, isMultiCell);
1:             internMap.put(elements, t);
1:     private ListType(AbstractType<T> elements, boolean isMultiCell)
1:         this.isMultiCell = isMultiCell;
1:     }
1: 
1:     public AbstractType<T> getElementsType()
1:     {
1:         return elements;
/////////////////////////////////////////////////////////////////////////
1:     public AbstractType<?> freeze()
1:     {
1:         if (isMultiCell)
1:             return getInstance(this.elements, false);
0:         else
1:             return this;
1:     }
1: 
1:     @Override
1:     public boolean isMultiCell()
1:     {
1:         return isMultiCell;
1:     }
1: 
1:     @Override
1:     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
1:     {
1:         assert !isMultiCell;
1:         return this.elements.isCompatibleWith(((ListType) previous).elements);
1:     }
1: 
1:     @Override
1:     public boolean isValueCompatibleWithFrozen(CollectionType<?> previous)
1:     {
1:         assert !isMultiCell;
1:         return this.elements.isValueCompatibleWithInternal(((ListType) previous).elements);
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         // Note that this is only used if the collection is frozen
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString(boolean ignoreFreezing)
1:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
1: 
1:         StringBuilder sb = new StringBuilder();
1:         if (includeFrozenType)
1:             sb.append(FrozenType.class.getName()).append("(");
1:         sb.append(getClass().getName());
1:         sb.append(TypeParser.stringifyTypeParameters(Collections.<AbstractType<?>>singletonList(elements), ignoreFreezing || !isMultiCell));
1:         if (includeFrozenType)
1:             sb.append(")");
1:         return sb.toString();
1:         assert isMultiCell;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesUserType(String userTypeName)
1:         return getElementsType().referencesUserType(userTypeName);
commit:e6f23e6
commit:1de63e9
commit:98c4a7c
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public boolean references(AbstractType<?> check)
1:     {
0:         return super.references(check) || elements.references(check);
1:     }
1: 
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:07594ee
/////////////////////////////////////////////////////////////////////////
1:         super(ComparisonType.CUSTOM, Kind.LIST);
/////////////////////////////////////////////////////////////////////////
1:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.Cell;
/////////////////////////////////////////////////////////////////////////
1:     public List<ByteBuffer> serializedValues(Iterator<Cell> cells)
1:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>();
1:         while (cells.hasNext())
1:             bbs.add(cells.next().value());
commit:3b299c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.CollectionSerializer;
/////////////////////////////////////////////////////////////////////////
0:         int size1 = CollectionSerializer.readCollectionSize(bb1, 3);
0:         int size2 = CollectionSerializer.readCollectionSize(bb2, 3);
0:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, 3);
0:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, 3);
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:     public ListSerializer<T> getSerializer()
/////////////////////////////////////////////////////////////////////////
0:     public List<ByteBuffer> serializedValues(List<Cell> cells)
1:         return bbs;
commit:f4b9f16
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public int compare(ByteBuffer o1, ByteBuffer o2)
1:     {
1:         return compareListOrSet(elements, o1, o2);
1:     }
1: 
1:     static int compareListOrSet(AbstractType<?> elementsComparator, ByteBuffer o1, ByteBuffer o2)
1:     {
0:         // Note that this is only used if the collection is inside an UDT
0:         if (o1 == null || !o1.hasRemaining())
0:             return o2 == null || !o2.hasRemaining() ? 0 : -1;
0:         if (o2 == null || !o2.hasRemaining())
0:             return 1;
1: 
1:         ByteBuffer bb1 = o1.duplicate();
1:         ByteBuffer bb2 = o2.duplicate();
1: 
0:         int size1 = ByteBufferUtil.readShortLength(bb1);
0:         int size2 = ByteBufferUtil.readShortLength(bb2);
1: 
1:         for (int i = 0; i < Math.min(size1, size2); i++)
1:         {
0:             ByteBuffer v1 = ByteBufferUtil.readBytesWithShortLength(bb1);
0:             ByteBuffer v2 = ByteBufferUtil.readBytesWithShortLength(bb2);
1:             int cmp = elementsComparator.compare(v1, v2);
1:             if (cmp != 0)
1:                 return cmp;
1:         }
1: 
1:         return size1 == size2 ? 0 : (size1 < size2 ? -1 : 1);
1:     }
1: 
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Cell;
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Cell> cells)
0:         cells = enforceLimit(cells);
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(cells.size());
0:         for (Cell c : cells)
0:         return pack(bbs, cells.size(), size);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Column> columns)
0:         for (Column c : columns)
0:             bbs.add(c.value());
0:             size += 2 + c.value().remaining();
commit:b2da839
commit:f634ac7
/////////////////////////////////////////////////////////////////////////
0:         columns = enforceLimit(columns);
1: 
commit:daff1fc
/////////////////////////////////////////////////////////////////////////
1:     public final ListSerializer<T> serializer;
/////////////////////////////////////////////////////////////////////////
1:         this.serializer = ListSerializer.getInstance(elements.getSerializer());
/////////////////////////////////////////////////////////////////////////
1:         return serializer;
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.TypeSerializer;
1: import org.apache.cassandra.serializers.ListSerializer;
/////////////////////////////////////////////////////////////////////////
0:         this.composer = ListSerializer.getInstance(elements.getSerializer());
/////////////////////////////////////////////////////////////////////////
0:     public TypeSerializer<List<T>> getSerializer()
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.AbstractSerializer;
0: import org.apache.cassandra.type.ListSerializer;
/////////////////////////////////////////////////////////////////////////
0:     public final ListSerializer<T> composer;
/////////////////////////////////////////////////////////////////////////
0:         this.composer = ListSerializer.getInstance(elements.asComposer());
/////////////////////////////////////////////////////////////////////////
0:         return composer.serialize(bytes);
/////////////////////////////////////////////////////////////////////////
0:         return composer.deserialize(value);
1:     }
1: 
0:     public AbstractSerializer<List<T>> asComposer()
1:     {
0:         return composer;
commit:c47f407
commit:9f268d1
/////////////////////////////////////////////////////////////////////////
0:             int n = getUnsignedShort(input);
0:                 int s = getUnsignedShort(input);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Column;
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Pair<ByteBuffer, Column>> columns)
0:         for (Pair<ByteBuffer, Column> p : columns)
commit:8b00f3a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.BufferUnderflowException;
/////////////////////////////////////////////////////////////////////////
0:         try
0:             ByteBuffer input = bytes.duplicate();
0:             int n = input.getShort();
0:             List<T> l = new ArrayList<T>(n);
0:             for (int i = 0; i < n; i++)
1:             {
0:                 int s = input.getShort();
0:                 byte[] data = new byte[s];
0:                 input.get(data);
0:                 ByteBuffer databb = ByteBuffer.wrap(data);
0:                 elements.validate(databb);
0:                 l.add(elements.compose(databb));
1:             }
0:             return l;
0:         catch (BufferUnderflowException e)
1:         {
0:             throw new MarshalException("Not enough bytes to read a list");
1:         }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     public static ListType<?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public AbstractType<?> nameComparator()
0:     public AbstractType<?> valueComparator()
/////////////////////////////////////////////////////////////////////////
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
0: import java.util.concurrent.atomic.AtomicReference;
1: 
0: import org.apache.cassandra.cql3.ColumnNameBuilder;
0: import org.apache.cassandra.cql3.Term;
0: import org.apache.cassandra.cql3.UpdateParameters;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.IColumn;
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.Pair;
0: import org.apache.cassandra.utils.UUIDGen;
1: 
0: public class ListType extends CollectionType
1: {
0:     // interning instances
0:     private static final Map<AbstractType<?>, ListType> instances = new HashMap<AbstractType<?>, ListType>();
1: 
0:     // Our reference time (1 jan 2010, 00:00:00) in milliseconds.
0:     private static final long REFERENCE_TIME = 1262304000000L;
1: 
1:     /*
0:      * For prepend, we need to be able to generate unique but decreasing time
0:      * UUID, which is a bit challenging. To do that, given a time in milliseconds,
0:      * we adds a number represening the 100-nanoseconds precision and make sure
0:      * that within the same millisecond, that number is always increasing. We
0:      * do rely on the fact that the user will only provide decreasing
0:      * milliseconds timestamp for that purpose.
1:      */
0:     private static class PrecisionTime
1:     {
0:         public final long millis;
0:         public final int nanos;
1: 
0:         public PrecisionTime(long millis, int nanos)
1:         {
0:             this.millis = millis;
0:             this.nanos = nanos;
1:         }
1:     }
1: 
0:     private static final AtomicReference<PrecisionTime> last = new AtomicReference<PrecisionTime>(new PrecisionTime(Long.MAX_VALUE, 0));
1: 
0:     private static PrecisionTime getNextTime(long millis)
1:     {
0:         while (true)
1:         {
0:             PrecisionTime current = last.get();
0:             assert millis <= current.millis;
0:             PrecisionTime next = millis < current.millis
0:                                ? new PrecisionTime(millis, 0)
0:                                : new PrecisionTime(millis, current.nanos + 1);
0:             if (last.compareAndSet(current, next))
0:                 return next;
1:         }
1:     }
1: 
0:     public final AbstractType<?> elements;
1: 
0:     public static ListType getInstance(TypeParser parser) throws ConfigurationException
1:     {
1:         List<AbstractType<?>> l = parser.getTypeParameters();
1:         if (l.size() != 1)
1:             throw new ConfigurationException("ListType takes exactly 1 type parameter");
1: 
0:         return getInstance(l.get(0));
1:     }
1: 
0:     public static synchronized ListType getInstance(AbstractType<?> elements)
1:     {
0:         ListType t = instances.get(elements);
1:         if (t == null)
1:         {
0:             t = new ListType(elements);
0:             instances.put(elements, t);
1:         }
1:         return t;
1:     }
1: 
0:     private ListType(AbstractType<?> elements)
1:     {
0:         super(Kind.LIST);
1:         this.elements = elements;
1:     }
1: 
0:     protected AbstractType<?> nameComparator()
1:     {
1:         return TimeUUIDType.instance;
1:     }
1: 
0:     protected AbstractType<?> valueComparator()
1:     {
1:         return elements;
1:     }
1: 
0:     protected void appendToStringBuilder(StringBuilder sb)
1:     {
0:         sb.append(getClass().getName()).append(TypeParser.stringifyTypeParameters(Collections.<AbstractType<?>>singletonList(elements)));
1:     }
1: 
0:     public void executeFunction(ColumnFamily cf, ColumnNameBuilder fullPath, Function fct, List<Term> args, UpdateParameters params) throws InvalidRequestException
1:     {
0:         switch (fct)
1:         {
0:             case APPEND:
0:                 doAppend(cf, fullPath, args, params);
0:                 break;
0:             case PREPEND:
0:                 doPrepend(cf, fullPath, args, params);
0:                 break;
0:             default:
0:                 throw new AssertionError("Unsupported function " + fct);
1:         }
1:     }
1: 
0:     public void execute(ColumnFamily cf, ColumnNameBuilder fullPath, Function fct, List<Term> args, UpdateParameters params, List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
1:     {
0:         switch (fct)
1:         {
0:             case SET:
0:                 doSet(cf, fullPath, validateIdx(fct, args.get(0), list), args.get(1), params, list);
0:                 break;
0:             case DISCARD_LIST:
0:                 // If list is empty, do nothing
0:                 if (list != null)
0:                     doDiscard(cf, fullPath, args, params, list);
0:                 break;
0:             case DISCARD_KEY:
0:                 doDiscardIdx(cf, fullPath, validateIdx(fct, args.get(0), list), params, list);
0:                 break;
0:             default:
0:                 throw new AssertionError();
1:         }
1:     }
1: 
0:     private int validateIdx(Function fct, Term value, List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
1:     {
0:         try
1:         {
0:             if (value.getType() != Term.Type.INTEGER)
0:                 throw new InvalidRequestException(String.format("Invalid argument %s for %s, must be an integer", value.getText(), fct));
0:             int idx = Integer.parseInt(value.getText());
0:             if (list == null || list.size() <= idx)
0:                 throw new InvalidRequestException(String.format("Invalid index %d, list has size %d", idx, list == null ? 0 : list.size()));
0:             return idx;
1:         }
0:         catch (NumberFormatException e)
1:         {
0:             // This should not happen, unless we screwed up the parser
0:             throw new RuntimeException();
1:         }
1:     }
1: 
0:     private void doPrepend(ColumnFamily cf, ColumnNameBuilder builder, List<Term> values, UpdateParameters params) throws InvalidRequestException
1:     {
0:         long time = REFERENCE_TIME - (System.currentTimeMillis() - REFERENCE_TIME);
0:         // We do the loop in reverse order because getNext() will create increasing time but we want the last
0:         // value in the prepended list to have the lower time
0:         for (int i = values.size() - 1; i >= 0; i--)
1:         {
0:             ColumnNameBuilder b = i == 0 ? builder : builder.copy();
0:             PrecisionTime pt = getNextTime(time);
0:             ByteBuffer uuid = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(pt.millis, pt.nanos));
0:             ByteBuffer name = b.add(uuid).build();
0:             cf.addColumn(params.makeColumn(name, values.get(i).getByteBuffer(elements, params.variables)));
1:         }
1:     }
1: 
0:     private void doAppend(ColumnFamily cf, ColumnNameBuilder builder, List<Term> values, UpdateParameters params) throws InvalidRequestException
1:     {
0:         for (int i = 0; i < values.size(); i++)
1:         {
0:             ColumnNameBuilder b = i == values.size() - 1 ? builder : builder.copy();
0:             ByteBuffer uuid = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());
0:             ByteBuffer name = b.add(uuid).build();
0:             cf.addColumn(params.makeColumn(name, values.get(i).getByteBuffer(elements, params.variables)));
1:         }
1:     }
1: 
0:     public void doSet(ColumnFamily cf, ColumnNameBuilder builder, int idx, Term value, UpdateParameters params, List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
1:     {
0:         ByteBuffer name = list.get(idx).right.name();
0:         cf.addColumn(params.makeColumn(name, value.getByteBuffer(elements, params.variables)));
1:     }
1: 
0:     public void doDiscard(ColumnFamily cf, ColumnNameBuilder builder, List<Term> values, UpdateParameters params, List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
1:     {
0:         Set<ByteBuffer> toDiscard = new HashSet<ByteBuffer>();
0:         for (Term value : values)
0:             toDiscard.add(value.getByteBuffer(elements, params.variables));
1: 
0:         for (Pair<ByteBuffer, IColumn> p : list)
1:         {
0:             IColumn c = p.right;
0:             if (toDiscard.contains(c.value()))
0:                 cf.addColumn(params.makeTombstone(c.name()));
1:         }
1:     }
1: 
0:     public void doDiscardIdx(ColumnFamily cf, ColumnNameBuilder builder, int idx, UpdateParameters params, List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
1:     {
0:         ByteBuffer name = list.get(idx).right.name();
0:         cf.addColumn(params.makeTombstone(name));
1:     }
1: 
0:     public ByteBuffer serializeForThrift(List<Pair<ByteBuffer, IColumn>> columns)
1:     {
0:         List<Object> l = new ArrayList<Object>(columns.size());
0:         for (Pair<ByteBuffer, IColumn> p : columns)
0:             l.add(elements.compose(p.right.value()));
0:         return ByteBufferUtil.bytes(FBUtilities.json(l));
1:     }
1: }
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
1:         if (!o1.hasRemaining() || !o2.hasRemaining())
1:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:95f94a4
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:d54a93f
/////////////////////////////////////////////////////////////////////////
0:         ListType<T> t = instances.get(elements);
0:             t = new ListType<T>(elements);
commit:5e5fbc6
/////////////////////////////////////////////////////////////////////////
1: public class ListType<T> extends CollectionType<List<T>>
0:     public final AbstractType<T> elements;
0:     public static ListType<?> getInstance(TypeParser parser) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:     public static synchronized <T> ListType<T> getInstance(AbstractType<T> elements)
/////////////////////////////////////////////////////////////////////////
0:     private ListType(AbstractType<T> elements)
1:     public AbstractType<UUID> nameComparator()
1:     public AbstractType<T> valueComparator()
0:     public List<T> compose(ByteBuffer bytes)
0:     {
0:         ByteBuffer input = bytes.duplicate();
0:         int n = input.getShort();
0:         List<T> l = new ArrayList<T>(n);
0:         for (int i = 0; i < n; i++)
0:         {
0:             int s = input.getShort();
0:             byte[] data = new byte[s];
0:             input.get(data);
0:             l.add(elements.compose(ByteBuffer.wrap(data)));
0:         }
0:         return l;
0:     }
0: 
0:     /**
0:      * Layout is: {@code <n><s_1><b_1>...<s_n><b_n> }
0:      * where:
0:      *   n is the number of elements
0:      *   s_i is the number of bytes composing the ith element
0:      *   b_i is the s_i bytes composing the ith element
0:      */
0:     public ByteBuffer decompose(List<T> value)
0:     {
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(value.size());
0:         int size = 0;
0:         for (T elt : value)
0:         {
0:             ByteBuffer bb = elements.decompose(elt);
0:             bbs.add(bb);
0:             size += 2 + bb.remaining();
0:         }
0:         return pack(bbs, value.size(), size);
0:     }
0: 
0:     public ByteBuffer serialize(List<Pair<ByteBuffer, IColumn>> columns)
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(columns.size());
0:         int size = 0;
0:         {
0:             bbs.add(p.right.value());
0:             size += 2 + p.right.value().remaining();
0:         }
0:         return pack(bbs, columns.size(), size);
============================================================================