1:bfd57d1: /*
1:bfd57d1:  * Licensed to the Apache Software Foundation (ASF) under one
1:bfd57d1:  * or more contributor license agreements.  See the NOTICE file
1:bfd57d1:  * distributed with this work for additional information
1:bfd57d1:  * regarding copyright ownership.  The ASF licenses this file
1:bfd57d1:  * to you under the Apache License, Version 2.0 (the
1:bfd57d1:  * "License"); you may not use this file except in compliance
1:bfd57d1:  * with the License.  You may obtain a copy of the License at
1:bfd57d1:  *
1:bfd57d1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:bfd57d1:  *
1:bfd57d1:  * Unless required by applicable law or agreed to in writing, software
1:bfd57d1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:bfd57d1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bfd57d1:  * See the License for the specific language governing permissions and
1:bfd57d1:  * limitations under the License.
1:bfd57d1:  */
1:bfd57d1: package org.apache.cassandra.cql3;
1:bfd57d1: 
1:bfd57d1: import java.util.regex.Matcher;
1:bfd57d1: import java.util.regex.Pattern;
1:bfd57d1: 
1:bfd57d1: import com.google.common.base.Objects;
1:bfd57d1: 
1:bfd57d1: import org.apache.cassandra.serializers.MarshalException;
1:bfd57d1: 
1:bfd57d1: import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
1:bfd57d1: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
1:bfd57d1: 
1:bfd57d1: /**
1:bfd57d1:  * Represents a duration. A durations store separately months, days, and seconds due to the fact that
1:bfd57d1:  * the number of days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.
1:bfd57d1:  */
1:bfd57d1: public final class Duration
1:bfd57d1: {
1:bfd57d1:     public static final long NANOS_PER_MICRO = 1000L;
1:bfd57d1:     public static final long NANOS_PER_MILLI = 1000 * NANOS_PER_MICRO;
1:bfd57d1:     public static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;
1:bfd57d1:     public static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;
1:bfd57d1:     public static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;
1:bfd57d1:     public static final int DAYS_PER_WEEK = 7;
1:bfd57d1:     public static final int MONTHS_PER_YEAR = 12;
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The Regexp used to parse the duration provided as String.
1:bfd57d1:      */
1:bfd57d1:     private static final Pattern STANDARD_PATTERN =
1:bfd57d1:             Pattern.compile("\\G(\\d+)(y|Y|mo|MO|mO|Mo|w|W|d|D|h|H|s|S|ms|MS|mS|Ms|us|US|uS|Us|µs|µS|ns|NS|nS|Ns|m|M)");
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
1:bfd57d1:      */
1:bfd57d1:     private static final Pattern ISO8601_PATTERN =
1:bfd57d1:             Pattern.compile("P((\\d+)Y)?((\\d+)M)?((\\d+)D)?(T((\\d+)H)?((\\d+)M)?((\\d+)S)?)?");
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
1:bfd57d1:      */
1:bfd57d1:     private static final Pattern ISO8601_WEEK_PATTERN = Pattern.compile("P(\\d+)W");
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The Regexp used to parse the duration when provided in the ISO 8601 alternative format.
1:bfd57d1:      */
1:bfd57d1:     private static final Pattern ISO8601_ALTERNATIVE_PATTERN =
1:bfd57d1:             Pattern.compile("P(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})");
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The number of months.
1:bfd57d1:      */
1:bfd57d1:     private final int months;
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The number of days.
1:bfd57d1:      */
1:bfd57d1:     private final int days;
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * The number of nanoseconds.
1:bfd57d1:      */
1:bfd57d1:     private final long nanoseconds;
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * Creates a duration. A duration can be negative.
1:bfd57d1:      * In this case all the non zero values must be negatives.
1:bfd57d1:      *
1:bfd57d1:      * @param months the number of months
1:bfd57d1:      * @param days the number of days
1:bfd57d1:      * @param nanoseconds the number of nanoseconds
1:bfd57d1:      */
1:bfd57d1:     private Duration(int months, int days, long nanoseconds)
1:bfd57d1:     {
1:bfd57d1:         // Makes sure that all the values are negatives if one of them is
1:bfd57d1:         assert (months >= 0 && days >= 0 && nanoseconds >= 0)
1:bfd57d1:             || ((months <= 0 && days <=0 && nanoseconds <=0));
1:bfd57d1: 
1:bfd57d1:         this.months = months;
1:bfd57d1:         this.days = days;
1:bfd57d1:         this.nanoseconds = nanoseconds;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     public static Duration newInstance(int months, int days, long nanoseconds)
1:bfd57d1:     {
1:bfd57d1:         return new Duration(months, days, nanoseconds);
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * Converts a <code>String</code> into a duration.
1:bfd57d1:      * <p>The accepted formats are:
1:bfd57d1:      * <ul>
1:bfd57d1:      * <li>multiple digits followed by a time unit like: 12h30m where the time unit can be:
1:bfd57d1:      *   <ul>
1:bfd57d1:      *      <li>{@code y}: years</li>
1:bfd57d1:      *      <li>{@code m}: months</li>
1:bfd57d1:      *      <li>{@code w}: weeks</li>
1:bfd57d1:      *      <li>{@code d}: days</li>
1:bfd57d1:      *      <li>{@code h}: hours</li>
1:bfd57d1:      *      <li>{@code m}: minutes</li>
1:bfd57d1:      *      <li>{@code s}: seconds</li>
1:bfd57d1:      *      <li>{@code ms}: milliseconds</li>
1:bfd57d1:      *      <li>{@code us} or {@code µs}: microseconds</li>
1:bfd57d1:      *      <li>{@code ns}: nanoseconds</li>
1:bfd57d1:      *   </ul>
1:bfd57d1:      * </li>
1:bfd57d1:      * <li>ISO 8601 format:  P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W</li>
1:bfd57d1:      * <li>ISO 8601 alternative format: P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]</li>
1:bfd57d1:      * </ul>
1:bfd57d1:      *
1:bfd57d1:      * @param input the <code>String</code> to convert
1:bfd57d1:      * @return a number of nanoseconds
1:bfd57d1:      */
1:bfd57d1:     public static Duration from(String input)
1:bfd57d1:     {
1:bfd57d1:         boolean isNegative = input.startsWith("-");
1:bfd57d1:         String source = isNegative ? input.substring(1) : input;
1:bfd57d1: 
1:bfd57d1:         if (source.startsWith("P"))
1:bfd57d1:         {
1:bfd57d1:             if (source.endsWith("W"))
1:bfd57d1:                 return parseIso8601WeekFormat(isNegative, source);
1:bfd57d1: 
1:bfd57d1:             if (source.contains("-"))
1:bfd57d1:                 return parseIso8601AlternativeFormat(isNegative, source);
1:bfd57d1: 
1:bfd57d1:             return parseIso8601Format(isNegative, source);
1:bfd57d1:         }
1:bfd57d1:         return parseStandardFormat(isNegative, source);
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static Duration parseIso8601Format(boolean isNegative, String source)
1:bfd57d1:     {
1:bfd57d1:         Matcher matcher = ISO8601_PATTERN.matcher(source);
1:bfd57d1:         if (!matcher.matches())
1:bfd57d1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1:bfd57d1: 
1:bfd57d1:         Builder builder = new Builder(isNegative);
1:bfd57d1:         if (matcher.group(1) != null)
1:bfd57d1:             builder.addYears(groupAsLong(matcher, 2));
1:bfd57d1: 
1:bfd57d1:         if (matcher.group(3) != null)
1:bfd57d1:             builder.addMonths(groupAsLong(matcher, 4));
1:bfd57d1: 
1:bfd57d1:         if (matcher.group(5) != null)
1:bfd57d1:             builder.addDays(groupAsLong(matcher, 6));
1:bfd57d1: 
1:bfd57d1:         // Checks if the String contains time information
1:bfd57d1:         if (matcher.group(7) != null)
1:bfd57d1:         {
1:bfd57d1:             if (matcher.group(8) != null)
1:bfd57d1:                 builder.addHours(groupAsLong(matcher, 9));
1:bfd57d1: 
1:bfd57d1:             if (matcher.group(10) != null)
1:bfd57d1:                 builder.addMinutes(groupAsLong(matcher, 11));
1:bfd57d1: 
1:bfd57d1:             if (matcher.group(12) != null)
1:bfd57d1:                 builder.addSeconds(groupAsLong(matcher, 13));
1:bfd57d1:         }
1:bfd57d1:         return builder.build();
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static Duration parseIso8601AlternativeFormat(boolean isNegative, String source)
1:bfd57d1:     {
1:bfd57d1:         Matcher matcher = ISO8601_ALTERNATIVE_PATTERN.matcher(source);
1:bfd57d1:         if (!matcher.matches())
1:bfd57d1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1:bfd57d1: 
1:bfd57d1:         return new Builder(isNegative).addYears(groupAsLong(matcher, 1))
1:bfd57d1:                                       .addMonths(groupAsLong(matcher, 2))
1:bfd57d1:                                       .addDays(groupAsLong(matcher, 3))
1:bfd57d1:                                       .addHours(groupAsLong(matcher, 4))
1:bfd57d1:                                       .addMinutes(groupAsLong(matcher, 5))
1:bfd57d1:                                       .addSeconds(groupAsLong(matcher, 6))
1:bfd57d1:                                       .build();
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static Duration parseIso8601WeekFormat(boolean isNegative, String source)
1:bfd57d1:     {
1:bfd57d1:         Matcher matcher = ISO8601_WEEK_PATTERN.matcher(source);
1:bfd57d1:         if (!matcher.matches())
1:bfd57d1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1:bfd57d1: 
1:bfd57d1:         return new Builder(isNegative).addWeeks(groupAsLong(matcher, 1))
1:bfd57d1:                                       .build();
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static Duration parseStandardFormat(boolean isNegative, String source)
1:bfd57d1:     {
1:bfd57d1:         Matcher matcher = STANDARD_PATTERN.matcher(source);
1:bfd57d1:         if (!matcher.find())
1:bfd57d1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1:bfd57d1: 
1:bfd57d1:         Builder builder = new Builder(isNegative);
1:bfd57d1:         boolean done = false;
1:bfd57d1: 
1:bfd57d1:         do
1:bfd57d1:         {
1:bfd57d1:             long number = groupAsLong(matcher, 1);
1:bfd57d1:             String symbol = matcher.group(2);
1:bfd57d1:             add(builder, number, symbol);
1:bfd57d1:             done = matcher.end() == source.length();
1:bfd57d1:         }
1:bfd57d1:         while (matcher.find());
1:bfd57d1: 
1:bfd57d1:         if (!done)
1:bfd57d1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1:bfd57d1: 
1:bfd57d1:         return builder.build();
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static long groupAsLong(Matcher matcher, int group)
1:bfd57d1:     {
1:bfd57d1:         return Long.parseLong(matcher.group(group));
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static Builder add(Builder builder, long number, String symbol)
1:bfd57d1:     {
1:bfd57d1:         switch (symbol.toLowerCase())
1:bfd57d1:         {
1:bfd57d1:             case "y": return builder.addYears(number);
1:bfd57d1:             case "mo": return builder.addMonths(number);
1:bfd57d1:             case "w": return builder.addWeeks(number);
1:bfd57d1:             case "d": return builder.addDays(number);
1:bfd57d1:             case "h": return builder.addHours(number);
1:bfd57d1:             case "m": return builder.addMinutes(number);
1:bfd57d1:             case "s": return builder.addSeconds(number);
1:bfd57d1:             case "ms": return builder.addMillis(number);
1:bfd57d1:             case "us":
1:bfd57d1:             case "µs": return builder.addMicros(number);
1:bfd57d1:             case "ns": return builder.addNanos(number);
1:bfd57d1:         }
1:bfd57d1:         throw new MarshalException(String.format("Unknown duration symbol '%s'", symbol));
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     public int getMonths()
1:bfd57d1:     {
1:bfd57d1:         return months;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     public int getDays()
1:bfd57d1:     {
1:bfd57d1:         return days;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     public long getNanoseconds()
1:bfd57d1:     {
1:bfd57d1:         return nanoseconds;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     @Override
1:bfd57d1:     public int hashCode()
1:bfd57d1:     {
1:bfd57d1:         return Objects.hashCode(days, months, nanoseconds);
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     @Override
1:bfd57d1:     public boolean equals(Object obj)
1:bfd57d1:     {
1:bfd57d1:         if (!(obj instanceof Duration))
1:bfd57d1:             return false;
1:bfd57d1: 
1:bfd57d1:         Duration other = (Duration) obj;
1:bfd57d1:         return days == other.days
1:bfd57d1:                 && months == other.months
1:bfd57d1:                 && nanoseconds == other.nanoseconds;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     @Override
1:bfd57d1:     public String toString()
1:bfd57d1:     {
1:bfd57d1:         StringBuilder builder = new StringBuilder();
1:bfd57d1: 
1:bfd57d1:         if (months < 0 || days < 0 || nanoseconds < 0)
1:bfd57d1:             builder.append('-');
1:bfd57d1: 
1:bfd57d1:         long remainder = append(builder, Math.abs(months), MONTHS_PER_YEAR, "y");
1:bfd57d1:         append(builder, remainder, 1, "mo");
1:bfd57d1: 
1:bfd57d1:         append(builder, Math.abs(days), 1, "d");
1:bfd57d1: 
1:bfd57d1:         if (nanoseconds != 0)
1:bfd57d1:         {
1:bfd57d1:             remainder = append(builder, Math.abs(nanoseconds), NANOS_PER_HOUR, "h");
1:bfd57d1:             remainder = append(builder, remainder, NANOS_PER_MINUTE, "m");
1:bfd57d1:             remainder = append(builder, remainder, NANOS_PER_SECOND, "s");
1:bfd57d1:             remainder = append(builder, remainder, NANOS_PER_MILLI, "ms");
1:bfd57d1:             remainder = append(builder, remainder, NANOS_PER_MICRO, "us");
1:bfd57d1:             append(builder, remainder, 1, "ns");
1:bfd57d1:         }
1:bfd57d1:         return builder.toString();
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     /**
1:bfd57d1:      * Appends the result of the division to the specified builder if the dividend is not zero.
1:bfd57d1:      *
1:bfd57d1:      * @param builder the builder to append to
1:bfd57d1:      * @param dividend the dividend
1:bfd57d1:      * @param divisor the divisor
1:bfd57d1:      * @param unit the time unit to append after the result of the division
1:bfd57d1:      * @return the remainder of the division
1:bfd57d1:      */
1:bfd57d1:     private static long append(StringBuilder builder, long dividend, long divisor, String unit)
1:bfd57d1:     {
1:bfd57d1:         if (dividend == 0 || dividend < divisor)
1:bfd57d1:             return dividend;
1:bfd57d1: 
1:bfd57d1:         builder.append(dividend / divisor).append(unit);
1:bfd57d1:         return dividend % divisor;
1:bfd57d1:     }
1:bfd57d1: 
1:bfd57d1:     private static class Builder
1:bfd57d1:     {
1:bfd57d1:         /**
1:bfd57d1:          * {@code true} if the duration is a negative one, {@code false} otherwise.
1:bfd57d1:          */
1:bfd57d1:         private final boolean isNegative;
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * The number of months.
1:bfd57d1:          */
1:bfd57d1:         private int months;
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * The number of days.
1:bfd57d1:          */
1:bfd57d1:         private int days;
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * The number of nanoseconds.
1:bfd57d1:          */
1:bfd57d1:         private long nanoseconds;
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * We need to make sure that the values for each units are provided in order.
1:bfd57d1:          */
1:bfd57d1:         private int currentUnitIndex;
1:bfd57d1: 
1:bfd57d1:         public Builder(boolean isNegative)
1:bfd57d1:         {
1:bfd57d1:             this.isNegative = isNegative;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of years.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfYears the number of years to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addYears(long numberOfYears)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(1);
1:bfd57d1:             validateMonths(numberOfYears, MONTHS_PER_YEAR);
1:bfd57d1:             months += numberOfYears * MONTHS_PER_YEAR;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of months.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfMonths the number of months to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addMonths(long numberOfMonths)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(2);
1:bfd57d1:             validateMonths(numberOfMonths, 1);
1:bfd57d1:             months += numberOfMonths;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of weeks.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfWeeks the number of weeks to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addWeeks(long numberOfWeeks)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(3);
1:bfd57d1:             validateDays(numberOfWeeks, DAYS_PER_WEEK);
1:bfd57d1:             days += numberOfWeeks * DAYS_PER_WEEK;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of days.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfDays the number of days to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addDays(long numberOfDays)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(4);
1:bfd57d1:             validateDays(numberOfDays, 1);
1:bfd57d1:             days += numberOfDays;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of hours.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfHours the number of hours to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addHours(long numberOfHours)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(5);
1:bfd57d1:             validateNanos(numberOfHours, NANOS_PER_HOUR);
1:bfd57d1:             nanoseconds += numberOfHours * NANOS_PER_HOUR;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of minutes.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfMinutes the number of minutes to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addMinutes(long numberOfMinutes)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(6);
1:bfd57d1:             validateNanos(numberOfMinutes, NANOS_PER_MINUTE);
1:bfd57d1:             nanoseconds += numberOfMinutes * NANOS_PER_MINUTE;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of seconds.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfSeconds the number of seconds to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addSeconds(long numberOfSeconds)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(7);
1:bfd57d1:             validateNanos(numberOfSeconds, NANOS_PER_SECOND);
1:bfd57d1:             nanoseconds += numberOfSeconds * NANOS_PER_SECOND;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of milliseconds.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfMillis the number of milliseconds to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addMillis(long numberOfMillis)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(8);
1:bfd57d1:             validateNanos(numberOfMillis, NANOS_PER_MILLI);
1:bfd57d1:             nanoseconds += numberOfMillis * NANOS_PER_MILLI;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of microseconds.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfMicros the number of microseconds to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addMicros(long numberOfMicros)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(9);
1:bfd57d1:             validateNanos(numberOfMicros, NANOS_PER_MICRO);
1:bfd57d1:             nanoseconds += numberOfMicros * NANOS_PER_MICRO;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Adds the specified amount of nanoseconds.
1:bfd57d1:          *
1:bfd57d1:          * @param numberOfNanos the number of nanoseconds to add.
1:bfd57d1:          * @return this {@code Builder}
1:bfd57d1:          */
1:bfd57d1:         public Builder addNanos(long numberOfNanos)
1:bfd57d1:         {
1:bfd57d1:             validateOrder(10);
1:bfd57d1:             validateNanos(numberOfNanos, 1);
1:bfd57d1:             nanoseconds += numberOfNanos;
1:bfd57d1:             return this;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Validates that the total number of months can be stored.
1:bfd57d1:          * @param units the number of units that need to be added
1:bfd57d1:          * @param monthsPerUnit the number of days per unit
1:bfd57d1:          */
1:bfd57d1:         private void validateMonths(long units, int monthsPerUnit)
1:bfd57d1:         {
1:bfd57d1:             validate(units, (Integer.MAX_VALUE - months) / monthsPerUnit, "months");
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Validates that the total number of days can be stored.
1:bfd57d1:          * @param units the number of units that need to be added
1:bfd57d1:          * @param daysPerUnit the number of days per unit
1:bfd57d1:          */
1:bfd57d1:         private void validateDays(long units, int daysPerUnit)
1:bfd57d1:         {
1:bfd57d1:             validate(units, (Integer.MAX_VALUE - days) / daysPerUnit, "days");
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Validates that the total number of nanoseconds can be stored.
1:bfd57d1:          * @param units the number of units that need to be added
1:bfd57d1:          * @param nanosPerUnit the number of nanoseconds per unit
1:bfd57d1:          */
1:bfd57d1:         private void validateNanos(long units, long nanosPerUnit)
1:bfd57d1:         {
1:bfd57d1:             validate(units, (Long.MAX_VALUE - nanoseconds) / nanosPerUnit, "nanoseconds");
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Validates that the specified amount is less than the limit.
1:bfd57d1:          * @param units the number of units to check
1:bfd57d1:          * @param limit the limit on the number of units
1:bfd57d1:          * @param unitName the unit name
1:bfd57d1:          */
1:bfd57d1:         private void validate(long units, long limit, String unitName)
1:bfd57d1:         {
1:bfd57d1:             checkTrue(units <= limit,
1:bfd57d1:                       "Invalid duration. The total number of %s must be less or equal to %s",
1:bfd57d1:                       unitName,
1:bfd57d1:                       Integer.MAX_VALUE);
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Validates that the duration values are added in the proper order.
1:bfd57d1:          * @param unitIndex the unit index (e.g. years=1, months=2, ...)
1:bfd57d1:          */
1:bfd57d1:         private void validateOrder(int unitIndex)
1:bfd57d1:         {
1:bfd57d1:             if (unitIndex == currentUnitIndex)
1:bfd57d1:                 throw invalidRequest("Invalid duration. The %s are specified multiple times", getUnitName(unitIndex));
1:bfd57d1: 
1:bfd57d1:             if (unitIndex <= currentUnitIndex)
1:bfd57d1:                 throw invalidRequest("Invalid duration. The %s should be after %s",
1:bfd57d1:                       getUnitName(currentUnitIndex),
1:bfd57d1:                       getUnitName(unitIndex));
1:bfd57d1: 
1:bfd57d1:             currentUnitIndex = unitIndex;
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         /**
1:bfd57d1:          * Returns the name of the unit corresponding to the specified index.
1:bfd57d1:          * @param unitIndex the unit index
1:bfd57d1:          * @return the name of the unit corresponding to the specified index.
1:bfd57d1:          */
1:bfd57d1:         private String getUnitName(int unitIndex)
1:bfd57d1:         {
1:bfd57d1:             switch (unitIndex)
1:bfd57d1:             {
1:bfd57d1:                 case 1: return "years";
1:bfd57d1:                 case 2: return "months";
1:bfd57d1:                 case 3: return "weeks";
1:bfd57d1:                 case 4: return "days";
1:bfd57d1:                 case 5: return "hours";
1:bfd57d1:                 case 6: return "minutes";
1:bfd57d1:                 case 7: return "seconds";
1:bfd57d1:                 case 8: return "milliseconds";
1:bfd57d1:                 case 9: return "microseconds";
1:bfd57d1:                 case 10: return "nanoseconds";
1:bfd57d1:                 default: throw new AssertionError("unknown unit index: " + unitIndex);
1:bfd57d1:             }
1:bfd57d1:         }
1:bfd57d1: 
1:bfd57d1:         public Duration build()
1:bfd57d1:         {
1:bfd57d1:             return isNegative ? new Duration(-months, -days, -nanoseconds) : new Duration(months, days, nanoseconds);
1:bfd57d1:         }
1:bfd57d1:     }
1:bfd57d1: }
============================================================================
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:bfd57d1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: 
1: import com.google.common.base.Objects;
1: 
1: import org.apache.cassandra.serializers.MarshalException;
1: 
1: import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
1: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
1: 
1: /**
1:  * Represents a duration. A durations store separately months, days, and seconds due to the fact that
1:  * the number of days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.
1:  */
1: public final class Duration
1: {
1:     public static final long NANOS_PER_MICRO = 1000L;
1:     public static final long NANOS_PER_MILLI = 1000 * NANOS_PER_MICRO;
1:     public static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;
1:     public static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;
1:     public static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;
1:     public static final int DAYS_PER_WEEK = 7;
1:     public static final int MONTHS_PER_YEAR = 12;
1: 
1:     /**
1:      * The Regexp used to parse the duration provided as String.
1:      */
1:     private static final Pattern STANDARD_PATTERN =
1:             Pattern.compile("\\G(\\d+)(y|Y|mo|MO|mO|Mo|w|W|d|D|h|H|s|S|ms|MS|mS|Ms|us|US|uS|Us|µs|µS|ns|NS|nS|Ns|m|M)");
1: 
1:     /**
1:      * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
1:      */
1:     private static final Pattern ISO8601_PATTERN =
1:             Pattern.compile("P((\\d+)Y)?((\\d+)M)?((\\d+)D)?(T((\\d+)H)?((\\d+)M)?((\\d+)S)?)?");
1: 
1:     /**
1:      * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
1:      */
1:     private static final Pattern ISO8601_WEEK_PATTERN = Pattern.compile("P(\\d+)W");
1: 
1:     /**
1:      * The Regexp used to parse the duration when provided in the ISO 8601 alternative format.
1:      */
1:     private static final Pattern ISO8601_ALTERNATIVE_PATTERN =
1:             Pattern.compile("P(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})");
1: 
1:     /**
1:      * The number of months.
1:      */
1:     private final int months;
1: 
1:     /**
1:      * The number of days.
1:      */
1:     private final int days;
1: 
1:     /**
1:      * The number of nanoseconds.
1:      */
1:     private final long nanoseconds;
1: 
1:     /**
1:      * Creates a duration. A duration can be negative.
1:      * In this case all the non zero values must be negatives.
1:      *
1:      * @param months the number of months
1:      * @param days the number of days
1:      * @param nanoseconds the number of nanoseconds
1:      */
1:     private Duration(int months, int days, long nanoseconds)
1:     {
1:         // Makes sure that all the values are negatives if one of them is
1:         assert (months >= 0 && days >= 0 && nanoseconds >= 0)
1:             || ((months <= 0 && days <=0 && nanoseconds <=0));
1: 
1:         this.months = months;
1:         this.days = days;
1:         this.nanoseconds = nanoseconds;
1:     }
1: 
1:     public static Duration newInstance(int months, int days, long nanoseconds)
1:     {
1:         return new Duration(months, days, nanoseconds);
1:     }
1: 
1:     /**
1:      * Converts a <code>String</code> into a duration.
1:      * <p>The accepted formats are:
1:      * <ul>
1:      * <li>multiple digits followed by a time unit like: 12h30m where the time unit can be:
1:      *   <ul>
1:      *      <li>{@code y}: years</li>
1:      *      <li>{@code m}: months</li>
1:      *      <li>{@code w}: weeks</li>
1:      *      <li>{@code d}: days</li>
1:      *      <li>{@code h}: hours</li>
1:      *      <li>{@code m}: minutes</li>
1:      *      <li>{@code s}: seconds</li>
1:      *      <li>{@code ms}: milliseconds</li>
1:      *      <li>{@code us} or {@code µs}: microseconds</li>
1:      *      <li>{@code ns}: nanoseconds</li>
1:      *   </ul>
1:      * </li>
1:      * <li>ISO 8601 format:  P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W</li>
1:      * <li>ISO 8601 alternative format: P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]</li>
1:      * </ul>
1:      *
1:      * @param input the <code>String</code> to convert
1:      * @return a number of nanoseconds
1:      */
1:     public static Duration from(String input)
1:     {
1:         boolean isNegative = input.startsWith("-");
1:         String source = isNegative ? input.substring(1) : input;
1: 
1:         if (source.startsWith("P"))
1:         {
1:             if (source.endsWith("W"))
1:                 return parseIso8601WeekFormat(isNegative, source);
1: 
1:             if (source.contains("-"))
1:                 return parseIso8601AlternativeFormat(isNegative, source);
1: 
1:             return parseIso8601Format(isNegative, source);
1:         }
1:         return parseStandardFormat(isNegative, source);
1:     }
1: 
1:     private static Duration parseIso8601Format(boolean isNegative, String source)
1:     {
1:         Matcher matcher = ISO8601_PATTERN.matcher(source);
1:         if (!matcher.matches())
1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1: 
1:         Builder builder = new Builder(isNegative);
1:         if (matcher.group(1) != null)
1:             builder.addYears(groupAsLong(matcher, 2));
1: 
1:         if (matcher.group(3) != null)
1:             builder.addMonths(groupAsLong(matcher, 4));
1: 
1:         if (matcher.group(5) != null)
1:             builder.addDays(groupAsLong(matcher, 6));
1: 
1:         // Checks if the String contains time information
1:         if (matcher.group(7) != null)
1:         {
1:             if (matcher.group(8) != null)
1:                 builder.addHours(groupAsLong(matcher, 9));
1: 
1:             if (matcher.group(10) != null)
1:                 builder.addMinutes(groupAsLong(matcher, 11));
1: 
1:             if (matcher.group(12) != null)
1:                 builder.addSeconds(groupAsLong(matcher, 13));
1:         }
1:         return builder.build();
1:     }
1: 
1:     private static Duration parseIso8601AlternativeFormat(boolean isNegative, String source)
1:     {
1:         Matcher matcher = ISO8601_ALTERNATIVE_PATTERN.matcher(source);
1:         if (!matcher.matches())
1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1: 
1:         return new Builder(isNegative).addYears(groupAsLong(matcher, 1))
1:                                       .addMonths(groupAsLong(matcher, 2))
1:                                       .addDays(groupAsLong(matcher, 3))
1:                                       .addHours(groupAsLong(matcher, 4))
1:                                       .addMinutes(groupAsLong(matcher, 5))
1:                                       .addSeconds(groupAsLong(matcher, 6))
1:                                       .build();
1:     }
1: 
1:     private static Duration parseIso8601WeekFormat(boolean isNegative, String source)
1:     {
1:         Matcher matcher = ISO8601_WEEK_PATTERN.matcher(source);
1:         if (!matcher.matches())
1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1: 
1:         return new Builder(isNegative).addWeeks(groupAsLong(matcher, 1))
1:                                       .build();
1:     }
1: 
1:     private static Duration parseStandardFormat(boolean isNegative, String source)
1:     {
1:         Matcher matcher = STANDARD_PATTERN.matcher(source);
1:         if (!matcher.find())
1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1: 
1:         Builder builder = new Builder(isNegative);
1:         boolean done = false;
1: 
1:         do
1:         {
1:             long number = groupAsLong(matcher, 1);
1:             String symbol = matcher.group(2);
1:             add(builder, number, symbol);
1:             done = matcher.end() == source.length();
1:         }
1:         while (matcher.find());
1: 
1:         if (!done)
1:             throw invalidRequest("Unable to convert '%s' to a duration", source);
1: 
1:         return builder.build();
1:     }
1: 
1:     private static long groupAsLong(Matcher matcher, int group)
1:     {
1:         return Long.parseLong(matcher.group(group));
1:     }
1: 
1:     private static Builder add(Builder builder, long number, String symbol)
1:     {
1:         switch (symbol.toLowerCase())
1:         {
1:             case "y": return builder.addYears(number);
1:             case "mo": return builder.addMonths(number);
1:             case "w": return builder.addWeeks(number);
1:             case "d": return builder.addDays(number);
1:             case "h": return builder.addHours(number);
1:             case "m": return builder.addMinutes(number);
1:             case "s": return builder.addSeconds(number);
1:             case "ms": return builder.addMillis(number);
1:             case "us":
1:             case "µs": return builder.addMicros(number);
1:             case "ns": return builder.addNanos(number);
1:         }
1:         throw new MarshalException(String.format("Unknown duration symbol '%s'", symbol));
1:     }
1: 
1:     public int getMonths()
1:     {
1:         return months;
1:     }
1: 
1:     public int getDays()
1:     {
1:         return days;
1:     }
1: 
1:     public long getNanoseconds()
1:     {
1:         return nanoseconds;
1:     }
1: 
1:     @Override
1:     public int hashCode()
1:     {
1:         return Objects.hashCode(days, months, nanoseconds);
1:     }
1: 
1:     @Override
1:     public boolean equals(Object obj)
1:     {
1:         if (!(obj instanceof Duration))
1:             return false;
1: 
1:         Duration other = (Duration) obj;
1:         return days == other.days
1:                 && months == other.months
1:                 && nanoseconds == other.nanoseconds;
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
1:         StringBuilder builder = new StringBuilder();
1: 
1:         if (months < 0 || days < 0 || nanoseconds < 0)
1:             builder.append('-');
1: 
1:         long remainder = append(builder, Math.abs(months), MONTHS_PER_YEAR, "y");
1:         append(builder, remainder, 1, "mo");
1: 
1:         append(builder, Math.abs(days), 1, "d");
1: 
1:         if (nanoseconds != 0)
1:         {
1:             remainder = append(builder, Math.abs(nanoseconds), NANOS_PER_HOUR, "h");
1:             remainder = append(builder, remainder, NANOS_PER_MINUTE, "m");
1:             remainder = append(builder, remainder, NANOS_PER_SECOND, "s");
1:             remainder = append(builder, remainder, NANOS_PER_MILLI, "ms");
1:             remainder = append(builder, remainder, NANOS_PER_MICRO, "us");
1:             append(builder, remainder, 1, "ns");
1:         }
1:         return builder.toString();
1:     }
1: 
1:     /**
1:      * Appends the result of the division to the specified builder if the dividend is not zero.
1:      *
1:      * @param builder the builder to append to
1:      * @param dividend the dividend
1:      * @param divisor the divisor
1:      * @param unit the time unit to append after the result of the division
1:      * @return the remainder of the division
1:      */
1:     private static long append(StringBuilder builder, long dividend, long divisor, String unit)
1:     {
1:         if (dividend == 0 || dividend < divisor)
1:             return dividend;
1: 
1:         builder.append(dividend / divisor).append(unit);
1:         return dividend % divisor;
1:     }
1: 
1:     private static class Builder
1:     {
1:         /**
1:          * {@code true} if the duration is a negative one, {@code false} otherwise.
1:          */
1:         private final boolean isNegative;
1: 
1:         /**
1:          * The number of months.
1:          */
1:         private int months;
1: 
1:         /**
1:          * The number of days.
1:          */
1:         private int days;
1: 
1:         /**
1:          * The number of nanoseconds.
1:          */
1:         private long nanoseconds;
1: 
1:         /**
1:          * We need to make sure that the values for each units are provided in order.
1:          */
1:         private int currentUnitIndex;
1: 
1:         public Builder(boolean isNegative)
1:         {
1:             this.isNegative = isNegative;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of years.
1:          *
1:          * @param numberOfYears the number of years to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addYears(long numberOfYears)
1:         {
1:             validateOrder(1);
1:             validateMonths(numberOfYears, MONTHS_PER_YEAR);
1:             months += numberOfYears * MONTHS_PER_YEAR;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of months.
1:          *
1:          * @param numberOfMonths the number of months to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addMonths(long numberOfMonths)
1:         {
1:             validateOrder(2);
1:             validateMonths(numberOfMonths, 1);
1:             months += numberOfMonths;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of weeks.
1:          *
1:          * @param numberOfWeeks the number of weeks to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addWeeks(long numberOfWeeks)
1:         {
1:             validateOrder(3);
1:             validateDays(numberOfWeeks, DAYS_PER_WEEK);
1:             days += numberOfWeeks * DAYS_PER_WEEK;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of days.
1:          *
1:          * @param numberOfDays the number of days to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addDays(long numberOfDays)
1:         {
1:             validateOrder(4);
1:             validateDays(numberOfDays, 1);
1:             days += numberOfDays;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of hours.
1:          *
1:          * @param numberOfHours the number of hours to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addHours(long numberOfHours)
1:         {
1:             validateOrder(5);
1:             validateNanos(numberOfHours, NANOS_PER_HOUR);
1:             nanoseconds += numberOfHours * NANOS_PER_HOUR;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of minutes.
1:          *
1:          * @param numberOfMinutes the number of minutes to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addMinutes(long numberOfMinutes)
1:         {
1:             validateOrder(6);
1:             validateNanos(numberOfMinutes, NANOS_PER_MINUTE);
1:             nanoseconds += numberOfMinutes * NANOS_PER_MINUTE;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of seconds.
1:          *
1:          * @param numberOfSeconds the number of seconds to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addSeconds(long numberOfSeconds)
1:         {
1:             validateOrder(7);
1:             validateNanos(numberOfSeconds, NANOS_PER_SECOND);
1:             nanoseconds += numberOfSeconds * NANOS_PER_SECOND;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of milliseconds.
1:          *
1:          * @param numberOfMillis the number of milliseconds to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addMillis(long numberOfMillis)
1:         {
1:             validateOrder(8);
1:             validateNanos(numberOfMillis, NANOS_PER_MILLI);
1:             nanoseconds += numberOfMillis * NANOS_PER_MILLI;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of microseconds.
1:          *
1:          * @param numberOfMicros the number of microseconds to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addMicros(long numberOfMicros)
1:         {
1:             validateOrder(9);
1:             validateNanos(numberOfMicros, NANOS_PER_MICRO);
1:             nanoseconds += numberOfMicros * NANOS_PER_MICRO;
1:             return this;
1:         }
1: 
1:         /**
1:          * Adds the specified amount of nanoseconds.
1:          *
1:          * @param numberOfNanos the number of nanoseconds to add.
1:          * @return this {@code Builder}
1:          */
1:         public Builder addNanos(long numberOfNanos)
1:         {
1:             validateOrder(10);
1:             validateNanos(numberOfNanos, 1);
1:             nanoseconds += numberOfNanos;
1:             return this;
1:         }
1: 
1:         /**
1:          * Validates that the total number of months can be stored.
1:          * @param units the number of units that need to be added
1:          * @param monthsPerUnit the number of days per unit
1:          */
1:         private void validateMonths(long units, int monthsPerUnit)
1:         {
1:             validate(units, (Integer.MAX_VALUE - months) / monthsPerUnit, "months");
1:         }
1: 
1:         /**
1:          * Validates that the total number of days can be stored.
1:          * @param units the number of units that need to be added
1:          * @param daysPerUnit the number of days per unit
1:          */
1:         private void validateDays(long units, int daysPerUnit)
1:         {
1:             validate(units, (Integer.MAX_VALUE - days) / daysPerUnit, "days");
1:         }
1: 
1:         /**
1:          * Validates that the total number of nanoseconds can be stored.
1:          * @param units the number of units that need to be added
1:          * @param nanosPerUnit the number of nanoseconds per unit
1:          */
1:         private void validateNanos(long units, long nanosPerUnit)
1:         {
1:             validate(units, (Long.MAX_VALUE - nanoseconds) / nanosPerUnit, "nanoseconds");
1:         }
1: 
1:         /**
1:          * Validates that the specified amount is less than the limit.
1:          * @param units the number of units to check
1:          * @param limit the limit on the number of units
1:          * @param unitName the unit name
1:          */
1:         private void validate(long units, long limit, String unitName)
1:         {
1:             checkTrue(units <= limit,
1:                       "Invalid duration. The total number of %s must be less or equal to %s",
1:                       unitName,
1:                       Integer.MAX_VALUE);
1:         }
1: 
1:         /**
1:          * Validates that the duration values are added in the proper order.
1:          * @param unitIndex the unit index (e.g. years=1, months=2, ...)
1:          */
1:         private void validateOrder(int unitIndex)
1:         {
1:             if (unitIndex == currentUnitIndex)
1:                 throw invalidRequest("Invalid duration. The %s are specified multiple times", getUnitName(unitIndex));
1: 
1:             if (unitIndex <= currentUnitIndex)
1:                 throw invalidRequest("Invalid duration. The %s should be after %s",
1:                       getUnitName(currentUnitIndex),
1:                       getUnitName(unitIndex));
1: 
1:             currentUnitIndex = unitIndex;
1:         }
1: 
1:         /**
1:          * Returns the name of the unit corresponding to the specified index.
1:          * @param unitIndex the unit index
1:          * @return the name of the unit corresponding to the specified index.
1:          */
1:         private String getUnitName(int unitIndex)
1:         {
1:             switch (unitIndex)
1:             {
1:                 case 1: return "years";
1:                 case 2: return "months";
1:                 case 3: return "weeks";
1:                 case 4: return "days";
1:                 case 5: return "hours";
1:                 case 6: return "minutes";
1:                 case 7: return "seconds";
1:                 case 8: return "milliseconds";
1:                 case 9: return "microseconds";
1:                 case 10: return "nanoseconds";
1:                 default: throw new AssertionError("unknown unit index: " + unitIndex);
1:             }
1:         }
1: 
1:         public Duration build()
1:         {
1:             return isNegative ? new Duration(-months, -days, -nanoseconds) : new Duration(months, days, nanoseconds);
1:         }
1:     }
1: }
============================================================================