1:1aeca2b: /*
1:1aeca2b:  * Licensed to the Apache Software Foundation (ASF) under one
1:1aeca2b:  * or more contributor license agreements.  See the NOTICE file
1:1aeca2b:  * distributed with this work for additional information
1:1aeca2b:  * regarding copyright ownership.  The ASF licenses this file
1:1aeca2b:  * to you under the Apache License, Version 2.0 (the
1:1aeca2b:  * "License"); you may not use this file except in compliance
1:1aeca2b:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cdfd0:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:07594ee:  */
1:07cf56f: package org.apache.cassandra.db.marshal;
1:522d0dd: 
1:a991b64: import java.io.IOException;
1:07594ee: import java.lang.reflect.Method;
1:e7a385a: import java.nio.ByteBuffer;
1:dcc3bb0: import java.util.ArrayList;
1:986cee6: import java.util.Collection;
1:a950b92: import java.util.Collections;
1:e7a385a: import java.util.Comparator;
1:a950b92: import java.util.List;
1:522d0dd: import java.util.Map;
1:b76a5b5: 
1:07594ee: import org.slf4j.Logger;
1:07594ee: import org.slf4j.LoggerFactory;
1:85cc390: 
1:4ed0060: import org.apache.cassandra.cql3.AssignmentTestable;
1:a67f779: import org.apache.cassandra.cql3.CQL3Type;
1:4ed0060: import org.apache.cassandra.cql3.ColumnSpecification;
1:a67f779: import org.apache.cassandra.cql3.Term;
1:a991b64: import org.apache.cassandra.db.TypeSizes;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:fc8b76f: import org.apache.cassandra.serializers.TypeSerializer;
1:fc8b76f: import org.apache.cassandra.serializers.MarshalException;
1:c7b02d1: 
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:07594ee: import org.apache.cassandra.utils.FastByteOperations;
1:1bb2dd9: import org.github.jamm.Unmetered;
1:a991b64: import org.apache.cassandra.io.util.DataOutputPlus;
1:2457599: import org.apache.cassandra.io.util.DataInputPlus;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:07594ee: 
1:07594ee: import static org.apache.cassandra.db.marshal.AbstractType.ComparisonType.CUSTOM;
1:07594ee: 
1:85cc390: /**
1:e7a385a:  * Specifies a Comparator for a specific type of ByteBuffer.
1:07cdfd0:  *
1:e7a385a:  * Note that empty ByteBuffer are used to represent "start at the beginning"
1:e3aef8e:  * or "stop at the end" arguments to get_slice, so the Comparator
1:e3aef8e:  * should always handle those values even if they normally do not
1:e7a385a:  * represent a valid ByteBuffer for the type being compared.
1:85cc390:  */
1:1bb2dd9: @Unmetered
1:4ed0060: public abstract class AbstractType<T> implements Comparator<ByteBuffer>, AssignmentTestable
1:522d0dd: {
1:07594ee:     private static final Logger logger = LoggerFactory.getLogger(AbstractType.class);
1:85cc390: 
1:ae0275b:     public final Comparator<ByteBuffer> reverseComparator;
1:85cc390: 
1:85cc390:     public enum ComparisonType
1:85cc390:     {
1:85cc390:         /**
1:07594ee:          * This type should never be compared
1:85cc390:          */
1:07594ee:         NOT_COMPARABLE,
1:07594ee:         /**
1:07594ee:          * This type is always compared by its sequence of unsigned bytes
1:07594ee:          */
1:07594ee:         BYTE_ORDER,
1:07594ee:         /**
1:07594ee:          * This type can only be compared by calling the type's compareCustom() method, which may be expensive.
1:07594ee:          * Support for this may be removed in a major release of Cassandra, however upgrade facilities will be
1:07594ee:          * provided if and when this happens.
1:07594ee:          */
1:07594ee:         CUSTOM
1:57ead56:     }
1:4d34917: 
1:07594ee:     public final ComparisonType comparisonType;
1:07594ee:     public final boolean isByteOrderComparable;
1:07cdfd0: 
1:07594ee:     protected AbstractType(ComparisonType comparisonType)
1:4d34917:     {
1:07594ee:         this.comparisonType = comparisonType;
1:07594ee:         this.isByteOrderComparable = comparisonType == ComparisonType.BYTE_ORDER;
1:07594ee:         reverseComparator = (o1, o2) -> AbstractType.this.compare(o2, o1);
1:07594ee:         try
1:4d34917:         {
1:07594ee:             Method custom = getClass().getMethod("compareCustom", ByteBuffer.class, ByteBuffer.class);
1:07594ee:             if ((custom.getDeclaringClass() == AbstractType.class) == (comparisonType == CUSTOM))
1:07594ee:                 throw new IllegalStateException((comparisonType == CUSTOM ? "compareCustom must be overridden if ComparisonType is CUSTOM"
1:07594ee:                                                                          : "compareCustom should not be overridden if ComparisonType is not CUSTOM")
1:07594ee:                                                 + " (" + getClass().getSimpleName() + ")");
1:85cc390:         }
1:07594ee:         catch (NoSuchMethodException e)
1:4d34917:         {
1:07594ee:             throw new IllegalStateException();
1:85cc390:         }
1:98c4a7c:     }
1:07cdfd0: 
1:dcc3bb0:     public static List<String> asCQLTypeStringList(List<AbstractType<?>> abstractTypes)
1:4d34917:     {
1:dcc3bb0:         List<String> r = new ArrayList<>(abstractTypes.size());
1:dcc3bb0:         for (AbstractType<?> abstractType : abstractTypes)
1:dcc3bb0:             r.add(abstractType.asCQL3Type().toString());
1:dcc3bb0:         return r;
1:dcc3bb0:     }
1:2fd3268: 
1:daff1fc:     public T compose(ByteBuffer bytes)
1:daff1fc:     {
1:daff1fc:         return getSerializer().deserialize(bytes);
1:daff1fc:     }
1:2fd3268: 
1:daff1fc:     public ByteBuffer decompose(T value)
1:daff1fc:     {
1:daff1fc:         return getSerializer().serialize(value);
1:daff1fc:     }
1:85cc390: 
1:e94032a:     /** get a string representation of the bytes used for various identifier (NOT just for log messages) */
1:daff1fc:     public String getString(ByteBuffer bytes)
1:daff1fc:     {
1:a991b64:         if (bytes == null)
1:a991b64:             return "null";
1:a991b64: 
1:daff1fc:         TypeSerializer<T> serializer = getSerializer();
1:daff1fc:         serializer.validate(bytes);
1:daff1fc: 
1:d6f32e4:         return serializer.toString(serializer.deserialize(bytes));
1:daff1fc:     }
1:98c4a7c: 
1:ccb0028:     /** get a byte representation of the given string. */
1:ccb0028:     public abstract ByteBuffer fromString(String source) throws MarshalException;
1:8be7e5c: 
1:c7b02d1:     /** Given a parsed JSON string, return a byte representation of the object.
1:c7b02d1:      * @param parsed the result of parsing a json string
1:c7b02d1:      **/
1:c7b02d1:     public abstract Term fromJSONObject(Object parsed) throws MarshalException;
1:c7b02d1: 
1:c7b02d1:     /** Converts a value to a JSON string. */
1:e0adc16:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:8be7e5c:     {
1:c7b02d1:         return '"' + getSerializer().deserialize(buffer).toString() + '"';
1:8be7e5c:     }
1:c7b02d1: 
1:ae0275b:     /* validate that the byte array is a valid sequence for the type we are supposed to be comparing */
1:daff1fc:     public void validate(ByteBuffer bytes) throws MarshalException
1:daff1fc:     {
1:daff1fc:         getSerializer().validate(bytes);
1:daff1fc:     }
1:a67f779: 
1:07594ee:     public final int compare(ByteBuffer left, ByteBuffer right)
1:a67f779:     {
1:07594ee:         return isByteOrderComparable
1:07594ee:                ? FastByteOperations.compareUnsigned(left, right)
1:07594ee:                : compareCustom(left, right);
1:a67f779:     }
1:dcc3bb0: 
1:98c4a7c:     /**
1:07594ee:      * Implement IFF ComparisonType is CUSTOM
1:07cdfd0:      *
1:07594ee:      * Compares the ByteBuffer representation of two instances of this class,
1:07594ee:      * for types where this cannot be done by simple in-order comparison of the
1:07594ee:      * unsigned bytes
1:07cf56f:      *
1:07594ee:      * Standard Java compare semantics
1:d62b2cf:      */
1:07594ee:     public int compareCustom(ByteBuffer left, ByteBuffer right)
1:85cc390:     {
1:07594ee:         throw new UnsupportedOperationException();
1:c7b02d1:     }
1:07594ee: 
1:07594ee:     /**
1:110a132:      * Validate cell value. Unlike {@linkplain #validate(java.nio.ByteBuffer)},
1:110a132:      * cell value is passed to validate its content.
1:110a132:      * Usually, this is the same as validate except collection.
1:07cf56f:      *
1:110a132:      * @param cellValue ByteBuffer representing cell value
1:110a132:      * @throws MarshalException
1:98c4a7c:      */
1:110a132:     public void validateCellValue(ByteBuffer cellValue) throws MarshalException
1:d62b2cf:     {
1:110a132:         validate(cellValue);
1:07594ee:     }
1:07594ee: 
1:a67f779:     /* Most of our internal type should override that. */
1:a67f779:     public CQL3Type asCQL3Type()
1:a67f779:     {
1:a67f779:         return new CQL3Type.Custom(this);
1:a67f779:     }
1:e9c6742: 
1:a991b64:     /**
1:a991b64:      * Same as compare except that this ignore ReversedType. This is to be use when
1:a991b64:      * comparing 2 values to decide for a CQL condition (see Operator.isSatisfiedBy) as
1:a991b64:      * for CQL, ReversedType is simply an "hint" to the storage engine but it does not
1:a991b64:      * change the meaning of queries per-se.
1:a991b64:      */
1:a991b64:     public int compareForCQL(ByteBuffer v1, ByteBuffer v2)
1:a991b64:     {
1:a991b64:         return compare(v1, v2);
1:a991b64:     }
1:a991b64: 
1:fc8b76f:     public abstract TypeSerializer<T> getSerializer();
1:a67f779: 
1:ad38251:     /* convenience method */
1:e7a385a:     public String getString(Collection<ByteBuffer> names)
1:c7b02d1:     {
2:986cee6:         StringBuilder builder = new StringBuilder();
1:e7a385a:         for (ByteBuffer name : names)
1:98c4a7c:         {
1:986cee6:             builder.append(getString(name)).append(",");
1:07594ee:         }
2:986cee6:         return builder.toString();
1:07594ee:     }
1:07594ee: 
1:c8a0a3a:     public boolean isCounter()
1:dcc3bb0:     {
1:acf1b18:         return false;
1:677230d:     }
1:110a132: 
1:1de8e39:     public boolean isFrozenCollection()
1:677230d:     {
1:1de8e39:         return isCollection() && !isMultiCell();
1:ee55f36:     }
1:1de8e39: 
1:c12abfb:     public boolean isReversed()
1:ee55f36:     {
1:c12abfb:         return false;
1:4df4f79:     }
1:c12abfb: 
1:3a2faf9:     public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws SyntaxException
1:07594ee:     {
1:522d0dd:         Map<String, String> parameters = parser.getKeyValueParameters();
1:522d0dd:         String reversed = parameters.get("reversed");
1:522d0dd:         if (reversed != null && (reversed.isEmpty() || reversed.equals("true")))
1:522d0dd:         {
1:522d0dd:             return ReversedType.getInstance(baseType);
1:522d0dd:         }
3:4d34917:         else
1:4d34917:         {
1:522d0dd:             return baseType;
1:4d34917:         }
1:4d34917:     }
1:522d0dd: 
1:522d0dd:     /**
1:0fdab63:      * Returns true if this comparator is compatible with the provided
1:0fdab63:      * previous comparator, that is if previous can safely be replaced by this.
1:0fdab63:      * A comparator cn should be compatible with a previous one cp if forall columns c1 and c2,
1:0fdab63:      * if   cn.validate(c1) and cn.validate(c2) and cn.compare(c1, c2) == v,
1:0fdab63:      * then cp.validate(c1) and cp.validate(c2) and cp.compare(c1, c2) == v.
1:0fdab63:      *
1:0fdab63:      * Note that a type should be compatible with at least itself and when in
1:0fdab63:      * doubt, keep the default behavior of not being compatible with any other comparator!
1:0fdab63:      */
1:0fdab63:     public boolean isCompatibleWith(AbstractType<?> previous)
1:4d34917:     {
1:189a607:         return this.equals(previous);
1:189a607:     }
1:189a607: 
1:189a607:     /**
1:9da742d:      * Returns true if values of the other AbstractType can be read and "reasonably" interpreted by the this
1:9da742d:      * AbstractType. Note that this is a weaker version of isCompatibleWith, as it does not require that both type
1:9da742d:      * compare values the same way.
1:189a607:      *
1:9da742d:      * The restriction on the other type being "reasonably" interpreted is to prevent, for example, IntegerType from
1:9da742d:      * being compatible with all other types.  Even though any byte string is a valid IntegerType value, it doesn't
1:9da742d:      * necessarily make sense to interpret a UUID or a UTF8 string as an integer.
1:d62b2cf:      *
1:189a607:      * Note that a type should be compatible with at least itself.
1:189a607:      */
1:9da742d:     public boolean isValueCompatibleWith(AbstractType<?> otherType)
1:189a607:     {
1:9da742d:         return isValueCompatibleWithInternal((otherType instanceof ReversedType) ? ((ReversedType) otherType).baseType : otherType);
1:4d34917:     }
1:0fdab63: 
1:0fdab63:     /**
1:9da742d:      * Needed to handle ReversedType in value-compatibility checks.  Subclasses should implement this instead of
1:9da742d:      * isValueCompatibleWith().
1:9da742d:      */
1:9da742d:     protected boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
1:0fdab63:     {
1:9da742d:         return isCompatibleWith(otherType);
1:0fdab63:     }
1:9da742d: 
1:9da742d:     /**
1:91bdf7f:      * An alternative comparison function used by CollectionsType in conjunction with CompositeType.
1:91bdf7f:      *
1:91bdf7f:      * This comparator is only called to compare components of a CompositeType. It gets the value of the
1:91bdf7f:      * previous component as argument (or null if it's the first component of the composite).
1:91bdf7f:      *
1:91bdf7f:      * Unless you're doing something very similar to CollectionsType, you shouldn't override this.
1:91bdf7f:      */
1:91bdf7f:     public int compareCollectionMembers(ByteBuffer v1, ByteBuffer v2, ByteBuffer collectionName)
1:91bdf7f:     {
1:91bdf7f:         return compare(v1, v2);
1:91bdf7f:     }
1:91bdf7f: 
1:91bdf7f:     /**
1:91bdf7f:      * An alternative validation function used by CollectionsType in conjunction with CompositeType.
1:91bdf7f:      *
1:91bdf7f:      * This is similar to the compare function above.
1:91bdf7f:      */
1:91bdf7f:     public void validateCollectionMember(ByteBuffer bytes, ByteBuffer collectionName) throws MarshalException
1:91bdf7f:     {
1:91bdf7f:         validate(bytes);
1:91bdf7f:     }
1:91bdf7f: 
1:2b62df2:     public boolean isCollection()
1:2b62df2:     {
1:2b62df2:         return false;
1:2b62df2:     }
1:2b62df2: 
1:677230d:     public boolean isUDT()
1:522d0dd:     {
1:677230d:         return false;
1:522d0dd:     }
1:677230d: 
1:ee55f36:     public boolean isMultiCell()
1:85cc390:     {
1:ee55f36:         return false;
1:522d0dd:     }
1:ee55f36: 
1:677230d:     public boolean isFreezable()
1:677230d:     {
1:677230d:         return false;
1:677230d:     }
1:677230d: 
1:ee55f36:     public AbstractType<?> freeze()
1:ee55f36:     {
1:d62b2cf:         return this;
1:d62b2cf:     }
1:d62b2cf: 
1:91bdf7f:     /**
1:dee84cc:      * Returns an AbstractType instance that is equivalent to this one, but with all nested UDTs and collections
1:dee84cc:      * explicitly frozen.
1:d62b2cf:      *
1:fe7eee0:      * This is only necessary for {@code 2.x -> 3.x} schema migrations, and can be removed in Cassandra 4.0.
1:9da742d:      *
1:dee84cc:      * See CASSANDRA-11609 and CASSANDRA-11613.
1:07594ee:      */
1:dee84cc:     public AbstractType<?> freezeNestedMulticellTypes()
1:9da742d:     {
1:ee55f36:         return this;
1:ee55f36:     }
1:ee55f36: 
1:d62b2cf:     /**
1:4df4f79:      * Returns {@code true} for types where empty should be handled like {@code null} like {@link Int32Type}.
1:4df4f79:      */
1:4df4f79:     public boolean isEmptyValueMeaningless()
1:4df4f79:     {
1:4df4f79:         return false;
1:9da742d:     }
1:4df4f79: 
1:ee55f36:     /**
1:ee55f36:      * @param ignoreFreezing if true, the type string will not be wrapped with FrozenType(...), even if this type is frozen.
1:ee55f36:      */
1:ee55f36:     public String toString(boolean ignoreFreezing)
1:ee55f36:     {
1:ee55f36:         return this.toString();
1:ee55f36:     }
1:ee55f36: 
1:4df4f79:     /**
1:a950b92:      * The number of subcomponents this type has.
1:a950b92:      * This is always 1, i.e. the type has only itself as "subcomponents", except for CompositeType.
1:a950b92:      */
1:a950b92:     public int componentsCount()
1:a950b92:     {
1:a950b92:         return 1;
1:a950b92:     }
1:a950b92: 
1:a950b92:     /**
1:a950b92:      * Return a list of the "subcomponents" this type has.
1:a950b92:      * This always return a singleton list with the type itself except for CompositeType.
1:a950b92:      */
1:a950b92:     public List<AbstractType<?>> getComponents()
1:a950b92:     {
1:a950b92:         return Collections.<AbstractType<?>>singletonList(this);
1:a950b92:     }
1:a950b92: 
1:a950b92:     /**
1:a991b64:      * The length of values for this type if all values are of fixed length, -1 otherwise.
1:a991b64:      */
1:a991b64:     protected int valueLengthIfFixed()
1:a991b64:     {
1:a991b64:         return -1;
1:a991b64:     }
1:a991b64: 
1:a991b64:     // This assumes that no empty values are passed
1:a991b64:     public void writeValue(ByteBuffer value, DataOutputPlus out) throws IOException
1:a991b64:     {
1:a991b64:         assert value.hasRemaining();
1:a991b64:         if (valueLengthIfFixed() >= 0)
1:a991b64:             out.write(value);
1:a991b64:         else
1:2457599:             ByteBufferUtil.writeWithVIntLength(value, out);
1:a991b64:     }
1:a991b64: 
1:03f72ac:     public long writtenLength(ByteBuffer value)
1:a991b64:     {
1:a991b64:         assert value.hasRemaining();
1:a991b64:         return valueLengthIfFixed() >= 0
1:a991b64:              ? value.remaining()
1:2457599:              : TypeSizes.sizeofWithVIntLength(value);
1:a991b64:     }
1:a991b64: 
1:2457599:     public ByteBuffer readValue(DataInputPlus in) throws IOException
1:a991b64:     {
1:57ead56:         return readValue(in, Integer.MAX_VALUE);
1:4d34917:     }
1:57ead56: 
1:57ead56:     public ByteBuffer readValue(DataInputPlus in, int maxValueSize) throws IOException
1:4d34917:     {
1:a991b64:         int length = valueLengthIfFixed();
1:85cc390: 
1:a991b64:         if (length >= 0)
1:a991b64:             return ByteBufferUtil.read(in, length);
1:a991b64:         else
1:a991b64:         {
1:85cc390:             int l = (int)in.readUnsignedVInt();
1:85cc390:             if (l < 0)
1:85cc390:                 throw new IOException("Corrupt (negative) value length encountered");
1:a991b64: 
1:85cc390:             if (l > maxValueSize)
1:85cc390:                 throw new IOException(String.format("Corrupt value length %d encountered, as it exceeds the maximum of %d, " +
1:85cc390:                                                     "which is set via max_value_size_in_mb in cassandra.yaml",
1:85cc390:                                                     l, maxValueSize));
1:a991b64: 
1:85cc390:             return ByteBufferUtil.read(in, l);
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:2457599:     public void skipValue(DataInputPlus in) throws IOException
1:57ead56:     {
1:a991b64:         int length = valueLengthIfFixed();
1:2457599:         if (length >= 0)
1:ff27eb3:             in.skipBytesFully(length);
1:2457599:         else
1:2457599:             ByteBufferUtil.skipWithVIntLength(in);
1:4d34917:     }
1:85cc390: 
1:7a3c3ab:     public boolean referencesUserType(String userTypeName)
1:07594ee:     {
1:7a3c3ab:         return false;
1:4d34917:     }
1:85cc390: 
1:ecf05b8:     public boolean referencesDuration()
1:ecf05b8:     {
1:ecf05b8:         return false;
1:ecf05b8:     }
1:ecf05b8: 
1:a991b64:     /**
1:522d0dd:      * This must be overriden by subclasses if necessary so that for any
1:522d0dd:      * AbstractType, this == TypeParser.parse(toString()).
2:07594ee:      *
1:cc83c44:      * Note that for backwards compatibility this includes the full classname.
1:cc83c44:      * For CQL purposes the short name is fine.
1:522d0dd:      */
1:522d0dd:     @Override
1:522d0dd:     public String toString()
1:522d0dd:     {
1:522d0dd:         return getClass().getName();
1:522d0dd:     }
1:07594ee: 
1:677230d:     /**
1:677230d:      * Checks to see if two types are equal when ignoring or not ignoring differences in being frozen, depending on
1:677230d:      * the value of the ignoreFreezing parameter.
1:677230d:      * @param other type to compare
1:677230d:      * @param ignoreFreezing if true, differences in the types being frozen will be ignored
1:677230d:      */
1:677230d:     public boolean equals(Object other, boolean ignoreFreezing)
1:677230d:     {
1:677230d:         return this.equals(other);
1:85cc390:     }
1:677230d: 
1:07594ee:     public void checkComparable()
1:07594ee:     {
1:07594ee:         switch (comparisonType)
2:07594ee:         {
1:07594ee:             case NOT_COMPARABLE:
1:07594ee:                 throw new IllegalArgumentException(this + " cannot be used in comparisons, so cannot be used as a clustering column");
1:677230d:         }
1:07594ee:     }
1:4ed0060: 
1:4ed0060:     public final AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:4ed0060:     {
1:4ed0060:         // We should ignore the fact that the output type is frozen in our comparison as functions do not support
1:4ed0060:         // frozen types for arguments
1:4ed0060:         AbstractType<?> receiverType = receiver.type;
1:4ed0060:         if (isFreezable() && !isMultiCell())
1:4ed0060:             receiverType = receiverType.freeze();
1:4ed0060: 
1:4ed0060:         if (isReversed())
1:4ed0060:             receiverType = ReversedType.getInstance(receiverType);
1:4ed0060: 
1:4ed0060:         if (equals(receiverType))
1:4ed0060:             return AssignmentTestable.TestResult.EXACT_MATCH;
1:4ed0060: 
1:4ed0060:         if (receiverType.isValueCompatibleWith(this))
1:4ed0060:             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:4ed0060: 
1:4ed0060:         return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:4ed0060:     }
1:07594ee: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
commit:a2b73a5
commit:68d20ed
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesDuration()
1:     {
1:         return false;
1:     }
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.AssignmentTestable;
1: import org.apache.cassandra.cql3.ColumnSpecification;
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractType<T> implements Comparator<ByteBuffer>, AssignmentTestable
/////////////////////////////////////////////////////////////////////////
1: 
1:     public final AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:     {
1:         // We should ignore the fact that the output type is frozen in our comparison as functions do not support
1:         // frozen types for arguments
1:         AbstractType<?> receiverType = receiver.type;
1:         if (isFreezable() && !isMultiCell())
1:             receiverType = receiverType.freeze();
1: 
1:         if (isReversed())
1:             receiverType = ReversedType.getInstance(receiverType);
1: 
1:         if (equals(receiverType))
1:             return AssignmentTestable.TestResult.EXACT_MATCH;
1: 
1:         if (receiverType.isValueCompatibleWith(this))
1:             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1: 
1:         return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:     }
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:             ByteBufferUtil.writeWithVIntLength(value, out);
/////////////////////////////////////////////////////////////////////////
1:              : TypeSizes.sizeofWithVIntLength(value);
1:     public ByteBuffer readValue(DataInputPlus in) throws IOException
0:             return ByteBufferUtil.readWithVIntLength(in);
1:     public void skipValue(DataInputPlus in) throws IOException
1:         if (length >= 0)
0:             FileUtils.skipBytesFully(in, length);
1:         else
1:             ByteBufferUtil.skipWithVIntLength(in);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.TypeSizes;
1: import org.apache.cassandra.io.util.DataOutputPlus;
0: import org.apache.cassandra.io.util.FileUtils;
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
1:         if (bytes == null)
1:             return "null";
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Same as compare except that this ignore ReversedType. This is to be use when
1:      * comparing 2 values to decide for a CQL condition (see Operator.isSatisfiedBy) as
1:      * for CQL, ReversedType is simply an "hint" to the storage engine but it does not
1:      * change the meaning of queries per-se.
1:      */
1:     public int compareForCQL(ByteBuffer v1, ByteBuffer v2)
1:     {
1:         return compare(v1, v2);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     * The length of values for this type if all values are of fixed length, -1 otherwise.
1:      */
1:     protected int valueLengthIfFixed()
1:     {
1:         return -1;
1:     }
1: 
1:     // This assumes that no empty values are passed
1:     public void writeValue(ByteBuffer value, DataOutputPlus out) throws IOException
1:     {
1:         assert value.hasRemaining();
1:         if (valueLengthIfFixed() >= 0)
1:             out.write(value);
1:         else
0:             ByteBufferUtil.writeWithLength(value, out);
1:     }
1: 
0:     public long writtenLength(ByteBuffer value, TypeSizes sizes)
1:     {
1:         assert value.hasRemaining();
1:         return valueLengthIfFixed() >= 0
1:              ? value.remaining()
0:              : sizes.sizeofWithLength(value);
1:     }
1: 
0:     public ByteBuffer readValue(DataInput in) throws IOException
1:     {
1:         int length = valueLengthIfFixed();
1:         if (length >= 0)
1:             return ByteBufferUtil.read(in, length);
1:         else
0:             return ByteBufferUtil.readWithLength(in);
1:     }
1: 
0:     public void skipValue(DataInput in) throws IOException
1:     {
1:         int length = valueLengthIfFixed();
0:         if (length < 0)
0:             length = in.readInt();
1: 
0:         FileUtils.skipBytesFully(in, length);
1:     }
1: 
1:     /**
commit:28497fd
commit:8dab582
commit:d6f32e4
/////////////////////////////////////////////////////////////////////////
1:         return serializer.toString(serializer.deserialize(bytes));
commit:64e4628
commit:362cc05
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5c54262
commit:189a607
/////////////////////////////////////////////////////////////////////////
1:         return this.equals(previous);
1:     }
1: 
1:     /**
0:      * Returns true if values of the previous AbstracType can be read by the this
0:      * AbsractType. Note that this is a weaker version of isCompatibleWith, as it
0:      * does not require that both type compare values the same way.
1:      *
1:      * Note that a type should be compatible with at least itself.
1:      */
0:     public boolean isValueCompatibleWith(AbstractType<?> previous)
1:     {
0:         return isCompatibleWith(previous);
commit:daff1fc
/////////////////////////////////////////////////////////////////////////
1:     public T compose(ByteBuffer bytes)
1:     {
1:         return getSerializer().deserialize(bytes);
1:     }
1:     public ByteBuffer decompose(T value)
1:     {
1:         return getSerializer().serialize(value);
1:     }
1:     public String getString(ByteBuffer bytes)
1:     {
1:         TypeSerializer<T> serializer = getSerializer();
1:         serializer.validate(bytes);
1: 
0:         T value = serializer.deserialize(bytes);
0:         return value == null ? "null" : serializer.toString(value);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void validate(ByteBuffer bytes) throws MarshalException
1:     {
1:         getSerializer().validate(bytes);
1:     }
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.TypeSerializer;
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1:     public abstract TypeSerializer<T> getSerializer();
commit:9ec7b80
/////////////////////////////////////////////////////////////////////////
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.AbstractSerializer;
0: import org.apache.cassandra.type.MarshalException;
/////////////////////////////////////////////////////////////////////////
0:     public abstract AbstractSerializer<T> asComposer();
1: 
commit:a950b92
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:      * The number of subcomponents this type has.
1:      * This is always 1, i.e. the type has only itself as "subcomponents", except for CompositeType.
1:      */
1:     public int componentsCount()
1:     {
1:         return 1;
1:     }
1: 
1:     /**
1:      * Return a list of the "subcomponents" this type has.
1:      * This always return a singleton list with the type itself except for CompositeType.
1:      */
1:     public List<AbstractType<?>> getComponents()
1:     {
1:         return Collections.<AbstractType<?>>singletonList(this);
1:     }
1: 
1:     /**
commit:aae62a7
commit:31e669a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d66630d
commit:a67f779
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
1: import org.apache.cassandra.cql3.CQL3Type;
1: import org.apache.cassandra.cql3.Term;
/////////////////////////////////////////////////////////////////////////
0:     /* CQL3 types will actually override this, but we use a default for compatibility sake */
0:     public Set<Term.Type> supportedCQL3Constants()
1:     {
0:         return null;
1:     }
1: 
1:     /* Most of our internal type should override that. */
1:     public CQL3Type asCQL3Type()
1:     {
1:         return new CQL3Type.Custom(this);
1:     }
1: 
commit:6b02851
commit:8be7e5c
/////////////////////////////////////////////////////////////////////////
0:     /** for compatibility with TimeUUID in CQL2. See TimeUUIDType (that overrides it). */
0:     public ByteBuffer fromStringCQL2(String source) throws MarshalException
1:     {
0:         return fromString(source);
1:     }
1: 
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Column;
/////////////////////////////////////////////////////////////////////////
0:     public final Comparator<Column> columnComparator;
0:     public final Comparator<Column> columnReverseComparator;
/////////////////////////////////////////////////////////////////////////
0:         columnComparator = new Comparator<Column>()
0:             public int compare(Column c1, Column c2)
0:         columnReverseComparator = new Comparator<Column>()
0:             public int compare(Column c1, Column c2)
/////////////////////////////////////////////////////////////////////////
0:     public String getColumnsString(Collection<Column> columns)
0:         for (Column column : columns)
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws SyntaxException
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
1:     public boolean isCollection()
1:     {
1:         return false;
1:     }
1: 
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1:      * An alternative comparison function used by CollectionsType in conjunction with CompositeType.
1:      *
1:      * This comparator is only called to compare components of a CompositeType. It gets the value of the
1:      * previous component as argument (or null if it's the first component of the composite).
1:      *
1:      * Unless you're doing something very similar to CollectionsType, you shouldn't override this.
1:      */
1:     public int compareCollectionMembers(ByteBuffer v1, ByteBuffer v2, ByteBuffer collectionName)
1:     {
1:         return compare(v1, v2);
1:     }
1: 
1:     /**
1:      * An alternative validation function used by CollectionsType in conjunction with CompositeType.
1:      *
1:      * This is similar to the compare function above.
1:      */
1:     public void validateCollectionMember(ByteBuffer bytes, ByteBuffer collectionName) throws MarshalException
1:     {
1:         validate(bytes);
1:     }
1: 
1:     /**
commit:34498a9
/////////////////////////////////////////////////////////////////////////
0:                         int comp2 = AbstractType.this.compare(t1.max, t2.max);
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.OnDiskAtom;
0: import org.apache.cassandra.db.RangeTombstone;
/////////////////////////////////////////////////////////////////////////
0:     public final Comparator<OnDiskAtom> onDiskAtomComparator;
/////////////////////////////////////////////////////////////////////////
0:         onDiskAtomComparator = new Comparator<OnDiskAtom>()
1:         {
0:             public int compare(OnDiskAtom c1, OnDiskAtom c2)
1:             {
0:                 int comp = AbstractType.this.compare(c1.name(), c2.name());
0:                 if (comp != 0)
0:                     return comp;
1: 
0:                 if (c1 instanceof RangeTombstone)
1:                 {
0:                     if (c2 instanceof RangeTombstone)
1:                     {
0:                         RangeTombstone t1 = (RangeTombstone)c1;
0:                         RangeTombstone t2 = (RangeTombstone)c2;
0:                         int comp2 = AbstractType.this.compare(t1.max, t1.max);
0:                         if (comp2 == 0)
0:                             return t1.data.compareTo(t2.data);
1:                         else
0:                             return comp2;
1:                     }
1:                     else
1:                     {
0:                         return -1;
1:                     }
1:                 }
0:                 else if (c2 instanceof RangeTombstone)
1:                 {
0:                     return 1;
1:                 }
1:                 else
1:                 {
0:                     return 0;
1:                 }
1:             }
0:         };
commit:bc577ba
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.db.marshal;
commit:0fdab63
/////////////////////////////////////////////////////////////////////////
1:      * Returns true if this comparator is compatible with the provided
1:      * previous comparator, that is if previous can safely be replaced by this.
1:      * A comparator cn should be compatible with a previous one cp if forall columns c1 and c2,
1:      * if   cn.validate(c1) and cn.validate(c2) and cn.compare(c1, c2) == v,
1:      * then cp.validate(c1) and cp.validate(c2) and cp.compare(c1, c2) == v.
1:      *
1:      * Note that a type should be compatible with at least itself and when in
1:      * doubt, keep the default behavior of not being compatible with any other comparator!
1:      */
1:     public boolean isCompatibleWith(AbstractType<?> previous)
1:     {
0:         return this == previous;
1:     }
1: 
1:     /**
commit:6ea00a3
/////////////////////////////////////////////////////////////////////////
0:                 return AbstractType.this.compare(o2, o1);
commit:b76a5b5
/////////////////////////////////////////////////////////////////////////
1: 
commit:522d0dd
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static AbstractType parseDefaultParameters(AbstractType baseType, TypeParser parser) throws ConfigurationException
1:     {
1:         Map<String, String> parameters = parser.getKeyValueParameters();
1:         String reversed = parameters.get("reversed");
1:         if (reversed != null && (reversed.isEmpty() || reversed.equals("true")))
1:         {
1:             return ReversedType.getInstance(baseType);
1:         }
0:         else
1:         {
1:             return baseType;
1:         }
1:     }
1: 
1:     /**
1:      * This must be overriden by subclasses if necessary so that for any
1:      * AbstractType, this == TypeParser.parse(toString()).
1:      */
1:     @Override
1:     public String toString()
1:     {
1:         return getClass().getName();
1:     }
author:Alex Petrov
-------------------------------------------------------------------------------
commit:57ead56
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return readValue(in, Integer.MAX_VALUE);
1:     }
1: 
1:     public ByteBuffer readValue(DataInputPlus in, int maxValueSize) throws IOException
1:     {
commit:85cc390
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.annotations.VisibleForTesting;
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public enum ComparisonType
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * The maximum size of values for this type, used when some values are not of fixed length,
0:      * that is valueLengthIfFixed() returns -1.
1:      */
0:     public int maxValueSize;
1: 
0:         this(comparisonType, DatabaseDescriptor.getMaxValueSize());
1:     }
1: 
0:     protected AbstractType(ComparisonType comparisonType, int maxValueSize)
1:     {
0:         this.maxValueSize = maxValueSize;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Change the maximum value size, this should only be called for testing.
0:      * Unfortunately, ensuring we use a type created with a different maxValueSize
0:      * is too hard at the moment, due to the pervasive use of the type's singleton instances.
1:      */
0:     @VisibleForTesting
0:     public void setMaxValueSize(int maxValueSize)
1:     {
0:         this.maxValueSize = maxValueSize;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:      * The length of values for this type if all values are of fixed length, -1 otherwise.
/////////////////////////////////////////////////////////////////////////
1: 
1:         {
1:             int l = (int)in.readUnsignedVInt();
1:             if (l < 0)
1:                 throw new IOException("Corrupt (negative) value length encountered");
1: 
1:             if (l > maxValueSize)
1:                 throw new IOException(String.format("Corrupt value length %d encountered, as it exceeds the maximum of %d, " +
1:                                                     "which is set via max_value_size_in_mb in cassandra.yaml",
1:                                                     l, maxValueSize));
1: 
1:             return ByteBufferUtil.read(in, l);
1:         }
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:dee84cc
/////////////////////////////////////////////////////////////////////////
1:      * Returns an AbstractType instance that is equivalent to this one, but with all nested UDTs and collections
1:      * explicitly frozen.
1:      * See CASSANDRA-11609 and CASSANDRA-11613.
1:     public AbstractType<?> freezeNestedMulticellTypes()
commit:d62b2cf
/////////////////////////////////////////////////////////////////////////
0:      * Returns an AbstractType instance that is equivalent to this one, but with all nested UDTs explicitly frozen and
0:      * all collections in UDTs explicitly frozen.
1:      *
0:      * This is only necessary for 2.x -> 3.x schema migrations, and can be removed in Cassandra 4.0.
1:      *
0:      * See CASSANDRA-11609
1:      */
0:     public AbstractType<?> freezeNestedUDTs()
1:     {
1:         return this;
1:     }
1: 
1:     /**
commit:677230d
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUDT()
1:     {
1:         return false;
1:     }
1: 
1:     public boolean isFreezable()
1:     {
1:         return false;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks to see if two types are equal when ignoring or not ignoring differences in being frozen, depending on
1:      * the value of the ignoreFreezing parameter.
1:      * @param other type to compare
1:      * @param ignoreFreezing if true, differences in the types being frozen will be ignored
1:      */
1:     public boolean equals(Object other, boolean ignoreFreezing)
1:     {
1:         return this.equals(other);
1:     }
1: 
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.Term;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** Given a parsed JSON string, return a byte representation of the object.
1:      * @param parsed the result of parsing a json string
1:      **/
1:     public abstract Term fromJSONObject(Object parsed) throws MarshalException;
1: 
1:     /** Converts a value to a JSON string. */
0:     public String toJSONString(ByteBuffer buffer, int protocolVersion)
1:     {
1:         return '"' + getSerializer().deserialize(buffer).toString() + '"';
1:     }
1: 
commit:699a69d
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
1:     public boolean isMultiCell()
1:     {
1:         return false;
1:     }
1: 
1:     public AbstractType<?> freeze()
1:     {
1:         return this;
1:     }
1: 
1:     /**
1:      * @param ignoreFreezing if true, the type string will not be wrapped with FrozenType(...), even if this type is frozen.
1:      */
1:     public String toString(boolean ignoreFreezing)
1:     {
1:         return this.toString();
1:     }
1: 
commit:5101687
commit:9dcdb8b
commit:9da742d
/////////////////////////////////////////////////////////////////////////
1:      * Returns true if values of the other AbstractType can be read and "reasonably" interpreted by the this
1:      * AbstractType. Note that this is a weaker version of isCompatibleWith, as it does not require that both type
1:      * compare values the same way.
1:      *
1:      * The restriction on the other type being "reasonably" interpreted is to prevent, for example, IntegerType from
1:      * being compatible with all other types.  Even though any byte string is a valid IntegerType value, it doesn't
1:      * necessarily make sense to interpret a UUID or a UTF8 string as an integer.
1:     public boolean isValueCompatibleWith(AbstractType<?> otherType)
1:         return isValueCompatibleWithInternal((otherType instanceof ReversedType) ? ((ReversedType) otherType).baseType : otherType);
1:     }
1: 
1:     /**
1:      * Needed to handle ReversedType in value-compatibility checks.  Subclasses should implement this instead of
1:      * isValueCompatibleWith().
1:      */
1:     protected boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
1:     {
1:         return isCompatibleWith(otherType);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:fe7eee0
/////////////////////////////////////////////////////////////////////////
1:      * This is only necessary for {@code 2.x -> 3.x} schema migrations, and can be removed in Cassandra 4.0.
commit:bc6b5f4
commit:56f35db
/////////////////////////////////////////////////////////////////////////
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesUserType(String userTypeName)
1:         return false;
commit:e94032a
/////////////////////////////////////////////////////////////////////////
1:     /** get a string representation of the bytes used for various identifier (NOT just for log messages) */
commit:e6f23e6
commit:1de63e9
commit:98c4a7c
/////////////////////////////////////////////////////////////////////////
0:      * Checks whether this type or any of the types this type contains references the given type.
1:      */
0:     public boolean references(AbstractType<?> check)
1:     {
0:         return this.equals(check);
1:     }
1: 
1:     /**
commit:4df4f79
/////////////////////////////////////////////////////////////////////////
1:      * Returns {@code true} for types where empty should be handled like {@code null} like {@link Int32Type}.
1:      */
1:     public boolean isEmptyValueMeaningless()
1:     {
1:         return false;
1:     }
1: 
1:     /**
commit:dcc3bb0
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     public static List<String> asCQLTypeStringList(List<AbstractType<?>> abstractTypes)
1:     {
1:         List<String> r = new ArrayList<>(abstractTypes.size());
1:         for (AbstractType<?> abstractType : abstractTypes)
1:             r.add(abstractType.asCQL3Type().toString());
1:         return r;
1:     }
1: 
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ff27eb3
/////////////////////////////////////////////////////////////////////////
1:             in.skipBytesFully(length);
commit:07594ee
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FastByteOperations;
1: import static org.apache.cassandra.db.marshal.AbstractType.ComparisonType.CUSTOM;
0: import static org.apache.cassandra.db.marshal.AbstractType.ComparisonType.NOT_COMPARABLE;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(AbstractType.class);
1: 
0:     public static enum ComparisonType
1:         /**
1:          * This type should never be compared
1:          */
1:         NOT_COMPARABLE,
1:         /**
1:          * This type is always compared by its sequence of unsigned bytes
1:          */
1:         BYTE_ORDER,
1:         /**
1:          * This type can only be compared by calling the type's compareCustom() method, which may be expensive.
1:          * Support for this may be removed in a major release of Cassandra, however upgrade facilities will be
1:          * provided if and when this happens.
1:          */
1:         CUSTOM
1:     }
1:     public final ComparisonType comparisonType;
1:     public final boolean isByteOrderComparable;
1:     protected AbstractType(ComparisonType comparisonType)
1:     {
1:         this.comparisonType = comparisonType;
1:         this.isByteOrderComparable = comparisonType == ComparisonType.BYTE_ORDER;
1:         reverseComparator = (o1, o2) -> AbstractType.this.compare(o2, o1);
1:         try
1:         {
1:             Method custom = getClass().getMethod("compareCustom", ByteBuffer.class, ByteBuffer.class);
1:             if ((custom.getDeclaringClass() == AbstractType.class) == (comparisonType == CUSTOM))
1:                 throw new IllegalStateException((comparisonType == CUSTOM ? "compareCustom must be overridden if ComparisonType is CUSTOM"
1:                                                                          : "compareCustom should not be overridden if ComparisonType is not CUSTOM")
1:                                                 + " (" + getClass().getSimpleName() + ")");
1:         }
1:         catch (NoSuchMethodException e)
1:         {
1:             throw new IllegalStateException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public final int compare(ByteBuffer left, ByteBuffer right)
1:     {
1:         return isByteOrderComparable
1:                ? FastByteOperations.compareUnsigned(left, right)
1:                : compareCustom(left, right);
1:     }
1: 
0:     /**
1:      * Implement IFF ComparisonType is CUSTOM
1:      *
1:      * Compares the ByteBuffer representation of two instances of this class,
1:      * for types where this cannot be done by simple in-order comparison of the
1:      * unsigned bytes
1:      *
1:      * Standard Java compare semantics
1:      */
1:     public int compareCustom(ByteBuffer left, ByteBuffer right)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void checkComparable()
0:     {
1:         switch (comparisonType)
0:         {
1:             case NOT_COMPARABLE:
1:                 throw new IllegalArgumentException(this + " cannot be used in comparisons, so cannot be used as a clustering column");
0:         }
0:     }
author:blerer
-------------------------------------------------------------------------------
commit:d332c7e
commit:1de8e39
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFrozenCollection()
0:     {
1:         return isCollection() && !isMultiCell();
0:     }
1: 
commit:1bb2dd9
/////////////////////////////////////////////////////////////////////////
1: import org.github.jamm.Unmetered;
/////////////////////////////////////////////////////////////////////////
1: @Unmetered
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:c12abfb
/////////////////////////////////////////////////////////////////////////
1:     public boolean isReversed()
0:     {
1:         return false;
0:     }
1: 
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1:     public long writtenLength(ByteBuffer value)
0:              : TypeSizes.sizeofWithLength(value);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:ff4d159
commit:110a132
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Validate cell value. Unlike {@linkplain #validate(java.nio.ByteBuffer)},
1:      * cell value is passed to validate its content.
1:      * Usually, this is the same as validate except collection.
0:      *
1:      * @param cellValue ByteBuffer representing cell value
1:      * @throws MarshalException
0:      */
1:     public void validateCellValue(ByteBuffer cellValue) throws MarshalException
0:     {
1:         validate(cellValue);
0:     }
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
0:      * @return true IFF the byte representation of this type can be compared unsigned
0:      * and always return the same result as calling this object's compare or compareCollectionMembers methods
0:      */
0:     public boolean isByteOrderComparable()
0:     {
1:         return false;
0:     }
0: 
0:     /**
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:2621707
/////////////////////////////////////////////////////////////////////////
commit:c8a0a3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public boolean isCounter()
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.ColumnSlice;
0: import org.apache.cassandra.db.filter.SliceQueryFilter;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected boolean intersects(ByteBuffer minColName, ByteBuffer maxColName, ByteBuffer sliceStart, ByteBuffer sliceEnd)
0:     {
0:         return (sliceStart.equals(ByteBufferUtil.EMPTY_BYTE_BUFFER) || compare(maxColName, sliceStart) >= 0)
0:                && (sliceEnd.equals(ByteBufferUtil.EMPTY_BYTE_BUFFER) || compare(sliceEnd, minColName) >= 0);
0:     }
0: 
0:     public boolean intersects(List<ByteBuffer> minColumnNames, List<ByteBuffer> maxColumnNames, SliceQueryFilter filter)
0:     {
0:         assert minColumnNames.size() == 1;
0: 
0:         for (ColumnSlice slice : filter.slices)
0:         {
0:             ByteBuffer start = filter.isReversed() ? slice.finish : slice.start;
0:             ByteBuffer finish = filter.isReversed() ? slice.start : slice.finish;
0: 
0:             if (intersects(minColumnNames.get(0), maxColumnNames.get(0), start, finish))
0:                 return true;
0:         }
0:         return false;
0:     }
0: 
commit:aa76394
/////////////////////////////////////////////////////////////////////////
0:     public String getColumnsString(Iterable<Column> columns)
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
1:     /** get a byte representation of the given string. */
1:     public abstract ByteBuffer fromString(String source) throws MarshalException;
commit:2bc0d4d
/////////////////////////////////////////////////////////////////////////
0:     public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws ConfigurationException
commit:cc83c44
/////////////////////////////////////////////////////////////////////////
0:      *
1:      * Note that for backwards compatibility this includes the full classname.
1:      * For CQL purposes the short name is fine.
commit:c11eeb4
/////////////////////////////////////////////////////////////////////////
commit:5001907
/////////////////////////////////////////////////////////////////////////
0:     /** @deprecated use reverseComparator field instead */
commit:835669a
/////////////////////////////////////////////////////////////////////////
0: 
0:     //
0:     // JDBC metadata
0:     //
0: 
0:     public abstract boolean isSigned();
0:     public abstract boolean isCaseSensitive();
0:     public abstract boolean isCurrency();
0:     public abstract int getPrecision(T obj);
0:     public abstract int getScale(T obj);
0:     public abstract int getJdbcType();
0:     public abstract boolean needsQuotes();
commit:2d95cb4
/////////////////////////////////////////////////////////////////////////
0:     
0:     public abstract ByteBuffer decompose(T value);
commit:fad6615
commit:ae0275b
/////////////////////////////////////////////////////////////////////////
0:     public final Comparator<IColumn> columnComparator;
0:     public final Comparator<IColumn> columnReverseComparator;
1:     public final Comparator<ByteBuffer> reverseComparator;
0:                 return AbstractType.this.compare(o1.lastName, o2.lastName);
0:                 return AbstractType.this.compare(o1.firstName, o2.firstName);
0:         columnComparator = new Comparator<IColumn>()
0:         {
0:             public int compare(IColumn c1, IColumn c2)
0:             {
0:                 return AbstractType.this.compare(c1.name(), c2.name());
0:             }
0:         };
0:         columnReverseComparator = new Comparator<IColumn>()
0:         {
0:             public int compare(IColumn c1, IColumn c2)
0:             {
0:                 return AbstractType.this.compare(c2.name(), c1.name());
0:             }
0:         };
0:         reverseComparator = new Comparator<ByteBuffer>()
/////////////////////////////////////////////////////////////////////////
0:     /** @deprecated; use reverseComparator field instead */
0:     public Comparator<ByteBuffer> getReverseComparator()
0:     {
0:         return reverseComparator;
0:     }
0: 
0:     /** get a string representation of the bytes suitable for log messages */
0:     public abstract String getString(ByteBuffer bytes);
0: 
0:     /** get a byte representation of the given string.
0:      *  defaults to unsupportedoperation so people deploying custom Types can update at their leisure. */
0:     public ByteBuffer fromString(String source)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
1:     /* validate that the byte array is a valid sequence for the type we are supposed to be comparing */
0:     public abstract void validate(ByteBuffer bytes) throws MarshalException;
0: 
commit:a9cbaae
commit:1fb2d3b
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.io.sstable.IndexHelper.IndexInfo;
/////////////////////////////////////////////////////////////////////////
0:     public final Comparator<IndexInfo> indexComparator;
0:     public final Comparator<IndexInfo> indexReverseComparator;
0: 
0:     protected AbstractType()
0:     {
0:         final AbstractType that = this;
0:         indexComparator = new Comparator<IndexInfo>()
0:         {
0:             public int compare(IndexInfo o1, IndexInfo o2)
0:             {
0:                 return that.compare(o1.lastName, o2.lastName);
0:             }
0:         };
0:         indexReverseComparator = new Comparator<IndexInfo>()
0:         {
0:             public int compare(IndexInfo o1, IndexInfo o2)
0:             {
0:                 return that.compare(o1.firstName, o2.firstName);
0:             }
0:         };
0:     }
0: 
commit:ad38251
/////////////////////////////////////////////////////////////////////////
0:     /** get a byte representation of the given string.
0:      *  defaults to unsupportedoperation so people deploying custom Types can update at their leisure. */
0:     public ByteBuffer fromString(String source)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     /* validate that the byte array is a valid sequence for the type we are supposed to be comparing */
/////////////////////////////////////////////////////////////////////////
1:     /* convenience method */
/////////////////////////////////////////////////////////////////////////
0:     /* convenience method */
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
1: import java.util.Comparator;
1:  * Specifies a Comparator for a specific type of ByteBuffer.
1:  * Note that empty ByteBuffer are used to represent "start at the beginning"
1:  * represent a valid ByteBuffer for the type being compared.
0: public abstract class AbstractType implements Comparator<ByteBuffer>
0:     public abstract String getString(ByteBuffer bytes);
0:     public void validate(ByteBuffer bytes)
0:     public Comparator<ByteBuffer> getReverseComparator()
0:         return new Comparator<ByteBuffer>()
0:             public int compare(ByteBuffer o1, ByteBuffer o2)
0:                 if (o1.remaining() == 0)
0:                     return o2.remaining() == 0 ? 0 : -1;
0:                 if (o2.remaining() == 0)
/////////////////////////////////////////////////////////////////////////
1:     public String getString(Collection<ByteBuffer> names)
1:         for (ByteBuffer name : names)
commit:2e06336
/////////////////////////////////////////////////////////////////////////
commit:ca4a07e
/////////////////////////////////////////////////////////////////////////
0:             builder.append(column.getString(this)).append(",");
commit:1aeca2b
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
0:  */
0: 
commit:9f570c1
/////////////////////////////////////////////////////////////////////////
0:     public Comparator<byte[]> getReverseComparator()
0:     {
0:         return new Comparator<byte[]>()
0:         {
0:             public int compare(byte[] o1, byte[] o2)
0:             {
0:                 if (o1.length == 0)
0:                 {
0:                     return o2.length == 0 ? 0 : -1;
0:                 }
0:                 if (o2.length == 0)
0:                 {
0:                     return 1;
0:                 }
0: 
0:                 return -AbstractType.this.compare(o1, o2);
0:             }
0:         };
0:     }
0: 
commit:e3aef8e
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Specifies a Comparator for a specific type of byte[].
0:  *
0:  * Note that empty byte[] are used to represent "start at the beginning"
1:  * or "stop at the end" arguments to get_slice, so the Comparator
1:  * should always handle those values even if they normally do not
0:  * represent a valid byte[] for the type being compared.
0:  */
commit:986cee6
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db.marshal;
0: 
0: import java.util.Comparator;
1: import java.util.Collection;
0: 
0: import org.apache.cassandra.db.IColumn;
0: import org.apache.cassandra.db.SuperColumn;
0: 
0: public abstract class AbstractType implements Comparator<byte[]>
0: {
0:     /** get a string representation of the bytes suitable for log messages */
0:     public abstract String getString(byte[] bytes);
0: 
0:     /** validate that the byte array is a valid sequence for the type we are supposed to be comparing */
0:     public void validate(byte[] bytes)
0:     {
0:         getString(bytes);
0:     }
0: 
0:     /** convenience method */
0:     public String getString(Collection<byte[]> names)
0:     {
1:         StringBuilder builder = new StringBuilder();
0:         for (byte[] name : names)
0:         {
1:             builder.append(getString(name)).append(",");
0:         }
1:         return builder.toString();
0:     }
0: 
0:     /** convenience method */
0:     public String getColumnsString(Collection<IColumn> columns)
0:     {
1:         StringBuilder builder = new StringBuilder();
0:         for (IColumn column : columns)
0:         {
0:             builder.append(getString(column.name())).append(",");
0:         }
1:         return builder.toString();
0:     }
0: }
author:Eric Evans
-------------------------------------------------------------------------------
commit:a0d45f7
/////////////////////////////////////////////////////////////////////////
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:725bfa9
/////////////////////////////////////////////////////////////////////////
0:     /** get a string representation of a particular type. */
0:     public abstract String toString(T t);
0:     
commit:d4c800b
/////////////////////////////////////////////////////////////////////////
0:     
0:     /** returns the class this AbstractType represents. */
0:     public abstract Class<T> getType();
commit:4417e22
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer fromString(String source) throws MarshalException
commit:05d8ffd
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractType<T> implements Comparator<ByteBuffer>
/////////////////////////////////////////////////////////////////////////
0:     
0:     public abstract T compose(ByteBuffer bytes);
/////////////////////////////////////////////////////////////////////////
0:     /** @deprecated; use reverseComparator field instead */
0:     public Comparator<ByteBuffer> getReverseComparator()
0:     {
0:         return reverseComparator;
0:     }
0: 
commit:a4ebfe3
/////////////////////////////////////////////////////////////////////////
0:     public abstract void validate(ByteBuffer bytes) throws MarshalException;
commit:fbda616
/////////////////////////////////////////////////////////////////////////
0: 
0:     public final boolean equals(Object obj)
0:     {
0:         if (obj == null)
0:             return false;
0:         else
0:             return obj.getClass().getName().equals(getClass().getName());
0:     }
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:2c4ac98
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean isCommutative()
0:     {
0:         return false;
0:     }
============================================================================