1:17dd4cc: /**
1:17dd4cc:  * Licensed to the Apache Software Foundation (ASF) under one
1:17dd4cc:  * or more contributor license agreements.  See the NOTICE file
1:17dd4cc:  * distributed with this work for additional information
1:17dd4cc:  * regarding copyright ownership.  The ASF licenses this file
1:17dd4cc:  * to you under the Apache License, Version 2.0 (the
1:17dd4cc:  * "License"); you may not use this file except in compliance
1:17dd4cc:  * with the License.  You may obtain a copy of the License at
1:17dd4cc:  *
1:17dd4cc:  *   http://www.apache.org/licenses/LICENSE-2.0
1:17dd4cc:  *
1:17dd4cc:  * Unless required by applicable law or agreed to in writing,
1:17dd4cc:  * software distributed under the License is distributed on an
1:17dd4cc:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:17dd4cc:  * KIND, either express or implied.  See the License for the
1:17dd4cc:  * specific language governing permissions and limitations
1:17dd4cc:  * under the License.
1:17dd4cc:  *
1:17dd4cc:  */
1:17dd4cc: package org.apache.cassandra.utils.memory;
1:17dd4cc: 
1:17dd4cc: import java.nio.ByteBuffer;
1:17dd4cc: import java.util.*;
1:17dd4cc: import java.util.concurrent.*;
1:17dd4cc: 
1:17dd4cc: import org.junit.After;
1:17dd4cc: import org.junit.Before;
1:9797511: import org.junit.BeforeClass;
1:17dd4cc: import org.junit.Ignore;
1:17dd4cc: import org.junit.Test;
1:17dd4cc: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:17dd4cc: import org.apache.cassandra.io.compress.BufferType;
1:17dd4cc: import org.apache.cassandra.io.util.RandomAccessReader;
1:17dd4cc: 
1:17dd4cc: import static org.junit.Assert.*;
1:17dd4cc: 
1:17dd4cc: public class BufferPoolTest
1:17dd4cc: {
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:17dd4cc:     @Before
1:17dd4cc:     public void setUp()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.MEMORY_USAGE_THRESHOLD = 8 * 1024L * 1024L;
1:17dd4cc:         BufferPool.DISABLED = false;
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @After
1:17dd4cc:     public void cleanUp()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.reset();
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testGetPut() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         final int size = RandomAccessReader.DEFAULT_BUFFER_SIZE;
1:17dd4cc: 
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(size, buffer.capacity());
1:17dd4cc:         assertEquals(true, buffer.isDirect());
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:17dd4cc: 
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:         assertEquals(null, BufferPool.currentChunk());
1:17dd4cc:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testPageAligned()
1:17dd4cc:     {
1:17dd4cc:         final int size = 1024;
1:17dd4cc:         for (int i = size;
1:17dd4cc:                  i <= BufferPool.CHUNK_SIZE;
1:17dd4cc:                  i += size)
1:17dd4cc:         {
1:17dd4cc:             checkPageAligned(i);
1:17dd4cc:         }
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void checkPageAligned(int size)
1:17dd4cc:     {
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(size, buffer.capacity());
1:17dd4cc:         assertTrue(buffer.isDirect());
1:17dd4cc: 
1:17dd4cc:         long address = MemoryUtil.getAddress(buffer);
1:17dd4cc:         assertTrue((address % MemoryUtil.pageSize()) == 0);
1:17dd4cc: 
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testDifferentSizes() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         final int size1 = 1024;
1:17dd4cc:         final int size2 = 2048;
1:17dd4cc: 
1:17dd4cc:         ByteBuffer buffer1 = BufferPool.get(size1);
1:17dd4cc:         assertNotNull(buffer1);
1:17dd4cc:         assertEquals(size1, buffer1.capacity());
1:17dd4cc: 
1:17dd4cc:         ByteBuffer buffer2 = BufferPool.get(size2);
1:17dd4cc:         assertNotNull(buffer2);
1:17dd4cc:         assertEquals(size2, buffer2.capacity());
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:17dd4cc: 
1:17dd4cc:         BufferPool.put(buffer1);
1:17dd4cc:         BufferPool.put(buffer2);
1:17dd4cc: 
1:17dd4cc:         assertEquals(null, BufferPool.currentChunk());
1:17dd4cc:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMaxMemoryExceededDirect()
1:17dd4cc:     {
1:17dd4cc:         boolean cur = BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED;
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false;
1:17dd4cc: 
1:17dd4cc:         requestDoubleMaxMemory();
1:17dd4cc: 
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur;
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMaxMemoryExceededHeap()
1:17dd4cc:     {
1:17dd4cc:         boolean cur = BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED;
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1:17dd4cc: 
1:17dd4cc:         requestDoubleMaxMemory();
1:17dd4cc: 
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur;
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMaxMemoryExceeded_SameAsChunkSize()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.MEMORY_USAGE_THRESHOLD = BufferPool.GlobalPool.MACRO_CHUNK_SIZE;
1:17dd4cc:         requestDoubleMaxMemory();
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMaxMemoryExceeded_SmallerThanChunkSize()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.MEMORY_USAGE_THRESHOLD = BufferPool.GlobalPool.MACRO_CHUNK_SIZE / 2;
1:17dd4cc:         requestDoubleMaxMemory();
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testRecycle()
1:17dd4cc:     {
1:17dd4cc:         requestUpToSize(RandomAccessReader.DEFAULT_BUFFER_SIZE, 3 * BufferPool.CHUNK_SIZE);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void requestDoubleMaxMemory()
1:17dd4cc:     {
1:17dd4cc:         requestUpToSize(RandomAccessReader.DEFAULT_BUFFER_SIZE, (int)(2 * BufferPool.MEMORY_USAGE_THRESHOLD));
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void requestUpToSize(int bufferSize, int totalSize)
1:17dd4cc:     {
1:17dd4cc:         final int numBuffers = totalSize / bufferSize;
1:17dd4cc: 
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(numBuffers);
1:17dd4cc:         for (int i = 0; i < numBuffers; i++)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(bufferSize);
1:17dd4cc:             assertNotNull(buffer);
1:17dd4cc:             assertEquals(bufferSize, buffer.capacity());
1:17dd4cc: 
1:17dd4cc:             if (BufferPool.sizeInBytes() > BufferPool.MEMORY_USAGE_THRESHOLD)
1:17dd4cc:                 assertEquals(BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED, !buffer.isDirect());
1:17dd4cc: 
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         for (ByteBuffer buffer : buffers)
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc: 
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testBigRequest()
1:17dd4cc:     {
1:17dd4cc:         final int size = BufferPool.CHUNK_SIZE + 1;
1:17dd4cc: 
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(size, buffer.capacity());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testFillUpChunks()
1:17dd4cc:     {
1:17dd4cc:         final int size = RandomAccessReader.DEFAULT_BUFFER_SIZE;
1:17dd4cc:         final int numBuffers = BufferPool.CHUNK_SIZE / size;
1:17dd4cc: 
1:17dd4cc:         List<ByteBuffer> buffers1 = new ArrayList<>(numBuffers);
1:17dd4cc:         List<ByteBuffer> buffers2 = new ArrayList<>(numBuffers);
1:17dd4cc:         for (int i = 0; i < numBuffers; i++)
1:17dd4cc:             buffers1.add(BufferPool.get(size));
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk1 = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk1);
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < numBuffers; i++)
1:17dd4cc:             buffers2.add(BufferPool.get(size));
1:17dd4cc: 
1:17dd4cc:         assertEquals(2, BufferPool.numChunks());
1:17dd4cc: 
1:17dd4cc:         for (ByteBuffer buffer : buffers1)
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc: 
1:17dd4cc:         assertEquals(1, BufferPool.numChunks());
1:17dd4cc: 
1:17dd4cc:         for (ByteBuffer buffer : buffers2)
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc: 
1:17dd4cc:         assertEquals(0, BufferPool.numChunks());
1:17dd4cc: 
1:17dd4cc:         buffers2.clear();
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testOutOfOrderFrees()
1:17dd4cc:     {
1:17dd4cc:         final int size = 4096;
1:17dd4cc:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1:17dd4cc: 
1:17dd4cc:         final int[] idxs = new int[maxFreeSlots];
1:17dd4cc:         for (int i = 0; i < maxFreeSlots; i++)
1:17dd4cc:             idxs[i] = i;
1:17dd4cc: 
1:17dd4cc:         doTestFrees(size, maxFreeSlots, idxs);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testInOrderFrees()
1:17dd4cc:     {
1:17dd4cc:         final int size = 4096;
1:17dd4cc:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1:17dd4cc: 
1:17dd4cc:         final int[] idxs = new int[maxFreeSlots];
1:17dd4cc:         for (int i = 0; i < maxFreeSlots; i++)
1:17dd4cc:             idxs[i] = maxFreeSlots - 1 - i;
1:17dd4cc: 
1:17dd4cc:         doTestFrees(size, maxFreeSlots, idxs);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testRandomFrees()
1:17dd4cc:     {
1:17dd4cc:         doTestRandomFrees(12345567878L);
1:17dd4cc: 
1:17dd4cc:         BufferPool.reset();
1:17dd4cc:         doTestRandomFrees(20452249587L);
1:17dd4cc: 
1:17dd4cc:         BufferPool.reset();
1:17dd4cc:         doTestRandomFrees(82457252948L);
1:17dd4cc: 
1:17dd4cc:         BufferPool.reset();
1:17dd4cc:         doTestRandomFrees(98759284579L);
1:17dd4cc: 
1:17dd4cc:         BufferPool.reset();
1:17dd4cc:         doTestRandomFrees(19475257244L);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void doTestRandomFrees(long seed)
1:17dd4cc:     {
1:17dd4cc:         final int size = 4096;
1:17dd4cc:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1:17dd4cc: 
1:17dd4cc:         final int[] idxs = new int[maxFreeSlots];
1:17dd4cc:         for (int i = 0; i < maxFreeSlots; i++)
1:17dd4cc:             idxs[i] = maxFreeSlots - 1 - i;
1:17dd4cc: 
1:17dd4cc:         Random rnd = new Random();
1:17dd4cc:         rnd.setSeed(seed);
1:17dd4cc:         for (int i = idxs.length - 1; i > 0; i--)
1:17dd4cc:         {
1:17dd4cc:             int idx = rnd.nextInt(i+1);
1:17dd4cc:             int v = idxs[idx];
1:17dd4cc:             idxs[idx] = idxs[i];
1:17dd4cc:             idxs[i] = v;
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         doTestFrees(size, maxFreeSlots, idxs);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void doTestFrees(final int size, final int maxFreeSlots, final int[] toReleaseIdxs)
1:17dd4cc:     {
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(maxFreeSlots);
1:17dd4cc:         for (int i = 0; i < maxFreeSlots; i++)
1:17dd4cc:         {
1:17dd4cc:             buffers.add(BufferPool.get(size));
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertFalse(chunk.isFree());
1:17dd4cc: 
1:17dd4cc:         int freeSize = BufferPool.CHUNK_SIZE - maxFreeSlots * size;
1:17dd4cc:         assertEquals(freeSize, chunk.free());
1:17dd4cc: 
1:17dd4cc:         for (int i : toReleaseIdxs)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = buffers.get(i);
1:17dd4cc:             assertNotNull(buffer);
1:17dd4cc:             assertEquals(size, buffer.capacity());
1:17dd4cc: 
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc: 
1:17dd4cc:             freeSize += size;
1:17dd4cc:             if (freeSize == chunk.capacity())
1:17dd4cc:                 assertEquals(0, chunk.free());
1:17dd4cc:             else
1:17dd4cc:                 assertEquals(freeSize, chunk.free());
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         assertFalse(chunk.isFree());
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testDifferentSizeBuffersOnOneChunk()
1:17dd4cc:     {
1:17dd4cc:         int[] sizes = new int[] {
1:17dd4cc:             5, 1024, 4096, 8, 16000, 78, 512, 256, 63, 55, 89, 90, 255, 32, 2048, 128
1:17dd4cc:         };
1:17dd4cc: 
1:17dd4cc:         int sum = 0;
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1:17dd4cc:         for (int i = 0; i < sizes.length; i++)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(sizes[i]);
1:17dd4cc:             assertNotNull(buffer);
1:17dd4cc:             assertTrue(buffer.capacity() >= sizes[i]);
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc: 
1:17dd4cc:             sum += BufferPool.currentChunk().roundUp(buffer.capacity());
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         // else the test will fail, adjust sizes as required
1:17dd4cc:         assertTrue(sum <= BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc: 
1:17dd4cc:         Random rnd = new Random();
1:17dd4cc:         rnd.setSeed(298347529L);
1:17dd4cc:         while (!buffers.isEmpty())
1:17dd4cc:         {
1:17dd4cc:             int index = rnd.nextInt(buffers.size());
1:17dd4cc:             ByteBuffer buffer = buffers.remove(index);
1:17dd4cc: 
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         assertEquals(null, BufferPool.currentChunk());
1:17dd4cc:         assertEquals(0, chunk.free());
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testChunkExhausted()
1:17dd4cc:     {
1:17dd4cc:         final int size = BufferPool.CHUNK_SIZE / 64; // 1kbit
1:17dd4cc:         int[] sizes = new int[128];
1:17dd4cc:         Arrays.fill(sizes, size);
1:17dd4cc: 
1:17dd4cc:         int sum = 0;
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1:17dd4cc:         for (int i = 0; i < sizes.length; i++)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(sizes[i]);
1:17dd4cc:             assertNotNull(buffer);
1:17dd4cc:             assertTrue(buffer.capacity() >= sizes[i]);
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc: 
1:17dd4cc:             sum += buffer.capacity();
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         // else the test will fail, adjust sizes as required
1:17dd4cc:         assertTrue(sum <= BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1:17dd4cc: 
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < sizes.length; i++)
1:17dd4cc:         {
1:17dd4cc:             BufferPool.put(buffers.get(i));
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         assertEquals(null, BufferPool.currentChunk());
1:17dd4cc:         assertEquals(0, chunk.free());
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testCompactIfOutOfCapacity()
1:17dd4cc:     {
1:17dd4cc:         final int size = 4096;
1:17dd4cc:         final int numBuffersInChunk = BufferPool.GlobalPool.MACRO_CHUNK_SIZE / size;
1:17dd4cc: 
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(numBuffersInChunk);
1:17dd4cc:         Set<Long> addresses = new HashSet<>(numBuffersInChunk);
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < numBuffersInChunk; i++)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc:             addresses.add(MemoryUtil.getAddress(buffer));
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         for (int i = numBuffersInChunk - 1; i >= 0; i--)
1:17dd4cc:             BufferPool.put(buffers.get(i));
1:17dd4cc: 
1:17dd4cc:         buffers.clear();
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < numBuffersInChunk; i++)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:             assertNotNull(buffer);
1:17dd4cc:             assertEquals(size, buffer.capacity());
1:17dd4cc:             addresses.remove(MemoryUtil.getAddress(buffer));
1:17dd4cc: 
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         assertTrue(addresses.isEmpty()); // all 5 released buffers were used
1:17dd4cc: 
1:17dd4cc:         for (ByteBuffer buffer : buffers)
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testHeapBuffer()
1:17dd4cc:     {
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(1024, BufferType.ON_HEAP);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(1024, buffer.capacity());
1:17dd4cc:         assertFalse(buffer.isDirect());
1:17dd4cc:         assertNotNull(buffer.array());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testSingleBufferOneChunk()
1:17dd4cc:     {
1:17dd4cc:         checkBuffer(0);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(1);
1:17dd4cc:         checkBuffer(2);
1:17dd4cc:         checkBuffer(4);
1:17dd4cc:         checkBuffer(5);
1:17dd4cc:         checkBuffer(8);
1:17dd4cc:         checkBuffer(16);
1:17dd4cc:         checkBuffer(32);
1:17dd4cc:         checkBuffer(64);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(65);
1:17dd4cc:         checkBuffer(127);
1:17dd4cc:         checkBuffer(128);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(129);
1:17dd4cc:         checkBuffer(255);
1:17dd4cc:         checkBuffer(256);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(512);
1:17dd4cc:         checkBuffer(1024);
1:17dd4cc:         checkBuffer(2048);
1:17dd4cc:         checkBuffer(4096);
1:17dd4cc:         checkBuffer(8192);
1:17dd4cc:         checkBuffer(16384);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(16385);
1:17dd4cc:         checkBuffer(32767);
1:17dd4cc:         checkBuffer(32768);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(32769);
1:17dd4cc:         checkBuffer(33172);
1:17dd4cc:         checkBuffer(33553);
1:17dd4cc:         checkBuffer(36000);
1:17dd4cc:         checkBuffer(65535);
1:17dd4cc:         checkBuffer(65536);
1:17dd4cc: 
1:17dd4cc:         checkBuffer(65537);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void checkBuffer(int size)
1:17dd4cc:     {
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:         assertEquals(size, buffer.capacity());
1:17dd4cc: 
1:17dd4cc:         if (size > 0 && size < BufferPool.CHUNK_SIZE)
1:17dd4cc:         {
1:17dd4cc:             BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:             assertNotNull(chunk);
1:17dd4cc:             assertEquals(chunk.capacity(), chunk.free() + chunk.roundUp(size));
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMultipleBuffersOneChunk()
1:17dd4cc:     {
1:17dd4cc:         checkBuffers(32768, 33553);
1:17dd4cc:         checkBuffers(32768, 32768);
1:17dd4cc:         checkBuffers(48450, 33172);
1:17dd4cc:         checkBuffers(32768, 15682, 33172);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void checkBuffers(int ... sizes)
1:17dd4cc:     {
1:17dd4cc:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1:17dd4cc: 
1:17dd4cc:         for (int size : sizes)
1:17dd4cc:         {
1:17dd4cc:             ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc:             assertEquals(size, buffer.capacity());
1:17dd4cc: 
1:17dd4cc:             buffers.add(buffer);
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         for (ByteBuffer buffer : buffers)
1:17dd4cc:             BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testBuffersWithGivenSlots()
1:17dd4cc:     {
1:17dd4cc:         checkBufferWithGivenSlots(21241, (-1L << 27) ^ (1L << 40));
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void checkBufferWithGivenSlots(int size, long freeSlots)
1:17dd4cc:     {
1:17dd4cc:         //first allocate to make sure there is a chunk
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(size);
1:17dd4cc: 
1:17dd4cc:         // now get the current chunk and override the free slots mask
1:17dd4cc:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc:         long oldFreeSlots = chunk.setFreeSlots(freeSlots);
1:17dd4cc: 
1:17dd4cc:         // now check we can still get the buffer with the free slots mask changed
1:17dd4cc:         ByteBuffer buffer2 = BufferPool.get(size);
1:17dd4cc:         assertEquals(size, buffer.capacity());
1:17dd4cc:         BufferPool.put(buffer2);
1:17dd4cc: 
1:17dd4cc:         // reset the free slots
1:17dd4cc:         chunk.setFreeSlots(oldFreeSlots);
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testZeroSizeRequest()
1:17dd4cc:     {
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(0);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(0, buffer.capacity());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test(expected = IllegalArgumentException.class)
1:17dd4cc:     public void testNegativeSizeRequest()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.get(-1);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testBufferPoolDisabled()
1:17dd4cc:     {
1:17dd4cc:         BufferPool.DISABLED = true;
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(1024);
1:17dd4cc:         assertEquals(0, BufferPool.numChunks());
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(1024, buffer.capacity());
1:17dd4cc:         assertFalse(buffer.isDirect());
1:17dd4cc:         assertNotNull(buffer.array());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:         assertEquals(0, BufferPool.numChunks());
1:17dd4cc: 
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false;
1:17dd4cc:         buffer = BufferPool.get(1024);
1:17dd4cc:         assertEquals(0, BufferPool.numChunks());
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(1024, buffer.capacity());
1:17dd4cc:         assertTrue(buffer.isDirect());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:         assertEquals(0, BufferPool.numChunks());
1:17dd4cc: 
1:17dd4cc:         // clean-up
1:17dd4cc:         BufferPool.DISABLED = false;
1:17dd4cc:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_SameSizeImmediateReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 1, true, RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_SameSizePostponedReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 1, false, RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_TwoSizesOneBufferImmediateReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 1, true, 1024, 2048);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_TwoSizesOneBufferPostponedReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 1, false, 1024, 2048);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_TwoSizesTwoBuffersImmediateReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 2, true, 1024, 2048);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_TwoSizesTwoBuffersPostponedReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40, 2, false, 1024, 2048);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_MultipleSizesOneBufferImmediateReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40,
1:17dd4cc:                              1,
1:17dd4cc:                              true,
1:17dd4cc:                              1024,
1:17dd4cc:                              2048,
1:17dd4cc:                              3072,
1:17dd4cc:                              4096,
1:17dd4cc:                              5120);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_MultipleSizesOneBufferPostponedReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40,
1:17dd4cc:                              1,
1:17dd4cc:                              false,
1:17dd4cc:                              1024,
1:17dd4cc:                              2048,
1:17dd4cc:                              3072,
1:17dd4cc:                              4096,
1:17dd4cc:                              5120);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_MultipleSizesMultipleBuffersImmediateReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40,
1:17dd4cc:                              4,
1:17dd4cc:                              true,
1:17dd4cc:                              1024,
1:17dd4cc:                              2048,
1:17dd4cc:                              3072,
1:17dd4cc:                              4096,
1:17dd4cc:                              5120);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Test
1:17dd4cc:     public void testMT_MultipleSizesMultipleBuffersPostponedReturn() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         checkMultipleThreads(40,
1:17dd4cc:                              3,
1:17dd4cc:                              false,
1:17dd4cc:                              1024,
1:17dd4cc:                              2048,
1:17dd4cc:                              3072,
1:17dd4cc:                              4096,
1:17dd4cc:                              5120);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void checkMultipleThreads(int threadCount, int numBuffersPerThread, final boolean returnImmediately, final int ... sizes) throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:17dd4cc:         final CountDownLatch finished = new CountDownLatch(threadCount);
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < threadCount; i++)
1:17dd4cc:         {
1:17dd4cc:             final int[] threadSizes = new int[numBuffersPerThread];
1:17dd4cc:             for (int j = 0; j < threadSizes.length; j++)
1:17dd4cc:                 threadSizes[j] = sizes[(i * numBuffersPerThread + j) % sizes.length];
1:17dd4cc: 
1:17dd4cc:             final Random rand = new Random();
1:17dd4cc:             executorService.submit(new Runnable()
1:17dd4cc:             {
1:17dd4cc:                 @Override
1:17dd4cc:                 public void run()
1:17dd4cc:                 {
1:17dd4cc:                     try
1:17dd4cc:                     {
1:17dd4cc:                         Thread.sleep(rand.nextInt(3));
1:17dd4cc: 
1:17dd4cc:                         List<ByteBuffer> toBeReturned = new ArrayList<ByteBuffer>(threadSizes.length);
1:17dd4cc: 
1:17dd4cc:                         for (int j = 0; j < threadSizes.length; j++)
1:17dd4cc:                         {
1:17dd4cc:                             ByteBuffer buffer = BufferPool.get(threadSizes[j]);
1:17dd4cc:                             assertNotNull(buffer);
1:17dd4cc:                             assertEquals(threadSizes[j], buffer.capacity());
1:17dd4cc: 
1:17dd4cc:                             for (int i = 0; i < 10; i++)
1:17dd4cc:                                 buffer.putInt(i);
1:17dd4cc: 
1:17dd4cc:                             buffer.rewind();
1:17dd4cc: 
1:17dd4cc:                             Thread.sleep(rand.nextInt(3));
1:17dd4cc: 
1:17dd4cc:                             for (int i = 0; i < 10; i++)
1:17dd4cc:                                 assertEquals(i, buffer.getInt());
1:17dd4cc: 
1:17dd4cc:                             if (returnImmediately)
1:17dd4cc:                                 BufferPool.put(buffer);
1:17dd4cc:                             else
1:17dd4cc:                                 toBeReturned.add(buffer);
1:17dd4cc: 
1:17dd4cc:                             assertTrue(BufferPool.sizeInBytes() > 0);
1:17dd4cc:                         }
1:17dd4cc: 
1:17dd4cc:                         Thread.sleep(rand.nextInt(3));
1:17dd4cc: 
1:17dd4cc:                         for (ByteBuffer buffer : toBeReturned)
1:17dd4cc:                             BufferPool.put(buffer);
1:17dd4cc:                     }
1:17dd4cc:                     catch (Exception ex)
1:17dd4cc:                     {
1:17dd4cc:                         ex.printStackTrace();
1:17dd4cc:                         fail(ex.getMessage());
1:17dd4cc:                     }
1:17dd4cc:                     finally
1:17dd4cc:                     {
1:17dd4cc:                         finished.countDown();
1:17dd4cc:                     }
1:17dd4cc:                 }
1:17dd4cc:             });
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         finished.await();
1:17dd4cc:         assertEquals(0, executorService.shutdownNow().size());
1:17dd4cc: 
1:17dd4cc:         // Make sure thread local storage gets GC-ed
1:17dd4cc:         for (int i = 0; i < 5; i++)
1:17dd4cc:         {
1:17dd4cc:             System.gc();
1:17dd4cc:             Thread.sleep(100);
1:17dd4cc:         }
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Ignore
1:17dd4cc:     public void testMultipleThreadsReleaseSameBuffer() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         doMultipleThreadsReleaseBuffers(45, 4096);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     @Ignore
1:17dd4cc:     public void testMultipleThreadsReleaseDifferentBuffer() throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         doMultipleThreadsReleaseBuffers(45, 4096, 8192);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     private void doMultipleThreadsReleaseBuffers(final int threadCount, final int ... sizes) throws InterruptedException
1:17dd4cc:     {
1:17dd4cc:         final ByteBuffer[] buffers = new ByteBuffer[sizes.length];
1:17dd4cc:         int sum = 0;
1:17dd4cc:         for (int i = 0; i < sizes.length; i++)
1:17dd4cc:         {
1:17dd4cc:             buffers[i] = BufferPool.get(sizes[i]);
1:17dd4cc:             assertNotNull(buffers[i]);
1:17dd4cc:             assertEquals(sizes[i], buffers[i].capacity());
1:17dd4cc:             sum += BufferPool.currentChunk().roundUp(buffers[i].capacity());
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         final BufferPool.Chunk chunk = BufferPool.currentChunk();
1:17dd4cc:         assertNotNull(chunk);
1:17dd4cc:         assertFalse(chunk.isFree());
1:17dd4cc: 
1:17dd4cc:         // if we use multiple chunks the test will fail, adjust sizes accordingly
1:17dd4cc:         assertTrue(sum < BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1:17dd4cc: 
1:17dd4cc:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:17dd4cc:         final CountDownLatch finished = new CountDownLatch(threadCount);
1:17dd4cc: 
1:17dd4cc:         for (int i = 0; i < threadCount; i++)
1:17dd4cc:         {
1:17dd4cc:             final int idx = i % sizes.length;
1:17dd4cc:             final ByteBuffer buffer = buffers[idx];
1:17dd4cc: 
1:17dd4cc:             executorService.submit(new Runnable()
1:17dd4cc:             {
1:17dd4cc:                 @Override
1:17dd4cc:                 public void run()
1:17dd4cc:                 {
1:17dd4cc:                     try
1:17dd4cc:                     {
1:17dd4cc:                         assertNotSame(chunk, BufferPool.currentChunk());
1:17dd4cc:                         BufferPool.put(buffer);
1:17dd4cc:                     }
1:17dd4cc:                     catch (AssertionError ex)
1:17dd4cc:                     { //this is expected if we release a buffer more than once
1:17dd4cc:                         ex.printStackTrace();
1:17dd4cc:                     }
1:17dd4cc:                     catch (Throwable t)
1:17dd4cc:                     {
1:17dd4cc:                         t.printStackTrace();
1:17dd4cc:                         fail(t.getMessage());
1:17dd4cc:                     }
1:17dd4cc:                     finally
1:17dd4cc:                     {
1:17dd4cc:                         finished.countDown();
1:17dd4cc:                     }
1:17dd4cc:                 }
1:17dd4cc:             });
1:17dd4cc:         }
1:17dd4cc: 
1:17dd4cc:         finished.await();
1:17dd4cc:         assertEquals(0, executorService.shutdownNow().size());
1:17dd4cc: 
1:17dd4cc:         executorService = null;
1:17dd4cc: 
1:17dd4cc:         // Make sure thread local storage gets GC-ed
1:17dd4cc:         System.gc();
1:17dd4cc:         System.gc();
1:17dd4cc:         System.gc();
1:17dd4cc: 
1:17dd4cc:         assertTrue(BufferPool.currentChunk().isFree());
1:17dd4cc: 
1:17dd4cc:         //make sure the main thread can still allocate buffers
1:17dd4cc:         ByteBuffer buffer = BufferPool.get(sizes[0]);
1:17dd4cc:         assertNotNull(buffer);
1:17dd4cc:         assertEquals(sizes[0], buffer.capacity());
1:17dd4cc:         BufferPool.put(buffer);
1:17dd4cc:     }
1:17dd4cc: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:stefania
-------------------------------------------------------------------------------
commit:17dd4cc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  *
1:  */
1: package org.apache.cassandra.utils.memory;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: import java.util.concurrent.*;
1: 
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.io.compress.BufferType;
1: import org.apache.cassandra.io.util.RandomAccessReader;
1: 
1: import static org.junit.Assert.*;
1: 
1: public class BufferPoolTest
1: {
1:     @Before
1:     public void setUp()
1:     {
1:         BufferPool.MEMORY_USAGE_THRESHOLD = 8 * 1024L * 1024L;
1:         BufferPool.DISABLED = false;
1:     }
1: 
1:     @After
1:     public void cleanUp()
1:     {
1:         BufferPool.reset();
1:     }
1: 
1:     @Test
1:     public void testGetPut() throws InterruptedException
1:     {
1:         final int size = RandomAccessReader.DEFAULT_BUFFER_SIZE;
1: 
1:         ByteBuffer buffer = BufferPool.get(size);
1:         assertNotNull(buffer);
1:         assertEquals(size, buffer.capacity());
1:         assertEquals(true, buffer.isDirect());
1: 
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1: 
1:         BufferPool.put(buffer);
1:         assertEquals(null, BufferPool.currentChunk());
1:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:     }
1: 
1: 
1:     @Test
1:     public void testPageAligned()
1:     {
1:         final int size = 1024;
1:         for (int i = size;
1:                  i <= BufferPool.CHUNK_SIZE;
1:                  i += size)
1:         {
1:             checkPageAligned(i);
1:         }
1:     }
1: 
1:     private void checkPageAligned(int size)
1:     {
1:         ByteBuffer buffer = BufferPool.get(size);
1:         assertNotNull(buffer);
1:         assertEquals(size, buffer.capacity());
1:         assertTrue(buffer.isDirect());
1: 
1:         long address = MemoryUtil.getAddress(buffer);
1:         assertTrue((address % MemoryUtil.pageSize()) == 0);
1: 
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testDifferentSizes() throws InterruptedException
1:     {
1:         final int size1 = 1024;
1:         final int size2 = 2048;
1: 
1:         ByteBuffer buffer1 = BufferPool.get(size1);
1:         assertNotNull(buffer1);
1:         assertEquals(size1, buffer1.capacity());
1: 
1:         ByteBuffer buffer2 = BufferPool.get(size2);
1:         assertNotNull(buffer2);
1:         assertEquals(size2, buffer2.capacity());
1: 
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1: 
1:         BufferPool.put(buffer1);
1:         BufferPool.put(buffer2);
1: 
1:         assertEquals(null, BufferPool.currentChunk());
1:         assertEquals(BufferPool.GlobalPool.MACRO_CHUNK_SIZE, BufferPool.sizeInBytes());
1:     }
1: 
1:     @Test
1:     public void testMaxMemoryExceededDirect()
1:     {
1:         boolean cur = BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED;
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false;
1: 
1:         requestDoubleMaxMemory();
1: 
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur;
1:     }
1: 
1:     @Test
1:     public void testMaxMemoryExceededHeap()
1:     {
1:         boolean cur = BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED;
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1: 
1:         requestDoubleMaxMemory();
1: 
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur;
1:     }
1: 
1:     @Test
1:     public void testMaxMemoryExceeded_SameAsChunkSize()
1:     {
1:         BufferPool.MEMORY_USAGE_THRESHOLD = BufferPool.GlobalPool.MACRO_CHUNK_SIZE;
1:         requestDoubleMaxMemory();
1:     }
1: 
1:     @Test
1:     public void testMaxMemoryExceeded_SmallerThanChunkSize()
1:     {
1:         BufferPool.MEMORY_USAGE_THRESHOLD = BufferPool.GlobalPool.MACRO_CHUNK_SIZE / 2;
1:         requestDoubleMaxMemory();
1:     }
1: 
1:     @Test
1:     public void testRecycle()
1:     {
1:         requestUpToSize(RandomAccessReader.DEFAULT_BUFFER_SIZE, 3 * BufferPool.CHUNK_SIZE);
1:     }
1: 
1:     private void requestDoubleMaxMemory()
1:     {
1:         requestUpToSize(RandomAccessReader.DEFAULT_BUFFER_SIZE, (int)(2 * BufferPool.MEMORY_USAGE_THRESHOLD));
1:     }
1: 
1:     private void requestUpToSize(int bufferSize, int totalSize)
1:     {
1:         final int numBuffers = totalSize / bufferSize;
1: 
1:         List<ByteBuffer> buffers = new ArrayList<>(numBuffers);
1:         for (int i = 0; i < numBuffers; i++)
1:         {
1:             ByteBuffer buffer = BufferPool.get(bufferSize);
1:             assertNotNull(buffer);
1:             assertEquals(bufferSize, buffer.capacity());
1: 
1:             if (BufferPool.sizeInBytes() > BufferPool.MEMORY_USAGE_THRESHOLD)
1:                 assertEquals(BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED, !buffer.isDirect());
1: 
1:             buffers.add(buffer);
1:         }
1: 
1:         for (ByteBuffer buffer : buffers)
1:             BufferPool.put(buffer);
1: 
1:     }
1: 
1:     @Test
1:     public void testBigRequest()
1:     {
1:         final int size = BufferPool.CHUNK_SIZE + 1;
1: 
1:         ByteBuffer buffer = BufferPool.get(size);
1:         assertNotNull(buffer);
1:         assertEquals(size, buffer.capacity());
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testFillUpChunks()
1:     {
1:         final int size = RandomAccessReader.DEFAULT_BUFFER_SIZE;
1:         final int numBuffers = BufferPool.CHUNK_SIZE / size;
1: 
1:         List<ByteBuffer> buffers1 = new ArrayList<>(numBuffers);
1:         List<ByteBuffer> buffers2 = new ArrayList<>(numBuffers);
1:         for (int i = 0; i < numBuffers; i++)
1:             buffers1.add(BufferPool.get(size));
1: 
1:         BufferPool.Chunk chunk1 = BufferPool.currentChunk();
1:         assertNotNull(chunk1);
1: 
1:         for (int i = 0; i < numBuffers; i++)
1:             buffers2.add(BufferPool.get(size));
1: 
1:         assertEquals(2, BufferPool.numChunks());
1: 
1:         for (ByteBuffer buffer : buffers1)
1:             BufferPool.put(buffer);
1: 
1:         assertEquals(1, BufferPool.numChunks());
1: 
1:         for (ByteBuffer buffer : buffers2)
1:             BufferPool.put(buffer);
1: 
1:         assertEquals(0, BufferPool.numChunks());
1: 
1:         buffers2.clear();
1:     }
1: 
1:     @Test
1:     public void testOutOfOrderFrees()
1:     {
1:         final int size = 4096;
1:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1: 
1:         final int[] idxs = new int[maxFreeSlots];
1:         for (int i = 0; i < maxFreeSlots; i++)
1:             idxs[i] = i;
1: 
1:         doTestFrees(size, maxFreeSlots, idxs);
1:     }
1: 
1:     @Test
1:     public void testInOrderFrees()
1:     {
1:         final int size = 4096;
1:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1: 
1:         final int[] idxs = new int[maxFreeSlots];
1:         for (int i = 0; i < maxFreeSlots; i++)
1:             idxs[i] = maxFreeSlots - 1 - i;
1: 
1:         doTestFrees(size, maxFreeSlots, idxs);
1:     }
1: 
1:     @Test
1:     public void testRandomFrees()
1:     {
1:         doTestRandomFrees(12345567878L);
1: 
1:         BufferPool.reset();
1:         doTestRandomFrees(20452249587L);
1: 
1:         BufferPool.reset();
1:         doTestRandomFrees(82457252948L);
1: 
1:         BufferPool.reset();
1:         doTestRandomFrees(98759284579L);
1: 
1:         BufferPool.reset();
1:         doTestRandomFrees(19475257244L);
1:     }
1: 
1:     private void doTestRandomFrees(long seed)
1:     {
1:         final int size = 4096;
1:         final int maxFreeSlots = BufferPool.CHUNK_SIZE / size;
1: 
1:         final int[] idxs = new int[maxFreeSlots];
1:         for (int i = 0; i < maxFreeSlots; i++)
1:             idxs[i] = maxFreeSlots - 1 - i;
1: 
1:         Random rnd = new Random();
1:         rnd.setSeed(seed);
1:         for (int i = idxs.length - 1; i > 0; i--)
1:         {
1:             int idx = rnd.nextInt(i+1);
1:             int v = idxs[idx];
1:             idxs[idx] = idxs[i];
1:             idxs[i] = v;
1:         }
1: 
1:         doTestFrees(size, maxFreeSlots, idxs);
1:     }
1: 
1:     private void doTestFrees(final int size, final int maxFreeSlots, final int[] toReleaseIdxs)
1:     {
1:         List<ByteBuffer> buffers = new ArrayList<>(maxFreeSlots);
1:         for (int i = 0; i < maxFreeSlots; i++)
1:         {
1:             buffers.add(BufferPool.get(size));
1:         }
1: 
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertFalse(chunk.isFree());
1: 
1:         int freeSize = BufferPool.CHUNK_SIZE - maxFreeSlots * size;
1:         assertEquals(freeSize, chunk.free());
1: 
1:         for (int i : toReleaseIdxs)
1:         {
1:             ByteBuffer buffer = buffers.get(i);
1:             assertNotNull(buffer);
1:             assertEquals(size, buffer.capacity());
1: 
1:             BufferPool.put(buffer);
1: 
1:             freeSize += size;
1:             if (freeSize == chunk.capacity())
1:                 assertEquals(0, chunk.free());
1:             else
1:                 assertEquals(freeSize, chunk.free());
1:         }
1: 
1:         assertFalse(chunk.isFree());
1:     }
1: 
1:     @Test
1:     public void testDifferentSizeBuffersOnOneChunk()
1:     {
1:         int[] sizes = new int[] {
1:             5, 1024, 4096, 8, 16000, 78, 512, 256, 63, 55, 89, 90, 255, 32, 2048, 128
1:         };
1: 
1:         int sum = 0;
1:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1:         for (int i = 0; i < sizes.length; i++)
1:         {
1:             ByteBuffer buffer = BufferPool.get(sizes[i]);
1:             assertNotNull(buffer);
1:             assertTrue(buffer.capacity() >= sizes[i]);
1:             buffers.add(buffer);
1: 
1:             sum += BufferPool.currentChunk().roundUp(buffer.capacity());
1:         }
1: 
1:         // else the test will fail, adjust sizes as required
1:         assertTrue(sum <= BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1: 
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1: 
1:         Random rnd = new Random();
1:         rnd.setSeed(298347529L);
1:         while (!buffers.isEmpty())
1:         {
1:             int index = rnd.nextInt(buffers.size());
1:             ByteBuffer buffer = buffers.remove(index);
1: 
1:             BufferPool.put(buffer);
1:         }
1: 
1:         assertEquals(null, BufferPool.currentChunk());
1:         assertEquals(0, chunk.free());
1:     }
1: 
1:     @Test
1:     public void testChunkExhausted()
1:     {
1:         final int size = BufferPool.CHUNK_SIZE / 64; // 1kbit
1:         int[] sizes = new int[128];
1:         Arrays.fill(sizes, size);
1: 
1:         int sum = 0;
1:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1:         for (int i = 0; i < sizes.length; i++)
1:         {
1:             ByteBuffer buffer = BufferPool.get(sizes[i]);
1:             assertNotNull(buffer);
1:             assertTrue(buffer.capacity() >= sizes[i]);
1:             buffers.add(buffer);
1: 
1:             sum += buffer.capacity();
1:         }
1: 
1:         // else the test will fail, adjust sizes as required
1:         assertTrue(sum <= BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1: 
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1: 
1:         for (int i = 0; i < sizes.length; i++)
1:         {
1:             BufferPool.put(buffers.get(i));
1:         }
1: 
1:         assertEquals(null, BufferPool.currentChunk());
1:         assertEquals(0, chunk.free());
1:     }
1: 
1:     @Test
1:     public void testCompactIfOutOfCapacity()
1:     {
1:         final int size = 4096;
1:         final int numBuffersInChunk = BufferPool.GlobalPool.MACRO_CHUNK_SIZE / size;
1: 
1:         List<ByteBuffer> buffers = new ArrayList<>(numBuffersInChunk);
1:         Set<Long> addresses = new HashSet<>(numBuffersInChunk);
1: 
1:         for (int i = 0; i < numBuffersInChunk; i++)
1:         {
1:             ByteBuffer buffer = BufferPool.get(size);
1:             buffers.add(buffer);
1:             addresses.add(MemoryUtil.getAddress(buffer));
1:         }
1: 
1:         for (int i = numBuffersInChunk - 1; i >= 0; i--)
1:             BufferPool.put(buffers.get(i));
1: 
1:         buffers.clear();
1: 
1:         for (int i = 0; i < numBuffersInChunk; i++)
1:         {
1:             ByteBuffer buffer = BufferPool.get(size);
1:             assertNotNull(buffer);
1:             assertEquals(size, buffer.capacity());
1:             addresses.remove(MemoryUtil.getAddress(buffer));
1: 
1:             buffers.add(buffer);
1:         }
1: 
1:         assertTrue(addresses.isEmpty()); // all 5 released buffers were used
1: 
1:         for (ByteBuffer buffer : buffers)
1:             BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testHeapBuffer()
1:     {
1:         ByteBuffer buffer = BufferPool.get(1024, BufferType.ON_HEAP);
1:         assertNotNull(buffer);
1:         assertEquals(1024, buffer.capacity());
1:         assertFalse(buffer.isDirect());
1:         assertNotNull(buffer.array());
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testSingleBufferOneChunk()
1:     {
1:         checkBuffer(0);
1: 
1:         checkBuffer(1);
1:         checkBuffer(2);
1:         checkBuffer(4);
1:         checkBuffer(5);
1:         checkBuffer(8);
1:         checkBuffer(16);
1:         checkBuffer(32);
1:         checkBuffer(64);
1: 
1:         checkBuffer(65);
1:         checkBuffer(127);
1:         checkBuffer(128);
1: 
1:         checkBuffer(129);
1:         checkBuffer(255);
1:         checkBuffer(256);
1: 
1:         checkBuffer(512);
1:         checkBuffer(1024);
1:         checkBuffer(2048);
1:         checkBuffer(4096);
1:         checkBuffer(8192);
1:         checkBuffer(16384);
1: 
1:         checkBuffer(16385);
1:         checkBuffer(32767);
1:         checkBuffer(32768);
1: 
1:         checkBuffer(32769);
1:         checkBuffer(33172);
1:         checkBuffer(33553);
1:         checkBuffer(36000);
1:         checkBuffer(65535);
1:         checkBuffer(65536);
1: 
1:         checkBuffer(65537);
1:     }
1: 
1:     private void checkBuffer(int size)
1:     {
1:         ByteBuffer buffer = BufferPool.get(size);
1:         assertEquals(size, buffer.capacity());
1: 
1:         if (size > 0 && size < BufferPool.CHUNK_SIZE)
1:         {
1:             BufferPool.Chunk chunk = BufferPool.currentChunk();
1:             assertNotNull(chunk);
1:             assertEquals(chunk.capacity(), chunk.free() + chunk.roundUp(size));
1:         }
1: 
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testMultipleBuffersOneChunk()
1:     {
1:         checkBuffers(32768, 33553);
1:         checkBuffers(32768, 32768);
1:         checkBuffers(48450, 33172);
1:         checkBuffers(32768, 15682, 33172);
1:     }
1: 
1:     private void checkBuffers(int ... sizes)
1:     {
1:         List<ByteBuffer> buffers = new ArrayList<>(sizes.length);
1: 
1:         for (int size : sizes)
1:         {
1:             ByteBuffer buffer = BufferPool.get(size);
1:             assertEquals(size, buffer.capacity());
1: 
1:             buffers.add(buffer);
1:         }
1: 
1:         for (ByteBuffer buffer : buffers)
1:             BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testBuffersWithGivenSlots()
1:     {
1:         checkBufferWithGivenSlots(21241, (-1L << 27) ^ (1L << 40));
1:     }
1: 
1:     private void checkBufferWithGivenSlots(int size, long freeSlots)
1:     {
1:         //first allocate to make sure there is a chunk
1:         ByteBuffer buffer = BufferPool.get(size);
1: 
1:         // now get the current chunk and override the free slots mask
1:         BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1:         long oldFreeSlots = chunk.setFreeSlots(freeSlots);
1: 
1:         // now check we can still get the buffer with the free slots mask changed
1:         ByteBuffer buffer2 = BufferPool.get(size);
1:         assertEquals(size, buffer.capacity());
1:         BufferPool.put(buffer2);
1: 
1:         // reset the free slots
1:         chunk.setFreeSlots(oldFreeSlots);
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test
1:     public void testZeroSizeRequest()
1:     {
1:         ByteBuffer buffer = BufferPool.get(0);
1:         assertNotNull(buffer);
1:         assertEquals(0, buffer.capacity());
1:         BufferPool.put(buffer);
1:     }
1: 
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testNegativeSizeRequest()
1:     {
1:         BufferPool.get(-1);
1:     }
1: 
1:     @Test
1:     public void testBufferPoolDisabled()
1:     {
1:         BufferPool.DISABLED = true;
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1:         ByteBuffer buffer = BufferPool.get(1024);
1:         assertEquals(0, BufferPool.numChunks());
1:         assertNotNull(buffer);
1:         assertEquals(1024, buffer.capacity());
1:         assertFalse(buffer.isDirect());
1:         assertNotNull(buffer.array());
1:         BufferPool.put(buffer);
1:         assertEquals(0, BufferPool.numChunks());
1: 
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false;
1:         buffer = BufferPool.get(1024);
1:         assertEquals(0, BufferPool.numChunks());
1:         assertNotNull(buffer);
1:         assertEquals(1024, buffer.capacity());
1:         assertTrue(buffer.isDirect());
1:         BufferPool.put(buffer);
1:         assertEquals(0, BufferPool.numChunks());
1: 
1:         // clean-up
1:         BufferPool.DISABLED = false;
1:         BufferPool.ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true;
1:     }
1: 
1:     @Test
1:     public void testMT_SameSizeImmediateReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 1, true, RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:     }
1: 
1:     @Test
1:     public void testMT_SameSizePostponedReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 1, false, RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:     }
1: 
1:     @Test
1:     public void testMT_TwoSizesOneBufferImmediateReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 1, true, 1024, 2048);
1:     }
1: 
1:     @Test
1:     public void testMT_TwoSizesOneBufferPostponedReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 1, false, 1024, 2048);
1:     }
1: 
1:     @Test
1:     public void testMT_TwoSizesTwoBuffersImmediateReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 2, true, 1024, 2048);
1:     }
1: 
1:     @Test
1:     public void testMT_TwoSizesTwoBuffersPostponedReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40, 2, false, 1024, 2048);
1:     }
1: 
1:     @Test
1:     public void testMT_MultipleSizesOneBufferImmediateReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40,
1:                              1,
1:                              true,
1:                              1024,
1:                              2048,
1:                              3072,
1:                              4096,
1:                              5120);
1:     }
1: 
1:     @Test
1:     public void testMT_MultipleSizesOneBufferPostponedReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40,
1:                              1,
1:                              false,
1:                              1024,
1:                              2048,
1:                              3072,
1:                              4096,
1:                              5120);
1:     }
1: 
1:     @Test
1:     public void testMT_MultipleSizesMultipleBuffersImmediateReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40,
1:                              4,
1:                              true,
1:                              1024,
1:                              2048,
1:                              3072,
1:                              4096,
1:                              5120);
1:     }
1: 
1:     @Test
1:     public void testMT_MultipleSizesMultipleBuffersPostponedReturn() throws InterruptedException
1:     {
1:         checkMultipleThreads(40,
1:                              3,
1:                              false,
1:                              1024,
1:                              2048,
1:                              3072,
1:                              4096,
1:                              5120);
1:     }
1: 
1:     private void checkMultipleThreads(int threadCount, int numBuffersPerThread, final boolean returnImmediately, final int ... sizes) throws InterruptedException
1:     {
1:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:         final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:         for (int i = 0; i < threadCount; i++)
1:         {
1:             final int[] threadSizes = new int[numBuffersPerThread];
1:             for (int j = 0; j < threadSizes.length; j++)
1:                 threadSizes[j] = sizes[(i * numBuffersPerThread + j) % sizes.length];
1: 
1:             final Random rand = new Random();
1:             executorService.submit(new Runnable()
1:             {
1:                 @Override
1:                 public void run()
1:                 {
1:                     try
1:                     {
1:                         Thread.sleep(rand.nextInt(3));
1: 
1:                         List<ByteBuffer> toBeReturned = new ArrayList<ByteBuffer>(threadSizes.length);
1: 
1:                         for (int j = 0; j < threadSizes.length; j++)
1:                         {
1:                             ByteBuffer buffer = BufferPool.get(threadSizes[j]);
1:                             assertNotNull(buffer);
1:                             assertEquals(threadSizes[j], buffer.capacity());
1: 
1:                             for (int i = 0; i < 10; i++)
1:                                 buffer.putInt(i);
1: 
1:                             buffer.rewind();
1: 
1:                             Thread.sleep(rand.nextInt(3));
1: 
1:                             for (int i = 0; i < 10; i++)
1:                                 assertEquals(i, buffer.getInt());
1: 
1:                             if (returnImmediately)
1:                                 BufferPool.put(buffer);
1:                             else
1:                                 toBeReturned.add(buffer);
1: 
1:                             assertTrue(BufferPool.sizeInBytes() > 0);
1:                         }
1: 
1:                         Thread.sleep(rand.nextInt(3));
1: 
1:                         for (ByteBuffer buffer : toBeReturned)
1:                             BufferPool.put(buffer);
1:                     }
1:                     catch (Exception ex)
1:                     {
1:                         ex.printStackTrace();
1:                         fail(ex.getMessage());
1:                     }
1:                     finally
1:                     {
1:                         finished.countDown();
1:                     }
1:                 }
1:             });
1:         }
1: 
1:         finished.await();
1:         assertEquals(0, executorService.shutdownNow().size());
1: 
1:         // Make sure thread local storage gets GC-ed
1:         for (int i = 0; i < 5; i++)
1:         {
1:             System.gc();
1:             Thread.sleep(100);
1:         }
1:     }
1: 
1:     @Ignore
1:     public void testMultipleThreadsReleaseSameBuffer() throws InterruptedException
1:     {
1:         doMultipleThreadsReleaseBuffers(45, 4096);
1:     }
1: 
1:     @Ignore
1:     public void testMultipleThreadsReleaseDifferentBuffer() throws InterruptedException
1:     {
1:         doMultipleThreadsReleaseBuffers(45, 4096, 8192);
1:     }
1: 
1:     private void doMultipleThreadsReleaseBuffers(final int threadCount, final int ... sizes) throws InterruptedException
1:     {
1:         final ByteBuffer[] buffers = new ByteBuffer[sizes.length];
1:         int sum = 0;
1:         for (int i = 0; i < sizes.length; i++)
1:         {
1:             buffers[i] = BufferPool.get(sizes[i]);
1:             assertNotNull(buffers[i]);
1:             assertEquals(sizes[i], buffers[i].capacity());
1:             sum += BufferPool.currentChunk().roundUp(buffers[i].capacity());
1:         }
1: 
1:         final BufferPool.Chunk chunk = BufferPool.currentChunk();
1:         assertNotNull(chunk);
1:         assertFalse(chunk.isFree());
1: 
1:         // if we use multiple chunks the test will fail, adjust sizes accordingly
1:         assertTrue(sum < BufferPool.GlobalPool.MACRO_CHUNK_SIZE);
1: 
1:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:         final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:         for (int i = 0; i < threadCount; i++)
1:         {
1:             final int idx = i % sizes.length;
1:             final ByteBuffer buffer = buffers[idx];
1: 
1:             executorService.submit(new Runnable()
1:             {
1:                 @Override
1:                 public void run()
1:                 {
1:                     try
1:                     {
1:                         assertNotSame(chunk, BufferPool.currentChunk());
1:                         BufferPool.put(buffer);
1:                     }
1:                     catch (AssertionError ex)
1:                     { //this is expected if we release a buffer more than once
1:                         ex.printStackTrace();
1:                     }
1:                     catch (Throwable t)
1:                     {
1:                         t.printStackTrace();
1:                         fail(t.getMessage());
1:                     }
1:                     finally
1:                     {
1:                         finished.countDown();
1:                     }
1:                 }
1:             });
1:         }
1: 
1:         finished.await();
1:         assertEquals(0, executorService.shutdownNow().size());
1: 
1:         executorService = null;
1: 
1:         // Make sure thread local storage gets GC-ed
1:         System.gc();
1:         System.gc();
1:         System.gc();
1: 
1:         assertTrue(BufferPool.currentChunk().isFree());
1: 
1:         //make sure the main thread can still allocate buffers
1:         ByteBuffer buffer = BufferPool.get(sizes[0]);
1:         assertNotNull(buffer);
1:         assertEquals(sizes[0], buffer.capacity());
1:         BufferPool.put(buffer);
1:     }
1: }
============================================================================