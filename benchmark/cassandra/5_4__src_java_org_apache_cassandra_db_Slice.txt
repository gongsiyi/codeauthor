1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
4:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
6:a991b64:  */
1:a991b64: package org.apache.cassandra.db;
53:a991b64: 
1:a991b64: import java.io.IOException;
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.util.*;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.db.marshal.AbstractType;
1:2457599: import org.apache.cassandra.io.util.DataInputPlus;
1:a991b64: import org.apache.cassandra.io.util.DataOutputPlus;
1:a991b64: 
6:a991b64: /**
1:a991b64:  * A slice represents the selection of a range of rows.
4:a991b64:  * <p>
1:a991b64:  * A slice has a start and an end bound that are both (potentially full) clustering prefixes.
1:a991b64:  * A slice selects every rows whose clustering is bigger than the slice start prefix but smaller
1:a991b64:  * than the end prefix. Both start and end can be either inclusive or exclusive.
1:a991b64:  */
1:a991b64: public class Slice
50:a991b64: {
2:a991b64:     public static final Serializer serializer = new Serializer();
1:a991b64: 
1:a991b64:     /** The slice selecting all rows (of a given partition) */
1:2cc26eb:     public static final Slice ALL = new Slice(ClusteringBound.BOTTOM, ClusteringBound.TOP)
1:a991b64:     {
3:a991b64:         @Override
1:2cc26eb:         public boolean includes(ClusteringComparator comparator, ClusteringPrefix clustering)
1:a991b64:         {
1:a991b64:             return true;
50:a991b64:         }
1:8c64cef: 
1:a991b64:         @Override
1:a991b64:         public boolean intersects(ClusteringComparator comparator, List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:8c64cef:         {
1:a991b64:             return true;
1:8c64cef:         }
1:8c64cef: 
1:a991b64:         @Override
2:a991b64:         public String toString(ClusteringComparator comparator)
1:8c64cef:         {
1:a991b64:             return "ALL";
1:8c64cef:         }
1:a991b64:     };
1:8c64cef: 
1:2cc26eb:     private final ClusteringBound start;
1:2cc26eb:     private final ClusteringBound end;
1:a991b64: 
1:2cc26eb:     private Slice(ClusteringBound start, ClusteringBound end)
1:8c64cef:     {
1:a991b64:         assert start.isStart() && end.isEnd();
1:2457599:         this.start = start;
1:2457599:         this.end = end;
1:8c64cef:     }
1:a991b64: 
1:2cc26eb:     public static Slice make(ClusteringBound start, ClusteringBound end)
1:a991b64:     {
1:2cc26eb:         if (start == ClusteringBound.BOTTOM && end == ClusteringBound.TOP)
1:a991b64:             return ALL;
1:a991b64: 
1:a991b64:         return new Slice(start, end);
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static Slice make(ClusteringComparator comparator, Object... values)
1:a991b64:     {
2:a991b64:         CBuilder builder = CBuilder.create(comparator);
1:8c64cef:         for (Object val : values)
1:a991b64:         {
2:a991b64:             if (val instanceof ByteBuffer)
1:8c64cef:                 builder.add((ByteBuffer) val);
2:a991b64:             else
2:a991b64:                 builder.add(val);
1:a991b64:         }
1:a991b64:         return new Slice(builder.buildBound(true, true), builder.buildBound(false, true));
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static Slice make(Clustering clustering)
1:a991b64:     {
1:a991b64:         // This doesn't give us what we want with the clustering prefix
1:a991b64:         assert clustering != Clustering.STATIC_CLUSTERING;
1:a991b64:         ByteBuffer[] values = extractValues(clustering);
1:2cc26eb:         return new Slice(ClusteringBound.inclusiveStartOf(values), ClusteringBound.inclusiveEndOf(values));
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static Slice make(Clustering start, Clustering end)
1:a991b64:     {
1:a991b64:         // This doesn't give us what we want with the clustering prefix
1:a991b64:         assert start != Clustering.STATIC_CLUSTERING && end != Clustering.STATIC_CLUSTERING;
1:a991b64: 
1:a991b64:         ByteBuffer[] startValues = extractValues(start);
1:a991b64:         ByteBuffer[] endValues = extractValues(end);
1:a991b64: 
1:2cc26eb:         return new Slice(ClusteringBound.inclusiveStartOf(startValues), ClusteringBound.inclusiveEndOf(endValues));
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static ByteBuffer[] extractValues(ClusteringPrefix clustering)
1:a991b64:     {
1:a991b64:         ByteBuffer[] values = new ByteBuffer[clustering.size()];
1:a991b64:         for (int i = 0; i < clustering.size(); i++)
1:a991b64:             values[i] = clustering.get(i);
2:a991b64:         return values;
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     public ClusteringBound start()
1:a991b64:     {
1:a991b64:         return start;
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     public ClusteringBound end()
1:a991b64:     {
1:a991b64:         return end;
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     public ClusteringBound open(boolean reversed)
1:a991b64:     {
1:a991b64:         return reversed ? end : start;
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     public ClusteringBound close(boolean reversed)
1:a991b64:     {
1:a991b64:         return reversed ? start : end;
1:a991b64:     }
1:a991b64: 
1:2457599:     /**
1:a991b64:      * Return whether the slice is empty.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator to compare the bounds.
1:a991b64:      * @return whether the slice formed is empty or not.
1:2457599:      */
1:a991b64:     public boolean isEmpty(ClusteringComparator comparator)
1:a991b64:     {
1:a991b64:         return isEmpty(comparator, start(), end());
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Return whether the slice formed by the two provided bound is empty or not.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator to compare the bounds.
1:a991b64:      * @param start the start for the slice to consider. This must be a start bound.
1:a991b64:      * @param end the end for the slice to consider. This must be an end bound.
1:a991b64:      * @return whether the slice formed by {@code start} and {@code end} is
1:a991b64:      * empty or not.
1:a991b64:      */
1:2cc26eb:     public static boolean isEmpty(ClusteringComparator comparator, ClusteringBound start, ClusteringBound end)
1:a991b64:     {
1:a991b64:         assert start.isStart() && end.isEnd();
1:a991b64:         return comparator.compare(end, start) < 0;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:2cc26eb:      * Returns whether a given clustering or bound is included in this slice.
1:a991b64:      *
2:a991b64:      * @param comparator the comparator for the table this is a slice of.
1:a991b64:      * @param bound the bound to test inclusion of.
1:a991b64:      *
1:a991b64:      * @return whether {@code bound} is within the bounds of this slice.
1:a991b64:      */
1:2cc26eb:     public boolean includes(ClusteringComparator comparator, ClusteringPrefix bound)
1:a991b64:     {
1:a991b64:         return comparator.compare(start, bound) <= 0 && comparator.compare(bound, end) <= 0;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns a slice for continuing paging from the last returned clustering prefix.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator for the table this is a filter for.
1:a991b64:      * @param lastReturned the last clustering that was returned for the query we are paging for. The
1:a991b64:      * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
1:a991b64:      * (where coming after means "greater than" if {@code !reversed} and "lesser than" otherwise).
1:a991b64:      * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
1:a991b64:      * @param reversed whether the query we're paging for is reversed or not.
1:a991b64:      *
1:a991b64:      * @return a new slice that selects results coming after {@code lastReturned}, or {@code null} if paging
1:a991b64:      * the resulting slice selects nothing (i.e. if it originally selects nothing coming after {@code lastReturned}).
1:a991b64:      */
1:a991b64:     public Slice forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:a991b64:     {
1:8c64cef:         if (lastReturned == null)
1:8c64cef:             return this;
1:8c64cef: 
1:a991b64:         if (reversed)
1:a991b64:         {
1:a991b64:             int cmp = comparator.compare(lastReturned, start);
1:a991b64:             if (cmp < 0 || (!inclusive && cmp == 0))
1:a991b64:                 return null;
1:a991b64: 
1:a991b64:             cmp = comparator.compare(end, lastReturned);
1:a991b64:             if (cmp < 0 || (inclusive && cmp == 0))
2:a991b64:                 return this;
1:a991b64: 
1:a991b64:             ByteBuffer[] values = extractValues(lastReturned);
1:2cc26eb:             return new Slice(start, inclusive ? ClusteringBound.inclusiveEndOf(values) : ClusteringBound.exclusiveEndOf(values));
1:a991b64:         }
1:a991b64:         else
1:a991b64:         {
1:a991b64:             int cmp = comparator.compare(end, lastReturned);
1:a991b64:             if (cmp < 0 || (!inclusive && cmp == 0))
1:a991b64:                 return null;
1:a991b64: 
1:a991b64:             cmp = comparator.compare(lastReturned, start);
1:a991b64:             if (cmp < 0 || (inclusive && cmp == 0))
1:a991b64:                 return this;
1:a991b64: 
1:a991b64:             ByteBuffer[] values = extractValues(lastReturned);
1:2cc26eb:             return new Slice(inclusive ? ClusteringBound.inclusiveStartOf(values) : ClusteringBound.exclusiveStartOf(values), end);
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Given the per-clustering column minimum and maximum value a sstable contains, whether or not this slice potentially
1:a991b64:      * intersects that sstable or not.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator for the table this is a slice of.
1:a991b64:      * @param minClusteringValues the smallest values for each clustering column that a sstable contains.
1:a991b64:      * @param maxClusteringValues the biggest values for each clustering column that a sstable contains.
1:a991b64:      *
1:a991b64:      * @return whether the slice might intersects with the sstable having {@code minClusteringValues} and
1:a991b64:      * {@code maxClusteringValues}.
1:a991b64:      */
1:a991b64:     public boolean intersects(ClusteringComparator comparator, List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:a991b64:     {
1:a991b64:         // If this slice start after max or end before min, it can't intersect
1:a991b64:         if (start.compareTo(comparator, maxClusteringValues) > 0 || end.compareTo(comparator, minClusteringValues) < 0)
1:a991b64:             return false;
1:a991b64: 
1:a991b64:         // We could safely return true here, but there's a minor optimization: if the first component
1:a991b64:         // of the slice is restricted to a single value (typically the slice is [4:5, 4:7]), we can
1:a991b64:         // check that the second component falls within the min/max for that component (and repeat for
1:a991b64:         // all components).
1:a991b64:         for (int j = 0; j < minClusteringValues.size() && j < maxClusteringValues.size(); j++)
1:a991b64:         {
1:a991b64:             ByteBuffer s = j < start.size() ? start.get(j) : null;
1:a991b64:             ByteBuffer f = j < end.size() ? end.get(j) : null;
1:a991b64: 
1:a991b64:             // we already know the first component falls within its min/max range (otherwise we wouldn't get here)
1:a991b64:             if (j > 0 && (j < end.size() && comparator.compareComponent(j, f, minClusteringValues.get(j)) < 0 ||
1:a991b64:                         j < start.size() && comparator.compareComponent(j, s, maxClusteringValues.get(j)) > 0))
1:a991b64:                 return false;
1:a991b64: 
1:a991b64:             // if this component isn't equal in the start and finish, we don't need to check any more
1:a991b64:             if (j >= start.size() || j >= end.size() || comparator.compareComponent(j, s, f) != 0)
1:a991b64:                 break;
1:a991b64:         }
1:a991b64:         return true;
1:a991b64:     }
1:a991b64: 
2:a991b64:     public String toString(CFMetaData metadata)
1:a991b64:     {
2:a991b64:         return toString(metadata.comparator);
1:a991b64:     }
1:a991b64: 
1:a991b64:     public String toString(ClusteringComparator comparator)
1:a991b64:     {
2:a991b64:         StringBuilder sb = new StringBuilder();
1:a991b64:         sb.append(start.isInclusive() ? "[" : "(");
1:a991b64:         for (int i = 0; i < start.size(); i++)
1:a991b64:         {
2:a991b64:             if (i > 0)
1:8c64cef:                 sb.append(':');
1:a991b64:             sb.append(comparator.subtype(i).getString(start.get(i)));
1:a991b64:         }
2:a991b64:         sb.append(", ");
1:a991b64:         for (int i = 0; i < end.size(); i++)
1:a991b64:         {
1:a991b64:             if (i > 0)
1:8c64cef:                 sb.append(':');
1:a991b64:             sb.append(comparator.subtype(i).getString(end.get(i)));
1:a991b64:         }
1:a991b64:         sb.append(end.isInclusive() ? "]" : ")");
1:a991b64:         return sb.toString();
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Override
1:a991b64:     public boolean equals(Object other)
1:a991b64:     {
1:a991b64:         if(!(other instanceof Slice))
1:a991b64:             return false;
1:a991b64: 
1:a991b64:         Slice that = (Slice)other;
1:a991b64:         return this.start().equals(that.start())
1:a991b64:             && this.end().equals(that.end());
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Override
1:a991b64:     public int hashCode()
1:a991b64:     {
1:a991b64:         return Objects.hash(start(), end());
1:a991b64:     }
1:a991b64: 
2:a991b64:     public static class Serializer
1:a991b64:     {
1:a991b64:         public void serialize(Slice slice, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException
1:a991b64:         {
1:2cc26eb:             ClusteringBound.serializer.serialize(slice.start, out, version, types);
1:2cc26eb:             ClusteringBound.serializer.serialize(slice.end, out, version, types);
1:a991b64:         }
1:a991b64: 
1:03f72ac:         public long serializedSize(Slice slice, int version, List<AbstractType<?>> types)
1:a991b64:         {
1:2cc26eb:             return ClusteringBound.serializer.serializedSize(slice.start, version, types)
1:2cc26eb:                  + ClusteringBound.serializer.serializedSize(slice.end, version, types);
1:a991b64:         }
1:a991b64: 
1:2457599:         public Slice deserialize(DataInputPlus in, int version, List<AbstractType<?>> types) throws IOException
1:a991b64:         {
1:2cc26eb:             ClusteringBound start = (ClusteringBound) ClusteringBound.serializer.deserialize(in, version, types);
1:2cc26eb:             ClusteringBound end = (ClusteringBound) ClusteringBound.serializer.deserialize(in, version, types);
1:a991b64:             return new Slice(start, end);
1:a991b64:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:     public static final Slice ALL = new Slice(ClusteringBound.BOTTOM, ClusteringBound.TOP)
1:         public boolean includes(ClusteringComparator comparator, ClusteringPrefix clustering)
/////////////////////////////////////////////////////////////////////////
1:     private final ClusteringBound start;
1:     private final ClusteringBound end;
1:     private Slice(ClusteringBound start, ClusteringBound end)
1:     public static Slice make(ClusteringBound start, ClusteringBound end)
1:         if (start == ClusteringBound.BOTTOM && end == ClusteringBound.TOP)
/////////////////////////////////////////////////////////////////////////
1:         return new Slice(ClusteringBound.inclusiveStartOf(values), ClusteringBound.inclusiveEndOf(values));
/////////////////////////////////////////////////////////////////////////
1:         return new Slice(ClusteringBound.inclusiveStartOf(startValues), ClusteringBound.inclusiveEndOf(endValues));
/////////////////////////////////////////////////////////////////////////
1:     public ClusteringBound start()
1:     public ClusteringBound end()
1:     public ClusteringBound open(boolean reversed)
1:     public ClusteringBound close(boolean reversed)
/////////////////////////////////////////////////////////////////////////
1:     public static boolean isEmpty(ClusteringComparator comparator, ClusteringBound start, ClusteringBound end)
1:      * Returns whether a given clustering or bound is included in this slice.
1:     public boolean includes(ClusteringComparator comparator, ClusteringPrefix bound)
/////////////////////////////////////////////////////////////////////////
1:             return new Slice(start, inclusive ? ClusteringBound.inclusiveEndOf(values) : ClusteringBound.exclusiveEndOf(values));
/////////////////////////////////////////////////////////////////////////
1:             return new Slice(inclusive ? ClusteringBound.inclusiveStartOf(values) : ClusteringBound.exclusiveStartOf(values), end);
/////////////////////////////////////////////////////////////////////////
1:             ClusteringBound.serializer.serialize(slice.start, out, version, types);
1:             ClusteringBound.serializer.serialize(slice.end, out, version, types);
1:             return ClusteringBound.serializer.serializedSize(slice.start, version, types)
1:                  + ClusteringBound.serializer.serializedSize(slice.end, version, types);
1:             ClusteringBound start = (ClusteringBound) ClusteringBound.serializer.deserialize(in, version, types);
1:             ClusteringBound end = (ClusteringBound) ClusteringBound.serializer.deserialize(in, version, types);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
0:     public static class Bound extends AbstractBufferClusteringPrefix
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (Object val : values)
1:                 builder.add((ByteBuffer) val);
/////////////////////////////////////////////////////////////////////////
1:         if (lastReturned == null)
1:             return this;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 sb.append(':');
1:                 sb.append(':');
/////////////////////////////////////////////////////////////////////////
0:         public static Bound inclusiveStartOf(ClusteringPrefix prefix)
1:         {
0:             ByteBuffer[] values = new ByteBuffer[prefix.size()];
0:             for (int i = 0; i < prefix.size(); i++)
0:                 values[i] = prefix.get(i);
0:             return inclusiveStartOf(values);
1:         }
1: 
0:         public static Bound exclusiveStartOf(ClusteringPrefix prefix)
1:         {
0:             ByteBuffer[] values = new ByteBuffer[prefix.size()];
0:             for (int i = 0; i < prefix.size(); i++)
0:                 values[i] = prefix.get(i);
0:             return exclusiveStartOf(values);
1:         }
1: 
0:         public static Bound inclusiveEndOf(ClusteringPrefix prefix)
1:         {
0:             ByteBuffer[] values = new ByteBuffer[prefix.size()];
0:             for (int i = 0; i < prefix.size(); i++)
0:                 values[i] = prefix.get(i);
0:             return inclusiveEndOf(values);
1:         }
1: 
0:             for (Object val : values)
0:                     builder.add((ByteBuffer) val);
/////////////////////////////////////////////////////////////////////////
0:             sb.append(kind()).append('(');
0:             return sb.append(')').toString();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         this.start = start;
1:         this.end = end;
/////////////////////////////////////////////////////////////////////////
1:         public Slice deserialize(DataInputPlus in, int version, List<AbstractType<?>> types) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         /**
0:          * The smallest and biggest bound. Note that as range tomstone bounds are (special case) of slice bounds,
0:          * we want the BOTTOM and TOP to be the same object, but we alias them here because it's cleaner when dealing
0:          * with slices to refer to Slice.Bound.BOTTOM and Slice.Bound.TOP.
1:          */
0:         public static final Bound BOTTOM = RangeTombstone.Bound.BOTTOM;
0:         public static final Bound TOP = RangeTombstone.Bound.TOP;
0:             super(kind, values);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:          * Contrarily to {@code Clustering}, a slice bound can be a true prefix of the full clustering, so we actually record
/////////////////////////////////////////////////////////////////////////
0:             public Slice.Bound deserialize(DataInputPlus in, int version, List<AbstractType<?>> types) throws IOException
0:             public Slice.Bound deserializeValues(DataInputPlus in, Kind kind, int version, List<AbstractType<?>> types) throws IOException
0:                 ByteBuffer[] values = ClusteringPrefix.serializer.deserializeValuesWithoutSize(in, size, version, types);
0:                 return Slice.Bound.create(kind, values);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
0: import java.io.DataInput;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
0: import java.security.MessageDigest;
1: import java.util.*;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.io.util.DataOutputPlus;
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.ObjectSizes;
1: 
1: /**
1:  * A slice represents the selection of a range of rows.
1:  * <p>
1:  * A slice has a start and an end bound that are both (potentially full) clustering prefixes.
1:  * A slice selects every rows whose clustering is bigger than the slice start prefix but smaller
1:  * than the end prefix. Both start and end can be either inclusive or exclusive.
1:  */
1: public class Slice
1: {
1:     public static final Serializer serializer = new Serializer();
1: 
1:     /** The slice selecting all rows (of a given partition) */
0:     public static final Slice ALL = new Slice(Bound.BOTTOM, Bound.TOP)
1:     {
1:         @Override
0:         public boolean selects(ClusteringComparator comparator, Clustering clustering)
1:         {
1:             return true;
1:         }
1: 
1:         @Override
1:         public boolean intersects(ClusteringComparator comparator, List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:         {
1:             return true;
1:         }
1: 
1:         @Override
1:         public String toString(ClusteringComparator comparator)
1:         {
1:             return "ALL";
1:         }
1:     };
1: 
0:     private final Bound start;
0:     private final Bound end;
1: 
0:     private Slice(Bound start, Bound end)
1:     {
1:         assert start.isStart() && end.isEnd();
0:         this.start = start.takeAlias();
0:         this.end = end.takeAlias();
1:     }
1: 
0:     public static Slice make(Bound start, Bound end)
1:     {
0:         if (start == Bound.BOTTOM && end == Bound.TOP)
1:             return ALL;
1: 
1:         return new Slice(start, end);
1:     }
1: 
1:     public static Slice make(ClusteringComparator comparator, Object... values)
1:     {
1:         CBuilder builder = CBuilder.create(comparator);
0:         for (int i = 0; i < values.length; i++)
1:         {
0:             Object val = values[i];
1:             if (val instanceof ByteBuffer)
0:                 builder.add((ByteBuffer)val);
1:             else
1:                 builder.add(val);
1:         }
1:         return new Slice(builder.buildBound(true, true), builder.buildBound(false, true));
1:     }
1: 
1:     public static Slice make(Clustering clustering)
1:     {
1:         // This doesn't give us what we want with the clustering prefix
1:         assert clustering != Clustering.STATIC_CLUSTERING;
1:         ByteBuffer[] values = extractValues(clustering);
0:         return new Slice(Bound.inclusiveStartOf(values), Bound.inclusiveEndOf(values));
1:     }
1: 
1:     public static Slice make(Clustering start, Clustering end)
1:     {
1:         // This doesn't give us what we want with the clustering prefix
1:         assert start != Clustering.STATIC_CLUSTERING && end != Clustering.STATIC_CLUSTERING;
1: 
1:         ByteBuffer[] startValues = extractValues(start);
1:         ByteBuffer[] endValues = extractValues(end);
1: 
0:         return new Slice(Bound.inclusiveStartOf(startValues), Bound.inclusiveEndOf(endValues));
1:     }
1: 
1:     private static ByteBuffer[] extractValues(ClusteringPrefix clustering)
1:     {
1:         ByteBuffer[] values = new ByteBuffer[clustering.size()];
1:         for (int i = 0; i < clustering.size(); i++)
1:             values[i] = clustering.get(i);
1:         return values;
1:     }
1: 
0:     public Bound start()
1:     {
1:         return start;
1:     }
1: 
0:     public Bound end()
1:     {
1:         return end;
1:     }
1: 
0:     public Bound open(boolean reversed)
1:     {
1:         return reversed ? end : start;
1:     }
1: 
0:     public Bound close(boolean reversed)
1:     {
1:         return reversed ? start : end;
1:     }
1: 
1:     /**
1:      * Return whether the slice is empty.
1:      *
1:      * @param comparator the comparator to compare the bounds.
1:      * @return whether the slice formed is empty or not.
1:      */
1:     public boolean isEmpty(ClusteringComparator comparator)
1:     {
1:         return isEmpty(comparator, start(), end());
1:     }
1: 
1:     /**
1:      * Return whether the slice formed by the two provided bound is empty or not.
1:      *
1:      * @param comparator the comparator to compare the bounds.
1:      * @param start the start for the slice to consider. This must be a start bound.
1:      * @param end the end for the slice to consider. This must be an end bound.
1:      * @return whether the slice formed by {@code start} and {@code end} is
1:      * empty or not.
1:      */
0:     public static boolean isEmpty(ClusteringComparator comparator, Slice.Bound start, Slice.Bound end)
1:     {
1:         assert start.isStart() && end.isEnd();
1:         return comparator.compare(end, start) < 0;
1:     }
1: 
1:     /**
0:      * Returns whether a given clustering is selected by this slice.
1:      *
1:      * @param comparator the comparator for the table this is a slice of.
0:      * @param clustering the clustering to test inclusion of.
1:      *
0:      * @return whether {@code clustering} is selected by this slice.
1:      */
0:     public boolean selects(ClusteringComparator comparator, Clustering clustering)
1:     {
0:         return comparator.compare(start, clustering) <= 0 && comparator.compare(clustering, end) <= 0;
1:     }
1: 
1:     /**
0:      * Returns whether a given bound is included in this slice.
1:      *
1:      * @param comparator the comparator for the table this is a slice of.
1:      * @param bound the bound to test inclusion of.
1:      *
1:      * @return whether {@code bound} is within the bounds of this slice.
1:      */
0:     public boolean includes(ClusteringComparator comparator, Bound bound)
1:     {
1:         return comparator.compare(start, bound) <= 0 && comparator.compare(bound, end) <= 0;
1:     }
1: 
1:     /**
1:      * Returns a slice for continuing paging from the last returned clustering prefix.
1:      *
1:      * @param comparator the comparator for the table this is a filter for.
1:      * @param lastReturned the last clustering that was returned for the query we are paging for. The
1:      * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
1:      * (where coming after means "greater than" if {@code !reversed} and "lesser than" otherwise).
1:      * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
1:      * @param reversed whether the query we're paging for is reversed or not.
1:      *
1:      * @return a new slice that selects results coming after {@code lastReturned}, or {@code null} if paging
1:      * the resulting slice selects nothing (i.e. if it originally selects nothing coming after {@code lastReturned}).
1:      */
1:     public Slice forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:     {
1:         if (reversed)
1:         {
1:             int cmp = comparator.compare(lastReturned, start);
1:             if (cmp < 0 || (!inclusive && cmp == 0))
1:                 return null;
1: 
1:             cmp = comparator.compare(end, lastReturned);
1:             if (cmp < 0 || (inclusive && cmp == 0))
1:                 return this;
1: 
1:             ByteBuffer[] values = extractValues(lastReturned);
0:             return new Slice(start, inclusive ? Bound.inclusiveEndOf(values) : Bound.exclusiveEndOf(values));
1:         }
1:         else
1:         {
1:             int cmp = comparator.compare(end, lastReturned);
1:             if (cmp < 0 || (!inclusive && cmp == 0))
1:                 return null;
1: 
1:             cmp = comparator.compare(lastReturned, start);
1:             if (cmp < 0 || (inclusive && cmp == 0))
1:                 return this;
1: 
1:             ByteBuffer[] values = extractValues(lastReturned);
0:             return new Slice(inclusive ? Bound.inclusiveStartOf(values) : Bound.exclusiveStartOf(values), end);
1:         }
1:     }
1: 
1:     /**
1:      * Given the per-clustering column minimum and maximum value a sstable contains, whether or not this slice potentially
1:      * intersects that sstable or not.
1:      *
1:      * @param comparator the comparator for the table this is a slice of.
1:      * @param minClusteringValues the smallest values for each clustering column that a sstable contains.
1:      * @param maxClusteringValues the biggest values for each clustering column that a sstable contains.
1:      *
1:      * @return whether the slice might intersects with the sstable having {@code minClusteringValues} and
1:      * {@code maxClusteringValues}.
1:      */
1:     public boolean intersects(ClusteringComparator comparator, List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:     {
1:         // If this slice start after max or end before min, it can't intersect
1:         if (start.compareTo(comparator, maxClusteringValues) > 0 || end.compareTo(comparator, minClusteringValues) < 0)
1:             return false;
1: 
1:         // We could safely return true here, but there's a minor optimization: if the first component
1:         // of the slice is restricted to a single value (typically the slice is [4:5, 4:7]), we can
1:         // check that the second component falls within the min/max for that component (and repeat for
1:         // all components).
1:         for (int j = 0; j < minClusteringValues.size() && j < maxClusteringValues.size(); j++)
1:         {
1:             ByteBuffer s = j < start.size() ? start.get(j) : null;
1:             ByteBuffer f = j < end.size() ? end.get(j) : null;
1: 
1:             // we already know the first component falls within its min/max range (otherwise we wouldn't get here)
1:             if (j > 0 && (j < end.size() && comparator.compareComponent(j, f, minClusteringValues.get(j)) < 0 ||
1:                         j < start.size() && comparator.compareComponent(j, s, maxClusteringValues.get(j)) > 0))
1:                 return false;
1: 
1:             // if this component isn't equal in the start and finish, we don't need to check any more
1:             if (j >= start.size() || j >= end.size() || comparator.compareComponent(j, s, f) != 0)
1:                 break;
1:         }
1:         return true;
1:     }
1: 
1:     public String toString(CFMetaData metadata)
1:     {
1:         return toString(metadata.comparator);
1:     }
1: 
1:     public String toString(ClusteringComparator comparator)
1:     {
1:         StringBuilder sb = new StringBuilder();
1:         sb.append(start.isInclusive() ? "[" : "(");
1:         for (int i = 0; i < start.size(); i++)
1:         {
1:             if (i > 0)
0:                 sb.append(":");
1:             sb.append(comparator.subtype(i).getString(start.get(i)));
1:         }
1:         sb.append(", ");
1:         for (int i = 0; i < end.size(); i++)
1:         {
1:             if (i > 0)
0:                 sb.append(":");
1:             sb.append(comparator.subtype(i).getString(end.get(i)));
1:         }
1:         sb.append(end.isInclusive() ? "]" : ")");
1:         return sb.toString();
1:     }
1: 
1:     @Override
1:     public boolean equals(Object other)
1:     {
1:         if(!(other instanceof Slice))
1:             return false;
1: 
1:         Slice that = (Slice)other;
1:         return this.start().equals(that.start())
1:             && this.end().equals(that.end());
1:     }
1: 
1:     @Override
1:     public int hashCode()
1:     {
1:         return Objects.hash(start(), end());
1:     }
1: 
1:     public static class Serializer
1:     {
1:         public void serialize(Slice slice, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException
1:         {
0:             Bound.serializer.serialize(slice.start, out, version, types);
0:             Bound.serializer.serialize(slice.end, out, version, types);
1:         }
1: 
0:         public long serializedSize(Slice slice, int version, List<AbstractType<?>> types, TypeSizes sizes)
1:         {
0:             return Bound.serializer.serializedSize(slice.start, version, types, sizes)
0:                  + Bound.serializer.serializedSize(slice.end, version, types, sizes);
1:         }
1: 
0:         public Slice deserialize(DataInput in, int version, List<AbstractType<?>> types) throws IOException
1:         {
0:             Bound start = Bound.serializer.deserialize(in, version, types);
0:             Bound end = Bound.serializer.deserialize(in, version, types);
1:             return new Slice(start, end);
1:         }
1:     }
1: 
1:     /**
0:      * The bound of a slice.
1:      * <p>
0:      * This can be either a start or an end bound, and this can be either inclusive or exclusive.
1:      */
0:     public static class Bound extends AbstractClusteringPrefix
1:     {
0:         private static final long EMPTY_SIZE = ObjectSizes.measure(new Bound(Kind.INCL_START_BOUND, new ByteBuffer[0]));
1:         public static final Serializer serializer = new Serializer();
1: 
0:         /** The smallest start bound, i.e. the one that starts before any row. */
0:         public static final Bound BOTTOM = inclusiveStartOf();
0:         /** The biggest end bound, i.e. the one that ends after any row. */
0:         public static final Bound TOP = inclusiveEndOf();
1: 
0:         protected final Kind kind;
0:         protected final ByteBuffer[] values;
1: 
0:         protected Bound(Kind kind, ByteBuffer[] values)
1:         {
0:             this.kind = kind;
0:             this.values = values;
1:         }
1: 
0:         public static Bound create(Kind kind, ByteBuffer[] values)
1:         {
0:             assert !kind.isBoundary();
0:             return new Bound(kind, values);
1:         }
1: 
0:         public static Kind boundKind(boolean isStart, boolean isInclusive)
1:         {
0:             return isStart
0:                  ? (isInclusive ? Kind.INCL_START_BOUND : Kind.EXCL_START_BOUND)
0:                  : (isInclusive ? Kind.INCL_END_BOUND : Kind.EXCL_END_BOUND);
1:         }
1: 
0:         public static Bound inclusiveStartOf(ByteBuffer... values)
1:         {
0:             return create(Kind.INCL_START_BOUND, values);
1:         }
1: 
0:         public static Bound inclusiveEndOf(ByteBuffer... values)
1:         {
0:             return create(Kind.INCL_END_BOUND, values);
1:         }
1: 
0:         public static Bound exclusiveStartOf(ByteBuffer... values)
1:         {
0:             return create(Kind.EXCL_START_BOUND, values);
1:         }
1: 
0:         public static Bound exclusiveEndOf(ByteBuffer... values)
1:         {
0:             return create(Kind.EXCL_END_BOUND, values);
1:         }
1: 
0:         public static Bound exclusiveStartOf(ClusteringPrefix prefix)
1:         {
0:             ByteBuffer[] values = new ByteBuffer[prefix.size()];
0:             for (int i = 0; i < prefix.size(); i++)
0:                 values[i] = prefix.get(i);
0:             return exclusiveStartOf(values);
1:         }
1: 
0:         public static Bound inclusiveEndOf(ClusteringPrefix prefix)
1:         {
0:             ByteBuffer[] values = new ByteBuffer[prefix.size()];
0:             for (int i = 0; i < prefix.size(); i++)
0:                 values[i] = prefix.get(i);
0:             return inclusiveEndOf(values);
1:         }
1: 
0:         public static Bound create(ClusteringComparator comparator, boolean isStart, boolean isInclusive, Object... values)
1:         {
1:             CBuilder builder = CBuilder.create(comparator);
0:             for (int i = 0; i < values.length; i++)
1:             {
0:                 Object val = values[i];
1:                 if (val instanceof ByteBuffer)
0:                     builder.add((ByteBuffer)val);
1:                 else
1:                     builder.add(val);
1:             }
0:             return builder.buildBound(isStart, isInclusive);
1:         }
1: 
0:         public Kind kind()
1:         {
0:             return kind;
1:         }
1: 
0:         public int size()
1:         {
0:             return values.length;
1:         }
1: 
0:         public ByteBuffer get(int i)
1:         {
0:             return values[i];
1:         }
1: 
0:         public Bound withNewKind(Kind kind)
1:         {
0:             assert !kind.isBoundary();
0:             return new Bound(kind, values);
1:         }
1: 
0:         public boolean isStart()
1:         {
0:             return kind().isStart();
1:         }
1: 
0:         public boolean isEnd()
1:         {
0:             return !isStart();
1:         }
1: 
0:         public boolean isInclusive()
1:         {
0:             return kind == Kind.INCL_START_BOUND || kind == Kind.INCL_END_BOUND;
1:         }
1: 
0:         public boolean isExclusive()
1:         {
0:             return kind == Kind.EXCL_START_BOUND || kind == Kind.EXCL_END_BOUND;
1:         }
1: 
1:         /**
0:          * Returns the inverse of the current bound.
1:          * <p>
0:          * This invert both start into end (and vice-versa) and inclusive into exclusive (and vice-versa).
1:          *
0:          * @return the invert of this bound. For instance, if this bound is an exlusive start, this return
0:          * an inclusive end with the same values.
1:          */
0:         public Slice.Bound invert()
1:         {
0:             return withNewKind(kind().invert());
1:         }
1: 
0:         public ByteBuffer[] getRawValues()
1:         {
1:             return values;
1:         }
1: 
0:         public void digest(MessageDigest digest)
1:         {
0:             for (int i = 0; i < size(); i++)
0:                 digest.update(get(i).duplicate());
0:             FBUtilities.updateWithByte(digest, kind().ordinal());
1:         }
1: 
0:         public void writeTo(Slice.Bound.Writer writer)
1:         {
0:             super.writeTo(writer);
0:             writer.writeBoundKind(kind());
1:         }
1: 
0:         // For use by intersects, it's called with the sstable bound opposite to the slice bound
0:         // (so if the slice bound is a start, it's call with the max sstable bound)
0:         private int compareTo(ClusteringComparator comparator, List<ByteBuffer> sstableBound)
1:         {
0:             for (int i = 0; i < sstableBound.size(); i++)
1:             {
0:                 // Say the slice bound is a start. It means we're in the case where the max
0:                 // sstable bound is say (1:5) while the slice start is (1). So the start
0:                 // does start before the sstable end bound (and intersect it). It's the exact
0:                 // inverse with a end slice bound.
0:                 if (i >= size())
0:                     return isStart() ? -1 : 1;
1: 
0:                 int cmp = comparator.compareComponent(i, get(i), sstableBound.get(i));
0:                 if (cmp != 0)
0:                     return cmp;
1:             }
1: 
0:             // Say the slice bound is a start. I means we're in the case where the max
0:             // sstable bound is say (1), while the slice start is (1:5). This again means
0:             // that the slice start before the end bound.
0:             if (size() > sstableBound.size())
0:                 return isStart() ? -1 : 1;
1: 
0:             // The slice bound is equal to the sstable bound. Results depends on whether the slice is inclusive or not
0:             return isInclusive() ? 0 : (isStart() ? 1 : -1);
1:         }
1: 
1:         public String toString(CFMetaData metadata)
1:         {
1:             return toString(metadata.comparator);
1:         }
1: 
1:         public String toString(ClusteringComparator comparator)
1:         {
1:             StringBuilder sb = new StringBuilder();
0:             sb.append(kind()).append("(");
0:             for (int i = 0; i < size(); i++)
1:             {
1:                 if (i > 0)
1:                     sb.append(", ");
0:                 sb.append(comparator.subtype(i).getString(get(i)));
1:             }
0:             return sb.append(")").toString();
1:         }
1: 
0:         // Overriding to get a more precise type
1:         @Override
0:         public Bound takeAlias()
1:         {
1:             return this;
1:         }
1: 
1:         @Override
0:         public long unsharedHeapSize()
1:         {
0:             return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(values);
1:         }
1: 
0:         public long unsharedHeapSizeExcludingData()
1:         {
0:             return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(values);
1:         }
1: 
0:         public static Builder builder(int size)
1:         {
0:             return new Builder(size);
1:         }
1: 
0:         public interface Writer extends ClusteringPrefix.Writer
1:         {
0:             public void writeBoundKind(Kind kind);
1:         }
1: 
0:         public static class Builder implements Writer
1:         {
0:             private final ByteBuffer[] values;
0:             private Kind kind;
0:             private int idx;
1: 
0:             private Builder(int size)
1:             {
0:                 this.values = new ByteBuffer[size];
1:             }
1: 
0:             public void writeClusteringValue(ByteBuffer value)
1:             {
0:                 values[idx++] = value;
1:             }
1: 
0:             public void writeBoundKind(Kind kind)
1:             {
0:                 this.kind = kind;
1:             }
1: 
0:             public Slice.Bound build()
1:             {
0:                 assert idx == values.length;
0:                 return Slice.Bound.create(kind, values);
1:             }
1:         }
1: 
1:         /**
0:          * Serializer for slice bounds.
1:          * <p>
0:          * Contrarily to {@code Clustering}, a slice bound can only be a true prefix of the full clustering, so we actually record
0:          * its size.
1:          */
1:         public static class Serializer
1:         {
0:             public void serialize(Slice.Bound bound, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException
1:             {
0:                 out.writeByte(bound.kind().ordinal());
0:                 out.writeShort(bound.size());
0:                 ClusteringPrefix.serializer.serializeValuesWithoutSize(bound, out, version, types);
1:             }
1: 
0:             public long serializedSize(Slice.Bound bound, int version, List<AbstractType<?>> types, TypeSizes sizes)
1:             {
0:                 return 1 // kind ordinal
0:                      + sizes.sizeof((short)bound.size())
0:                      + ClusteringPrefix.serializer.valuesWithoutSizeSerializedSize(bound, version, types, sizes);
1:             }
1: 
0:             public Slice.Bound deserialize(DataInput in, int version, List<AbstractType<?>> types) throws IOException
1:             {
0:                 Kind kind = Kind.values()[in.readByte()];
0:                 return deserializeValues(in, kind, version, types);
1:             }
1: 
0:             public Slice.Bound deserializeValues(DataInput in, Kind kind, int version, List<AbstractType<?>> types) throws IOException
1:             {
0:                 int size = in.readUnsignedShort();
0:                 if (size == 0)
0:                     return kind.isStart() ? BOTTOM : TOP;
1: 
0:                 Builder builder = builder(size);
0:                 ClusteringPrefix.serializer.deserializeValuesWithoutSize(in, size, version, types, builder);
0:                 builder.writeBoundKind(kind);
0:                 return builder.build();
1:             }
1: 
0:             public void deserializeValues(DataInput in, Bound.Kind kind, int version, List<AbstractType<?>> types, Writer writer) throws IOException
1:             {
0:                 int size = in.readUnsignedShort();
0:                 ClusteringPrefix.serializer.deserializeValuesWithoutSize(in, size, version, types, writer);
0:                 writer.writeBoundKind(kind);
1:             }
1: 
1:         }
1:     }
1: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1:         public long serializedSize(Slice slice, int version, List<AbstractType<?>> types)
0:             return Bound.serializer.serializedSize(slice.start, version, types)
0:                  + Bound.serializer.serializedSize(slice.end, version, types);
/////////////////////////////////////////////////////////////////////////
0:             public long serializedSize(Slice.Bound bound, int version, List<AbstractType<?>> types)
0:                      + TypeSizes.sizeof((short)bound.size())
0:                      + ClusteringPrefix.serializer.valuesWithoutSizeSerializedSize(bound, version, types);
============================================================================