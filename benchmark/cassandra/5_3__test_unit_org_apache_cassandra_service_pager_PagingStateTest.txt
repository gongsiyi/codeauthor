4:b99c863: 
1:b99c863: /*
1:b99c863: * Licensed to the Apache Software Foundation (ASF) under one
1:b99c863: * or more contributor license agreements.  See the NOTICE file
1:b99c863: * distributed with this work for additional information
1:b99c863: * regarding copyright ownership.  The ASF licenses this file
1:b99c863: * to you under the Apache License, Version 2.0 (the
1:b99c863: * "License"); you may not use this file except in compliance
1:b99c863: * with the License.  You may obtain a copy of the License at
1:b99c863: *
1:b99c863: *    http://www.apache.org/licenses/LICENSE-2.0
1:b99c863: *
1:b99c863: * Unless required by applicable law or agreed to in writing,
1:b99c863: * software distributed under the License is distributed on an
1:b99c863: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:b99c863: * KIND, either express or implied.  See the License for the
1:b99c863: * specific language governing permissions and limitations
1:b99c863: * under the License.
1:b99c863: */
1:b99c863: package org.apache.cassandra.service.pager;
1:b99c863: 
1:b99c863: import java.nio.ByteBuffer;
1:b99c863: 
1:9797511: import org.junit.BeforeClass;
1:b99c863: import org.junit.Test;
1:b99c863: 
1:e0adc16: import org.apache.cassandra.Util;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:b99c863: import org.apache.cassandra.utils.ByteBufferUtil;
1:b99c863: 
1:b99c863: import static org.junit.Assert.assertEquals;
1:b99c863: import static org.junit.Assert.assertTrue;
1:b99c863: 
1:b99c863: public class PagingStateTest
2:b99c863: {
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:b99c863:     @Test
1:b99c863:     public void testSerializationBackwardCompatibility()
1:b99c863:     {
1:b99c863:         /*
1:b99c863:          * Tests that the serialized paging state for the native protocol V3 is backward compatible
1:b99c863:          * with what old nodes generate. For that, it compares the serialized format to the hard-coded
1:b99c863:          * value of the same state generated on a 2.1. For the curious, said hardcoded value has been
1:b99c863:          * generated by the following code:
1:b99c863:          *     ByteBuffer pk = ByteBufferUtil.bytes("someKey");
1:b99c863:          *     CellName cn = CellNames.compositeSparse(new ByteBuffer[]{ ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42) },
1:b99c863:          *                                             new ColumnIdentifier("myCol", false),
1:b99c863:          *                                             false);
1:b99c863:          *     PagingState state = new PagingState(pk, cn.toByteBuffer(), 10);
1:b99c863:          *     System.out.println("PagingState = " + ByteBufferUtil.bytesToHex(state.serialize()));
1:b99c863:          */
1:e0adc16:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V3);
1:b99c863: 
1:e0adc16:         String serializedState = ByteBufferUtil.bytesToHex(state.serialize(ProtocolVersion.V3));
1:b99c863:         // Note that we don't assert exact equality because we know 3.0 nodes include the "remainingInPartition" number
1:b99c863:         // that is not present on 2.1/2.2 nodes. We know this is ok however because we know that 2.1/2.2 nodes will ignore
1:b99c863:         // anything remaining once they have properly deserialized a paging state.
1:b99c863:         assertTrue(serializedState.startsWith("0007736f6d654b65790014000263310000040000002a0000056d79636f6c000000000a"));
2:b99c863:     }
1:b99c863: 
1:b99c863:     @Test
1:b99c863:     public void testSerializeDeserializeV3()
1:b99c863:     {
1:e0adc16:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V3);
1:e0adc16:         ByteBuffer serialized = state.serialize(ProtocolVersion.V3);
1:e0adc16:         assertEquals(serialized.remaining(), state.serializedSize(ProtocolVersion.V3));
1:e0adc16:         assertEquals(state, PagingState.deserialize(serialized, ProtocolVersion.V3));
1:b99c863:     }
1:b99c863: 
1:b99c863:     @Test
1:b99c863:     public void testSerializeDeserializeV4()
1:b99c863:     {
1:e0adc16:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V4);
1:e0adc16:         ByteBuffer serialized = state.serialize(ProtocolVersion.V4);
1:e0adc16:         assertEquals(serialized.remaining(), state.serializedSize(ProtocolVersion.V4));
1:e0adc16:         assertEquals(state, PagingState.deserialize(serialized, ProtocolVersion.V4));
1:b99c863:     }
1:b99c863: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V3);
1:         String serializedState = ByteBufferUtil.bytesToHex(state.serialize(ProtocolVersion.V3));
/////////////////////////////////////////////////////////////////////////
1:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V3);
1:         ByteBuffer serialized = state.serialize(ProtocolVersion.V3);
1:         assertEquals(serialized.remaining(), state.serializedSize(ProtocolVersion.V3));
1:         assertEquals(state, PagingState.deserialize(serialized, ProtocolVersion.V3));
1:         PagingState state = Util.makeSomePagingState(ProtocolVersion.V4);
1:         ByteBuffer serialized = state.serialize(ProtocolVersion.V4);
1:         assertEquals(serialized.remaining(), state.serializedSize(ProtocolVersion.V4));
1:         assertEquals(state, PagingState.deserialize(serialized, ProtocolVersion.V4));
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
0:         Row row = BTreeRow.singleCellRow(c, BufferCell.live(def, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
0:         Clustering c = Clustering.make(ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:b99c863
/////////////////////////////////////////////////////////////////////////
1: 
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.service.pager;
1: 
1: import java.nio.ByteBuffer;
1: 
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.cql3.ColumnIdentifier;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.rows.*;
0: import org.apache.cassandra.db.marshal.*;
0: import org.apache.cassandra.transport.Server;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: public class PagingStateTest
1: {
0:     private PagingState makeSomePagingState(int protocolVersion)
1:     {
0:         CFMetaData metadata = CFMetaData.Builder.create("ks", "tbl")
0:                                                 .addPartitionKey("k", AsciiType.instance)
0:                                                 .addClusteringColumn("c1", AsciiType.instance)
0:                                                 .addClusteringColumn("c1", Int32Type.instance)
0:                                                 .addRegularColumn("myCol", AsciiType.instance)
0:                                                 .build();
1: 
0:         ByteBuffer pk = ByteBufferUtil.bytes("someKey");
1: 
0:         ColumnDefinition def = metadata.getColumnDefinition(new ColumnIdentifier("myCol", false));
0:         Clustering c = new Clustering(ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42));
0:         Row row = BTreeRow.singleCellRow(c, BufferCell.live(metadata, def, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER));
0:         PagingState.RowMark mark = PagingState.RowMark.create(metadata, row, protocolVersion);
0:         return new PagingState(pk, mark, 10, 0);
1:     }
1: 
1:     @Test
1:     public void testSerializationBackwardCompatibility()
1:     {
1:         /*
1:          * Tests that the serialized paging state for the native protocol V3 is backward compatible
1:          * with what old nodes generate. For that, it compares the serialized format to the hard-coded
1:          * value of the same state generated on a 2.1. For the curious, said hardcoded value has been
1:          * generated by the following code:
1:          *     ByteBuffer pk = ByteBufferUtil.bytes("someKey");
1:          *     CellName cn = CellNames.compositeSparse(new ByteBuffer[]{ ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42) },
1:          *                                             new ColumnIdentifier("myCol", false),
1:          *                                             false);
1:          *     PagingState state = new PagingState(pk, cn.toByteBuffer(), 10);
1:          *     System.out.println("PagingState = " + ByteBufferUtil.bytesToHex(state.serialize()));
1:          */
0:         PagingState state = makeSomePagingState(Server.VERSION_3);
1: 
0:         String serializedState = ByteBufferUtil.bytesToHex(state.serialize(Server.VERSION_3));
1:         // Note that we don't assert exact equality because we know 3.0 nodes include the "remainingInPartition" number
1:         // that is not present on 2.1/2.2 nodes. We know this is ok however because we know that 2.1/2.2 nodes will ignore
1:         // anything remaining once they have properly deserialized a paging state.
1:         assertTrue(serializedState.startsWith("0007736f6d654b65790014000263310000040000002a0000056d79636f6c000000000a"));
1:     }
1: 
1:     @Test
1:     public void testSerializeDeserializeV3()
1:     {
0:         PagingState state = makeSomePagingState(Server.VERSION_3);
0:         ByteBuffer serialized = state.serialize(Server.VERSION_3);
0:         assertEquals(serialized.remaining(), state.serializedSize(Server.VERSION_3));
0:         assertEquals(state, PagingState.deserialize(serialized, Server.VERSION_3));
1:     }
1: 
1:     @Test
1:     public void testSerializeDeserializeV4()
1:     {
0:         PagingState state = makeSomePagingState(Server.VERSION_4);
0:         ByteBuffer serialized = state.serialize(Server.VERSION_4);
0:         assertEquals(serialized.remaining(), state.serializedSize(Server.VERSION_4));
0:         assertEquals(state, PagingState.deserialize(serialized, Server.VERSION_4));
1:     }
1: }
============================================================================