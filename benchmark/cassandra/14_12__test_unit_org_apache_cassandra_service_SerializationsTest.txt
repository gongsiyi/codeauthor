1:407a76f: /*
1:407a76f:  * Licensed to the Apache Software Foundation (ASF) under one
1:407a76f:  * or more contributor license agreements.  See the NOTICE file
1:407a76f:  * distributed with this work for additional information
1:407a76f:  * regarding copyright ownership.  The ASF licenses this file
1:407a76f:  * to you under the Apache License, Version 2.0 (the
1:407a76f:  * "License"); you may not use this file except in compliance
1:407a76f:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:407a76f:  *   http://www.apache.org/licenses/LICENSE-2.0
3:07cdfd0:  *
1:407a76f:  * Unless required by applicable law or agreed to in writing,
1:407a76f:  * software distributed under the License is distributed on an
1:407a76f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:407a76f:  * KIND, either express or implied.  See the License for the
1:407a76f:  * specific language governing permissions and limitations
1:407a76f:  * under the License.
1:407a76f:  */
1:f81cc74: package org.apache.cassandra.service;
1:a991b64: 
1:434636a: import java.io.IOException;
1:eb4fa4a: import java.net.InetAddress;
1:0dd50a6: import java.util.Arrays;
1:eb4fa4a: import java.util.Collections;
1:eb4fa4a: import java.util.UUID;
1:69f77cb: 
1:0a08525: import org.junit.AfterClass;
1:0a08525: import org.junit.BeforeClass;
1:c715b6d: import org.junit.Test;
1:0a08525: 
1:c715b6d: import org.apache.cassandra.AbstractSerializationsTester;
1:0a08525: import org.apache.cassandra.Util;
1:0a08525: import org.apache.cassandra.Util.PartitionerSwitcher;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:c715b6d: import org.apache.cassandra.dht.IPartitioner;
1:c715b6d: import org.apache.cassandra.dht.RandomPartitioner;
1:dc89826: import org.apache.cassandra.dht.Range;
1:c715b6d: import org.apache.cassandra.dht.Token;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus.DataInputStreamPlus;
1:16499ca: import org.apache.cassandra.io.util.DataOutputStreamPlus;
1:a06be23: import org.apache.cassandra.net.MessageIn;
1:a7b7214: import org.apache.cassandra.net.MessagingService;
1:eb4fa4a: import org.apache.cassandra.repair.NodePair;
1:eb4fa4a: import org.apache.cassandra.repair.RepairJobDesc;
1:eb4fa4a: import org.apache.cassandra.repair.Validator;
1:eb4fa4a: import org.apache.cassandra.repair.messages.*;
1:c715b6d: import org.apache.cassandra.utils.FBUtilities;
1:0dd50a6: import org.apache.cassandra.utils.MerkleTrees;
1:69f77cb: 
1:434636a: public class SerializationsTest extends AbstractSerializationsTester
3:434636a: {
1:0a08525:     private static PartitionerSwitcher partitionerSwitcher;
1:0a08525:     private static UUID RANDOM_UUID;
1:0a08525:     private static Range<Token> FULL_RANGE;
1:0a08525:     private static RepairJobDesc DESC;
1:0a08525: 
1:0a08525:     @BeforeClass
1:0a08525:     public static void defineSchema() throws Exception
1:56302ce:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:0a08525:         partitionerSwitcher = Util.switchPartitioner(RandomPartitioner.instance);
1:0a08525:         RANDOM_UUID = UUID.fromString("b5c3d033-75aa-4c2f-a819-947aac7a0c54");
1:0a08525:         FULL_RANGE = new Range<>(Util.testPartitioner().getMinimumToken(), Util.testPartitioner().getMinimumToken());
1:0dd50a6:         DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", Arrays.asList(FULL_RANGE));
1:56302ce:     }
1:56302ce: 
1:0a08525:     @AfterClass
1:0a08525:     public static void tearDown()
1:0a08525:     {
1:0a08525:         partitionerSwitcher.close();
1:0a08525:     }
1:0dd50a6:     
1:eb4fa4a:     private void testRepairMessageWrite(String fileName, RepairMessage... messages) throws IOException
1:69f77cb:     {
1:16499ca:         try (DataOutputStreamPlus out = getOutput(fileName))
1:eb4fa4a:         {
1:eb4fa4a:             for (RepairMessage message : messages)
1:eb4fa4a:             {
1:eb4fa4a:                 testSerializedSize(message, RepairMessage.serializer);
1:eb4fa4a:                 RepairMessage.serializer.serialize(message, out, getVersion());
1:69f77cb:             }
1:eb4fa4a:             // also serialize MessageOut
1:eb4fa4a:             for (RepairMessage message : messages)
1:eb4fa4a:                 message.createMessage().serialize(out,  getVersion());
1:eb4fa4a:         }
1:eb4fa4a:     }
1:0a08525: 
1:eb4fa4a:     private void testValidationRequestWrite() throws IOException
1:eb4fa4a:     {
1:eb4fa4a:         ValidationRequest message = new ValidationRequest(DESC, 1234);
1:eb4fa4a:         testRepairMessageWrite("service.ValidationRequest.bin", message);
1:eb4fa4a:     }
1:69f77cb: 
1:434636a:     @Test
1:eb4fa4a:     public void testValidationRequestRead() throws IOException
1:434636a:     {
1:434636a:         if (EXECUTE_WRITES)
1:eb4fa4a:             testValidationRequestWrite();
1:07cdfd0: 
1:03f72ac:         try (DataInputStreamPlus in = getInput("service.ValidationRequest.bin"))
1:eb4fa4a:         {
1:eb4fa4a:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.VALIDATION_REQUEST;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a:             assert ((ValidationRequest) message).gcBefore == 1234;
1:07cdfd0: 
1:1936648:             assert MessageIn.read(in, getVersion(), -1) != null;
1:eb4fa4a:         }
3:434636a:     }
1:07cdfd0: 
1:eb4fa4a:     private void testValidationCompleteWrite() throws IOException
1:434636a:     {
1:07893d7:         IPartitioner p = RandomPartitioner.instance;
1:0dd50a6: 
1:0dd50a6:         MerkleTrees mt = new MerkleTrees(p);
1:0dd50a6: 
1:9597641:         // empty validation
1:0dd50a6:         mt.addMerkleTree((int) Math.pow(2, 15), FULL_RANGE);
1:eb4fa4a:         Validator v0 = new Validator(DESC, FBUtilities.getBroadcastAddress(),  -1);
1:ef4a07b:         ValidationComplete c0 = new ValidationComplete(DESC, mt);
1:9597641: 
1:9597641:         // validation with a tree
1:0dd50a6:         mt = new MerkleTrees(p);
1:0dd50a6:         mt.addMerkleTree(Integer.MAX_VALUE, FULL_RANGE);
1:434636a:         for (int i = 0; i < 10; i++)
1:9597641:             mt.split(p.getRandomToken());
1:ef4a07b:         Validator v1 = new Validator(DESC, FBUtilities.getBroadcastAddress(), -1);
1:ef4a07b:         ValidationComplete c1 = new ValidationComplete(DESC, mt);
1:9597641: 
1:eb4fa4a:         // validation failed
1:eb4fa4a:         ValidationComplete c3 = new ValidationComplete(DESC);
1:07cdfd0: 
1:eb4fa4a:         testRepairMessageWrite("service.ValidationComplete.bin", c0, c1, c3);
1:434636a:     }
1:07cdfd0: 
1:434636a:     @Test
1:eb4fa4a:     public void testValidationCompleteRead() throws IOException
1:434636a:     {
1:434636a:         if (EXECUTE_WRITES)
1:eb4fa4a:             testValidationCompleteWrite();
1:07cdfd0: 
1:03f72ac:         try (DataInputStreamPlus in = getInput("service.ValidationComplete.bin"))
1:eb4fa4a:         {
1:eb4fa4a:             // empty validation
1:eb4fa4a:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:dc89826: 
1:0dd50a6:             assert ((ValidationComplete) message).success();
1:0dd50a6:             assert ((ValidationComplete) message).trees != null;
2:eb4fa4a: 
1:eb4fa4a:             // validation with a tree
1:eb4fa4a:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a: 
1:0dd50a6:             assert ((ValidationComplete) message).success();
1:0dd50a6:             assert ((ValidationComplete) message).trees != null;
1:eb4fa4a: 
1:eb4fa4a:             // failed validation
1:eb4fa4a:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a: 
1:0dd50a6:             assert !((ValidationComplete) message).success();
1:0dd50a6:             assert ((ValidationComplete) message).trees == null;
1:eb4fa4a: 
1:eb4fa4a:             // MessageOuts
1:eb4fa4a:             for (int i = 0; i < 3; i++)
1:1936648:                 assert MessageIn.read(in, getVersion(), -1) != null;
1:eb4fa4a:         }
1:434636a:     }
1:eb4fa4a: 
1:eb4fa4a:     private void testSyncRequestWrite() throws IOException
1:434636a:     {
1:eb4fa4a:         InetAddress local = InetAddress.getByAddress(new byte[]{127, 0, 0, 1});
1:eb4fa4a:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:eb4fa4a:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:eb4fa4a:         SyncRequest message = new SyncRequest(DESC, local, src, dest, Collections.singleton(FULL_RANGE));
1:eb4fa4a: 
1:eb4fa4a:         testRepairMessageWrite("service.SyncRequest.bin", message);
1:eb4fa4a:     }
1:eb4fa4a: 
1:eb4fa4a:     @Test
1:eb4fa4a:     public void testSyncRequestRead() throws IOException
1:eb4fa4a:     {
1:eb4fa4a:         if (EXECUTE_WRITES)
1:eb4fa4a:             testSyncRequestWrite();
1:eb4fa4a: 
1:eb4fa4a:         InetAddress local = InetAddress.getByAddress(new byte[]{127, 0, 0, 1});
1:eb4fa4a:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:eb4fa4a:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:eb4fa4a: 
1:03f72ac:         try (DataInputStreamPlus in = getInput("service.SyncRequest.bin"))
1:eb4fa4a:         {
1:eb4fa4a:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.SYNC_REQUEST;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a:             assert local.equals(((SyncRequest) message).initiator);
1:eb4fa4a:             assert src.equals(((SyncRequest) message).src);
1:eb4fa4a:             assert dest.equals(((SyncRequest) message).dst);
1:eb4fa4a:             assert ((SyncRequest) message).ranges.size() == 1 && ((SyncRequest) message).ranges.contains(FULL_RANGE);
1:eb4fa4a: 
1:1936648:             assert MessageIn.read(in, getVersion(), -1) != null;
1:eb4fa4a:         }
1:eb4fa4a:     }
1:eb4fa4a: 
1:eb4fa4a:     private void testSyncCompleteWrite() throws IOException
1:eb4fa4a:     {
1:eb4fa4a:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:eb4fa4a:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:eb4fa4a:         // sync success
1:eb4fa4a:         SyncComplete success = new SyncComplete(DESC, src, dest, true);
1:eb4fa4a:         // sync fail
1:eb4fa4a:         SyncComplete fail = new SyncComplete(DESC, src, dest, false);
1:eb4fa4a: 
1:eb4fa4a:         testRepairMessageWrite("service.SyncComplete.bin", success, fail);
1:eb4fa4a:     }
1:eb4fa4a: 
1:eb4fa4a:     @Test
1:eb4fa4a:     public void testSyncCompleteRead() throws IOException
1:eb4fa4a:     {
1:eb4fa4a:         if (EXECUTE_WRITES)
1:eb4fa4a:             testSyncCompleteWrite();
1:eb4fa4a: 
1:eb4fa4a:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:eb4fa4a:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:eb4fa4a:         NodePair nodes = new NodePair(src, dest);
1:eb4fa4a: 
1:03f72ac:         try (DataInputStreamPlus in = getInput("service.SyncComplete.bin"))
1:eb4fa4a:         {
1:eb4fa4a:             // success
1:eb4fa4a:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.SYNC_COMPLETE;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a: 
1:eb4fa4a:             assert nodes.equals(((SyncComplete) message).nodes);
1:eb4fa4a:             assert ((SyncComplete) message).success;
1:eb4fa4a: 
1:eb4fa4a:             // fail
1:eb4fa4a:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:eb4fa4a:             assert message.messageType == RepairMessage.Type.SYNC_COMPLETE;
1:eb4fa4a:             assert DESC.equals(message.desc);
1:eb4fa4a: 
1:eb4fa4a:             assert nodes.equals(((SyncComplete) message).nodes);
1:eb4fa4a:             assert !((SyncComplete) message).success;
1:eb4fa4a: 
1:eb4fa4a:             // MessageOuts
1:eb4fa4a:             for (int i = 0; i < 2; i++)
4:eb4fa4a:                 assert MessageIn.read(in, getVersion(), -1) != null;
1:eb4fa4a:         }
1:434636a:     }
1:434636a: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Marcus Olsson
-------------------------------------------------------------------------------
commit:0dd50a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.MerkleTrees;
/////////////////////////////////////////////////////////////////////////
1:         DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", Arrays.asList(FULL_RANGE));
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:         MerkleTrees mt = new MerkleTrees(p);
1: 
1:         mt.addMerkleTree((int) Math.pow(2, 15), FULL_RANGE);
1:         mt = new MerkleTrees(p);
1:         mt.addMerkleTree(Integer.MAX_VALUE, FULL_RANGE);
/////////////////////////////////////////////////////////////////////////
1:             assert ((ValidationComplete) message).success();
1:             assert ((ValidationComplete) message).trees != null;
1:             assert ((ValidationComplete) message).success();
1:             assert ((ValidationComplete) message).trees != null;
1:             assert !((ValidationComplete) message).success();
1:             assert ((ValidationComplete) message).trees == null;
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: import org.junit.AfterClass;
1: import org.junit.BeforeClass;
1: 
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.Util.PartitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
1:     private static PartitionerSwitcher partitionerSwitcher;
1:     private static UUID RANDOM_UUID;
1:     private static Range<Token> FULL_RANGE;
1:     private static RepairJobDesc DESC;
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws Exception
1:         partitionerSwitcher = Util.switchPartitioner(RandomPartitioner.instance);
1:         RANDOM_UUID = UUID.fromString("b5c3d033-75aa-4c2f-a819-947aac7a0c54");
1:         FULL_RANGE = new Range<>(Util.testPartitioner().getMinimumToken(), Util.testPartitioner().getMinimumToken());
0:         DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", FULL_RANGE);
1:     @AfterClass
1:     public static void tearDown()
1:     {
1:         partitionerSwitcher.close();
1:     }
1: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:     static
0:         System.setProperty("cassandra.partitioner", "RandomPartitioner");
0:     private static final UUID RANDOM_UUID = UUID.fromString("b5c3d033-75aa-4c2f-a819-947aac7a0c54");
0:     private static final Range<Token> FULL_RANGE = new Range<>(StorageService.getPartitioner().getMinimumToken(), StorageService.getPartitioner().getMinimumToken());
0:     private static final RepairJobDesc DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", FULL_RANGE);
commit:ae80948
/////////////////////////////////////////////////////////////////////////
0:         ActiveRepairService.TreeRequest.serializer.serialize(Statics.req, out, getVersion());
0:         testSerializedSize(Statics.req, ActiveRepairService.TreeRequest.serializer);
/////////////////////////////////////////////////////////////////////////
0:         assert ActiveRepairService.TreeRequest.serializer.deserialize(in, getVersion()) != null;
/////////////////////////////////////////////////////////////////////////
0:         ActiveRepairService.Validator v0 = new ActiveRepairService.Validator(Statics.req);
0:         ActiveRepairService.Validator v1 = new ActiveRepairService.Validator(Statics.req, mt);
0:         ActiveRepairService.Validator.serializer.serialize(v0, out, getVersion());
0:         ActiveRepairService.Validator.serializer.serialize(v1, out, getVersion());
0:         testSerializedSize(v0, ActiveRepairService.Validator.serializer);
0:         testSerializedSize(v1, ActiveRepairService.Validator.serializer);
/////////////////////////////////////////////////////////////////////////
0:         assert ActiveRepairService.Validator.serializer.deserialize(in, getVersion()) != null;
0:         assert ActiveRepairService.Validator.serializer.deserialize(in, getVersion()) != null;
/////////////////////////////////////////////////////////////////////////
0:         private static final ActiveRepairService.CFPair pair = new ActiveRepairService.CFPair("Keyspace1", "Standard1");
0:         private static final ActiveRepairService.TreeRequest req = new ActiveRepairService.TreeRequest("sessionId", FBUtilities.getBroadcastAddress(), FULL_RANGE, pair);
commit:1936648
/////////////////////////////////////////////////////////////////////////
1:         assert MessageIn.read(in, getVersion(), -1) != null;
/////////////////////////////////////////////////////////////////////////
1:         assert MessageIn.read(in, getVersion(), -1) != null;
1:         assert MessageIn.read(in, getVersion(), -1) != null;
commit:a06be23
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessageIn;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         assert MessageIn.read(in, getVersion(), "id") != null;
/////////////////////////////////////////////////////////////////////////
0:         assert MessageIn.read(in, getVersion(), "id") != null;
0:         assert MessageIn.read(in, getVersion(), "id") != null;
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
0:         AntiEntropyService.TreeRequest.serializer.serialize(Statics.req, out, getVersion());
0:         Statics.req.createMessage().serialize(out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert AntiEntropyService.TreeRequest.serializer.deserialize(in, getVersion()) != null;
/////////////////////////////////////////////////////////////////////////
0:         AntiEntropyService.Validator.serializer.serialize(v0, out, getVersion());
0:         AntiEntropyService.Validator.serializer.serialize(v1, out, getVersion());
0:         v0.createMessage().serialize(out, getVersion());
0:         v1.createMessage().serialize(out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert AntiEntropyService.Validator.serializer.deserialize(in, getVersion()) != null;
0:         assert AntiEntropyService.Validator.serializer.deserialize(in, getVersion()) != null;
commit:d3c5dbd
commit:56302ce
/////////////////////////////////////////////////////////////////////////
0:     static
1:     {
0:         System.setProperty("cassandra.partitioner", "RandomPartitioner");
1:     }
1: 
commit:9597641
/////////////////////////////////////////////////////////////////////////
1:         // empty validation
1: 
1:         // validation with a tree
0:         IPartitioner p = new RandomPartitioner();
0:         MerkleTree mt = new MerkleTree(p, FULL_RANGE, MerkleTree.RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:             mt.split(p.getRandomToken());
1: 
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.AfterClass;
0: import org.junit.BeforeClass;
1: 
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.Util.PartitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
0:     private static PartitionerSwitcher partitionerSwitcher;
0:     private static UUID RANDOM_UUID;
0:     private static Range<Token> FULL_RANGE;
0:     private static RepairJobDesc DESC;
1: 
0:     @BeforeClass
0:     public static void defineSchema() throws Exception
0:         partitionerSwitcher = Util.switchPartitioner(RandomPartitioner.instance);
0:         RANDOM_UUID = UUID.fromString("b5c3d033-75aa-4c2f-a819-947aac7a0c54");
0:         FULL_RANGE = new Range<>(Util.testPartitioner().getMinimumToken(), Util.testPartitioner().getMinimumToken());
0:         DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", FULL_RANGE);
0:     @AfterClass
0:     public static void tearDown()
1:     {
0:         partitionerSwitcher.close();
1:     }
1: 
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner p = RandomPartitioner.instance;
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataInputPlus;
1: import org.apache.cassandra.io.util.DataInputPlus.DataInputStreamPlus;
/////////////////////////////////////////////////////////////////////////
1:         try (DataInputStreamPlus in = getInput("service.ValidationRequest.bin"))
/////////////////////////////////////////////////////////////////////////
1:         try (DataInputStreamPlus in = getInput("service.ValidationComplete.bin"))
/////////////////////////////////////////////////////////////////////////
1:         try (DataInputStreamPlus in = getInput("service.SyncRequest.bin"))
/////////////////////////////////////////////////////////////////////////
1:         try (DataInputStreamPlus in = getInput("service.SyncComplete.bin"))
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputStreamPlus;
/////////////////////////////////////////////////////////////////////////
1:         try (DataOutputStreamPlus out = getOutput(fileName))
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: 
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:554223b
/////////////////////////////////////////////////////////////////////////
0:     public static Range<Token> FULL_RANGE = new Range<Token>(StorageService.getPartitioner().getMinimumToken(), StorageService.getPartitioner().getMinimumToken());
commit:dc89826
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.Range;
/////////////////////////////////////////////////////////////////////////
0:     public static Range FULL_RANGE = new Range(StorageService.getPartitioner().getMinimumToken(), StorageService.getPartitioner().getMinimumToken());
1: 
/////////////////////////////////////////////////////////////////////////
0:         MerkleTree mt = new MerkleTree(part, FULL_RANGE, MerkleTree.RECOMMENDED_DEPTH, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:         private static final AntiEntropyService.TreeRequest req = new AntiEntropyService.TreeRequest("sessionId", FBUtilities.getLocalAddress(), FULL_RANGE, pair);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:ef4a07b
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = new RandomPartitioner();
0:         MerkleTree mt = new MerkleTree(p, FULL_RANGE, MerkleTree.RECOMMENDED_DEPTH, (int) Math.pow(2, 15));
1:         ValidationComplete c0 = new ValidationComplete(DESC, mt);
0:         mt = new MerkleTree(p, FULL_RANGE, MerkleTree.RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:         Validator v1 = new Validator(DESC, FBUtilities.getBroadcastAddress(), -1);
1:         ValidationComplete c1 = new ValidationComplete(DESC, mt);
commit:eb4fa4a
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.util.Collections;
1: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.repair.NodePair;
1: import org.apache.cassandra.repair.RepairJobDesc;
1: import org.apache.cassandra.repair.Validator;
1: import org.apache.cassandra.repair.messages.*;
/////////////////////////////////////////////////////////////////////////
0:     private static final UUID RANDOM_UUID = UUID.fromString("b5c3d033-75aa-4c2f-a819-947aac7a0c54");
0:     private static final Range<Token> FULL_RANGE = new Range<>(StorageService.getPartitioner().getMinimumToken(), StorageService.getPartitioner().getMinimumToken());
0:     private static final RepairJobDesc DESC = new RepairJobDesc(RANDOM_UUID, "Keyspace1", "Standard1", FULL_RANGE);
1:     private void testRepairMessageWrite(String fileName, RepairMessage... messages) throws IOException
0:         try (DataOutputStream out = getOutput(fileName))
1:         {
1:             for (RepairMessage message : messages)
1:             {
1:                 testSerializedSize(message, RepairMessage.serializer);
1:                 RepairMessage.serializer.serialize(message, out, getVersion());
1:             }
1:             // also serialize MessageOut
1:             for (RepairMessage message : messages)
1:                 message.createMessage().serialize(out,  getVersion());
1:         }
1:     }
1:     private void testValidationRequestWrite() throws IOException
1:     {
1:         ValidationRequest message = new ValidationRequest(DESC, 1234);
1:         testRepairMessageWrite("service.ValidationRequest.bin", message);
1:     public void testValidationRequestRead() throws IOException
1:             testValidationRequestWrite();
0:         try (DataInputStream in = getInput("service.ValidationRequest.bin"))
1:         {
1:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.VALIDATION_REQUEST;
1:             assert DESC.equals(message.desc);
1:             assert ((ValidationRequest) message).gcBefore == 1234;
1: 
1:             assert MessageIn.read(in, getVersion(), -1) != null;
1:         }
1:     private void testValidationCompleteWrite() throws IOException
1:         Validator v0 = new Validator(DESC, FBUtilities.getBroadcastAddress(),  -1);
0:         ValidationComplete c0 = new ValidationComplete(DESC, v0.tree);
0:         Validator v1 = new Validator(DESC, FBUtilities.getBroadcastAddress(), mt, -1);
0:         ValidationComplete c1 = new ValidationComplete(DESC, v1.tree);
1:         // validation failed
1:         ValidationComplete c3 = new ValidationComplete(DESC);
1:         testRepairMessageWrite("service.ValidationComplete.bin", c0, c1, c3);
1:     public void testValidationCompleteRead() throws IOException
1:             testValidationCompleteWrite();
0:         try (DataInputStream in = getInput("service.ValidationComplete.bin"))
1:         {
1:             // empty validation
1:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:             assert DESC.equals(message.desc);
1: 
0:             assert ((ValidationComplete) message).success;
0:             assert ((ValidationComplete) message).tree != null;
1: 
1:             // validation with a tree
1:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:             assert DESC.equals(message.desc);
1: 
0:             assert ((ValidationComplete) message).success;
0:             assert ((ValidationComplete) message).tree != null;
1: 
1:             // failed validation
1:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.VALIDATION_COMPLETE;
1:             assert DESC.equals(message.desc);
1: 
0:             assert !((ValidationComplete) message).success;
0:             assert ((ValidationComplete) message).tree == null;
1: 
1:             // MessageOuts
1:             for (int i = 0; i < 3; i++)
1:                 assert MessageIn.read(in, getVersion(), -1) != null;
1:         }
1:     private void testSyncRequestWrite() throws IOException
1:         InetAddress local = InetAddress.getByAddress(new byte[]{127, 0, 0, 1});
1:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:         SyncRequest message = new SyncRequest(DESC, local, src, dest, Collections.singleton(FULL_RANGE));
1: 
1:         testRepairMessageWrite("service.SyncRequest.bin", message);
1:     }
1: 
1:     @Test
1:     public void testSyncRequestRead() throws IOException
1:     {
1:         if (EXECUTE_WRITES)
1:             testSyncRequestWrite();
1: 
1:         InetAddress local = InetAddress.getByAddress(new byte[]{127, 0, 0, 1});
1:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1: 
0:         try (DataInputStream in = getInput("service.SyncRequest.bin"))
1:         {
1:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.SYNC_REQUEST;
1:             assert DESC.equals(message.desc);
1:             assert local.equals(((SyncRequest) message).initiator);
1:             assert src.equals(((SyncRequest) message).src);
1:             assert dest.equals(((SyncRequest) message).dst);
1:             assert ((SyncRequest) message).ranges.size() == 1 && ((SyncRequest) message).ranges.contains(FULL_RANGE);
1: 
1:             assert MessageIn.read(in, getVersion(), -1) != null;
1:         }
1:     }
1: 
1:     private void testSyncCompleteWrite() throws IOException
1:     {
1:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:         // sync success
1:         SyncComplete success = new SyncComplete(DESC, src, dest, true);
1:         // sync fail
1:         SyncComplete fail = new SyncComplete(DESC, src, dest, false);
1: 
1:         testRepairMessageWrite("service.SyncComplete.bin", success, fail);
1:     }
1: 
1:     @Test
1:     public void testSyncCompleteRead() throws IOException
1:     {
1:         if (EXECUTE_WRITES)
1:             testSyncCompleteWrite();
1: 
1:         InetAddress src = InetAddress.getByAddress(new byte[]{127, 0, 0, 2});
1:         InetAddress dest = InetAddress.getByAddress(new byte[]{127, 0, 0, 3});
1:         NodePair nodes = new NodePair(src, dest);
1: 
0:         try (DataInputStream in = getInput("service.SyncComplete.bin"))
1:         {
1:             // success
1:             RepairMessage message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.SYNC_COMPLETE;
1:             assert DESC.equals(message.desc);
1: 
1:             assert nodes.equals(((SyncComplete) message).nodes);
1:             assert ((SyncComplete) message).success;
1: 
1:             // fail
1:             message = RepairMessage.serializer.deserialize(in, getVersion());
1:             assert message.messageType == RepairMessage.Type.SYNC_COMPLETE;
1:             assert DESC.equals(message.desc);
1: 
1:             assert nodes.equals(((SyncComplete) message).nodes);
1:             assert !((SyncComplete) message).success;
1: 
1:             // MessageOuts
1:             for (int i = 0; i < 2; i++)
1:                 assert MessageIn.read(in, getVersion(), -1) != null;
1:         }
commit:f81cc74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.service;
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 
0:         // test serializedSize
0:         testSerializedSize(Statics.req, AntiEntropyService.TreeRequest.serializer);
/////////////////////////////////////////////////////////////////////////
0: 
0:         // test serializedSize
0:         testSerializedSize(v0, AntiEntropyService.Validator.serializer);
0:         testSerializedSize(v1, AntiEntropyService.Validator.serializer);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputStreamAndChannel;
/////////////////////////////////////////////////////////////////////////
0:         try (DataOutputStreamAndChannel out = getOutput(fileName))
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:a7b7214
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
0:     private static final RepairJobDesc DESC = new RepairJobDesc(getVersion() < MessagingService.VERSION_21 ? null : RANDOM_UUID, RANDOM_UUID, "Keyspace1", "Standard1", FULL_RANGE);
commit:efbdee2
/////////////////////////////////////////////////////////////////////////
0:         private static final ActiveRepairService.TreeRequest req = new ActiveRepairService.TreeRequest("sessionId", FBUtilities.getBroadcastAddress(), FULL_RANGE, 1234, pair);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:c715b6d
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
0: 
1: import org.apache.cassandra.AbstractSerializationsTester;
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.RandomPartitioner;
0: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.net.MessageSerializer;
1: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.MerkleTree;
0: 
0:     private static MessageSerializer messageSerializer = new MessageSerializer();
0: 
0:         messageSerializer.serialize(AntiEntropyService.TreeRequestVerbHandler.makeVerb(Statics.req, getVersion()), out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert messageSerializer.deserialize(in, getVersion()) != null;
/////////////////////////////////////////////////////////////////////////
0:         messageSerializer.serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getBroadcastAddress(), v0), out, getVersion());
0:         messageSerializer.serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getBroadcastAddress(), v1), out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert messageSerializer.deserialize(in, getVersion()) != null;
0:         assert messageSerializer.deserialize(in, getVersion()) != null;
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getBroadcastAddress(), v0), out, getVersion());
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getBroadcastAddress(), v1), out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         private static final AntiEntropyService.TreeRequest req = new AntiEntropyService.TreeRequest("sessionId", FBUtilities.getBroadcastAddress(), FULL_RANGE, pair);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
0:         AntiEntropyService.TreeRequestVerbHandler.SERIALIZER.serialize(Statics.req, out, getVersion());
0:         Message.serializer().serialize(AntiEntropyService.TreeRequestVerbHandler.makeVerb(Statics.req, getVersion()), out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert AntiEntropyService.TreeRequestVerbHandler.SERIALIZER.deserialize(in, getVersion()) != null;
0:         assert Message.serializer().deserialize(in, getVersion()) != null;
/////////////////////////////////////////////////////////////////////////
0:         AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.serialize(v0, out, getVersion());
0:         AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.serialize(v1, out, getVersion());
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getLocalAddress(), v0), out, getVersion());
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getLocalAddress(), v1), out, getVersion());
/////////////////////////////////////////////////////////////////////////
0:         assert AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.deserialize(in, getVersion()) != null;
0:         assert AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.deserialize(in, getVersion()) != null;
0:         assert Message.serializer().deserialize(in, getVersion()) != null;
0:         assert Message.serializer().deserialize(in, getVersion()) != null;
commit:5d02c51
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
0:         Message.serializer().serialize(AntiEntropyService.TreeRequestVerbHandler.makeVerb(Statics.req, MessagingService.version_), out);
commit:434636a
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.service;
0: 
0: import org.apache.cassandra.AbstractSerializationsTester;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.RandomPartitioner;
0: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.MerkleTree;
0: import org.junit.Test;
0: 
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
1: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.List;
0: 
1: public class SerializationsTest extends AbstractSerializationsTester
1: {
0:     private void testTreeRequestWrite() throws IOException
1:     {
0:         DataOutputStream out = getOutput("service.TreeRequest.bin");
0:         AntiEntropyService.TreeRequestVerbHandler.SERIALIZER.serialize(Statics.req, out);
0:         Message.serializer().serialize(AntiEntropyService.TreeRequestVerbHandler.makeVerb(Statics.req), out);
0:         out.close();
1:     }
0:     
1:     @Test
0:     public void testTreeRequestRead() throws IOException
1:     {
1:         if (EXECUTE_WRITES)
0:             testTreeRequestWrite();
0:         
0:         DataInputStream in = getInput("service.TreeRequest.bin");
0:         assert AntiEntropyService.TreeRequestVerbHandler.SERIALIZER.deserialize(in) != null;
0:         assert Message.serializer().deserialize(in) != null;
0:         in.close();
1:     }
0:     
0:     private void testTreeResponseWrite() throws IOException
1:     {
0:         AntiEntropyService.Validator v0 = new AntiEntropyService.Validator(Statics.req);
0:         IPartitioner part = new RandomPartitioner();
0:         MerkleTree mt = new MerkleTree(part, MerkleTree.RECOMMENDED_DEPTH, Integer.MAX_VALUE);
0:         List<Token> tokens = new ArrayList<Token>();
1:         for (int i = 0; i < 10; i++)
1:         {
0:             Token t = part.getRandomToken();
0:             tokens.add(t);
0:             mt.split(t);
1:         }
0:         AntiEntropyService.Validator v1 = new AntiEntropyService.Validator(Statics.req, mt);
0:         DataOutputStream out = getOutput("service.TreeResponse.bin");
0:         AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.serialize(v0, out);
0:         AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.serialize(v1, out);
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getLocalAddress(), v0), out);
0:         Message.serializer().serialize(AntiEntropyService.TreeResponseVerbHandler.makeVerb(FBUtilities.getLocalAddress(), v1), out);
0:         out.close();
1:     }
0:     
1:     @Test
0:     public void testTreeResponseRead() throws IOException
1:     {
1:         if (EXECUTE_WRITES)
0:             testTreeResponseWrite();
0:         
0:         DataInputStream in = getInput("service.TreeResponse.bin");
0:         assert AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.deserialize(in) != null;
0:         assert AntiEntropyService.TreeResponseVerbHandler.SERIALIZER.deserialize(in) != null;
0:         assert Message.serializer().deserialize(in) != null;
0:         assert Message.serializer().deserialize(in) != null;
0:         in.close();
1:     }
0:     
0:     private static class Statics
1:     {
0:         private static final AntiEntropyService.CFPair pair = new AntiEntropyService.CFPair("Keyspace1", "Standard1");
0:         private static final AntiEntropyService.TreeRequest req = new AntiEntropyService.TreeRequest("sessionId", FBUtilities.getLocalAddress(), pair);
1:     }
1: }
author:Eric Evans
-------------------------------------------------------------------------------
commit:407a76f
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  * 
1:  */
0: 
============================================================================