1:d224c2b: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
4:eeb164e:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:b24dc53:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
1:209d067:  */
1:066ef58: package org.apache.cassandra.db;
1:0a08525: 
1:2fdc5ef: import java.lang.management.ManagementFactory;
1:96d41f0: import java.util.List;
1:d224c2b: 
1:be22ee4: import javax.management.MBeanServer;
1:be22ee4: import javax.management.ObjectName;
1:d224c2b: 
1:96d41f0: import org.apache.cassandra.hints.HintsService;
1:d224c2b: 
1:209d067: /**
1:96d41f0:  * A proxy class that implement the deprecated legacy HintedHandoffManagerMBean interface.
1:8ea2d2a:  *
1:96d41f0:  * TODO: remove in 4.0.
1:d224c2b:  */
1:96d41f0: @SuppressWarnings("deprecation")
1:96d41f0: @Deprecated
1:96d41f0: public final class HintedHandOffManager implements HintedHandOffManagerMBean
1:d224c2b: {
1:a2e2c03:     public static final HintedHandOffManager instance = new HintedHandOffManager();
1:98bcf40: 
1:96d41f0:     public static final String MBEAN_NAME = "org.apache.cassandra.db:type=HintedHandoffManager";
1:98bcf40: 
1:96d41f0:     private HintedHandOffManager()
1:d224c2b:     {
1:d224c2b:     }
1:0a08525: 
1:96d41f0:     public void registerMBean()
1:d224c2b:     {
1:2fdc5ef:         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
1:98bcf40:         try
1:98bcf40:         {
1:9ccaaad:             mbs.registerMBean(this, new ObjectName(MBEAN_NAME));
1:98bcf40:         }
1:ab5372f:         catch (Exception e)
1:98bcf40:         {
1:98bcf40:             throw new RuntimeException(e);
1:98bcf40:         }
1:d224c2b:     }
1:98bcf40: 
1:96d41f0:     public void deleteHintsForEndpoint(String host)
1:d224c2b:     {
1:96d41f0:         HintsService.instance.deleteAllHintsForEndpoint(host);
1:d224c2b:     }
1:1e49aba: 
1:96d41f0:     public void truncateAllHints()
1:d224c2b:     {
1:96d41f0:         HintsService.instance.deleteAllHints();
1:d224c2b:     }
1:1e49aba: 
1:96d41f0:     // TODO
1:2fdc5ef:     public List<String> listEndpointsPendingHints()
1:d224c2b:     {
1:96d41f0:         throw new UnsupportedOperationException();
1:96d41f0:     }
1:0a08525: 
1:96d41f0:     // TODO
1:96d41f0:     public void scheduleHintDelivery(String host)
1:96d41f0:     {
1:96d41f0:         throw new UnsupportedOperationException();
1:96d41f0:     }
1:d224c2b: 
1:96d41f0:     public void pauseHintsDelivery(boolean doPause)
1:96d41f0:     {
1:96d41f0:         if (doPause)
1:96d41f0:             HintsService.instance.pauseDispatch();
1:96d41f0:         else
1:96d41f0:             HintsService.instance.resumeDispatch();
1:d224c2b:     }
2:d224c2b: }
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:96d41f0
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.cassandra.hints.HintsService;
1:  * A proxy class that implement the deprecated legacy HintedHandoffManagerMBean interface.
1:  * TODO: remove in 4.0.
1: @SuppressWarnings("deprecation")
1: @Deprecated
1: public final class HintedHandOffManager implements HintedHandOffManagerMBean
1:     public static final String MBEAN_NAME = "org.apache.cassandra.db:type=HintedHandoffManager";
1:     private HintedHandOffManager()
1:     public void registerMBean()
/////////////////////////////////////////////////////////////////////////
1:     public void deleteHintsForEndpoint(String host)
1:         HintsService.instance.deleteAllHintsForEndpoint(host);
1:     public void truncateAllHints()
1:         HintsService.instance.deleteAllHints();
1:     // TODO
1:         throw new UnsupportedOperationException();
1:     }
1:     // TODO
1:     public void scheduleHintDelivery(String host)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1:     public void pauseHintsDelivery(boolean doPause)
1:     {
1:         if (doPause)
1:             HintsService.instance.pauseDispatch();
1:         else
1:             HintsService.instance.resumeDispatch();
commit:b31845c
/////////////////////////////////////////////////////////////////////////
0:             ttl = Math.min(ttl, upd.metadata().params.gcGraceSeconds);
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer key = UUIDType.instance.decompose(targetId);
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, tokenBytes, BTreeBackedRow.singleCellRow(clustering, cell));
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer key = ByteBuffer.wrap(UUIDGen.decompose(hostId));
0:         final Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(SystemKeyspace.Hints, key, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:              RowIterator iter = UnfilteredRowIterators.filter(SinglePartitionReadCommand.fullPartitionRead(SystemKeyspace.Hints, nowInSec, hostIdBytes).queryMemtableAndDisk(hintStore, op), nowInSec))
/////////////////////////////////////////////////////////////////////////
0:                                                         DataRange.allData(hintStore.metadata.partitioner));
/////////////////////////////////////////////////////////////////////////
0:         List<String> result = new ArrayList<>();
1: 
0:         try (ReadOrderGroup orderGroup = cmd.startOrderGroup();
0:              UnfilteredPartitionIterator iter = cmd.executeLocally(orderGroup))
/////////////////////////////////////////////////////////////////////////
0:                         result.add(UUIDType.instance.compose(partition.partitionKey().getKey()).toString());
1: 
commit:4a88249
commit:6f42afa
commit:351e35b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.JMXEnabledScheduledThreadPoolExecutor;
0: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
0:     private final JMXEnabledScheduledThreadPoolExecutor executor =
0:         new JMXEnabledScheduledThreadPoolExecutor(
0:             DatabaseDescriptor.getMaxHintsThread(),
0:             new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY),
0:             "internal");
/////////////////////////////////////////////////////////////////////////
0:         executor.scheduleWithFixedDelay(runnable, 10, 10, TimeUnit.MINUTES);
/////////////////////////////////////////////////////////////////////////
0:         executor.submit(runnable);
/////////////////////////////////////////////////////////////////////////
0:         executor.submit(runnable).get();
commit:3e9d345
/////////////////////////////////////////////////////////////////////////
0:     private final ColumnFamilyStore hintStore = Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.HINTS);
/////////////////////////////////////////////////////////////////////////
0:         CellName name = SystemKeyspace.Hints.comparator.makeCellName(hintId, MessagingService.current_version);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(SystemKeyspace.NAME, SystemKeyspace.HINTS));
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.HINTS, columnName, timestamp);
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.HINTS, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                     Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.HINTS).truncateBlocking();
/////////////////////////////////////////////////////////////////////////
0:                                                             SystemKeyspace.HINTS,
/////////////////////////////////////////////////////////////////////////
0:                                                           SystemKeyspace.HINTS,
commit:8badc28
commit:611d1ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final ColumnFamilyStore hintStore = Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.HINTS_TABLE);
/////////////////////////////////////////////////////////////////////////
0:         CellName name = SystemKeyspace.HintsTable.comparator.makeCellName(hintId, MessagingService.current_version);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(SystemKeyspace.NAME, SystemKeyspace.HINTS_TABLE));
0:         return new Mutation(SystemKeyspace.NAME, UUIDType.instance.decompose(targetId), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation mutation = new Mutation(SystemKeyspace.NAME, tokenBytes);
0:         mutation.delete(SystemKeyspace.HINTS_TABLE, columnName, timestamp);
/////////////////////////////////////////////////////////////////////////
0:         final Mutation mutation = new Mutation(SystemKeyspace.NAME, hostIdBytes);
0:         mutation.delete(SystemKeyspace.HINTS_TABLE, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                     Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.HINTS_TABLE).truncateBlocking();
/////////////////////////////////////////////////////////////////////////
0:                                                             SystemKeyspace.HINTS_TABLE,
/////////////////////////////////////////////////////////////////////////
0:             RangeSliceCommand cmd = new RangeSliceCommand(SystemKeyspace.NAME,
0:                                                           SystemKeyspace.HINTS_TABLE,
commit:96f40e6
commit:2966b61
commit:98bcf40
/////////////////////////////////////////////////////////////////////////
0:                     hintStore.forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
0:     protected void compact()
0:         ArrayList<Descriptor> descriptors = new ArrayList<>();
1: 
1:         try
1:         {
0:             CompactionManager.instance.submitUserDefined(hintStore, descriptors, (int) (System.currentTimeMillis() / 1000)).get();
1:         }
0:         catch (InterruptedException | ExecutionException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:      * 3. Delete the column if the write was successful
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Flush all the tombstones to disk
0:         hintStore.forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("Started scheduleAllDeliveries");
1: 
0:         // Force a major compaction to get rid of the tombstones and expired hints. Do it once, before we schedule any
0:         // individual replay, to avoid N - 1 redundant individual compactions (when N is the number of nodes with hints
0:         // to deliver to).
0:         compact();
/////////////////////////////////////////////////////////////////////////
0:                 scheduleHintDelivery(target, false);
0:         logger.debug("Finished scheduleAllDeliveries");
/////////////////////////////////////////////////////////////////////////
0:     public void scheduleHintDelivery(final InetAddress to, final boolean precompact)
/////////////////////////////////////////////////////////////////////////
0:                     // If it's an individual node hint replay (triggered by Gossip or via JMX), and not the global scheduled replay
0:                     // (every 10 minutes), force a major compaction to get rid of the tombstones and expired hints.
0:                     if (precompact)
0:                         compact();
1: 
/////////////////////////////////////////////////////////////////////////
0:         scheduleHintDelivery(InetAddress.getByName(to), true);
commit:029cd40
commit:1e77219
commit:1e49aba
/////////////////////////////////////////////////////////////////////////
0:     // read less columns (mutations) per page if they are very large
0:         if (meanColumnCount <= 0)
1: 
0:         int averageColumnSize = (int) (hintStore.getMeanRowSize() / meanColumnCount);
0:         if (averageColumnSize <= 0)
0:             return PAGE_SIZE;
1: 
0:         // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
0:         return Math.max(2, Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize));
commit:4485e6d
/////////////////////////////////////////////////////////////////////////
0:                 if (!hint.isLive())
commit:5045d3e
commit:3a73e39
commit:2890cc5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 rateLimiter.acquire((int) RowMutation.serializer.serializedSize(rm, MessagingService.current_version));
/////////////////////////////////////////////////////////////////////////
0:                 WriteResponseHandler responseHandler = new WriteResponseHandler(endpoint, WriteType.SIMPLE, callback);
0:                 MessagingService.instance().sendUnhintableMutation(rm, endpoint, responseHandler);
commit:66af6fe
commit:384de4b
commit:8709706
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 for (UUID cfId : rm.getColumnFamilyIds())
0:                     if (hint.maxTimestamp() <= SystemTable.getTruncatedAt(cfId))
0:                         logger.debug("Skipping delivery of hint for truncated columnfamily {}", cfId);
commit:8a2a0c3
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.name(), hint.timestamp());
/////////////////////////////////////////////////////////////////////////
0:                     if (hint.timestamp() < truncatedAt)
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.name(), hint.timestamp());
/////////////////////////////////////////////////////////////////////////
0:                         deleteHint(hostIdBytes, hint.name(), hint.timestamp());
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:     public Mutation hintFor(Mutation mutation, int ttl, UUID targetId)
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer value = ByteBuffer.wrap(FBUtilities.serialize(mutation, Mutation.serializer, MessagingService.current_version));
0:         return new Mutation(Keyspace.SYSTEM_KS, UUIDType.instance.decompose(targetId), cf);
0:      * determine the TTL for the hint Mutation
0:     public static int calculateHintTTL(Mutation mutation)
/////////////////////////////////////////////////////////////////////////
0:         Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, tokenBytes);
0:         mutation.delete(SystemKeyspace.HINTS_CF, columnName, timestamp);
0:         mutation.applyUnsafe(); // don't bother with commitlog since we're going to flush as soon as we're done with delivery
/////////////////////////////////////////////////////////////////////////
0:         final Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, hostIdBytes);
0:         mutation.delete(SystemKeyspace.HINTS_CF, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                     mutation.apply();
/////////////////////////////////////////////////////////////////////////
0:                 Mutation mutation;
0:                     mutation = Mutation.serializer.deserialize(in, version);
/////////////////////////////////////////////////////////////////////////
0:                 for (UUID cfId : ImmutableSet.copyOf((mutation.getColumnFamilyIds())))
0:                         ColumnFamilyStore cfs = Keyspace.open(mutation.getKeyspaceName()).getColumnFamilyStore(cfId);
/////////////////////////////////////////////////////////////////////////
0:                         mutation = mutation.without(cfId);
0:                 if (mutation.isEmpty())
0:                 MessageOut<Mutation> message = mutation.createMessage();
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:     private final ColumnFamilyStore hintStore = Keyspace.open(Keyspace.SYSTEM_KS).getColumnFamilyStore(SystemKeyspace.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(Keyspace.SYSTEM_KS, SystemKeyspace.HINTS_CF));
0:         return new RowMutation(Keyspace.SYSTEM_KS, UUIDType.instance.decompose(targetId), cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Keyspace.SYSTEM_KS, tokenBytes);
0:         rm.delete(SystemKeyspace.HINTS_CF, columnName, timestamp);
/////////////////////////////////////////////////////////////////////////
0:         final RowMutation rm = new RowMutation(Keyspace.SYSTEM_KS, hostIdBytes);
0:         rm.delete(SystemKeyspace.HINTS_CF, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         // usually we use DD.getDefsVersion, which checks the local schema uuid as stored in the system keyspace.
/////////////////////////////////////////////////////////////////////////
0:                                                             SystemKeyspace.HINTS_CF,
/////////////////////////////////////////////////////////////////////////
0:                         ColumnFamilyStore cfs = Keyspace.open(rm.getKeyspaceName()).getColumnFamilyStore(cfId);
/////////////////////////////////////////////////////////////////////////
0:             RangeSliceCommand cmd = new RangeSliceCommand(Keyspace.SYSTEM_KS,
0:                                                           SystemKeyspace.HINTS_CF,
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:             long now = System.currentTimeMillis();
0:                                                             pageSize,
0:                                                             now);
0:             ColumnFamily hintsPage = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), (int) (now / 1000));
/////////////////////////////////////////////////////////////////////////
0:                 if (!hint.isLive(System.currentTimeMillis()))
/////////////////////////////////////////////////////////////////////////
0:         List<Row> rows = hintStore.getRangeSlice(range, null, filter, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:             RangeSliceCommand cmd = new RangeSliceCommand(Table.SYSTEM_KS,
0:                                                           SystemTable.HINTS_CF,
0:                                                           System.currentTimeMillis(),
0:                                                           predicate,
0:                                                           range,
0:                                                           null,
0:                                                           LARGE_NUMBER);
0:             return StorageProxy.getRangeSlice(cmd, ConsistencyLevel.ONE);
commit:2ee9030
commit:076a0e4
commit:d224c2b
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.WriteTimeoutException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                                                                  new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY),
0:                                                                                  "internal");
1: 
0:     private final ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_KS).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHint(ByteBuffer tokenBytes, ByteBuffer columnName, long timestamp)
/////////////////////////////////////////////////////////////////////////
0:             logger.warn("Unable to find {}, not a hostname or ipaddr of a node", ipOrHostname);
/////////////////////////////////////////////////////////////////////////
0:                     logger.info("Deleting any stored hints for {}", endpoint);
0:                     logger.warn("Could not delete hints for {}: {}", endpoint, e);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void deliverHintsToEndpoint(InetAddress endpoint)
/////////////////////////////////////////////////////////////////////////
0:         doDeliverHintsToEndpoint(endpoint);
1:     }
1:     /*
0:      * 1. Get the key of the endpoint we need to handoff
0:      * 2. For each column, deserialize the mutation and send it to the endpoint
0:      * 3. Delete the subcolumn if the write was successful
0:      * 4. Force a flush
0:      * 5. Do major compaction to clean up all deletes etc.
1:      */
0:     private void doDeliverHintsToEndpoint(InetAddress endpoint)
1:     {
/////////////////////////////////////////////////////////////////////////
0:         int pageSize = calculatePageSize();
0:         logger.debug("Using pageSize of {}", pageSize);
0:         delivery:
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey,
0:                                                             new QueryPath(SystemTable.HINTS_CF),
0:                                                             startColumn,
0:                                                             ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                             false,
0:                                                             pageSize);
0:             ColumnFamily hintsPage = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter),
0:                                                                      (int) (System.currentTimeMillis() / 1000));
1: 
0:                 break;
0:             // check if node is still alive and we should continue delivery process
0:             if (!FailureDetector.instance.isAlive(endpoint))
1:             {
0:                 logger.info("Endpoint {} died during hint delivery; aborting ({} delivered)", endpoint, rowsReplayed);
0:                 return;
0:             List<WriteResponseHandler> responseHandlers = Lists.newArrayList();
1: 
0:                 // check if hints delivery has been paused during the process
0:                 if (hintedHandOffPaused)
1:                 {
0:                     logger.debug("Hints delivery process is paused, aborting");
0:                     break delivery;
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 catch (IOException e)
1:                 {
0:                     throw new AssertionError(e);
1:                 }
0:                 Runnable callback = new Runnable()
0:                     public void run()
0:                 WriteResponseHandler responseHandler = new WriteResponseHandler(endpoint, WriteType.UNLOGGED_BATCH, callback);
0:                 responseHandlers.add(responseHandler);
0:             for (WriteResponseHandler handler : responseHandlers)
0:                 try
1:                 {
0:                     handler.get();
1:                 }
0:                 catch (WriteTimeoutException e)
1:                 {
0:                     logger.info("Timed out replaying hints to {}; aborting ({} delivered)", endpoint, rowsReplayed);
0:                     return;
1:                 }
0:         logger.info("Finished hinted handoff of {} rows to endpoint {}", rowsReplayed, endpoint);
0: 
/////////////////////////////////////////////////////////////////////////
1:     }
0:     private int calculatePageSize()
0:     {
0:         // read less columns (mutations) per page if they are very large
0:         if (hintStore.getMeanColumns() > 0)
0:             int averageColumnSize = (int) (hintStore.getMeanRowSize() / hintStore.getMeanColumns());
0:             // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
0:             return Math.max(2, Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize));
1:         }
0:         else
0:         {
0:             return PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (!queuedDeliveries.add(to))
0: 
0: 
0:         executor.execute(new Runnable()
0:             public void run()
0:                 try
0:                 {
0:                     deliverHintsToEndpoint(to);
0:                 }
0:                 finally
0:                 {
0:                     queuedDeliveries.remove(to);
0:                 }
0:         });
/////////////////////////////////////////////////////////////////////////
0:     public void pauseHintsDelivery(boolean b)
0:     {
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
0:         return new Mutation(PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, key, BTreeRow.singleCellRow(clustering, cell)));
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, tokenBytes, BTreeRow.singleCellRow(clustering, cell));
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:         return new Mutation(PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, key, BTreeBackedRow.singleCellRow(clustering, cell)));
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, dk, BTreeBackedRow.singleCellRow(clustering, cell));
commit:e5a76bd
/////////////////////////////////////////////////////////////////////////
0:         for (SSTable sstable : hintStore.getTracker().getUncompacting())
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:65c695c
commit:39c7869
commit:e8f2cb5
commit:c9587cd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
0: import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.StorageProxy;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.service.WriteResponseHandler;
/////////////////////////////////////////////////////////////////////////
0:     // To keep metrics consistent with earlier versions, where periodic tasks were run on a shared executor,
0:     // we run them on this executor and so keep counts separate from those for hint delivery tasks. See CASSANDRA-9129
0:     private final DebuggableScheduledThreadPoolExecutor executor =
0:         new DebuggableScheduledThreadPoolExecutor(1, new NamedThreadFactory("HintedHandoffManager", Thread.MIN_PRIORITY));
0: 
0:     // Non-scheduled executor to run the actual hint delivery tasks.
0:     // Per CASSANDRA-9129, this is where the values displayed in nodetool tpstats
0:     // and via the HintedHandoff mbean are obtained.
0:     private final ThreadPoolExecutor hintDeliveryExecutor =
0:         new JMXEnabledThreadPoolExecutor(
0:             Integer.MAX_VALUE,
0:             TimeUnit.SECONDS,
0:             new LinkedBlockingQueue<Runnable>(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         hintDeliveryExecutor.execute(new Runnable()
commit:4397c34
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.ScheduledExecutors;
/////////////////////////////////////////////////////////////////////////
0:         ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(runnable, 10, 10, TimeUnit.MINUTES);
/////////////////////////////////////////////////////////////////////////
0:         ScheduledExecutors.optionalTasks.submit(runnable);
/////////////////////////////////////////////////////////////////////////
0:         ScheduledExecutors.optionalTasks.submit(runnable).get();
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(UUIDType.instance.decompose(targetId));
0: 
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dk =  StorageService.getPartitioner().decorateKey(tokenBytes);
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, dk, BTreeBackedRow.singleCellRow(clustering, cell));
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dk =  StorageService.getPartitioner().decorateKey(ByteBuffer.wrap(UUIDGen.decompose(hostId)));
0:         final Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(SystemKeyspace.Hints, dk, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(hostIdBytes);
/////////////////////////////////////////////////////////////////////////
0:              RowIterator iter = UnfilteredRowIterators.filter(SinglePartitionReadCommand.fullPartitionRead(SystemKeyspace.Hints, nowInSec, epkey).queryMemtableAndDisk(hintStore, op), nowInSec))
/////////////////////////////////////////////////////////////////////////
0:                                                         DataRange.allData(StorageService.getPartitioner()));
/////////////////////////////////////////////////////////////////////////
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:         // Extract the keys as strings to be reported.
0:         LinkedList<String> result = new LinkedList<>();
0:         try (ReadOrderGroup orderGroup = cmd.startOrderGroup(); UnfilteredPartitionIterator iter = cmd.executeLocally(orderGroup))
/////////////////////////////////////////////////////////////////////////
0:                         result.addFirst(tokenFactory.toString(partition.partitionKey().getToken()));
commit:005835e
commit:1569bd9
/////////////////////////////////////////////////////////////////////////
0:         return Math.max(2, Math.min(PAGE_SIZE, 4 * 1024 * 1024 / averageColumnSize));
commit:65e09fa
commit:fe57142
commit:ab5372f
/////////////////////////////////////////////////////////////////////////
0:         boolean finished = false;
/////////////////////////////////////////////////////////////////////////
0:             {
0:                 logger.info("Finished hinted handoff of {} rows to endpoint {}", rowsReplayed, endpoint);
0:                 finished = true;
0:             }
0:                 break;
/////////////////////////////////////////////////////////////////////////
0:                     break delivery;
0:         if (finished || rowsReplayed.get() >= DatabaseDescriptor.getTombstoneDebugThreshold())
0:             try
0:             {
0:                 compact().get();
0:             }
1:             catch (Exception e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
commit:115cbb1
commit:69c9e03
commit:8cc28a1
/////////////////////////////////////////////////////////////////////////
0:         int meanColumnCount = hintStore.getMeanColumns();
0:         if (meanColumnCount > 0)
0:             int averageColumnSize = (int) (hintStore.getMeanRowSize() / meanColumnCount);
commit:06939dd
/////////////////////////////////////////////////////////////////////////
0:     public RowMutation hintFor(RowMutation mutation, int ttl, UUID targetId)
0:         metrics.incrCreatedHints(StorageService.instance.getTokenMetadata().getEndpointForHostId(targetId));
0: 
/////////////////////////////////////////////////////////////////////////
commit:f3b1a2c
commit:19d2782
/////////////////////////////////////////////////////////////////////////
0:         // max rate is scaled by the number of nodes in the cluster (CASSANDRA-5272).
0:         int throttleInKB = DatabaseDescriptor.getHintedHandoffThrottleInKB()
0:                            / (StorageService.instance.getTokenMetadata().getAllEndpoints().size() - 1);
commit:c4c9626
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.ImmutableSet;
/////////////////////////////////////////////////////////////////////////
0:                 Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
0:                 for (UUID cfId : ImmutableSet.copyOf((rm.getColumnFamilyIds())))
0:                 {
0:                     Long truncatedAt = truncationTimesCache.get(cfId);
0:                     if (truncatedAt == null)
0:                     {
0:                         ColumnFamilyStore cfs = Table.open(rm.getTable()).getColumnFamilyStore(cfId);
0:                         truncatedAt = cfs.getTruncationTime();
0:                         truncationTimesCache.put(cfId, truncatedAt);
0:                     }
0: 
0:                     if (hint.maxTimestamp() < truncatedAt)
0:                     {
0:                         logger.debug("Skipping delivery of hint for truncated columnfamily {}" + cfId);
0:                         rm = rm.without(cfId);
0:                     }
0:                 }
0: 
0:                 if (rm.isEmpty())
0:                 {
0:                     deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
0:                     continue;
0:                 }
0: 
commit:f620b34
commit:b706391
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.ImmutableSet;
/////////////////////////////////////////////////////////////////////////
0:                 Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
0:                 for (UUID cfId : ImmutableSet.copyOf((rm.getColumnFamilyIds())))
0:                 {
0:                     Long truncatedAt = truncationTimesCache.get(cfId);
0:                     if (truncatedAt == null)
0:                     {
0:                         ColumnFamilyStore cfs = Table.open(rm.getTable()).getColumnFamilyStore(cfId);
0:                         truncatedAt = cfs.getTruncationTime();
0:                         truncationTimesCache.put(cfId, truncatedAt);
0:                     }
0: 
0:                     if (hint.maxTimestamp() < truncatedAt)
0:                     {
0:                         logger.debug("Skipping delivery of hint for truncated columnfamily {}" + cfId);
0:                         rm = rm.without(cfId);
0:                     }
0:                 }
0: 
0:                 if (rm.isEmpty())
0:                 {
0:                     deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
0:                     continue;
0:                 }
0: 
commit:2effc40
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.util.concurrent.Uninterruptibles;
0: 
/////////////////////////////////////////////////////////////////////////
0:             Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:             Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
commit:aa76394
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.HINTS_CF));
/////////////////////////////////////////////////////////////////////////
0:             for (final Column hint : hintsPage)
commit:209d067
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Returns a mutation representing a Hint to be sent to <code>targetId</code>
0:      * as soon as it becomes available again.
1:      */
0:     public static RowMutation hintFor(RowMutation mutation, UUID targetId) throws IOException
0:     {
0:         UUID hintId = UUIDGen.getTimeUUID();
0: 
0:         // The hint TTL is set at the smallest GCGraceSeconds for any of the CFs in the RM;
0:         // this ensures that deletes aren't "undone" by delivery of an old hint
0:         int ttl = Integer.MAX_VALUE;
0:         for (ColumnFamily cf : mutation.getColumnFamilies())
0:             ttl = Math.min(ttl, cf.metadata().getGcGraceSeconds());
0: 
0:         // serialize the hint with id and version as a composite column name
0:         ByteBuffer name = comparator.decompose(hintId, MessagingService.current_version);
0:         ByteBuffer value = ByteBuffer.wrap(FBUtilities.serialize(mutation, RowMutation.serializer, MessagingService.current_version));
0:         ColumnFamily cf = ColumnFamily.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.HINTS_CF));
0:         cf.addColumn(name, value, System.currentTimeMillis(), ttl);
0: 
0:         return new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(targetId), cf);
0:     }
0: 
commit:a15500e
/////////////////////////////////////////////////////////////////////////
0:         IDiskAtomFilter filter = new NamesQueryFilter(ImmutableSortedSet.<ByteBuffer>of());
commit:4881221
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.IAsyncCallback;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final ByteBuffer hostIdBytes = ByteBuffer.wrap(UUIDGen.decompose(hostId));
0:         final AtomicInteger rowsReplayed = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
0:             {
0:                 if (ByteBufferUtil.EMPTY_BYTE_BUFFER.equals(startColumn))
0:                 {
0:                     // we've started from the beginning and could not find anything (only maybe tombstones)
0:                     break;
0:                 }
0:                 else
0:                 {
0:                     // restart query from the first column until we read an empty row;
0:                     // that will tell us everything was delivered successfully with no timeouts
0:                     startColumn = ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                     continue;
0:                 }
0:             }
0: 
0:             for (final IColumn hint : hintsPage.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
0:                     continue;
0:                 MessageOut<RowMutation> message = rm.createMessage();
0:                 rateLimiter.acquire(message.serializedSize(MessagingService.current_version));
0:                 WrappedRunnable callback = new WrappedRunnable()
0:                     public void runMayThrow() throws IOException
0:                         rowsReplayed.incrementAndGet();
0:                         deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
0:                 };
0:                 IAsyncCallback responseHandler = new WriteResponseHandler(endpoint, WriteType.UNLOGGED_BATCH, callback);
0:                 MessagingService.instance().sendRR(message, endpoint, responseHandler);
0:             }
0: 
0:             // check if node is still alive and we should continue delivery process
0:             if (!FailureDetector.instance.isAlive(endpoint))
0:             {
0:                 logger.debug("Endpoint {} died during hint delivery, aborting", endpoint);
0:                 return;
0:         if (rowsReplayed.get() > 0)
/////////////////////////////////////////////////////////////////////////
0: 
commit:fc32358
commit:0d12493
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.annotations.VisibleForTesting;
/////////////////////////////////////////////////////////////////////////
0:     @VisibleForTesting
0:     protected Future<?> compact() throws ExecutionException, InterruptedException
0:         return CompactionManager.instance.submitUserDefined(hintStore, descriptors, (int) (System.currentTimeMillis() / 1000));
commit:e752de9
/////////////////////////////////////////////////////////////////////////
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:         for (Row row : getHintsSlice(1))
0:             if (row.cf != null) //ignore removed rows
0:                 result.addFirst(tokenFactory.toString(row.key.token));
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:         for (Row row : getHintsSlice(Integer.MAX_VALUE))
0:             if (row.cf == null) // ignore removed rows
0:             int count = row.cf.getColumnCount();
0:                 result.put(tokenFactory.toString(row.key.token), count);
commit:c1724dd
commit:b03ae12
/////////////////////////////////////////////////////////////////////////
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:         for (Row row : getHintsSlice(1))
0:             if (row.cf != null) //ignore removed rows
0:                 result.addFirst(tokenFactory.toString(row.key.token));
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:         for (Row row : getHintsSlice(Integer.MAX_VALUE))
0:             if (row.cf == null) // ignore removed rows
0:             int count = row.cf.getColumnCount();
0:                 result.put(tokenFactory.toString(row.key.token), count);
commit:84c0657
/////////////////////////////////////////////////////////////////////////
0:         AbstractWriteResponseHandler responseHandler = WriteResponseHandler.create(endpoint);
commit:5c94432
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Table.SYSTEM_KS, tokenBytes);
/////////////////////////////////////////////////////////////////////////
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_KS, hostIdBytes);
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_KS).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_KS).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_KS).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:             rows = StorageProxy.getRangeSlice(new RangeSliceCommand(Table.SYSTEM_KS, parent, predicate, range, null, LARGE_NUMBER), ConsistencyLevel.ONE);
commit:70754af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.Token;
commit:f5c19e8
commit:de03959
commit:4764a37
/////////////////////////////////////////////////////////////////////////
0:         Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();
0:             if (r.cf == null) // ignore removed rows
0:                 continue;
0: 
0:             int count = r.cf.getColumnCount();
0:             if (count > 0)
0:                 result.put(tokenFactory.toString(r.key.token), count);
commit:c9a13c3
/////////////////////////////////////////////////////////////////////////
0:     private static void sendMutation(InetAddress endpoint, MessageOut<?> message) throws TimedOutException
/////////////////////////////////////////////////////////////////////////
0:                 catch (TimedOutException e)
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.Int32Type;
0: import org.apache.cassandra.db.marshal.UUIDType;
/////////////////////////////////////////////////////////////////////////
0:  * The hint schema looks like this:
0:  * CREATE TABLE hints (
0:  *   target_id uuid,
0:  *   hint_id timeuuid,
0:  *   message_version int,
0:  *   mutation blob,
0:  *   PRIMARY KEY (target_id, hint_id, message_version)
0:  * ) WITH COMPACT STORAGE;
1:  *
0:  * Thus, for each node in the cluster we treat its uuid as the partition key; each hint is a logical row
0:  * (physical composite column) containing the mutation to replay and associated metadata.
/////////////////////////////////////////////////////////////////////////
0:     static final CompositeType comparator = CompositeType.getInstance(Arrays.<AbstractType<?>>asList(UUIDType.instance, Int32Type.instance));
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHint(ByteBuffer tokenBytes, ByteBuffer columnName, long timestamp) throws IOException
0:         rm.delete(new QueryPath(SystemTable.HINTS_CF, null, columnName), timestamp);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath(SystemTable.HINTS_CF), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(SystemTable.HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
/////////////////////////////////////////////////////////////////////////
0:                 ByteBuffer[] components = comparator.split(hint.name());
0:                 int version = Int32Type.instance.compose(components[1]);
0:                 DataInputStream in = new DataInputStream(ByteBufferUtil.inputStream(hint.value()));
0:                     rm = RowMutation.serializer.deserialize(in, version);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(SystemTable.HINTS_CF);
/////////////////////////////////////////////////////////////////////////
0:         ColumnParent parent = new ColumnParent(SystemTable.HINTS_CF);
commit:aa26705
commit:33f1bac
/////////////////////////////////////////////////////////////////////////
0:                 // Skip tombstones:
0:                 // if we iterate quickly enough, it's possible that we could request a new page in the same millisecond
0:                 // in which the local deletion timestamp was generated on the last column in the old page, in which
0:                 // case the hint will have no columns (since it's deleted) but will still be included in the resultset
0:                 // since (even with gcgs=0) it's still a "relevant" tombstone.
0:                 if (!hint.isLive())
0:                     continue;
0: 
/////////////////////////////////////////////////////////////////////////
commit:b993eec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.NamedThreadFactory;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.MessageOut;
0: import org.apache.cassandra.utils.Throttle;
/////////////////////////////////////////////////////////////////////////
0:     private final ThreadPoolExecutor executor = new JMXEnabledThreadPoolExecutor(DatabaseDescriptor.getMaxHintsThread(),
0:                                                                                  Integer.MAX_VALUE,
0:                                                                                  TimeUnit.SECONDS,
0:                                                                                  new LinkedBlockingQueue<Runnable>(),
0:                                                                                  new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY), "HintedHandoff");
/////////////////////////////////////////////////////////////////////////
0:     private static void sendMutation(InetAddress endpoint, MessageOut<?> message) throws TimeoutException
0:         MessagingService.instance().sendRR(message, endpoint, responseHandler);
/////////////////////////////////////////////////////////////////////////
0:         long hintSizes = 0;
0:         Throttle hintThrottle = new Throttle("HintThrottle", new Throttle.ThroughputFunction()
0:         {
0:             public int targetThroughput()
0:             {
0:                 if (DatabaseDescriptor.getHintedHandoffThrottleInKB() < 1)
0:                     // throttling disabled
0:                     return 0;
0:                 // total throughput
0:                 int totalBytesPerMS = (DatabaseDescriptor.getHintedHandoffThrottleInKB() * 1024) / 8 / 1000;
0:                 // per hint throughput (target bytes per MS)
0:                 return totalBytesPerMS / Math.max(1, executor.getActiveCount());
0:             }
0:         });
0: 
/////////////////////////////////////////////////////////////////////////
0:                         MessageOut<RowMutation> message = rm.createMessage();
0:                         sendMutation(endpoint, message);
0:                         // throttle for the messages sent.
0:                         hintSizes += message.serializedSize(MessagingService.current_version);
0:                         hintThrottle.throttle(hintSizes);
/////////////////////////////////////////////////////////////////////////
0:         // We should not deliver hints to the same host in 2 different threads
0:         if (queuedDeliveries.contains(to) || !queuedDeliveries.add(to))
0:         logger.debug("Scheduling delivery of Hints to {}", to);
commit:7602145
/////////////////////////////////////////////////////////////////////////
0:                 // Skip tombstones:
0:                 // if we iterate quickly enough, it's possible that we could request a new page in the same millisecond
0:                 // in which the local deletion timestamp was generated on the last column in the old page, in which
0:                 // case the hint will have no columns (since it's deleted) but will still be included in the resultset
0:                 // since (even with gcgs=0) it's still a "relevant" tombstone.
0:                 if (!hint.isLive())
0:                     continue;
0: 
commit:2820f05
/////////////////////////////////////////////////////////////////////////
0:                 // Skip tombstones:
0:                 // if we iterate quickly enough, it's possible that we could request a new page in the same millisecond
0:                 // in which the local deletion timestamp was generated on the last column in the old page, in which
0:                 // case the hint will have no columns (since it's deleted) but will still be included in the resultset
0:                 // since (even with gcgs=0) it's still a "relevant" tombstone.
0:                 if (!hint.isLive())
0:                     continue;
0: 
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.Descriptor;
0: import org.apache.cassandra.io.sstable.SSTable;
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance().sendRR(mutation.createMessage(), endpoint, responseHandler);
commit:f080511
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Endpoint {} died before hint delivery, aborting", endpoint);
commit:5613f8f
commit:7e4ef1c
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(tokenBytes);
commit:24a7080
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation rm;
0:                 try
0:                 {
0:                     rm = RowMutation.serializer().deserialize(in, ByteBufferUtil.toInt(versionColumn.value()));
0:                 }
0:                 catch (UnknownColumnFamilyException e)
0:                 {
0:                     logger_.debug("Skipping delivery of hint for deleted columnfamily", e);
0:                     rm = null;
0:                 }
0:                     if (rm != null)
0:                     {
0:                         sendMutation(endpoint, rm);
0:                         rowsReplayed++;
0:                     }
commit:17ee459
commit:bd9e402
commit:a91b258
commit:a043998
/////////////////////////////////////////////////////////////////////////
0:             waitForSchemaAgreement(endpoint);
commit:7587e73
commit:5cc12f3
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.*;
0: import org.apache.cassandra.io.sstable.Descriptor;
0: import org.apache.cassandra.io.sstable.SSTable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     compact();
/////////////////////////////////////////////////////////////////////////
0:     private Future<?> compact() throws ExecutionException, InterruptedException
0:     {
0:         final ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         hintStore.forceBlockingFlush();
0:         ArrayList<Descriptor> descriptors = new ArrayList<Descriptor>();
0:         for (SSTable sstable : hintStore.getSSTables())
0:             descriptors.add(sstable.descriptor);
0:         return CompactionManager.instance.submitUserDefined(hintStore, descriptors, Integer.MAX_VALUE);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 compact().get();
commit:0d09395
/////////////////////////////////////////////////////////////////////////
0:     private int waitForSchemaAgreement(InetAddress endpoint) throws TimeoutException
0:         while (gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA) == null)
0:         {
0:             try
0:             {
0:                 Thread.sleep(1000);
0:             }
0:             catch (InterruptedException e)
0:             {
0:                 throw new AssertionError(e);
0:             }
0:                 throw new TimeoutException("Didin't receive gossiped schema from " + endpoint + " in " + 2 * StorageService.RING_DELAY + "ms");
/////////////////////////////////////////////////////////////////////////
0:             try
0:             {
0:                 Thread.sleep(1000);
0:             }
0:             catch (InterruptedException e)
0:             {
0:                 throw new AssertionError(e);
0:             }
0:                 throw new TimeoutException("Could not reach schema agreement with " + endpoint + " in " + 2 * StorageService.RING_DELAY + "ms");
0:     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, InterruptedException
0:             deliverHintsToEndpointInternal(endpoint);
0:     }
0: 
0:     private void deliverHintsToEndpointInternal(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, InterruptedException
0:     {
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         if (hintStore.isEmpty())
0:             return; // nothing to do, don't confuse users by logging a no-op handoff
0: 
0:         logger_.debug("Checking remote({}) schema before delivering hints", endpoint);
0:         int waited;
0:         try
0:         {
0:             waited = waitForSchemaAgreement(endpoint);
0:         }
0:         catch (TimeoutException e)
0:         {
0:             return;
0:         }
0:         // sleep a random amount to stagger handoff delivery from different replicas.
0:         // (if we had to wait, then gossiper randomness took care of that for us already.)
0:         if (waited == 0)
0:         {
0:             // use a 'rounded' sleep interval because of a strange bug with windows: CASSANDRA-3375
0:             int sleep = FBUtilities.threadLocalRandom().nextInt(2000) * 30;
0:             logger_.debug("Sleeping {}ms to stagger hint delivery", sleep);
0:             Thread.sleep(sleep);
0:         }
0: 
0:         if (!FailureDetector.instance.isAlive(endpoint))
0:         {
0:             logger_.info("Endpoint {} died before hint delivery, aborting", endpoint);
0:             return;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         logger_.info(String.format("Finished hinted handoff of %s rows to endpoint %s", rowsReplayed, endpoint));
commit:190fb8c
/////////////////////////////////////////////////////////////////////////
0:     private static final int PAGE_SIZE = 128;
/////////////////////////////////////////////////////////////////////////
0:         int pageSize = PAGE_SIZE;
0:         // read less columns (mutations) per page if they are very large
0:         if (hintStore.getMeanColumns() > 0)
0:         {
0:             int averageColumnSize = (int) (hintStore.getMeanRowSize() / hintStore.getMeanColumns());
0:             pageSize = Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize);
0:             pageSize = Math.max(2, pageSize); // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
0:             logger_.debug("average hinted-row column size is {}; using pageSize of {}", averageColumnSize, pageSize);
0:         }
0: 
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
commit:7043e29
/////////////////////////////////////////////////////////////////////////
0:     private static final int PAGE_SIZE = 128;
/////////////////////////////////////////////////////////////////////////
0:         int pageSize = PAGE_SIZE;
0:         // read less columns (mutations) per page if they are very large
0:         if (hintStore.getMeanColumns() > 0)
0:         {
0:             int averageColumnSize = (int) (hintStore.getMeanRowSize() / hintStore.getMeanColumns());
0:             pageSize = Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize);
0:             pageSize = Math.max(2, pageSize); // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
0:             logger_.debug("average hinted-row column size is {}; using pageSize of {}", averageColumnSize, pageSize);
0:         }
0: 
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
commit:6c28169
commit:23e1aa4
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
0: import com.google.common.collect.ImmutableSortedSet;
0: import org.apache.cassandra.db.filter.IFilter;
0: import org.apache.cassandra.db.filter.NamesQueryFilter;
/////////////////////////////////////////////////////////////////////////
0:  *  <dest token>: {           // key
/////////////////////////////////////////////////////////////////////////
0:     public void start()
/////////////////////////////////////////////////////////////////////////
0: 
0:         Runnable runnable = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 scheduleAllDeliveries();
0:             }
0:         };
0:         StorageService.optionalTasks.scheduleWithFixedDelay(runnable, 10, 10, TimeUnit.MINUTES);
0:     private static void sendMutation(InetAddress endpoint, RowMutation mutation) throws TimeoutException
0:         responseHandler.get();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintsPage = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:             if (pagingFinished(hintsPage, startColumn))
0:             for (IColumn hint : hintsPage.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:                 try
0:                     sendMutation(endpoint, rm);
0:                 catch (TimeoutException e)
0:                     logger_.info(String.format("Timed out replaying hints to %s; aborting further deliveries", endpoint));
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Attempt delivery to any node for which we have hints.  Necessary since we can generate hints even for
0:      * nodes which are never officially down/failed.
0:      */
0:     private void scheduleAllDeliveries()
0:     {
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Started scheduleAllDeliveries");
0: 
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         IPartitioner p = StorageService.getPartitioner();
0:         Range range = new Range(p.getMinimumToken(), p.getMinimumToken(), p);
0:         IFilter filter = new NamesQueryFilter(ImmutableSortedSet.<ByteBuffer>of());
0:         List<Row> rows = hintStore.getRangeSlice(null, range, Integer.MAX_VALUE, filter);
0:         for (Row row : rows)
0:         {
0:             Token<?> token = StorageService.getPartitioner().getTokenFactory().fromByteArray(row.key.key);
0:             InetAddress target = StorageService.instance.getTokenMetadata().getEndpoint(token);
0:             scheduleHintDelivery(target);
0:         }
0: 
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Finished scheduleAllDeliveries");
0:     }
0: 
0:     public void scheduleHintDelivery(final InetAddress to)
/////////////////////////////////////////////////////////////////////////
0:     public void scheduleHintDelivery(String to) throws UnknownHostException
0:         scheduleHintDelivery(InetAddress.getByName(to));
commit:d5723b0
/////////////////////////////////////////////////////////////////////////
0:         if (hintStore.isEmpty())
/////////////////////////////////////////////////////////////////////////
0:                         deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
commit:16e1875
/////////////////////////////////////////////////////////////////////////
0:     // in 0.8, subcolumns were KS-CF bytestrings, and the data was stored in the "normal" storage there.
0:     // (so replay always consisted of sending an entire row,
0:     // no matter how little was part of the mutation that created the hint.)
0:     private static final String SEPARATOR_08 = "-";
0: 
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe(); // don't bother with commitlog since we're going to flush as soon as we're done with delivery
/////////////////////////////////////////////////////////////////////////
0:             page:
0:                 for (IColumn subColumn : hint.getSubColumns())
0:                 {
0:                     // both 0.8 and 1.0 column names are UTF8 strings, so this check is safe
0:                     if (ByteBufferUtil.string(subColumn.name()).contains(SEPARATOR_08))
0:                     {
0:                         logger_.debug("0.8-style hint found.  This should have been taken care of by purgeIncompatibleHints");
0:                         deleteHint(tokenBytes, hint.name(), subColumn.timestamp());
0:                         continue page;
0:                     }
0:                 }
commit:78446d6
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_ = new JMXEnabledThreadPoolExecutor("HintedHandoff", Thread.MIN_PRIORITY);
commit:d23655b
/////////////////////////////////////////////////////////////////////////
0:         StorageService.optionalTasks.execute(runnable);
commit:62cc775
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHint(ByteBuffer tokenBytes, ByteBuffer hintId, long timestamp) throws IOException
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tokenBytes);
/////////////////////////////////////////////////////////////////////////
0:         if (!StorageService.instance.getTokenMetadata().isMember(endpoint))
0:             return;
0:         Token<?> token = StorageService.instance.getTokenMetadata().getToken(endpoint);
0:         ByteBuffer tokenBytes = StorageService.getPartitioner().getTokenFactory().toByteArray(token);
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tokenBytes);
/////////////////////////////////////////////////////////////////////////
0:                     logger_.info("Deleting any stored hints for " + endpoint);
0:                     logger_.warn("Could not delete hints for " + endpoint + ": " + e);
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Checking remote({}) schema before delivering hints", endpoint);
/////////////////////////////////////////////////////////////////////////
0: 
0:         // find the hints for the node using its token.
0:         Token<?> token = StorageService.instance.getTokenMetadata().getToken(endpoint);
0:         logger_.info("Started hinted handoff for token: {} with IP: {}", token, endpoint);
0:         ByteBuffer tokenBytes = StorageService.getPartitioner().getTokenFactory().toByteArray(token);
0:         DecoratedKey<?> epkey =  StorageService.getPartitioner().decorateKey(tokenBytes);
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(tokenBytes, hint.name(), versionColumn.timestamp());
commit:64f9337
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_ = new JMXEnabledThreadPoolExecutor("HintedHandoff");
commit:d505bde
commit:be22ee4
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.InputStream;
1: import javax.management.MBeanServer;
1: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.ApplicationState;
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:  * (We have to use String keys for compatibility with OPP.)
0:  * SuperColumns in these rows are the mutations to replay, with uuid names:
0:  *  <dest ip>: {              // key
0:  *    <uuid>: {               // supercolumn
0:  *      mutation: <mutation>  // subcolumn
0:  *      version: <mutation serialization version>
0:  *      table: <table of hinted mutation>
0:  *      key: <key of hinted mutation>
0:  *    }
0:  *  }
0:  * When FailureDetector signals that a node that was down is back up, we page through
0:  * the hinted mutations and send them over one at a time, waiting for
0:  * hinted_handoff_throttle_delay in between each.
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMutation(InetAddress endpoint, RowMutation mutation) throws IOException
0:         IWriteResponseHandler responseHandler = WriteResponseHandler.create(endpoint);
0:         MessagingService.instance().sendRR(mutation, endpoint, responseHandler);
0: 
0:         try
0:             responseHandler.get();
0:         catch (TimeoutException e)
0:         try
0:             Thread.sleep(DatabaseDescriptor.getHintedHandoffThrottleDelay());
0:         catch (InterruptedException e)
0:             throw new AssertionError(e);
0:     private static void deleteHint(ByteBuffer endpointAddress, ByteBuffer hintId, long timestamp) throws IOException
0:         rm.delete(new QueryPath(HINTS_CF, hintId), timestamp);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (!FailureDetector.instance.isAlive(endpoint))
/////////////////////////////////////////////////////////////////////////
0:         // 2. For each column, deserialize the mutation and send it to the endpoint
/////////////////////////////////////////////////////////////////////////
0:             for (IColumn hint : hintColumnFamily.getSortedColumns())
0:             {
0:                 startColumn = hint.name();
0: 
0:                 IColumn versionColumn = hint.getSubColumn(ByteBufferUtil.bytes("version"));
0:                 IColumn tableColumn = hint.getSubColumn(ByteBufferUtil.bytes("table"));
0:                 IColumn keyColumn = hint.getSubColumn(ByteBufferUtil.bytes("key"));
0:                 IColumn mutationColumn = hint.getSubColumn(ByteBufferUtil.bytes("mutation"));
0:                 assert versionColumn != null;
0:                 assert tableColumn != null;
0:                 assert keyColumn != null;
0:                 assert mutationColumn != null;
0:                 DataInputStream in = new DataInputStream(ByteBufferUtil.inputStream(mutationColumn.value()));
0:                 RowMutation rm = RowMutation.serializer().deserialize(in, ByteBufferUtil.toInt(versionColumn.value()));
0: 
0:                 if (sendMutation(endpoint, rm))
0:                 {
0:                     deleteHint(endpointAsUTF8, hint.name(), versionColumn.timestamp());
0:                     rowsReplayed++;
0:                 }
0:                 else
0:                 {
0:                     logger_.info("Could not complete hinted handoff to " + endpoint);
0:                     break delivery;
commit:6652b5d
commit:8a80faf
/////////////////////////////////////////////////////////////////////////
0:     private static final int PAGE_SIZE = 1024;
commit:e70e733
/////////////////////////////////////////////////////////////////////////
0:                     CompactionManager.instance.submitMaximal(hintStore, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:                 CompactionManager.instance.submitMaximal(hintStore, Integer.MAX_VALUE).get();
commit:129d80a
/////////////////////////////////////////////////////////////////////////
0:                     CompactionManager.instance.submitMajor(hintStore, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:                 CompactionManager.instance.submitMajor(hintStore, Integer.MAX_VALUE).get();
commit:3c4687c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.compaction.CompactionManager;
commit:98dfbfa
commit:43c05d9
/////////////////////////////////////////////////////////////////////////
commit:40a1369
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
0:         if (CFMetaData.getId(tableName, cfName) == null)
0:         {
0:             logger_.debug("Discarding hints for dropped keyspace or columnfamily {}/{}", tableName, cfName);
0:             return true;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dkey = StorageService.getPartitioner().decorateKey(key);
commit:ae7dbe3
commit:21b5cdb
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendRow(InetAddress endpoint, String tableName, String cfName, ByteBuffer key) throws IOException
/////////////////////////////////////////////////////////////////////////
0: 
0:         int pageSize = PAGE_SIZE;
0:         // send less columns per page if they are very large
0:         if (cfs.getMeanColumns() > 0)
0:         {
0:             int averageColumnSize = (int) (cfs.getMeanRowSize() / cfs.getMeanColumns());
0:             pageSize = Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize);
0:             pageSize = Math.max(2, pageSize); // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
0:             logger_.debug("average hinted-row column size is {}; using pageSize of {}", averageColumnSize, pageSize);
0:         }
0: 
0:             QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(cfs.getColumnFamilyName()), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
/////////////////////////////////////////////////////////////////////////
0:                     if (sendRow(endpoint, parts[0], parts[1], keyColumn.name()))
commit:bec125b
commit:f05d188
/////////////////////////////////////////////////////////////////////////
0:         StorageService.tasks.execute(runnable);
commit:1adcd1c
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Checking remote schema before delivering hints");
0:                 logger_.debug("Sleeping {}ms to stagger hint delivery", sleep);
commit:3f71a98
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Checking remote schema before delivering hints");
0:                 logger_.debug("Sleeping {}ms to stagger hint delivery", sleep);
commit:ec26ee7
/////////////////////////////////////////////////////////////////////////
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ByteBufferUtil.bytes(ipaddr));
/////////////////////////////////////////////////////////////////////////
0:         byte[] withsep = ArrayUtils.addAll(tableName.getBytes(UTF_8), SEPARATOR.getBytes(UTF_8));
0:         int index = ByteBufferUtil.lastIndexOf(joined, SEPARATOR.getBytes(UTF_8)[0], joined.limit());
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer endpointAsUTF8 = ByteBufferUtil.bytes(endpoint.getHostAddress()); // keys have to be UTF8 to make OPP happy
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey oldTableKey = StorageService.getPartitioner().decorateKey(ByteBufferUtil.bytes(oldTable));
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, ByteBufferUtil.bytes(newTable));
commit:6a0df02
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey<?> dkey = StorageService.getPartitioner().decorateKey(key);
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey<?> epkey =  StorageService.getPartitioner().decorateKey(endpointAsUTF8);
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey<?> oldTableKey = StorageService.getPartitioner().decorateKey(ByteBuffer.wrap(oldTable.getBytes(UTF_8)));
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner<?> partitioner = StorageService.getPartitioner();
commit:dc3d5bc
commit:13c45ad
/////////////////////////////////////////////////////////////////////////
0: 
0:             try
0:             {
0:                 Thread.sleep(DatabaseDescriptor.getHintedHandoffThrottleDelay());
0:             }
0:             catch (InterruptedException e)
0:             {
0:                 throw new AssertionError(e);
0:             }
commit:c5ee059
/////////////////////////////////////////////////////////////////////////
0:         try
0:             logger_.info("Checking remote schema before delivering hints");
0:             int waited = waitForSchemaAgreement(endpoint);
0:             // sleep a random amount to stagger handoff delivery from different replicas.
0:             // (if we had to wait, then gossiper randomness took care of that for us already.)
0:             if (waited == 0) {
0:                 int sleep = new Random().nextInt(60000);
0:                 logger_.info("Sleeping {}ms to stagger hint delivery", sleep);
0:                 Thread.sleep(sleep);
0:             }
0:             if (!Gossiper.instance.getEndpointStateForEndpoint(endpoint).isAlive())
0:             {
0:                 logger_.info("Endpoint {} died before hint delivery, aborting", endpoint);
0:                 return;
0:             }
0:         finally
0:         {
0:             queuedDeliveries.remove(endpoint);
0:         }
0:         logger_.info("Started hinted handoff for endpoint " + endpoint);
commit:1f7b42e
/////////////////////////////////////////////////////////////////////////
0:         try
0:             logger_.info("Checking remote schema before delivering hints");
0:             int waited = waitForSchemaAgreement(endpoint);
0:             // sleep a random amount to stagger handoff delivery from different replicas.
0:             // (if we had to wait, then gossiper randomness took care of that for us already.)
0:             if (waited == 0) {
0:                 int sleep = new Random().nextInt(60000);
0:                 logger_.info("Sleeping {}ms to stagger hint delivery", sleep);
0:                 Thread.sleep(sleep);
0:             }
0:             if (!Gossiper.instance.getEndpointStateForEndpoint(endpoint).isAlive())
0:             {
0:                 logger_.info("Endpoint {} died before hint delivery, aborting", endpoint);
0:                 return;
0:             }
0:         finally
0:         {
0:             queuedDeliveries.remove(endpoint);
0:         }
0:         logger_.info("Started hinted handoff for endpoint " + endpoint);
commit:46ea05f
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
0:             throw new RuntimeException("Corrupted hint name " + ByteBufferUtil.bytesToHex(joined));
0:         try
0:         {
0:             return new String[] { ByteBufferUtil.string(joined, joined.position(), index - joined.position()),
0:                                   ByteBufferUtil.string(joined, index + 1, joined.limit() - (index + 1)) };
0:         }
0:         catch (CharacterCodingException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
commit:59f87af
/////////////////////////////////////////////////////////////////////////
0:     public static void deleteHintsForEndPoint(final InetAddress endpoint)
0:         final ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ByteBuffer.wrap(endpoint.getAddress()));
0: 
0:         // execute asynchronously to avoid blocking caller (which may be processing gossip)
0:         Runnable runnable = new Runnable()
0:             public void run()
0:             {
0:                 try
0:                 {
0:                     logger_.info("Deleting any stored hints for " + endpoint);
0:                     rm.apply();
0:                     hintStore.forceFlush();
0:                     CompactionManager.instance.submitMajor(hintStore, 0, Integer.MAX_VALUE);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     logger_.warn("Could not delete hints for " + endpoint + ": " + e);
0:                 }
0:             }
0:         };
0:         StorageService.scheduledTasks.execute(runnable);
commit:93126cb
/////////////////////////////////////////////////////////////////////////
0:     	executor_.execute(r);
commit:c186d6e
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer endpointAsUTF8 = ByteBuffer.wrap(endpoint.getHostAddress().getBytes(UTF_8)); // keys have to be UTF8 to make OPP happy
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(endpointAsUTF8);
0:         delivery:
0:         while (true)
0:         {
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:             if (pagingFinished(hintColumnFamily, startColumn))
0:                 break;
0:             for (IColumn keyColumn : hintColumnFamily.getSortedColumns())
0:             {
0:                 startColumn = keyColumn.name();
0:                 Collection<IColumn> tableCFs = keyColumn.getSubColumns();
0:                 for (IColumn tableCF : tableCFs)
0:                 {
0:                     String[] parts = getTableAndCFNames(tableCF.name());
0:                     if (sendMessage(endpoint, parts[0], parts[1], keyColumn.name()))
0:                     {
0:                         deleteHintKey(endpointAsUTF8, keyColumn.name(), tableCF.name(), tableCF.timestamp());
0:                         rowsReplayed++;
0:                     else
0:                     {
0:                         logger_.info("Could not complete hinted handoff to " + endpoint);
0:                         break delivery;
0:                     }
0: 
0:                     startColumn = keyColumn.name();
0:         }
commit:745fb44
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendRR(message, endpoint, responseHandler);
commit:43d330d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer startColumn = ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:             QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(cfs.getColumnFamilyName()), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer startColumn = ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                 QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer startCol = ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:             QueryFilter filter = QueryFilter.getSliceFilter(oldTableKey, new QueryPath(HINTS_CF), startCol, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
commit:b814afa
/////////////////////////////////////////////////////////////////////////
0:                                 ByteBufferUtil.string(joined, joined.position(), index - joined.position()),
0:                                 ByteBufferUtil.string(joined, index + 1, joined.limit() - (index + 1))
commit:37ec7d3
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendRR(message, Arrays.asList(endpoint), responseHandler);
commit:ef25537
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.ArrayUtils;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: import static com.google.common.base.Charsets.UTF_8;
commit:2c6f56d
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance.sendRR(message, Arrays.asList(endpoint), responseHandler);
commit:6e9a2e9
/////////////////////////////////////////////////////////////////////////
0:  * HHM never deletes the row from Application tables; usually (but not for CL.ANY!)
0:  * the row belongs on this node, as well.  instead, we rely on cleanup compactions
0:  * to remove data that doesn't belong.  (Cleanup compactions may be started manually
commit:d5fa915
/////////////////////////////////////////////////////////////////////////
0:         index = ArrayUtils.lastIndexOf(joined.array(), SEPARATOR.getBytes()[0],joined.limit()+joined.arrayOffset());
0:         if (index == -1 || index < (joined.position() + joined.arrayOffset() + 1))
0:             throw new RuntimeException("Corrupted hint name " + new String(joined.array(), joined.arrayOffset() + joined.position(), joined.remaining()));
commit:8358669
/////////////////////////////////////////////////////////////////////////
0:         parts[1] = new String(ArrayUtils.subarray(joined.array(), index+1, joined.limit()+joined.arrayOffset()));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
0: 
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.commons.lang.ArrayUtils;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endpoint, String tableName, String cfName, ByteBuffer key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer startColumn = FBUtilities.EMPTY_BYTE_BUFFER;
0:             QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(cfs.getColumnFamilyName()), startColumn, FBUtilities.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHintKey(ByteBuffer endpointAddress, ByteBuffer key, ByteBuffer tableCF, long timestamp) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ByteBuffer.wrap(endpoint.getAddress()));
/////////////////////////////////////////////////////////////////////////
0:     private static boolean pagingFinished(ColumnFamily hintColumnFamily, ByteBuffer startColumn)
0:     public static ByteBuffer makeCombinedName(String tableName, String columnFamily)
0:         return ByteBuffer.wrap(ArrayUtils.addAll(withsep, columnFamily.getBytes(UTF_8)));
0:     private static String[] getTableAndCFNames(ByteBuffer joined)
0:         index = ArrayUtils.lastIndexOf(joined.array(), SEPARATOR.getBytes()[0],joined.position()+joined.arrayOffset());
0:         parts[0] = new String(ArrayUtils.subarray(joined.array(), joined.position()+joined.arrayOffset(), index));
0:         parts[1] = new String(ArrayUtils.subarray(joined.array(), index+1, joined.limit()));
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(ByteBuffer.wrap(endpoint.getHostAddress().getBytes(UTF_8)));
0:         ByteBuffer startColumn = FBUtilities.EMPTY_BYTE_BUFFER;
0:                 QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, FBUtilities.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:                             deleteHintKey(ByteBuffer.wrap(endpoint.getHostAddress().getBytes(UTF_8)), keyColumn.name(), tableCF.name(), tableCF.timestamp());
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey oldTableKey = StorageService.getPartitioner().decorateKey(ByteBuffer.wrap(oldTable.getBytes(UTF_8)));
0:         ByteBuffer startCol = FBUtilities.EMPTY_BYTE_BUFFER;
0:             QueryFilter filter = QueryFilter.getSliceFilter(oldTableKey, new QueryPath(HINTS_CF), startCol, FBUtilities.EMPTY_BYTE_BUFFER, false, PAGE_SIZE);
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, ByteBuffer.wrap(newTable.getBytes(UTF_8)));
0:             for (ByteBuffer key : cf.getColumnNames())
commit:9d32382
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHintKey(byte[] endpointAddress, byte[] key, byte[] tableCF, long timestamp) throws IOException
0:         rm.delete(new QueryPath(HINTS_CF, key, tableCF), timestamp);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath(HINTS_CF), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                             deleteHintKey(endpoint.getHostAddress().getBytes(UTF_8), keyColumn.name(), tableCF.name(), tableCF.timestamp());
/////////////////////////////////////////////////////////////////////////
0:                 drop.delete(new QueryPath(HINTS_CF, key), now);
commit:5c44cc1
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.IWriteResponseHandler;
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_ = new JMXEnabledThreadPoolExecutor("HintedHandoff", DatabaseDescriptor.getCompactionThreadPriority());
commit:43eae6f
/////////////////////////////////////////////////////////////////////////
0:         executor_ = new JMXEnabledThreadPoolExecutor("HintedHandoff", hhPriority);
commit:1eea19e
/////////////////////////////////////////////////////////////////////////
commit:4c451cd
/////////////////////////////////////////////////////////////////////////
0:             if (cf.getColumnNames().isEmpty())
0:             {
0:                 logger_.debug("Nothing to hand off for {}", dkey);
0:                 break;
0:             }
0: 
commit:b2a8d89
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(cfs.getColumnFamilyName()), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:                 QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:             QueryFilter filter = QueryFilter.getSliceFilter(oldTableKey, new QueryPath(HINTS_CF), startCol, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
commit:4ac23ca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.IWriteResponseHandler;
/////////////////////////////////////////////////////////////////////////
0:             IWriteResponseHandler responseHandler =  WriteResponseHandler.create(endpoint);
commit:c6b1668
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_;
0: 
0:     public HintedHandOffManager()
0:     {
0:         int hhPriority = System.getProperty("cassandra.compaction.priority") == null
0:                          ? Thread.NORM_PRIORITY
0:                          : Integer.parseInt(System.getProperty("cassandra.compaction.priority"));
0:         executor_ = new JMXEnabledThreadPoolExecutor("HINTED-HANDOFF-POOL", hhPriority);
0:     }
commit:f4be897
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.InetAddress;
0: import java.util.concurrent.TimeoutException;
0: import org.apache.commons.lang.ArrayUtils;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.service.DigestMismatchException;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.service.WriteResponseHandler;
0: import static com.google.common.base.Charsets.UTF_8;
0: 
/////////////////////////////////////////////////////////////////////////
0:         byte[] withsep = ArrayUtils.addAll(tableName.getBytes(UTF_8), SEPARATOR.getBytes());
0:         return ArrayUtils.addAll(withsep, columnFamily.getBytes(UTF_8));
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey oldTableKey = StorageService.getPartitioner().decorateKey(oldTable.getBytes(UTF_8));
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, newTable.getBytes(UTF_8));
commit:5ab5e1b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentSkipListSet;
/////////////////////////////////////////////////////////////////////////
0: import org.cliffc.high_scale_lib.NonBlockingHashSet;
/////////////////////////////////////////////////////////////////////////
0:     private final NonBlockingHashSet<InetAddress> queuedDeliveries = new NonBlockingHashSet<InetAddress>();
0: 
/////////////////////////////////////////////////////////////////////////
0:     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
0:         queuedDeliveries.remove(endpoint);
/////////////////////////////////////////////////////////////////////////
0:         if (!queuedDeliveries.add(to))
0:             return;
0: 
commit:0b2ba99
/////////////////////////////////////////////////////////////////////////
0:         logger_.info("Started hinted handoff for endpoint " + endpoint);
/////////////////////////////////////////////////////////////////////////
0:         int rowsReplayed = 0;
/////////////////////////////////////////////////////////////////////////
0:                     {
0:                         rowsReplayed++;
0:                     }
0: 
0:                     startColumn = keyColumn.name();
0: 
0:         if (rowsReplayed > 0)
0:             hintStore.forceFlush();
0:             try
0:             {
0:                 CompactionManager.instance.submitMajor(hintStore, 0, Integer.MAX_VALUE).get();
0:             }
0:             catch (Exception e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         logger_.info(String.format("Finished hinted handoff of %s rows to endpoint %s",
0:                                    rowsReplayed, endpoint));
commit:b24dc53
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  * For each endpoint for which we have hints, there is a row in the system hints CF.
0:  * Subcolumns names within that supercolumn are keyspace+CF, concatenated with SEPARATOR.
0:  * Subcolumn values are always empty; instead, we store the row data "normally"
0:  * in the application table it belongs in.
0:  * When FailureDetector signals that a node that was down is back up, we read its
0:  * hints row to see what rows we need to forward data for, then reach each row in its
0:  * entirety and send it over.
0:  * deliverHints is also exposed to JMX so it can be run manually if FD ever misses
0:  * its cue somehow.
1:  *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static final String SEPARATOR = "-";
0:     private static boolean sendMessage(InetAddress endpoint, String tableName, String cfName, byte[] key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dkey, new QueryPath(cfs.getColumnFamilyName())));
0:         if (cf != null)
0:             rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHintKey(byte[] endpointAddress, byte[] key, byte[] tableCF) throws IOException
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, endpointAddress);
0:         rm.delete(new QueryPath(HINTS_CF, key, tableCF), new TimestampClock(System.currentTimeMillis()));
0:     public static void deleteHintsForEndPoint(InetAddress endpoint)
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, endpoint.getAddress());
0:         rm.delete(new QueryPath(HINTS_CF), new TimestampClock(System.currentTimeMillis()));
0:         try {
0:             logger_.info("Deleting any stored hints for " + endpoint);
0:             rm.apply();
0:             hintStore.forceFlush();
0:             CompactionManager.instance.submitMajor(hintStore, 0, Integer.MAX_VALUE).get();
0:         }
0:         catch (Exception e)
0:         {
0:             logger_.warn("Could not delete hints for " + endpoint + ": " + e);
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public static byte[] makeCombinedName(String tableName, String columnFamily)
0:     {
0:         byte[] withsep = ArrayUtils.addAll(tableName.getBytes(FBUtilities.UTF8), SEPARATOR.getBytes());
0:         return ArrayUtils.addAll(withsep, columnFamily.getBytes(FBUtilities.UTF8));
0:     }
0: 
0:     private static String[] getTableAndCFNames(byte[] joined)
0:     {
0:         int index;
0:         index = ArrayUtils.lastIndexOf(joined, SEPARATOR.getBytes()[0]);
0:         if (index < 1)
0:             throw new RuntimeException("Corrupted hint name " + joined.toString());
0:         String[] parts = new String[2];
0:         parts[0] = new String(ArrayUtils.subarray(joined, 0, index));
0:         parts[1] = new String(ArrayUtils.subarray(joined, index+1, joined.length));
0:         return parts;
0: 
0:     }
0:             
0:         // 1. Get the key of the endpoint we need to handoff
0:         // 2. For each column read the list of rows: subcolumns are KS + SEPARATOR + CF
0:         // 3. Delete the subcolumn if the write was successful
0:         // 4. Force a flush
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(endpoint.getAddress());
0:         byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
0:         while (true)
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:             if (pagingFinished(hintColumnFamily, startColumn))
0:                 break;
0:             Collection<IColumn> keyColumns = hintColumnFamily.getSortedColumns();
0:             for (IColumn keyColumn : keyColumns)
0:                 startColumn = keyColumn.name();
0:                 Collection<IColumn> tableCFs = keyColumn.getSubColumns();
0:                 for (IColumn tableCF : tableCFs)
0:                     String[] parts = getTableAndCFNames(tableCF.name());
0:                     if (sendMessage(endpoint, parts[0], parts[1], keyColumn.name()))
0:                         deleteHintKey(endpoint.getAddress(), keyColumn.name(), tableCF.name());
commit:acbcc4b
/////////////////////////////////////////////////////////////////////////
0: import java.net.UnknownHostException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // 4. Now force a flush
0:         // 5. Do major compaction to clean up all deletes etc.
/////////////////////////////////////////////////////////////////////////
0:         hintStore.forceFlush();
0:         try
0:         {
0:             CompactionManager.instance.submitMajor(hintStore, 0, Integer.MAX_VALUE).get();
0:         }
0:         catch (Exception e)
0:         {
0:             throw new RuntimeException(e);
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void deliverHints(String to) throws UnknownHostException
0:     {
0:         deliverHints(InetAddress.getByName(to));
0:     }
commit:cba59a8
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), new TimestampClock(timestamp));
0:         rm.delete(new QueryPath(HINTS_CF, key, null), new TimestampClock(System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:                 drop.delete(new QueryPath(HINTS_CF, key), new TimestampClock(now));
commit:5a45534
/////////////////////////////////////////////////////////////////////////
0:         WriteResponseHandler responseHandler = new WriteResponseHandler(endpoint);
commit:d55ed91
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endpoint, String tableName, byte[] key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         WriteResponseHandler responseHandler = new WriteResponseHandler(1, tableName);
0:         MessagingService.instance.sendRR(message, new InetAddress[] { endpoint }, responseHandler);
/////////////////////////////////////////////////////////////////////////
0:     /** hintStore must be the hints columnfamily from the system table */
0:     private static void deliverAllHints() throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException
/////////////////////////////////////////////////////////////////////////
0:     private static void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
commit:ef1895b
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.AbstractReplicationStrategy;
0: import org.apache.cassandra.thrift.ConsistencyLevel;
0: import org.apache.cassandra.thrift.UnavailableException;
0: import com.google.common.collect.Multimap;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endpoint, String tableName, byte[] key) throws IOException, UnavailableException
/////////////////////////////////////////////////////////////////////////
0:         InetAddress [] endpoints = new InetAddress[] { endpoint };
0:         AbstractReplicationStrategy rs = StorageService.instance.getReplicationStrategy(tableName);
0:         List<InetAddress> endpointlist = Arrays.asList(endpoints);
0:         Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(endpointlist);
0:         WriteResponseHandler responseHandler = new WriteResponseHandler(endpointlist, hintedEndpoints, ConsistencyLevel.ALL, tableName);
0:         MessagingService.instance.sendRR(message, endpoints, responseHandler);
/////////////////////////////////////////////////////////////////////////
0:     /** hintStore must be the hints columnfamily from the system table 
0:      * @throws UnavailableException */
0:     private static void deliverAllHints() throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException, UnavailableException
/////////////////////////////////////////////////////////////////////////
0:     private static void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException, UnavailableException
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endpoint, String tableName, byte[] key) throws IOException
0:         if (!Gossiper.instance.isKnownEndpoint(endpoint))
0:             logger_.warn("Hints found for endpoint " + endpoint + " which is not part of the gossip network.  discarding.");
0:         if (!FailureDetector.instance.isAlive(endpoint))
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance.sendRR(message, new InetAddress[] { endpoint }, responseHandler);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteEndpoint(byte[] endpointAddress, String tableName, byte[] key, long timestamp) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                             deleteEndpoint(endpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:     private static void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
0:           logger_.debug("Started hinted handoff for endpoint " + endpoint);
0:         byte[] targetEPBytes = endpoint.getAddress();
/////////////////////////////////////////////////////////////////////////
0:                     for (IColumn hintEndpoint : endpoints)
0:                         if (Arrays.equals(hintEndpoint.name(), targetEPBytes) && sendMessage(endpoint, tableName, keyBytes))
0:                                 deleteEndpoint(hintEndpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:           logger_.debug("Finished hinted handoff for endpoint " + endpoint);
commit:bf98ec9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = cfstore.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfstore.getColumnFamilyName())));
/////////////////////////////////////////////////////////////////////////
0:                 QueryFilter filter = QueryFilter.getSliceFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:                 QueryFilter filter = QueryFilter.getSliceFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
commit:7e09822
/////////////////////////////////////////////////////////////////////////
0:         for (ColumnFamilyStore cfstore : table.getColumnFamilyStores())
commit:2126f60
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance.sendRR(message, new InetAddress[] { endPoint }, responseHandler);
commit:af9b768
/////////////////////////////////////////////////////////////////////////
0:                 if (pagingFinished(hintColumnFamily, startColumn))
/////////////////////////////////////////////////////////////////////////
0:                     startColumn = keyColumn.name();
/////////////////////////////////////////////////////////////////////////
0:     private static boolean pagingFinished(ColumnFamily hintColumnFamily, byte[] startColumn)
0:     {
0:         // done if no hints found or the start column (same as last column processed in previous iteration) is the only one
0:         return hintColumnFamily == null
0:                || (hintColumnFamily.getSortedColumns().size() == 1 && hintColumnFamily.getColumn(startColumn) != null);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 if (pagingFinished(hintColumnFamily, startColumn))
/////////////////////////////////////////////////////////////////////////
0:                     startColumn = keyColumn.name();
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
1:     public static final HintedHandOffManager instance = new HintedHandOffManager();
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected HintedHandOffManager()
/////////////////////////////////////////////////////////////////////////
0:         if (!Gossiper.instance.isKnownEndpoint(endPoint))
0:         if (!FailureDetector.instance.isAlive(endPoint))
commit:53854bb
/////////////////////////////////////////////////////////////////////////
0:         }, "Hint delivery").start();
commit:facfe74
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_ = new JMXEnabledThreadPoolExecutor("HINTED-HANDOFF-POOL");
0: 
/////////////////////////////////////////////////////////////////////////
0:     public HintedHandOffManager()
0:     {
0:         new Thread(new WrappedRunnable()
0:         {
0:             public void runMayThrow() throws Exception
0:             {
0:                 while (true)
0:                 {
0:                     Thread.sleep(INTERVAL_IN_MS);
0:                     deliverAllHints();
0:                 }
0:             }
0:         }).start();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static void deliverAllHints() throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:                 if (hintColumnFamily == null)
0:                 Collection<IColumn> keys = hintColumnFamily.getSortedColumns();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c30c366
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryFilter;
0: import org.apache.cassandra.db.filter.SliceQueryFilter;
0: 
0: import org.apache.commons.lang.ArrayUtils;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static final int PAGE_SIZE = 10000;
/////////////////////////////////////////////////////////////////////////
0:             byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
0:             while (true)
0:                 QueryFilter filter = new SliceQueryFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
0:                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:                 if (hintColumnFamily == null)
0:                     break;
0:                 Collection<IColumn> keys = hintColumnFamily.getSortedColumns();
0: 
0:                 for (IColumn keyColumn : keys)
0:                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                     String keyStr = new String(keyColumn.name(), "UTF-8");
0:                     int deleted = 0;
0:                     for (IColumn endpoint : endpoints)
0:                     {
0:                         if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyStr))
0:                         {
0:                             deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
0:                             deleted++;
0:                         }
0:                     }
0:                     if (deleted == endpoints.size())
0:                     {
0:                         deleteHintKey(tableName, keyColumn.name());
0:                     }
0: 
0:                     startColumn = keyColumn.name(); // repeating the last as the first is fine since we just deleted it
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = systemTable.getColumnFamilyStore(HINTS_CF);
0:             byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
0:             while (true)
0:                 QueryFilter filter = new SliceQueryFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
0:                 ColumnFamily hintedColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:                 if (hintedColumnFamily == null)
0:                     break;
0:                 }
0:                 Collection<IColumn> keys = hintedColumnFamily.getSortedColumns();
0: 
0:                 for (IColumn keyColumn : keys)
0:                 {
0:                     String keyStr = new String(keyColumn.name(), "UTF-8");
0:                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                     for (IColumn hintEndPoint : endpoints)
0:                         if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, tableName, keyStr))
0:                             if (endpoints.size() == 1)
0:                             {
0:                                 deleteHintKey(tableName, keyColumn.name());
0:                             }
0:                             else
0:                             {
0:                                 deleteEndPoint(hintEndPoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
0:                             }
0:                             break;
0: 
0:                     startColumn = keyColumn.name(); // repeating the last as the first is fine since we just deleted it
commit:6b1e0a4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.WrappedRunnable;
/////////////////////////////////////////////////////////////////////////
0:         final Runnable r = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
0:                 deliverAllHints(columnFamilyStore);
/////////////////////////////////////////////////////////////////////////
0:         Runnable r = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
0:                 deliverHintsToEndpoint(to);
commit:0642a53
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.Gossiper;
0: 
/////////////////////////////////////////////////////////////////////////
0:     final static long INTERVAL_IN_MS = 3600 * 1000; // check for ability to deliver hints this often
/////////////////////////////////////////////////////////////////////////
0:         if (!Gossiper.instance().isKnownEndpoint(endPoint))
0:         {
0:             logger_.warn("Hints found for endpoint " + endPoint + " which is not part of the gossip network.  discarding.");
0:             return true;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         TimerTask task = new TimerTask()
0:         };
0:         timer.schedule(task, INTERVAL_IN_MS, INTERVAL_IN_MS);
commit:b4c7f55
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor_ = new JMXEnabledThreadPoolExecutor("HINTED-HANDOFF-POOL");
commit:453c817
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutionException;
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             CompactionManager.instance.submitMajor(hintStore).get();
0:         }
0:         catch (Exception e)
0:         {
0:             throw new RuntimeException(e);
0:         }
commit:4777551
/////////////////////////////////////////////////////////////////////////
0:     private static volatile HintedHandOffManager instance_;
0:     private static final Lock lock_ = new ReentrantLock();
0:     private static final Logger logger_ = Logger.getLogger(HintedHandOffManager.class);
0:     private final ExecutorService executor_ = new DebuggableThreadPoolExecutor("HINTED-HANDOFF-POOL");
0:     final Timer timer = new Timer("HINTED-HANDOFF-TIMER");
0:         if (instance_ == null)
0:                 if (instance_ == null)
commit:e0f5809
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = cfstore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfstore.getColumnFamilyName())));
0:             if (cf != null)
0:                 rm.add(cf);
commit:994487d
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(tableName, key);
0:         for (ColumnFamilyStore cfstore : table.getColumnFamilyStores().values())
0:         {
0:             rm.add(cfstore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfstore.getColumnFamilyName()))));
0:         }
commit:51fa961
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintedColumnFamily = ColumnFamilyStore.removeDeleted(systemTable.get(tableName, HINTS_CF), Integer.MAX_VALUE);
commit:a5bd08f
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endPoint, String tableName, String key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         WriteResponseHandler responseHandler = new WriteResponseHandler(1);
0:         MessagingService.instance().sendRR(message, new InetAddress[] { endPoint }, responseHandler);
0:         try
0:         {
0:             responseHandler.get();
0:         }
0:         catch (TimeoutException e)
0:         {
0:             return false;
0:         }
0:         return true;
/////////////////////////////////////////////////////////////////////////
0:                     if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, tableName, keyStr))
commit:924c7e5
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance().sendRR(message, new InetAddress[] { endPoint }, quorumResponseHandler);
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endPoint, String tableName, String key) throws DigestMismatchException, TimeoutException, IOException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance().sendRR(message, new InetAddress[]{ endPoint }, quorumResponseHandler);
/////////////////////////////////////////////////////////////////////////
0:                     if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyStr))
/////////////////////////////////////////////////////////////////////////
0:     private static void deliverHintsToEndpoint(InetAddress endPoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
0:         byte[] targetEPBytes = endPoint.getAddress();
/////////////////////////////////////////////////////////////////////////
0:                     if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, null, keyStr))
/////////////////////////////////////////////////////////////////////////
0:     public void deliverHints(final InetAddress to)
commit:694a611
/////////////////////////////////////////////////////////////////////////
0:           logger_.debug("Started hinted handoff for endPoint " + endPoint);
/////////////////////////////////////////////////////////////////////////
0:           logger_.debug("Finished hinted handoff for endpoint " + endPoint);
commit:c1e22db
/////////////////////////////////////////////////////////////////////////
0:                         deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                             deleteEndPoint(hintEndPoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
commit:eeb164e
/////////////////////////////////////////////////////////////////////////
0:  * For each table (keyspace), there is a row in the system hints CF.
0:  * SuperColumns in that row are keys for which we have hinted data.
0:  * Subcolumns names within that supercolumn are host IPs. Subcolumn values are always empty.
0:  * Instead, we store the row data "normally" in the application table it belongs in.
1:  *
0:  * So when we deliver hints we look up endpoints that need data delivered
0:  * on a per-key basis, then read that entire row out and send it over.
0:  * (TODO handle rows that have incrementally grown too large for a single message.)
1:  *
0:  * HHM never deletes the row from Application tables; there is no way to distinguish that
0:  * from hinted tombstones!  instead, rely on cleanup compactions to remove data
0:  * that doesn't belong on this node.  (Cleanup compactions may be started manually
0:  * -- on a per node basis -- with "nodeprobe cleanup.")
1:  *
0:  * TODO this avoids our hint rows from growing excessively large by offloading the
0:  * message data into application tables.  But, this means that cleanup compactions
0:  * will nuke HH data.  Probably better would be to store the RowMutation messages
0:  * in a HHData (non-super) CF, modifying the above to store a UUID value in the
0:  * HH subcolumn value, which we use as a key to a [standard] HHData system CF
0:  * that would contain the message bytes.
1:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(tableName, row);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHintKey(String tableName, byte[] key) throws IOException
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName);
0:         rm.delete(new QueryPath(HINTS_CF, key, null), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                     deleteHintKey(tableName, keyColumn.name());
/////////////////////////////////////////////////////////////////////////
0:                     if (new String(hintEndPoint.name(), "UTF-8").equals(targetEPBytes) && sendMessage(endPoint.getHost(), null, keyStr))
0:                             deleteHintKey(tableName, keyColumn.name());
0:                         else
0:                         {
0:                             deleteEndPoint(hintEndPoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                         }
0:                         break;
commit:5e9b35c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         MessagingService.instance().sendRR(message, new EndPoint[]{ endPoint }, quorumResponseHandler);
commit:de83183
/////////////////////////////////////////////////////////////////////////
0: import java.util.Timer;
0: import java.util.TimerTask;
0: import java.util.concurrent.ExecutorService;
0: import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
0:     final static long INTERVAL_IN_MS = 3600 * 1000;
0:     private ExecutorService executor_ = new DebuggableThreadPoolExecutor("HINTED-HANDOFF-POOL");
0:     Timer timer = new Timer("HINTED-HANDOFF-TIMER");
/////////////////////////////////////////////////////////////////////////
0:     public void scheduleHandoffsFor(final ColumnFamilyStore columnFamilyStore)
0:         final Runnable r = new Runnable()
/////////////////////////////////////////////////////////////////////////
0:         timer.schedule(new TimerTask()
0:         {
0:             public void run()
0:             {
0:                 executor_.execute(r);
0:             }
0:         }, INTERVAL_IN_MS, INTERVAL_IN_MS);
commit:1d0cf13
/////////////////////////////////////////////////////////////////////////
0:         hintStore.doMajorCompaction(0);
commit:d7bd37a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.NamedThreadFactory;
/////////////////////////////////////////////////////////////////////////
0:     private ScheduledExecutorService executor_ = new DebuggableScheduledThreadPoolExecutor(1, new NamedThreadFactory("HINTED-HANDOFF-POOL"));
commit:39982f3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         hintStore.forceAntiCompaction(null, null, 0);
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.cassandra.db;
0: 
0: import java.util.Collection;
0: import java.util.Set;
0: import java.util.concurrent.ScheduledExecutorService;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.TimeoutException;
0: import java.util.concurrent.locks.Lock;
0: import java.util.concurrent.locks.ReentrantLock;
0: import java.io.IOException;
0: 
0: import org.apache.log4j.Logger;
0: 
0: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
0: import org.apache.cassandra.concurrent.ThreadFactoryImpl;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.gms.FailureDetector;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.*;
0: import org.apache.cassandra.db.filter.IdentityQueryFilter;
0: import org.apache.cassandra.db.filter.QueryPath;
0: 
0: 
0: /**
0:  * There are two ways hinted data gets delivered to the intended nodes.
0:  *
0:  * runHints() runs periodically and pushes the hinted data on this node to
0:  * every intended node.
0:  *
0:  * runDelieverHints() is called when some other node starts up (potentially
0:  * from a failure) and delivers the hinted data just to that node.
0:  */
0: public class HintedHandOffManager
0: {
0:     private static HintedHandOffManager instance_;
0:     private static Lock lock_ = new ReentrantLock();
0:     private static Logger logger_ = Logger.getLogger(HintedHandOffManager.class);
0:     final static long intervalInMins_ = 60;
0:     private ScheduledExecutorService executor_ = new DebuggableScheduledThreadPoolExecutor(1, new ThreadFactoryImpl("HINTED-HANDOFF-POOL"));
0:     public static final String HINTS_CF = "HintsColumnFamily";
0: 
0: 
0:     public static HintedHandOffManager instance()
0:     {
0:         if ( instance_ == null )
0:         {
0:             lock_.lock();
0:             try
0:             {
0:                 if ( instance_ == null )
0:                     instance_ = new HintedHandOffManager();
0:             }
0:             finally
0:             {
0:                 lock_.unlock();
0:             }
0:         }
0:         return instance_;
0:     }
0: 
0:     private static boolean sendMessage(String endpointAddress, String tableName, String key) throws DigestMismatchException, TimeoutException, IOException, InvalidRequestException
0:     {
0:         EndPoint endPoint = new EndPoint(endpointAddress, DatabaseDescriptor.getStoragePort());
0:         if (!FailureDetector.instance().isAlive(endPoint))
0:         {
0:             return false;
0:         }
0: 
0:         Table table = Table.open(tableName);
0:         Row row = table.get(key);
0:         Row purgedRow = new Row(tableName,key);
0:         for (ColumnFamily cf : row.getColumnFamilies())
0:         {
0:             purgedRow.addColumnFamily(ColumnFamilyStore.removeDeleted(cf));
0:         }
0:         RowMutation rm = new RowMutation(tableName, purgedRow);
0:         Message message = rm.makeRowMutationMessage();
0:         QuorumResponseHandler<Boolean> quorumResponseHandler = new QuorumResponseHandler<Boolean>(1, new WriteResponseResolver());
0:         MessagingService.getMessagingInstance().sendRR(message, new EndPoint[]{ endPoint }, quorumResponseHandler);
0: 
0:         return quorumResponseHandler.get();
0:     }
0: 
0:     private static void deleteEndPoint(byte[] endpointAddress, String tableName, byte[] key, long timestamp) throws IOException
0:     {
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName);
0:         rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), timestamp);
0:         rm.apply();
0:     }
0: 
0:     private static void deleteHintedData(String tableName, String key) throws IOException
0:     {
0:         // delete the row from Application CFs: find the largest timestamp in any of
0:         // the data columns, and delete the entire CF with that value for the tombstone.
0: 
0:         // Note that we delete all data associated with the key: this may be more than
0:         // we sent earlier in sendMessage, since HH is not serialized with writes.
0:         // This is sub-optimal but okay, since HH is just an effort to make a recovering
0:         // node more consistent than it would have been; we can rely on the other
0:         // consistency mechanisms to finish the job in this corner case.
0:         RowMutation rm = new RowMutation(tableName, key);
0:         Table table = Table.open(tableName);
0:         Row row = table.get(key); // not necessary to do removeDeleted here
0:         Collection<ColumnFamily> cfs = row.getColumnFamilies();
0:         for (ColumnFamily cf : cfs)
0:         {
0:             long maxTS = Long.MIN_VALUE;
0:             if (!cf.isSuper())
0:             {
0:                 for (IColumn col : cf.getSortedColumns())
0:                     maxTS = Math.max(maxTS, col.timestamp());
0:             }
0:             else
0:             {
0:                 for (IColumn col : cf.getSortedColumns())
0:                 {
0:                     maxTS = Math.max(maxTS, col.timestamp());
0:                     Collection<IColumn> subColumns = col.getSubColumns();
0:                     for (IColumn subCol : subColumns)
0:                         maxTS = Math.max(maxTS, subCol.timestamp());
0:                 }
0:             }
0:             rm.delete(new QueryPath(cf.name()), maxTS);
0:         }
0:         rm.apply();
0:     }
0: 
0:     /** hintStore must be the hints columnfamily from the system table */
0:     private static void deliverAllHints(ColumnFamilyStore hintStore) throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException
0:     {
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Started deliverAllHints");
0: 
0:         // 1. Scan through all the keys that we need to handoff
0:         // 2. For each key read the list of recipients and send
0:         // 3. Delete that recipient from the key if write was successful
0:         // 4. If all writes were success for a given key we can even delete the key .
0:         // 5. Now force a flush
0:         // 6. Do major compaction to clean up all deletes etc.
0:         // 7. I guess we are done
0:         for (String tableName : DatabaseDescriptor.getTables())
0:         {
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(new IdentityQueryFilter(tableName, new QueryPath(HINTS_CF))), Integer.MAX_VALUE);
0:             if (hintColumnFamily == null)
0:             {
0:                 continue;
0:             }
0:             Collection<IColumn> keys = hintColumnFamily.getSortedColumns();
0: 
0:             for (IColumn keyColumn : keys)
0:             {
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 String keyStr = new String(keyColumn.name(), "UTF-8");
0:                 int deleted = 0;
0:                 for (IColumn endpoint : endpoints)
0:                 {
0:                     String endpointStr = new String(endpoint.name(), "UTF-8");
0:                     if (sendMessage(endpointStr, tableName, keyStr))
0:                     {
0:                         deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                         deleted++;
0:                     }
0:                 }
0:                 if (deleted == endpoints.size())
0:                 {
0:                     deleteHintedData(tableName, keyStr);
0:                 }
0:             }
0:         }
0:         hintStore.forceFlush();
0:         hintStore.forceCompaction(null, null, 0, null);
0: 
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Finished deliverAllHints");
0:     }
0: 
0:     private static void deliverHintsToEndpoint(EndPoint endPoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
0:     {
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Started hinted handoff for endPoint " + endPoint.getHost());
0: 
0:         String targetEPBytes = endPoint.getHost();
0:         // 1. Scan through all the keys that we need to handoff
0:         // 2. For each key read the list of recipients if the endpoint matches send
0:         // 3. Delete that recipient from the key if write was successful
0:         Table systemTable = Table.open(Table.SYSTEM_TABLE);
0:         for (String tableName : DatabaseDescriptor.getTables())
0:         {
0:             ColumnFamily hintedColumnFamily = systemTable.get(tableName, HINTS_CF);
0:             if (hintedColumnFamily == null)
0:             {
0:                 continue;
0:             }
0:             Collection<IColumn> keys = hintedColumnFamily.getSortedColumns();
0: 
0:             for (IColumn keyColumn : keys)
0:             {
0:                 String keyStr = new String(keyColumn.name(), "UTF-8");
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 for (IColumn hintEndPoint : endpoints)
0:                 {
0:                     if (hintEndPoint.name().equals(targetEPBytes) && sendMessage(endPoint.getHost(), null, keyStr))
0:                     {
0:                         deleteEndPoint(hintEndPoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                         if (endpoints.size() == 1)
0:                         {
0:                             deleteHintedData(tableName, keyStr);
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0: 
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Finished hinted handoff for endpoint " + endPoint.getHost());
0:     }
0: 
0:     public void submit(final ColumnFamilyStore columnFamilyStore)
0:     {
0:         Runnable r = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 try
0:                 {
0:                     deliverAllHints(columnFamilyStore);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     throw new RuntimeException(e);
0:                 }
0:             }
0:         };
0:     	executor_.scheduleWithFixedDelay(r, HintedHandOffManager.intervalInMins_, HintedHandOffManager.intervalInMins_, TimeUnit.MINUTES);
0:     }
0: 
0:     /*
0:      * This method is used to deliver hints to a particular endpoint.
0:      * When we learn that some endpoint is back up we deliver the data
0:      * to him via an event driven mechanism.
0:     */
0:     public void deliverHints(final EndPoint to)
0:     {
0:         Runnable r = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 try
0:                 {
0:                     deliverHintsToEndpoint(to);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     throw new RuntimeException(e);
0:                 }
0:             }
0:         };
0:     	executor_.submit(r);
0:     }
0: }
commit:986cee6
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteEndPoint(byte[] endpointAddress, String tableName, byte[] key, long timestamp) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                 for (IColumn col : cf.getSortedColumns())
0:                 for (IColumn col : cf.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:             Collection<IColumn> keys = hintColumnFamily.getSortedColumns();
0:                 String keyStr = new String(keyColumn.name(), "UTF-8");
0:                     String endpointStr = new String(endpoint.name(), "UTF-8");
0:                     if (sendMessage(endpointStr, tableName, keyStr))
/////////////////////////////////////////////////////////////////////////
0:                     deleteHintedData(tableName, keyStr);
/////////////////////////////////////////////////////////////////////////
0:         String targetEPBytes = endPoint.getHost();
/////////////////////////////////////////////////////////////////////////
0:             Collection<IColumn> keys = hintedColumnFamily.getSortedColumns();
0:                 String keyStr = new String(keyColumn.name(), "UTF-8");
0:                 for (IColumn hintEndPoint : endpoints)
0:                     if (hintEndPoint.name().equals(targetEPBytes) && sendMessage(endPoint.getHost(), null, keyStr))
0:                         deleteEndPoint(hintEndPoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                             deleteHintedData(tableName, keyStr);
commit:f2da00f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryPath;
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), timestamp);
/////////////////////////////////////////////////////////////////////////
0:             rm.delete(new QueryPath(cf.name()), maxTS);
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(new IdentityQueryFilter(tableName, new QueryPath(HINTS_CF))), Integer.MAX_VALUE);
commit:dd4f4be
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.IdentityQueryFilter;
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(new IdentityQueryFilter(tableName, HINTS_CF)), Integer.MAX_VALUE);
commit:4e3a440
/////////////////////////////////////////////////////////////////////////
0:         // 2. For each key read the list of recipients and send
0:         // 3. Delete that recipient from the key if write was successful
0:         // 7. I guess we are done
/////////////////////////////////////////////////////////////////////////
0:         // 2. For each key read the list of recipients if the endpoint matches send
0:         // 3. Delete that recipient from the key if write was successful
commit:0077af4
/////////////////////////////////////////////////////////////////////////
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Started deliverAllHints");
/////////////////////////////////////////////////////////////////////////
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Finished deliverAllHints");
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Started hinted handoff for endPoint " + endPoint.getHost());
/////////////////////////////////////////////////////////////////////////
0:         if (logger_.isDebugEnabled())
0:           logger_.debug("Finished hinted handoff for endpoint " + endPoint.getHost());
commit:682736e
/////////////////////////////////////////////////////////////////////////
0:     public static final String HINTS_CF = "HintsColumnFamily";
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(HINTS_CF + ":" + key + ":" + endpointAddress, timestamp);
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(tableName, HINTS_CF, new IdentityFilter()), Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintedColumnFamily = systemTable.get(tableName, HINTS_CF);
commit:5cdc75d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteEndPoint(String endpointAddress, String tableName, String key, long timestamp) throws IOException
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName);
0:         rm.delete(Table.HINTS_CF + ":" + key + ":" + endpointAddress, timestamp);
0:     private static void deleteHintedData(String tableName, String key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(tableName, key);
/////////////////////////////////////////////////////////////////////////
0:     /** hintStore must be the hints columnfamily from the system table */
0:     private static void deliverAllHints(ColumnFamilyStore hintStore) throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException
0:         logger_.debug("Started deliverAllHints");
/////////////////////////////////////////////////////////////////////////
0:         for (String tableName : DatabaseDescriptor.getTables())
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(tableName, Table.HINTS_CF, new IdentityFilter()), Integer.MAX_VALUE);
0:             if (hintColumnFamily == null)
0:                 continue;
0:             }
0:             Collection<IColumn> keys = hintColumnFamily.getAllColumns();
0:             for (IColumn keyColumn : keys)
0:             {
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 int deleted = 0;
0:                 for (IColumn endpoint : endpoints)
0:                     if (sendMessage(endpoint.name(), tableName, keyColumn.name()))
0:                         deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                         deleted++;
0:                 if (deleted == endpoints.size())
0:                 {
0:                     deleteHintedData(tableName, keyColumn.name());
0:                 }
0:         hintStore.forceFlush();
0:         hintStore.forceCompaction(null, null, 0, null);
0: 
0:         logger_.debug("Finished deliverAllHints");
0:     private static void deliverHintsToEndpoint(EndPoint endPoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
0:         Table systemTable = Table.open(Table.SYSTEM_TABLE);
0:         for (String tableName : DatabaseDescriptor.getTables())
0:             ColumnFamily hintedColumnFamily = systemTable.get(tableName, Table.HINTS_CF);
0:             if (hintedColumnFamily == null)
0:                 continue;
0:             }
0:             Collection<IColumn> keys = hintedColumnFamily.getAllColumns();
0:             for (IColumn keyColumn : keys)
0:             {
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 for (IColumn endpoint : endpoints)
0:                     if (endpoint.name().equals(endPoint.getHost()) && sendMessage(endpoint.name(), null, keyColumn.name()))
0:                         deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                         if (endpoints.size() == 1)
0:                             deleteHintedData(tableName, keyColumn.name());
0: 
0:         logger_.debug("Finished hinted handoff for endpoint " + endPoint.getHost());
/////////////////////////////////////////////////////////////////////////
0:                 try
0:                 {
0:                     deliverAllHints(columnFamilyStore);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     throw new RuntimeException(e);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 try
0:                 {
0:                     deliverHintsToEndpoint(to);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     throw new RuntimeException(e);
0:                 }
commit:cc37376
/////////////////////////////////////////////////////////////////////////
0:                 Table table = Table.open(tableName);
/////////////////////////////////////////////////////////////////////////
0:                 logger_.error("error delivering hints", ex);
/////////////////////////////////////////////////////////////////////////
0:                 Table table = Table.open(tableName);
/////////////////////////////////////////////////////////////////////////
0:                 logger_.error("Error delivering hints", ex);
commit:9aeef94
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(String endpointAddress, String tableName, String key) throws DigestMismatchException, TimeoutException, IOException, InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open(tableName);
0:         Row purgedRow = new Row(tableName,key);
0:         RowMutation rm = new RowMutation(tableName, purgedRow);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteEndPoint(String endpointAddress, String tableName, String key, long timestamp) throws Exception
0:         RowMutation rm = new RowMutation(tableName, key_);
0:     private static void deleteHintedData(String tableName, String key) throws Exception
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(tableName, key_);
0:         Table table = Table.open(tableName);
/////////////////////////////////////////////////////////////////////////
0:         for ( String tableName:DatabaseDescriptor.getTables() )
0:             Table table = Table.open(tableName);
0:             try
0:                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(table.get(key_, Table.hints_), Integer.MAX_VALUE);
0:                 if (hintColumnFamily == null)
0:                     columnFamilyStore.forceFlush();
0:                     return;
0:                 }
0:                 Collection<IColumn> keys = hintColumnFamily.getAllColumns();
0:                 if (keys == null)
0:                 {
0:                     return;
0:                 }
0: 
0:                 for (IColumn keyColumn : keys)
0:                 {
0:                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                     int deleted = 0;
0:                     for (IColumn endpoint : endpoints)
0:                         if (sendMessage(endpoint.name(), tableName, keyColumn.name()))
0:                         {
0:                             deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                             deleted++;
0:                         }
0:                     }
0:                     if (deleted == endpoints.size())
0:                     {
0:                         deleteHintedData(tableName, keyColumn.name());
0:                 columnFamilyStore.forceFlush();
0:                 columnFamilyStore.forceCompaction(null, null, 0, null);
0:             catch (Exception ex)
0:             {
0:                 logger_.error(ex.getMessage());
0:             }
0:             finally
0:             {
0:                 logger_.debug("Finished hinted handoff of " + columnFamilyStore.columnFamily_);
0:             }
/////////////////////////////////////////////////////////////////////////
0:         for ( String tableName:DatabaseDescriptor.getTables() )
0:             Table table = Table.open(tableName);
0:             try
0:                 ColumnFamily hintedColumnFamily = table.get(key_, Table.hints_);
0:                 if (hintedColumnFamily == null)
0:                     return;
0:                 }
0:                 Collection<IColumn> keys = hintedColumnFamily.getAllColumns();
0:                 if (keys == null)
0:                 {
0:                     return;
0:                 }
0: 
0:                 for (IColumn keyColumn : keys)
0:                 {
0:                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                     for (IColumn endpoint : endpoints)
0:                         if (endpoint.name().equals(endPoint.getHost()) && sendMessage(endpoint.name(), null, keyColumn.name()))
0:                             deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), keyColumn.timestamp());
0:                             if (endpoints.size() == 1)
0:                             {
0:                                 deleteHintedData(tableName, keyColumn.name());
0:                             }
0:             catch (Exception ex)
0:             {
0:                 logger_.error(ex.getMessage());
0:             }
0:             finally
0:             {
0:                 logger_.debug("Finished hinted handoff for endpoint " + endPoint.getHost());
0:             }            
commit:7acfcb0
/////////////////////////////////////////////////////////////////////////
0: public class HintedHandOffManager
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0ae07f2
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(String endpointAddress, String key) throws DigestMismatchException, TimeoutException, IOException, InvalidRequestException
commit:f17487c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     final static long intervalInMins_ = 60;
/////////////////////////////////////////////////////////////////////////
0:         Row purgedRow = new Row(key);
0:         for (ColumnFamily cf : row.getColumnFamilies())
0:         {
0:             purgedRow.addColumnFamily(ColumnFamilyStore.removeDeleted(cf));
0:         }
0:         RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), purgedRow);
0: 
0:     private static void deleteEndPoint(String endpointAddress, String key, long timestamp) throws Exception
0:         rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress, timestamp);
0:     private static void deleteHintedData(String key) throws Exception
0:         // delete the row from Application CFs: find the largest timestamp in any of
0:         // the data columns, and delete the entire CF with that value for the tombstone.
0: 
0:         // Note that we delete all data associated with the key: this may be more than
0:         // we sent earlier in sendMessage, since HH is not serialized with writes.
0:         // This is sub-optimal but okay, since HH is just an effort to make a recovering
0:         // node more consistent than it would have been; we can rely on the other
0:         // consistency mechanisms to finish the job in this corner case.
0:         Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:         Row row = table.get(key); // not necessary to do removeDeleted here
0:         Collection<ColumnFamily> cfs = row.getColumnFamilies();
0:         for (ColumnFamily cf : cfs)
0:         {
0:             Set<IColumn> columns = cf.getAllColumns();
0:             long maxTS = Long.MIN_VALUE;
0:             if (!cf.isSuper())
0:             {
0:                 for (IColumn col : columns)
0:                     maxTS = Math.max(maxTS, col.timestamp());
0:             }
0:             else
0:             {
0:                 for (IColumn col : columns)
0:                 {
0:                     maxTS = Math.max(maxTS, col.timestamp());
0:                     Collection<IColumn> subColumns = col.getSubColumns();
0:                     for (IColumn subCol : subColumns)
0:                         maxTS = Math.max(maxTS, subCol.timestamp());
0:                 }
0:             }
0:             rm.delete(cf.name(), maxTS);
0:         }
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(table.get(key_, Table.hints_), Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:                 int deleted = 0;
0:                 for (IColumn endpoint : endpoints)
0:                     if (sendMessage(endpoint.name(), keyColumn.name()))
0:                         deleteEndPoint(endpoint.name(), keyColumn.name(), keyColumn.timestamp());
0:                         deleted++;
0:                 if (deleted == endpoints.size())
0:                     deleteHintedData(keyColumn.name());
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintedColumnFamily = table.get(key_, Table.hints_);
/////////////////////////////////////////////////////////////////////////
0:                     if (endpoint.name().equals(endPoint.getHost()) && sendMessage(endpoint.name(), keyColumn.name()))
0:                         deleteEndPoint(endpoint.name(), keyColumn.name(), keyColumn.timestamp());
0:                         if (endpoints.size() == 1)
0:                             deleteHintedData(keyColumn.name());
commit:017b576
/////////////////////////////////////////////////////////////////////////
0:  * There are two ways hinted data gets delivered to the intended nodes.
0:  *
0:  * runHints() runs periodically and pushes the hinted data on this node to
0:  * every intended node.
0:  *
0:  * runDelieverHints() is called when some other node starts up (potentially
0:  * from a failure) and delivers the hinted data just to that node.
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(String endpointAddress, String key) throws DigestMismatchException, TimeoutException, IOException
0:         EndPoint endPoint = new EndPoint(endpointAddress, DatabaseDescriptor.getStoragePort());
0:         if (!FailureDetector.instance().isAlive(endPoint))
0:             return false;
0:         Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:         Row row = table.get(key);
0:         RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), row);
0:         Message message = rm.makeRowMutationMessage();
0: 
0:         QuorumResponseHandler<Boolean> quorumResponseHandler = new QuorumResponseHandler<Boolean>(1, new WriteResponseResolver());
0:         MessagingService.getMessagingInstance().sendRR(message, new EndPoint[]{ endPoint }, quorumResponseHandler);
0:         return quorumResponseHandler.get();
0:     }
0: 
0:     private static void deleteEndPoint(String endpointAddress, String key) throws Exception
0:     {
0:         RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), key_);
0:         rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress, System.currentTimeMillis());
0:         rm.apply();
0:     }
0: 
0:     private static void deleteKey(String key) throws Exception
0:     {
0:         // delete the hint record
0:         RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), key_);
0:         rm.delete(Table.hints_ + ":" + key, System.currentTimeMillis());
0:         rm.apply();
0:     }
0: 
0:     private static void deliverAllHints(ColumnFamilyStore columnFamilyStore)
0:     {
0:         logger_.debug("Started hinted handoff of " + columnFamilyStore.columnFamily_);
0: 
0:         // 1. Scan through all the keys that we need to handoff
0:         // 2. For each key read the list of recepients and send
0:         // 3. Delete that recepient from the key if write was successful
0:         // 4. If all writes were success for a given key we can even delete the key .
0:         // 5. Now force a flush
0:         // 6. Do major compaction to clean up all deletes etc.
0:         // 7. I guess we r done
0:         Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:         ColumnFamily hintColumnFamily = null;
0:         try
0:             hintColumnFamily = table.get(key_, Table.hints_);
0:             if (hintColumnFamily == null)
0:                 columnFamilyStore.forceFlush();
0:                 return;
0:             }
0:             Collection<IColumn> keys = hintColumnFamily.getAllColumns();
0:             if (keys == null)
0:             {
0:                 return;
0:             for (IColumn keyColumn : keys)
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 // endpoints could be null if the server were terminated during a previous runHints
0:                 // after deleteEndPoint but before deleteKey.
0:                 boolean allsuccess = true;
0:                 if (endpoints != null)
0:                 {
0:                     for (IColumn endpoint : endpoints)
0:                     {
0:                         if (sendMessage(endpoint.name(), keyColumn.name()))
0:                         {
0:                             deleteEndPoint(endpoint.name(), keyColumn.name());
0:                         }
0:                         else
0:                         {
0:                             allsuccess = false;
0:                         }
0:                     }
0:                 }
0:                 if (allsuccess)
0:                 {
0:                     deleteKey(keyColumn.name());
0:                 }
0:             columnFamilyStore.forceFlush();
0:             columnFamilyStore.forceCompaction(null, null, 0, null);
0:         catch (Exception ex)
0:             logger_.error(ex.getMessage());
0:         finally
0:             logger_.debug("Finished hinted handoff of " + columnFamilyStore.columnFamily_);
0:         }
0:     }
0:     private static void deliverHintsToEndpoint(EndPoint endPoint)
0:     {
0:         logger_.debug("Started hinted handoff for endPoint " + endPoint.getHost());
0: 
0:         // 1. Scan through all the keys that we need to handoff
0:         // 2. For each key read the list of recepients if teh endpoint matches send
0:         // 3. Delete that recepient from the key if write was successful
0:         Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:         ColumnFamily hintedColumnFamily = null;
0:         try
0:         {
0:             hintedColumnFamily = table.get(key_, Table.hints_);
0:             if (hintedColumnFamily == null)
0:             {
0:                 return;
0:             }
0:             Collection<IColumn> keys = hintedColumnFamily.getAllColumns();
0:             if (keys == null)
0:             {
0:                 return;
0:             }
0: 
0:             for (IColumn keyColumn : keys)
0:             {
0:                 Collection<IColumn> endpoints = keyColumn.getSubColumns();
0:                 if (endpoints == null)
0:                 {
0:                     deleteKey(keyColumn.name());
0:                     continue;
0:                 }
0:                 for (IColumn endpoint : endpoints)
0:                 {
0:                     if (endpoint.name().equals(endPoint.getHost()))
0:                     {
0:                         if (sendMessage(endpoint.name(), keyColumn.name()))
0:                         {
0:                             deleteEndPoint(endpoint.name(), keyColumn.name());
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         catch (Exception ex)
0:         {
0:             logger_.error(ex.getMessage());
0:         }
0:         finally
0:         {
0:             logger_.debug("Finished hinted handoff for endpoint " + endPoint.getHost());
/////////////////////////////////////////////////////////////////////////
0:     public void submit(final ColumnFamilyStore columnFamilyStore)
0:         Runnable r = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 deliverAllHints(columnFamilyStore);
0:             }
0:         };
0:     	executor_.scheduleWithFixedDelay(r, HintedHandOffManager.intervalInMins_, HintedHandOffManager.intervalInMins_, TimeUnit.MINUTES);
/////////////////////////////////////////////////////////////////////////
0:     public void deliverHints(final EndPoint to)
0:         Runnable r = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 deliverHintsToEndpoint(to);
0:             }
0:         };
0:     	executor_.submit(r);
commit:93abe8d
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeoutException;
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.*;
/////////////////////////////////////////////////////////////////////////
0:         private boolean sendMessage(String endpointAddress, String key) throws DigestMismatchException, TimeoutException, IOException
0:             EndPoint endPoint = new EndPoint(endpointAddress, DatabaseDescriptor.getStoragePort());
0:             if (!FailureDetector.instance().isAlive(endPoint))
0:             {
0:                 return false;
0:             }
0: 
0:             Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:             Row row = table.get(key);
0:             RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), row);
0:             Message message = rm.makeRowMutationMessage();
0: 
0:             QuorumResponseHandler<Boolean> quorumResponseHandler = new QuorumResponseHandler<Boolean>(1, new WriteResponseResolver());
0:             MessagingService.getMessagingInstance().sendRR(message, new EndPoint[]{ endPoint }, quorumResponseHandler);
0:             return quorumResponseHandler.get();
commit:71739ef
commit:ecfe313
/////////////////////////////////////////////////////////////////////////
0: import org.apache.log4j.Logger;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         	rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress, System.currentTimeMillis());
0:         	rm.delete(Table.hints_ + ":" + key, System.currentTimeMillis());
commit:6687121
/////////////////////////////////////////////////////////////////////////
0:                     columnFamilyStore_.forceFlush();
/////////////////////////////////////////////////////////////////////////
0:                 columnFamilyStore_.forceFlush();
commit:66dee7a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.log4j.Logger;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         	rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress, System.currentTimeMillis());
0:         	rm.delete(Table.hints_ + ":" + key, System.currentTimeMillis());
commit:39d3f83
/////////////////////////////////////////////////////////////////////////
0:                     columnFamilyStore_.forceFlush();
/////////////////////////////////////////////////////////////////////////
0:                 columnFamilyStore_.forceFlush();
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer key = UUIDType.instance.decompose(targetId);
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, tokenBytes, BTreeBackedRow.singleCellRow(clustering, cell));
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer key = ByteBuffer.wrap(UUIDGen.decompose(hostId));
0:         final Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(SystemKeyspace.Hints, key, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:              RowIterator iter = UnfilteredRowIterators.filter(SinglePartitionReadCommand.fullPartitionRead(SystemKeyspace.Hints, nowInSec, hostIdBytes).queryMemtableAndDisk(hintStore, op), nowInSec))
/////////////////////////////////////////////////////////////////////////
0:                                                         DataRange.allData(hintStore.metadata.partitioner));
/////////////////////////////////////////////////////////////////////////
0:         List<String> result = new ArrayList<>();
0: 
0:         try (ReadOrderGroup orderGroup = cmd.startOrderGroup();
0:              UnfilteredPartitionIterator iter = cmd.executeLocally(orderGroup))
/////////////////////////////////////////////////////////////////////////
0:                         result.add(UUIDType.instance.compose(partition.partitionKey().getKey()).toString());
0: 
commit:07893d7
/////////////////////////////////////////////////////////////////////////
0:         Range<RowPosition> range = new Range<RowPosition>(minPos, minPos);
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner partitioner = StorageService.getPartitioner();
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:c4c9eae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataInputBuffer;
/////////////////////////////////////////////////////////////////////////
0:                 DataInputPlus in = new DataInputBuffer(cell.value(), true);
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataInputPlus;
0: import org.apache.cassandra.io.util.NIODataInputStream;
/////////////////////////////////////////////////////////////////////////
0:                 DataInputPlus in = new NIODataInputStream(cell.value(), true);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(UUIDType.instance.decompose(targetId));
0:         Clustering clustering = SystemKeyspace.Hints.comparator.make(hintId, MessagingService.current_version);
0:         Cell cell = BufferCell.expiring(hintColumn, now, ttl, FBUtilities.nowInSeconds(), value);
0:         return new Mutation(PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, key, ArrayBackedRow.singleCellRow(clustering, cell)));
/////////////////////////////////////////////////////////////////////////
0:         Cell cell = BufferCell.tombstone(hintColumn, timestamp, FBUtilities.nowInSeconds());
0:         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, dk, ArrayBackedRow.singleCellRow(clustering, cell));
/////////////////////////////////////////////////////////////////////////
0:                 final long timestamp = cell.timestamp();
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.db.rows.*;
0: import org.apache.cassandra.db.partitions.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.concurrent.OpOrder;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static final int MAX_SIMULTANEOUSLY_REPLAYED_HINTS = 128;
/////////////////////////////////////////////////////////////////////////
0:     private static final ColumnDefinition hintColumn = SystemKeyspace.Hints.compactValueColumn();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         PartitionUpdate upd = new PartitionUpdate(SystemKeyspace.Hints,
0:                                                   StorageService.getPartitioner().decorateKey(UUIDType.instance.decompose(targetId)),
0:                                                   PartitionColumns.of(hintColumn),
0:                                                   1);
0: 
0:         Row.Writer writer = upd.writer();
0:         Rows.writeClustering(SystemKeyspace.Hints.comparator.make(hintId, MessagingService.current_version), writer);
0: 
0:         writer.writeCell(hintColumn, false, value, SimpleLivenessInfo.forUpdate(now, ttl, FBUtilities.nowInSeconds(), SystemKeyspace.Hints), null);
0:         writer.endOfRow();
0: 
0:         return new Mutation(upd);
/////////////////////////////////////////////////////////////////////////
0:         for (PartitionUpdate upd : mutation.getPartitionUpdates())
0:             ttl = Math.min(ttl, upd.metadata().getGcGraceSeconds());
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHint(ByteBuffer tokenBytes, Clustering clustering, long timestamp)
0:         DecoratedKey dk =  StorageService.getPartitioner().decorateKey(tokenBytes);
0: 
0:         PartitionUpdate upd = new PartitionUpdate(SystemKeyspace.Hints, dk, PartitionColumns.of(hintColumn), 1);
0: 
0:         Row.Writer writer = upd.writer();
0:         Rows.writeClustering(clustering, writer);
0:         Cells.writeTombstone(writer, hintColumn, timestamp, FBUtilities.nowInSeconds());
0: 
0:         new Mutation(upd).applyUnsafe(); // don't bother with commitlog since we're going to flush as soon as we're done with delivery
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dk =  StorageService.getPartitioner().decorateKey(ByteBuffer.wrap(UUIDGen.decompose(hostId)));
0:         final Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(SystemKeyspace.Hints, dk, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:         // Flush all the tombstones to disk
0:         hintStore.forceBlockingFlush();
0:     }
0: 
0:     private boolean checkDelivered(InetAddress endpoint, List<WriteResponseHandler<Mutation>> handlers, AtomicInteger rowsReplayed)
0:     {
0:         for (WriteResponseHandler<Mutation> handler : handlers)
0:         {
0:             try
0:             {
0:                 handler.get();
0:             }
0:             catch (WriteTimeoutException e)
0:             {
0:                 logger.info("Failed replaying hints to {}; aborting ({} delivered), error : {}",
0:                             endpoint, rowsReplayed, e.getMessage());
0:                 return false;
0:             }
0:         }
0:         return true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         int nowInSec = FBUtilities.nowInSeconds();
0:         try (OpOrder.Group op = hintStore.readOrdering.start();
0:              RowIterator iter = UnfilteredRowIterators.filter(SinglePartitionReadCommand.fullPartitionRead(SystemKeyspace.Hints, nowInSec, epkey).queryMemtableAndDisk(hintStore, op), nowInSec))
0: 
0:             while (iter.hasNext())
0:                 // check if node is still alive and we should continue delivery process
0:                 if (!FailureDetector.instance.isAlive(endpoint))
0:                 {
0:                     logger.info("Endpoint {} died during hint delivery; aborting ({} delivered)", endpoint, rowsReplayed);
0:                     return;
0:                 }
0: 
0:                     return;
0:                 // Wait regularly on the endpoint acknowledgment. If we timeout on it, the endpoint is probably dead so stop delivery
0:                 if (responseHandlers.size() > MAX_SIMULTANEOUSLY_REPLAYED_HINTS && !checkDelivered(endpoint, responseHandlers, rowsReplayed))
0:                     return;
0:                 final Row hint = iter.next();
0:                 int version = Int32Type.instance.compose(hint.clustering().get(1));
0:                 Cell cell = hint.getCell(hintColumn);
0:                 final long timestamp = cell.livenessInfo().timestamp();
0:                 DataInputStream in = new DataInputStream(ByteBufferUtil.inputStream(cell.value()));
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.clustering(), timestamp);
/////////////////////////////////////////////////////////////////////////
0:                     if (timestamp <= SystemKeyspace.getTruncatedAt(cfId))
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.clustering(), timestamp);
/////////////////////////////////////////////////////////////////////////
0:                         deleteHint(hostIdBytes, hint.clustering(), timestamp);
/////////////////////////////////////////////////////////////////////////
0:             // Wait on the last handlers
0:             if (checkDelivered(endpoint, responseHandlers, rowsReplayed))
0:                 logger.info("Finished hinted handoff of {} rows to endpoint {}", rowsReplayed, endpoint);
/////////////////////////////////////////////////////////////////////////
0:         ReadCommand cmd = new PartitionRangeReadCommand(hintStore.metadata,
0:                                                         FBUtilities.nowInSeconds(),
0:                                                         ColumnFilter.all(hintStore.metadata),
0:                                                         RowFilter.NONE,
0:                                                         DataLimits.cqlLimits(Integer.MAX_VALUE, 1),
0:                                                         DataRange.allData(StorageService.getPartitioner()));
0: 
0:         try (ReadOrderGroup orderGroup = cmd.startOrderGroup(); UnfilteredPartitionIterator iter = cmd.executeLocally(orderGroup))
0:             while (iter.hasNext())
0:             {
0:                 try (UnfilteredRowIterator partition = iter.next())
0:                 {
0:                     UUID hostId = UUIDGen.getUUID(partition.partitionKey().getKey());
0:                     InetAddress target = StorageService.instance.getTokenMetadata().getEndpointForHostId(hostId);
0:                     // token may have since been removed (in which case we have just read back a tombstone)
0:                     if (target != null)
0:                         scheduleHintDelivery(target, false);
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         ReadCommand cmd = PartitionRangeReadCommand.allDataRead(SystemKeyspace.Hints, FBUtilities.nowInSeconds());
0:         try (ReadOrderGroup orderGroup = cmd.startOrderGroup(); UnfilteredPartitionIterator iter = cmd.executeLocally(orderGroup))
0:             while (iter.hasNext())
0:             {
0:                 try (UnfilteredRowIterator partition = iter.next())
0:                 {
0:                     // We don't delete by range on the hints table, so we don't have to worry about the
0:                     // iterator returning only range tombstone marker
0:                     if (partition.hasNext())
0:                         result.addFirst(tokenFactory.toString(partition.partitionKey().getToken()));
0:                 }
0:             }
commit:6127f85
/////////////////////////////////////////////////////////////////////////
0:                || (!startColumn.isEmpty() && hintColumnFamily.getSortedColumns().size() == 1 && hintColumnFamily.getColumn((CellName)startColumn) != null);
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:             for (final Cell hint : hintsPage)
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.composites.CellName;
0: import org.apache.cassandra.db.composites.Composite;
0: import org.apache.cassandra.db.composites.Composites;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         CellName name = CFMetaData.HintsCf.comparator.makeCellName(hintId, MessagingService.current_version);
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHint(ByteBuffer tokenBytes, CellName columnName, long timestamp)
/////////////////////////////////////////////////////////////////////////
0:     private static boolean pagingFinished(ColumnFamily hintColumnFamily, Composite startColumn)
0:                || (hintColumnFamily.getSortedColumns().size() == 1 && hintColumnFamily.getColumn((CellName)startColumn) != null);
/////////////////////////////////////////////////////////////////////////
0:         Composite startColumn = Composites.EMPTY;
/////////////////////////////////////////////////////////////////////////
0:                                                             Composites.EMPTY,
/////////////////////////////////////////////////////////////////////////
0:                 int version = Int32Type.instance.compose(hint.name().get(1));
/////////////////////////////////////////////////////////////////////////
0:         IDiskAtomFilter filter = new NamesQueryFilter(ImmutableSortedSet.<CellName>of());
/////////////////////////////////////////////////////////////////////////
0:         SliceQueryFilter predicate = new SliceQueryFilter(ColumnSlice.ALL_COLUMNS_ARRAY,
commit:e48ff29
/////////////////////////////////////////////////////////////////////////
0:         List<Row> rows = hintStore.getRangeSlice(range, null, filter, Integer.MAX_VALUE, System.currentTimeMillis());
commit:e2506f1
/////////////////////////////////////////////////////////////////////////
0:     public static RowMutation hintFor(RowMutation mutation, UUID targetId)
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(SystemTable.HINTS_CF, columnName, timestamp);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(SystemTable.HINTS_CF, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             QueryFilter filter = QueryFilter.getSliceFilter(epkey, SystemTable.HINTS_CF, startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
/////////////////////////////////////////////////////////////////////////
0:             for (final Column hint : hintsPage.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:         List<Row> rows = hintStore.getRangeSlice(range, Integer.MAX_VALUE, filter, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             rows = StorageProxy.getRangeSlice(new RangeSliceCommand(Table.SYSTEM_KS, SystemTable.HINTS_CF, predicate, range, null, LARGE_NUMBER), ConsistencyLevel.ONE);
commit:ee5aafe
/////////////////////////////////////////////////////////////////////////
0:         AbstractWriteResponseHandler responseHandler = new WriteResponseHandler(endpoint, WriteType.UNLOGGED_BATCH);
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.WriteTimeoutException;
/////////////////////////////////////////////////////////////////////////
0:     private static void sendMutation(InetAddress endpoint, MessageOut<?> message) throws WriteTimeoutException
/////////////////////////////////////////////////////////////////////////
0:                 catch (WriteTimeoutException e)
commit:0042426
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.*;
/////////////////////////////////////////////////////////////////////////
0:     private List<Row> getHintsSlice(int columnCount)
0:         SliceQueryFilter predicate = new SliceQueryFilter(ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                           ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                           false,
0:                                                           columnCount);
commit:ec04fe3
commit:a4a83fc
commit:5c7ccb0
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
0: /*
/////////////////////////////////////////////////////////////////////////
commit:686139a
/////////////////////////////////////////////////////////////////////////
0:         executor.execute(r);
commit:910b663
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(HintedHandOffManager.class);
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor = new JMXEnabledThreadPoolExecutor("HintedHandoff", Thread.MIN_PRIORITY);
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("Created HHOM instance, registered MBean.");
/////////////////////////////////////////////////////////////////////////
0:             logger.warn("Unable to find "+ipOrHostname+", not a hostname or ipaddr of a node?:");
/////////////////////////////////////////////////////////////////////////
0:                     logger.info("Deleting any stored hints for " + endpoint);
0:                     logger.warn("Could not delete hints for " + endpoint + ": " + e);
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("schema for {} matches local schema", endpoint);
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("Checking remote({}) schema before delivering hints", endpoint);
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Sleeping {}ms to stagger hint delivery", sleep);
0:             logger.info("Endpoint {} died before hint delivery, aborting", endpoint);
/////////////////////////////////////////////////////////////////////////
0:         logger.info("Started hinted handoff for token: {} with IP: {}", token, endpoint);
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("average hinted-row column size is {}; using pageSize of {}", averageColumnSize, pageSize);
/////////////////////////////////////////////////////////////////////////
0:                         logger.debug("0.8-style hint found.  This should have been taken care of by purgeIncompatibleHints");
/////////////////////////////////////////////////////////////////////////
0:                     logger.info(String.format("Timed out replaying hints to %s; aborting further deliveries", endpoint));
/////////////////////////////////////////////////////////////////////////
0:         logger.info(String.format("Finished hinted handoff of %s rows to endpoint %s", rowsReplayed, endpoint));
/////////////////////////////////////////////////////////////////////////
0:         if (logger.isDebugEnabled())
0:           logger.debug("Started scheduleAllDeliveries");
/////////////////////////////////////////////////////////////////////////
0:         if (logger.isDebugEnabled())
0:           logger.debug("Finished scheduleAllDeliveries");
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("deliverHints to {}", to);
/////////////////////////////////////////////////////////////////////////
0:     	executor.execute(r);
/////////////////////////////////////////////////////////////////////////
0:             logger.info("HintsCF getEPPendingHints timed out.");
commit:38c04fe
commit:a6a4beb
/////////////////////////////////////////////////////////////////////////
0:         RowPosition minPos = p.getMinimumToken().minKeyBound();
0:         Range<RowPosition> range = new Range<RowPosition>(minPos, minPos, p);
commit:3297a96
/////////////////////////////////////////////////////////////////////////
0:         List<Row> rows = hintStore.getRangeSlice(null, range, Integer.MAX_VALUE, filter, null);
/////////////////////////////////////////////////////////////////////////
0:             rows = StorageProxy.getRangeSlice(new RangeSliceCommand("system", parent, predicate, range, null, LARGE_NUMBER), ConsistencyLevel.ONE);
commit:28568eb
/////////////////////////////////////////////////////////////////////////
0:             if (hintStore.isEmpty())
0:                 return; // nothing to do, don't confuse users by logging a no-op handoff
0: 
commit:7a26bc0
/////////////////////////////////////////////////////////////////////////
0:             if (hintStore.isEmpty())
0:                 return; // nothing to do, don't confuse users by logging a no-op handoff
0: 
commit:554223b
/////////////////////////////////////////////////////////////////////////
0:         RowPosition minPos = partitioner.getMinimumToken().minKeyBound();
0:         Range<RowPosition> range = new Range<RowPosition>(minPos, minPos);
commit:b42139c
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         if (hintStore.getSSTables().isEmpty())
0:             return; // nothing to do, don't confuse users by logging a no-op handoff
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         logger_.debug("deliverHints to {}", to);
commit:2f998d0
/////////////////////////////////////////////////////////////////////////
0:                 int sleep = FBUtilities.threadLocalRandom().nextInt(60000);
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ByteBufferUtil.bytes(ipaddr));
/////////////////////////////////////////////////////////////////////////
0:         byte[] withsep = ArrayUtils.addAll(tableName.getBytes(UTF_8), SEPARATOR.getBytes(UTF_8));
0:         int index = ByteBufferUtil.lastIndexOf(joined, SEPARATOR.getBytes(UTF_8)[0], joined.limit());
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer endpointAsUTF8 = ByteBufferUtil.bytes(endpoint.getHostAddress()); // keys have to be UTF8 to make OPP happy
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey<?> oldTableKey = StorageService.getPartitioner().decorateKey(ByteBufferUtil.bytes(oldTable));
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, ByteBufferUtil.bytes(newTable));
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:c059a56
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.WriteFailureException;
/////////////////////////////////////////////////////////////////////////
0:             List<WriteResponseHandler<Mutation>> responseHandlers = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
0:                 WriteResponseHandler<Mutation> responseHandler = new WriteResponseHandler<>(endpoint, WriteType.SIMPLE, callback);
0:             for (WriteResponseHandler<Mutation> handler : responseHandlers)
0:                 catch (WriteTimeoutException|WriteFailureException e)
0:                     logger.info("Failed replaying hints to {}; aborting ({} delivered), error : {}",
0:                         endpoint, rowsReplayed, e.getMessage());
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:8896a70
/////////////////////////////////////////////////////////////////////////
0:         int averageColumnSize = (int) (hintStore.metric.meanRowSize.getValue() / meanColumnCount);
commit:be67fda
commit:3787d6c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         int index = ByteBufferUtil.lastIndexOf(joined, SEPARATOR.getBytes()[0], joined.limit());
0:         if (index == -1 || index < (joined.position() + 1))
0:             throw new RuntimeException("Corrupted hint name " + ByteBufferUtil.string(joined));
0: 
0:         return new String[] {
0:                                 ByteBufferUtil.string(joined, joined.position(), index),
0:                                 ByteBufferUtil.string(joined, index + 1, joined.limit())
0:                             };
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:b2ecf7b
commit:06168b1
commit:c26a7e7
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void compact()
commit:5b31449
commit:54618a1
/////////////////////////////////////////////////////////////////////////
0:         for (SSTable sstable : hintStore.getDataTracker().getUncompactingSSTables())
author:Brandon Williams
-------------------------------------------------------------------------------
commit:e88bcfe
/////////////////////////////////////////////////////////////////////////
0:         if (descriptors.isEmpty())
0:             return;
0: 
commit:156e278
commit:827d93e
/////////////////////////////////////////////////////////////////////////
0:         if (descriptors.isEmpty())
0:             return;
0: 
commit:7eaedbf
commit:604e31b
/////////////////////////////////////////////////////////////////////////
0:         StorageService.optionalTasks.submit(runnable);
0:     }
0: 
0:     //foobar
0:     public void truncateAllHints() throws ExecutionException, InterruptedException
0:     {
0:         Runnable runnable = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 try
0:                 {
0:                     logger.info("Truncating all stored hints.");
0:                     Keyspace.open(Keyspace.SYSTEM_KS).getColumnFamilyStore(SystemKeyspace.HINTS_CF).truncateBlocking();
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     logger.warn("Could not truncate all hints.", e);
0:                 }
0:             }
0:         };
0:         StorageService.optionalTasks.submit(runnable).get();
0: 
commit:7950dc3
commit:27da625
/////////////////////////////////////////////////////////////////////////
0:     static final int maxHintTTL = Integer.parseInt(System.getProperty("cassandra.maxHintTTL", String.valueOf(Integer.MAX_VALUE)));
/////////////////////////////////////////////////////////////////////////
0:         int ttl = maxHintTTL;
commit:4d82ac9
commit:8a06958
commit:59bf44d
/////////////////////////////////////////////////////////////////////////
0:         while (gossiper.getEndpointStateForEndpoint(endpoint) != null && gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA) == null)
/////////////////////////////////////////////////////////////////////////
0:         if (gossiper.getEndpointStateForEndpoint(endpoint) == null)
0:             throw new TimeoutException("Node " + endpoint + " vanished while waiting for agreement");
0:         while (gossiper.getEndpointStateForEndpoint(endpoint) != null && !gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA).value.equals(
/////////////////////////////////////////////////////////////////////////
0:         if (gossiper.getEndpointStateForEndpoint(endpoint) == null)
0:             throw new TimeoutException("Node " + endpoint + " vanished while waiting for agreement");
commit:50b8bf2
commit:6d3ef44
commit:577cb2c
/////////////////////////////////////////////////////////////////////////
0:         try
0:             compact().get();
0:         }
0:         catch (Exception e)
0:         {
0:             throw new RuntimeException(e);
commit:049352f
commit:9ccaaad
/////////////////////////////////////////////////////////////////////////
0:     public static final String MBEAN_NAME = "org.apache.cassandra.db:type=HintedHandoffManager";
0:     private volatile boolean hintedHandOffPaused = false;
0: 
/////////////////////////////////////////////////////////////////////////
1:             mbs.registerMBean(this, new ObjectName(MBEAN_NAME));
/////////////////////////////////////////////////////////////////////////
0:         // check if hints delivery has been paused
0:         if (hintedHandOffPaused)
0:         {
0:             logger.debug("Hints delivery process is paused, aborting");
0:             return;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:             // check if hints delivery has been paused during the process
0:             if (hintedHandOffPaused)
0:             {
0:                 logger.debug("Hints delivery process is paused, aborting");
0:                 break;
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 if (hintedHandOffPaused)
0:                 {
0:                     logger.debug("Hints delivery process is paused, aborting");
0:                     break;
0:                 }
/////////////////////////////////////////////////////////////////////////
0:         if (hintedHandOffPaused)
0:         {
0:             logger.info("Hints delivery process is paused, not delivering further hints");
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public void pauseHintsDelivery(boolean b) {
0:         hintedHandOffPaused = b;
0:     }
0: 
commit:add2d2d
/////////////////////////////////////////////////////////////////////////
0:         UUID hostId = Gossiper.instance.getHostId(endpoint);
commit:061595f
/////////////////////////////////////////////////////////////////////////
0:                     logger.debug("Skipping delivery of hint for deleted columnfamily", e);
commit:2e79069
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily hintsPage = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), (int)(System.currentTimeMillis() / 1000));
commit:333e7ac
/////////////////////////////////////////////////////////////////////////
0:             // token may have since been removed (in which case we have just read back a tombstone)
0:             if (target != null)
0:                 scheduleHintDelivery(target);
commit:cfd9399
commit:cafeeeb
/////////////////////////////////////////////////////////////////////////
0:                     hintStore.forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
0:                 hintStore.forceBlockingFlush();
commit:80b9483
/////////////////////////////////////////////////////////////////////////
0:                 // use a 'rounded' sleep interval because of a strange bug with windows: CASSANDRA-3375
commit:6b5e7a1
/////////////////////////////////////////////////////////////////////////
0:                 int sleep = FBUtilities.threadLocalRandom().nextInt(2000) * 30;
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:                 gossiper.getEndpointStateForEndpoint(FBUtilities.getBroadcastAddress()).getApplicationState(ApplicationState.SCHEMA).value))
commit:ecbd71f
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.ApplicationState;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private int waitForSchemaAgreement(InetAddress endpoint) throws InterruptedException
0:         Gossiper gossiper = Gossiper.instance;
0:         int waited = 0;
0:         while (!gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA).value.equals(
0:                 gossiper.getEndpointStateForEndpoint(FBUtilities.getLocalAddress()).getApplicationState(ApplicationState.SCHEMA).value))
0:         {
0:             Thread.sleep(1000);
0:             waited += 1000;
0:             if (waited > 2 * StorageService.RING_DELAY)
0:                 throw new RuntimeException("Could not reach schema agreement with " + endpoint + " in " + 2 * StorageService.RING_DELAY + "ms");
0:         }
0:         logger_.debug("schema for {} matches local schema", endpoint);
0:         return waited;
0:     }
0:             
0:     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException, InterruptedException
0:     {
0:         logger_.info("Checking remote schema before delivering hints");
0:         int waited = waitForSchemaAgreement(endpoint);
0:         // sleep a random amount to stagger handoff delivery from different replicas.
0:         // (if we had to wait, then gossiper randomness took care of that for us already.)
0:         if (waited == 0) {
0:             int sleep = new Random().nextInt(60000);
0:             logger_.info("Sleeping {}ms to stagger hint delivery", sleep);
0:             Thread.sleep(sleep);
0:         }
0:         if (!Gossiper.instance.getEndpointStateForEndpoint(endpoint).isAlive())
0:         {
0:             logger_.info("Endpoint {} died before hint delivery, aborting", endpoint);
0:             return;
0:         }
0: 
commit:df3a076
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException
commit:25f1ed5
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.ApplicationState;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private int waitForSchemaAgreement(InetAddress endpoint) throws InterruptedException
0:         Gossiper gossiper = Gossiper.instance;
0:         int waited = 0;
0:         while (!gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA).value.equals(
0:                 gossiper.getEndpointStateForEndpoint(FBUtilities.getLocalAddress()).getApplicationState(ApplicationState.SCHEMA).value))
0:         {
0:             Thread.sleep(1000);
0:             waited += 1000;
0:             if (waited > 2 * StorageService.RING_DELAY)
0:                 throw new RuntimeException("Could not reach schema agreement with " + endpoint + " in " + 2 * StorageService.RING_DELAY + "ms");
0:         }
0:         logger_.debug("schema for {} matches local schema", endpoint);
0:         return waited;
0:     }
0:             
0:     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException, InterruptedException
0:     {
0:         logger_.info("Checking remote schema before delivering hints to " + endpoint);
0:         int waited = waitForSchemaAgreement(endpoint);
0:         // sleep a random amount to stagger handoff delivery from different replicas.
0:         // (if we had to wait, then gossiper randomness took care of that for us already.)
0:         if (waited == 0)
0:             Thread.sleep(new Random().nextInt(60000));
0: 
commit:2fdc5ef
/////////////////////////////////////////////////////////////////////////
1: import java.lang.management.ManagementFactory;
0: import java.util.*;
0: import static com.google.common.base.Charsets.UTF_8;
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.service.*;
0: import org.apache.cassandra.thrift.*;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0:  * The key for this row is ByteBuffer.wrap(string), i.e. "127.0.0.1".
0:  *
/////////////////////////////////////////////////////////////////////////
0: public class HintedHandOffManager implements HintedHandOffManagerMBean
0:     public static final String HINTS_CF = "HintsColumnFamily";
0:     private static final int LARGE_NUMBER = 65536; // 64k nodes ought to be enough for anybody.
0:     public HintedHandOffManager()
0:     {
1:         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
0:         try
0:         {
0:             mbs.registerMBean(this, new ObjectName("org.apache.cassandra.db:type=HintedHandoffManager"));
0:         }
0:         catch (Exception e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:     }
0:     public void registerMBean()
0:     {
0:         logger_.debug("Created HHOM instance, registered MBean.");
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     }
0:     public void deleteHintsForEndpoint(final String ipOrHostname)
0:         try
0:         {
0:             InetAddress endpoint = InetAddress.getByName(ipOrHostname);
0:             deleteHintsForEndpoint(endpoint);
0:         }
0:         catch (UnknownHostException e)
0:         {
0:             logger_.warn("Unable to find "+ipOrHostname+", not a hostname or ipaddr of a node?:");
0:             e.printStackTrace();
0:             throw new RuntimeException(e);
0:         }
0:     }
0: 
0:     public void deleteHintsForEndpoint(final InetAddress endpoint)
0:     {
0:         final String ipaddr = endpoint.getHostAddress();
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ByteBuffer.wrap(ipaddr.getBytes()));
/////////////////////////////////////////////////////////////////////////
0:                     logger_.info("Deleting any stored hints for " + ipaddr);
0:                     logger_.warn("Could not delete hints for " + ipaddr + ": " + e);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public List<String> listEndpointsPendingHints()
0:     {
0:         List<Row> rows = getHintsSlice(1);
0: 
0:         // Extract the keys as strings to be reported.
0:         LinkedList<String> result = new LinkedList<String>();
0:         for (Row r : rows)
0:         {
0:             if (r.cf != null) //ignore removed rows
0:                 result.addFirst(new String(r.key.key.array()));
0:         }
0:         return result;
0:     }
0: 
0:     public Map<String, Integer> countPendingHints()
0:     {
0:         List<Row> rows = getHintsSlice(Integer.MAX_VALUE);
0: 
0:         Map<String, Integer> result = new HashMap<String, Integer>();
0:         for (Row r : rows)
0:         {
0:             if (r.cf != null) //ignore removed rows
0:                 result.put(new String(r.key.key.array()), r.cf.getColumnCount());
0:         }
0:         return result;
0:     }
0: 
0:     private List<Row> getHintsSlice(int column_count)
0:     {
0:         // ColumnParent for HintsCF...
0:         ColumnParent parent = new ColumnParent(HINTS_CF);
0: 
0:         // Get count # of columns...
0:         SlicePredicate predicate = new SlicePredicate();
0:         SliceRange sliceRange = new SliceRange();
0:         sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
0:         sliceRange.setCount(column_count);
0:         predicate.setSlice_range(sliceRange);
0: 
0:         // From keys "" to ""...
0:         IPartitioner partitioner = StorageService.getPartitioner();
0:         ByteBuffer empty = ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:         Range range = new Range(partitioner.getToken(empty), partitioner.getToken(empty));
0: 
0:         // Get a bunch of rows!
0:         List<Row> rows;
0:         try
0:         {
0:             rows = StorageProxy.getRangeSlice(new RangeSliceCommand("system", parent, predicate, range, LARGE_NUMBER), ConsistencyLevel.ONE);
0:         }
0:         catch (Exception e)
0:         {
0:             logger_.info("HintsCF getEPPendingHints timed out.");
0:             throw new RuntimeException(e);
0:         }
0:         return rows;
0:     }
commit:e766e15
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(endpoint.getHostAddress().getBytes(UTF_8));
/////////////////////////////////////////////////////////////////////////
0:                             deleteHintKey(endpoint.getHostAddress().getBytes(UTF_8), keyColumn.name(), tableCF.name(), tableCF.clock());
commit:8a17df1
/////////////////////////////////////////////////////////////////////////
0:         byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
0:         while (true)
0:         {
0:             QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(cfs.getColumnFamilyName()), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
0:             ColumnFamily cf = cfs.getColumnFamily(filter);
0:             if (pagingFinished(cf, startColumn))
0:                 break;
0:             startColumn = cf.getColumnNames().last();
0:             RowMutation rm = new RowMutation(tableName, key);
0:             Message message = rm.makeRowMutationMessage();
0:             WriteResponseHandler responseHandler = new WriteResponseHandler(endpoint);
0:             MessagingService.instance.sendRR(message, new InetAddress[] { endpoint }, responseHandler);
0:             try
0:             {
0:                 responseHandler.get();
0:             }
0:             catch (TimeoutException e)
0:             {
0:                 return false;
0:             }
commit:cb806f5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.IClock;
/////////////////////////////////////////////////////////////////////////
0:     private static void deleteHintKey(byte[] endpointAddress, byte[] key, byte[] tableCF, IClock clock) throws IOException
0:         rm.delete(new QueryPath(HINTS_CF, key, tableCF), clock);
0:     }                                                         
/////////////////////////////////////////////////////////////////////////
0:         delivery:
0:             while (true)
0:                 QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
0:                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:                 if (pagingFinished(hintColumnFamily, startColumn))
0:                     break;
0:                 Collection<IColumn> keyColumns = hintColumnFamily.getSortedColumns();
0:                 for (IColumn keyColumn : keyColumns)
0:                     Collection<IColumn> tableCFs = keyColumn.getSubColumns();
0:                     for (IColumn tableCF : tableCFs)
0:                     {
0:                         String[] parts = getTableAndCFNames(tableCF.name());
0:                         if (sendMessage(endpoint, parts[0], parts[1], keyColumn.name()))
0:                         {
0:                             deleteHintKey(endpoint.getAddress(), keyColumn.name(), tableCF.name(), tableCF.clock());
0:                             rowsReplayed++;
0:                         }
0:                         else
0:                         {
0:                             logger_.info("Could not complete hinted handoff to " + endpoint);
0:                             break delivery;
0:                         }
0: 
0:                         startColumn = keyColumn.name();
0:                     }
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:49768fe
commit:0705e8a
commit:f25da97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.JVMStabilityInspector;
/////////////////////////////////////////////////////////////////////////
0:                     JVMStabilityInspector.inspectThrowable(e);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:93c99a6
/////////////////////////////////////////////////////////////////////////
0:                     logger.debug("Skipping delivery of hint for deleted table", e);
/////////////////////////////////////////////////////////////////////////
0:                         logger.debug("Skipping delivery of hint for truncated table {}", cfId);
commit:cd6aa2d
/////////////////////////////////////////////////////////////////////////
0:                         logger.debug("Skipping delivery of hint for truncated columnfamily {}", cfId);
commit:d60ead8
/////////////////////////////////////////////////////////////////////////
0:             Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
/////////////////////////////////////////////////////////////////////////
0:                 truncationTimesCache.clear();
commit:647e067
/////////////////////////////////////////////////////////////////////////
0:             Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
/////////////////////////////////////////////////////////////////////////
0:                 truncationTimesCache.clear();
commit:f1c9bc6
/////////////////////////////////////////////////////////////////////////
0:     protected Future<?> compact()
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:             UUID hostId = UUIDGen.getUUID(row.key.getKey());
/////////////////////////////////////////////////////////////////////////
0:                 result.addFirst(tokenFactory.toString(row.key.getToken()));
commit:203b3ad
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.util.concurrent.RateLimiter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // rate limit is in bytes per second. Uses Double.MAX_VALUE if disabled (set to 0 in cassandra.yaml).
0:         int throttleInKB = DatabaseDescriptor.getHintedHandoffThrottleInKB();
0:         RateLimiter rateLimiter = RateLimiter.create(throttleInKB == 0 ? Double.MAX_VALUE : throttleInKB * 1024);
0: 
/////////////////////////////////////////////////////////////////////////
0:                         rateLimiter.acquire(message.serializedSize(MessagingService.current_version));
commit:9a336a1
commit:710609b
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:f2be80c
/////////////////////////////////////////////////////////////////////////
0: 
0:         InetAddress endpoint = StorageService.instance.getTokenMetadata().getEndpointForHostId(targetId);
0:         // during tests we may not have a matching endpoint, but this would be unexpected in real clusters
0:         if (endpoint != null)
0:             metrics.incrCreatedHints(endpoint);
0:         else
0:             logger.warn("Unable to find matching endpoint for target {} when storing a hint", targetId);
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:f56f08c
commit:60acf0d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.metrics.HintedHandoffMetrics;
/////////////////////////////////////////////////////////////////////////
0:     public final HintedHandoffMetrics metrics = new HintedHandoffMetrics();
0: 
/////////////////////////////////////////////////////////////////////////
0:                 metrics.log();
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:5467fb5
/////////////////////////////////////////////////////////////////////////
0:                                                                                  new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY), "internal");
commit:587cb58
/////////////////////////////////////////////////////////////////////////
0:                     rm = RowMutation.serializer.deserialize(in, ByteBufferUtil.toInt(versionColumn.value()));
author:Eric Evans
-------------------------------------------------------------------------------
commit:7cb3b73
/////////////////////////////////////////////////////////////////////////
0:             UUID hostId = UUIDGen.getUUID(row.key.key);
0:             InetAddress target = StorageService.instance.getTokenMetadata().getEndpointForHostId(hostId);
commit:0a5267e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.UUIDGen;
/////////////////////////////////////////////////////////////////////////
0:         UUID hostId = StorageService.instance.getTokenMetadata().getHostId(endpoint);
0:         ByteBuffer hostIdBytes = ByteBuffer.wrap(UUIDGen.decompose(hostId));
0:         final RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, hostIdBytes);
/////////////////////////////////////////////////////////////////////////
0:         UUID hostId = StorageService.instance.getTokenMetadata().getHostId(endpoint);
0:         logger.info("Started hinted handoff for host: {} with IP: {}", hostId, endpoint);
0:         ByteBuffer hostIdBytes = ByteBuffer.wrap(UUIDGen.decompose(hostId));
0:         DecoratedKey epkey =  StorageService.getPartitioner().decorateKey(hostIdBytes);
0: 
/////////////////////////////////////////////////////////////////////////
0:                         deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
/////////////////////////////////////////////////////////////////////////
0:                     deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
commit:542bd79
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.thrift.InvalidRequestException;
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:4e11242
commit:e6d74c1
/////////////////////////////////////////////////////////////////////////
0:         // first, wait for schema to be gossiped.
0:         while (gossiper.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.SCHEMA) == null) {
0:             Thread.sleep(1000);
0:             waited += 1000;
0:             if (waited > 2 * StorageService.RING_DELAY)
0:                 throw new RuntimeException("Didin't receive gossiped schema from " + endpoint + " in " + 2 * StorageService.RING_DELAY + "ms");
0:         }
0:         waited = 0;
0:         // then wait for the correct schema version.
commit:5d02c51
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendRR(rm, endpoint, responseHandler);
commit:434564d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
0: import static org.apache.cassandra.utils.FBUtilities.UTF8;
/////////////////////////////////////////////////////////////////////////
0:     private static boolean sendMessage(InetAddress endPoint, String tableName, byte[] key) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dkey = StorageService.getPartitioner().decorateKey(key);
0:             ColumnFamily cf = cfstore.getColumnFamily(QueryFilter.getIdentityFilter(dkey, new QueryPath(cfstore.getColumnFamilyName())));
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
/////////////////////////////////////////////////////////////////////////
0:             DecoratedKey tableNameKey = StorageService.getPartitioner().decorateKey(tableName.getBytes(UTF8));
0:                 QueryFilter filter = QueryFilter.getSliceFilter(tableNameKey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:                     byte[] keyBytes = keyColumn.name();
0:                         if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyBytes))
/////////////////////////////////////////////////////////////////////////
0:             DecoratedKey tableNameKey = StorageService.getPartitioner().decorateKey(tableName.getBytes(UTF8));
0:                 QueryFilter filter = QueryFilter.getSliceFilter(tableNameKey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:                     byte[] keyBytes = keyColumn.name();
0:                         if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, tableName, keyBytes))
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey oldTableKey = StorageService.getPartitioner().decorateKey(oldTable.getBytes(UTF8));
/////////////////////////////////////////////////////////////////////////
0:             QueryFilter filter = QueryFilter.getSliceFilter(oldTableKey, new QueryPath(HINTS_CF), startCol, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, newTable.getBytes(UTF8));
0:             RowMutation drop = new RowMutation(Table.SYSTEM_TABLE, oldTableKey.key);
commit:a89fd2a
/////////////////////////////////////////////////////////////////////////
0:     /** called when a keyspace is dropped or rename. newTable==null in the case of a drop. */
0:     public static void renameHints(String oldTable, String newTable) throws IOException
0:     {
0:         // we're basically going to fetch, drop and add the scf for the old and new table. we need to do it piecemeal 
0:         // though since there could be GB of data.
0:         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
0:         byte[] startCol = ArrayUtils.EMPTY_BYTE_ARRAY;
0:         long now = System.currentTimeMillis();
0:         while (true)
0:         {
0:             QueryFilter filter = QueryFilter.getSliceFilter(oldTable, new QueryPath(HINTS_CF), startCol, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
0:             ColumnFamily cf = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
0:             if (pagingFinished(cf, startCol))
0:                 break;
0:             if (newTable != null)
0:             {
0:                 RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, newTable);
0:                 insert.add(cf);
0:                 insert.apply();
0:             }
0:             RowMutation drop = new RowMutation(Table.SYSTEM_TABLE, oldTable);
0:             for (byte[] key : cf.getColumnNames())
0:             {
0:                 drop.delete(new QueryPath(HINTS_CF, key), now);
0:                 startCol = key;
0:             }
0:             drop.apply();
0:         }
0:     }
0: 
commit:0095f0c
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger_ = LoggerFactory.getLogger(HintedHandOffManager.class);
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
0:         WriteResponseHandler responseHandler = new WriteResponseHandler(1, tableName);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:964dd9b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.IResponseResolver;
0: import org.apache.cassandra.service.QuorumResponseHandler;
0: import org.apache.cassandra.service.WriteResponseResolver;
0: import org.apache.log4j.Logger;
/////////////////////////////////////////////////////////////////////////
0:         	rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress);
0:         	rm.delete(Table.hints_ + ":" + key);
/////////////////////////////////////////////////////////////////////////
0:                     columnFamilyStore_.forceFlush(false);
/////////////////////////////////////////////////////////////////////////
0:                 columnFamilyStore_.forceFlush(false);
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import java.util.Collection;
0: import java.util.concurrent.ScheduledExecutorService;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.locks.Lock;
0: import java.util.concurrent.locks.ReentrantLock;
0: 
0: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
0: import org.apache.cassandra.concurrent.ThreadFactoryImpl;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.gms.FailureDetector;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.IComponentShutdown;
0: import org.apache.cassandra.service.IResponseResolver;
0: import org.apache.cassandra.service.QuorumResponseHandler;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.service.WriteResponseResolver;
0: import org.apache.log4j.Logger;
0: 
0: 
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class HintedHandOffManager implements IComponentShutdown
0: {
0:     private static HintedHandOffManager instance_;
0:     private static Lock lock_ = new ReentrantLock();
0:     private static Logger logger_ = Logger.getLogger(HintedHandOffManager.class);
0:     public static final String key_ = "HintedHandOffKey";
0:     final static long intervalInMins_ = 20;
0:     private ScheduledExecutorService executor_ = new DebuggableScheduledThreadPoolExecutor(1, new ThreadFactoryImpl("HINTED-HANDOFF-POOL"));
0: 
0: 
0:     public static HintedHandOffManager instance()
0:     {
0:         if ( instance_ == null )
0:         {
0:             lock_.lock();
0:             try
0:             {
0:                 if ( instance_ == null )
0:                     instance_ = new HintedHandOffManager();
0:             }
0:             finally
0:             {
0:                 lock_.unlock();
0:             }
0:         }
0:         return instance_;
0:     }
0: 
0:     class HintedHandOff implements Runnable
0:     {
0:         private ColumnFamilyStore columnFamilyStore_ = null;
0:         private EndPoint endPoint_ = null;
0: 
0:         HintedHandOff(ColumnFamilyStore columnFamilyStore)
0:         {
0:         	columnFamilyStore_ = columnFamilyStore;
0:         }
0:         HintedHandOff(EndPoint endPoint)
0:         {
0:         	endPoint_ = endPoint;
0:         }
0: 
0:         private boolean sendMessage(String endpointAddress, String key) throws Exception
0:         {
0:         	boolean success = false; // TODO : fix the hack we need to make sure the data is written on the other end.
0:         	if(FailureDetector.instance().isAlive(new EndPoint(endpointAddress, DatabaseDescriptor.getControlPort())))
0:         	{
0:         		success = true;
0:         	}
0:         	else
0:         	{
0:         		return success;
0:         	}
0:         	Table table = Table.open(DatabaseDescriptor.getTables().get(0));
0:         	Row row = null;
0:         	row = table.get(key);
0:         	RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), row);
0: 			RowMutationMessage rmMsg = new RowMutationMessage(rm);
0: 			Message message = RowMutationMessage.makeRowMutationMessage( rmMsg );
0: 			EndPoint endPoint = new EndPoint(endpointAddress, DatabaseDescriptor.getStoragePort());
0: 			MessagingService.getMessagingInstance().sendOneWay(message, endPoint);
0: 			return success;
0:         }
0: 
0:         private void deleteEndPoint(String endpointAddress, String key) throws Exception
0:         {
0:         	RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), key_);
0:         	rm.delete(Table.hints_ + ":" + key + ":" + endpointAddress);
0:         	rm.apply();
0:         }
0: 
0:         private void deleteKey(String key) throws Exception
0:         {
0:         	RowMutation rm = new RowMutation(DatabaseDescriptor.getTables().get(0), key_);
0:         	rm.delete(Table.hints_ + ":" + key);
0:         	rm.apply();
0:         }
0: 
0:         private void runHints()
0:         {
0:             logger_.debug("Started  hinted handoff " + columnFamilyStore_.columnFamily_);
0: 
0:             // 1. Scan through all the keys that we need to handoff
0:             // 2. For each key read the list of recepients and send
0:             // 3. Delete that recepient from the key if write was successful
0:             // 4. If all writes were success for a given key we can even delete the key .
0:             // 5. Now force a flush
0:             // 6. Do major compaction to clean up all deletes etc.
0:             // 7. I guess we r done
0:             Table table =  Table.open(DatabaseDescriptor.getTables().get(0));
0:             ColumnFamily hintedColumnFamily = null;
0:             boolean success = false;
0:             boolean allsuccess = true;
0:             try
0:             {
0:             	hintedColumnFamily = table.get(key_, Table.hints_);
0:             	if(hintedColumnFamily == null)
0:             	{
0:                     // Force flush now
0:                     columnFamilyStore_.forceFlush(false);
0:             		return;
0:             	}
0:             	Collection<IColumn> keys = hintedColumnFamily.getAllColumns();
0:             	if(keys != null)
0:             	{
0:                 	for(IColumn key : keys)
0:                 	{
0:                 		// Get all the endpoints for teh key
0:                 		Collection<IColumn> endpoints =  key.getSubColumns();
0:                 		allsuccess = true;
0:                 		if ( endpoints != null )
0:                 		{
0:                 			for(IColumn endpoint : endpoints )
0:                 			{
0:                 				success = sendMessage(endpoint.name(), key.name());
0:                 				if(success)
0:                 				{
0:                 					// Delete the endpoint from the list
0:                 					deleteEndPoint(endpoint.name(), key.name());
0:                 				}
0:                 				else
0:                 				{
0:                 					allsuccess = false;
0:                 				}
0:                 			}
0:                 		}
0:                 		if(endpoints == null || allsuccess)
0:                 		{
0:                 			// Delete the key itself.
0:                 			deleteKey(key.name());
0:                 		}
0:                 	}
0:             	}
0:                 // Force flush now
0:                 columnFamilyStore_.forceFlush(false);
0: 
0:                 // Now do a major compaction
0:                 columnFamilyStore_.forceCompaction(null, null, 0, null);
0:             }
0:             catch ( Exception ex)
0:             {
0:             	logger_.warn(ex.getMessage());
0:             }
0:             logger_.debug("Finished hinted handoff ..."+columnFamilyStore_.columnFamily_);
0:         }
0: 
0:         private void runDeliverHints(EndPoint to)
0:         {
0:             logger_.debug("Started  hinted handoff for endPoint " + endPoint_.getHost());
0: 
0:             // 1. Scan through all the keys that we need to handoff
0:             // 2. For each key read the list of recepients if teh endpoint matches send
0:             // 3. Delete that recepient from the key if write was successful
0: 
0:             Table table =  Table.open(DatabaseDescriptor.getTables().get(0));
0:             ColumnFamily hintedColumnFamily = null;
0:             boolean success = false;
0:             try
0:             {
0:             	hintedColumnFamily = table.get(key_, Table.hints_);
0:             	if(hintedColumnFamily == null)
0:             		return;
0:             	Collection<IColumn> keys = hintedColumnFamily.getAllColumns();
0:             	if(keys != null)
0:             	{
0:                 	for(IColumn key : keys)
0:                 	{
0:                 		// Get all the endpoints for teh key
0:                 		Collection<IColumn> endpoints =  key.getSubColumns();
0:                 		if ( endpoints != null )
0:                 		{
0:                 			for(IColumn endpoint : endpoints )
0:                 			{
0:                 				if(endpoint.name().equals(endPoint_.getHost()))
0:                 				{
0: 	                				success = sendMessage(endpoint.name(), key.name());
0: 	                				if(success)
0: 	                				{
0: 	                					// Delete the endpoint from the list
0: 	                					deleteEndPoint(endpoint.name(), key.name());
0: 	                				}
0:                 				}
0:                 			}
0:                 		}
0:                 		if(endpoints == null)
0:                 		{
0:                 			// Delete the key itself.
0:                 			deleteKey(key.name());
0:                 		}
0:                 	}
0:             	}
0:             }
0:             catch ( Exception ex)
0:             {
0:             	logger_.warn(ex.getMessage());
0:             }
0:             logger_.debug("Finished hinted handoff for endpoint ..." + endPoint_.getHost());
0:         }
0: 
0:         public void run()
0:         {
0:         	if(endPoint_ == null)
0:         	{
0:         		runHints();
0:         	}
0:         	else
0:         	{
0:         		runDeliverHints(endPoint_);
0:         	}
0: 
0:         }
0:     }
0: 
0:     public HintedHandOffManager()
0:     {
0:     	StorageService.instance().registerComponentForShutdown(this);
0:     }
0: 
0:     public void submit(ColumnFamilyStore columnFamilyStore)
0:     {
0:     	executor_.scheduleWithFixedDelay(new HintedHandOff(columnFamilyStore), HintedHandOffManager.intervalInMins_,
0:     			HintedHandOffManager.intervalInMins_, TimeUnit.MINUTES);
0:     }
0: 
0:     /*
0:      * This method is used to deliver hints to a particular endpoint.
0:      * When we learn that some endpoint is back up we deliver the data
0:      * to him via an event driven mechanism.
0:     */
0:     public void deliverHints(EndPoint to)
0:     {
0:     	executor_.submit(new HintedHandOff(to));
0:     }
0: 
0:     public void shutdown()
0:     {
0:     	executor_.shutdownNow();
0:     }
0: }
============================================================================