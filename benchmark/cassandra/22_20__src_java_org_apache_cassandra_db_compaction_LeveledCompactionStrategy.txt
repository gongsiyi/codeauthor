1:d01f8dd: /*
1:d01f8dd:  * Licensed to the Apache Software Foundation (ASF) under one
1:d01f8dd:  * or more contributor license agreements.  See the NOTICE file
1:d01f8dd:  * distributed with this work for additional information
1:d01f8dd:  * regarding copyright ownership.  The ASF licenses this file
1:d01f8dd:  * to you under the Apache License, Version 2.0 (the
1:d01f8dd:  * "License"); you may not use this file except in compliance
1:d01f8dd:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
3:07cdfd0:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:d90f0f3:  */
1:07cf56f: package org.apache.cassandra.db.compaction;
1:d01f8dd: 
1:910170c: import java.util.*;
1:37f5175: 
1:aab97ff: 
1:b8874ad: import com.google.common.annotations.VisibleForTesting;
1:46e422a: import com.google.common.base.Joiner;
1:46e422a: import com.google.common.collect.*;
1:0091af9: import com.google.common.primitives.Doubles;
1:910170c: 
1:f0ee59d: import org.slf4j.Logger;
1:f0ee59d: import org.slf4j.LoggerFactory;
1:aab97ff: 
1:8a97969: import org.apache.cassandra.config.CFMetaData;
1:b3a4e20: import org.apache.cassandra.config.Config;
1:f0ee59d: import org.apache.cassandra.db.ColumnFamilyStore;
1:e5a76bd: import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
1:a991b64: import org.apache.cassandra.db.rows.UnfilteredRowIterator;
1:46e422a: import org.apache.cassandra.dht.Range;
1:46e422a: import org.apache.cassandra.dht.Token;
1:360d1a2: import org.apache.cassandra.exceptions.ConfigurationException;
1:910170c: import org.apache.cassandra.io.sstable.ISSTableScanner;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:e16d8a7: import org.codehaus.jackson.JsonNode;
1:e16d8a7: import org.codehaus.jackson.node.JsonNodeFactory;
1:e16d8a7: import org.codehaus.jackson.node.ObjectNode;
2:9361543: 
1:e16f584: public class LeveledCompactionStrategy extends AbstractCompactionStrategy
1:9fc14bc: {
1:f0ee59d:     private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);
1:ca63545:     private static final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
1:b3a4e20:     private static final boolean tolerateSstableSize = Boolean.getBoolean(Config.PROPERTY_PREFIX + "tolerate_sstable_size");
1:9fc14bc:     private static final String LEVEL_FANOUT_SIZE_OPTION = "fanout_size";
1:9fc14bc:     public static final int DEFAULT_LEVEL_FANOUT_SIZE = 10;
1:ca63545: 
1:b8874ad:     @VisibleForTesting
1:b8874ad:     final LeveledManifest manifest;
1:84a461a:     private final int maxSSTableSizeInMB;
1:9fc14bc:     private final int levelFanoutSize;
1:46e422a: 
1:f0ee59d:     public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)
1:68d2526:     {
1:f0ee59d:         super(cfs, options);
1:e7ea389:         int configuredMaxSSTableSize = 160;
1:9fc14bc:         int configuredLevelFanoutSize = DEFAULT_LEVEL_FANOUT_SIZE;
1:6968f68:         SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);
1:f19610c:         if (options != null)
1:b3a4e20:         {             
1:b3a4e20:             if (options.containsKey(SSTABLE_SIZE_OPTION))             
1:b3a4e20:             {                 
1:b3a4e20:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));                 
1:b3a4e20:                 if (!tolerateSstableSize)
1:b3a4e20:                 {                     
1:c5368c7:                     if (configuredMaxSSTableSize >= 1000)
1:c5368c7:                         logger.warn("Max sstable size of {}MB is configured for {}.{}; having a unit of compaction this large is probably a bad idea",
1:f19610c:                                 configuredMaxSSTableSize, cfs.name, cfs.getColumnFamilyName());
1:68d2526:                     if (configuredMaxSSTableSize < 50)
1:c5368c7:                         logger.warn("Max sstable size of {}MB is configured for {}.{}.  Testing done for CASSANDRA-5727 indicates that performance improves up to 160MB",
1:f19610c:                                 configuredMaxSSTableSize, cfs.name, cfs.getColumnFamilyName());
1:65059cf:                 }
1:a7b7214:             }
1:9fc14bc: 
1:9fc14bc:             if (options.containsKey(LEVEL_FANOUT_SIZE_OPTION))
1:a7b7214:             {
1:9fc14bc:                 configuredLevelFanoutSize = Integer.parseInt(options.get(LEVEL_FANOUT_SIZE_OPTION));
1:9fc14bc:             }
1:048c8a9:         }
1:84a461a:         maxSSTableSizeInMB = configuredMaxSSTableSize;
1:9fc14bc:         levelFanoutSize = configuredLevelFanoutSize;
1:278a5e8: 
1:9fc14bc:         manifest = new LeveledManifest(cfs, this.maxSSTableSizeInMB, this.levelFanoutSize, localOptions);
1:4a849ef:         logger.trace("Created {}", manifest);
1:d01f8dd:     }
1:0e28478: 
1:f0ee59d:     public int getLevelSize(int i)
1:6808e75:     {
1:f0ee59d:         return manifest.getLevelSize(i);
1:e7ea389:     }
1:46e422a: 
1:c64d975:     public int[] getAllLevelSize()
1:68d2526:     {
1:c64d975:         return manifest.getAllLevelSize();
1:d2f43e4:     }
1:46e422a: 
1:a90b98e:     @Override
1:6808e75:     public void startup()
1:a90b98e:     {
1:6808e75:         manifest.calculateLastCompactedKeys();
1:6808e75:         super.startup();
1:6808e75:     }
1:6808e75: 
1:37f5175:     /**
1:d90f0f3:      * the only difference between background and maximal in LCS is that maximal is still allowed
1:d90f0f3:      * (by explicit user request) even when compaction is disabled.
1:d01f8dd:      */
1:05660a5:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
1:ed0a07c:     public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
1:68d2526:     {
1:686f516:         while (true)
1:f19610c:         {
1:75d5639:             OperationType op;
1:ecec863:             LeveledManifest.CompactionCandidate candidate = manifest.getCompactionCandidates();
1:ecec863:             if (candidate == null)
1:f19610c:             {
1:686f516:                 // if there is no sstable to compact in standard way, try compacting based on droppable tombstone ratio
1:686f516:                 SSTableReader sstable = findDroppableSSTable(gcBefore);
1:686f516:                 if (sstable == null)
1:f19610c:                 {
1:4a849ef:                     logger.trace("No compaction necessary for {}", this);
1:a5d095e:                     return null;
1:b44683c:                 }
1:ecec863:                 candidate = new LeveledManifest.CompactionCandidate(Collections.singleton(sstable),
1:ecec863:                                                                     sstable.getSSTableLevel(),
1:ecec863:                                                                     getMaxSSTableBytes());
1:686f516:                 op = OperationType.TOMBSTONE_COMPACTION;
1:98b9cb4:             }
1:0e83100:             else
1:65059cf:             {
1:75d5639:                 op = OperationType.COMPACTION;
1:03f0116:             }
1:360d1a2: 
1:e5a76bd:             LifecycleTransaction txn = cfs.getTracker().tryModify(candidate.sstables, OperationType.COMPACTION);
1:e5a76bd:             if (txn != null)
1:048c8a9:             {
1:e5a76bd:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, txn, candidate.level, gcBefore, candidate.maxSSTableBytes, false);
1:686f516:                 newTask.setCompactionType(op);
1:910170c:                 return newTask;
1:686f516:             }
1:686f516:         }
1:278a5e8:     }
1:b44683c: 
1:05660a5:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
1:910170c:     public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefore, boolean splitOutput)
1:910170c:     {
1:910170c:         Iterable<SSTableReader> sstables = manifest.getAllSSTables();
1:910170c: 
1:910170c:         Iterable<SSTableReader> filteredSSTables = filterSuspectSSTables(sstables);
1:910170c:         if (Iterables.isEmpty(sstables))
1:910170c:             return null;
1:e5a76bd:         LifecycleTransaction txn = cfs.getTracker().tryModify(filteredSSTables, OperationType.COMPACTION);
1:e5a76bd:         if (txn == null)
1:910170c:             return null;
1:e5a76bd:         return Arrays.<AbstractCompactionTask>asList(new LeveledCompactionTask(cfs, txn, 0, gcBefore, getMaxSSTableBytes(), true));
1:910170c: 
1:910170c:     }
1:910170c: 
1:6808e75:     @Override
1:05660a5:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
1:f0ee59d:     public AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
1:b44683c:     {
1:a5d095e: 
1:a5d095e:         if (sstables.isEmpty())
1:a7b7214:             return null;
1:d40ac78: 
1:d40ac78:         LifecycleTransaction transaction = cfs.getTracker().tryModify(sstables, OperationType.COMPACTION);
1:d40ac78:         if (transaction == null)
1:d40ac78:         {
1:d40ac78:             logger.trace("Unable to mark {} for compaction; probably a background compaction got to it first.  You can disable background compactions temporarily if this is a problem", sstables);
1:d40ac78:             return null;
1:d40ac78:         }
1:a5d095e:         int level = sstables.size() > 1 ? 0 : sstables.iterator().next().getSSTableLevel();
1:a5d095e:         return new LeveledCompactionTask(cfs, transaction, level, gcBefore, level == 0 ? Long.MAX_VALUE : getMaxSSTableBytes(), false);
1:5bd57cb:     }
1:d90f0f3: 
1:0368e97:     @Override
1:e5a76bd:     public AbstractCompactionTask getCompactionTask(LifecycleTransaction txn, int gcBefore, long maxSSTableBytes)
1:e7ea389:     {
1:e5a76bd:         assert txn.originals().size() > 0;
1:a90b98e:         int level = -1;
1:a90b98e:         // if all sstables are in the same level, we can set that level:
1:e5a76bd:         for (SSTableReader sstable : txn.originals())
1:a90b98e:         {
1:a90b98e:             if (level == -1)
1:a90b98e:                 level = sstable.getSSTableLevel();
1:a90b98e:             if (level != sstable.getSSTableLevel())
1:a90b98e:                 level = 0;
1:a90b98e:         }
1:e5a76bd:         return new LeveledCompactionTask(cfs, txn, level, gcBefore, maxSSTableBytes, false);
1:a90b98e:     }
1:a90b98e: 
1:d90f0f3:     /**
1:37f5175:      * Leveled compaction strategy has guarantees on the data contained within each level so we
1:37f5175:      * have to make sure we only create groups of SSTables with members from the same level.
1:37f5175:      * This way we won't end up creating invalid sstables during anti-compaction.
1:37f5175:      * @param ssTablesToGroup
1:37f5175:      * @return Groups of sstables from the same level
1:37f5175:      */
1:37f5175:     @Override
1:37f5175:     public Collection<Collection<SSTableReader>> groupSSTablesForAntiCompaction(Collection<SSTableReader> ssTablesToGroup)
1:37f5175:     {
1:37f5175:         int groupSize = 2;
1:37f5175:         Map<Integer, Collection<SSTableReader>> sstablesByLevel = new HashMap<>();
1:37f5175:         for (SSTableReader sstable : ssTablesToGroup)
1:37f5175:         {
1:37f5175:             Integer level = sstable.getSSTableLevel();
1:0a56037:             Collection<SSTableReader> sstablesForLevel = sstablesByLevel.get(level);
1:0a56037:             if (sstablesForLevel == null)
1:37f5175:             {
1:0a56037:                 sstablesForLevel = new ArrayList<SSTableReader>();
1:0a56037:                 sstablesByLevel.put(level, sstablesForLevel);
1:37f5175:             }
1:0a56037:             sstablesForLevel.add(sstable);
1:37f5175:         }
1:37f5175: 
1:37f5175:         Collection<Collection<SSTableReader>> groupedSSTables = new ArrayList<>();
1:37f5175: 
1:37f5175:         for (Collection<SSTableReader> levelOfSSTables : sstablesByLevel.values())
1:37f5175:         {
1:37f5175:             Collection<SSTableReader> currGroup = new ArrayList<>();
1:37f5175:             for (SSTableReader sstable : levelOfSSTables)
1:37f5175:             {
1:37f5175:                 currGroup.add(sstable);
1:37f5175:                 if (currGroup.size() == groupSize)
1:37f5175:                 {
1:37f5175:                     groupedSSTables.add(currGroup);
1:37f5175:                     currGroup = new ArrayList<>();
1:37f5175:                 }
1:37f5175:             }
1:37f5175: 
1:37f5175:             if (currGroup.size() != 0)
1:37f5175:                 groupedSSTables.add(currGroup);
1:37f5175:         }
1:37f5175:         return groupedSSTables;
1:37f5175: 
1:37f5175:     }
1:37f5175: 
1:f0ee59d:     public int getEstimatedRemainingTasks()
1:d2f43e4:     {
1:e16d8a7:         int n = manifest.getEstimatedTasks();
1:e16d8a7:         cfs.getCompactionStrategyManager().compactionLogger.pending(this, n);
1:e16d8a7:         return n;
1:75d5639:     }
1:d90f0f3: 
1:ecec863:     public long getMaxSSTableBytes()
1:98b9cb4:     {
1:8aeb2fe:         return maxSSTableSizeInMB * 1024L * 1024L;
1:0e28478:     }
1:46e422a: 
1:9fc14bc:     public int getLevelFanoutSize()
1:9fc14bc:     {
1:9fc14bc:         return levelFanoutSize;
1:9fc14bc:     }
1:9fc14bc: 
1:9b48a0b:     public ScannerList getScanners(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
1:03f0116:     {
1:cc75de6:         Set<SSTableReader>[] sstablesPerLevel = manifest.getSStablesPerLevelSnapshot();
1:cc75de6: 
1:46e422a:         Multimap<Integer, SSTableReader> byLevel = ArrayListMultimap.create();
1:a90b98e:         for (SSTableReader sstable : sstables)
1:a7b7214:         {
1:cc75de6:             int level = sstable.getSSTableLevel();
1:cc75de6:             // if an sstable is not on the manifest, it was recently added or removed
1:cc75de6:             // so we add it to level -1 and create exclusive scanners for it - see below (#9935)
1:cc75de6:             if (level >= sstablesPerLevel.length || !sstablesPerLevel[level].contains(sstable))
1:cc75de6:             {
1:cc75de6:                 logger.warn("Live sstable {} from level {} is not on corresponding level in the leveled manifest." +
1:cc75de6:                             " This is not a problem per se, but may indicate an orphaned sstable due to a failed" +
1:cc75de6:                             " compaction not cleaned up properly.",
1:cc75de6:                              sstable.getFilename(), level);
1:cc75de6:                 level = -1;
1:a7b7214:             }
1:cc75de6:             byLevel.get(level).add(sstable);
1:cc75de6:         }
1:46e422a: 
1:1fec4a4:         List<ISSTableScanner> scanners = new ArrayList<ISSTableScanner>(sstables.size());
1:0e83100:         try
1:75d5639:         {
1:0e83100:             for (Integer level : byLevel.keySet())
1:686f516:             {
1:e5a76bd:                 // level can be -1 when sstables are added to Tracker but not to LeveledManifest
1:0e83100:                 // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
1:0e83100:                 if (level <= 0)
1:0e83100:                 {
1:0e83100:                     // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
1:0e83100:                     for (SSTableReader sstable : byLevel.get(level))
1:f2a3547:                         scanners.add(sstable.getScanner(ranges));
1:0e83100:                 }
1:a7b7214:                 else
1:0e83100:                 {
1:0e83100:                     // Create a LeveledScanner that only opens one sstable at a time, in sorted order
1:9b48a0b:                     Collection<SSTableReader> intersecting = LeveledScanner.intersecting(byLevel.get(level), ranges);
1:0e83100:                     if (!intersecting.isEmpty())
1:a991b64:                     {
1:a991b64:                         @SuppressWarnings("resource") // The ScannerList will be in charge of closing (and we close properly on errors)
1:9b48a0b:                         ISSTableScanner scanner = new LeveledScanner(intersecting, ranges);
1:a991b64:                         scanners.add(scanner);
1:a991b64:                     }
1:0e83100:                 }
1:d90f0f3:             }
1:08848e7:         }
1:0e83100:         catch (Throwable t)
1:0e83100:         {
1:0e83100:             try
1:0e83100:             {
1:0e83100:                 new ScannerList(scanners).close();
1:0e83100:             }
1:0e83100:             catch (Throwable t2)
1:0e83100:             {
1:0e83100:                 t.addSuppressed(t2);
1:0e83100:             }
1:0e83100:             throw t;
1:0e83100:         }
1:08848e7: 
1:0e83100:         return new ScannerList(scanners);
1:08848e7:     }
1:4d7e703: 
1:e16f584:     @Override
1:3527099:     public void replaceSSTables(Collection<SSTableReader> removed, Collection<SSTableReader> added)
1:3527099:     {
1:3527099:         manifest.replace(removed, added);
1:3527099:     }
1:3527099: 
1:3527099:     @Override
1:e16f584:     public void addSSTable(SSTableReader added)
1:e16f584:     {
1:e16f584:         manifest.add(added);
1:e16f584:     }
1:e16f584: 
1:e16f584:     @Override
1:e16f584:     public void removeSSTable(SSTableReader sstable)
1:e16f584:     {
1:e16f584:         manifest.remove(sstable);
1:e16f584:     }
1:e16f584: 
1:46e422a:     // Lazily creates SSTableBoundedScanner for sstable that are assumed to be from the
1:46e422a:     // same level (e.g. non overlapping) - see #4142
1:a991b64:     private static class LeveledScanner extends AbstractIterator<UnfilteredRowIterator> implements ISSTableScanner
1:686f516:     {
1:9b48a0b:         private final Collection<Range<Token>> ranges;
1:46e422a:         private final List<SSTableReader> sstables;
1:46e422a:         private final Iterator<SSTableReader> sstableIterator;
1:46e422a:         private final long totalLength;
1:10649b1:         private final long compressedLength;
1:46e422a: 
1:1fec4a4:         private ISSTableScanner currentScanner;
1:46e422a:         private long positionOffset;
1:10649b1:         private long totalBytesScanned = 0;
1:46e422a: 
1:9b48a0b:         public LeveledScanner(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
1:278a5e8:         {
1:9b48a0b:             this.ranges = ranges;
1:46e422a: 
1:effdb08:             // add only sstables that intersect our range, and estimate how much data that involves
1:0368e97:             this.sstables = new ArrayList<>(sstables.size());
1:46e422a:             long length = 0;
1:10649b1:             long cLength = 0;
2:46e422a:             for (SSTableReader sstable : sstables)
1:effdb08:             {
1:effdb08:                 this.sstables.add(sstable);
1:effdb08:                 long estimatedKeys = sstable.estimatedKeys();
1:effdb08:                 double estKeysInRangeRatio = 1.0;
1:effdb08: 
1:9b48a0b:                 if (estimatedKeys > 0 && ranges != null)
1:9b48a0b:                     estKeysInRangeRatio = ((double) sstable.estimatedKeysForRanges(ranges)) / estimatedKeys;
1:effdb08: 
1:effdb08:                 length += sstable.uncompressedLength() * estKeysInRangeRatio;
1:10649b1:                 cLength += sstable.onDiskLength() * estKeysInRangeRatio;
1:effdb08:             }
1:effdb08: 
1:46e422a:             totalLength = length;
1:10649b1:             compressedLength = cLength;
1:f388c9d:             Collections.sort(this.sstables, SSTableReader.sstableComparator);
1:effdb08:             sstableIterator = this.sstables.iterator();
1:effdb08:             assert sstableIterator.hasNext(); // caller should check intersecting first
1:8580047:             SSTableReader currentSSTable = sstableIterator.next();
1:f2a3547:             currentScanner = currentSSTable.getScanner(ranges);
1:10649b1: 
1:effdb08:         }
1:effdb08: 
1:9b48a0b:         public static Collection<SSTableReader> intersecting(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
1:effdb08:         {
1:9b48a0b:             if (ranges == null)
1:9b48a0b:                 return Lists.newArrayList(sstables);
1:9b48a0b: 
1:9b48a0b:             Set<SSTableReader> filtered = new HashSet<>();
1:9b48a0b:             for (Range<Token> range : ranges)
1:9b48a0b:             {
1:9b48a0b:                 for (SSTableReader sstable : sstables)
1:effdb08:                 {
1:9b48a0b:                     Range<Token> sstableRange = new Range<>(sstable.first.getToken(), sstable.last.getToken());
1:9b48a0b:                     if (range == null || sstableRange.intersects(range))
1:9b48a0b:                         filtered.add(sstable);
1:9b48a0b:                 }
1:effdb08:             }
1:effdb08:             return filtered;
1:67ed39f:         }
1:9b48a0b: 
1:46e422a: 
1:a991b64:         public boolean isForThrift()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:8a97969:         public CFMetaData metadata()
1:8a97969:         {
1:8a97969:             return sstables.get(0).metadata; // The ctor checks we have at least one sstable
1:8a97969:         }
1:8a97969: 
1:a991b64:         protected UnfilteredRowIterator computeNext()
1:5bd57cb:         {
1:effdb08:             if (currentScanner == null)
1:effdb08:                 return endOfData();
1:effdb08: 
1:a991b64:             while (true)
1:0e28478:             {
1:a991b64:                 if (currentScanner.hasNext())
1:a991b64:                     return currentScanner.next();
1:b034297: 
1:a991b64:                 positionOffset += currentScanner.getLengthInBytes();
1:10649b1:                 totalBytesScanned += currentScanner.getBytesScanned();
1:10649b1: 
1:a991b64:                 currentScanner.close();
1:a991b64:                 if (!sstableIterator.hasNext())
1:a991b64:                 {
1:a991b64:                     // reset to null so getCurrentPosition does not return wrong value
1:a991b64:                     currentScanner = null;
1:a991b64:                     return endOfData();
1:67ed39f:                 }
1:8580047:                 SSTableReader currentSSTable = sstableIterator.next();
1:f2a3547:                 currentScanner = currentSSTable.getScanner(ranges);
1:67ed39f:             }
1:4d7e703:         }
1:46e422a: 
1:a991b64:         public void close()
1:d90f0f3:         {
2:46e422a:             if (currentScanner != null)
1:b034297:                 currentScanner.close();
1:4d7e703:         }
1:46e422a: 
1:46e422a:         public long getLengthInBytes()
1:08848e7:         {
1:46e422a:             return totalLength;
1:aead8da:         }
1:46e422a: 
1:46e422a:         public long getCurrentPosition()
1:08848e7:         {
1:46e422a:             return positionOffset + (currentScanner == null ? 0L : currentScanner.getCurrentPosition());
1:aead8da:         }
1:46e422a: 
1:10649b1:         public long getCompressedLengthInBytes()
1:10649b1:         {
1:10649b1:             return compressedLength;
1:10649b1:         }
1:10649b1: 
1:10649b1:         public long getBytesScanned()
1:10649b1:         {
1:10649b1:             return currentScanner == null ? totalBytesScanned : totalBytesScanned + currentScanner.getBytesScanned();
1:10649b1:         }
1:10649b1: 
1:46e422a:         public String getBackingFiles()
1:67ed39f:         {
1:46e422a:             return Joiner.on(", ").join(sstables);
1:aead8da:         }
7:46e422a:     }
1:46e422a: 
2:b44683c:     @Override
1:aab97ff:     public String toString()
1:67ed39f:     {
1:9e14e19:         return String.format("LCS@%d(%s)", hashCode(), cfs.name);
1:46e422a:     }
1:46e422a: 
1:0091af9:     private SSTableReader findDroppableSSTable(final int gcBefore)
1:67ed39f:     {
1:0091af9:         level:
1:0091af9:         for (int i = manifest.getLevelCount(); i >= 0; i--)
1:4d7e703:         {
1:0091af9:             // sort sstables by droppable ratio in descending order
1:0091af9:             SortedSet<SSTableReader> sstables = manifest.getLevelSorted(i, new Comparator<SSTableReader>()
1:4d7e703:             {
1:0091af9:                 public int compare(SSTableReader o1, SSTableReader o2)
2:aead8da:                 {
1:0091af9:                     double r1 = o1.getEstimatedDroppableTombstoneRatio(gcBefore);
1:0091af9:                     double r2 = o2.getEstimatedDroppableTombstoneRatio(gcBefore);
1:0091af9:                     return -1 * Doubles.compare(r1, r2);
1:46e422a:                 }
1:0091af9:             });
1:686f516:             if (sstables.isEmpty())
1:0091af9:                 continue;
1:3ad3e73: 
1:e5a76bd:             Set<SSTableReader> compacting = cfs.getTracker().getCompacting();
1:effdb08:             for (SSTableReader sstable : sstables)
1:aead8da:             {
1:0091af9:                 if (sstable.getEstimatedDroppableTombstoneRatio(gcBefore) <= tombstoneThreshold)
1:0091af9:                     continue level;
1:686f516:                 else if (!compacting.contains(sstable) && !sstable.isMarkedSuspect() && worthDroppingTombstones(sstable, gcBefore))
1:0091af9:                     return sstable;
1:46e422a:             }
1:46e422a:         }
1:686f516:         return null;
1:46e422a:     }
1:84a461a: 
1:e16d8a7:     public CompactionLogger.Strategy strategyLogger()
1:e16d8a7:     {
1:e16d8a7:         return new CompactionLogger.Strategy()
1:e16d8a7:         {
1:e16d8a7:             public JsonNode sstable(SSTableReader sstable)
1:e16d8a7:             {
1:e16d8a7:                 ObjectNode node = JsonNodeFactory.instance.objectNode();
1:e16d8a7:                 node.put("level", sstable.getSSTableLevel());
1:e16d8a7:                 node.put("min_token", sstable.first.getToken().toString());
1:e16d8a7:                 node.put("max_token", sstable.last.getToken().toString());
1:e16d8a7:                 return node;
1:e16d8a7:             }
1:e16d8a7: 
1:e16d8a7:             public JsonNode options()
1:e16d8a7:             {
1:e16d8a7:                 return null;
1:e16d8a7:             }
1:e16d8a7:         };
1:e16d8a7:     }
1:e16d8a7: 
1:360d1a2:     public static Map<String, String> validateOptions(Map<String, String> options) throws ConfigurationException
1:360d1a2:     {
1:360d1a2:         Map<String, String> uncheckedOptions = AbstractCompactionStrategy.validateOptions(options);
1:360d1a2: 
1:360d1a2:         String size = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : "1";
1:360d1a2:         try
1:360d1a2:         {
1:360d1a2:             int ssSize = Integer.parseInt(size);
1:360d1a2:             if (ssSize < 1)
1:360d1a2:             {
1:360d1a2:                 throw new ConfigurationException(String.format("%s must be larger than 0, but was %s", SSTABLE_SIZE_OPTION, ssSize));
1:360d1a2:             }
1:360d1a2:         }
1:360d1a2:         catch (NumberFormatException ex)
1:360d1a2:         {
1:360d1a2:             throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", size, SSTABLE_SIZE_OPTION), ex);
1:360d1a2:         }
1:360d1a2: 
1:360d1a2:         uncheckedOptions.remove(SSTABLE_SIZE_OPTION);
1:360d1a2: 
1:9fc14bc:         // Validate the fanout_size option
1:9fc14bc:         String levelFanoutSize = options.containsKey(LEVEL_FANOUT_SIZE_OPTION) ? options.get(LEVEL_FANOUT_SIZE_OPTION) : String.valueOf(DEFAULT_LEVEL_FANOUT_SIZE);
1:9fc14bc:         try
1:9fc14bc:         {
1:9fc14bc:             int fanoutSize = Integer.parseInt(levelFanoutSize);
1:9fc14bc:             if (fanoutSize < 1)
1:9fc14bc:             {
1:9fc14bc:                 throw new ConfigurationException(String.format("%s must be larger than 0, but was %s", LEVEL_FANOUT_SIZE_OPTION, fanoutSize));
1:9fc14bc:             }
1:9fc14bc:         }
1:9fc14bc:         catch (NumberFormatException ex)
1:9fc14bc:         {
1:9fc14bc:             throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", size, LEVEL_FANOUT_SIZE_OPTION), ex);
1:9fc14bc:         }
1:9fc14bc: 
1:9fc14bc:         uncheckedOptions.remove(LEVEL_FANOUT_SIZE_OPTION);
1:9fc14bc: 
1:6968f68:         uncheckedOptions = SizeTieredCompactionStrategyOptions.validateOptions(options, uncheckedOptions);
1:6968f68: 
1:360d1a2:         return uncheckedOptions;
1:360d1a2:     }
1:46e422a: }
============================================================================
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:42e0fc5
commit:bdeef40
commit:16ea55b
commit:bf7d433
commit:3128802
commit:0541597
commit:9b48a0b
/////////////////////////////////////////////////////////////////////////
1:     public ScannerList getScanners(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
/////////////////////////////////////////////////////////////////////////
0:                         scanners.add(sstable.getScanner(ranges, CompactionManager.instance.getRateLimiter()));
1:                     Collection<SSTableReader> intersecting = LeveledScanner.intersecting(byLevel.get(level), ranges);
1:                         ISSTableScanner scanner = new LeveledScanner(intersecting, ranges);
/////////////////////////////////////////////////////////////////////////
1:         private final Collection<Range<Token>> ranges;
/////////////////////////////////////////////////////////////////////////
1:         public LeveledScanner(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
1:             this.ranges = ranges;
/////////////////////////////////////////////////////////////////////////
1:                 if (estimatedKeys > 0 && ranges != null)
1:                     estKeysInRangeRatio = ((double) sstable.estimatedKeysForRanges(ranges)) / estimatedKeys;
/////////////////////////////////////////////////////////////////////////
0:             currentScanner = sstableIterator.next().getScanner(ranges, CompactionManager.instance.getRateLimiter());
1:         public static Collection<SSTableReader> intersecting(Collection<SSTableReader> sstables, Collection<Range<Token>> ranges)
1:             if (ranges == null)
1:                 return Lists.newArrayList(sstables);
1: 
1:             Set<SSTableReader> filtered = new HashSet<>();
1:             for (Range<Token> range : ranges)
1:                 for (SSTableReader sstable : sstables)
1:                 {
1:                     Range<Token> sstableRange = new Range<>(sstable.first.getToken(), sstable.last.getToken());
1:                     if (range == null || sstableRange.intersects(range))
1:                         filtered.add(sstable);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 currentScanner = sstableIterator.next().getScanner(ranges, CompactionManager.instance.getRateLimiter());
commit:ed0a07c
/////////////////////////////////////////////////////////////////////////
1:     public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
commit:d26187e
commit:325aeb7
commit:dce303b
/////////////////////////////////////////////////////////////////////////
commit:910170c
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: 
1: import org.apache.cassandra.io.sstable.ISSTableScanner;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, candidate.sstables, candidate.level, gcBefore, candidate.maxSSTableBytes, false);
1:                 return newTask;
1:     public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefore, boolean splitOutput)
1:     {
1:         Iterable<SSTableReader> sstables = manifest.getAllSSTables();
1: 
1:         Iterable<SSTableReader> filteredSSTables = filterSuspectSSTables(sstables);
1:         if (Iterables.isEmpty(sstables))
1:             return null;
0:         if (!cfs.getDataTracker().markCompacting(filteredSSTables))
1:             return null;
0:         return Arrays.<AbstractCompactionTask>asList(new LeveledCompactionTask(cfs, filteredSSTables, 0, gcBefore, getMaxSSTableBytes(), true));
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         return new LeveledCompactionTask(cfs, sstables, level, gcBefore, maxSSTableBytes, false);
commit:21bb6d2
commit:3527099
/////////////////////////////////////////////////////////////////////////
1:     public void replaceSSTables(Collection<SSTableReader> removed, Collection<SSTableReader> added)
1:     {
1:         manifest.replace(removed, added);
1:     }
1: 
1:     @Override
commit:af44d1a
commit:e16f584
/////////////////////////////////////////////////////////////////////////
1: public class LeveledCompactionStrategy extends AbstractCompactionStrategy
/////////////////////////////////////////////////////////////////////////
0:         manifest = new LeveledManifest(cfs, this.maxSSTableSizeInMB, localOptions);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(sstable.getSSTableLevel()).add(sstable);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void addSSTable(SSTableReader added)
1:     {
1:         manifest.add(added);
1:     }
1: 
1:     @Override
1:     public void removeSSTable(SSTableReader sstable)
1:     {
1:         manifest.remove(sstable);
1:     }
1: 
commit:26191ca
commit:a90b98e
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public AbstractCompactionTask getCompactionTask(Collection<SSTableReader> sstables, int gcBefore, long maxSSTableBytes)
1:     {
0:         assert sstables.size() > 0;
1:         int level = -1;
1:         // if all sstables are in the same level, we can set that level:
1:         for (SSTableReader sstable : sstables)
1:         {
1:             if (level == -1)
1:                 level = sstable.getSSTableLevel();
1:             if (level != sstable.getSSTableLevel())
1:                 level = 0;
1:         }
0:         return new LeveledCompactionTask(cfs, sstables, level, gcBefore, maxSSTableBytes);
1:     }
1: 
commit:a7b7214
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.notifications.SSTableRepairStatusChanged;
/////////////////////////////////////////////////////////////////////////
0:         Collection<AbstractCompactionTask> tasks = getMaximalTask(gcBefore);
0:         if (tasks == null || tasks.size() == 0)
1:             return null;
0:         return tasks.iterator().next();
0:     public Collection<AbstractCompactionTask> getMaximalTask(int gcBefore)
/////////////////////////////////////////////////////////////////////////
0:                 return Arrays.<AbstractCompactionTask>asList(newTask);
/////////////////////////////////////////////////////////////////////////
0:         else if (notification instanceof SSTableRepairStatusChanged)
1:         {
0:             manifest.repairStatusChanged(((SSTableRepairStatusChanged) notification).sstable);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         {
0:             if (manifest.hasRepairedData() && !sstable.isRepaired())
0:                 byLevel.get(0).add(sstable);
1:             else
0:                 byLevel.get(sstable.getSSTableLevel()).add(sstable);
1:         }
commit:857a7f5
commit:8f367fd
/////////////////////////////////////////////////////////////////////////
0:         manifest = LeveledManifest.create(cfs, this.maxSSTableSizeInMB, cfs.getSSTables(), localOptions);
commit:ebefb77
/////////////////////////////////////////////////////////////////////////
0:         if (!isEnabled())
author:Dikang Gu
-------------------------------------------------------------------------------
commit:9fc14bc
/////////////////////////////////////////////////////////////////////////
1:     private static final String LEVEL_FANOUT_SIZE_OPTION = "fanout_size";
1:     public static final int DEFAULT_LEVEL_FANOUT_SIZE = 10;
1:     private final int levelFanoutSize;
1:         int configuredLevelFanoutSize = DEFAULT_LEVEL_FANOUT_SIZE;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (options.containsKey(LEVEL_FANOUT_SIZE_OPTION))
1:             {
1:                 configuredLevelFanoutSize = Integer.parseInt(options.get(LEVEL_FANOUT_SIZE_OPTION));
1:             }
1:         levelFanoutSize = configuredLevelFanoutSize;
1:         manifest = new LeveledManifest(cfs, this.maxSSTableSizeInMB, this.levelFanoutSize, localOptions);
/////////////////////////////////////////////////////////////////////////
1:     public int getLevelFanoutSize()
1:     {
1:         return levelFanoutSize;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Validate the fanout_size option
1:         String levelFanoutSize = options.containsKey(LEVEL_FANOUT_SIZE_OPTION) ? options.get(LEVEL_FANOUT_SIZE_OPTION) : String.valueOf(DEFAULT_LEVEL_FANOUT_SIZE);
1:         try
1:         {
1:             int fanoutSize = Integer.parseInt(levelFanoutSize);
1:             if (fanoutSize < 1)
1:             {
1:                 throw new ConfigurationException(String.format("%s must be larger than 0, but was %s", LEVEL_FANOUT_SIZE_OPTION, fanoutSize));
1:             }
1:         }
1:         catch (NumberFormatException ex)
1:         {
1:             throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", size, LEVEL_FANOUT_SIZE_OPTION), ex);
1:         }
1: 
1:         uncheckedOptions.remove(LEVEL_FANOUT_SIZE_OPTION);
1: 
commit:6808e75
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void startup()
1:     {
1:         manifest.calculateLastCompactedKeys();
1:         super.startup();
1:     }
1: 
author:Anthony Grasso
-------------------------------------------------------------------------------
commit:f2a3547
/////////////////////////////////////////////////////////////////////////
1:                         scanners.add(sstable.getScanner(ranges));
/////////////////////////////////////////////////////////////////////////
1:             currentScanner = currentSSTable.getScanner(ranges);
/////////////////////////////////////////////////////////////////////////
1:                 currentScanner = currentSSTable.getScanner(ranges);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:b3a4e20
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Config;
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean tolerateSstableSize = Boolean.getBoolean(Config.PROPERTY_PREFIX + "tolerate_sstable_size");
/////////////////////////////////////////////////////////////////////////
1:         {             
1:             if (options.containsKey(SSTABLE_SIZE_OPTION))             
1:             {                 
1:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));                 
1:                 if (!tolerateSstableSize)
1:                 {                     
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:         {
0:             if (options.containsKey(SSTABLE_SIZE_OPTION))
1:             {
0:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));
0:                 if (!Boolean.getBoolean("cassandra.tolerate_sstable_size"))
1:                 {
1:                     if (configuredMaxSSTableSize < 50)
commit:8580047
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             SSTableReader currentSSTable = sstableIterator.next();
/////////////////////////////////////////////////////////////////////////
1:                 SSTableReader currentSSTable = sstableIterator.next();
commit:0a56037
/////////////////////////////////////////////////////////////////////////
1:             Collection<SSTableReader> sstablesForLevel = sstablesByLevel.get(level);
1:             if (sstablesForLevel == null)
1:                 sstablesForLevel = new ArrayList<SSTableReader>();
1:                 sstablesByLevel.put(level, sstablesForLevel);
1:             sstablesForLevel.add(sstable);
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:f19610c
/////////////////////////////////////////////////////////////////////////
1:         if (options != null)
1:         {             
0:             if (options.containsKey(SSTABLE_SIZE_OPTION))             
1:             {                 
0:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));                 
0:                 if (!Boolean.getBoolean("cassandra.tolerate_sstable_size"))                 
1:                 {                     
1:                                 configuredMaxSSTableSize, cfs.name, cfs.getColumnFamilyName());
0:                     if (configuredMaxSSTableSize < 50)  
1:                                 configuredMaxSSTableSize, cfs.name, cfs.getColumnFamilyName());
commit:997ab95
/////////////////////////////////////////////////////////////////////////
commit:ab94f28
commit:260dc75
/////////////////////////////////////////////////////////////////////////
commit:029c2f3
commit:95ff3bb
commit:ca63545
/////////////////////////////////////////////////////////////////////////
1:     private static final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
1: 
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:1e289fa
/////////////////////////////////////////////////////////////////////////
0:     private static final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:05660a5
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:10649b1
/////////////////////////////////////////////////////////////////////////
0:                         scanners.add(sstable.getScanner(ranges, null));
/////////////////////////////////////////////////////////////////////////
1:         private final long compressedLength;
0:         private SSTableReader currentSSTable;
1:         private long totalBytesScanned = 0;
/////////////////////////////////////////////////////////////////////////
1:             long cLength = 0;
/////////////////////////////////////////////////////////////////////////
1:                 cLength += sstable.onDiskLength() * estKeysInRangeRatio;
1:             compressedLength = cLength;
0:             currentSSTable = sstableIterator.next();
0:             currentScanner = currentSSTable.getScanner(ranges, null);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 totalBytesScanned += currentScanner.getBytesScanned();
1: 
/////////////////////////////////////////////////////////////////////////
0:                 currentSSTable = sstableIterator.next();
0:                 currentScanner = currentSSTable.getScanner(ranges, null);
/////////////////////////////////////////////////////////////////////////
1:         public long getCompressedLengthInBytes()
1:         {
1:             return compressedLength;
1:         }
1: 
1:         public long getBytesScanned()
1:         {
1:             return currentScanner == null ? totalBytesScanned : totalBytesScanned + currentScanner.getBytesScanned();
1:         }
1: 
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("resource")
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("resource")
author:Vishy Kasar
-------------------------------------------------------------------------------
commit:a5d095e
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (sstables.isEmpty())
1:             return null;
/////////////////////////////////////////////////////////////////////////
1:         int level = sstables.size() > 1 ? 0 : sstables.iterator().next().getSSTableLevel();
1:         return new LeveledCompactionTask(cfs, transaction, level, gcBefore, level == 0 ? Long.MAX_VALUE : getMaxSSTableBytes(), false);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:d40ac78
/////////////////////////////////////////////////////////////////////////
0:         if (sstables.size() != 1)
0:             throw new UnsupportedOperationException("LevelDB compaction strategy does not allow user-specified compactions");
1: 
1:         LifecycleTransaction transaction = cfs.getTracker().tryModify(sstables, OperationType.COMPACTION);
1:         if (transaction == null)
1:         {
1:             logger.trace("Unable to mark {} for compaction; probably a background compaction got to it first.  You can disable background compactions temporarily if this is a problem", sstables);
1:             return null;
1:         }
0:         int level = sstables.iterator().next().getSSTableLevel();
0:         return getCompactionTask(transaction, gcBefore, level == 0 ? Integer.MAX_VALUE : getMaxSSTableBytes());
commit:07893d7
/////////////////////////////////////////////////////////////////////////
0:                 Range<Token> sstableRange = new Range<>(sstable.first.getToken(), sstable.last.getToken());
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:e16d8a7
/////////////////////////////////////////////////////////////////////////
1: import org.codehaus.jackson.JsonNode;
1: import org.codehaus.jackson.node.JsonNodeFactory;
1: import org.codehaus.jackson.node.ObjectNode;
/////////////////////////////////////////////////////////////////////////
1:         int n = manifest.getEstimatedTasks();
1:         cfs.getCompactionStrategyManager().compactionLogger.pending(this, n);
1:         return n;
/////////////////////////////////////////////////////////////////////////
1:     public CompactionLogger.Strategy strategyLogger()
1:     {
1:         return new CompactionLogger.Strategy()
1:         {
1:             public JsonNode sstable(SSTableReader sstable)
1:             {
1:                 ObjectNode node = JsonNodeFactory.instance.objectNode();
1:                 node.put("level", sstable.getSSTableLevel());
1:                 node.put("min_token", sstable.first.getToken().toString());
1:                 node.put("max_token", sstable.last.getToken().toString());
1:                 return node;
1:             }
1: 
1:             public JsonNode options()
1:             {
1:                 return null;
1:             }
1:         };
1:     }
1: 
author:Paulo Motta
-------------------------------------------------------------------------------
commit:cc75de6
/////////////////////////////////////////////////////////////////////////
1:         Set<SSTableReader>[] sstablesPerLevel = manifest.getSStablesPerLevelSnapshot();
1: 
1:             int level = sstable.getSSTableLevel();
1:             // if an sstable is not on the manifest, it was recently added or removed
1:             // so we add it to level -1 and create exclusive scanners for it - see below (#9935)
1:             if (level >= sstablesPerLevel.length || !sstablesPerLevel[level].contains(sstable))
1:             {
1:                 logger.warn("Live sstable {} from level {} is not on corresponding level in the leveled manifest." +
1:                             " This is not a problem per se, but may indicate an orphaned sstable due to a failed" +
1:                             " compaction not cleaned up properly.",
1:                              sstable.getFilename(), level);
1:                 level = -1;
1:             }
1:             byLevel.get(level).add(sstable);
commit:4a849ef
/////////////////////////////////////////////////////////////////////////
1:         logger.trace("Created {}", manifest);
/////////////////////////////////////////////////////////////////////////
1:                     logger.trace("No compaction necessary for {}", this);
author:blerer
-------------------------------------------------------------------------------
commit:aa60cde
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:8a97969
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
1:         public CFMetaData metadata()
1:         {
1:             return sstables.get(0).metadata; // The ctor checks we have at least one sstable
1:         }
1: 
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.UnfilteredRowIterator;
0: import org.apache.cassandra.io.sstable.ISSTableScanner;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
1:                     {
1:                         @SuppressWarnings("resource") // The ScannerList will be in charge of closing (and we close properly on errors)
0:                         ISSTableScanner scanner = new LeveledScanner(intersecting, range);
1:                         scanners.add(scanner);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     private static class LeveledScanner extends AbstractIterator<UnfilteredRowIterator> implements ISSTableScanner
/////////////////////////////////////////////////////////////////////////
1:         public boolean isForThrift()
1:         {
1:             return false;
1:         }
1: 
1:         protected UnfilteredRowIterator computeNext()
1:             while (true)
1:                 if (currentScanner.hasNext())
1:                     return currentScanner.next();
1:                 positionOffset += currentScanner.getLengthInBytes();
1:                 currentScanner.close();
1:                 if (!sstableIterator.hasNext())
1:                 {
1:                     // reset to null so getCurrentPosition does not return wrong value
1:                     currentScanner = null;
1:                     return endOfData();
0:                 currentScanner = sstableIterator.next().getScanner(range, CompactionManager.instance.getRateLimiter());
1:         public void close()
commit:1522134
commit:360d1a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0:             String value = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : "5";
0:             configuredMaxSSTableSize = Integer.parseInt(value);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static Map<String, String> validateOptions(Map<String, String> options) throws ConfigurationException
1:     {
1:         Map<String, String> uncheckedOptions = AbstractCompactionStrategy.validateOptions(options);
1: 
1:         String size = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : "1";
1:         try
1:         {
1:             int ssSize = Integer.parseInt(size);
1:             if (ssSize < 1)
1:             {
1:                 throw new ConfigurationException(String.format("%s must be larger than 0, but was %s", SSTABLE_SIZE_OPTION, ssSize));
1:             }
1:         }
1:         catch (NumberFormatException ex)
1:         {
1:             throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", size, SSTABLE_SIZE_OPTION), ex);
1:         }
1: 
1:         uncheckedOptions.remove(SSTABLE_SIZE_OPTION);
1: 
1:         return uncheckedOptions;
1:     }
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
/////////////////////////////////////////////////////////////////////////
0:     private static class LeveledScanner extends AbstractIterator<OnDiskAtomIterator> implements ICompactionScanner
/////////////////////////////////////////////////////////////////////////
0:         protected OnDiskAtomIterator computeNext()
commit:65059cf
/////////////////////////////////////////////////////////////////////////
0:             switch (listChangedNotification.compactionType)
1:             {
0:                 // Cleanup, scrub and updateSSTable shouldn't promote (see #3989)
0:                 case CLEANUP:
0:                 case SCRUB:
0:                 case UPGRADE_SSTABLES:
0:                     manifest.replace(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
0:                 default:
0:                     manifest.promote(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
1:             }
commit:d78db44
commit:048c8a9
/////////////////////////////////////////////////////////////////////////
0:             switch (listChangedNotification.compactionType)
1:             {
0:                 // Cleanup, scrub and updateSSTable shouldn't promote (see #3989)
0:                 case CLEANUP:
0:                 case SCRUB:
0:                 case UPGRADE_SSTABLES:
0:                     manifest.replace(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
0:                 default:
0:                     manifest.promote(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
1:             }
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.db.compaction;
commit:d01f8dd
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
1:  */
1: 
/////////////////////////////////////////////////////////////////////////
1: }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e5a76bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
/////////////////////////////////////////////////////////////////////////
1:             LifecycleTransaction txn = cfs.getTracker().tryModify(candidate.sstables, OperationType.COMPACTION);
1:             if (txn != null)
1:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, txn, candidate.level, gcBefore, candidate.maxSSTableBytes, false);
/////////////////////////////////////////////////////////////////////////
1:         LifecycleTransaction txn = cfs.getTracker().tryModify(filteredSSTables, OperationType.COMPACTION);
1:         if (txn == null)
1:         return Arrays.<AbstractCompactionTask>asList(new LeveledCompactionTask(cfs, txn, 0, gcBefore, getMaxSSTableBytes(), true));
/////////////////////////////////////////////////////////////////////////
1:     public AbstractCompactionTask getCompactionTask(LifecycleTransaction txn, int gcBefore, long maxSSTableBytes)
1:         assert txn.originals().size() > 0;
1:         for (SSTableReader sstable : txn.originals())
1:         return new LeveledCompactionTask(cfs, txn, level, gcBefore, maxSSTableBytes, false);
/////////////////////////////////////////////////////////////////////////
1:                 // level can be -1 when sstables are added to Tracker but not to LeveledManifest
/////////////////////////////////////////////////////////////////////////
1:             Set<SSTableReader> compacting = cfs.getTracker().getCompacting();
commit:0956a8a
commit:0e83100
/////////////////////////////////////////////////////////////////////////
0:     public ScannerList getScanners(Collection<SSTableReader> sstables, Range<Token> range)
/////////////////////////////////////////////////////////////////////////
1:         try
1:             for (Integer level : byLevel.keySet())
0:                 // level can be -1 when sstables are added to DataTracker but not to LeveledManifest
1:                 // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
1:                 if (level <= 0)
1:                 {
1:                     // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
1:                     for (SSTableReader sstable : byLevel.get(level))
0:                         scanners.add(sstable.getScanner(range, CompactionManager.instance.getRateLimiter()));
1:                 }
1:                 else
1:                 {
1:                     // Create a LeveledScanner that only opens one sstable at a time, in sorted order
0:                     List<SSTableReader> intersecting = LeveledScanner.intersecting(byLevel.get(level), range);
1:                     if (!intersecting.isEmpty())
0:                         scanners.add(new LeveledScanner(intersecting, range));
1:                 }
1:         catch (Throwable t)
1:         {
1:             try
1:             {
1:                 new ScannerList(scanners).close();
1:             }
1:             catch (Throwable t2)
1:             {
1:                 t.addSuppressed(t2);
1:             }
1:             throw t;
1:         }
1:         return new ScannerList(scanners);
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:bee53d7
commit:1fec4a4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.ISSTableScanner;
/////////////////////////////////////////////////////////////////////////
1:         List<ISSTableScanner> scanners = new ArrayList<ISSTableScanner>(sstables.size());
/////////////////////////////////////////////////////////////////////////
0:     private static class LeveledScanner extends AbstractIterator<OnDiskAtomIterator> implements ISSTableScanner
1:         private ISSTableScanner currentScanner;
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             this.sstables = new ArrayList<>(sstables.size());
/////////////////////////////////////////////////////////////////////////
0:             ArrayList<SSTableReader> filtered = new ArrayList<>();
0:                 Range<Token> sstableRange = new Range<>(sstable.first.getToken(), sstable.last.getToken(), sstable.partitioner);
author:Russell Spitzer
-------------------------------------------------------------------------------
commit:37f5175
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.Comparator;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.SortedSet;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Leveled compaction strategy has guarantees on the data contained within each level so we
1:      * have to make sure we only create groups of SSTables with members from the same level.
1:      * This way we won't end up creating invalid sstables during anti-compaction.
1:      * @param ssTablesToGroup
1:      * @return Groups of sstables from the same level
1:      */
1:     @Override
1:     public Collection<Collection<SSTableReader>> groupSSTablesForAntiCompaction(Collection<SSTableReader> ssTablesToGroup)
1:     {
1:         int groupSize = 2;
1:         Map<Integer, Collection<SSTableReader>> sstablesByLevel = new HashMap<>();
1:         for (SSTableReader sstable : ssTablesToGroup)
1:         {
1:             Integer level = sstable.getSSTableLevel();
0:             if (!sstablesByLevel.containsKey(level))
1:             {
0:                 sstablesByLevel.put(level, new ArrayList<SSTableReader>());
1:             }
0:             sstablesByLevel.get(level).add(sstable);
1:         }
1: 
1:         Collection<Collection<SSTableReader>> groupedSSTables = new ArrayList<>();
1: 
1:         for (Collection<SSTableReader> levelOfSSTables : sstablesByLevel.values())
1:         {
1:             Collection<SSTableReader> currGroup = new ArrayList<>();
1:             for (SSTableReader sstable : levelOfSSTables)
1:             {
1:                 currGroup.add(sstable);
1:                 if (currGroup.size() == groupSize)
1:                 {
1:                     groupedSSTables.add(currGroup);
1:                     currGroup = new ArrayList<>();
1:                 }
1:             }
1: 
1:             if (currGroup.size() != 0)
1:                 groupedSSTables.add(currGroup);
1:         }
1:         return groupedSSTables;
1: 
1:     }
1: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:7dec15b
commit:b44683c
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public void startup()
1:     {
0:         super.startup();
0:         cfs.getDataTracker().subscribe(this);
0:         logger.debug("{} subscribed to the data tracker.", this);
1:     }
1: 
1:     @Override
0:         logger.debug("{} unsubscribed from the data tracker.", this);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:90e585d
commit:ecec863
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             LeveledManifest.CompactionCandidate candidate = manifest.getCompactionCandidates();
1:             if (candidate == null)
/////////////////////////////////////////////////////////////////////////
1:                 candidate = new LeveledManifest.CompactionCandidate(Collections.singleton(sstable),
1:                                                                     sstable.getSSTableLevel(),
1:                                                                     getMaxSSTableBytes());
0:             if (cfs.getDataTracker().markCompacting(candidate.sstables))
0:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, candidate.sstables, candidate.level, gcBefore, candidate.maxSSTableBytes);
/////////////////////////////////////////////////////////////////////////
1:     public long getMaxSSTableBytes()
commit:229da37
commit:c5368c7
/////////////////////////////////////////////////////////////////////////
0:                 if (!Boolean.getBoolean("cassandra.tolerate_sstable_size"))
1:                     if (configuredMaxSSTableSize >= 1000)
1:                         logger.warn("Max sstable size of {}MB is configured for {}.{}; having a unit of compaction this large is probably a bad idea",
0:                                     configuredMaxSSTableSize, cfs.table.name, cfs.getColumnFamilyName());
0:                     if (configuredMaxSSTableSize < 50)
1:                         logger.warn("Max sstable size of {}MB is configured for {}.{}.  Testing done for CASSANDRA-5727 indicates that performance improves up to 160MB",
0:                                     configuredMaxSSTableSize, cfs.table.name, cfs.getColumnFamilyName());
commit:e533d5a
/////////////////////////////////////////////////////////////////////////
0:         if (options.containsKey(SSTABLE_SIZE_OPTION))
0:             configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));
0:             if (configuredMaxSSTableSize >= 1000)
0:                 // Yes, people have done this
0:                 logger.warn("Max sstable size of {}MB is configured; having a unit of compaction this large is probably a bad idea", configuredMaxSSTableSize);
commit:e7ea389
/////////////////////////////////////////////////////////////////////////
1:         int configuredMaxSSTableSize = 160;
0:             if (options.containsKey(SSTABLE_SIZE_OPTION))
0:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));
0:                 if (configuredMaxSSTableSize >= 1000)
1:                 {
0:                     // Yes, people have done this
0:                     logger.warn("Max sstable size of {}MB is configured; having a unit of compaction this large is probably a bad idea", configuredMaxSSTableSize);
1:                 }
commit:6362b94
commit:d2f43e4
/////////////////////////////////////////////////////////////////////////
0:         int configuredMaxSSTableSize = 160;
0:             if (options.containsKey(SSTABLE_SIZE_OPTION))
0:                 configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));
0:                 if (configuredMaxSSTableSize >= 1000)
1:                 {
0:                     // Yes, people have done this
0:                     logger.warn("Max sstable size of {}MB is configured; having a unit of compaction this large is probably a bad idea", configuredMaxSSTableSize);
1:                 }
commit:98b9cb4
/////////////////////////////////////////////////////////////////////////
0:             if (configuredMaxSSTableSize >= 1000)
1:             {
0:                 // Yes, people have done this
0:                 logger.warn("Max sstable size of {}MB is configured; having a unit of compaction this large is probably a bad idea", configuredMaxSSTableSize);
1:             }
commit:03f0116
/////////////////////////////////////////////////////////////////////////
0:             if (configuredMaxSSTableSize >= 1000)
1:             {
0:                 // Yes, people have done this
0:                 logger.warn("Max sstable size of {}MB is configured; having a unit of compaction this large is probably a bad idea", configuredMaxSSTableSize);
1:             }
commit:74f37b5
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.util.concurrent.RateLimiter;
/////////////////////////////////////////////////////////////////////////
0:                     scanners.add(sstable.getScanner(range, CompactionManager.instance.getRateLimiter()));
/////////////////////////////////////////////////////////////////////////
0:             currentScanner = sstableIterator.next().getScanner(range, CompactionManager.instance.getRateLimiter());
/////////////////////////////////////////////////////////////////////////
0:                     currentScanner = sstableIterator.next().getScanner(range, CompactionManager.instance.getRateLimiter());
commit:2b0797b
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.util.concurrent.RateLimiter;
/////////////////////////////////////////////////////////////////////////
0:                     scanners.add(sstable.getDirectScanner(range, CompactionManager.instance.getRateLimiter()));
/////////////////////////////////////////////////////////////////////////
0:             currentScanner = sstableIterator.next().getDirectScanner(range, CompactionManager.instance.getRateLimiter());
/////////////////////////////////////////////////////////////////////////
0:                     currentScanner = sstableIterator.next().getDirectScanner(range, CompactionManager.instance.getRateLimiter());
commit:6968f68
/////////////////////////////////////////////////////////////////////////
1:         SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);
/////////////////////////////////////////////////////////////////////////
0:         manifest = LeveledManifest.create(cfs, this.maxSSTableSizeInMB, Collections.<SSTableReader>emptyList(), localOptions);
/////////////////////////////////////////////////////////////////////////
1:         uncheckedOptions = SizeTieredCompactionStrategyOptions.validateOptions(options, uncheckedOptions);
1: 
commit:75d5639
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.Pair;
/////////////////////////////////////////////////////////////////////////
0:             Pair<? extends Collection<SSTableReader>, Integer> pair = manifest.getCompactionCandidates();
0:             Collection<SSTableReader> sstables;
1:             OperationType op;
0:             int level;
0:             if (pair == null)
/////////////////////////////////////////////////////////////////////////
0:                 level = sstable.getSSTableLevel();
1:             }
0:             else
1:             {
1:                 op = OperationType.COMPACTION;
0:                 sstables = pair.left;
0:                 level = pair.right;
0:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, level, gcBefore, maxSSTableSizeInMB);
/////////////////////////////////////////////////////////////////////////
commit:01bc564
/////////////////////////////////////////////////////////////////////////
0:                     scanners.add(sstable.getDirectScanner(range));
/////////////////////////////////////////////////////////////////////////
0:             currentScanner = sstableIterator.next().getDirectScanner(range);
/////////////////////////////////////////////////////////////////////////
0:                     currentScanner = sstableIterator.next().getDirectScanner(range);
commit:effdb08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 List<SSTableReader> intersecting = LeveledScanner.intersecting(byLevel.get(level), range);
0:                 if (!intersecting.isEmpty())
0:                     scanners.add(new LeveledScanner(intersecting, range));
/////////////////////////////////////////////////////////////////////////
1:             // add only sstables that intersect our range, and estimate how much data that involves
0:             this.sstables = new ArrayList<SSTableReader>(sstables.size());
1:             {
1:                 this.sstables.add(sstable);
1:                 long estimatedKeys = sstable.estimatedKeys();
1:                 double estKeysInRangeRatio = 1.0;
1: 
0:                 if (estimatedKeys > 0 && range != null)
0:                     estKeysInRangeRatio = ((double) sstable.estimatedKeysForRanges(Collections.singleton(range))) / estimatedKeys;
1: 
1:                 length += sstable.uncompressedLength() * estKeysInRangeRatio;
1:             }
1: 
0:             Collections.sort(this.sstables, SSTable.sstableComparator);
1:             sstableIterator = this.sstables.iterator();
1:             assert sstableIterator.hasNext(); // caller should check intersecting first
0:             currentScanner = sstableIterator.next().getDirectScanner(range);
1:         }
1: 
0:         public static List<SSTableReader> intersecting(Collection<SSTableReader> sstables, Range<Token> range)
1:         {
0:             ArrayList<SSTableReader> filtered = new ArrayList<SSTableReader>();
1:             for (SSTableReader sstable : sstables)
1:             {
0:                 Range<Token> sstableRange = new Range<Token>(sstable.first.getToken(), sstable.last.getToken(), sstable.partitioner);
0:                 if (range == null || sstableRange.intersects(range))
0:                     filtered.add(sstable);
1:             }
1:             return filtered;
1:             if (currentScanner == null)
1:                 return endOfData();
1: 
commit:d72e938
/////////////////////////////////////////////////////////////////////////
0:     public synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
0:         if (!isActive || cfs.isCompactionDisabled())
commit:c5f9ac8
commit:a416649
/////////////////////////////////////////////////////////////////////////
0:         private ICompactionScanner currentScanner;
commit:4042ef2
commit:686f516
/////////////////////////////////////////////////////////////////////////
0:     public AbstractCompactionTask getMaximalTask(int gcBefore)
1:         while (true)
0:             Collection<SSTableReader> sstables = manifest.getCompactionCandidates();
0:             OperationType op = OperationType.COMPACTION;
1:             if (sstables.isEmpty())
1:                 // if there is no sstable to compact in standard way, try compacting based on droppable tombstone ratio
1:                 SSTableReader sstable = findDroppableSSTable(gcBefore);
1:                 if (sstable == null)
1:                 {
0:                     logger.debug("No compaction necessary for {}", this);
1:                     return null;
1:                 }
0:                 sstables = Collections.singleton(sstable);
1:                 op = OperationType.TOMBSTONE_COMPACTION;
0:             if (cfs.getDataTracker().markCompacting(sstables))
1:             {
0:                 LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, maxSSTableSizeInMB);
1:                 newTask.setCompactionType(op);
0:                 return newTask;
1:             }
/////////////////////////////////////////////////////////////////////////
0:             Set<SSTableReader> compacting = cfs.getDataTracker().getCompacting();
1:                 else if (!compacting.contains(sstable) && !sstable.isMarkedSuspect() && worthDroppingTombstones(sstable, gcBefore))
commit:278a5e8
/////////////////////////////////////////////////////////////////////////
0:             manifest.replace(listChangedNotification.removed, listChangedNotification.added);
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(sstable.getSSTableLevel()).add(sstable);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int getNextLevel(Collection<SSTableReader> sstables, OperationType operationType)
1:     {
0:         return manifest.getNextLevel(sstables, operationType);
1:     }
commit:5bd57cb
/////////////////////////////////////////////////////////////////////////
0:             switch (listChangedNotification.compactionType)
1:             {
0:                 // Cleanup, scrub and updateSSTable shouldn't promote (see #3989)
0:                 case CLEANUP:
0:                 case SCRUB:
0:                 case UPGRADE_SSTABLES:
0:                 case TOMBSTONE_COMPACTION: // Also when performing tombstone removal.
0:                     manifest.replace(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
0:                 default:
0:                     manifest.promote(listChangedNotification.removed, listChangedNotification.added);
0:                     break;
1:             }
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(manifest.levelOf(sstable)).add(sstable);
/////////////////////////////////////////////////////////////////////////
commit:0e28478
/////////////////////////////////////////////////////////////////////////
0:             manifest.replace(listChangedNotification.removed, listChangedNotification.added);
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(sstable.getSSTableLevel()).add(sstable);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int getNextLevel(Collection<SSTableReader> sstables, OperationType operationType)
1:     {
0:         return manifest.getNextLevel(sstables, operationType);
1:     }
commit:9e14e19
/////////////////////////////////////////////////////////////////////////
1:         return String.format("LCS@%d(%s)", hashCode(), cfs.name);
commit:aff58e8
commit:b034297
/////////////////////////////////////////////////////////////////////////
0:             sstableIterator = this.sstables.iterator();
0:             currentScanner = sstableIterator.next().getDirectScanner(range);
/////////////////////////////////////////////////////////////////////////
0:                 while (true)
1: 
0:                     positionOffset += currentScanner.getLengthInBytes();
1:                     currentScanner.close();
0:                     if (!sstableIterator.hasNext())
0:                         return endOfData();
0:                     currentScanner = sstableIterator.next().getDirectScanner(range);
commit:7d857e6
/////////////////////////////////////////////////////////////////////////
0:             if (value != null)
commit:debb15e
/////////////////////////////////////////////////////////////////////////
0:     public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables, Range<Token> range)
commit:213974d
commit:d90f0f3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * the only difference between background and maximal in LCS is that maximal is still allowed
1:      * (by explicit user request) even when compaction is disabled.
1:      */
0:         if (cfs.isCompactionDisabled())
0:             return null;
1: 
0:         return getMaximalTask(gcBefore);
1:     }
1: 
0:     public AbstractCompactionTask getMaximalTask(int gcBefore)
1:     {
/////////////////////////////////////////////////////////////////////////
commit:6f65c8c
commit:a2a28a4
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(manifest.levelOf(sstable)).add(sstable);
0:                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
0:                 scanners.add(new LeveledScanner(byLevel.get(level), range));
commit:08848e7
/////////////////////////////////////////////////////////////////////////
1:         {
0:             int level = manifest.levelOf(sstable);
0:             assert level >= 0;
0:             byLevel.get(level).add(sstable);
1:         }
0:                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each.
0:                 ArrayList<SSTableReader> sstables1 = new ArrayList<SSTableReader>(byLevel.get(level));
0:                 scanners.add(new LeveledScanner(sstables1, range));
1: 
0:                 Collections.sort(sstables1, SSTable.sstableComparator);
0:                 SSTableReader previous = null;
0:                 for (SSTableReader sstable : sstables1)
1:                 {
0:                     assert previous == null || sstable.first.compareTo(previous.last) > 0 : String.format("%s >= %s in %s and %s for %s in %s",
0:                                                                                                           previous.last,
0:                                                                                                           sstable.first,
0:                                                                                                           previous,
0:                                                                                                           sstable,
0:                                                                                                           sstable.getColumnFamilyName(),
0:                                                                                                           manifest.getLevel(level));
0:                     previous = sstable;
1:                 }
commit:67ed39f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:         for (Integer level : byLevel.keySet())
1:         {
0:             if (level == 0)
1:             {
0:                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
0:                 for (SSTableReader sstable : byLevel.get(level))
0:                     scanners.add(sstable.getDirectScanner(range));
1:             }
0:             else
1:             {
0:                 // Create a LeveledScanner that only opens one sstable at a time, in sorted order
0:                 scanners.add(new LeveledScanner(byLevel.get(level), range));
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         public LeveledScanner(Collection<SSTableReader> sstables, Range<Token> range)
0:             this.sstables = new ArrayList<SSTableReader>(sstables);
0:             Collections.sort(this.sstables, SSTable.sstableComparator);
0:             this.sstableIterator = this.sstables.iterator();
/////////////////////////////////////////////////////////////////////////
0:                 currentScanner = sstableIterator.next().getDirectScanner(range);
commit:4d7e703
/////////////////////////////////////////////////////////////////////////
1:         {
0:             int level = manifest.levelOf(sstable);
0:             assert level >= 0;
0:             byLevel.get(level).add(sstable);
1:         }
0:                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each.
0:                 ArrayList<SSTableReader> sstables1 = new ArrayList<SSTableReader>(byLevel.get(level));
0:                 scanners.add(new LeveledScanner(sstables1, range));
1: 
0:                 Collections.sort(sstables1, SSTable.sstableComparator);
0:                 SSTableReader previous = null;
0:                 for (SSTableReader sstable : sstables1)
1:                 {
0:                     assert previous == null || sstable.first.compareTo(previous.last) > 0 : String.format("%s >= %s in %s and %s for %s in %s",
0:                                                                                                           previous.last,
0:                                                                                                           sstable.first,
0:                                                                                                           previous,
0:                                                                                                           sstable,
0:                                                                                                           sstable.getColumnFamilyName(),
0:                                                                                                           manifest.getLevel(level));
0:                     previous = sstable;
1:                 }
commit:aead8da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:         for (Integer level : byLevel.keySet())
1:         {
0:             if (level == 0)
1:             {
0:                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
0:                 for (SSTableReader sstable : byLevel.get(level))
0:                     scanners.add(sstable.getDirectScanner(range));
1:             }
0:             else
1:             {
0:                 // Create a LeveledScanner that only opens one sstable at a time, in sorted order
0:                 scanners.add(new LeveledScanner(byLevel.get(level), range));
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         public LeveledScanner(Collection<SSTableReader> sstables, Range<Token> range)
0:             this.sstables = new ArrayList<SSTableReader>(sstables);
0:             Collections.sort(this.sstables, SSTable.sstableComparator);
0:             this.sstableIterator = this.sstables.iterator();
/////////////////////////////////////////////////////////////////////////
0:                 currentScanner = sstableIterator.next().getDirectScanner(range);
commit:06a7bf3
commit:46e422a
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
1: import com.google.common.base.Joiner;
1: import com.google.common.collect.*;
0: import org.apache.cassandra.db.columniterator.IColumnIterator;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.io.sstable.SSTableScanner;
/////////////////////////////////////////////////////////////////////////
0:     public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables, Range<Token> range) throws IOException
0:     {
1:         Multimap<Integer, SSTableReader> byLevel = ArrayListMultimap.create();
1:         for (SSTableReader sstable : sstables)
0:             byLevel.get(manifest.levelOf(sstable)).add(sstable);
1: 
0:         List<ICompactionScanner> scanners = new ArrayList<ICompactionScanner>(sstables.size());
0:         for (Integer level : ImmutableSortedSet.copyOf(byLevel.keySet()))
0:             scanners.add(new LeveledScanner(new ArrayList<SSTableReader>(byLevel.get(level)), range));
1: 
0:         return scanners;
1:     }
1: 
1:     // Lazily creates SSTableBoundedScanner for sstable that are assumed to be from the
1:     // same level (e.g. non overlapping) - see #4142
0:     private static class LeveledScanner extends AbstractIterator<IColumnIterator> implements ICompactionScanner
0:     {
0:         private final Range<Token> range;
1:         private final List<SSTableReader> sstables;
1:         private final Iterator<SSTableReader> sstableIterator;
1:         private final long totalLength;
1: 
0:         private SSTableScanner currentScanner;
1:         private long positionOffset;
1: 
0:         public LeveledScanner(List<SSTableReader> sstables, Range<Token> range)
0:         {
0:             this.range = range;
0:             this.sstables = sstables;
1: 
0:             // Sorting a list we got in argument is bad but it's all private to this class so let's not bother
0:             Collections.sort(sstables, SSTable.sstableComparator);
0:             this.sstableIterator = sstables.iterator();
1: 
1:             long length = 0;
1:             for (SSTableReader sstable : sstables)
0:                 length += sstable.uncompressedLength();
1:             totalLength = length;
1:         }
1: 
0:         protected IColumnIterator computeNext()
0:         {
0:             try
0:             {
1:                 if (currentScanner != null)
0:                 {
0:                     if (currentScanner.hasNext())
0:                     {
0:                         return currentScanner.next();
1:                     }
0:                     else
0:                     {
0:                         positionOffset += currentScanner.getLengthInBytes();
0:                         currentScanner.close();
0:                         currentScanner = null;
0:                         return computeNext();
1:                     }
1:                 }
1: 
0:                 if (!sstableIterator.hasNext())
0:                     return endOfData();
1: 
0:                 SSTableReader reader = sstableIterator.next();
0:                 currentScanner = reader.getDirectScanner(range);
0:                 return computeNext();
1:             }
0:             catch (IOException e)
0:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public void close() throws IOException
0:         {
1:             if (currentScanner != null)
0:                 currentScanner.close();
1:         }
1: 
1:         public long getLengthInBytes()
0:         {
1:             return totalLength;
1:         }
1: 
1:         public long getCurrentPosition()
0:         {
1:             return positionOffset + (currentScanner == null ? 0L : currentScanner.getCurrentPosition());
1:         }
1: 
1:         public String getBackingFiles()
0:         {
1:             return Joiner.on(", ").join(sstables);
1:         }
1:     }
1: 
commit:be1b02b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
0:             return null;
0:             return null;
0:                ? newTask
0:                : null;
0:     public AbstractCompactionTask getMaximalTask(int gcBefore)
0:         return getNextBackgroundTask(gcBefore);
commit:3bf9c79
/////////////////////////////////////////////////////////////////////////
commit:2eba60e
/////////////////////////////////////////////////////////////////////////
0:     private final LeveledManifest manifest;
/////////////////////////////////////////////////////////////////////////
commit:127dc35
/////////////////////////////////////////////////////////////////////////
0:         return manifest.getEstimatedTasks();
commit:3ad3e73
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
0: import com.google.common.collect.ImmutableSet;
0: import com.google.common.collect.Sets;
0: import org.apache.cassandra.io.sstable.SSTable;
/////////////////////////////////////////////////////////////////////////
0:     public boolean isKeyExistenceExpensive(Set<? extends SSTable> sstablesToIgnore)
0:     {
0:         Set<SSTableReader> L0 = ImmutableSet.copyOf(manifest.getLevel(0));
0:         return Sets.difference(L0, sstablesToIgnore).size() + manifest.getLevelCount() > 20;
0:     }
1: 
commit:faaff14
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("{} subscribed to the data tracker.", this);
commit:84a461a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final int maxSSTableSizeInMB;
/////////////////////////////////////////////////////////////////////////
1:         maxSSTableSizeInMB = configuredMaxSSTableSize;
0:         manifest = LeveledManifest.create(cfs, this.maxSSTableSizeInMB);
/////////////////////////////////////////////////////////////////////////
0:         LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSizeInMB);
/////////////////////////////////////////////////////////////////////////
0:     public long getMaxSSTableSize()
0:     {
0:         return maxSSTableSizeInMB * 1024 * 1024;
0:     }
1: 
commit:aab97ff
/////////////////////////////////////////////////////////////////////////
0:         logger.debug("Created {}", manifest);
1: 
0:         // TODO this is redundant wrt the kickoff in AbstractCompactionStrategy, once CASSANDRA-X is done
0:         Runnable runnable = new Runnable()
0:         {
0:             public void run()
0:             {
0:                 CompactionManager.instance.submitBackground(LeveledCompactionStrategy.this.cfs);
0:             }
0:         };
0:         StorageService.optionalTasks.scheduleAtFixedRate(runnable, 5 * 60, 5, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         {
0:             logger.debug("Compaction still in progress for {}", this);
0:         }
0:         {
0:             logger.debug("No compaction necessary for {}", this);
0:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
1:     public String toString()
0:     {
0:         return String.format("LCS@%d(%s)", hashCode(), cfs.columnFamily);
0:     }
commit:31e060a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         super.shutdown();
/////////////////////////////////////////////////////////////////////////
0:         return getBackgroundTasks(gcBefore);
commit:9361543
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicReference<LeveledCompactionTask> task = new AtomicReference<LeveledCompactionTask>();
/////////////////////////////////////////////////////////////////////////
0:     public List<AbstractCompactionTask> getBackgroundTasks(int gcBefore)
0:         LeveledCompactionTask currentTask = task.get();
0:         if (currentTask != null && !currentTask.isDone())
0:             return Collections.emptyList();
1: 
1: 
0:         LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSize);
0:         return task.compareAndSet(currentTask, newTask)
0:                ? Collections.<AbstractCompactionTask>singletonList(newTask)
0:                : Collections.<AbstractCompactionTask>emptyList();
commit:f0ee59d
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db.compaction;
0: 
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.concurrent.TimeUnit;
0: 
0: import org.apache.commons.lang.StringUtils;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
1: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.DataTracker;
0: import org.apache.cassandra.io.sstable.SSTableReader;
0: import org.apache.cassandra.notifications.INotification;
0: import org.apache.cassandra.notifications.INotificationConsumer;
0: import org.apache.cassandra.notifications.SSTableAddedNotification;
0: import org.apache.cassandra.notifications.SSTableListChangedNotification;
0: import org.apache.cassandra.service.StorageService;
0: 
0: public class LeveledCompactionStrategy extends AbstractCompactionStrategy implements INotificationConsumer
0: {
1:     private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);
0: 
0:     private LeveledManifest manifest;
0:     private final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
0:     private final int maxSSTableSize;
0: 
0:     public class ScheduledBackgroundCompaction implements Runnable
0:     {
0:         ColumnFamilyStore cfs;
0: 
0:         public ScheduledBackgroundCompaction(ColumnFamilyStore cfs)
0:         {
0:             this.cfs = cfs;
0:         }
0: 
0:         public void run()
0:         {
0:             if (CompactionManager.instance.getActiveCompactions() == 0)
0:             {
0:                 CompactionManager.instance.submitBackground(cfs);
0:             }
0:         }
0:     }
0: 
1:     public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)
0:     {
1:         super(cfs, options);
0:         int configuredMaxSSTableSize = 5;
0:         if (options != null)
0:         {
0:             String value = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : null;
0:             if (null != value)
0:             {
0:                 try
0:                 {
0:                     configuredMaxSSTableSize = Integer.parseInt(value);
0:                 }
0:                 catch (NumberFormatException ex)
0:                 {
0:                     logger.warn(String.format("%s is not a parsable int (base10) for %s using default value",
0:                                               value, SSTABLE_SIZE_OPTION));
0:                 }
0:             }
0:         }
0:         maxSSTableSize = configuredMaxSSTableSize;
0: 
0:         cfs.getDataTracker().subscribe(this);
0:         logger.info(this + " subscribed to the data tracker.");
0: 
0:         manifest = LeveledManifest.create(cfs, this.maxSSTableSize);
0:         // override min/max for this strategy
0:         cfs.setMaximumCompactionThreshold(Integer.MAX_VALUE);
0:         cfs.setMinimumCompactionThreshold(1);
0: 
0:         DebuggableScheduledThreadPoolExecutor st = StorageService.scheduledTasks;
0:         st.scheduleAtFixedRate(new ScheduledBackgroundCompaction(cfs), 10000, 3000, TimeUnit.MILLISECONDS);
0:     }
0: 
0:     public void shutdown()
0:     {
0:         cfs.getDataTracker().unsubscribe(this);
0:     }
0: 
1:     public int getLevelSize(int i)
0:     {
1:         return manifest.getLevelSize(i);
0:     }
0: 
0:     public synchronized List<AbstractCompactionTask> getBackgroundTasks(int gcBefore)
0:     {
0:         Collection<SSTableReader> sstables = manifest.getCompactionCandidates();
0:         logger.debug("CompactionManager candidates are {}", StringUtils.join(sstables, ","));
0:         if (sstables.isEmpty())
0:             return Collections.emptyList();
0:         LeveledCompactionTask task = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSize);
0:         return Collections.<AbstractCompactionTask>singletonList(task);
0:     }
0: 
0:     public List<AbstractCompactionTask> getMaximalTasks(int gcBefore)
0:     {
0:         return Collections.emptyList();
0:     }
0: 
1:     public AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
0:     {
0:         throw new UnsupportedOperationException("LevelDB compaction strategy does not allow user-specified compactions");
0:     }
0: 
1:     public int getEstimatedRemainingTasks()
0:     {
0:         return 0;
0:     }
0: 
0:     public void handleNotification(INotification notification, Object sender)
0:     {
0:         if (notification instanceof SSTableAddedNotification)
0:         {
0:             SSTableAddedNotification flushedNotification = (SSTableAddedNotification) notification;
0:             manifest.add(flushedNotification.added);
0:             manifest.logDistribution();
0:         }
0:         else if (notification instanceof SSTableListChangedNotification)
0:         {
0:             SSTableListChangedNotification listChangedNotification = (SSTableListChangedNotification) notification;
0:             manifest.promote(listChangedNotification.removed, listChangedNotification.added);
0:             manifest.logDistribution();
0:         }
0:     }
0: }
commit:f9497f4
/////////////////////////////////////////////////////////////////////////
commit:ed0df5f
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db.compaction;
0: 
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.concurrent.TimeUnit;
0: 
0: import org.apache.commons.lang.StringUtils;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.DataTracker;
0: import org.apache.cassandra.io.sstable.SSTableReader;
0: import org.apache.cassandra.notifications.INotification;
0: import org.apache.cassandra.notifications.INotificationConsumer;
0: import org.apache.cassandra.notifications.SSTableAddedNotification;
0: import org.apache.cassandra.notifications.SSTableListChangedNotification;
0: import org.apache.cassandra.service.StorageService;
0: 
0: public class LeveledCompactionStrategy extends AbstractCompactionStrategy implements INotificationConsumer
0: {
0:     private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);
0: 
0:     private LeveledManifest manifest;
0:     private final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
0:     private final int maxSSTableSize;
0: 
0:     public class ScheduledBackgroundCompaction implements Runnable
0:     {
0:         ColumnFamilyStore cfs;
0: 
0:         public ScheduledBackgroundCompaction(ColumnFamilyStore cfs)
0:         {
0:             this.cfs = cfs;
0:         }
0: 
0:         public void run()
0:         {
0:             if (CompactionManager.instance.getActiveCompactions() == 0)
0:             {
0:                 CompactionManager.instance.submitBackground(cfs);
0:             }
0:         }
0:     }
0: 
0:     public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)
0:     {
0:         super(cfs, options);
0:         int configuredMaxSSTableSize = 5;
0:         if (options != null)
0:         {
0:             String value = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : null;
0:             if (null != value)
0:             {
0:                 try
0:                 {
0:                     configuredMaxSSTableSize = Integer.parseInt(value);
0:                 }
0:                 catch (NumberFormatException ex)
0:                 {
0:                     logger.warn(String.format("%s is not a parsable int (base10) for %s using default value",
0:                                               value, SSTABLE_SIZE_OPTION));
0:                 }
0:             }
0:         }
0:         maxSSTableSize = configuredMaxSSTableSize;
0: 
0:         DataTracker.subscribe(this);
0:         logger.info(this + " subscribed to the data tracker.");
0: 
0:         manifest = LeveledManifest.create(cfs, this.maxSSTableSize);
0:         // override min/max for this strategy
0:         cfs.setMaximumCompactionThreshold(Integer.MAX_VALUE);
0:         cfs.setMinimumCompactionThreshold(1);
0: 
0:         DebuggableScheduledThreadPoolExecutor st = StorageService.scheduledTasks;
0:         st.scheduleAtFixedRate(new ScheduledBackgroundCompaction(cfs), 10000, 3000, TimeUnit.MILLISECONDS);
0:     }
0: 
0:     public void shutdown()
0:     {
0:         DataTracker.unsubscribe(this);
0:     }
0: 
0:     public int getLevelSize(int i)
0:     {
0:         return manifest.getLevelSize(i);
0:     }
0: 
0:     public synchronized List<AbstractCompactionTask> getBackgroundTasks(int gcBefore)
0:     {
0:         Collection<SSTableReader> sstables = manifest.getCompactionCandidates();
0:         logger.debug("CompactionManager candidates are {}", StringUtils.join(sstables, ","));
0:         if (sstables.isEmpty())
0:             return Collections.emptyList();
0:         LeveledCompactionTask task = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSize);
0:         return Collections.<AbstractCompactionTask>singletonList(task);
0:     }
0: 
0:     public List<AbstractCompactionTask> getMaximalTasks(int gcBefore)
0:     {
0:         return Collections.emptyList();
0:     }
0: 
0:     public AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
0:     {
0:         throw new UnsupportedOperationException("LevelDB compaction strategy does not allow user-specified compactions");
0:     }
0: 
0:     public int getEstimatedRemainingTasks()
0:     {
0:         return 0;
0:     }
0: 
0:     public void handleNotification(INotification notification, Object sender)
0:     {
0:         if (notification instanceof SSTableAddedNotification)
0:         {
0:             SSTableAddedNotification flushedNotification = (SSTableAddedNotification) notification;
0:             manifest.add(flushedNotification.added);
0:             manifest.logDistribution();
0:         }
0:         else if (notification instanceof SSTableListChangedNotification)
0:         {
0:             SSTableListChangedNotification listChangedNotification = (SSTableListChangedNotification) notification;
0:             manifest.promote(listChangedNotification.removed, listChangedNotification.added);
0:             manifest.logDistribution();
0:         }
0:     }
0: }
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:f388c9d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Collections.sort(this.sstables, SSTableReader.sstableComparator);
commit:61f5e50
commit:b8874ad
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.annotations.VisibleForTesting;
/////////////////////////////////////////////////////////////////////////
1:     @VisibleForTesting
1:     final LeveledManifest manifest;
/////////////////////////////////////////////////////////////////////////
0:                     {
0:                         // reset to null so getCurrentPosition does not return wrong value
0:                         currentScanner = null;
0:                     }
commit:4376ce7
/////////////////////////////////////////////////////////////////////////
0:             byLevel.get(manifest.levelOf(sstable)).add(sstable);
commit:771005e
commit:e1491f3
/////////////////////////////////////////////////////////////////////////
0:             // level can be -1 when sstables are added to DataTracker but not to LeveledManifest
0:             // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
0:             if (level <= 0)
commit:2a3076b
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.annotations.VisibleForTesting;
/////////////////////////////////////////////////////////////////////////
0:     @VisibleForTesting
0:     final LeveledManifest manifest;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized AbstractCompactionTask getMaximalTask(int gcBefore)
/////////////////////////////////////////////////////////////////////////
0:         if (!cfs.getDataTracker().markCompacting(sstables))
0:         {
0:             logger.debug("Unable to mark {} for compaction; probably a user-defined compaction got in the way", sstables);
0:             return null;
0:         }
0: 
0:         LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, maxSSTableSizeInMB);
0:         return newTask;
/////////////////////////////////////////////////////////////////////////
commit:c64d975
/////////////////////////////////////////////////////////////////////////
1:     public int[] getAllLevelSize()
0:     {
1:         return manifest.getAllLevelSize();
0:     }
0: 
commit:0091af9
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.primitives.Doubles;
/////////////////////////////////////////////////////////////////////////
0:         OperationType op = OperationType.COMPACTION;
0:             // if there is no sstable to compact in standard way, try compacting based on droppable tombstone ratio
0:             SSTableReader sstable = findDroppableSSTable(gcBefore);
0:             if (sstable == null)
0:             {
0:                 logger.debug("No compaction necessary for {}", this);
0:                 return null;
0:             }
0:             sstables = Collections.singleton(sstable);
0:             op = OperationType.TOMBSTONE_COMPACTION;
0:         newTask.setCompactionType(op);
/////////////////////////////////////////////////////////////////////////
0:                 case TOMBSTONE_COMPACTION: // Also when performing tombstone removal.
/////////////////////////////////////////////////////////////////////////
0: 
1:     private SSTableReader findDroppableSSTable(final int gcBefore)
0:     {
1:         level:
1:         for (int i = manifest.getLevelCount(); i >= 0; i--)
0:         {
1:             // sort sstables by droppable ratio in descending order
1:             SortedSet<SSTableReader> sstables = manifest.getLevelSorted(i, new Comparator<SSTableReader>()
0:             {
1:                 public int compare(SSTableReader o1, SSTableReader o2)
0:                 {
1:                     double r1 = o1.getEstimatedDroppableTombstoneRatio(gcBefore);
1:                     double r2 = o2.getEstimatedDroppableTombstoneRatio(gcBefore);
1:                     return -1 * Doubles.compare(r1, r2);
0:                 }
1:             });
0:             if (sstables.isEmpty())
1:                 continue;
0: 
0:             for (SSTableReader sstable : sstables)
0:             {
1:                 if (sstable.getEstimatedDroppableTombstoneRatio(gcBefore) <= tombstoneThreshold)
1:                     continue level;
0:                 else if (!sstable.isMarkedSuspect() && worthDroppingTombstones(sstable, gcBefore))
1:                     return sstable;
0:             }
0:         }
0:         return null;
0:     }
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:480a1a8
commit:27ed655
/////////////////////////////////////////////////////////////////////////
0:                     scanners.add(sstable.getScanner(range));
/////////////////////////////////////////////////////////////////////////
0:             currentScanner = sstableIterator.next().getScanner(range);
/////////////////////////////////////////////////////////////////////////
0:                     currentScanner = sstableIterator.next().getScanner(range);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:8aeb2fe
/////////////////////////////////////////////////////////////////////////
1:         return maxSSTableSizeInMB * 1024L * 1024L;
============================================================================