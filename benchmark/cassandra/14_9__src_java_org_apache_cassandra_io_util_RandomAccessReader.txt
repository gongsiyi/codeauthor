1:07cf56f: /*
1:1ecabe6:  * Licensed to the Apache Software Foundation (ASF) under one
1:1ecabe6:  * or more contributor license agreements.  See the NOTICE file
1:1ecabe6:  * distributed with this work for additional information
1:1ecabe6:  * regarding copyright ownership.  The ASF licenses this file
1:1ecabe6:  * to you under the Apache License, Version 2.0 (the
1:1ecabe6:  * "License"); you may not use this file except in compliance
1:1ecabe6:  * with the License.  You may obtain a copy of the License at
1:ce63ccc:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
2:1ecabe6:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:1ecabe6:  */
1:d389047: package org.apache.cassandra.io.util;
1:ce63ccc: 
1:b4133f3: import java.io.File;
1:b4133f3: import java.io.IOException;
1:ce63ccc: import java.nio.ByteOrder;
1:30bb255: 
1:ce63ccc: import com.google.common.primitives.Ints;
1:967a2cf: 
1:3adfd15: import org.apache.cassandra.io.compress.BufferType;
1:30bb255: import org.apache.cassandra.io.util.Rebufferer.BufferHolder;
1:ce63ccc: 
1:ce63ccc: public class RandomAccessReader extends RebufferingInputStream implements FileDataInput
1:ce63ccc: {
1:ce63ccc:     // The default buffer size when the client doesn't specify it
1:6422e34:     public static final int DEFAULT_BUFFER_SIZE = 4096;
1:ce63ccc: 
1:ce63ccc:     // offset of the last file mark
1:b4133f3:     private long markedPointer;
1:ce63ccc: 
1:30bb255:     final Rebufferer rebufferer;
1:b4133f3:     private BufferHolder bufferHolder = Rebufferer.EMPTY;
1:ce63ccc: 
1:b4133f3:     /**
1:b4133f3:      * Only created through Builder
1:b4133f3:      *
1:b4133f3:      * @param rebufferer Rebufferer to use
1:b4133f3:      */
1:b4133f3:     RandomAccessReader(Rebufferer rebufferer)
1:30bb255:     {
1:30bb255:         super(Rebufferer.EMPTY.buffer());
1:30bb255:         this.rebufferer = rebufferer;
1:ce63ccc:     }
1:30bb255: 
1:b4133f3:     /**
1:d389047:      * Read data from file starting from current currentOffset to populate buffer.
1:d389047:      */
1:ce63ccc:     public void reBuffer()
1:30bb255:     {
1:ce63ccc:         if (isEOF())
1:967a2cf:             return;
1:30bb255: 
1:30bb255:         reBufferAt(current());
1:30bb255:     }
1:967a2cf: 
1:b4133f3:     private void reBufferAt(long position)
1:30bb255:     {
1:30bb255:         bufferHolder.release();
1:30bb255:         bufferHolder = rebufferer.rebuffer(position);
1:30bb255:         buffer = bufferHolder.buffer();
1:30bb255:         buffer.position(Ints.checkedCast(position - bufferHolder.offset()));
1:967a2cf: 
1:ce63ccc:         assert buffer.order() == ByteOrder.BIG_ENDIAN : "Buffer must have BIG ENDIAN byte ordering";
1:30bb255:     }
1:967a2cf: 
1:17dd4cc:     @Override
1:d389047:     public long getFilePointer()
1:967a2cf:     {
1:30bb255:         if (buffer == null)     // closed already
1:30bb255:             return rebufferer.fileLength();
1:c18ce58:         return current();
1:967a2cf:     }
1:30bb255: 
1:c18ce58:     protected long current()
1:967a2cf:     {
1:30bb255:         return bufferHolder.offset() + buffer.position();
1:967a2cf:     }
1:30bb255: 
1:d389047:     public String getPath()
1:ce63ccc:     {
1:30bb255:         return getChannel().filePath();
1:ce63ccc:     }
1:30bb255: 
1:ce63ccc:     public ChannelProxy getChannel()
1:ce63ccc:     {
1:30bb255:         return rebufferer.channel();
1:ce63ccc:     }
1:30bb255: 
1:ce63ccc:     @Override
1:ce63ccc:     public void reset() throws IOException
1:ce63ccc:     {
1:d389047:         seek(markedPointer);
1:ce63ccc:     }
1:967a2cf: 
1:ce63ccc:     @Override
1:ce63ccc:     public boolean markSupported()
1:ce63ccc:     {
1:ce63ccc:         return true;
1:ce63ccc:     }
1:967a2cf: 
1:d389047:     public long bytesPastMark()
1:ce63ccc:     {
1:c18ce58:         long bytes = current() - markedPointer;
1:d389047:         assert bytes >= 0;
1:d389047:         return bytes;
1:ce63ccc:     }
1:ce63ccc: 
1:e8651b6:     public DataPosition mark()
1:ce63ccc:     {
1:c18ce58:         markedPointer = current();
1:d389047:         return new BufferedRandomAccessFileMark(markedPointer);
1:ce63ccc:     }
1:ce63ccc: 
1:e8651b6:     public void reset(DataPosition mark)
1:ce63ccc:     {
1:d389047:         assert mark instanceof BufferedRandomAccessFileMark;
1:d389047:         seek(((BufferedRandomAccessFileMark) mark).pointer);
1:ce63ccc:     }
1:ce63ccc: 
1:e8651b6:     public long bytesPastMark(DataPosition mark)
1:ce63ccc:     {
1:d389047:         assert mark instanceof BufferedRandomAccessFileMark;
1:c18ce58:         long bytes = current() - ((BufferedRandomAccessFileMark) mark).pointer;
1:d389047:         assert bytes >= 0;
1:d389047:         return bytes;
1:ce63ccc:     }
1:ce63ccc: 
1:ce63ccc:     /**
1:d389047:      * @return true if there is no more data to read
1:d389047:      */
1:debb15e:     public boolean isEOF()
1:ce63ccc:     {
1:ce63ccc:         return current() == length();
1:ce63ccc:     }
1:ce63ccc: 
1:debb15e:     public long bytesRemaining()
1:ce63ccc:     {
1:d389047:         return length() - getFilePointer();
1:ce63ccc:     }
1:ce63ccc: 
9:d389047:     @Override
1:ce63ccc:     public int available() throws IOException
1:ce63ccc:     {
1:ce63ccc:         return Ints.saturatedCast(bytesRemaining());
1:ce63ccc:     }
1:ce63ccc: 
1:ce63ccc:     @Override
1:17dd4cc:     public void close()
1:ce63ccc:     {
1:30bb255:         // close needs to be idempotent.
1:17dd4cc:         if (buffer == null)
1:0ced7a3:             return;
1:ce63ccc: 
1:30bb255:         bufferHolder.release();
1:30bb255:         rebufferer.closeReader();
1:30bb255:         buffer = null;
1:30bb255:         bufferHolder = null;
1:ce63ccc: 
1:ce63ccc:         //For performance reasons we don't keep a reference to the file
1:ce63ccc:         //channel so we don't close it
1:ce63ccc:     }
1:ce63ccc: 
1:d389047:     @Override
1:d389047:     public String toString()
1:ce63ccc:     {
1:30bb255:         return getClass().getSimpleName() + ':' + rebufferer.toString();
1:ce63ccc:     }
1:ce63ccc: 
1:d389047:     /**
1:d389047:      * Class to hold a mark to the position of the file
1:d389047:      */
1:b4133f3:     private static class BufferedRandomAccessFileMark implements DataPosition
1:ce63ccc:     {
1:5a6e2b0:         final long pointer;
1:ce63ccc: 
1:b4133f3:         private BufferedRandomAccessFileMark(long pointer)
1:ce63ccc:         {
1:d389047:             this.pointer = pointer;
1:ce63ccc:         }
1:ce63ccc:     }
1:ce63ccc: 
1:d389047:     @Override
1:debb15e:     public void seek(long newPosition)
1:ce63ccc:     {
1:d389047:         if (newPosition < 0)
1:d389047:             throw new IllegalArgumentException("new position should not be negative");
1:ce63ccc: 
1:17dd4cc:         if (buffer == null)
1:17dd4cc:             throw new IllegalStateException("Attempted to seek in a closed RAR");
1:ce63ccc: 
1:30bb255:         long bufferOffset = bufferHolder.offset();
1:c18ce58:         if (newPosition >= bufferOffset && newPosition < bufferOffset + buffer.limit())
1:ce63ccc:         {
1:c18ce58:             buffer.position((int) (newPosition - bufferOffset));
1:ce63ccc:             return;
1:ce63ccc:         }
1:30bb255: 
1:30bb255:         if (newPosition > length())
1:30bb255:             throw new IllegalArgumentException(String.format("Unable to seek to position %d in %s (%d bytes) in read-only mode",
1:30bb255:                                                          newPosition, getPath(), length()));
1:30bb255:         reBufferAt(newPosition);
1:ce63ccc:     }
1:ce63ccc: 
1:d389047:     /**
1:ce63ccc:      * Reads a line of text form the current position in this file. A line is
1:ce63ccc:      * represented by zero or more characters followed by {@code '\n'}, {@code
1:ce63ccc:      * '\r'}, {@code "\r\n"} or the end of file marker. The string does not
1:ce63ccc:      * include the line terminating sequence.
1:6536c05:      * <p>
1:ce63ccc:      * Blocks until a line terminating sequence has been read, the end of the
1:ce63ccc:      * file is reached or an exception is thrown.
1:6536c05:      * </p>
1:ce63ccc:      * @return the contents of the line or {@code null} if no characters have
1:ce63ccc:      * been read before the end of the file has been reached.
1:ce63ccc:      * @throws IOException if this file is closed or another I/O error occurs.
1:ce63ccc:      */
1:ce63ccc:     public final String readLine() throws IOException
1:ce63ccc:     {
1:ce63ccc:         StringBuilder line = new StringBuilder(80); // Typical line length
1:ce63ccc:         boolean foundTerminator = false;
1:ce63ccc:         long unreadPosition = -1;
1:ce63ccc:         while (true)
1:ce63ccc:         {
1:ce63ccc:             int nextByte = read();
1:ce63ccc:             switch (nextByte)
2:4e29b7a:             {
1:ce63ccc:                 case -1:
1:ce63ccc:                     return line.length() != 0 ? line.toString() : null;
1:ce63ccc:                 case (byte) '\r':
1:ce63ccc:                     if (foundTerminator)
1:ce63ccc:                     {
1:ce63ccc:                         seek(unreadPosition);
1:ce63ccc:                         return line.toString();
1:ce63ccc:                     }
1:ce63ccc:                     foundTerminator = true;
1:ce63ccc:                     /* Have to be able to peek ahead one byte */
1:ce63ccc:                     unreadPosition = getPosition();
1:ce63ccc:                     break;
1:ce63ccc:                 case (byte) '\n':
1:ce63ccc:                     return line.toString();
1:ce63ccc:                 default:
1:ce63ccc:                     if (foundTerminator)
1:ce63ccc:                     {
1:ce63ccc:                         seek(unreadPosition);
1:ce63ccc:                         return line.toString();
1:ce63ccc:                     }
1:ce63ccc:                     line.append((char) nextByte);
1:ce63ccc:             }
1:ce63ccc:         }
1:ce63ccc:     }
1:ce63ccc: 
1:debb15e:     public long length()
1:4e29b7a:     {
1:30bb255:         return rebufferer.fileLength();
1:6422e34:     }
20:ce63ccc: 
1:22e18f5:     public long getPosition()
1:ce63ccc:     {
1:ce63ccc:         return current();
1:ce63ccc:     }
1:ce63ccc: 
1:30bb255:     public double getCrcCheckChance()
1:30bb255:     {
1:30bb255:         return rebufferer.getCrcCheckChance();
1:30bb255:     }
1:30bb255: 
1:ce63ccc:     // A wrapper of the RandomAccessReader that closes the channel when done.
1:ce63ccc:     // For performance reasons RAR does not increase the reference count of
1:ce63ccc:     // a channel but assumes the owner will keep it open and close it,
1:ce63ccc:     // see CASSANDRA-9379, this thin class is just for those cases where we do
1:ce63ccc:     // not have a shared channel.
1:b4133f3:     static class RandomAccessReaderWithOwnChannel extends RandomAccessReader
1:30bb255:     {
1:b4133f3:         RandomAccessReaderWithOwnChannel(Rebufferer rebufferer)
1:30bb255:         {
1:30bb255:             super(rebufferer);
1:30bb255:         }
1:30bb255: 
1:ce63ccc:         @Override
1:ce63ccc:         public void close()
1:30bb255:         {
1:ce63ccc:             try
1:ce63ccc:             {
1:ce63ccc:                 super.close();
1:30bb255:             }
1:ce63ccc:             finally
1:30bb255:             {
1:30bb255:                 try
1:ce63ccc:                 {
1:30bb255:                     rebufferer.close();
1:30bb255:                 }
1:30bb255:                 finally
1:30bb255:                 {
1:30bb255:                     getChannel().close();
1:30bb255:                 }
1:30bb255:             }
1:ce63ccc:         }
1:ce63ccc:     }
1:ce63ccc: 
1:d389047:     /**
1:b4133f3:      * Open a RandomAccessReader (not compressed, not mmapped, no read throttling) that will own its channel.
1:b4133f3:      *
1:b4133f3:      * @param file File to open for reading
1:b4133f3:      * @return new RandomAccessReader that owns the channel opened in this method.
1:b4133f3:      */
1:ce63ccc:     @SuppressWarnings("resource")
1:ce63ccc:     public static RandomAccessReader open(File file)
1:ce63ccc:     {
1:b4133f3:         ChannelProxy channel = new ChannelProxy(file);
1:b4133f3:         try
1:b4133f3:         {
1:b4133f3:             ChunkReader reader = new SimpleChunkReader(channel, -1, BufferType.OFF_HEAP, DEFAULT_BUFFER_SIZE);
1:b4133f3:             Rebufferer rebufferer = reader.instantiateRebufferer();
1:b4133f3:             return new RandomAccessReaderWithOwnChannel(rebufferer);
1:b4133f3:         }
1:b4133f3:         catch (Throwable t)
1:b4133f3:         {
1:b4133f3:             channel.close();
1:b4133f3:             throw t;
1:b4133f3:         }
1:ce63ccc:     }
3:4e29b7a: }
============================================================================
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:b4133f3
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.IOException;
1:     private long markedPointer;
1:     private BufferHolder bufferHolder = Rebufferer.EMPTY;
1:     /**
1:      * Only created through Builder
1:      *
1:      * @param rebufferer Rebufferer to use
1:      */
1:     RandomAccessReader(Rebufferer rebufferer)
/////////////////////////////////////////////////////////////////////////
1:     private void reBufferAt(long position)
/////////////////////////////////////////////////////////////////////////
1:     private static class BufferedRandomAccessFileMark implements DataPosition
1:         private BufferedRandomAccessFileMark(long pointer)
/////////////////////////////////////////////////////////////////////////
1:     static class RandomAccessReaderWithOwnChannel extends RandomAccessReader
1:         RandomAccessReaderWithOwnChannel(Rebufferer rebufferer)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Open a RandomAccessReader (not compressed, not mmapped, no read throttling) that will own its channel.
1:      *
1:      * @param file File to open for reading
1:      * @return new RandomAccessReader that owns the channel opened in this method.
1:      */
1:         ChannelProxy channel = new ChannelProxy(file);
1:         try
1:         {
1:             ChunkReader reader = new SimpleChunkReader(channel, -1, BufferType.OFF_HEAP, DEFAULT_BUFFER_SIZE);
1:             Rebufferer rebufferer = reader.instantiateRebufferer();
1:             return new RandomAccessReaderWithOwnChannel(rebufferer);
1:         }
1:         catch (Throwable t)
1:         {
1:             channel.close();
1:             throw t;
1:         }
commit:587773f
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:30bb255
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.annotations.VisibleForTesting;
0: import org.apache.cassandra.io.compress.CompressionMetadata;
1: import org.apache.cassandra.io.util.Rebufferer.BufferHolder;
/////////////////////////////////////////////////////////////////////////
0:     @VisibleForTesting
1:     final Rebufferer rebufferer;
0:     BufferHolder bufferHolder = Rebufferer.EMPTY;
0:     protected RandomAccessReader(Rebufferer rebufferer)
1:     {
1:         super(Rebufferer.EMPTY.buffer());
1:         this.rebufferer = rebufferer;
0:     public static ByteBuffer allocateBuffer(int size, BufferType bufferType)
/////////////////////////////////////////////////////////////////////////
1:         reBufferAt(current());
1:     }
0:     public void reBufferAt(long position)
1:     {
1:         bufferHolder.release();
1:         bufferHolder = rebufferer.rebuffer(position);
1:         buffer = bufferHolder.buffer();
1:         buffer.position(Ints.checkedCast(position - bufferHolder.offset()));
1:         if (buffer == null)     // closed already
1:             return rebufferer.fileLength();
1:         return bufferHolder.offset() + buffer.position();
1:         return getChannel().filePath();
1:         return rebufferer.channel();
/////////////////////////////////////////////////////////////////////////
1:         // close needs to be idempotent.
1:         bufferHolder.release();
1:         rebufferer.closeReader();
1:         buffer = null;
1:         bufferHolder = null;
/////////////////////////////////////////////////////////////////////////
1:         return getClass().getSimpleName() + ':' + rebufferer.toString();
/////////////////////////////////////////////////////////////////////////
1:         long bufferOffset = bufferHolder.offset();
1: 
1:         if (newPosition > length())
1:             throw new IllegalArgumentException(String.format("Unable to seek to position %d in %s (%d bytes) in read-only mode",
1:                                                          newPosition, getPath(), length()));
1:         reBufferAt(newPosition);
/////////////////////////////////////////////////////////////////////////
1:         return rebufferer.fileLength();
/////////////////////////////////////////////////////////////////////////
1:     public double getCrcCheckChance()
1:     {
1:         return rebufferer.getCrcCheckChance();
1:     }
1: 
0:     protected static Rebufferer instantiateRebufferer(RebuffererFactory fileRebufferer, RateLimiter limiter)
1:     {
0:         Rebufferer rebufferer = fileRebufferer.instantiateRebufferer();
1: 
0:         if (limiter != null)
0:             rebufferer = new LimitingRebufferer(rebufferer, limiter, MAX_BUFFER_SIZE);
1: 
0:         return rebufferer;
1:     }
1: 
0:     public static RandomAccessReader build(SegmentedFile file, RateLimiter limiter)
1:     {
0:         return new RandomAccessReader(instantiateRebufferer(file.rebuffererFactory(), limiter));
1:     }
1: 
0:     public static Builder builder(ChannelProxy channel)
1:     {
0:         return new Builder(channel);
1:     }
1: 
0:         protected int bufferSize;
/////////////////////////////////////////////////////////////////////////
0:         // An optional limiter that will throttle the amount of data we read
0:         public RateLimiter limiter;
1: 
0:         // Compression for compressed readers
0:         public CompressionMetadata compression;
/////////////////////////////////////////////////////////////////////////
0:         private int adjustedBufferSize()
0:                 return MAX_BUFFER_SIZE;
0:             // should already be a page size multiple but if that's not case round it up
0:             int wholePageSize = (bufferSize + 4095) & ~4095;
0:             return Math.min(MAX_BUFFER_SIZE, wholePageSize);
0:         protected Rebufferer createRebufferer()
0:             return instantiateRebufferer(chunkReader(), limiter);
0:         public RebuffererFactory chunkReader()
0:             if (compression != null)
0:                 return CompressedSegmentedFile.chunkReader(channel, compression, regions);
0:             if (regions != null)
0:                 return new MmapRebufferer(channel, -1, regions);
1: 
0:             int adjustedSize = adjustedBufferSize();
0:             return new SimpleChunkReader(channel, -1, bufferType, adjustedSize);
/////////////////////////////////////////////////////////////////////////
0:         public Builder compression(CompressionMetadata metadata)
1:         {
0:             this.compression = metadata;
0:             return this;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             return new RandomAccessReader(createRebufferer());
0:             return new RandomAccessReaderWithOwnChannel(createRebufferer());
/////////////////////////////////////////////////////////////////////////
0:         protected RandomAccessReaderWithOwnChannel(Rebufferer rebufferer)
1:             super(rebufferer);
/////////////////////////////////////////////////////////////////////////
1:                 try
1:                 {
1:                     rebufferer.close();
1:                 }
1:                 finally
1:                 {
1:                     getChannel().close();
1:                 }
commit:3adfd15
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.compress.BufferType;
/////////////////////////////////////////////////////////////////////////
0:     protected RandomAccessReader(ChannelProxy channel, int bufferSize, long overrideLength, BufferType bufferType, PoolingSegmentedFile owner)
/////////////////////////////////////////////////////////////////////////
0:         buffer = allocateBuffer(bufferSize, bufferType);
0:     protected ByteBuffer allocateBuffer(int bufferSize, BufferType bufferType)
0:         return bufferType.allocate(size);
/////////////////////////////////////////////////////////////////////////
0:         return new RandomAccessReader(channel, bufferSize, overrideSize, BufferType.ON_HEAP, owner);
author:Paulo Motta
-------------------------------------------------------------------------------
commit:e8651b6
/////////////////////////////////////////////////////////////////////////
1:     public DataPosition mark()
1:     public void reset(DataPosition mark)
1:     public long bytesPastMark(DataPosition mark)
/////////////////////////////////////////////////////////////////////////
0:     protected static class BufferedRandomAccessFileMark implements DataPosition
author:Dave Brosius
-------------------------------------------------------------------------------
commit:6536c05
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * </p>
commit:bc6b5f4
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:0c92c52
/////////////////////////////////////////////////////////////////////////
commit:967a2cf
/////////////////////////////////////////////////////////////////////////
0:     // The maximum buffer size, we will never buffer more than this size. Further,
0:     // when the limiter is not null, i.e. when throttling is enabled, we read exactly
0:     // this size, since when throttling the intention is to eventually read everything,
0:     // see CASSANDRA-8630
0:     // NOTE: this size is chosen both for historical consistency, as a reasonable upper bound,
0:     //       and because our BufferPool currently has a maximum allocation size of this.
0:     public static final int MAX_BUFFER_SIZE = 1 << 16; // 64k
/////////////////////////////////////////////////////////////////////////
0:     protected final BufferType bufferType;
/////////////////////////////////////////////////////////////////////////
0:         super(builder.createBuffer());
0:         this.bufferSize = builder.bufferSize;
0:         this.buffer = builder.buffer;
0:     protected static ByteBuffer allocateBuffer(int size, BufferType bufferType)
/////////////////////////////////////////////////////////////////////////
0:         // The buffer
0:         public ByteBuffer buffer;
1: 
0:             this.bufferSize = DEFAULT_BUFFER_SIZE;
0:          * make sure that it is a multiple of the page size, 4096. Also limit it to the maximum
0:          * buffer size unless we are throttling, in which case we may as well read the maximum
0:          * directly since the intention is to read the full file, see CASSANDRA-8630.
0:         private void setBufferSize()
0:             if (limiter != null)
1:             {
0:                 bufferSize = MAX_BUFFER_SIZE;
1:                 return;
1: 
0:             if ((bufferSize & ~4095) != bufferSize)
0:             { // should already be a page size multiple but if that's not case round it up
0:                 bufferSize = (bufferSize + 4095) & ~4095;
1:             }
1: 
0:             bufferSize = Math.min(MAX_BUFFER_SIZE, bufferSize);
1:         }
1: 
0:         protected ByteBuffer createBuffer()
1:         {
0:             setBufferSize();
1: 
0:             buffer = regions == null
0:                      ? allocateBuffer(bufferSize, bufferType)
0:                      : regions.floor(0).buffer.duplicate();
1: 
0:             buffer.limit(0);
0:             return buffer;
/////////////////////////////////////////////////////////////////////////
0:             this.bufferSize = bufferSize;
/////////////////////////////////////////////////////////////////////////
commit:ce63ccc
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteOrder;
1: 
1: import com.google.common.primitives.Ints;
0: import com.google.common.util.concurrent.RateLimiter;
1: public class RandomAccessReader extends RebufferingInputStream implements FileDataInput
1:     // The default buffer size when the client doesn't specify it
0:     // The maximum buffer size when the limiter is not null, i.e. when throttling
0:     // is enabled. This is required to avoid aquiring permits that are too large.
0:     public static final int MAX_THROTTLED_BUFFER_SIZE = 1 << 16; // 64k
1: 
0:     // optional memory mapped regions for the channel
0:     protected final MmappedRegions regions;
0:     // An optional limiter that will throttle the amount of data we read
0:     protected final RateLimiter limiter;
0:     // the file length, this can be overridden at construction to a value shorter
0:     // than the true length of the file; if so, it acts as an imposed limit on reads,
0:     // required when opening sstables early not to read past the mark
0:     // the buffer size for buffered readers
0:     protected final int bufferSize;
0:     // the buffer type for buffered readers
0:     private final BufferType bufferType;
1: 
0:     // offset from the beginning of the file
0:     protected long bufferOffset;
1: 
1:     // offset of the last file mark
0:     protected long markedPointer;
1: 
0:     protected RandomAccessReader(Builder builder)
1:     {
0:         super(null);
1: 
0:         this.channel = builder.channel;
0:         this.regions = builder.regions;
0:         this.limiter = builder.limiter;
0:         this.fileLength = builder.overrideLength <= 0 ? builder.channel.size() : builder.overrideLength;
0:         this.bufferSize = getBufferSize(builder);
0:         this.bufferType = builder.bufferType;
1: 
0:         if (builder.bufferSize <= 0)
0:         if (builder.initializeBuffers)
0:             initializeBuffer();
1:     }
0:     protected int getBufferSize(Builder builder)
1:     {
0:         if (builder.limiter == null)
0:             return builder.bufferSize;
1: 
0:         // limit to ensure more accurate throttling
0:         return Math.min(MAX_THROTTLED_BUFFER_SIZE, builder.bufferSize);
1:     }
1: 
0:     protected void initializeBuffer()
1:     {
0:         if (regions == null)
0:             buffer = allocateBuffer(bufferSize);
0:         else
0:             buffer = regions.floor(0).buffer.duplicate();
1: 
0:     protected ByteBuffer allocateBuffer(int size)
0:         return BufferPool.get(size, bufferType).order(ByteOrder.BIG_ENDIAN);
0:     protected void releaseBuffer()
0:         if (buffer != null)
0:             if (regions == null)
0:                 BufferPool.put(buffer);
0:             buffer = null;
1:     public void reBuffer()
1:     {
1:         if (isEOF())
1:             return;
1: 
0:         if (regions == null)
0:             reBufferStandard();
0:         else
0:             reBufferMmap();
1: 
0:         if (limiter != null)
0:             limiter.acquire(buffer.remaining());
1: 
1:         assert buffer.order() == ByteOrder.BIG_ENDIAN : "Buffer must have BIG ENDIAN byte ordering";
1:     }
1: 
0:     protected void reBufferStandard()
0:         buffer.clear();
/////////////////////////////////////////////////////////////////////////
0:                 throw new FSReadError(new IOException("Unexpected end of file"), channel.filePath());
1: 
1: 
0:     protected void reBufferMmap()
1:     {
0:         long position = bufferOffset + buffer.position();
0:         assert position < fileLength;
1: 
0:         MmappedRegions.Region region = regions.floor(position);
0:         bufferOffset = region.bottom();
0:         buffer = region.buffer.duplicate();
0:         buffer.position(Ints.checkedCast(position - bufferOffset));
1: 
0:         if (limiter != null && bufferSize < buffer.remaining())
0:         { // ensure accurate throttling
0:             buffer.limit(buffer.position() + bufferSize);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public ChannelProxy getChannel()
0:         return channel;
1:     @Override
1:     public void reset() throws IOException
1:     @Override
1:     public boolean markSupported()
1:     {
1:         return true;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return current() == length();
/////////////////////////////////////////////////////////////////////////
1:     public int available() throws IOException
1:     {
1:         return Ints.saturatedCast(bytesRemaining());
1:     }
1: 
1:     @Override
0:         releaseBuffer();
1: 
1:         //For performance reasons we don't keep a reference to the file
1:         //channel so we don't close it
0:         return getClass().getSimpleName() + "(filePath='" + channel + "')";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads a line of text form the current position in this file. A line is
1:      * represented by zero or more characters followed by {@code '\n'}, {@code
1:      * '\r'}, {@code "\r\n"} or the end of file marker. The string does not
1:      * include the line terminating sequence.
0:      * <p/>
1:      * Blocks until a line terminating sequence has been read, the end of the
1:      * file is reached or an exception is thrown.
1:      *
1:      * @return the contents of the line or {@code null} if no characters have
1:      * been read before the end of the file has been reached.
1:      * @throws IOException if this file is closed or another I/O error occurs.
1:      */
1:     public final String readLine() throws IOException
1:         StringBuilder line = new StringBuilder(80); // Typical line length
1:         boolean foundTerminator = false;
1:         long unreadPosition = -1;
1:         while (true)
1:             int nextByte = read();
1:             switch (nextByte)
1:                 case -1:
1:                     return line.length() != 0 ? line.toString() : null;
1:                 case (byte) '\r':
1:                     if (foundTerminator)
1:                     {
1:                         seek(unreadPosition);
1:                         return line.toString();
1:                     }
1:                     foundTerminator = true;
1:                     /* Have to be able to peek ahead one byte */
1:                     unreadPosition = getPosition();
1:                     break;
1:                 case (byte) '\n':
1:                     return line.toString();
1:                 default:
1:                     if (foundTerminator)
1:                     {
1:                         seek(unreadPosition);
1:                         return line.toString();
1:                     }
1:                     line.append((char) nextByte);
/////////////////////////////////////////////////////////////////////////
1:         return current();
0:     public static class Builder
0:         // The NIO file channel or an empty channel
0:         public final ChannelProxy channel;
1: 
0:         // We override the file length when we open sstables early, so that we do not
0:         // read past the early mark
0:         public long overrideLength;
1: 
0:         // The size of the buffer for buffered readers
0:         public int bufferSize;
1: 
0:         // The type of the buffer for buffered readers
0:         public BufferType bufferType;
1: 
0:         // The mmap segments for mmap readers
0:         public MmappedRegions regions;
1: 
0:         // An optional limiter that will throttle the amount of data we read
0:         public RateLimiter limiter;
1: 
0:         public boolean initializeBuffers;
1: 
0:         public Builder(ChannelProxy channel)
1:         {
0:             this.channel = channel;
0:             this.overrideLength = -1L;
0:             this.bufferSize = getBufferSize(DEFAULT_BUFFER_SIZE);
0:             this.bufferType = BufferType.OFF_HEAP;
0:             this.regions = null;
0:             this.limiter = null;
0:             this.initializeBuffers = true;
1:         }
1: 
0:         /** The buffer size is typically already page aligned but if that is not the case
0:          * make sure that it is a multiple of the page size, 4096.
0:          * */
0:         private static int getBufferSize(int size)
1:         {
0:             if ((size & ~4095) != size)
0:             { // should already be a page size multiple but if that's not case round it up
0:                 size = (size + 4095) & ~4095;
1:             }
0:             return size;
1:         }
1: 
0:         public Builder overrideLength(long overrideLength)
1:         {
0:             if (overrideLength > channel.size())
0:                 throw new IllegalArgumentException("overrideLength cannot be more than the file size");
1: 
0:             this.overrideLength = overrideLength;
0:             return this;
1:         }
1: 
0:         public Builder bufferSize(int bufferSize)
1:         {
0:             if (bufferSize <= 0)
0:                 throw new IllegalArgumentException("bufferSize must be positive");
1: 
0:             this.bufferSize = getBufferSize(bufferSize);
0:             return this;
1:         }
1: 
0:         public Builder bufferType(BufferType bufferType)
1:         {
0:             this.bufferType = bufferType;
0:             return this;
1:         }
1: 
0:         public Builder regions(MmappedRegions regions)
1:         {
0:             this.regions = regions;
0:             return this;
1:         }
1: 
0:         public Builder limiter(RateLimiter limiter)
1:         {
0:             this.limiter = limiter;
0:             return this;
1:         }
1: 
0:         public Builder initializeBuffers(boolean initializeBuffers)
1:         {
0:             this.initializeBuffers = initializeBuffers;
0:             return this;
1:         }
1: 
0:         public RandomAccessReader build()
1:         {
0:             return new RandomAccessReader(this);
1:         }
1: 
0:         public RandomAccessReader buildWithChannel()
1:         {
0:             return new RandomAccessReaderWithOwnChannel(this);
1:         }
1:     }
1: 
1:     // A wrapper of the RandomAccessReader that closes the channel when done.
1:     // For performance reasons RAR does not increase the reference count of
1:     // a channel but assumes the owner will keep it open and close it,
1:     // see CASSANDRA-9379, this thin class is just for those cases where we do
1:     // not have a shared channel.
0:     public static class RandomAccessReaderWithOwnChannel extends RandomAccessReader
1:     {
0:         protected RandomAccessReaderWithOwnChannel(Builder builder)
1:         {
0:             super(builder);
1:         }
1: 
1:         @Override
1:         public void close()
1:         {
1:             try
1:             {
1:                 super.close();
1:             }
1:             finally
1:             {
0:                 channel.close();
1:             }
1:         }
1:     }
1: 
1:     @SuppressWarnings("resource")
1:     public static RandomAccessReader open(File file)
1:     {
0:         return new Builder(new ChannelProxy(file)).buildWithChannel();
1:     }
1: 
0:     public static RandomAccessReader open(ChannelProxy channel)
1:     {
0:         return new Builder(channel).build();
commit:6422e34
/////////////////////////////////////////////////////////////////////////
1:     public static final int DEFAULT_BUFFER_SIZE = 4096;
/////////////////////////////////////////////////////////////////////////
0:     /** The buffer size is typically already page aligned but if that is not the case
0:      * make sure that it is a multiple of the page size, 4096.
0:      * */
0:         if ((size & ~4095) != size)
0:         { // should already be a page size multiple but if that's not case round it up
0:             size = (size + 4095) & ~4095;
1:         }
0:         return size;
/////////////////////////////////////////////////////////////////////////
0:         return open(channel, DEFAULT_BUFFER_SIZE, -1L);
/////////////////////////////////////////////////////////////////////////
0: 
0:         long pageAligedPos = position & ~4095;
0:         // Because the buffer capacity is a multiple of the page size, we read less
0:         // the first time and then we should read at page boundaries only,
0:         // unless the user seeks elsewhere
0:         long upperLimit = Math.min(fileLength, pageAligedPos + buffer.capacity());
0:         buffer.limit((int)(upperLimit - position));
0:         while (buffer.hasRemaining() && limit < upperLimit)
commit:4e29b7a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected final ChannelProxy channel;
/////////////////////////////////////////////////////////////////////////
0:     protected RandomAccessReader(ChannelProxy channel, int bufferSize, long overrideLength, boolean useDirectBuffer, PoolingSegmentedFile owner)
0:         this.channel = channel.sharedCopy();
0:         fileLength = overrideLength <= 0 ? channel.size() : overrideLength;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static RandomAccessReader open(ChannelProxy channel, long overrideSize, PoolingSegmentedFile owner)
0:         return open(channel, DEFAULT_BUFFER_SIZE, overrideSize, owner);
0:         try (ChannelProxy channel = new ChannelProxy(file))
1:         {
0:             return open(channel);
1:         }
0:     public static RandomAccessReader open(ChannelProxy channel)
0:         return open(channel, -1L);
1:     }
0: 
0:     public static RandomAccessReader open(ChannelProxy channel, long overrideSize)
1:     {
0:         return open(channel, DEFAULT_BUFFER_SIZE, overrideSize, null);
0:     static RandomAccessReader open(ChannelProxy channel, int bufferSize, PoolingSegmentedFile owner)
0:         return open(channel, bufferSize, -1L, owner);
0:     private static RandomAccessReader open(ChannelProxy channel, int bufferSize, long overrideSize, PoolingSegmentedFile owner)
0:         return new RandomAccessReader(channel, bufferSize, overrideSize, false, owner);
0:         try (ChannelProxy channel = new ChannelProxy(writer.getPath()))
1:         {
0:             return open(channel, DEFAULT_BUFFER_SIZE, null);
1:         }
0:     public ChannelProxy getChannel()
/////////////////////////////////////////////////////////////////////////
0:         long position = bufferOffset;
0:         long limit = bufferOffset;
0:         while (buffer.hasRemaining() && limit < fileLength)
0:             int n = channel.read(buffer, position);
0:             if (n < 0)
0:                 break;
0:             position += n;
0:             limit = bufferOffset + buffer.position();
0:         if (limit > fileLength)
0:             buffer.position((int)(fileLength - bufferOffset));
0:         buffer.flip();
/////////////////////////////////////////////////////////////////////////
0:         return channel.filePath();
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
0:         return getClass().getSimpleName() + "(" + "filePath='" + channel + "')";
/////////////////////////////////////////////////////////////////////////
0:             throw new FSReadError(e, channel.toString());
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:b1abcd0
/////////////////////////////////////////////////////////////////////////
0:         @SuppressWarnings("resource")
commit:aedce5f
/////////////////////////////////////////////////////////////////////////
0:                 ? ByteBuffer.allocateDirect(size)
0:                 : ByteBuffer.allocate(size);
commit:36bd31d
commit:a1e2978
/////////////////////////////////////////////////////////////////////////
0:     // this can be overridden at construction to a value shorter than the true length of the file;
0:     // if so, it acts as an imposed limit on reads, rather than a convenience property
commit:36729b9
commit:0ced7a3
/////////////////////////////////////////////////////////////////////////
0:         this(file, bufferSize, -1, owner);
0:     }
0:     protected RandomAccessReader(File file, int bufferSize, long overrideLength, PoolingSegmentedFile owner) throws FileNotFoundException
0:     {
/////////////////////////////////////////////////////////////////////////
0:         long fileLength = overrideLength;
0:         if (fileLength <= 0)
0:             try
0:             {
0:                 fileLength = channel.size();
0:             }
0:             catch (IOException e)
0:             {
0:                 throw new FSReadError(e, filePath);
0:             }
0: 
0:         this.fileLength = fileLength;
0:     public static RandomAccessReader open(File file, long overrideSize, PoolingSegmentedFile owner)
0:         return open(file, DEFAULT_BUFFER_SIZE, overrideSize, owner);
0:         return open(file, -1L);
0:     }
0: 
0:     public static RandomAccessReader open(File file, long overrideSize)
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, overrideSize, null);
0:         return open(file, bufferSize, -1L, owner);
0:     }
0: 
0:     private static RandomAccessReader open(File file, int bufferSize, long overrideSize, PoolingSegmentedFile owner)
0:     {
0:             return new RandomAccessReader(file, bufferSize, overrideSize, owner);
/////////////////////////////////////////////////////////////////////////
0:             int read = buffer.length;
0:             if (bufferOffset + read > fileLength)
0:             {
0:                 if (bufferOffset >= fileLength)
1:                     return;
0:                 read = (int) (fileLength - bufferOffset);
0:             }
0:             int offset = 0;
0:             while (read > 0)
0:                 int n = super.read(buffer, offset, read);
0:                     throw new IllegalStateException();
0:                 read -= n;
0:                 offset += n;
0:             validBufferBytes = offset;
author:stefania
-------------------------------------------------------------------------------
commit:17dd4cc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.memory.BufferPool;
0:     public static final int DEFAULT_BUFFER_SIZE = 64 * 1024;
0: 
0:     // the IO channel to the file, we do not own a reference to this due to
0:     // performance reasons (CASSANDRA-9379) so it's up to the owner of the RAR to
0:     // ensure that the channel stays open and that it is closed afterwards
0:     protected final ChannelProxy channel;
/////////////////////////////////////////////////////////////////////////
0:     protected RandomAccessReader(ChannelProxy channel, int bufferSize, long overrideLength, BufferType bufferType)
0:         this.channel = channel;
0:         buffer = allocateBuffer(getBufferSize(bufferSize), bufferType);
0:     protected int getBufferSize(int size)
0:         return (int)Math.min(fileLength, size);
0:     protected ByteBuffer allocateBuffer(int size, BufferType bufferType)
0:         return BufferPool.get(size, bufferType);
0:     }
0: 
0:     // A wrapper of the RandomAccessReader that closes the channel when done.
0:     // For performance reasons RAR does not increase the reference count of
0:     // a channel but assumes the owner will keep it open and close it,
0:     // see CASSANDRA-9379, this thin class is just for those cases where we do
0:     // not have a shared channel.
0:     private static class RandomAccessReaderWithChannel extends RandomAccessReader
0:     {
0:         RandomAccessReaderWithChannel(File file)
0:         {
0:             super(new ChannelProxy(file), DEFAULT_BUFFER_SIZE, -1L, BufferType.OFF_HEAP);
0:         }
0: 
1:         @Override
1:         public void close()
0:         {
0:             try
0:             {
0:                 super.close();
0:             }
0:             finally
0:             {
0:                 channel.close();
0:             }
0:         }
0:         return new RandomAccessReaderWithChannel(file);
/////////////////////////////////////////////////////////////////////////
0:         return open(channel, DEFAULT_BUFFER_SIZE, overrideSize);
0:     public static RandomAccessReader open(ChannelProxy channel, int bufferSize, long overrideSize)
0:         return new RandomAccessReader(channel, bufferSize, overrideSize, BufferType.OFF_HEAP);
/////////////////////////////////////////////////////////////////////////
0: 	    //make idempotent
0:         bufferOffset += buffer.position();
0:         BufferPool.put(buffer);
0:         buffer = null;
/////////////////////////////////////////////////////////////////////////
1:         if (buffer == null)
1:             throw new IllegalStateException("Attempted to seek in a closed RAR");
0: 
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Attempted to read from closed RAR");
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (buffer == null)
0:             throw new IllegalStateException("Attempted to read from closed RAR");
0: 
/////////////////////////////////////////////////////////////////////////
0:         return bufferOffset + (buffer == null ? 0 : buffer.position());
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
0:         //make idempotent
0:         if (buffer == null)
0:             return;
0: 
commit:895ec3e
/////////////////////////////////////////////////////////////////////////
0:         this(file, bufferSize, false, owner);
0:     }
0: 
0:     protected RandomAccessReader(File file, int bufferSize, boolean useDirectBuffer, PoolingSegmentedFile owner) throws FileNotFoundException
0:     {
/////////////////////////////////////////////////////////////////////////
0:         buffer = allocateBuffer(bufferSize, useDirectBuffer);
0:     protected ByteBuffer allocateBuffer(int bufferSize, boolean useDirectBuffer)
0:         int size = (int) Math.min(fileLength, bufferSize);
0:         return useDirectBuffer
0:                 ? ByteBuffer.allocate(size)
0:                 : ByteBuffer.allocateDirect(size);
/////////////////////////////////////////////////////////////////////////
0:         FileUtils.clean(buffer);
0: 
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:bc7941c
/////////////////////////////////////////////////////////////////////////
0:                 throw new IllegalArgumentException(String.format("Unable to seek to position %d in %s (%d bytes) in read-only mode",
author:Jake Luciani
-------------------------------------------------------------------------------
commit:fe8829f
commit:e9d0214
commit:ad6ba3d
/////////////////////////////////////////////////////////////////////////
0:         //This may NPE so we make a ref
0:         //https://issues.apache.org/jira/browse/CASSANDRA-7756
0:         byte[] ref = buffer;
0:         return ref != null ? ref.length : 0;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:c18ce58
/////////////////////////////////////////////////////////////////////////
0: import java.nio.file.StandardOpenOption;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: public class RandomAccessReader extends AbstractDataInput implements FileDataInput
/////////////////////////////////////////////////////////////////////////
0:     protected ByteBuffer buffer;
0:     protected long bufferOffset, markedPointer;
0:     // channel linked with the file, used to retrieve data and force updates.
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new FileNotFoundException(filePath);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         buffer = allocateBuffer(bufferSize);
0:         buffer.limit(0);
0:     }
0: 
0:     protected ByteBuffer allocateBuffer(int bufferSize)
0:     {
0:         return ByteBuffer.allocate((int) Math.min(fileLength, bufferSize));
/////////////////////////////////////////////////////////////////////////
0:         catch (IOException e)
/////////////////////////////////////////////////////////////////////////
0:     // channel extends FileChannel, impl SeekableByteChannel.  Safe to cast.
0:     public FileChannel getChannel()
0:     {
0:         return channel;
0:     }
0: 
0:         bufferOffset += buffer.position();
0:         buffer.clear();
0:         assert bufferOffset < fileLength;
0:             while (buffer.hasRemaining())
0:                 int n = channel.read(buffer);
0:             buffer.flip();
/////////////////////////////////////////////////////////////////////////
1:         return current();
0:     }
0: 
1:     protected long current()
0:     {
0:         return bufferOffset + (buffer == null ? 0 : buffer.position());
/////////////////////////////////////////////////////////////////////////
0:         return buffer.capacity();
/////////////////////////////////////////////////////////////////////////
1:         long bytes = current() - markedPointer;
1:         markedPointer = current();
/////////////////////////////////////////////////////////////////////////
1:         long bytes = current() - ((BufferedRandomAccessFileMark) mark).pointer;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         bufferOffset += buffer.position();
0:             channel.close();
/////////////////////////////////////////////////////////////////////////
0:         if (newPosition >= length()) // it is save to call length() in read-only mode
0:         {
0:             if (newPosition > length())
0:                 throw new IllegalArgumentException(String.format("unable to seek to position %d in %s (%d bytes) in read-only mode",
0:             buffer.limit(0);
0:             bufferOffset = newPosition;
0:             return;
0:         }
1:         if (newPosition >= bufferOffset && newPosition < bufferOffset + buffer.limit())
0:         {
1:             buffer.position((int) (newPosition - bufferOffset));
0:             return;
0:         }
0:         // Set current location to newPosition and clear buffer so reBuffer calculates from newPosition
0:         bufferOffset = newPosition;
0:         buffer.clear();
0:         reBuffer();
0:         assert current() == newPosition;
/////////////////////////////////////////////////////////////////////////
0:         if (!buffer.hasRemaining())
0:         return (int)buffer.get() & 0xff;
/////////////////////////////////////////////////////////////////////////
0:         if (!buffer.hasRemaining())
0:         int toCopy = Math.min(length, buffer.remaining());
0:         buffer.get(buff, offset, toCopy);
0:             ByteBuffer result = ByteBuffer.allocate(length);
0:             while (result.hasRemaining())
0:             {
0:                 if (isEOF())
0:                     throw new EOFException();
0:                 if (!buffer.hasRemaining())
0:                     reBuffer();
0:                 ByteBufferUtil.put(buffer, result);
0:             }
0:             result.flip();
0:             return result;
0:         catch (Exception e)
/////////////////////////////////////////////////////////////////////////
0:         return bufferOffset + buffer.position();
0:     public long getPositionLimit()
0:         return length();
commit:22e18f5
/////////////////////////////////////////////////////////////////////////
1:     public long getPosition()
0:     {
0:         return current;
0:     }
0: 
commit:01a57ee
/////////////////////////////////////////////////////////////////////////
0:     public int getTotalBufferSize()
commit:1e0d951
commit:dfe4937
/////////////////////////////////////////////////////////////////////////
0:     public int getBufferSize()
0:     {
0:         return buffer.length;
0:     }
0: 
commit:01bc564
/////////////////////////////////////////////////////////////////////////
0:     private final boolean skipIOCache;
0: 
0:     // file descriptor
0:     private final int fd;
0: 
0:     // used if skip I/O cache was enabled
0:     private long bytesSinceCacheFlush = 0;
0: 
0:     protected RandomAccessReader(File file, int bufferSize, boolean skipIOCache, PoolingSegmentedFile owner) throws FileNotFoundException
/////////////////////////////////////////////////////////////////////////
0:         this.skipIOCache = skipIOCache;
0:         try
0:         {
0:             fd = CLibrary.getfd(getFD());
0:         }
0:         catch (IOException e)
0:         {
0:             // fd == null, Not Supposed To Happen
0:             throw new RuntimeException(e);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         return open(file, false);
0:     }
0: 
0:     public static RandomAccessReader open(File file, PoolingSegmentedFile owner)
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, false, owner);
0:     }
0: 
0:     public static RandomAccessReader open(File file, boolean skipIOCache)
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, skipIOCache, null);
0:     static RandomAccessReader open(File file, int bufferSize, boolean skipIOCache, PoolingSegmentedFile owner)
0:             return new RandomAccessReader(file, bufferSize, skipIOCache, owner);
/////////////////////////////////////////////////////////////////////////
0:         return open(new File(writer.getPath()), DEFAULT_BUFFER_SIZE, false, null);
/////////////////////////////////////////////////////////////////////////
0:             bytesSinceCacheFlush += read;
0: 
0:         if (skipIOCache && bytesSinceCacheFlush >= CACHE_FLUSH_INTERVAL_IN_BYTES)
0:         {
0:             // with random I/O we can't control what we are skipping so
0:             // it will be more appropriate to just skip a whole file after
0:             // we reach threshold
0:             CLibrary.trySkipCache(this.fd, 0, 0);
0:             bytesSinceCacheFlush = 0;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (skipIOCache && bytesSinceCacheFlush > 0)
0:             CLibrary.trySkipCache(fd, 0, 0);
0: 
/////////////////////////////////////////////////////////////////////////
0:         return getClass().getSimpleName() + "(" + "filePath='" + filePath + "'" + ", skipIOCache=" + skipIOCache + ")";
commit:edcc7f1
/////////////////////////////////////////////////////////////////////////
0:     protected final PoolingSegmentedFile owner;
0: 
0:     protected RandomAccessReader(File file, int bufferSize, boolean skipIOCache, PoolingSegmentedFile owner) throws FileNotFoundException
0:         this.owner = owner;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static RandomAccessReader open(File file, PoolingSegmentedFile owner)
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, false, owner);
0:     }
0: 
0:         return open(file, DEFAULT_BUFFER_SIZE, skipIOCache, null);
0:     static RandomAccessReader open(File file, int bufferSize, boolean skipIOCache, PoolingSegmentedFile owner)
0:             return new RandomAccessReader(file, bufferSize, skipIOCache, owner);
/////////////////////////////////////////////////////////////////////////
0:     static RandomAccessReader open(SequentialWriter writer)
0:         return open(new File(writer.getPath()), DEFAULT_BUFFER_SIZE, false, null);
/////////////////////////////////////////////////////////////////////////
0:         if (owner == null || buffer == null)
0:         {
0:             // The buffer == null check is so that if the pool owner has deallocated us, calling close()
0:             // will re-call deallocate rather than recycling a deallocated object.
0:             // I'd be more comfortable if deallocate didn't have to handle being idempotent like that,
0:             // but RandomAccessFile.close will call AbstractInterruptibleChannel.close which will
0:             // re-call RAF.close -- in this case, [C]RAR.close since we are overriding that.
0:             deallocate();
0:         }
0:         else
0:         {
0:             owner.recycle(this);
0:         }
0:     }
0: 
0:     public void deallocate()
0:     {
0:         buffer = null; // makes sure we don't use this after it's ostensibly closed
commit:6773383
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.annotations.VisibleForTesting;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static RandomAccessReader open(File file)
0:     {
0:         return open(file, false);
0:     }
0: 
0:     @VisibleForTesting
0:     static RandomAccessReader open(File file, int bufferSize, boolean skipIOCache)
/////////////////////////////////////////////////////////////////////////
0:     @VisibleForTesting
0:         return open(new File(writer.getPath()), DEFAULT_BUFFER_SIZE, false);
commit:debb15e
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import org.apache.cassandra.io.FSReadError;
/////////////////////////////////////////////////////////////////////////
0:     // used in tests
0:     public RandomAccessReader(File file, int bufferSize, boolean skipIOCache) throws FileNotFoundException
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             fd = CLibrary.getfd(getFD());
0:         }
0:         catch (IOException e)
0:         {
0:             // fd == null, Not Supposed To Happen
0:             throw new RuntimeException(e);
0:         }
0:         try
0:         {
0:             fileLength = channel.size();
0:         }
0:         catch (IOException e)
0:         {
0:             throw new FSReadError(e, filePath);
0:         }
0:     public static RandomAccessReader open(File file, boolean skipIOCache)
0:     public static RandomAccessReader open(File file)
0:     public static RandomAccessReader open(File file, int bufferSize)
0:     public static RandomAccessReader open(File file, int bufferSize, boolean skipIOCache)
0:         try
0:         {
0:             return new RandomAccessReader(file, bufferSize, skipIOCache);
0:         }
0:         catch (FileNotFoundException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:     public static RandomAccessReader open(SequentialWriter writer)
0:     protected void reBuffer()
0:         try
0:             if (bufferOffset >= channel.size())
0:                 return;
0: 
0:             channel.position(bufferOffset); // setting channel position
0: 
0:             int read = 0;
0: 
0:             while (read < buffer.length)
0:             {
0:                 int n = super.read(buffer, read, buffer.length - read);
0:                 if (n < 0)
0:                     break;
0:                 read += n;
0:             }
0: 
0:             validBufferBytes = read;
0:             bytesSinceCacheFlush += read;
0:         catch (IOException e)
0:         {
0:             throw new FSReadError(e, filePath);
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public void reset()
/////////////////////////////////////////////////////////////////////////
0:     public void reset(FileMark mark)
/////////////////////////////////////////////////////////////////////////
1:     public boolean isEOF()
1:     public long bytesRemaining()
/////////////////////////////////////////////////////////////////////////
0:     public void close()
0:         try
0:         {
0:             super.close();
0:         }
0:         catch (IOException e)
0:         {
0:             throw new FSReadError(e, filePath);
0:         }
/////////////////////////////////////////////////////////////////////////
1:     public void seek(long newPosition)
0:             throw new IllegalArgumentException(String.format("unable to seek to position %d in %s (%d bytes) in read-only mode",
0:                                                              newPosition, getPath(), length()));
/////////////////////////////////////////////////////////////////////////
0:     public int read()
0:             throw new AssertionError("Attempted to read from closed RAR");
/////////////////////////////////////////////////////////////////////////
0:     public int read(byte[] buffer)
/////////////////////////////////////////////////////////////////////////
0:     public int read(byte[] buff, int offset, int length)
0:             throw new AssertionError("Attempted to read from closed RAR");
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer readBytes(int length) throws EOFException
0: 
0:         try
0:         {
0:             readFully(buff); // reading data buffer
0:         }
0:         catch (EOFException e)
0:         {
0:             throw e;
0:         }
0:         catch (IOException e)
0:         {
0:             throw new FSReadError(e, filePath);
0:         }
1:     public long length()
0:     public void write(int value)
0:     public void write(byte[] buffer)
0:     public void write(byte[] buffer, int offset, int length)
commit:d389047
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.io.util;
0: 
0: import java.io.EOFException;
0: import java.io.File;
0: import java.io.IOException;
0: import java.io.RandomAccessFile;
0: import java.nio.ByteBuffer;
0: import java.nio.channels.ClosedChannelException;
0: import java.nio.channels.FileChannel;
0: 
0: import org.apache.cassandra.utils.CLibrary;
0: 
0: public class RandomAccessReader extends RandomAccessFile implements FileDataInput
0: {
0:     public static final long MAX_BYTES_IN_PAGE_CACHE = (long) Math.pow(2, 27); // 128mb
0: 
0:     // default buffer size, 64Kb
0:     public static final int DEFAULT_BUFFER_SIZE = 65536;
0: 
0:     // absolute filesystem path to the file
0:     private final String filePath;
0: 
0:     // buffer which will cache file blocks
0:     protected byte[] buffer;
0: 
0:     // `current` as current position in file
0:     // `bufferOffset` is the offset of the beginning of the buffer
0:     // `markedPointer` folds the offset of the last file mark
0:     protected long bufferOffset, current = 0, markedPointer;
0:     // `validBufferBytes` is the number of bytes in the buffer that are actually valid;
0:     //  this will be LESS than buffer capacity if buffer is not full!
0:     protected int validBufferBytes = 0;
0: 
0:     // channel liked with the file, used to retrieve data and force updates.
0:     private final FileChannel channel;
0: 
0:     private final boolean skipIOCache;
0: 
0:     // file descriptor
0:     private final int fd;
0: 
0:     // used if skip I/O cache was enabled
0:     private long bytesSinceCacheFlush = 0;
0: 
0:     private final long fileLength;
0: 
0:     public RandomAccessReader(File file, int bufferSize, boolean skipIOCache) throws IOException
0:     {
0:         super(file, "r");
0: 
0:         channel = super.getChannel();
0:         filePath = file.getAbsolutePath();
0: 
0:         // allocating required size of the buffer
0:         if (bufferSize <= 0)
0:             throw new IllegalArgumentException("bufferSize must be positive");
0:         buffer = new byte[bufferSize];
0: 
0:         this.skipIOCache = skipIOCache;
0:         fd = CLibrary.getfd(getFD());
0: 
0:         // we can cache file length in read-only mode
0:         fileLength = channel.size();
0:         validBufferBytes = -1; // that will trigger reBuffer() on demand by read/seek operations
0:     }
0: 
0:     public static RandomAccessReader open(File file, boolean skipIOCache) throws IOException
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, skipIOCache);
0:     }
0: 
0:     public static RandomAccessReader open(File file) throws IOException
0:     {
0:         return open(file, DEFAULT_BUFFER_SIZE, false);
0:     }
0: 
0:     public static RandomAccessReader open(File file, int bufferSize) throws IOException
0:     {
0:         return open(file, bufferSize, false);
0:     }
0: 
0:     public static RandomAccessReader open(File file, int bufferSize, boolean skipIOCache) throws IOException
0:     {
0:         return new RandomAccessReader(file, bufferSize, skipIOCache);
0:     }
0: 
0:     // convert open into open
0:     public static RandomAccessReader open(SequentialWriter writer) throws IOException
0:     {
0:         return open(new File(writer.getPath()), DEFAULT_BUFFER_SIZE);
0:     }
0: 
1:     /**
1:      * Read data from file starting from current currentOffset to populate buffer.
0:      * @throws IOException on any I/O error.
1:      */
0:     protected void reBuffer() throws IOException
0:     {
0:         resetBuffer();
0: 
0:         if (bufferOffset >= channel.size())
0:             return;
0: 
0:         channel.position(bufferOffset); // setting channel position
0: 
0:         int read = 0;
0: 
0:         while (read < buffer.length)
0:         {
0:             int n = super.read(buffer, read, buffer.length - read);
0:             if (n < 0)
0:                 break;
0:             read += n;
0:         }
0: 
0:         validBufferBytes = read;
0: 
0:         bytesSinceCacheFlush += read;
0: 
0:         if (skipIOCache && bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE)
0:         {
0:             // with random I/O we can't control what we are skipping so
0:             // it will be more appropriate to just skip a whole file after
0:             // we reach threshold
0:             CLibrary.trySkipCache(this.fd, 0, 0);
0:             bytesSinceCacheFlush = 0;
0:         }
0:     }
0: 
1:     @Override
1:     public long getFilePointer()
0:     {
0:         return current;
0:     }
0: 
1:     public String getPath()
0:     {
0:         return filePath;
0:     }
0: 
0:     public void reset() throws IOException
0:     {
1:         seek(markedPointer);
0:     }
0: 
1:     public long bytesPastMark()
0:     {
0:         long bytes = current - markedPointer;
1:         assert bytes >= 0;
1:         return bytes;
0:     }
0: 
0:     public FileMark mark()
0:     {
0:         markedPointer = current;
1:         return new BufferedRandomAccessFileMark(markedPointer);
0:     }
0: 
0:     public void reset(FileMark mark) throws IOException
0:     {
1:         assert mark instanceof BufferedRandomAccessFileMark;
1:         seek(((BufferedRandomAccessFileMark) mark).pointer);
0:     }
0: 
0:     public long bytesPastMark(FileMark mark)
0:     {
1:         assert mark instanceof BufferedRandomAccessFileMark;
0:         long bytes = current - ((BufferedRandomAccessFileMark) mark).pointer;
1:         assert bytes >= 0;
1:         return bytes;
0:     }
0: 
1:     /**
1:      * @return true if there is no more data to read
0:      * @throws IOException on any I/O error.
1:      */
0:     public boolean isEOF() throws IOException
0:     {
0:         return getFilePointer() == length();
0:     }
0: 
0:     public long bytesRemaining() throws IOException
0:     {
1:         return length() - getFilePointer();
0:     }
0: 
0:     protected int bufferCursor()
0:     {
0:         return (int) (current - bufferOffset);
0:     }
0: 
0:     protected void resetBuffer()
0:     {
0:         bufferOffset = current;
0:         validBufferBytes = 0;
0:     }
0: 
1:     @Override
0:     public void close() throws IOException
0:     {
0:         buffer = null;
0: 
0:         if (skipIOCache && bytesSinceCacheFlush > 0)
0:             CLibrary.trySkipCache(fd, 0, 0);
0: 
0:         super.close();
0:     }
0: 
1:     @Override
1:     public String toString()
0:     {
0:         return getClass().getSimpleName() + "(" + "filePath='" + filePath + "'" + ", skipIOCache=" + skipIOCache + ")";
0:     }
0: 
1:     /**
1:      * Class to hold a mark to the position of the file
1:      */
0:     protected static class BufferedRandomAccessFileMark implements FileMark
0:     {
0:         long pointer;
0: 
0:         public BufferedRandomAccessFileMark(long pointer)
0:         {
1:             this.pointer = pointer;
0:         }
0:     }
0: 
1:     @Override
0:     public void seek(long newPosition) throws IOException
0:     {
1:         if (newPosition < 0)
1:             throw new IllegalArgumentException("new position should not be negative");
0: 
0:         if (newPosition > length()) // it is save to call length() in read-only mode
0:             throw new EOFException(String.format("unable to seek to position %d in %s (%d bytes) in read-only mode",
0:                                                  newPosition, getPath(), length()));
0: 
0:         current = newPosition;
0: 
0:         if (newPosition > (bufferOffset + validBufferBytes) || newPosition < bufferOffset)
0:             reBuffer();
0:     }
0: 
1:     @Override
0:     // -1 will be returned if there is nothing to read; higher-level methods like readInt
0:     // or readFully (from RandomAccessFile) will throw EOFException but this should not
0:     public int read() throws IOException
0:     {
0:         if (buffer == null)
0:             throw new ClosedChannelException();
0: 
0:         if (isEOF())
0:             return -1; // required by RandomAccessFile
0: 
0:         if (current >= bufferOffset + buffer.length || validBufferBytes == -1)
0:             reBuffer();
0: 
0:         assert current >= bufferOffset && current < bufferOffset + validBufferBytes;
0: 
0:         return ((int) buffer[(int) (current++ - bufferOffset)]) & 0xff;
0:     }
0: 
1:     @Override
0:     public int read(byte[] buffer) throws IOException
0:     {
0:         return read(buffer, 0, buffer.length);
0:     }
0: 
1:     @Override
0:     // -1 will be returned if there is nothing to read; higher-level methods like readInt
0:     // or readFully (from RandomAccessFile) will throw EOFException but this should not
0:     public int read(byte[] buff, int offset, int length) throws IOException
0:     {
0:         if (buffer == null)
0:             throw new ClosedChannelException();
0: 
0:         if (length == 0)
0:             return 0;
0: 
0:         if (isEOF())
0:             return -1;
0: 
0:         if (current >= bufferOffset + buffer.length || validBufferBytes == -1)
0:             reBuffer();
0: 
0:         assert current >= bufferOffset && current < bufferOffset + validBufferBytes
0:                 : String.format("File (%s), current offset %d, buffer offset %d, buffer limit %d",
0:                                 getPath(),
0:                                 current,
0:                                 bufferOffset,
0:                                 validBufferBytes);
0: 
0:         int toCopy = Math.min(length, validBufferBytes - bufferCursor());
0: 
0:         System.arraycopy(buffer, bufferCursor(), buff, offset, toCopy);
0:         current += toCopy;
0: 
0:         return toCopy;
0:     }
0: 
0:     public ByteBuffer readBytes(int length) throws IOException
0:     {
0:         assert length >= 0 : "buffer length should not be negative: " + length;
0: 
0:         byte[] buff = new byte[length];
0:         readFully(buff); // reading data buffer
0: 
0:         return ByteBuffer.wrap(buff);
0:     }
0: 
1:     @Override
0:     public long length() throws IOException
0:     {
0:         return fileLength;
0:     }
0: 
1:     @Override
0:     public void write(int value) throws IOException
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
1:     @Override
0:     public void write(byte[] buffer) throws IOException
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
1:     @Override
0:     public void write(byte[] buffer, int offset, int length) throws IOException
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: }
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:27ed655
/////////////////////////////////////////////////////////////////////////
0:     protected RandomAccessReader(File file, int bufferSize, PoolingSegmentedFile owner) throws FileNotFoundException
/////////////////////////////////////////////////////////////////////////
0:         buffer = new byte[bufferSize];
/////////////////////////////////////////////////////////////////////////
0:         return open(file, DEFAULT_BUFFER_SIZE, owner);
0:     public static RandomAccessReader open(File file)
0:         return open(file, DEFAULT_BUFFER_SIZE, null);
0:     static RandomAccessReader open(File file, int bufferSize, PoolingSegmentedFile owner)
0:             return new RandomAccessReader(file, bufferSize, owner);
/////////////////////////////////////////////////////////////////////////
0:         return open(new File(writer.getPath()), DEFAULT_BUFFER_SIZE, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return getClass().getSimpleName() + "(" + "filePath='" + filePath + "')";
author:Peter Schuller
-------------------------------------------------------------------------------
commit:27fb2bf
commit:49e134c
/////////////////////////////////////////////////////////////////////////
0:     public static final long CACHE_FLUSH_INTERVAL_IN_BYTES = (long) Math.pow(2, 27); // 128mb
/////////////////////////////////////////////////////////////////////////
0:         if (skipIOCache && bytesSinceCacheFlush >= CACHE_FLUSH_INTERVAL_IN_BYTES)
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
1:         final long pointer;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:1ecabe6
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
0:     protected final FileChannel channel;
============================================================================