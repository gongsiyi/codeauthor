1:72790dc: /*
1:72790dc:  * Copyright 2005-2010 Roger Kapsi, Sam Berlin
13:72790dc:  *
1:72790dc:  *   Licensed under the Apache License, Version 2.0 (the "License");
1:72790dc:  *   you may not use this file except in compliance with the License.
1:72790dc:  *   You may obtain a copy of the License at
1:72790dc:  *
1:72790dc:  *       http://www.apache.org/licenses/LICENSE-2.0
1:72790dc:  *
1:72790dc:  *   Unless required by applicable law or agreed to in writing, software
1:72790dc:  *   distributed under the License is distributed on an "AS IS" BASIS,
1:72790dc:  *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72790dc:  *   See the License for the specific language governing permissions and
1:72790dc:  *   limitations under the License.
1:72790dc:  */
140:72790dc: 
1:72790dc: package org.apache.cassandra.index.sasi.utils.trie;
1:72790dc: 
1:72790dc: import java.io.Serializable;
1:72790dc: import java.util.*;
1:72790dc: 
9:72790dc: /**
1:72790dc:  * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
1:72790dc:  * to correspond to Cassandra code style, as the only Patricia Trie implementation,
1:72790dc:  * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
1:72790dc:  * on rkapsi/patricia-trie project) only supports String keys)
1:72790dc:  * but unfortunately is not deployed to the maven central as a downloadable artifact.
1:72790dc:  */
1:72790dc: 
1:72790dc: /**
1:72790dc:  * <h3>PATRICIA {@link Trie}</h3>
1:68d2526:  *
1:72790dc:  * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>
1:68d2526:  *
1:68d2526:  * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing
1:68d2526:  * all data at the edges of the {@link Trie} (and having empty internal nodes),
1:68d2526:  * PATRICIA stores data in every node. This allows for very efficient traversal,
1:68d2526:  * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)}
1:68d2526:  * operations. All operations are performed at worst in O(K) time, where K
1:68d2526:  * is the number of bits in the largest item in the tree. In practice,
1:68d2526:  * operations actually take O(A(K)) time, where A(K) is the average number of
1:72790dc:  * bits of all items in the tree.
1:68d2526:  *
1:72790dc:  * <p>Most importantly, PATRICIA requires very few comparisons to keys while
1:68d2526:  * doing any operation. While performing a lookup, each comparison (at most
1:68d2526:  * K of them, described above) will perform a single bit comparison against
1:72790dc:  * the given key, instead of comparing the entire key to another key.
1:68d2526:  *
1:68d2526:  * <p>The {@link Trie} can return operations in lexicographical order using the
1:68d2526:  * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The
1:68d2526:  * {@link Trie} can also scan for items that are 'bitwise' (using an XOR
1:68d2526:  * metric) by the 'select' method. Bitwise closeness is determined by the
1:68d2526:  * {@link KeyAnalyzer} returning true or false for a bit being set or not in
1:72790dc:  * a given key.
1:68d2526:  *
1:68d2526:  * <p>Any methods here that take an {@link Object} argument may throw a
1:68d2526:  * {@link ClassCastException} if the method is expecting an instance of K
1:72790dc:  * and it isn't K.
1:68d2526:  *
1:72790dc:  * @see <a href="http://en.wikipedia.org/wiki/Radix_tree">Radix Tree</a>
1:72790dc:  * @see <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA">PATRICIA</a>
1:72790dc:  * @see <a href="http://www.imperialviolet.org/binary/critbit.pdf">Crit-Bit Tree</a>
1:68d2526:  *
1:72790dc:  * @author Roger Kapsi
1:72790dc:  * @author Sam Berlin
1:72790dc:  */
1:72790dc: public class PatriciaTrie<K, V> extends AbstractPatriciaTrie<K, V> implements Serializable
1:72790dc: {
1:72790dc:     private static final long serialVersionUID = -2246014692353432660L;
1:68d2526: 
1:72790dc:     public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer)
1:72790dc:     {
1:72790dc:         super(keyAnalyzer);
4:72790dc:     }
1:68d2526: 
1:72790dc:     public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer, Map<? extends K, ? extends V> m)
1:72790dc:     {
1:72790dc:         super(keyAnalyzer, m);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Comparator<? super K> comparator()
1:72790dc:     {
1:72790dc:         return keyAnalyzer;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public SortedMap<K, V> prefixMap(K prefix)
1:72790dc:     {
1:72790dc:         return lengthInBits(prefix) == 0 ? this : new PrefixRangeMap(prefix);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public K firstKey()
1:72790dc:     {
1:72790dc:         return firstEntry().getKey();
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public K lastKey()
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> entry = lastEntry();
1:72790dc:         return entry != null ? entry.getKey() : null;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public SortedMap<K, V> headMap(K toKey)
1:72790dc:     {
1:72790dc:         return new RangeEntryMap(null, toKey);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public SortedMap<K, V> subMap(K fromKey, K toKey)
1:72790dc:     {
1:72790dc:         return new RangeEntryMap(fromKey, toKey);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public SortedMap<K, V> tailMap(K fromKey)
1:72790dc:     {
1:72790dc:         return new RangeEntryMap(fromKey, null);
1:68d2526:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns an entry strictly higher than the given key,
1:72790dc:      * or null if no such entry exists.
1:72790dc:      */
1:72790dc:     private TrieEntry<K,V> higherEntry(K key)
1:72790dc:     {
1:72790dc:         // TODO: Cleanup so that we don't actually have to add/remove from the
1:68d2526:         //       tree.  (We do it here because there are other well-defined
1:72790dc:         //       functions to perform the search.)
1:72790dc:         int lengthInBits = lengthInBits(key);
1:68d2526: 
1:72790dc:         if (lengthInBits == 0)
1:72790dc:         {
1:72790dc:             if (!root.isEmpty())
1:72790dc:             {
1:72790dc:                 // If data in root, and more after -- return it.
1:72790dc:                 return size() > 1 ? nextEntry(root) : null;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 // Root is empty & we want something after empty, return first.
1:72790dc:                 return firstEntry();
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:72790dc:         if (compareKeys(key, found.key))
1:72790dc:             return nextEntry(found);
1:68d2526: 
1:72790dc:         int bitIndex = bitIndex(key, found.key);
1:72790dc:         if (Tries.isValidBitIndex(bitIndex))
1:72790dc:         {
1:72790dc:             return replaceCeil(key, bitIndex);
1:72790dc:         }
1:72790dc:         else if (Tries.isNullBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             if (!root.isEmpty())
1:72790dc:             {
1:72790dc:                 return firstEntry();
1:72790dc:             }
1:72790dc:             else if (size() > 1)
1:72790dc:             {
1:72790dc:                 return nextEntry(firstEntry());
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return null;
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else if (Tries.isEqualBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             return nextEntry(found);
1:72790dc:         }
1:68d2526: 
1:72790dc:         // we should have exited above.
1:72790dc:         throw new IllegalStateException("invalid lookup: " + key);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns a key-value mapping associated with the least key greater
1:72790dc:      * than or equal to the given key, or null if there is no such key.
1:72790dc:      */
1:72790dc:     TrieEntry<K,V> ceilingEntry(K key)
1:72790dc:     {
1:72790dc:         // Basically:
1:72790dc:         // Follow the steps of adding an entry, but instead...
1:72790dc:         //
1:72790dc:         // - If we ever encounter a situation where we found an equal
1:72790dc:         //   key, we return it immediately.
1:72790dc:         //
1:72790dc:         // - If we hit an empty root, return the first iterable item.
1:72790dc:         //
1:72790dc:         // - If we have to add a new item, we temporarily add it,
1:72790dc:         //   find the successor to it, then remove the added item.
1:72790dc:         //
1:72790dc:         // These steps ensure that the returned value is either the
1:72790dc:         // entry for the key itself, or the first entry directly after
1:72790dc:         // the key.
1:68d2526: 
1:72790dc:         // TODO: Cleanup so that we don't actually have to add/remove from the
1:68d2526:         //       tree.  (We do it here because there are other well-defined
1:72790dc:         //       functions to perform the search.)
1:72790dc:         int lengthInBits = lengthInBits(key);
1:68d2526: 
1:72790dc:         if (lengthInBits == 0)
1:72790dc:         {
1:72790dc:             if (!root.isEmpty())
1:72790dc:             {
1:72790dc:                 return root;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return firstEntry();
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:72790dc:         if (compareKeys(key, found.key))
1:72790dc:             return found;
1:68d2526: 
1:72790dc:         int bitIndex = bitIndex(key, found.key);
1:72790dc:         if (Tries.isValidBitIndex(bitIndex))
1:72790dc:         {
1:72790dc:             return replaceCeil(key, bitIndex);
1:72790dc:         }
1:72790dc:         else if (Tries.isNullBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             if (!root.isEmpty())
1:72790dc:             {
1:72790dc:                 return root;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return firstEntry();
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else if (Tries.isEqualBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             return found;
1:72790dc:         }
1:68d2526: 
1:72790dc:         // we should have exited above.
1:72790dc:         throw new IllegalStateException("invalid lookup: " + key);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private TrieEntry<K, V> replaceCeil(K key, int bitIndex)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);
1:72790dc:         addEntry(added);
1:72790dc:         incrementSize(); // must increment because remove will decrement
1:72790dc:         TrieEntry<K, V> ceil = nextEntry(added);
1:72790dc:         removeEntry(added);
1:72790dc:         modCount -= 2; // we didn't really modify it.
1:72790dc:         return ceil;
1:72790dc:     }
1:72790dc: 
1:72790dc:     private TrieEntry<K, V> replaceLower(K key, int bitIndex)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);
1:72790dc:         addEntry(added);
1:72790dc:         incrementSize(); // must increment because remove will decrement
1:72790dc:         TrieEntry<K, V> prior = previousEntry(added);
1:72790dc:         removeEntry(added);
1:72790dc:         modCount -= 2; // we didn't really modify it.
1:72790dc:         return prior;
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns a key-value mapping associated with the greatest key
1:72790dc:      * strictly less than the given key, or null if there is no such key.
1:72790dc:      */
1:72790dc:     TrieEntry<K,V> lowerEntry(K key)
1:72790dc:     {
1:72790dc:         // Basically:
1:72790dc:         // Follow the steps of adding an entry, but instead...
1:72790dc:         //
1:72790dc:         // - If we ever encounter a situation where we found an equal
1:72790dc:         //   key, we return it's previousEntry immediately.
1:72790dc:         //
1:72790dc:         // - If we hit root (empty or not), return null.
1:72790dc:         //
1:72790dc:         // - If we have to add a new item, we temporarily add it,
1:72790dc:         //   find the previousEntry to it, then remove the added item.
1:72790dc:         //
1:72790dc:         // These steps ensure that the returned value is always just before
1:72790dc:         // the key or null (if there was nothing before it).
1:68d2526: 
1:72790dc:         // TODO: Cleanup so that we don't actually have to add/remove from the
1:68d2526:         //       tree.  (We do it here because there are other well-defined
1:72790dc:         //       functions to perform the search.)
1:72790dc:         int lengthInBits = lengthInBits(key);
1:68d2526: 
1:72790dc:         if (lengthInBits == 0)
1:72790dc:             return null; // there can never be anything before root.
1:68d2526: 
1:72790dc:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:72790dc:         if (compareKeys(key, found.key))
1:72790dc:             return previousEntry(found);
1:68d2526: 
1:72790dc:         int bitIndex = bitIndex(key, found.key);
1:72790dc:         if (Tries.isValidBitIndex(bitIndex))
1:72790dc:         {
1:72790dc:             return replaceLower(key, bitIndex);
1:72790dc:         }
1:72790dc:         else if (Tries.isNullBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             return null;
1:72790dc:         }
1:72790dc:         else if (Tries.isEqualBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             return previousEntry(found);
1:72790dc:         }
1:72790dc: 
1:72790dc:         // we should have exited above.
1:72790dc:         throw new IllegalStateException("invalid lookup: " + key);
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * Returns a key-value mapping associated with the greatest key
1:72790dc:      * less than or equal to the given key, or null if there is no such key.
1:72790dc:      */
1:68d2526:     TrieEntry<K,V> floorEntry(K key) {
1:72790dc:         // TODO: Cleanup so that we don't actually have to add/remove from the
1:68d2526:         //       tree.  (We do it here because there are other well-defined
1:72790dc:         //       functions to perform the search.)
1:72790dc:         int lengthInBits = lengthInBits(key);
1:68d2526: 
1:72790dc:         if (lengthInBits == 0)
1:72790dc:         {
1:72790dc:             return !root.isEmpty() ? root : null;
1:72790dc:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:72790dc:         if (compareKeys(key, found.key))
1:72790dc:             return found;
1:68d2526: 
1:72790dc:         int bitIndex = bitIndex(key, found.key);
1:72790dc:         if (Tries.isValidBitIndex(bitIndex))
1:72790dc:         {
1:72790dc:             return replaceLower(key, bitIndex);
1:72790dc:         }
1:72790dc:         else if (Tries.isNullBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             if (!root.isEmpty())
1:72790dc:             {
1:72790dc:                 return root;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return null;
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else if (Tries.isEqualBitKey(bitIndex))
1:72790dc:         {
1:72790dc:             return found;
1:72790dc:         }
1:72790dc: 
1:72790dc:         // we should have exited above.
1:72790dc:         throw new IllegalStateException("invalid lookup: " + key);
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * Finds the subtree that contains the prefix.
1:68d2526:      *
1:72790dc:      * This is very similar to getR but with the difference that
1:72790dc:      * we stop the lookup if h.bitIndex > lengthInBits.
1:72790dc:      */
1:72790dc:     private TrieEntry<K, V> subtree(K prefix)
1:72790dc:     {
1:72790dc:         int lengthInBits = lengthInBits(prefix);
1:68d2526: 
1:72790dc:         TrieEntry<K, V> current = root.left;
1:72790dc:         TrieEntry<K, V> path = root;
1:72790dc:         while(true)
1:72790dc:         {
1:72790dc:             if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex)
1:72790dc:                 break;
1:68d2526: 
1:72790dc:             path = current;
1:72790dc:             current = !isBitSet(prefix, current.bitIndex)
1:72790dc:                     ? current.left : current.right;
1:68d2526:         }
1:72790dc: 
1:72790dc:         // Make sure the entry is valid for a subtree.
1:72790dc:         TrieEntry<K, V> entry = current.isEmpty() ? path : current;
1:68d2526: 
1:72790dc:         // If entry is root, it can't be empty.
1:72790dc:         if (entry.isEmpty())
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // if root && length of root is less than length of lookup,
1:72790dc:         // there's nothing.
1:72790dc:         // (this prevents returning the whole subtree if root has an empty
1:72790dc:         //  string and we want to lookup things with "\0")
1:72790dc:         if (entry == root && lengthInBits(entry.getKey()) < lengthInBits)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // Found key's length-th bit differs from our key
1:72790dc:         // which means it cannot be the prefix...
1:72790dc:         if (isBitSet(prefix, lengthInBits) != isBitSet(entry.key, lengthInBits))
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // ... or there are less than 'length' equal bits
1:72790dc:         int bitIndex = bitIndex(prefix, entry.key);
1:72790dc:         return (bitIndex >= 0 && bitIndex < lengthInBits) ? null : entry;
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the last entry the {@link Trie} is storing.
1:68d2526:      *
1:72790dc:      * <p>This is implemented by going always to the right until
1:72790dc:      * we encounter a valid uplink. That uplink is the last key.
1:72790dc:      */
1:72790dc:     private TrieEntry<K, V> lastEntry()
1:72790dc:     {
1:72790dc:         return followRight(root.left);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Traverses down the right path until it finds an uplink.
1:72790dc:      */
1:72790dc:     private TrieEntry<K, V> followRight(TrieEntry<K, V> node)
1:72790dc:     {
1:72790dc:         // if Trie is empty, no last entry.
1:72790dc:         if (node.right == null)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // Go as far right as possible, until we encounter an uplink.
1:72790dc:         while (node.right.bitIndex > node.bitIndex)
1:72790dc:         {
1:72790dc:             node = node.right;
1:72790dc:         }
1:68d2526: 
1:72790dc:         return node.right;
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the node lexicographically before the given node (or null if none).
1:68d2526:      *
1:72790dc:      * This follows four simple branches:
1:72790dc:      *  - If the uplink that returned us was a right uplink:
1:72790dc:      *      - If predecessor's left is a valid uplink from predecessor, return it.
1:72790dc:      *      - Else, follow the right path from the predecessor's left.
1:72790dc:      *  - If the uplink that returned us was a left uplink:
1:68d2526:      *      - Loop back through parents until we encounter a node where
1:72790dc:      *        node != node.parent.left.
1:72790dc:      *          - If node.parent.left is uplink from node.parent:
1:72790dc:      *              - If node.parent.left is not root, return it.
1:72790dc:      *              - If it is root & root isEmpty, return null.
1:72790dc:      *              - If it is root & root !isEmpty, return root.
1:72790dc:      *          - If node.parent.left is not uplink from node.parent:
1:68d2526:      *              - Follow right path for first right child from node.parent.left
1:68d2526:      *
1:72790dc:      * @param start the start entry
1:72790dc:      */
1:72790dc:     private TrieEntry<K, V> previousEntry(TrieEntry<K, V> start)
1:72790dc:     {
1:72790dc:         if (start.predecessor == null)
1:72790dc:             throw new IllegalArgumentException("must have come from somewhere!");
1:68d2526: 
1:72790dc:         if (start.predecessor.right == start)
1:72790dc:         {
1:72790dc:             return isValidUplink(start.predecessor.left, start.predecessor)
1:72790dc:                     ? start.predecessor.left
1:72790dc:                     : followRight(start.predecessor.left);
1:72790dc:         }
1:72790dc: 
1:72790dc:         TrieEntry<K, V> node = start.predecessor;
1:72790dc:         while (node.parent != null && node == node.parent.left)
1:72790dc:         {
1:72790dc:             node = node.parent;
1:72790dc:         }
1:72790dc: 
1:72790dc:         if (node.parent == null) // can be null if we're looking up root.
1:72790dc:             return null;
1:72790dc: 
1:72790dc:         if (isValidUplink(node.parent.left, node.parent))
1:72790dc:         {
1:72790dc:             if (node.parent.left == root)
1:72790dc:             {
1:72790dc:                 return root.isEmpty() ? null : root;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return node.parent.left;
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else
1:72790dc:         {
1:72790dc:             return followRight(node.parent.left);
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the entry lexicographically after the given entry.
1:72790dc:      * If the given entry is null, returns the first node.
1:68d2526:      *
1:72790dc:      * This will traverse only within the subtree.  If the given node
1:72790dc:      * is not within the subtree, this will have undefined results.
1:72790dc:      */
1:72790dc:     private TrieEntry<K, V> nextEntryInSubtree(TrieEntry<K, V> node, TrieEntry<K, V> parentOfSubtree)
1:72790dc:     {
1:72790dc:         return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, parentOfSubtree);
1:72790dc:     }
1:68d2526: 
1:72790dc:     private boolean isPrefix(K key, K prefix)
1:72790dc:     {
1:72790dc:         return keyAnalyzer.isPrefix(key, prefix);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * A range view of the {@link Trie}
1:72790dc:      */
1:72790dc:     private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V>
1:72790dc:     {
1:72790dc:         /**
1:72790dc:          * The {@link #entrySet()} view
1:72790dc:          */
1:72790dc:         private transient volatile Set<Map.Entry<K, V>> entrySet;
1:72790dc: 
1:72790dc:         /**
1:68d2526:          * Creates and returns an {@link #entrySet()}
1:72790dc:          * view of the {@link RangeMap}
1:72790dc:          */
1:72790dc:         protected abstract Set<Map.Entry<K, V>> createEntrySet();
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * Returns the FROM Key
1:72790dc:          */
1:72790dc:         protected abstract K getFromKey();
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Whether or not the {@link #getFromKey()} is in the range
1:72790dc:          */
1:72790dc:         protected abstract boolean isFromInclusive();
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Returns the TO Key
1:72790dc:          */
1:72790dc:         protected abstract K getToKey();
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Whether or not the {@link #getToKey()} is in the range
1:72790dc:          */
1:72790dc:         protected abstract boolean isToInclusive();
1:68d2526: 
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public Comparator<? super K> comparator()
1:72790dc:         {
1:72790dc:             return PatriciaTrie.this.comparator();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean containsKey(Object key)
1:72790dc:         {
1:72790dc:             return inRange(Tries.<K>cast(key)) && PatriciaTrie.this.containsKey(key);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public V remove(Object key)
1:72790dc:         {
1:72790dc:             return (!inRange(Tries.<K>cast(key))) ? null : PatriciaTrie.this.remove(key);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public V get(Object key)
1:72790dc:         {
1:72790dc:             return (!inRange(Tries.<K>cast(key))) ? null : PatriciaTrie.this.get(key);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public V put(K key, V value)
1:72790dc:         {
1:72790dc:             if (!inRange(key))
1:72790dc:                 throw new IllegalArgumentException("Key is out of range: " + key);
1:72790dc: 
1:72790dc:             return PatriciaTrie.this.put(key, value);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public Set<Map.Entry<K, V>> entrySet()
1:72790dc:         {
1:72790dc:             if (entrySet == null)
1:72790dc:                 entrySet = createEntrySet();
1:72790dc:             return entrySet;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public SortedMap<K, V> subMap(K fromKey, K toKey)
1:72790dc:         {
1:72790dc:             if (!inRange2(fromKey))
1:72790dc:                 throw new IllegalArgumentException("FromKey is out of range: " + fromKey);
1:72790dc: 
1:72790dc:             if (!inRange2(toKey))
1:72790dc:                 throw new IllegalArgumentException("ToKey is out of range: " + toKey);
1:72790dc: 
1:72790dc:             return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public SortedMap<K, V> headMap(K toKey)
1:72790dc:         {
1:72790dc:             if (!inRange2(toKey))
1:72790dc:                 throw new IllegalArgumentException("ToKey is out of range: " + toKey);
1:72790dc: 
1:72790dc:             return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public SortedMap<K, V> tailMap(K fromKey)
1:72790dc:         {
1:72790dc:             if (!inRange2(fromKey))
1:72790dc:                 throw new IllegalArgumentException("FromKey is out of range: " + fromKey);
1:72790dc: 
1:72790dc:             return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * Returns true if the provided key is greater than TO and
1:72790dc:          * less than FROM
1:72790dc:          */
1:72790dc:         protected boolean inRange(K key)
1:72790dc:         {
1:72790dc:             K fromKey = getFromKey();
1:72790dc:             K toKey = getToKey();
1:72790dc: 
1:72790dc:             return (fromKey == null || inFromRange(key, false))
1:72790dc:                     && (toKey == null || inToRange(key, false));
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * This form allows the high endpoint (as well as all legit keys)
1:72790dc:          */
1:72790dc:         protected boolean inRange2(K key)
1:72790dc:         {
1:72790dc:             K fromKey = getFromKey();
1:72790dc:             K toKey = getToKey();
1:72790dc: 
1:72790dc:             return (fromKey == null || inFromRange(key, false))
1:72790dc:                     && (toKey == null || inToRange(key, true));
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:68d2526:          * Returns true if the provided key is in the FROM range
1:72790dc:          * of the {@link RangeMap}
1:72790dc:          */
1:72790dc:         protected boolean inFromRange(K key, boolean forceInclusive)
1:72790dc:         {
1:72790dc:             K fromKey = getFromKey();
1:72790dc:             boolean fromInclusive = isFromInclusive();
1:72790dc: 
1:72790dc:             int ret = keyAnalyzer.compare(key, fromKey);
1:72790dc:             return (fromInclusive || forceInclusive) ? ret >= 0 : ret > 0;
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:68d2526:          * Returns true if the provided key is in the TO range
1:72790dc:          * of the {@link RangeMap}
1:72790dc:          */
1:72790dc:         protected boolean inToRange(K key, boolean forceInclusive)
1:72790dc:         {
1:72790dc:             K toKey = getToKey();
1:72790dc:             boolean toInclusive = isToInclusive();
1:72790dc: 
1:72790dc:             int ret = keyAnalyzer.compare(key, toKey);
1:72790dc:             return (toInclusive || forceInclusive) ? ret <= 0 : ret < 0;
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * Creates and returns a sub-range view of the current {@link RangeMap}
1:72790dc:          */
1:72790dc:         protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);
1:72790dc:     }
1:68d2526: 
1:72790dc:    /**
1:72790dc:     * A {@link RangeMap} that deals with {@link Entry}s
1:72790dc:     */
1:72790dc:    private class RangeEntryMap extends RangeMap
1:72790dc:    {
1:68d2526:        /**
1:68d2526:         * The key to start from, null if the beginning.
1:72790dc:         */
1:72790dc:        protected final K fromKey;
1:68d2526: 
1:68d2526:        /**
1:68d2526:         * The key to end at, null if till the end.
1:72790dc:         */
1:72790dc:        protected final K toKey;
1:68d2526: 
1:68d2526:        /**
1:68d2526:         * Whether or not the 'from' is inclusive.
1:72790dc:         */
1:72790dc:        protected final boolean fromInclusive;
1:68d2526: 
1:68d2526:        /**
1:68d2526:         * Whether or not the 'to' is inclusive.
1:72790dc:         */
1:72790dc:        protected final boolean toInclusive;
1:68d2526: 
1:72790dc:        /**
1:72790dc:         * Creates a {@link RangeEntryMap} with the fromKey included and
1:72790dc:         * the toKey excluded from the range
1:72790dc:         */
1:72790dc:        protected RangeEntryMap(K fromKey, K toKey)
1:72790dc:        {
1:72790dc:            this(fromKey, true, toKey, false);
1:72790dc:        }
1:68d2526: 
1:72790dc:        /**
1:72790dc:         * Creates a {@link RangeEntryMap}
1:72790dc:         */
1:72790dc:        protected RangeEntryMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
1:72790dc:        {
1:72790dc:            if (fromKey == null && toKey == null)
1:72790dc:                throw new IllegalArgumentException("must have a from or to!");
1:68d2526: 
1:72790dc:            if (fromKey != null && toKey != null && keyAnalyzer.compare(fromKey, toKey) > 0)
1:72790dc:                throw new IllegalArgumentException("fromKey > toKey");
1:68d2526: 
1:72790dc:            this.fromKey = fromKey;
1:72790dc:            this.fromInclusive = fromInclusive;
1:72790dc:            this.toKey = toKey;
1:72790dc:            this.toInclusive = toInclusive;
1:72790dc:        }
1:68d2526: 
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        public K firstKey()
1:72790dc:        {
1:72790dc:            Map.Entry<K,V> e  = fromKey == null
1:72790dc:                 ? firstEntry()
1:72790dc:                 : fromInclusive ? ceilingEntry(fromKey) : higherEntry(fromKey);
1:68d2526: 
1:72790dc:            K first = e != null ? e.getKey() : null;
1:72790dc:            if (e == null || toKey != null && !inToRange(first, false))
1:72790dc:                throw new NoSuchElementException();
1:72790dc: 
1:72790dc:            return first;
1:72790dc:        }
1:68d2526: 
1:72790dc: 
1:72790dc:        @Override
1:72790dc:        public K lastKey()
1:72790dc:        {
1:72790dc:            Map.Entry<K,V> e = toKey == null
1:72790dc:                 ? lastEntry()
1:72790dc:                 : toInclusive ? floorEntry(toKey) : lowerEntry(toKey);
1:68d2526: 
1:72790dc:            K last = e != null ? e.getKey() : null;
1:72790dc:            if (e == null || fromKey != null && !inFromRange(last, false))
1:72790dc:                throw new NoSuchElementException();
1:72790dc: 
1:72790dc:            return last;
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        protected Set<Entry<K, V>> createEntrySet()
1:72790dc:        {
1:72790dc:            return new RangeEntrySet(this);
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        public K getFromKey()
1:72790dc:        {
1:72790dc:            return fromKey;
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        public K getToKey()
1:72790dc:        {
1:72790dc:            return toKey;
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        public boolean isFromInclusive()
1:72790dc:        {
1:72790dc:            return fromInclusive;
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        public boolean isToInclusive()
1:72790dc:        {
1:72790dc:            return toInclusive;
1:72790dc:        }
1:68d2526: 
1:72790dc:        @Override
1:72790dc:        protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
1:72790dc:        {
1:72790dc:            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
1:72790dc:        }
1:72790dc:    }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * A {@link Set} view of a {@link RangeMap}
1:72790dc:      */
1:72790dc:     private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>>
1:72790dc:     {
1:68d2526: 
1:72790dc:         private final RangeMap delegate;
1:72790dc: 
1:72790dc:         private int size = -1;
1:72790dc: 
1:72790dc:         private int expectedModCount = -1;
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * Creates a {@link RangeEntrySet}
1:72790dc:          */
1:72790dc:         public RangeEntrySet(RangeMap delegate)
1:72790dc:         {
1:72790dc:             if (delegate == null)
1:72790dc:                 throw new NullPointerException("delegate");
1:72790dc: 
1:72790dc:             this.delegate = delegate;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public Iterator<Map.Entry<K, V>> iterator()
1:72790dc:         {
1:72790dc:             K fromKey = delegate.getFromKey();
1:72790dc:             K toKey = delegate.getToKey();
1:72790dc: 
1:72790dc:             TrieEntry<K, V> first = fromKey == null ? firstEntry() : ceilingEntry(fromKey);
1:72790dc:             TrieEntry<K, V> last = null;
1:72790dc:             if (toKey != null)
1:72790dc:                 last = ceilingEntry(toKey);
1:72790dc: 
1:72790dc:             return new EntryIterator(first, last);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public int size()
1:72790dc:         {
1:72790dc:             if (size == -1 || expectedModCount != PatriciaTrie.this.modCount)
1:72790dc:             {
1:72790dc:                 size = 0;
1:72790dc: 
1:72790dc:                 for (Iterator<?> it = iterator(); it.hasNext(); it.next())
1:72790dc:                 {
1:72790dc:                     ++size;
1:72790dc:                 }
1:72790dc: 
1:72790dc:                 expectedModCount = PatriciaTrie.this.modCount;
1:72790dc:             }
1:72790dc: 
1:72790dc:             return size;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean isEmpty()
1:72790dc:         {
1:72790dc:             return !iterator().hasNext();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean contains(Object o)
1:72790dc:         {
1:72790dc:             if (!(o instanceof Map.Entry<?, ?>))
1:72790dc:                 return false;
1:68d2526: 
1:72790dc:             @SuppressWarnings("unchecked")
1:72790dc:             Map.Entry<K, V> entry = (Map.Entry<K, V>) o;
1:72790dc:             K key = entry.getKey();
1:72790dc:             if (!delegate.inRange(key))
1:72790dc:                 return false;
1:72790dc: 
1:72790dc:             TrieEntry<K, V> node = getEntry(key);
1:72790dc:             return node != null && Tries.areEqual(node.getValue(), entry.getValue());
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean remove(Object o)
1:72790dc:         {
1:72790dc:             if (!(o instanceof Map.Entry<?, ?>))
1:72790dc:                 return false;
1:72790dc: 
1:72790dc:             @SuppressWarnings("unchecked")
1:72790dc:             Map.Entry<K, V> entry = (Map.Entry<K, V>) o;
1:72790dc:             K key = entry.getKey();
1:72790dc:             if (!delegate.inRange(key))
1:72790dc:                 return false;
1:72790dc: 
1:72790dc:             TrieEntry<K, V> node = getEntry(key);
1:72790dc:             if (node != null && Tries.areEqual(node.getValue(), entry.getValue()))
1:72790dc:             {
1:72790dc:                 removeEntry(node);
1:72790dc:                 return true;
1:72790dc:             }
1:72790dc: 
1:72790dc:             return false;
1:72790dc:         }
1:72790dc: 
1:68d2526:         /**
1:68d2526:          * An {@link Iterator} for {@link RangeEntrySet}s.
1:72790dc:          */
1:72790dc:         private final class EntryIterator extends TrieIterator<Map.Entry<K,V>>
1:72790dc:         {
1:72790dc:             private final K excludedKey;
1:72790dc: 
1:72790dc:             /**
1:72790dc:              * Creates a {@link EntryIterator}
1:72790dc:              */
1:72790dc:             private EntryIterator(TrieEntry<K,V> first, TrieEntry<K,V> last)
1:72790dc:             {
1:72790dc:                 super(first);
1:72790dc:                 this.excludedKey = (last != null ? last.getKey() : null);
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public boolean hasNext()
1:72790dc:             {
1:72790dc:                 return next != null && !Tries.areEqual(next.key, excludedKey);
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public Map.Entry<K,V> next()
1:72790dc:             {
1:72790dc:                 if (next == null || Tries.areEqual(next.key, excludedKey))
1:72790dc:                     throw new NoSuchElementException();
1:68d2526: 
1:72790dc:                 return nextEntry();
1:68d2526:             }
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:68d2526:     /**
1:68d2526:      * A submap used for prefix views over the {@link Trie}.
1:72790dc:      */
1:72790dc:     private class PrefixRangeMap extends RangeMap
1:72790dc:     {
1:68d2526: 
1:72790dc:         private final K prefix;
1:68d2526: 
1:72790dc:         private K fromKey = null;
1:68d2526: 
1:72790dc:         private K toKey = null;
1:68d2526: 
1:72790dc:         private int expectedModCount = -1;
1:68d2526: 
1:72790dc:         private int size = -1;
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Creates a {@link PrefixRangeMap}
1:72790dc:          */
1:72790dc:         private PrefixRangeMap(K prefix)
1:72790dc:         {
1:72790dc:             this.prefix = prefix;
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * This method does two things. It determinates the FROM
1:72790dc:          * and TO range of the {@link PrefixRangeMap} and the number
1:68d2526:          * of elements in the range. This method must be called every
1:72790dc:          * time the {@link Trie} has changed.
1:72790dc:          */
1:72790dc:         private int fixup()
1:72790dc:         {
1:72790dc:             // The trie has changed since we last
1:72790dc:             // found our toKey / fromKey
1:72790dc:             if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount)
1:72790dc:             {
1:72790dc:                 Iterator<Map.Entry<K, V>> it = entrySet().iterator();
1:72790dc:                 size = 0;
1:68d2526: 
1:72790dc:                 Map.Entry<K, V> entry = null;
1:72790dc:                 if (it.hasNext())
1:72790dc:                 {
1:72790dc:                     entry = it.next();
1:72790dc:                     size = 1;
1:72790dc:                 }
1:68d2526: 
1:72790dc:                 fromKey = entry == null ? null : entry.getKey();
1:72790dc:                 if (fromKey != null)
1:72790dc:                 {
1:72790dc:                     TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);
1:72790dc:                     fromKey = prior == null ? null : prior.getKey();
1:72790dc:                 }
1:68d2526: 
1:72790dc:                 toKey = fromKey;
1:68d2526: 
1:72790dc:                 while (it.hasNext())
1:72790dc:                 {
1:72790dc:                     ++size;
1:72790dc:                     entry = it.next();
1:72790dc:                 }
1:68d2526: 
1:72790dc:                 toKey = entry == null ? null : entry.getKey();
1:68d2526: 
1:72790dc:                 if (toKey != null)
1:72790dc:                 {
1:72790dc:                     entry = nextEntry((TrieEntry<K, V>)entry);
1:72790dc:                     toKey = entry == null ? null : entry.getKey();
1:72790dc:                 }
1:68d2526: 
1:72790dc:                 expectedModCount = PatriciaTrie.this.modCount;
1:72790dc:             }
1:68d2526: 
1:72790dc:             return size;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public K firstKey()
1:72790dc:         {
1:72790dc:             fixup();
1:68d2526: 
1:72790dc:             Map.Entry<K,V> e = fromKey == null ? firstEntry() : higherEntry(fromKey);
1:72790dc:             K first = e != null ? e.getKey() : null;
1:72790dc:             if (e == null || !isPrefix(first, prefix))
1:72790dc:                 throw new NoSuchElementException();
1:68d2526: 
1:72790dc:             return first;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public K lastKey()
1:72790dc:         {
1:72790dc:             fixup();
1:68d2526: 
1:72790dc:             Map.Entry<K,V> e = toKey == null ? lastEntry() : lowerEntry(toKey);
1:72790dc:             K last = e != null ? e.getKey() : null;
1:72790dc:             if (e == null || !isPrefix(last, prefix))
1:72790dc:                 throw new NoSuchElementException();
1:68d2526: 
1:72790dc:             return last;
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Returns true if this {@link PrefixRangeMap}'s key is a prefix
1:72790dc:          * of the provided key.
1:72790dc:          */
1:72790dc:         @Override
1:72790dc:         protected boolean inRange(K key)
1:72790dc:         {
1:72790dc:             return isPrefix(key, prefix);
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Same as {@link #inRange(Object)}
1:72790dc:          */
1:72790dc:         @Override
1:72790dc:         protected boolean inRange2(K key)
1:72790dc:         {
1:72790dc:             return inRange(key);
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Returns true if the provided Key is in the FROM range
1:72790dc:          * of the {@link PrefixRangeMap}
1:72790dc:          */
1:72790dc:         @Override
1:72790dc:         protected boolean inFromRange(K key, boolean forceInclusive)
1:72790dc:         {
1:72790dc:             return isPrefix(key, prefix);
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Returns true if the provided Key is in the TO range
1:72790dc:          * of the {@link PrefixRangeMap}
1:72790dc:          */
1:72790dc:         @Override
1:72790dc:         protected boolean inToRange(K key, boolean forceInclusive)
1:72790dc:         {
1:72790dc:             return isPrefix(key, prefix);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         protected Set<Map.Entry<K, V>> createEntrySet()
1:72790dc:         {
1:72790dc:             return new PrefixRangeEntrySet(this);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public K getFromKey()
1:72790dc:         {
1:72790dc:             return fromKey;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public K getToKey()
1:72790dc:         {
1:72790dc:             return toKey;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean isFromInclusive()
1:72790dc:         {
1:72790dc:             return false;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean isToInclusive()
1:72790dc:         {
1:72790dc:             return false;
1:72790dc:         }
1:72790dc: 
1:72790dc:         @Override
1:72790dc:         protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,
1:72790dc:                                                  K toKey, boolean toInclusive)
1:72790dc:         {
1:72790dc:             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * A prefix {@link RangeEntrySet} view of the {@link Trie}
1:72790dc:      */
1:72790dc:     private final class PrefixRangeEntrySet extends RangeEntrySet
1:72790dc:     {
1:72790dc:         private final PrefixRangeMap delegate;
1:68d2526: 
1:72790dc:         private TrieEntry<K, V> prefixStart;
1:68d2526: 
1:72790dc:         private int expectedModCount = -1;
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Creates a {@link PrefixRangeEntrySet}
1:72790dc:          */
1:72790dc:         public PrefixRangeEntrySet(PrefixRangeMap delegate)
1:72790dc:         {
1:72790dc:             super(delegate);
1:72790dc:             this.delegate = delegate;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public int size()
1:72790dc:         {
1:72790dc:             return delegate.fixup();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public Iterator<Map.Entry<K,V>> iterator()
1:72790dc:         {
1:72790dc:             if (PatriciaTrie.this.modCount != expectedModCount)
1:72790dc:             {
1:72790dc:                 prefixStart = subtree(delegate.prefix);
1:72790dc:                 expectedModCount = PatriciaTrie.this.modCount;
1:72790dc:             }
1:68d2526: 
1:72790dc:             if (prefixStart == null)
1:72790dc:             {
1:72790dc:                 Set<Map.Entry<K,V>> empty = Collections.emptySet();
1:72790dc:                 return empty.iterator();
1:72790dc:             }
1:72790dc:             else if (lengthInBits(delegate.prefix) >= prefixStart.bitIndex)
1:72790dc:             {
1:72790dc:                 return new SingletonIterator(prefixStart);
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 return new EntryIterator(prefixStart, delegate.prefix);
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:68d2526:         /**
1:68d2526:          * An {@link Iterator} that holds a single {@link TrieEntry}.
1:72790dc:          */
1:72790dc:         private final class SingletonIterator implements Iterator<Map.Entry<K, V>>
1:72790dc:         {
1:72790dc:             private final TrieEntry<K, V> entry;
1:68d2526: 
1:72790dc:             private int hit = 0;
1:68d2526: 
1:72790dc:             public SingletonIterator(TrieEntry<K, V> entry)
1:72790dc:             {
1:72790dc:                 this.entry = entry;
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public boolean hasNext()
1:72790dc:             {
1:72790dc:                 return hit == 0;
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public Map.Entry<K, V> next()
1:72790dc:             {
1:72790dc:                 if (hit != 0)
1:72790dc:                     throw new NoSuchElementException();
1:68d2526: 
1:72790dc:                 ++hit;
1:72790dc:                 return entry;
1:72790dc:             }
1:68d2526: 
1:72790dc: 
1:72790dc:             @Override
1:72790dc:             public void remove()
1:72790dc:             {
1:72790dc:                 if (hit != 1)
1:72790dc:                     throw new IllegalStateException();
1:68d2526: 
1:72790dc:                 ++hit;
1:72790dc:                 PatriciaTrie.this.removeEntry(entry);
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:68d2526:         /**
1:68d2526:          * An {@link Iterator} for iterating over a prefix search.
1:72790dc:          */
1:72790dc:         private final class EntryIterator extends TrieIterator<Map.Entry<K, V>>
1:72790dc:         {
1:72790dc:             // values to reset the subtree if we remove it.
1:72790dc:             protected final K prefix;
1:72790dc:             protected boolean lastOne;
1:68d2526: 
1:72790dc:             protected TrieEntry<K, V> subtree; // the subtree to search within
1:68d2526: 
1:72790dc:             /**
1:68d2526:              * Starts iteration at the given entry & search only
1:72790dc:              * within the given subtree.
1:72790dc:              */
1:72790dc:             EntryIterator(TrieEntry<K, V> startScan, K prefix)
1:72790dc:             {
1:72790dc:                 subtree = startScan;
1:72790dc:                 next = PatriciaTrie.this.followLeft(startScan);
1:72790dc:                 this.prefix = prefix;
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public Map.Entry<K,V> next()
1:72790dc:             {
1:72790dc:                 Map.Entry<K, V> entry = nextEntry();
1:72790dc:                 if (lastOne)
1:72790dc:                     next = null;
1:72790dc:                 return entry;
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior)
1:72790dc:             {
1:72790dc:                 return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);
1:72790dc:             }
1:68d2526: 
1:72790dc:             @Override
1:72790dc:             public void remove()
1:72790dc:             {
1:72790dc:                 // If the current entry we're removing is the subtree
1:72790dc:                 // then we need to find a new subtree parent.
1:72790dc:                 boolean needsFixing = false;
1:72790dc:                 int bitIdx = subtree.bitIndex;
1:72790dc:                 if (current == subtree)
1:72790dc:                     needsFixing = true;
1:68d2526: 
1:72790dc:                 super.remove();
1:68d2526: 
1:72790dc:                 // If the subtree changed its bitIndex or we
1:72790dc:                 // removed the old subtree, get a new one.
1:72790dc:                 if (bitIdx != subtree.bitIndex || needsFixing)
1:72790dc:                     subtree = subtree(prefix);
1:72790dc: 
1:72790dc:                 // If the subtree's bitIndex is less than the
1:72790dc:                 // length of our prefix, it's the last item
1:72790dc:                 // in the prefix tree.
1:72790dc:                 if (lengthInBits(prefix) >= subtree.bitIndex)
1:72790dc:                     lastOne = true;
1:72790dc:             }
1:72790dc:         }
1:72790dc:     }
1:72790dc: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing
1:  * all data at the edges of the {@link Trie} (and having empty internal nodes),
1:  * PATRICIA stores data in every node. This allows for very efficient traversal,
1:  * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)}
1:  * operations. All operations are performed at worst in O(K) time, where K
1:  * is the number of bits in the largest item in the tree. In practice,
1:  * operations actually take O(A(K)) time, where A(K) is the average number of
1:  *
1:  * doing any operation. While performing a lookup, each comparison (at most
1:  * K of them, described above) will perform a single bit comparison against
1:  *
1:  * <p>The {@link Trie} can return operations in lexicographical order using the
1:  * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The
1:  * {@link Trie} can also scan for items that are 'bitwise' (using an XOR
1:  * metric) by the 'select' method. Bitwise closeness is determined by the
1:  * {@link KeyAnalyzer} returning true or false for a bit being set or not in
1:  *
1:  * <p>Any methods here that take an {@link Object} argument may throw a
1:  * {@link ClassCastException} if the method is expecting an instance of K
1:  *
1:  *
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //       tree.  (We do it here because there are other well-defined
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         //       tree.  (We do it here because there are other well-defined
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         //       tree.  (We do it here because there are other well-defined
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     TrieEntry<K,V> floorEntry(K key) {
1:         //       tree.  (We do it here because there are other well-defined
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1: 
1: 
1:         }
1: 
1: 
1: 
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:      *
1:      *      - Loop back through parents until we encounter a node where
1:      *              - Follow right path for first right child from node.parent.left
1:      *
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:          * Creates and returns an {@link #entrySet()}
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:          * Returns true if the provided key is in the FROM range
/////////////////////////////////////////////////////////////////////////
1:          * Returns true if the provided key is in the TO range
/////////////////////////////////////////////////////////////////////////
1: 
1:        /**
1:         * The key to start from, null if the beginning.
1: 
1:        /**
1:         * The key to end at, null if till the end.
1: 
1:        /**
1:         * Whether or not the 'from' is inclusive.
1: 
1:        /**
1:         * Whether or not the 'to' is inclusive.
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * An {@link Iterator} for {@link RangeEntrySet}s.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:     }
1: 
1:     /**
1:      * A submap used for prefix views over the {@link Trie}.
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:          * of elements in the range. This method must be called every
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * An {@link Iterator} that holds a single {@link TrieEntry}.
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:         /**
1:          * An {@link Iterator} for iterating over a prefix search.
1: 
1: 
1:              * Starts iteration at the given entry & search only
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:72790dc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright 2005-2010 Roger Kapsi, Sam Berlin
1:  *
1:  *   Licensed under the Apache License, Version 2.0 (the "License");
1:  *   you may not use this file except in compliance with the License.
1:  *   You may obtain a copy of the License at
1:  *
1:  *       http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *   Unless required by applicable law or agreed to in writing, software
1:  *   distributed under the License is distributed on an "AS IS" BASIS,
1:  *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *   See the License for the specific language governing permissions and
1:  *   limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.index.sasi.utils.trie;
1: 
1: import java.io.Serializable;
1: import java.util.*;
1: 
1: /**
1:  * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
1:  * to correspond to Cassandra code style, as the only Patricia Trie implementation,
1:  * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
1:  * on rkapsi/patricia-trie project) only supports String keys)
1:  * but unfortunately is not deployed to the maven central as a downloadable artifact.
1:  */
1: 
1: /**
1:  * <h3>PATRICIA {@link Trie}</h3>
1:  *  
1:  * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>
1:  * 
0:  * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing 
0:  * all data at the edges of the {@link Trie} (and having empty internal nodes), 
0:  * PATRICIA stores data in every node. This allows for very efficient traversal, 
0:  * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)} 
0:  * operations. All operations are performed at worst in O(K) time, where K 
0:  * is the number of bits in the largest item in the tree. In practice, 
0:  * operations actually take O(A(K)) time, where A(K) is the average number of 
1:  * bits of all items in the tree.
1:  * 
1:  * <p>Most importantly, PATRICIA requires very few comparisons to keys while
0:  * doing any operation. While performing a lookup, each comparison (at most 
0:  * K of them, described above) will perform a single bit comparison against 
1:  * the given key, instead of comparing the entire key to another key.
1:  * 
0:  * <p>The {@link Trie} can return operations in lexicographical order using the 
0:  * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The 
0:  * {@link Trie} can also scan for items that are 'bitwise' (using an XOR 
0:  * metric) by the 'select' method. Bitwise closeness is determined by the 
0:  * {@link KeyAnalyzer} returning true or false for a bit being set or not in 
1:  * a given key.
1:  * 
0:  * <p>Any methods here that take an {@link Object} argument may throw a 
0:  * {@link ClassCastException} if the method is expecting an instance of K 
1:  * and it isn't K.
1:  * 
1:  * @see <a href="http://en.wikipedia.org/wiki/Radix_tree">Radix Tree</a>
1:  * @see <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA">PATRICIA</a>
1:  * @see <a href="http://www.imperialviolet.org/binary/critbit.pdf">Crit-Bit Tree</a>
1:  * 
1:  * @author Roger Kapsi
1:  * @author Sam Berlin
1:  */
1: public class PatriciaTrie<K, V> extends AbstractPatriciaTrie<K, V> implements Serializable
1: {
1:     private static final long serialVersionUID = -2246014692353432660L;
1:     
1:     public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer)
1:     {
1:         super(keyAnalyzer);
1:     }
1:     
1:     public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer, Map<? extends K, ? extends V> m)
1:     {
1:         super(keyAnalyzer, m);
1:     }
1:     
1:     @Override
1:     public Comparator<? super K> comparator()
1:     {
1:         return keyAnalyzer;
1:     }
1:     
1:     @Override
1:     public SortedMap<K, V> prefixMap(K prefix)
1:     {
1:         return lengthInBits(prefix) == 0 ? this : new PrefixRangeMap(prefix);
1:     }
1:     
1:     @Override
1:     public K firstKey()
1:     {
1:         return firstEntry().getKey();
1:     }
1:     
1:     @Override
1:     public K lastKey()
1:     {
1:         TrieEntry<K, V> entry = lastEntry();
1:         return entry != null ? entry.getKey() : null;
1:     }
1:     
1:     @Override
1:     public SortedMap<K, V> headMap(K toKey)
1:     {
1:         return new RangeEntryMap(null, toKey);
1:     }
1:     
1:     @Override
1:     public SortedMap<K, V> subMap(K fromKey, K toKey)
1:     {
1:         return new RangeEntryMap(fromKey, toKey);
1:     }
1:     
1:     @Override
1:     public SortedMap<K, V> tailMap(K fromKey)
1:     {
1:         return new RangeEntryMap(fromKey, null);
1:     } 
1:     
1:     /**
1:      * Returns an entry strictly higher than the given key,
1:      * or null if no such entry exists.
1:      */
1:     private TrieEntry<K,V> higherEntry(K key)
1:     {
1:         // TODO: Cleanup so that we don't actually have to add/remove from the
0:         //       tree.  (We do it here because there are other well-defined 
1:         //       functions to perform the search.)
1:         int lengthInBits = lengthInBits(key);
1:         
1:         if (lengthInBits == 0)
1:         {
1:             if (!root.isEmpty())
1:             {
1:                 // If data in root, and more after -- return it.
1:                 return size() > 1 ? nextEntry(root) : null;
1:             }
1:             else
1:             {
1:                 // Root is empty & we want something after empty, return first.
1:                 return firstEntry();
1:             }
1:         }
1:         
1:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:         if (compareKeys(key, found.key))
1:             return nextEntry(found);
1:         
1:         int bitIndex = bitIndex(key, found.key);
1:         if (Tries.isValidBitIndex(bitIndex))
1:         {
1:             return replaceCeil(key, bitIndex);
1:         }
1:         else if (Tries.isNullBitKey(bitIndex))
1:         {
1:             if (!root.isEmpty())
1:             {
1:                 return firstEntry();
1:             }
1:             else if (size() > 1)
1:             {
1:                 return nextEntry(firstEntry());
1:             }
1:             else
1:             {
1:                 return null;
1:             }
1:         }
1:         else if (Tries.isEqualBitKey(bitIndex))
1:         {
1:             return nextEntry(found);
1:         }
1: 
1:         // we should have exited above.
1:         throw new IllegalStateException("invalid lookup: " + key);
1:     }
1:     
1:     /**
1:      * Returns a key-value mapping associated with the least key greater
1:      * than or equal to the given key, or null if there is no such key.
1:      */
1:     TrieEntry<K,V> ceilingEntry(K key)
1:     {
1:         // Basically:
1:         // Follow the steps of adding an entry, but instead...
1:         //
1:         // - If we ever encounter a situation where we found an equal
1:         //   key, we return it immediately.
1:         //
1:         // - If we hit an empty root, return the first iterable item.
1:         //
1:         // - If we have to add a new item, we temporarily add it,
1:         //   find the successor to it, then remove the added item.
1:         //
1:         // These steps ensure that the returned value is either the
1:         // entry for the key itself, or the first entry directly after
1:         // the key.
1:         
1:         // TODO: Cleanup so that we don't actually have to add/remove from the
0:         //       tree.  (We do it here because there are other well-defined 
1:         //       functions to perform the search.)
1:         int lengthInBits = lengthInBits(key);
1:         
1:         if (lengthInBits == 0)
1:         {
1:             if (!root.isEmpty())
1:             {
1:                 return root;
1:             }
1:             else
1:             {
1:                 return firstEntry();
1:             }
1:         }
1:         
1:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:         if (compareKeys(key, found.key))
1:             return found;
1:         
1:         int bitIndex = bitIndex(key, found.key);
1:         if (Tries.isValidBitIndex(bitIndex))
1:         {
1:             return replaceCeil(key, bitIndex);
1:         }
1:         else if (Tries.isNullBitKey(bitIndex))
1:         {
1:             if (!root.isEmpty())
1:             {
1:                 return root;
1:             }
1:             else
1:             {
1:                 return firstEntry();
1:             }
1:         }
1:         else if (Tries.isEqualBitKey(bitIndex))
1:         {
1:             return found;
1:         }
1: 
1:         // we should have exited above.
1:         throw new IllegalStateException("invalid lookup: " + key);
1:     }
1: 
1:     private TrieEntry<K, V> replaceCeil(K key, int bitIndex)
1:     {
1:         TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);
1:         addEntry(added);
1:         incrementSize(); // must increment because remove will decrement
1:         TrieEntry<K, V> ceil = nextEntry(added);
1:         removeEntry(added);
1:         modCount -= 2; // we didn't really modify it.
1:         return ceil;
1:     }
1: 
1:     private TrieEntry<K, V> replaceLower(K key, int bitIndex)
1:     {
1:         TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);
1:         addEntry(added);
1:         incrementSize(); // must increment because remove will decrement
1:         TrieEntry<K, V> prior = previousEntry(added);
1:         removeEntry(added);
1:         modCount -= 2; // we didn't really modify it.
1:         return prior;
1:     }
1:     
1:     /**
1:      * Returns a key-value mapping associated with the greatest key
1:      * strictly less than the given key, or null if there is no such key.
1:      */
1:     TrieEntry<K,V> lowerEntry(K key)
1:     {
1:         // Basically:
1:         // Follow the steps of adding an entry, but instead...
1:         //
1:         // - If we ever encounter a situation where we found an equal
1:         //   key, we return it's previousEntry immediately.
1:         //
1:         // - If we hit root (empty or not), return null.
1:         //
1:         // - If we have to add a new item, we temporarily add it,
1:         //   find the previousEntry to it, then remove the added item.
1:         //
1:         // These steps ensure that the returned value is always just before
1:         // the key or null (if there was nothing before it).
1:         
1:         // TODO: Cleanup so that we don't actually have to add/remove from the
0:         //       tree.  (We do it here because there are other well-defined 
1:         //       functions to perform the search.)
1:         int lengthInBits = lengthInBits(key);
1:         
1:         if (lengthInBits == 0)
1:             return null; // there can never be anything before root.
1:         
1:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:         if (compareKeys(key, found.key))
1:             return previousEntry(found);
1:         
1:         int bitIndex = bitIndex(key, found.key);
1:         if (Tries.isValidBitIndex(bitIndex))
1:         {
1:             return replaceLower(key, bitIndex);
1:         }
1:         else if (Tries.isNullBitKey(bitIndex))
1:         {
1:             return null;
1:         }
1:         else if (Tries.isEqualBitKey(bitIndex))
1:         {
1:             return previousEntry(found);
1:         }
1: 
1:         // we should have exited above.
1:         throw new IllegalStateException("invalid lookup: " + key);
1:     }
1:     
1:     /**
1:      * Returns a key-value mapping associated with the greatest key
1:      * less than or equal to the given key, or null if there is no such key.
1:      */
0:     TrieEntry<K,V> floorEntry(K key) {        
1:         // TODO: Cleanup so that we don't actually have to add/remove from the
0:         //       tree.  (We do it here because there are other well-defined 
1:         //       functions to perform the search.)
1:         int lengthInBits = lengthInBits(key);
1:         
1:         if (lengthInBits == 0)
1:         {
1:             return !root.isEmpty() ? root : null;
1:         }
1:         
1:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:         if (compareKeys(key, found.key))
1:             return found;
1:         
1:         int bitIndex = bitIndex(key, found.key);
1:         if (Tries.isValidBitIndex(bitIndex))
1:         {
1:             return replaceLower(key, bitIndex);
1:         }
1:         else if (Tries.isNullBitKey(bitIndex))
1:         {
1:             if (!root.isEmpty())
1:             {
1:                 return root;
1:             }
1:             else
1:             {
1:                 return null;
1:             }
1:         }
1:         else if (Tries.isEqualBitKey(bitIndex))
1:         {
1:             return found;
1:         }
1: 
1:         // we should have exited above.
1:         throw new IllegalStateException("invalid lookup: " + key);
1:     }
1:     
1:     /**
1:      * Finds the subtree that contains the prefix.
1:      * 
1:      * This is very similar to getR but with the difference that
1:      * we stop the lookup if h.bitIndex > lengthInBits.
1:      */
1:     private TrieEntry<K, V> subtree(K prefix)
1:     {
1:         int lengthInBits = lengthInBits(prefix);
1:         
1:         TrieEntry<K, V> current = root.left;
1:         TrieEntry<K, V> path = root;
1:         while(true)
1:         {
1:             if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex)
1:                 break;
1:             
1:             path = current;
1:             current = !isBitSet(prefix, current.bitIndex)
1:                     ? current.left : current.right;
1:         }        
1: 
1:         // Make sure the entry is valid for a subtree.
1:         TrieEntry<K, V> entry = current.isEmpty() ? path : current;
1:         
1:         // If entry is root, it can't be empty.
1:         if (entry.isEmpty())
1:             return null;
1:         
1:         // if root && length of root is less than length of lookup,
1:         // there's nothing.
1:         // (this prevents returning the whole subtree if root has an empty
1:         //  string and we want to lookup things with "\0")
1:         if (entry == root && lengthInBits(entry.getKey()) < lengthInBits)
1:             return null;
1:         
1:         // Found key's length-th bit differs from our key
1:         // which means it cannot be the prefix...
1:         if (isBitSet(prefix, lengthInBits) != isBitSet(entry.key, lengthInBits))
1:             return null;
1:         
1:         // ... or there are less than 'length' equal bits
1:         int bitIndex = bitIndex(prefix, entry.key);
1:         return (bitIndex >= 0 && bitIndex < lengthInBits) ? null : entry;
1:     }
1:     
1:     /**
1:      * Returns the last entry the {@link Trie} is storing.
1:      * 
1:      * <p>This is implemented by going always to the right until
1:      * we encounter a valid uplink. That uplink is the last key.
1:      */
1:     private TrieEntry<K, V> lastEntry()
1:     {
1:         return followRight(root.left);
1:     }
1:     
1:     /**
1:      * Traverses down the right path until it finds an uplink.
1:      */
1:     private TrieEntry<K, V> followRight(TrieEntry<K, V> node)
1:     {
1:         // if Trie is empty, no last entry.
1:         if (node.right == null)
1:             return null;
1:         
1:         // Go as far right as possible, until we encounter an uplink.
1:         while (node.right.bitIndex > node.bitIndex)
1:         {
1:             node = node.right;
1:         }
1:         
1:         return node.right;
1:     }
1:     
1:     /**
1:      * Returns the node lexicographically before the given node (or null if none).
1:      * 
1:      * This follows four simple branches:
1:      *  - If the uplink that returned us was a right uplink:
1:      *      - If predecessor's left is a valid uplink from predecessor, return it.
1:      *      - Else, follow the right path from the predecessor's left.
1:      *  - If the uplink that returned us was a left uplink:
0:      *      - Loop back through parents until we encounter a node where 
1:      *        node != node.parent.left.
1:      *          - If node.parent.left is uplink from node.parent:
1:      *              - If node.parent.left is not root, return it.
1:      *              - If it is root & root isEmpty, return null.
1:      *              - If it is root & root !isEmpty, return root.
1:      *          - If node.parent.left is not uplink from node.parent:
0:      *              - Follow right path for first right child from node.parent.left   
1:      * 
1:      * @param start the start entry
1:      */
1:     private TrieEntry<K, V> previousEntry(TrieEntry<K, V> start)
1:     {
1:         if (start.predecessor == null)
1:             throw new IllegalArgumentException("must have come from somewhere!");
1:         
1:         if (start.predecessor.right == start)
1:         {
1:             return isValidUplink(start.predecessor.left, start.predecessor)
1:                     ? start.predecessor.left
1:                     : followRight(start.predecessor.left);
1:         }
1: 
1:         TrieEntry<K, V> node = start.predecessor;
1:         while (node.parent != null && node == node.parent.left)
1:         {
1:             node = node.parent;
1:         }
1: 
1:         if (node.parent == null) // can be null if we're looking up root.
1:             return null;
1: 
1:         if (isValidUplink(node.parent.left, node.parent))
1:         {
1:             if (node.parent.left == root)
1:             {
1:                 return root.isEmpty() ? null : root;
1:             }
1:             else
1:             {
1:                 return node.parent.left;
1:             }
1:         }
1:         else
1:         {
1:             return followRight(node.parent.left);
1:         }
1:     }
1:     
1:     /**
1:      * Returns the entry lexicographically after the given entry.
1:      * If the given entry is null, returns the first node.
1:      * 
1:      * This will traverse only within the subtree.  If the given node
1:      * is not within the subtree, this will have undefined results.
1:      */
1:     private TrieEntry<K, V> nextEntryInSubtree(TrieEntry<K, V> node, TrieEntry<K, V> parentOfSubtree)
1:     {
1:         return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, parentOfSubtree);
1:     }
1:     
1:     private boolean isPrefix(K key, K prefix)
1:     {
1:         return keyAnalyzer.isPrefix(key, prefix);
1:     }
1:     
1:     /**
1:      * A range view of the {@link Trie}
1:      */
1:     private abstract class RangeMap extends AbstractMap<K, V> implements SortedMap<K, V>
1:     {
1:         /**
1:          * The {@link #entrySet()} view
1:          */
1:         private transient volatile Set<Map.Entry<K, V>> entrySet;
1: 
1:         /**
0:          * Creates and returns an {@link #entrySet()} 
1:          * view of the {@link RangeMap}
1:          */
1:         protected abstract Set<Map.Entry<K, V>> createEntrySet();
1: 
1:         /**
1:          * Returns the FROM Key
1:          */
1:         protected abstract K getFromKey();
1:         
1:         /**
1:          * Whether or not the {@link #getFromKey()} is in the range
1:          */
1:         protected abstract boolean isFromInclusive();
1:         
1:         /**
1:          * Returns the TO Key
1:          */
1:         protected abstract K getToKey();
1:         
1:         /**
1:          * Whether or not the {@link #getToKey()} is in the range
1:          */
1:         protected abstract boolean isToInclusive();
1:         
1:         
1:         @Override
1:         public Comparator<? super K> comparator()
1:         {
1:             return PatriciaTrie.this.comparator();
1:         }
1:         
1:         @Override
1:         public boolean containsKey(Object key)
1:         {
1:             return inRange(Tries.<K>cast(key)) && PatriciaTrie.this.containsKey(key);
1:         }
1:         
1:         @Override
1:         public V remove(Object key)
1:         {
1:             return (!inRange(Tries.<K>cast(key))) ? null : PatriciaTrie.this.remove(key);
1:         }
1:         
1:         @Override
1:         public V get(Object key)
1:         {
1:             return (!inRange(Tries.<K>cast(key))) ? null : PatriciaTrie.this.get(key);
1:         }
1:         
1:         @Override
1:         public V put(K key, V value)
1:         {
1:             if (!inRange(key))
1:                 throw new IllegalArgumentException("Key is out of range: " + key);
1: 
1:             return PatriciaTrie.this.put(key, value);
1:         }
1:         
1:         @Override
1:         public Set<Map.Entry<K, V>> entrySet()
1:         {
1:             if (entrySet == null)
1:                 entrySet = createEntrySet();
1:             return entrySet;
1:         }
1:         
1:         @Override
1:         public SortedMap<K, V> subMap(K fromKey, K toKey)
1:         {
1:             if (!inRange2(fromKey))
1:                 throw new IllegalArgumentException("FromKey is out of range: " + fromKey);
1: 
1:             if (!inRange2(toKey))
1:                 throw new IllegalArgumentException("ToKey is out of range: " + toKey);
1: 
1:             return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());
1:         }
1:         
1:         @Override
1:         public SortedMap<K, V> headMap(K toKey)
1:         {
1:             if (!inRange2(toKey))
1:                 throw new IllegalArgumentException("ToKey is out of range: " + toKey);
1: 
1:             return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());
1:         }
1:         
1:         @Override
1:         public SortedMap<K, V> tailMap(K fromKey)
1:         {
1:             if (!inRange2(fromKey))
1:                 throw new IllegalArgumentException("FromKey is out of range: " + fromKey);
1: 
1:             return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());
1:         }
1: 
1:         /**
1:          * Returns true if the provided key is greater than TO and
1:          * less than FROM
1:          */
1:         protected boolean inRange(K key)
1:         {
1:             K fromKey = getFromKey();
1:             K toKey = getToKey();
1: 
1:             return (fromKey == null || inFromRange(key, false))
1:                     && (toKey == null || inToRange(key, false));
1:         }
1: 
1:         /**
1:          * This form allows the high endpoint (as well as all legit keys)
1:          */
1:         protected boolean inRange2(K key)
1:         {
1:             K fromKey = getFromKey();
1:             K toKey = getToKey();
1: 
1:             return (fromKey == null || inFromRange(key, false))
1:                     && (toKey == null || inToRange(key, true));
1:         }
1: 
1:         /**
0:          * Returns true if the provided key is in the FROM range 
1:          * of the {@link RangeMap}
1:          */
1:         protected boolean inFromRange(K key, boolean forceInclusive)
1:         {
1:             K fromKey = getFromKey();
1:             boolean fromInclusive = isFromInclusive();
1: 
1:             int ret = keyAnalyzer.compare(key, fromKey);
1:             return (fromInclusive || forceInclusive) ? ret >= 0 : ret > 0;
1:         }
1: 
1:         /**
0:          * Returns true if the provided key is in the TO range 
1:          * of the {@link RangeMap}
1:          */
1:         protected boolean inToRange(K key, boolean forceInclusive)
1:         {
1:             K toKey = getToKey();
1:             boolean toInclusive = isToInclusive();
1: 
1:             int ret = keyAnalyzer.compare(key, toKey);
1:             return (toInclusive || forceInclusive) ? ret <= 0 : ret < 0;
1:         }
1: 
1:         /**
1:          * Creates and returns a sub-range view of the current {@link RangeMap}
1:          */
1:         protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);
1:     }
1:    
1:    /**
1:     * A {@link RangeMap} that deals with {@link Entry}s
1:     */
1:    private class RangeEntryMap extends RangeMap
1:    {
1:        /** 
0:         * The key to start from, null if the beginning. 
1:         */
1:        protected final K fromKey;
1:        
1:        /** 
0:         * The key to end at, null if till the end. 
1:         */
1:        protected final K toKey;
1:        
1:        /** 
0:         * Whether or not the 'from' is inclusive. 
1:         */
1:        protected final boolean fromInclusive;
1:        
1:        /** 
0:         * Whether or not the 'to' is inclusive. 
1:         */
1:        protected final boolean toInclusive;
1:        
1:        /**
1:         * Creates a {@link RangeEntryMap} with the fromKey included and
1:         * the toKey excluded from the range
1:         */
1:        protected RangeEntryMap(K fromKey, K toKey)
1:        {
1:            this(fromKey, true, toKey, false);
1:        }
1:        
1:        /**
1:         * Creates a {@link RangeEntryMap}
1:         */
1:        protected RangeEntryMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
1:        {
1:            if (fromKey == null && toKey == null)
1:                throw new IllegalArgumentException("must have a from or to!");
1:            
1:            if (fromKey != null && toKey != null && keyAnalyzer.compare(fromKey, toKey) > 0)
1:                throw new IllegalArgumentException("fromKey > toKey");
1:            
1:            this.fromKey = fromKey;
1:            this.fromInclusive = fromInclusive;
1:            this.toKey = toKey;
1:            this.toInclusive = toInclusive;
1:        }
1:        
1:        
1:        @Override
1:        public K firstKey()
1:        {
1:            Map.Entry<K,V> e  = fromKey == null
1:                 ? firstEntry()
1:                 : fromInclusive ? ceilingEntry(fromKey) : higherEntry(fromKey);
1:            
1:            K first = e != null ? e.getKey() : null;
1:            if (e == null || toKey != null && !inToRange(first, false))
1:                throw new NoSuchElementException();
1: 
1:            return first;
1:        }
1: 
1:        
1:        @Override
1:        public K lastKey()
1:        {
1:            Map.Entry<K,V> e = toKey == null
1:                 ? lastEntry()
1:                 : toInclusive ? floorEntry(toKey) : lowerEntry(toKey);
1:            
1:            K last = e != null ? e.getKey() : null;
1:            if (e == null || fromKey != null && !inFromRange(last, false))
1:                throw new NoSuchElementException();
1: 
1:            return last;
1:        }
1:        
1:        @Override
1:        protected Set<Entry<K, V>> createEntrySet()
1:        {
1:            return new RangeEntrySet(this);
1:        }
1:        
1:        @Override
1:        public K getFromKey()
1:        {
1:            return fromKey;
1:        }
1:        
1:        @Override
1:        public K getToKey()
1:        {
1:            return toKey;
1:        }
1:        
1:        @Override
1:        public boolean isFromInclusive()
1:        {
1:            return fromInclusive;
1:        }
1:        
1:        @Override
1:        public boolean isToInclusive()
1:        {
1:            return toInclusive;
1:        }
1:        
1:        @Override
1:        protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
1:        {
1:            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
1:        }
1:    }
1:    
1:     /**
1:      * A {@link Set} view of a {@link RangeMap}
1:      */
1:     private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>>
1:     {
1: 
1:         private final RangeMap delegate;
1: 
1:         private int size = -1;
1: 
1:         private int expectedModCount = -1;
1: 
1:         /**
1:          * Creates a {@link RangeEntrySet}
1:          */
1:         public RangeEntrySet(RangeMap delegate)
1:         {
1:             if (delegate == null)
1:                 throw new NullPointerException("delegate");
1: 
1:             this.delegate = delegate;
1:         }
1:         
1:         @Override
1:         public Iterator<Map.Entry<K, V>> iterator()
1:         {
1:             K fromKey = delegate.getFromKey();
1:             K toKey = delegate.getToKey();
1: 
1:             TrieEntry<K, V> first = fromKey == null ? firstEntry() : ceilingEntry(fromKey);
1:             TrieEntry<K, V> last = null;
1:             if (toKey != null)
1:                 last = ceilingEntry(toKey);
1: 
1:             return new EntryIterator(first, last);
1:         }
1:         
1:         @Override
1:         public int size()
1:         {
1:             if (size == -1 || expectedModCount != PatriciaTrie.this.modCount)
1:             {
1:                 size = 0;
1: 
1:                 for (Iterator<?> it = iterator(); it.hasNext(); it.next())
1:                 {
1:                     ++size;
1:                 }
1: 
1:                 expectedModCount = PatriciaTrie.this.modCount;
1:             }
1: 
1:             return size;
1:         }
1:         
1:         @Override
1:         public boolean isEmpty()
1:         {
1:             return !iterator().hasNext();
1:         }
1:         
1:         @Override
1:         public boolean contains(Object o)
1:         {
1:             if (!(o instanceof Map.Entry<?, ?>))
1:                 return false;
1: 
1:             @SuppressWarnings("unchecked")
1:             Map.Entry<K, V> entry = (Map.Entry<K, V>) o;
1:             K key = entry.getKey();
1:             if (!delegate.inRange(key))
1:                 return false;
1: 
1:             TrieEntry<K, V> node = getEntry(key);
1:             return node != null && Tries.areEqual(node.getValue(), entry.getValue());
1:         }
1:         
1:         @Override
1:         public boolean remove(Object o)
1:         {
1:             if (!(o instanceof Map.Entry<?, ?>))
1:                 return false;
1: 
1:             @SuppressWarnings("unchecked")
1:             Map.Entry<K, V> entry = (Map.Entry<K, V>) o;
1:             K key = entry.getKey();
1:             if (!delegate.inRange(key))
1:                 return false;
1: 
1:             TrieEntry<K, V> node = getEntry(key);
1:             if (node != null && Tries.areEqual(node.getValue(), entry.getValue()))
1:             {
1:                 removeEntry(node);
1:                 return true;
1:             }
1: 
1:             return false;
1:         }
1:         
1:         /** 
0:          * An {@link Iterator} for {@link RangeEntrySet}s. 
1:          */
1:         private final class EntryIterator extends TrieIterator<Map.Entry<K,V>>
1:         {
1:             private final K excludedKey;
1: 
1:             /**
1:              * Creates a {@link EntryIterator}
1:              */
1:             private EntryIterator(TrieEntry<K,V> first, TrieEntry<K,V> last)
1:             {
1:                 super(first);
1:                 this.excludedKey = (last != null ? last.getKey() : null);
1:             }
1:             
1:             @Override
1:             public boolean hasNext()
1:             {
1:                 return next != null && !Tries.areEqual(next.key, excludedKey);
1:             }
1:             
1:             @Override
1:             public Map.Entry<K,V> next()
1:             {
1:                 if (next == null || Tries.areEqual(next.key, excludedKey))
1:                     throw new NoSuchElementException();
1:                 
1:                 return nextEntry();
1:             }
1:         }
1:     }   
1:    
1:     /** 
0:      * A submap used for prefix views over the {@link Trie}. 
1:      */
1:     private class PrefixRangeMap extends RangeMap
1:     {
1:         
1:         private final K prefix;
1:         
1:         private K fromKey = null;
1:         
1:         private K toKey = null;
1:         
1:         private int expectedModCount = -1;
1:         
1:         private int size = -1;
1:         
1:         /**
1:          * Creates a {@link PrefixRangeMap}
1:          */
1:         private PrefixRangeMap(K prefix)
1:         {
1:             this.prefix = prefix;
1:         }
1:         
1:         /**
1:          * This method does two things. It determinates the FROM
1:          * and TO range of the {@link PrefixRangeMap} and the number
0:          * of elements in the range. This method must be called every 
1:          * time the {@link Trie} has changed.
1:          */
1:         private int fixup()
1:         {
1:             // The trie has changed since we last
1:             // found our toKey / fromKey
1:             if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount)
1:             {
1:                 Iterator<Map.Entry<K, V>> it = entrySet().iterator();
1:                 size = 0;
1:                 
1:                 Map.Entry<K, V> entry = null;
1:                 if (it.hasNext())
1:                 {
1:                     entry = it.next();
1:                     size = 1;
1:                 }
1:                 
1:                 fromKey = entry == null ? null : entry.getKey();
1:                 if (fromKey != null)
1:                 {
1:                     TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);
1:                     fromKey = prior == null ? null : prior.getKey();
1:                 }
1:                 
1:                 toKey = fromKey;
1:                 
1:                 while (it.hasNext())
1:                 {
1:                     ++size;
1:                     entry = it.next();
1:                 }
1:                 
1:                 toKey = entry == null ? null : entry.getKey();
1:                 
1:                 if (toKey != null)
1:                 {
1:                     entry = nextEntry((TrieEntry<K, V>)entry);
1:                     toKey = entry == null ? null : entry.getKey();
1:                 }
1:                 
1:                 expectedModCount = PatriciaTrie.this.modCount;
1:             }
1:             
1:             return size;
1:         }
1:         
1:         @Override
1:         public K firstKey()
1:         {
1:             fixup();
1:             
1:             Map.Entry<K,V> e = fromKey == null ? firstEntry() : higherEntry(fromKey);
1:             K first = e != null ? e.getKey() : null;
1:             if (e == null || !isPrefix(first, prefix))
1:                 throw new NoSuchElementException();
1:             
1:             return first;
1:         }
1:         
1:         @Override
1:         public K lastKey()
1:         {
1:             fixup();
1:             
1:             Map.Entry<K,V> e = toKey == null ? lastEntry() : lowerEntry(toKey);
1:             K last = e != null ? e.getKey() : null;
1:             if (e == null || !isPrefix(last, prefix))
1:                 throw new NoSuchElementException();
1:             
1:             return last;
1:         }
1:         
1:         /**
1:          * Returns true if this {@link PrefixRangeMap}'s key is a prefix
1:          * of the provided key.
1:          */
1:         @Override
1:         protected boolean inRange(K key)
1:         {
1:             return isPrefix(key, prefix);
1:         }
1: 
1:         /**
1:          * Same as {@link #inRange(Object)}
1:          */
1:         @Override
1:         protected boolean inRange2(K key)
1:         {
1:             return inRange(key);
1:         }
1:         
1:         /**
1:          * Returns true if the provided Key is in the FROM range
1:          * of the {@link PrefixRangeMap}
1:          */
1:         @Override
1:         protected boolean inFromRange(K key, boolean forceInclusive)
1:         {
1:             return isPrefix(key, prefix);
1:         }
1:         
1:         /**
1:          * Returns true if the provided Key is in the TO range
1:          * of the {@link PrefixRangeMap}
1:          */
1:         @Override
1:         protected boolean inToRange(K key, boolean forceInclusive)
1:         {
1:             return isPrefix(key, prefix);
1:         }
1:         
1:         @Override
1:         protected Set<Map.Entry<K, V>> createEntrySet()
1:         {
1:             return new PrefixRangeEntrySet(this);
1:         }
1:         
1:         @Override
1:         public K getFromKey()
1:         {
1:             return fromKey;
1:         }
1:         
1:         @Override
1:         public K getToKey()
1:         {
1:             return toKey;
1:         }
1:         
1:         @Override
1:         public boolean isFromInclusive()
1:         {
1:             return false;
1:         }
1:         
1:         @Override
1:         public boolean isToInclusive()
1:         {
1:             return false;
1:         }
1:         
1:         @Override
1:         protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,
1:                                                  K toKey, boolean toInclusive)
1:         {
1:             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
1:         }
1:     }
1:     
1:     /**
1:      * A prefix {@link RangeEntrySet} view of the {@link Trie}
1:      */
1:     private final class PrefixRangeEntrySet extends RangeEntrySet
1:     {
1:         private final PrefixRangeMap delegate;
1:         
1:         private TrieEntry<K, V> prefixStart;
1:         
1:         private int expectedModCount = -1;
1:         
1:         /**
1:          * Creates a {@link PrefixRangeEntrySet}
1:          */
1:         public PrefixRangeEntrySet(PrefixRangeMap delegate)
1:         {
1:             super(delegate);
1:             this.delegate = delegate;
1:         }
1:         
1:         @Override
1:         public int size()
1:         {
1:             return delegate.fixup();
1:         }
1:         
1:         @Override
1:         public Iterator<Map.Entry<K,V>> iterator()
1:         {
1:             if (PatriciaTrie.this.modCount != expectedModCount)
1:             {
1:                 prefixStart = subtree(delegate.prefix);
1:                 expectedModCount = PatriciaTrie.this.modCount;
1:             }
1:             
1:             if (prefixStart == null)
1:             {
1:                 Set<Map.Entry<K,V>> empty = Collections.emptySet();
1:                 return empty.iterator();
1:             }
1:             else if (lengthInBits(delegate.prefix) >= prefixStart.bitIndex)
1:             {
1:                 return new SingletonIterator(prefixStart);
1:             }
1:             else
1:             {
1:                 return new EntryIterator(prefixStart, delegate.prefix);
1:             }
1:         }
1:         
1:         /** 
0:          * An {@link Iterator} that holds a single {@link TrieEntry}. 
1:          */
1:         private final class SingletonIterator implements Iterator<Map.Entry<K, V>>
1:         {
1:             private final TrieEntry<K, V> entry;
1:             
1:             private int hit = 0;
1:             
1:             public SingletonIterator(TrieEntry<K, V> entry)
1:             {
1:                 this.entry = entry;
1:             }
1:             
1:             @Override
1:             public boolean hasNext()
1:             {
1:                 return hit == 0;
1:             }
1:             
1:             @Override
1:             public Map.Entry<K, V> next()
1:             {
1:                 if (hit != 0)
1:                     throw new NoSuchElementException();
1:                 
1:                 ++hit;
1:                 return entry;
1:             }
1: 
1:             
1:             @Override
1:             public void remove()
1:             {
1:                 if (hit != 1)
1:                     throw new IllegalStateException();
1:                 
1:                 ++hit;
1:                 PatriciaTrie.this.removeEntry(entry);
1:             }
1:         }
1:         
1:         /** 
0:          * An {@link Iterator} for iterating over a prefix search. 
1:          */
1:         private final class EntryIterator extends TrieIterator<Map.Entry<K, V>>
1:         {
1:             // values to reset the subtree if we remove it.
1:             protected final K prefix;
1:             protected boolean lastOne;
1:             
1:             protected TrieEntry<K, V> subtree; // the subtree to search within
1:             
1:             /**
0:              * Starts iteration at the given entry & search only 
1:              * within the given subtree.
1:              */
1:             EntryIterator(TrieEntry<K, V> startScan, K prefix)
1:             {
1:                 subtree = startScan;
1:                 next = PatriciaTrie.this.followLeft(startScan);
1:                 this.prefix = prefix;
1:             }
1:             
1:             @Override
1:             public Map.Entry<K,V> next()
1:             {
1:                 Map.Entry<K, V> entry = nextEntry();
1:                 if (lastOne)
1:                     next = null;
1:                 return entry;
1:             }
1:             
1:             @Override
1:             protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior)
1:             {
1:                 return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);
1:             }
1:             
1:             @Override
1:             public void remove()
1:             {
1:                 // If the current entry we're removing is the subtree
1:                 // then we need to find a new subtree parent.
1:                 boolean needsFixing = false;
1:                 int bitIdx = subtree.bitIndex;
1:                 if (current == subtree)
1:                     needsFixing = true;
1:                 
1:                 super.remove();
1:                 
1:                 // If the subtree changed its bitIndex or we
1:                 // removed the old subtree, get a new one.
1:                 if (bitIdx != subtree.bitIndex || needsFixing)
1:                     subtree = subtree(prefix);
1: 
1:                 // If the subtree's bitIndex is less than the
1:                 // length of our prefix, it's the last item
1:                 // in the prefix tree.
1:                 if (lengthInBits(prefix) >= subtree.bitIndex)
1:                     lastOne = true;
1:             }
1:         }
1:     }
1: }
============================================================================