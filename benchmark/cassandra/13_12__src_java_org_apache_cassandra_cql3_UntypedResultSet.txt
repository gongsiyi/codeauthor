1:ccb0028: /*
1:ccb0028:  * Licensed to the Apache Software Foundation (ASF) under one
1:ccb0028:  * or more contributor license agreements.  See the NOTICE file
1:ccb0028:  * distributed with this work for additional information
1:ccb0028:  * regarding copyright ownership.  The ASF licenses this file
1:ccb0028:  * to you under the Apache License, Version 2.0 (the
1:ccb0028:  * "License"); you may not use this file except in compliance
1:ccb0028:  * with the License.  You may obtain a copy of the License at
1:ccb0028:  *
1:ccb0028:  *   http://www.apache.org/licenses/LICENSE-2.0
1:ccb0028:  *
1:ccb0028:  * Unless required by applicable law or agreed to in writing,
1:ccb0028:  * software distributed under the License is distributed on an
1:ccb0028:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:ccb0028:  * KIND, either express or implied.  See the License for the
1:ccb0028:  * specific language governing permissions and limitations
1:ccb0028:  * under the License.
1:ccb0028:  */
1:ccb0028: package org.apache.cassandra.cql3;
1:ccb0028: 
1:8ea2d2a: import java.net.InetAddress;
1:ccb0028: import java.nio.ByteBuffer;
1:349d5db: import java.util.*;
1:ccb0028: 
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:489a9e8: import org.apache.cassandra.utils.AbstractIterator;
1:ccb0028: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:1147ee3: import org.apache.cassandra.cql3.statements.SelectStatement;
1:a991b64: import org.apache.cassandra.db.*;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:a991b64: import org.apache.cassandra.db.partitions.PartitionIterator;
1:8ea2d2a: import org.apache.cassandra.db.marshal.*;
1:1147ee3: import org.apache.cassandra.service.pager.QueryPager;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:ccb0028: 
1:ccb0028: /** a utility for doing internal cql-based queries */
1:362cc05: public abstract class UntypedResultSet implements Iterable<UntypedResultSet.Row>
1:ccb0028: {
1:362cc05:     public static UntypedResultSet create(ResultSet rs)
1:ccb0028:     {
1:362cc05:         return new FromResultSet(rs);
1:362cc05:     }
1:362cc05: 
1:362cc05:     public static UntypedResultSet create(List<Map<String, ByteBuffer>> results)
1:1147ee3:     {
1:362cc05:         return new FromResultList(results);
2:ccb0028:     }
1:ccb0028: 
1:1147ee3:     public static UntypedResultSet create(SelectStatement select, QueryPager pager, int pageSize)
1:1147ee3:     {
1:1147ee3:         return new FromPager(select, pager, pageSize);
1:1147ee3:     }
1:1147ee3: 
1:44f4cac:     public boolean isEmpty()
1:362cc05:     {
1:362cc05:         return size() == 0;
1:ccb0028:     }
1:ccb0028: 
1:362cc05:     public abstract int size();
1:362cc05:     public abstract Row one();
1:ccb0028: 
1:0932ed6:     // No implemented by all subclasses, but we use it when we know it's there (for tests)
1:0932ed6:     public abstract List<ColumnSpecification> metadata();
1:0932ed6: 
1:362cc05:     private static class FromResultSet extends UntypedResultSet
1:ccb0028:     {
1:362cc05:         private final ResultSet cqlRows;
1:362cc05: 
1:362cc05:         private FromResultSet(ResultSet cqlRows)
1:ccb0028:         {
1:362cc05:             this.cqlRows = cqlRows;
1:362cc05:         }
1:362cc05: 
1:362cc05:         public int size()
1:362cc05:         {
1:362cc05:             return cqlRows.size();
1:362cc05:         }
1:362cc05: 
1:362cc05:         public Row one()
1:362cc05:         {
1:c7b02d1:             if (cqlRows.size() != 1)
1:c7b02d1:                 throw new IllegalStateException("One row required, " + cqlRows.size() + " found");
1:f587397:             return new Row(cqlRows.metadata.requestNames(), cqlRows.rows.get(0));
1:362cc05:         }
1:362cc05: 
1:362cc05:         public Iterator<Row> iterator()
1:362cc05:         {
1:362cc05:             return new AbstractIterator<Row>()
1:362cc05:             {
1:362cc05:                 Iterator<List<ByteBuffer>> iter = cqlRows.rows.iterator();
1:362cc05: 
1:362cc05:                 protected Row computeNext()
1:362cc05:                 {
1:362cc05:                     if (!iter.hasNext())
1:1147ee3:                         return endOfData();
1:f587397:                     return new Row(cqlRows.metadata.requestNames(), iter.next());
1:362cc05:                 }
1:362cc05:             };
1:362cc05:         }
1:0932ed6: 
1:0932ed6:         public List<ColumnSpecification> metadata()
1:0932ed6:         {
1:01115f7:             return cqlRows.metadata.requestNames();
1:0932ed6:         }
1:362cc05:     }
1:0932ed6: 
1:362cc05:     private static class FromResultList extends UntypedResultSet
1:0932ed6:     {
1:362cc05:         private final List<Map<String, ByteBuffer>> cqlRows;
1:0932ed6: 
1:362cc05:         private FromResultList(List<Map<String, ByteBuffer>> cqlRows)
1:0932ed6:         {
1:362cc05:             this.cqlRows = cqlRows;
1:362cc05:         }
1:362cc05: 
1:362cc05:         public int size()
1:362cc05:         {
1:362cc05:             return cqlRows.size();
1:362cc05:         }
1:362cc05: 
1:362cc05:         public Row one()
1:362cc05:         {
1:362cc05:             if (cqlRows.size() != 1)
1:362cc05:                 throw new IllegalStateException("One row required, " + cqlRows.size() + " found");
1:362cc05:             return new Row(cqlRows.get(0));
1:362cc05:         }
1:362cc05: 
1:362cc05:         public Iterator<Row> iterator()
1:362cc05:         {
1:362cc05:             return new AbstractIterator<Row>()
1:362cc05:             {
1:362cc05:                 Iterator<Map<String, ByteBuffer>> iter = cqlRows.iterator();
1:362cc05: 
1:362cc05:                 protected Row computeNext()
1:362cc05:                 {
1:362cc05:                     if (!iter.hasNext())
2:362cc05:                         return endOfData();
1:362cc05:                     return new Row(iter.next());
1:362cc05:                 }
1:362cc05:             };
1:362cc05:         }
1:ccb0028: 
1:0932ed6:         public List<ColumnSpecification> metadata()
1:362cc05:         {
1:0932ed6:             throw new UnsupportedOperationException();
1:0932ed6:         }
1:ccb0028:     }
1:ccb0028: 
1:1147ee3:     private static class FromPager extends UntypedResultSet
1:1147ee3:     {
1:1147ee3:         private final SelectStatement select;
1:1147ee3:         private final QueryPager pager;
1:1147ee3:         private final int pageSize;
1:1147ee3:         private final List<ColumnSpecification> metadata;
1:1147ee3: 
1:1147ee3:         private FromPager(SelectStatement select, QueryPager pager, int pageSize)
1:1147ee3:         {
1:1147ee3:             this.select = select;
1:1147ee3:             this.pager = pager;
1:1147ee3:             this.pageSize = pageSize;
1:f587397:             this.metadata = select.getResultMetadata().requestNames();
1:1147ee3:         }
1:1147ee3: 
1:1147ee3:         public int size()
1:1147ee3:         {
1:1147ee3:             throw new UnsupportedOperationException();
1:1147ee3:         }
1:1147ee3: 
1:1147ee3:         public Row one()
1:1147ee3:         {
1:1147ee3:             throw new UnsupportedOperationException();
1:1147ee3:         }
1:1147ee3: 
1:1147ee3:         public Iterator<Row> iterator()
1:1147ee3:         {
1:1147ee3:             return new AbstractIterator<Row>()
1:1147ee3:             {
1:1147ee3:                 private Iterator<List<ByteBuffer>> currentPage;
1:1147ee3: 
1:1147ee3:                 protected Row computeNext()
1:1147ee3:                 {
1:a991b64:                     int nowInSec = FBUtilities.nowInSeconds();
1:1762424:                     while (currentPage == null || !currentPage.hasNext())
1:1762424:                     {
1:1762424:                         if (pager.isExhausted())
1:1762424:                             return endOfData();
1:a991b64: 
1:557bbbc:                         try (ReadExecutionController executionController = pager.executionController();
1:557bbbc:                              PartitionIterator iter = pager.fetchPageInternal(pageSize, executionController))
1:a991b64:                         {
1:a991b64:                             currentPage = select.process(iter, nowInSec).rows.iterator();
1:a991b64:                         }
1:1147ee3:                     }
1:1762424:                     return new Row(metadata, currentPage.next());
1:1147ee3:                 }
1:1147ee3:             };
1:1147ee3:         }
1:1147ee3: 
1:0932ed6:         public List<ColumnSpecification> metadata()
1:ccb0028:         {
1:0932ed6:             return metadata;
1:0932ed6:         }
1:1147ee3:     }
1:d881024: 
1:ccb0028:     public static class Row
1:ccb0028:     {
1:349d5db:         private final Map<String, ByteBuffer> data = new HashMap<>();
1:349d5db:         private final List<ColumnSpecification> columns = new ArrayList<>();
1:ccb0028: 
1:d881024:         public Row(Map<String, ByteBuffer> data)
1:ccb0028:         {
1:d881024:             this.data.putAll(data);
1:1147ee3:         }
1:ccb0028: 
1:6d3a3ee:         public Row(List<ColumnSpecification> names, List<ByteBuffer> columns)
1:ccb0028:         {
1:349d5db:             this.columns.addAll(names);
1:6d3a3ee:             for (int i = 0; i < names.size(); i++)
1:5f5905d:                 data.put(names.get(i).name.toString(), columns.get(i));
1:ccb0028:         }
1:ccb0028: 
1:a991b64:         public static Row fromInternalRow(CFMetaData metadata, DecoratedKey key, org.apache.cassandra.db.rows.Row row)
1:a991b64:         {
1:a991b64:             Map<String, ByteBuffer> data = new HashMap<>();
1:a991b64: 
1:a991b64:             ByteBuffer[] keyComponents = SelectStatement.getComponents(metadata, key);
1:a991b64:             for (ColumnDefinition def : metadata.partitionKeyColumns())
1:a991b64:                 data.put(def.name.toString(), keyComponents[def.position()]);
1:a991b64: 
1:a991b64:             Clustering clustering = row.clustering();
1:a991b64:             for (ColumnDefinition def : metadata.clusteringColumns())
1:a991b64:                 data.put(def.name.toString(), clustering.get(def.position()));
1:a991b64: 
1:a991b64:             for (ColumnDefinition def : metadata.partitionColumns())
1:a991b64:             {
1:2457599:                 if (def.isSimple())
1:a991b64:                 {
1:a991b64:                     Cell cell = row.getCell(def);
1:a991b64:                     if (cell != null)
1:a991b64:                         data.put(def.name.toString(), cell.value());
1:a991b64:                 }
1:2457599:                 else
1:2457599:                 {
1:2457599:                     ComplexColumnData complexData = row.getComplexColumnData(def);
1:2457599:                     if (complexData != null)
1:e0adc16:                         data.put(def.name.toString(), ((CollectionType)def.type).serializeForNativeProtocol(complexData.iterator(), ProtocolVersion.V3));
1:2457599:                 }
1:a991b64:             }
1:a991b64: 
1:a991b64:             return new Row(data);
1:a991b64:         }
1:a991b64: 
1:ccb0028:         public boolean has(String column)
1:a991b64:         {
1:ccb0028:             // Note that containsKey won't work because we may have null values
1:ccb0028:             return data.get(column) != null;
1:a991b64:         }
1:44fa12e: 
1:f797bfa:         public ByteBuffer getBlob(String column)
1:f797bfa:         {
1:f797bfa:             return data.get(column);
1:f797bfa:         }
1:f797bfa: 
1:ccb0028:         public String getString(String column)
1:44fa12e:         {
1:ccb0028:             return UTF8Type.instance.compose(data.get(column));
1:44fa12e:         }
1:8ea2d2a: 
1:ccb0028:         public boolean getBoolean(String column)
1:ccb0028:         {
1:ccb0028:             return BooleanType.instance.compose(data.get(column));
1:ccb0028:         }
1:ccb0028: 
1:35a945e:         public byte getByte(String column)
1:35a945e:         {
1:35a945e:             return ByteType.instance.compose(data.get(column));
1:35a945e:         }
1:35a945e: 
1:35a945e:         public short getShort(String column)
1:35a945e:         {
1:35a945e:             return ShortType.instance.compose(data.get(column));
1:35a945e:         }
1:35a945e: 
1:ccb0028:         public int getInt(String column)
1:ccb0028:         {
1:ccb0028:             return Int32Type.instance.compose(data.get(column));
1:ccb0028:         }
1:ccb0028: 
1:ccb0028:         public double getDouble(String column)
1:ccb0028:         {
1:ccb0028:             return DoubleType.instance.compose(data.get(column));
1:ccb0028:         }
1:ccb0028: 
1:ccb0028:         public ByteBuffer getBytes(String column)
1:ccb0028:         {
1:44fa12e:             return data.get(column);
1:ccb0028:         }
1:ccb0028: 
1:8ea2d2a:         public InetAddress getInetAddress(String column)
1:8ea2d2a:         {
1:8ea2d2a:             return InetAddressType.instance.compose(data.get(column));
1:8ea2d2a:         }
1:8ea2d2a: 
1:44f4cac:         public UUID getUUID(String column)
1:ccb0028:         {
1:44f4cac:             return UUIDType.instance.compose(data.get(column));
1:ccb0028:         }
2:44f4cac: 
1:398b1d2:         public Date getTimestamp(String column)
1:ccb0028:         {
1:9ec7b80:             return TimestampType.instance.compose(data.get(column));
1:ccb0028:         }
1:398b1d2: 
1:3a51ccf:         public long getLong(String column)
1:3a51ccf:         {
1:3a51ccf:             return LongType.instance.compose(data.get(column));
1:3a51ccf:         }
1:3a51ccf: 
1:d5ec013:         public <T> Set<T> getSet(String column, AbstractType<T> type)
1:d5ec013:         {
1:38bfc6d:             ByteBuffer raw = data.get(column);
1:ee55f36:             return raw == null ? null : SetType.getInstance(type, true).compose(raw);
1:d5ec013:         }
1:d5ec013: 
1:394b35e:         public <T> List<T> getList(String column, AbstractType<T> type)
1:394b35e:         {
1:394b35e:             ByteBuffer raw = data.get(column);
1:ee55f36:             return raw == null ? null : ListType.getInstance(type, true).compose(raw);
1:394b35e:         }
1:394b35e: 
1:38bfc6d:         public <K, V> Map<K, V> getMap(String column, AbstractType<K> keyType, AbstractType<V> valueType)
1:38bfc6d:         {
1:38bfc6d:             ByteBuffer raw = data.get(column);
1:ee55f36:             return raw == null ? null : MapType.getInstance(keyType, valueType, true).compose(raw);
1:38bfc6d:         }
1:38bfc6d: 
1:dc85238:         public Map<String, String> getTextMap(String column)
1:dc85238:         {
1:dc85238:             return getMap(column, UTF8Type.instance, UTF8Type.instance);
1:dc85238:         }
1:dc85238: 
1:db78236:         public <T> Set<T> getFrozenSet(String column, AbstractType<T> type)
1:db78236:         {
1:db78236:             ByteBuffer raw = data.get(column);
1:db78236:             return raw == null ? null : SetType.getInstance(type, false).compose(raw);
1:db78236:         }
1:db78236: 
1:db78236:         public <T> List<T> getFrozenList(String column, AbstractType<T> type)
1:db78236:         {
1:db78236:             ByteBuffer raw = data.get(column);
1:db78236:             return raw == null ? null : ListType.getInstance(type, false).compose(raw);
1:db78236:         }
1:db78236: 
1:db78236:         public <K, V> Map<K, V> getFrozenMap(String column, AbstractType<K> keyType, AbstractType<V> valueType)
1:db78236:         {
1:db78236:             ByteBuffer raw = data.get(column);
1:db78236:             return raw == null ? null : MapType.getInstance(keyType, valueType, false).compose(raw);
1:db78236:         }
1:db78236: 
1:db78236:         public Map<String, String> getFrozenTextMap(String column)
1:db78236:         {
1:db78236:             return getFrozenMap(column, UTF8Type.instance, UTF8Type.instance);
1:db78236:         }
1:db78236: 
1:394b35e:         public List<ColumnSpecification> getColumns()
1:394b35e:         {
1:394b35e:             return columns;
1:394b35e:         }
1:394b35e: 
1:8ea2d2a:         @Override
1:8ea2d2a:         public String toString()
1:8ea2d2a:         {
1:8ea2d2a:             return data.toString();
1:8ea2d2a:         }
1:ccb0028:     }
1:ccb0028: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         data.put(def.name.toString(), ((CollectionType)def.type).serializeForNativeProtocol(complexData.iterator(), ProtocolVersion.V3));
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
1:                         try (ReadExecutionController executionController = pager.executionController();
1:                              PartitionIterator iter = pager.fetchPageInternal(pageSize, executionController))
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1:             return cqlRows.metadata.requestNames();
commit:f797bfa
/////////////////////////////////////////////////////////////////////////
0:             return cqlRows.metadata.requestNames();
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer getBlob(String column)
1:         {
1:             return data.get(column);
1:         }
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
0:                         data.put(def.name.toString(), ((CollectionType)def.type).serializeForNativeProtocol(complexData.iterator(), Server.VERSION_3));
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1:             if (cqlRows.size() != 1)
1:                 throw new IllegalStateException("One row required, " + cqlRows.size() + " found");
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
1:             return raw == null ? null : SetType.getInstance(type, true).compose(raw);
1:             return raw == null ? null : ListType.getInstance(type, true).compose(raw);
1:             return raw == null ? null : MapType.getInstance(keyType, valueType, true).compose(raw);
author:blerer
-------------------------------------------------------------------------------
commit:737a338
commit:1b93eb4
commit:f497c13
commit:f587397
/////////////////////////////////////////////////////////////////////////
1:             return new Row(cqlRows.metadata.requestNames(), cqlRows.rows.get(0));
/////////////////////////////////////////////////////////////////////////
1:                     return new Row(cqlRows.metadata.requestNames(), iter.next());
/////////////////////////////////////////////////////////////////////////
1:             this.metadata = select.getResultMetadata().requestNames();
author:Robert Stupp
-------------------------------------------------------------------------------
commit:db78236
/////////////////////////////////////////////////////////////////////////
1:         public <T> Set<T> getFrozenSet(String column, AbstractType<T> type)
1:         {
1:             ByteBuffer raw = data.get(column);
1:             return raw == null ? null : SetType.getInstance(type, false).compose(raw);
1:         }
1: 
1:         public <T> List<T> getFrozenList(String column, AbstractType<T> type)
1:         {
1:             ByteBuffer raw = data.get(column);
1:             return raw == null ? null : ListType.getInstance(type, false).compose(raw);
1:         }
1: 
1:         public <K, V> Map<K, V> getFrozenMap(String column, AbstractType<K> keyType, AbstractType<V> valueType)
1:         {
1:             ByteBuffer raw = data.get(column);
1:             return raw == null ? null : MapType.getInstance(keyType, valueType, false).compose(raw);
1:         }
1: 
1:         public Map<String, String> getFrozenTextMap(String column)
1:         {
1:             return getFrozenMap(column, UTF8Type.instance, UTF8Type.instance);
1:         }
1: 
commit:1762424
/////////////////////////////////////////////////////////////////////////
1:                     while (currentPage == null || !currentPage.hasNext())
1:                     {
1:                         if (pager.isExhausted())
1:                             return endOfData();
0:                         currentPage = select.process(pager.fetchPage(pageSize)).rows.iterator();
1:                     return new Row(metadata, currentPage.next());
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AbstractIterator;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:                 if (def.isSimple())
1:                 else
1:                 {
1:                     ComplexColumnData complexData = row.getComplexColumnData(def);
1:                     if (complexData != null)
0:                         data.put(def.name.toString(), ((CollectionType)def.type).serializeForNativeProtocol(def, complexData.iterator(), Server.VERSION_3));
1:                 }
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.db.partitions.PartitionIterator;
0: import org.apache.cassandra.transport.Server;
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
1:                     int nowInSec = FBUtilities.nowInSeconds();
1: 
0:                         try (ReadOrderGroup orderGroup = pager.startOrderGroup(); PartitionIterator iter = pager.fetchPageInternal(pageSize, orderGroup))
1:                         {
1:                             currentPage = select.process(iter, nowInSec).rows.iterator();
1:                         }
/////////////////////////////////////////////////////////////////////////
1:         public static Row fromInternalRow(CFMetaData metadata, DecoratedKey key, org.apache.cassandra.db.rows.Row row)
1:         {
1:             Map<String, ByteBuffer> data = new HashMap<>();
1: 
1:             ByteBuffer[] keyComponents = SelectStatement.getComponents(metadata, key);
1:             for (ColumnDefinition def : metadata.partitionKeyColumns())
1:                 data.put(def.name.toString(), keyComponents[def.position()]);
1: 
1:             Clustering clustering = row.clustering();
1:             for (ColumnDefinition def : metadata.clusteringColumns())
1:                 data.put(def.name.toString(), clustering.get(def.position()));
1: 
1:             for (ColumnDefinition def : metadata.partitionColumns())
1:             {
0:                 if (def.isComplex())
1:                 {
0:                     Iterator<Cell> cells = row.getCells(def);
0:                     if (cells != null)
0:                         data.put(def.name.toString(), ((CollectionType)def.type).serializeForNativeProtocol(def, cells, Server.VERSION_3));
1:                 }
0:                 else
1:                 {
1:                     Cell cell = row.getCell(def);
1:                     if (cell != null)
1:                         data.put(def.name.toString(), cell.value());
1:                 }
1:             }
1: 
1:             return new Row(data);
1:         }
1: 
commit:44fa12e
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer getBlob(String column)
1:         {
1:             return data.get(column);
1:         }
1: 
commit:0932ed6
/////////////////////////////////////////////////////////////////////////
1:     // No implemented by all subclasses, but we use it when we know it's there (for tests)
1:     public abstract List<ColumnSpecification> metadata();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         public List<ColumnSpecification> metadata()
1:         {
0:             return cqlRows.metadata.names;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         public List<ColumnSpecification> metadata()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         public List<ColumnSpecification> metadata()
1:         {
1:             return metadata;
1:         }
commit:1147ee3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.statements.SelectStatement;
0: import org.apache.cassandra.exceptions.*;
1: import org.apache.cassandra.service.pager.QueryPager;
/////////////////////////////////////////////////////////////////////////
1:     public static UntypedResultSet create(SelectStatement select, QueryPager pager, int pageSize)
1:     {
1:         return new FromPager(select, pager, pageSize);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static class FromPager extends UntypedResultSet
1:     {
1:         private final SelectStatement select;
1:         private final QueryPager pager;
1:         private final int pageSize;
1:         private final List<ColumnSpecification> metadata;
1: 
1:         private FromPager(SelectStatement select, QueryPager pager, int pageSize)
1:         {
1:             this.select = select;
1:             this.pager = pager;
1:             this.pageSize = pageSize;
0:             this.metadata = select.getResultMetadata().names;
1:         }
1: 
1:         public int size()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public Row one()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public Iterator<Row> iterator()
1:         {
1:             return new AbstractIterator<Row>()
1:             {
1:                 private Iterator<List<ByteBuffer>> currentPage;
1: 
1:                 protected Row computeNext()
1:                 {
0:                     try {
0:                         while (currentPage == null || !currentPage.hasNext())
1:                         {
0:                             if (pager.isExhausted())
1:                                 return endOfData();
0:                             currentPage = select.process(pager.fetchPage(pageSize)).rows.iterator();
1:                         }
0:                         return new Row(metadata, currentPage.next());
0:                     } catch (RequestValidationException | RequestExecutionException e) {
0:                         throw new RuntimeException(e);
1:                     }
1:                 }
1:             };
1:         }
1:     }
1: 
commit:362cc05
/////////////////////////////////////////////////////////////////////////
1: public abstract class UntypedResultSet implements Iterable<UntypedResultSet.Row>
1:     public static UntypedResultSet create(ResultSet rs)
1:         return new FromResultSet(rs);
1:     }
1: 
1:     public static UntypedResultSet create(List<Map<String, ByteBuffer>> results)
1:     {
1:         return new FromResultList(results);
1:         return size() == 0;
1:     public abstract int size();
1:     public abstract Row one();
1:     private static class FromResultSet extends UntypedResultSet
1:         private final ResultSet cqlRows;
1:         private FromResultSet(ResultSet cqlRows)
1:             this.cqlRows = cqlRows;
1:         }
1:         public int size()
1:         {
1:             return cqlRows.size();
1:         }
1: 
1:         public Row one()
1:         {
0:             if (cqlRows.rows.size() != 1)
0:                 throw new IllegalStateException("One row required, " + cqlRows.rows.size() + " found");
0:             return new Row(cqlRows.metadata.names, cqlRows.rows.get(0));
1:         }
1: 
1:         public Iterator<Row> iterator()
1:         {
1:             return new AbstractIterator<Row>()
1:                 Iterator<List<ByteBuffer>> iter = cqlRows.rows.iterator();
1: 
1:                 protected Row computeNext()
1:                 {
1:                     if (!iter.hasNext())
1:                         return endOfData();
0:                     return new Row(cqlRows.metadata.names, iter.next());
1:                 }
1:             };
1:         }
1:     }
1: 
1:     private static class FromResultList extends UntypedResultSet
1:     {
1:         private final List<Map<String, ByteBuffer>> cqlRows;
1: 
1:         private FromResultList(List<Map<String, ByteBuffer>> cqlRows)
1:         {
1:             this.cqlRows = cqlRows;
1:         }
1: 
1:         public int size()
1:         {
1:             return cqlRows.size();
1:         }
1: 
1:         public Row one()
1:         {
1:             if (cqlRows.size() != 1)
1:                 throw new IllegalStateException("One row required, " + cqlRows.size() + " found");
1:             return new Row(cqlRows.get(0));
1:         }
1: 
1:         public Iterator<Row> iterator()
1:         {
1:             return new AbstractIterator<Row>()
1:             {
1:                 Iterator<Map<String, ByteBuffer>> iter = cqlRows.iterator();
1: 
1:                 protected Row computeNext()
1:                 {
1:                     if (!iter.hasNext())
1:                         return endOfData();
1:                     return new Row(iter.next());
1:                 }
1:             };
1:         }
commit:5f5905d
/////////////////////////////////////////////////////////////////////////
1:                 data.put(names.get(i).name.toString(), columns.get(i));
commit:9ec7b80
/////////////////////////////////////////////////////////////////////////
1:             return TimestampType.instance.compose(data.get(column));
commit:d5ec013
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         public <T> Set<T> getSet(String column, AbstractType<T> type)
1:         {
0:             return SetType.getInstance(type).compose(data.get(column));
1:         }
1: 
commit:6d3a3ee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.ResultSet;
0:     private final ResultSet cqlRows;
0:     public UntypedResultSet(ResultSet cqlRows)
0:         return cqlRows.size() == 0;
/////////////////////////////////////////////////////////////////////////
0:         if (cqlRows.rows.size() != 1)
0:             throw new IllegalStateException("One row required, " + cqlRows.rows.size() + " found");
0:         return new Row(cqlRows.metadata.names, cqlRows.rows.get(0));
0:             Iterator<List<ByteBuffer>> iter = cqlRows.rows.iterator();
0:                 return new Row(cqlRows.metadata.names, iter.next());
/////////////////////////////////////////////////////////////////////////
1:         public Row(List<ColumnSpecification> names, List<ByteBuffer> columns)
1:             for (int i = 0; i < names.size(); i++)
0:                 data.put(names.get(i).toString(), columns.get(i));
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:dc85238
/////////////////////////////////////////////////////////////////////////
1:         public Map<String, String> getTextMap(String column)
1:         {
1:             return getMap(column, UTF8Type.instance, UTF8Type.instance);
1:         }
1: 
commit:349d5db
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1:         private final Map<String, ByteBuffer> data = new HashMap<>();
1:         private final List<ColumnSpecification> columns = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:             this.columns.addAll(names);
commit:3a51ccf
/////////////////////////////////////////////////////////////////////////
1:         public long getLong(String column)
1:         {
1:             return LongType.instance.compose(data.get(column));
1:         }
1: 
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:35a945e
/////////////////////////////////////////////////////////////////////////
1:         public byte getByte(String column)
1:         {
1:             return ByteType.instance.compose(data.get(column));
1:         }
1: 
1:         public short getShort(String column)
1:         {
1:             return ShortType.instance.compose(data.get(column));
1:         }
1: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:7bde245
commit:394b35e
/////////////////////////////////////////////////////////////////////////
0:         final Map<String, ByteBuffer> data = new HashMap<String, ByteBuffer>();
0:         final List<ColumnSpecification> columns;
0:             this.columns = names;
/////////////////////////////////////////////////////////////////////////
1:         public <T> List<T> getList(String column, AbstractType<T> type)
1:         {
1:             ByteBuffer raw = data.get(column);
0:             return raw == null ? null : ListType.getInstance(type).compose(raw);
1:         }
1: 
1:         public List<ColumnSpecification> getColumns()
1:         {
1:             return columns;
1:         }
1: 
commit:38bfc6d
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer raw = data.get(column);
0:             return raw == null ? null : SetType.getInstance(type).compose(raw);
1:         }
1: 
1:         public <K, V> Map<K, V> getMap(String column, AbstractType<K> keyType, AbstractType<V> valueType)
1:         {
1:             ByteBuffer raw = data.get(column);
0:             return raw == null ? null : MapType.getInstance(keyType, valueType).compose(raw);
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
1: 
1:         public InetAddress getInetAddress(String column)
1:         {
1:             return InetAddressType.instance.compose(data.get(column));
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return data.toString();
1:         }
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
1: 
0: import com.google.common.collect.AbstractIterator;
1: 
0: import org.apache.cassandra.db.marshal.BooleanType;
0: import org.apache.cassandra.db.marshal.DoubleType;
0: import org.apache.cassandra.db.marshal.Int32Type;
0: import org.apache.cassandra.db.marshal.UTF8Type;
0: import org.apache.cassandra.thrift.Column;
0: import org.apache.cassandra.thrift.CqlRow;
0: import org.apache.hadoop.io.UTF8;
1: 
1: /** a utility for doing internal cql-based queries */
0: public class UntypedResultSet implements Iterable<UntypedResultSet.Row>
1: {
0:     private final List<CqlRow> cqlRows;
1: 
0:     public UntypedResultSet(List<CqlRow> cqlRows)
1:     {
0:         this.cqlRows = cqlRows;
1:     }
1: 
0:     public Row one()
1:     {
0:         if (cqlRows.size() != 1)
0:             throw new IllegalStateException("One row required, " + cqlRows.size() + " found");
0:         return new Row(cqlRows.get(0));
1:     }
1: 
0:     public Iterator<Row> iterator()
1:     {
0:         return new AbstractIterator<Row>()
1:         {
0:             Iterator<CqlRow> iter = cqlRows.iterator();
1: 
0:             protected Row computeNext()
1:             {
0:                 if (!iter.hasNext())
0:                     return endOfData();
0:                 return new Row(iter.next());
1:             }
0:         };
1:     }
1: 
1:     public static class Row
1:     {
0:         Map<String, ByteBuffer> data = new HashMap<String, ByteBuffer>();
1: 
0:         public Row(CqlRow cqlRow)
1:         {
0:             for (Column column : cqlRow.columns)
0:                 data.put(UTF8Type.instance.compose(column.name), column.value);
1:         }
1: 
1:         public boolean has(String column)
1:         {
1:             // Note that containsKey won't work because we may have null values
1:             return data.get(column) != null;
1:         }
1: 
1:         public String getString(String column)
1:         {
1:             return UTF8Type.instance.compose(data.get(column));
1:         }
1: 
1:         public boolean getBoolean(String column)
1:         {
1:             return BooleanType.instance.compose(data.get(column));
1:         }
1: 
1:         public int getInt(String column)
1:         {
1:             return Int32Type.instance.compose(data.get(column));
1:         }
1: 
1:         public double getDouble(String column)
1:         {
1:             return DoubleType.instance.compose(data.get(column));
1:         }
1: 
1:         public ByteBuffer getBytes(String column)
1:         {
0:             return data.get(column);
1:         }
1:     }
1: }
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:d881024
/////////////////////////////////////////////////////////////////////////
1:         public Row(Map<String, ByteBuffer> data)
0:         {
1:             this.data.putAll(data);
0:         }
1: 
author:Eric Evans
-------------------------------------------------------------------------------
commit:398b1d2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
1:         public Date getTimestamp(String column)
0:         {
0:             return DateType.instance.compose(data.get(column));
0:         }
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:44f4cac
/////////////////////////////////////////////////////////////////////////
0: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isEmpty()
0:     {
0:         return cqlRows.isEmpty();
0:     }
1: 
0:     public int size()
0:     {
0:         return cqlRows.size();
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public UUID getUUID(String column)
0:         {
1:             return UUIDType.instance.compose(data.get(column));
0:         }
0: 
============================================================================