1:ff533ad: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:34e241a: package org.apache.cassandra.locator;
1:a277fbe: 
1:ff533ad: import java.net.InetAddress;
1:ff533ad: import java.net.UnknownHostException;
1:ff533ad: import java.util.ArrayList;
1:a277fbe: import java.util.Arrays;
1:a277fbe: import java.util.Collection;
1:31e3f61: import java.util.Collections;
1:ff533ad: import java.util.HashMap;
1:ff533ad: import java.util.List;
1:ff533ad: import java.util.Map;
1:a277fbe: import java.util.Set;
1:34e241a: 
1:a991b64: import org.junit.Before;
1:9797511: import org.junit.BeforeClass;
1:a991b64: import org.junit.Test;
1:a991b64: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:07893d7: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:a277fbe: import org.apache.cassandra.dht.Range;
1:ff533ad: import org.apache.cassandra.dht.Token;
1:a277fbe: import org.apache.cassandra.service.StorageService;
1:a277fbe: import org.apache.cassandra.utils.Pair;
1:69542a9: 
1:a991b64: import static org.junit.Assert.assertEquals;
1:2f5f0c2: 
1:d2a3827: public class OldNetworkTopologyStrategyTest
3:ff533ad: {
1:ff533ad:     private List<Token> keyTokens;
1:ff533ad:     private TokenMetadata tmd;
1:ff533ad:     private Map<String, ArrayList<InetAddress>> expectedResults;
8:ff533ad: 
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:ff533ad:     @Before
1:ff533ad:     public void init()
1:ff533ad:     {
1:ff533ad:         keyTokens = new ArrayList<Token>();
1:ff533ad:         tmd = new TokenMetadata();
1:ff533ad:         expectedResults = new HashMap<String, ArrayList<InetAddress>>();
3:ff533ad:     }
1:ff533ad: 
1:a277fbe:     /**
1:ff533ad:      * 4 same rack endpoints
3:ff533ad:      *
1:a991b64:      * @throws java.net.UnknownHostException
2:ff533ad:      */
1:ff533ad:     @Test
1:ff533ad:     public void testBigIntegerEndpointsA() throws UnknownHostException
1:ff533ad:     {
1:ff533ad:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1:a277fbe: 
1:31e3f61:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
1:ff533ad:         addEndpoint("0", "5", "254.0.0.1");
1:ff533ad:         addEndpoint("10", "15", "254.0.0.2");
1:ff533ad:         addEndpoint("20", "25", "254.0.0.3");
1:ff533ad:         addEndpoint("30", "35", "254.0.0.4");
1:ff533ad: 
1:ff533ad:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.0.3", "254.0.0.4"));
1:ff533ad:         expectedResults.put("15", buildResult("254.0.0.3", "254.0.0.4", "254.0.0.1"));
1:ff533ad:         expectedResults.put("25", buildResult("254.0.0.4", "254.0.0.1", "254.0.0.2"));
1:ff533ad:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.0.2", "254.0.0.3"));
1:ff533ad: 
1:2f5f0c2:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
1:ff533ad:     }
1:ff533ad: 
1:ff533ad:     /**
1:ff533ad:      * 3 same rack endpoints
1:ff533ad:      * 1 external datacenter
1:ff533ad:      *
1:a991b64:      * @throws java.net.UnknownHostException
1:ff533ad:      */
1:ff533ad:     @Test
1:ff533ad:     public void testBigIntegerEndpointsB() throws UnknownHostException
1:ff533ad:     {
1:ff533ad:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1:ff533ad: 
1:31e3f61:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
1:ff533ad:         addEndpoint("0", "5", "254.0.0.1");
1:ff533ad:         addEndpoint("10", "15", "254.0.0.2");
1:ff533ad:         addEndpoint("20", "25", "254.1.0.3");
1:ff533ad:         addEndpoint("30", "35", "254.0.0.4");
1:ff533ad: 
1:ff533ad:         expectedResults.put("5", buildResult("254.0.0.2", "254.1.0.3", "254.0.0.4"));
1:ff533ad:         expectedResults.put("15", buildResult("254.1.0.3", "254.0.0.4", "254.0.0.1"));
1:ff533ad:         expectedResults.put("25", buildResult("254.0.0.4", "254.1.0.3", "254.0.0.1"));
1:ff533ad:         expectedResults.put("35", buildResult("254.0.0.1", "254.1.0.3", "254.0.0.2"));
1:ff533ad: 
1:2f5f0c2:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
1:ff533ad:     }
1:ff533ad: 
1:ff533ad:     /**
1:ff533ad:      * 2 same rack endpoints
1:ff533ad:      * 1 same datacenter, different rack endpoints
1:ff533ad:      * 1 external datacenter
1:ff533ad:      *
1:a991b64:      * @throws java.net.UnknownHostException
1:ff533ad:      */
1:ff533ad:     @Test
1:ff533ad:     public void testBigIntegerEndpointsC() throws UnknownHostException
1:ff533ad:     {
1:ff533ad:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1:ff533ad: 
1:31e3f61:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
1:ff533ad:         addEndpoint("0", "5", "254.0.0.1");
1:ff533ad:         addEndpoint("10", "15", "254.0.0.2");
1:ff533ad:         addEndpoint("20", "25", "254.0.1.3");
1:ff533ad:         addEndpoint("30", "35", "254.1.0.4");
1:ff533ad: 
1:ff533ad:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.1.3", "254.1.0.4"));
1:ff533ad:         expectedResults.put("15", buildResult("254.0.1.3", "254.1.0.4", "254.0.0.1"));
1:ff533ad:         expectedResults.put("25", buildResult("254.1.0.4", "254.0.0.1", "254.0.0.2"));
1:ff533ad:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.1.3", "254.1.0.4"));
1:ff533ad: 
1:2f5f0c2:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
1:ff533ad:     }
1:ff533ad: 
1:ff533ad:     private ArrayList<InetAddress> buildResult(String... addresses) throws UnknownHostException
1:ff533ad:     {
1:ff533ad:         ArrayList<InetAddress> result = new ArrayList<InetAddress>();
1:ff533ad:         for (String address : addresses)
1:ff533ad:         {
1:ff533ad:             result.add(InetAddress.getByName(address));
1:ff533ad:         }
1:ff533ad:         return result;
1:ff533ad:     }
1:ff533ad: 
1:ff533ad:     private void addEndpoint(String endpointTokenID, String keyTokenID, String endpointAddress) throws UnknownHostException
1:ff533ad:     {
1:ff533ad:         BigIntegerToken endpointToken = new BigIntegerToken(endpointTokenID);
1:ff533ad: 
1:ff533ad:         BigIntegerToken keyToken = new BigIntegerToken(keyTokenID);
1:ff533ad:         keyTokens.add(keyToken);
1:ff533ad: 
1:ff533ad:         InetAddress ep = InetAddress.getByName(endpointAddress);
1:ff533ad:         tmd.updateNormalToken(endpointToken, ep);
1:ff533ad:     }
1:ff533ad: 
1:9639f95:     private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens)
1:ff533ad:     {
1:ff533ad:         for (Token keyToken : keyTokens)
1:ff533ad:         {
1:df8a933:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyToken);
1:ff533ad:             for (int j = 0; j < endpoints.size(); j++)
1:ff533ad:             {
1:ff533ad:                 ArrayList<InetAddress> hostsExpected = expectedResults.get(keyToken.toString());
1:ff533ad:                 assertEquals(endpoints.get(j), hostsExpected.get(j));
1:ff533ad:             }
1:ff533ad:         }
1:ff533ad:     }
1:ff533ad: 
1:ff533ad:     /**
1:a277fbe:      * test basic methods to move a node. For sure, it's not the best place, but it's easy to test
1:a277fbe:      *
1:a991b64:      * @throws java.net.UnknownHostException
1:a277fbe:      */
1:a277fbe:     @Test
1:a277fbe:     public void testMoveLeft() throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         // Moves to the left : nothing to fetch, last part to stream
1:a277fbe: 
1:a277fbe:         int movingNodeIdx = 1;
1:a277fbe:         BigIntegerToken newToken = new BigIntegerToken("21267647932558653966460912964485513216");
1:a277fbe:         BigIntegerToken[] tokens = initTokens();
1:a277fbe:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
1:4334f99:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
1:a277fbe: 
1:a277fbe:         assertEquals(ranges.left.iterator().next().left, tokensAfterMove[movingNodeIdx]);
1:a277fbe:         assertEquals(ranges.left.iterator().next().right, tokens[movingNodeIdx]);
1:a277fbe:         assertEquals("No data should be fetched", ranges.right.size(), 0);
1:a277fbe: 
1:a277fbe:     }
1:a277fbe: 
1:a277fbe:     @Test
1:a277fbe:     public void testMoveRight() throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         // Moves to the right : last part to fetch, nothing to stream
1:a277fbe: 
1:a277fbe:         int movingNodeIdx = 1;
1:a277fbe:         BigIntegerToken newToken = new BigIntegerToken("35267647932558653966460912964485513216");
1:a277fbe:         BigIntegerToken[] tokens = initTokens();
1:a277fbe:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
1:4334f99:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
1:a277fbe: 
1:a277fbe:         assertEquals("No data should be streamed", ranges.left.size(), 0);
1:a277fbe:         assertEquals(ranges.right.iterator().next().left, tokens[movingNodeIdx]);
1:a277fbe:         assertEquals(ranges.right.iterator().next().right, tokensAfterMove[movingNodeIdx]);
1:a277fbe: 
1:a277fbe:     }
1:a277fbe: 
1:69542a9:     @SuppressWarnings("unchecked")
1:a277fbe:     @Test
1:a277fbe:     public void testMoveMiddleOfRing() throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         // moves to another position in the middle of the ring : should stream all its data, and fetch all its new data
1:a277fbe: 
1:a277fbe:         int movingNodeIdx = 1;
1:a277fbe:         int movingNodeIdxAfterMove = 4;
1:a277fbe:         BigIntegerToken newToken = new BigIntegerToken("90070591730234615865843651857942052864");
1:a277fbe:         BigIntegerToken[] tokens = initTokens();
1:a277fbe:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
1:4334f99:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
1:a277fbe: 
1:a277fbe:         // sort the results, so they can be compared
1:69542a9:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:69542a9:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:a277fbe:         Arrays.sort(toStream);
1:a277fbe:         Arrays.sort(toFetch);
1:a277fbe: 
1:a277fbe:         // build expected ranges
1:69542a9:         Range<Token>[] toStreamExpected = new Range[2];
1:69542a9:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
1:69542a9:         toStreamExpected[1] = new Range<Token>(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:a277fbe:         Arrays.sort(toStreamExpected);
1:69542a9:         Range<Token>[] toFetchExpected = new Range[2];
1:69542a9:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:69542a9:         toFetchExpected[1] = new Range<Token>(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:a277fbe:         Arrays.sort(toFetchExpected);
1:a277fbe: 
1:a277fbe:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:a277fbe:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:a277fbe:     }
1:a277fbe: 
1:69542a9:     @SuppressWarnings("unchecked")
1:a277fbe:     @Test
1:a277fbe:     public void testMoveAfterNextNeighbors() throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         // moves after its next neighbor in the ring
1:a277fbe: 
1:a277fbe:         int movingNodeIdx = 1;
1:a277fbe:         int movingNodeIdxAfterMove = 2;
1:a277fbe:         BigIntegerToken newToken = new BigIntegerToken("52535295865117307932921825928971026432");
1:a277fbe:         BigIntegerToken[] tokens = initTokens();
1:a277fbe:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
1:4334f99:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
1:a277fbe: 
1:a277fbe: 
1:a277fbe:         // sort the results, so they can be compared
1:69542a9:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:69542a9:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:a277fbe:         Arrays.sort(toStream);
1:a277fbe:         Arrays.sort(toFetch);
1:a277fbe: 
1:a277fbe:         // build expected ranges
1:69542a9:         Range<Token>[] toStreamExpected = new Range[1];
1:69542a9:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
1:a277fbe:         Arrays.sort(toStreamExpected);
1:69542a9:         Range<Token>[] toFetchExpected = new Range[2];
1:69542a9:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:69542a9:         toFetchExpected[1] = new Range<Token>(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:a277fbe:         Arrays.sort(toFetchExpected);
1:a277fbe: 
1:a277fbe:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:a277fbe:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:a277fbe:     }
1:a277fbe: 
1:69542a9:     @SuppressWarnings("unchecked")
1:a277fbe:     @Test
1:a277fbe:     public void testMoveBeforePreviousNeighbor() throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         // moves before its previous neighbor in the ring
1:a277fbe: 
1:a277fbe:         int movingNodeIdx = 1;
1:a277fbe:         int movingNodeIdxAfterMove = 7;
1:a277fbe:         BigIntegerToken newToken = new BigIntegerToken("158873535527910577765226390751398592512");
1:a277fbe:         BigIntegerToken[] tokens = initTokens();
1:a277fbe:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
1:4334f99:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
1:a277fbe: 
1:69542a9:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:69542a9:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:a277fbe:         Arrays.sort(toStream);
1:a277fbe:         Arrays.sort(toFetch);
1:a277fbe: 
1:69542a9:         Range<Token>[] toStreamExpected = new Range[2];
1:69542a9:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx, tokensAfterMove), getToken(movingNodeIdx - 1, tokensAfterMove));
1:69542a9:         toStreamExpected[1] = new Range<Token>(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:a277fbe:         Arrays.sort(toStreamExpected);
1:69542a9:         Range<Token>[] toFetchExpected = new Range[1];
1:69542a9:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:a277fbe:         Arrays.sort(toFetchExpected);
1:a277fbe: 
1:a277fbe:         System.out.println("toStream : " + Arrays.toString(toStream));
1:a277fbe:         System.out.println("toFetch : " + Arrays.toString(toFetch));
1:a277fbe:         System.out.println("toStreamExpected : " + Arrays.toString(toStreamExpected));
1:a277fbe:         System.out.println("toFetchExpected : " + Arrays.toString(toFetchExpected));
1:a277fbe: 
1:a277fbe:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:a277fbe:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:a277fbe:     }
1:a277fbe: 
1:a277fbe:     private BigIntegerToken[] initTokensAfterMove(BigIntegerToken[] tokens,
1:a277fbe:             int movingNodeIdx, BigIntegerToken newToken)
1:a277fbe:     {
1:a277fbe:         BigIntegerToken[] tokensAfterMove = tokens.clone();
1:a277fbe:         tokensAfterMove[movingNodeIdx] = newToken;
1:a277fbe:         return tokensAfterMove;
1:a277fbe:     }
1:a277fbe: 
1:a277fbe:     private BigIntegerToken[] initTokens()
1:a277fbe:     {
1:a277fbe:         BigIntegerToken[] tokens = new BigIntegerToken[] {
1:a277fbe:                 new BigIntegerToken("0"), // just to be able to test
1:a277fbe:                 new BigIntegerToken("34028236692093846346337460743176821145"),
1:a277fbe:                 new BigIntegerToken("42535295865117307932921825928971026432"),
1:a277fbe:                 new BigIntegerToken("63802943797675961899382738893456539648"),
1:a277fbe:                 new BigIntegerToken("85070591730234615865843651857942052864"),
1:a277fbe:                 new BigIntegerToken("106338239662793269832304564822427566080"),
1:a277fbe:                 new BigIntegerToken("127605887595351923798765477786913079296"),
1:a277fbe:                 new BigIntegerToken("148873535527910577765226390751398592512")
1:a277fbe:         };
1:a277fbe:         return tokens;
1:a277fbe:     }
1:a277fbe: 
1:a277fbe:     private TokenMetadata initTokenMetadata(BigIntegerToken[] tokens)
1:a277fbe:             throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         TokenMetadata tokenMetadataCurrent = new TokenMetadata();
1:a277fbe: 
1:a277fbe:         int lastIPPart = 1;
1:a277fbe:         for (BigIntegerToken token : tokens)
1:a277fbe:             tokenMetadataCurrent.updateNormalToken(token, InetAddress.getByName("254.0.0." + Integer.toString(lastIPPart++)));
1:a277fbe: 
1:a277fbe:         return tokenMetadataCurrent;
1:a277fbe:     }
1:a277fbe: 
1:a277fbe:     private BigIntegerToken getToken(int idx, BigIntegerToken[] tokens)
1:a277fbe:     {
1:a277fbe:         if (idx >= tokens.length)
1:a277fbe:             idx = idx % tokens.length;
1:a277fbe:         while (idx < 0)
1:a277fbe:             idx += tokens.length;
1:a277fbe: 
1:a277fbe:         return tokens[idx];
1:a277fbe: 
1:a277fbe:     }
1:a277fbe: 
1:4334f99:     private Pair<Set<Range<Token>>, Set<Range<Token>>> calculateStreamAndFetchRanges(BigIntegerToken[] tokens, BigIntegerToken[] tokensAfterMove, int movingNodeIdx) throws UnknownHostException
1:a277fbe:     {
1:a277fbe:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1:a277fbe: 
1:a277fbe:         InetAddress movingNode = InetAddress.getByName("254.0.0." + Integer.toString(movingNodeIdx + 1));
1:a277fbe: 
1:a277fbe: 
1:a277fbe:         TokenMetadata tokenMetadataCurrent = initTokenMetadata(tokens);
1:a277fbe:         TokenMetadata tokenMetadataAfterMove = initTokenMetadata(tokensAfterMove);
1:31e3f61:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tokenMetadataCurrent, endpointSnitch, optsWithRF(2));
1:a277fbe: 
1:a277fbe:         Collection<Range<Token>> currentRanges = strategy.getAddressRanges().get(movingNode);
1:a277fbe:         Collection<Range<Token>> updatedRanges = strategy.getPendingAddressRanges(tokenMetadataAfterMove, tokensAfterMove[movingNodeIdx], movingNode);
1:a277fbe: 
1:a277fbe:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = StorageService.instance.calculateStreamAndFetchRanges(currentRanges, updatedRanges);
1:a277fbe: 
1:a277fbe:         return ranges;
1:a277fbe:     }
1:a277fbe: 
1:31e3f61:     private static Map<String, String> optsWithRF(int rf)
1:31e3f61:     {
1:31e3f61:         return Collections.singletonMap("replication_factor", Integer.toString(rf));
1:31e3f61:     }
1:ff533ad: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
/////////////////////////////////////////////////////////////////////////
1:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
/////////////////////////////////////////////////////////////////////////
1:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, optsWithRF(1));
/////////////////////////////////////////////////////////////////////////
1:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tokenMetadataCurrent, endpointSnitch, optsWithRF(2));
/////////////////////////////////////////////////////////////////////////
1:     private static Map<String, String> optsWithRF(int rf)
1:     {
1:         return Collections.singletonMap("replication_factor", Integer.toString(rf));
1:     }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Before;
1: import org.junit.Test;
1: 
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.net.UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.net.UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.net.UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.net.UnknownHostException
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69542a9
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:         Range<Token>[] toStreamExpected = new Range[2];
1:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
1:         toStreamExpected[1] = new Range<Token>(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:         Range<Token>[] toFetchExpected = new Range[2];
1:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:         toFetchExpected[1] = new Range<Token>(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:         Range<Token>[] toStreamExpected = new Range[1];
1:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
1:         Range<Token>[] toFetchExpected = new Range[2];
1:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:         toFetchExpected[1] = new Range<Token>(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:         Range<Token>[] toStream = ranges.left.toArray(new Range[0]);
1:         Range<Token>[] toFetch = ranges.right.toArray(new Range[0]);
1:         Range<Token>[] toStreamExpected = new Range[2];
1:         toStreamExpected[0] = new Range<Token>(getToken(movingNodeIdx, tokensAfterMove), getToken(movingNodeIdx - 1, tokensAfterMove));
1:         toStreamExpected[1] = new Range<Token>(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:         Range<Token>[] toFetchExpected = new Range[1];
1:         toFetchExpected[0] = new Range<Token>(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class OldNetworkTopologyStrategyTest
author:Dave Brosius
-------------------------------------------------------------------------------
commit:2639ac2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9639f95
/////////////////////////////////////////////////////////////////////////
1:     private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens)
commit:4334f99
/////////////////////////////////////////////////////////////////////////
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
/////////////////////////////////////////////////////////////////////////
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
/////////////////////////////////////////////////////////////////////////
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
/////////////////////////////////////////////////////////////////////////
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
/////////////////////////////////////////////////////////////////////////
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx);
/////////////////////////////////////////////////////////////////////////
1:     private Pair<Set<Range<Token>>, Set<Range<Token>>> calculateStreamAndFetchRanges(BigIntegerToken[] tokens, BigIntegerToken[] tokensAfterMove, int movingNodeIdx) throws UnknownHostException
author:paul cannon
-------------------------------------------------------------------------------
commit:a277fbe
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
1: 
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Set;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.utils.Pair;
0: import org.junit.Before;
0: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * test basic methods to move a node. For sure, it's not the best place, but it's easy to test
1:      *
0:      * @throws UnknownHostException
1:      */
1:     @Test
1:     public void testMoveLeft() throws UnknownHostException
1:     {
1:         // Moves to the left : nothing to fetch, last part to stream
1: 
1:         int movingNodeIdx = 1;
1:         BigIntegerToken newToken = new BigIntegerToken("21267647932558653966460912964485513216");
1:         BigIntegerToken[] tokens = initTokens();
1:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
0:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx, newToken);
1: 
1:         assertEquals(ranges.left.iterator().next().left, tokensAfterMove[movingNodeIdx]);
1:         assertEquals(ranges.left.iterator().next().right, tokens[movingNodeIdx]);
1:         assertEquals("No data should be fetched", ranges.right.size(), 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testMoveRight() throws UnknownHostException
1:     {
1:         // Moves to the right : last part to fetch, nothing to stream
1: 
1:         int movingNodeIdx = 1;
1:         BigIntegerToken newToken = new BigIntegerToken("35267647932558653966460912964485513216");
1:         BigIntegerToken[] tokens = initTokens();
1:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
0:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx, newToken);
1: 
1:         assertEquals("No data should be streamed", ranges.left.size(), 0);
1:         assertEquals(ranges.right.iterator().next().left, tokens[movingNodeIdx]);
1:         assertEquals(ranges.right.iterator().next().right, tokensAfterMove[movingNodeIdx]);
1: 
1:     }
1: 
1:     @Test
1:     public void testMoveMiddleOfRing() throws UnknownHostException
1:     {
1:         // moves to another position in the middle of the ring : should stream all its data, and fetch all its new data
1: 
1:         int movingNodeIdx = 1;
1:         int movingNodeIdxAfterMove = 4;
1:         BigIntegerToken newToken = new BigIntegerToken("90070591730234615865843651857942052864");
1:         BigIntegerToken[] tokens = initTokens();
1:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
0:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx, newToken);
1: 
1:         // sort the results, so they can be compared
0:         Range[] toStream = ranges.left.toArray(new Range[0]);
0:         Range[] toFetch = ranges.right.toArray(new Range[0]);
1:         Arrays.sort(toStream);
1:         Arrays.sort(toFetch);
1: 
1:         // build expected ranges
0:         Range[] toStreamExpected = new Range[2];
0:         toStreamExpected[0] = new Range(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
0:         toStreamExpected[1] = new Range(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:         Arrays.sort(toStreamExpected);
0:         Range[] toFetchExpected = new Range[2];
0:         toFetchExpected[0] = new Range(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
0:         toFetchExpected[1] = new Range(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:         Arrays.sort(toFetchExpected);
1: 
1:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:     }
1: 
1:     @Test
1:     public void testMoveAfterNextNeighbors() throws UnknownHostException
1:     {
1:         // moves after its next neighbor in the ring
1: 
1:         int movingNodeIdx = 1;
1:         int movingNodeIdxAfterMove = 2;
1:         BigIntegerToken newToken = new BigIntegerToken("52535295865117307932921825928971026432");
1:         BigIntegerToken[] tokens = initTokens();
1:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
0:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx, newToken);
1: 
1: 
1:         // sort the results, so they can be compared
0:         Range[] toStream = ranges.left.toArray(new Range[0]);
0:         Range[] toFetch = ranges.right.toArray(new Range[0]);
1:         Arrays.sort(toStream);
1:         Arrays.sort(toFetch);
1: 
1:         // build expected ranges
0:         Range[] toStreamExpected = new Range[1];
0:         toStreamExpected[0] = new Range(getToken(movingNodeIdx - 2, tokens), getToken(movingNodeIdx - 1, tokens));
1:         Arrays.sort(toStreamExpected);
0:         Range[] toFetchExpected = new Range[2];
0:         toFetchExpected[0] = new Range(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
0:         toFetchExpected[1] = new Range(getToken(movingNodeIdxAfterMove, tokensAfterMove), getToken(movingNodeIdx, tokensAfterMove));
1:         Arrays.sort(toFetchExpected);
1: 
1:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:     }
1: 
1:     @Test
1:     public void testMoveBeforePreviousNeighbor() throws UnknownHostException
1:     {
1:         // moves before its previous neighbor in the ring
1: 
1:         int movingNodeIdx = 1;
1:         int movingNodeIdxAfterMove = 7;
1:         BigIntegerToken newToken = new BigIntegerToken("158873535527910577765226390751398592512");
1:         BigIntegerToken[] tokens = initTokens();
1:         BigIntegerToken[] tokensAfterMove = initTokensAfterMove(tokens, movingNodeIdx, newToken);
0:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = calculateStreamAndFetchRanges(tokens, tokensAfterMove, movingNodeIdx, newToken);
1: 
0:         Range[] toStream = ranges.left.toArray(new Range[0]);
0:         Range[] toFetch = ranges.right.toArray(new Range[0]);
1:         Arrays.sort(toStream);
1:         Arrays.sort(toFetch);
1: 
0:         Range[] toStreamExpected = new Range[2];
0:         toStreamExpected[0] = new Range(getToken(movingNodeIdx, tokensAfterMove), getToken(movingNodeIdx - 1, tokensAfterMove));
0:         toStreamExpected[1] = new Range(getToken(movingNodeIdx - 1, tokens), getToken(movingNodeIdx, tokens));
1:         Arrays.sort(toStreamExpected);
0:         Range[] toFetchExpected = new Range[1];
0:         toFetchExpected[0] = new Range(getToken(movingNodeIdxAfterMove - 1, tokens), getToken(movingNodeIdxAfterMove, tokens));
1:         Arrays.sort(toFetchExpected);
1: 
1:         System.out.println("toStream : " + Arrays.toString(toStream));
1:         System.out.println("toFetch : " + Arrays.toString(toFetch));
1:         System.out.println("toStreamExpected : " + Arrays.toString(toStreamExpected));
1:         System.out.println("toFetchExpected : " + Arrays.toString(toFetchExpected));
1: 
1:         assertEquals(Arrays.equals(toStream, toStreamExpected), true);
1:         assertEquals(Arrays.equals(toFetch, toFetchExpected), true);
1:     }
1: 
1:     private BigIntegerToken[] initTokensAfterMove(BigIntegerToken[] tokens,
1:             int movingNodeIdx, BigIntegerToken newToken)
1:     {
1:         BigIntegerToken[] tokensAfterMove = tokens.clone();
1:         tokensAfterMove[movingNodeIdx] = newToken;
1:         return tokensAfterMove;
1:     }
1: 
1:     private BigIntegerToken[] initTokens()
1:     {
1:         BigIntegerToken[] tokens = new BigIntegerToken[] {
1:                 new BigIntegerToken("0"), // just to be able to test
1:                 new BigIntegerToken("34028236692093846346337460743176821145"),
1:                 new BigIntegerToken("42535295865117307932921825928971026432"),
1:                 new BigIntegerToken("63802943797675961899382738893456539648"),
1:                 new BigIntegerToken("85070591730234615865843651857942052864"),
1:                 new BigIntegerToken("106338239662793269832304564822427566080"),
1:                 new BigIntegerToken("127605887595351923798765477786913079296"),
1:                 new BigIntegerToken("148873535527910577765226390751398592512")
1:         };
1:         return tokens;
1:     }
1: 
1:     private TokenMetadata initTokenMetadata(BigIntegerToken[] tokens)
1:             throws UnknownHostException
1:     {
1:         TokenMetadata tokenMetadataCurrent = new TokenMetadata();
1: 
1:         int lastIPPart = 1;
1:         for (BigIntegerToken token : tokens)
1:             tokenMetadataCurrent.updateNormalToken(token, InetAddress.getByName("254.0.0." + Integer.toString(lastIPPart++)));
1: 
1:         return tokenMetadataCurrent;
1:     }
1: 
1:     private BigIntegerToken getToken(int idx, BigIntegerToken[] tokens)
1:     {
1:         if (idx >= tokens.length)
1:             idx = idx % tokens.length;
1:         while (idx < 0)
1:             idx += tokens.length;
1: 
1:         return tokens[idx];
1: 
1:     }
1: 
0:     private Pair<Set<Range<Token>>, Set<Range<Token>>> calculateStreamAndFetchRanges(BigIntegerToken[] tokens, BigIntegerToken[] tokensAfterMove, int movingNodeIdx, BigIntegerToken newToken) throws UnknownHostException
1:     {
1:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1: 
1:         InetAddress movingNode = InetAddress.getByName("254.0.0." + Integer.toString(movingNodeIdx + 1));
1: 
1: 
1:         TokenMetadata tokenMetadataCurrent = initTokenMetadata(tokens);
1:         TokenMetadata tokenMetadataAfterMove = initTokenMetadata(tokensAfterMove);
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tokenMetadataCurrent, endpointSnitch, KSMetaData.optsWithRF(2));
1: 
1:         Collection<Range<Token>> currentRanges = strategy.getAddressRanges().get(movingNode);
1:         Collection<Range<Token>> updatedRanges = strategy.getPendingAddressRanges(tokenMetadataAfterMove, tokensAfterMove[movingNodeIdx], movingNode);
1: 
1:         Pair<Set<Range<Token>>, Set<Range<Token>>> ranges = StorageService.instance.calculateStreamAndFetchRanges(currentRanges, updatedRanges);
1: 
1:         return ranges;
1:     }
1: 
1: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, KSMetaData.optsWithRF(1));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, KSMetaData.optsWithRF(1));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, KSMetaData.optsWithRF(1));
commit:2f5f0c2
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.SchemaLoader;
0: public class OldNetworkTopologyStrategyTest extends SchemaLoader
/////////////////////////////////////////////////////////////////////////
1:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
/////////////////////////////////////////////////////////////////////////
1:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
/////////////////////////////////////////////////////////////////////////
1:         testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
/////////////////////////////////////////////////////////////////////////
0:     private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens) throws UnknownHostException
commit:916c810
/////////////////////////////////////////////////////////////////////////
0: public class OldNetworkTopologyStrategyTest
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, null);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, null);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new OldNetworkTopologyStrategy("Keyspace1", tmd, endpointSnitch, null);
commit:34e241a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.locator;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Before;
0: import org.junit.Test;
1: 
0: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
0:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyToken, table);
commit:ff533ad
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
1: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
0: package org.apache.cassandra.locator;
1: 
0: import static org.junit.Assert.assertEquals;
1: 
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.BigIntegerToken;
1: import org.apache.cassandra.dht.Token;
1: 
0: import org.junit.Before;
0: import org.junit.Test;
1: 
0: public class RackAwareStrategyTest
1: {
0:     private List<Token> endpointTokens;
1:     private List<Token> keyTokens;
1:     private TokenMetadata tmd;
1:     private Map<String, ArrayList<InetAddress>> expectedResults;
1: 
1:     @Before
1:     public void init()
1:     {
0:         endpointTokens = new ArrayList<Token>();
1:         keyTokens = new ArrayList<Token>();
1:         tmd = new TokenMetadata();
1:         expectedResults = new HashMap<String, ArrayList<InetAddress>>();
1:     }
1: 
1:     /**
1:      * 4 same rack endpoints
1:      *
0:      * @throws UnknownHostException
1:      */
1:     @Test
1:     public void testBigIntegerEndpointsA() throws UnknownHostException
1:     {
1:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
1:         addEndpoint("0", "5", "254.0.0.1");
1:         addEndpoint("10", "15", "254.0.0.2");
1:         addEndpoint("20", "25", "254.0.0.3");
1:         addEndpoint("30", "35", "254.0.0.4");
1: 
1:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.0.3", "254.0.0.4"));
1:         expectedResults.put("15", buildResult("254.0.0.3", "254.0.0.4", "254.0.0.1"));
1:         expectedResults.put("25", buildResult("254.0.0.4", "254.0.0.1", "254.0.0.2"));
1:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.0.2", "254.0.0.3"));
1: 
0:         runTestForReplicatedTables(strategy);
1:     }
1: 
1:     /**
1:      * 3 same rack endpoints
1:      * 1 external datacenter
1:      *
0:      * @throws UnknownHostException
1:      */
1:     @Test
1:     public void testBigIntegerEndpointsB() throws UnknownHostException
1:     {
1:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
1:         addEndpoint("0", "5", "254.0.0.1");
1:         addEndpoint("10", "15", "254.0.0.2");
1:         addEndpoint("20", "25", "254.1.0.3");
1:         addEndpoint("30", "35", "254.0.0.4");
1: 
1:         expectedResults.put("5", buildResult("254.0.0.2", "254.1.0.3", "254.0.0.4"));
1:         expectedResults.put("15", buildResult("254.1.0.3", "254.0.0.4", "254.0.0.1"));
1:         expectedResults.put("25", buildResult("254.0.0.4", "254.1.0.3", "254.0.0.1"));
1:         expectedResults.put("35", buildResult("254.0.0.1", "254.1.0.3", "254.0.0.2"));
1: 
0:         runTestForReplicatedTables(strategy);
1:     }
1: 
1:     /**
1:      * 2 same rack endpoints
1:      * 1 same datacenter, different rack endpoints
1:      * 1 external datacenter
1:      *
0:      * @throws UnknownHostException
1:      */
1:     @Test
1:     public void testBigIntegerEndpointsC() throws UnknownHostException
1:     {
1:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
1: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
1:         addEndpoint("0", "5", "254.0.0.1");
1:         addEndpoint("10", "15", "254.0.0.2");
1:         addEndpoint("20", "25", "254.0.1.3");
1:         addEndpoint("30", "35", "254.1.0.4");
1: 
1:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.1.3", "254.1.0.4"));
1:         expectedResults.put("15", buildResult("254.0.1.3", "254.1.0.4", "254.0.0.1"));
1:         expectedResults.put("25", buildResult("254.1.0.4", "254.0.0.1", "254.0.0.2"));
1:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.1.3", "254.1.0.4"));
1: 
0:         runTestForReplicatedTables(strategy);
1:     }
1: 
0:     private void runTestForReplicatedTables(AbstractReplicationStrategy strategy) throws UnknownHostException
1:     {
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
1:         {
0:             if (DatabaseDescriptor.getReplicationFactor(table) == 3)
0:                 testGetEndpoints(strategy, keyTokens.toArray(new Token[0]), table);
1:         }
1:     }
1: 
1:     private ArrayList<InetAddress> buildResult(String... addresses) throws UnknownHostException
1:     {
1:         ArrayList<InetAddress> result = new ArrayList<InetAddress>();
1:         for (String address : addresses)
1:         {
1:             result.add(InetAddress.getByName(address));
1:         }
1:         return result;
1:     }
1: 
1:     private void addEndpoint(String endpointTokenID, String keyTokenID, String endpointAddress) throws UnknownHostException
1:     {
1:         BigIntegerToken endpointToken = new BigIntegerToken(endpointTokenID);
0:         endpointTokens.add(endpointToken);
1: 
1:         BigIntegerToken keyToken = new BigIntegerToken(keyTokenID);
1:         keyTokens.add(keyToken);
1: 
1:         InetAddress ep = InetAddress.getByName(endpointAddress);
1:         tmd.updateNormalToken(endpointToken, ep);
1:     }
1: 
0:     private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens, String table) throws UnknownHostException
1:     {
1:         for (Token keyToken : keyTokens)
1:         {
0:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyToken, tmd, table);
1:             for (int j = 0; j < endpoints.size(); j++)
1:             {
1:                 ArrayList<InetAddress> hostsExpected = expectedResults.get(keyToken.toString());
1:                 assertEquals(endpoints.get(j), hostsExpected.get(j));
1:             }
1:         }
1:     }
1: 
1: }
commit:1a904da
/////////////////////////////////////////////////////////////////////////
0:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
/////////////////////////////////////////////////////////////////////////
0:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
/////////////////////////////////////////////////////////////////////////
0:         RackInferringSnitch endpointSnitch = new RackInferringSnitch();
commit:2e1b1a5
/////////////////////////////////////////////////////////////////////////
0:         EndpointSnitch endpointSnitch = new EndpointSnitch();
/////////////////////////////////////////////////////////////////////////
0:         EndpointSnitch endpointSnitch = new EndpointSnitch();
/////////////////////////////////////////////////////////////////////////
0:         EndpointSnitch endpointSnitch = new EndpointSnitch();
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
0:     private List<Token> endpointTokens;
/////////////////////////////////////////////////////////////////////////
0:         endpointTokens = new ArrayList<Token>();
/////////////////////////////////////////////////////////////////////////
0:         EndPointSnitch endpointSnitch = new EndPointSnitch();
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
0:         addEndpoint("0", "5", "254.0.0.1");
0:         addEndpoint("10", "15", "254.0.0.2");
0:         addEndpoint("20", "25", "254.0.0.3");
0:         addEndpoint("30", "35", "254.0.0.4");
/////////////////////////////////////////////////////////////////////////
0:         EndPointSnitch endpointSnitch = new EndPointSnitch();
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
0:         addEndpoint("0", "5", "254.0.0.1");
0:         addEndpoint("10", "15", "254.0.0.2");
0:         addEndpoint("20", "25", "254.1.0.3");
0:         addEndpoint("30", "35", "254.0.0.4");
/////////////////////////////////////////////////////////////////////////
0:         EndPointSnitch endpointSnitch = new EndPointSnitch();
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endpointSnitch);
0:         addEndpoint("0", "5", "254.0.0.1");
0:         addEndpoint("10", "15", "254.0.0.2");
0:         addEndpoint("20", "25", "254.0.1.3");
0:         addEndpoint("30", "35", "254.1.0.4");
/////////////////////////////////////////////////////////////////////////
0:     private void addEndpoint(String endpointTokenID, String keyTokenID, String endpointAddress) throws UnknownHostException
0:         BigIntegerToken endpointToken = new BigIntegerToken(endpointTokenID);
0:         endpointTokens.add(endpointToken);
0:         InetAddress ep = InetAddress.getByName(endpointAddress);
0:         tmd.updateNormalToken(endpointToken, ep);
0:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyToken, tmd, table);
0:             for (int j = 0; j < endpoints.size(); j++)
0:                 assertEquals(endpoints.get(j), hostsExpected.get(j));
commit:a8bf985
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
0: package org.apache.cassandra.locator;
0: 
0: import static org.junit.Assert.assertEquals;
0: 
0: import java.net.InetAddress;
0: import java.net.UnknownHostException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.BigIntegerToken;
0: import org.apache.cassandra.dht.Token;
0: 
0: import org.junit.Before;
0: import org.junit.Test;
0: 
0: public class RackAwareStrategyTest
0: {
0:     private List<Token> endPointTokens;
0:     private List<Token> keyTokens;
0:     private TokenMetadata tmd;
0:     private Map<String, ArrayList<InetAddress>> expectedResults;
0: 
0:     @Before
0:     public void init()
0:     {
0:         endPointTokens = new ArrayList<Token>();
0:         keyTokens = new ArrayList<Token>();
0:         tmd = new TokenMetadata();
0:         expectedResults = new HashMap<String, ArrayList<InetAddress>>();
0:     }
0: 
0:     /**
0:      * 4 same rack endpoints
0:      *
0:      * @throws UnknownHostException
0:      */
0:     @Test
0:     public void testBigIntegerEndpointsA() throws UnknownHostException
0:     {
0:         EndPointSnitch endPointSnitch = new EndPointSnitch();
0: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endPointSnitch);
0:         addEndPoint("0", "5", "254.0.0.1");
0:         addEndPoint("10", "15", "254.0.0.2");
0:         addEndPoint("20", "25", "254.0.0.3");
0:         addEndPoint("30", "35", "254.0.0.4");
0: 
0:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.0.3", "254.0.0.4"));
0:         expectedResults.put("15", buildResult("254.0.0.3", "254.0.0.4", "254.0.0.1"));
0:         expectedResults.put("25", buildResult("254.0.0.4", "254.0.0.1", "254.0.0.2"));
0:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.0.2", "254.0.0.3"));
0: 
0:         runTestForReplicatedTables(strategy);
0:     }
0: 
0:     /**
0:      * 3 same rack endpoints
0:      * 1 external datacenter
0:      *
0:      * @throws UnknownHostException
0:      */
0:     @Test
0:     public void testBigIntegerEndpointsB() throws UnknownHostException
0:     {
0:         EndPointSnitch endPointSnitch = new EndPointSnitch();
0: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endPointSnitch);
0:         addEndPoint("0", "5", "254.0.0.1");
0:         addEndPoint("10", "15", "254.0.0.2");
0:         addEndPoint("20", "25", "254.1.0.3");
0:         addEndPoint("30", "35", "254.0.0.4");
0: 
0:         expectedResults.put("5", buildResult("254.0.0.2", "254.1.0.3", "254.0.0.4"));
0:         expectedResults.put("15", buildResult("254.1.0.3", "254.0.0.4", "254.0.0.1"));
0:         expectedResults.put("25", buildResult("254.0.0.4", "254.1.0.3", "254.0.0.1"));
0:         expectedResults.put("35", buildResult("254.0.0.1", "254.1.0.3", "254.0.0.2"));
0: 
0:         runTestForReplicatedTables(strategy);
0:     }
0: 
0:     /**
0:      * 2 same rack endpoints
0:      * 1 same datacenter, different rack endpoints
0:      * 1 external datacenter
0:      *
0:      * @throws UnknownHostException
0:      */
0:     @Test
0:     public void testBigIntegerEndpointsC() throws UnknownHostException
0:     {
0:         EndPointSnitch endPointSnitch = new EndPointSnitch();
0: 
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy(tmd, endPointSnitch);
0:         addEndPoint("0", "5", "254.0.0.1");
0:         addEndPoint("10", "15", "254.0.0.2");
0:         addEndPoint("20", "25", "254.0.1.3");
0:         addEndPoint("30", "35", "254.1.0.4");
0: 
0:         expectedResults.put("5", buildResult("254.0.0.2", "254.0.1.3", "254.1.0.4"));
0:         expectedResults.put("15", buildResult("254.0.1.3", "254.1.0.4", "254.0.0.1"));
0:         expectedResults.put("25", buildResult("254.1.0.4", "254.0.0.1", "254.0.0.2"));
0:         expectedResults.put("35", buildResult("254.0.0.1", "254.0.1.3", "254.1.0.4"));
0: 
0:         runTestForReplicatedTables(strategy);
0:     }
0: 
0:     private void runTestForReplicatedTables(AbstractReplicationStrategy strategy) throws UnknownHostException
0:     {
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:         {
0:             if (DatabaseDescriptor.getReplicationFactor(table) == 3)
0:                 testGetEndpoints(strategy, keyTokens.toArray(new Token[0]), table);
0:         }
0:     }
0: 
0:     private ArrayList<InetAddress> buildResult(String... addresses) throws UnknownHostException
0:     {
0:         ArrayList<InetAddress> result = new ArrayList<InetAddress>();
0:         for (String address : addresses)
0:         {
0:             result.add(InetAddress.getByName(address));
0:         }
0:         return result;
0:     }
0: 
0:     private void addEndPoint(String endPointTokenID, String keyTokenID, String endPointAddress) throws UnknownHostException
0:     {
0:         BigIntegerToken endPointToken = new BigIntegerToken(endPointTokenID);
0:         endPointTokens.add(endPointToken);
0: 
0:         BigIntegerToken keyToken = new BigIntegerToken(keyTokenID);
0:         keyTokens.add(keyToken);
0: 
0:         InetAddress ep = InetAddress.getByName(endPointAddress);
0:         tmd.updateNormalToken(endPointToken, ep);
0:     }
0: 
0:     private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens, String table) throws UnknownHostException
0:     {
0:         for (Token keyToken : keyTokens)
0:         {
0:             List<InetAddress> endPoints = strategy.getNaturalEndpoints(keyToken, tmd, table);
0:             for (int j = 0; j < endPoints.size(); j++)
0:             {
0:                 ArrayList<InetAddress> hostsExpected = expectedResults.get(keyToken.toString());
0:                 assertEquals(endPoints.get(j), hostsExpected.get(j));
0:             }
0:         }
0:     }
0: 
0: }
author:Eric Evans
-------------------------------------------------------------------------------
commit:df8a933
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy("Keyspace1", tmd, endpointSnitch, null);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy("Keyspace1", tmd, endpointSnitch, null);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackAwareStrategy("Keyspace1", tmd, endpointSnitch, null);
/////////////////////////////////////////////////////////////////////////
1:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyToken);
============================================================================