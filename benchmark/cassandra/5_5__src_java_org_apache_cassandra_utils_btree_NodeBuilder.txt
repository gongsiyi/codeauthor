1:9f14856: /*
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:9f14856:  *
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9f14856:  *
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:9f14856:  */
1:412b053: package org.apache.cassandra.utils.btree;
2:412b053: 
1:4b54b8a: import org.apache.cassandra.utils.ObjectSizes;
1:4b54b8a: 
1:412b053: import java.util.Arrays;
1:412b053: import java.util.Comparator;
1:412b053: 
1:5250d7f: import static org.apache.cassandra.utils.btree.BTree.*;
1:412b053: 
1:412b053: /**
1:412b053:  * Represents a level / stack item of in progress modifications to a BTree.
1:412b053:  */
1:412b053: final class NodeBuilder
1:5f82aa3: {
1:412b053:     private static final int MAX_KEYS = 1 + (FAN_FACTOR * 2);
1:412b053: 
1:412b053:     // parent stack
1:412b053:     private NodeBuilder parent, child;
1:412b053: 
1:412b053:     // buffer for building new nodes
1:412b053:     private Object[] buildKeys = new Object[MAX_KEYS];  // buffers keys for branches and leaves
1:412b053:     private Object[] buildChildren = new Object[1 + MAX_KEYS]; // buffers children for branches only
1:412b053:     private int buildKeyPosition;
1:412b053:     private int buildChildPosition;
1:412b053:     // we null out the contents of buildKeys/buildChildren when clear()ing them for re-use; this is where
1:412b053:     // we track how much we actually have to null out
1:412b053:     private int maxBuildKeyPosition;
1:412b053: 
1:412b053:     // current node of the btree we're modifying/copying from
1:412b053:     private Object[] copyFrom;
1:412b053:     // the index of the first key in copyFrom that has not yet been copied into the build arrays
1:412b053:     private int copyFromKeyPosition;
1:412b053:     // the index of the first child node in copyFrom that has not yet been copied into the build arrays
1:412b053:     private int copyFromChildPosition;
1:412b053: 
1:4b54b8a:     private UpdateFunction updateFunction;
1:4b54b8a:     private Comparator comparator;
1:4b54b8a: 
1:412b053:     // upper bound of range owned by this level; lets us know if we need to ascend back up the tree
1:412b053:     // for the next key we update when bsearch gives an insertion point past the end of the values
1:412b053:     // in the current node
1:412b053:     private Object upperBound;
1:412b053: 
1:412b053:     // ensure we aren't referencing any garbage
1:412b053:     void clear()
4:412b053:     {
1:412b053:         NodeBuilder current = this;
1:e6e596d:         while (current != null && current.upperBound != null)
1:412b053:         {
1:e6e596d:             current.clearSelf();
1:412b053:             current = current.child;
4:412b053:         }
1:e6e596d:         current = parent;
1:e6e596d:         while (current != null && current.upperBound != null)
1:e6e596d:         {
1:e6e596d:             current.clearSelf();
1:e6e596d:             current = current.parent;
1:e6e596d:         }
1:e6e596d:     }
1:e6e596d: 
1:e6e596d:     void clearSelf()
1:e6e596d:     {
1:e6e596d:         reset(null, null, null, null);
1:e6e596d:         Arrays.fill(buildKeys, 0, maxBuildKeyPosition, null);
1:e6e596d:         Arrays.fill(buildChildren, 0, maxBuildKeyPosition + 1, null);
1:e6e596d:         maxBuildKeyPosition = 0;
1:412b053:     }
1:412b053: 
1:412b053:     // reset counters/setup to copy from provided node
1:4b54b8a:     void reset(Object[] copyFrom, Object upperBound, UpdateFunction updateFunction, Comparator comparator)
1:412b053:     {
1:412b053:         this.copyFrom = copyFrom;
1:412b053:         this.upperBound = upperBound;
1:4b54b8a:         this.updateFunction = updateFunction;
1:4b54b8a:         this.comparator = comparator;
1:412b053:         maxBuildKeyPosition = Math.max(maxBuildKeyPosition, buildKeyPosition);
1:412b053:         buildKeyPosition = 0;
1:412b053:         buildChildPosition = 0;
1:412b053:         copyFromKeyPosition = 0;
1:412b053:         copyFromChildPosition = 0;
1:412b053:     }
1:412b053: 
1:acf1b18:     NodeBuilder finish()
1:acf1b18:     {
1:acf1b18:         assert copyFrom != null;
1:acf1b18:         int copyFromKeyEnd = getKeyEnd(copyFrom);
1:acf1b18: 
1:acf1b18:         if (buildKeyPosition + buildChildPosition > 0)
1:acf1b18:         {
1:acf1b18:             // only want to copy if we've already changed something, otherwise we'll return the original
1:acf1b18:             copyKeys(copyFromKeyEnd);
1:acf1b18:             if (!isLeaf(copyFrom))
1:acf1b18:                 copyChildren(copyFromKeyEnd + 1);
1:acf1b18:         }
1:acf1b18:         return isRoot() ? null : ascend();
1:acf1b18:     }
1:acf1b18: 
1:412b053:     /**
1:412b053:      * Inserts or replaces the provided key, copying all not-yet-visited keys prior to it into our buffer.
1:412b053:      *
1:412b053:      * @param key key we are inserting/replacing
1:412b053:      * @return the NodeBuilder to retry the update against (a child if we own the range being updated,
1:412b053:      * a parent if we do not -- we got here from an earlier key -- and we need to ascend back up),
1:412b053:      * or null if we finished the update in this node.
1:412b053:      */
1:72507b7:     NodeBuilder update(Object key)
1:412b053:     {
1:412b053:         assert copyFrom != null;
1:412b053:         int copyFromKeyEnd = getKeyEnd(copyFrom);
1:412b053: 
1:acf1b18:         int i = copyFromKeyPosition;
1:acf1b18:         boolean found; // exact key match?
1:5ab1d95:         boolean owns = true; // true if this node (or a child) should contain the key
1:acf1b18:         if (i == copyFromKeyEnd)
1:acf1b18:         {
1:acf1b18:             found = false;
1:acf1b18:         }
1:acf1b18:         else
1:acf1b18:         {
1:acf1b18:             // this optimisation is for the common scenario of updating an existing row with the same columns/keys
1:acf1b18:             // and simply avoids performing a binary search until we've checked the proceeding key;
1:acf1b18:             // possibly we should disable this check if we determine that it fails more than a handful of times
1:acf1b18:             // during any given builder use to get the best of both worlds
1:e77ea12:             int c = -comparator.compare(key, copyFrom[i]);
1:acf1b18:             if (c >= 0)
1:acf1b18:             {
1:acf1b18:                 found = c == 0;
1:acf1b18:             }
1:acf1b18:             else
1:acf1b18:             {
1:5250d7f:                 i = Arrays.binarySearch(copyFrom, i + 1, copyFromKeyEnd, key, comparator);
1:acf1b18:                 found = i >= 0;
1:acf1b18:                 if (!found)
1:acf1b18:                     i = -i - 1;
1:acf1b18:             }
1:acf1b18:         }
1:acf1b18: 
1:5f82aa3:         if (found)
1:412b053:         {
1:5f82aa3:             Object prev = copyFrom[i];
1:5f82aa3:             Object next = updateFunction.apply(prev, key);
1:5f82aa3:             // we aren't actually replacing anything, so leave our state intact and continue
1:5f82aa3:             if (prev == next)
1:5f82aa3:                 return null;
1:5f82aa3:             key = next;
1:5f82aa3:         }
1:5250d7f:         else if (i == copyFromKeyEnd && compareUpperBound(comparator, key, upperBound) >= 0)
1:acf1b18:             owns = false;
1:412b053: 
1:412b053:         if (isLeaf(copyFrom))
1:412b053:         {
1:412b053: 
1:412b053:             if (owns)
1:412b053:             {
1:5f82aa3:                 // copy keys from the original node up to prior to the found index
1:5f82aa3:                 copyKeys(i);
1:5f82aa3: 
1:412b053:                 if (found)
1:5f82aa3:                 {
1:5f82aa3:                     // if found, we've applied updateFunction already
1:4b54b8a:                     replaceNextKey(key);
1:5f82aa3:                 }
1:5f82aa3:                 else
1:5f82aa3:                 {
1:986a1a7:                     // if not found, we need to apply updateFunction still, which is handled in addNewKey
1:986a1a7:                     addNewKey(key);
1:5f82aa3:                 }
1:412b053: 
1:412b053:                 // done, so return null
2:412b053:                 return null;
1:412b053:             }
1:5f82aa3:             else
1:5f82aa3:             {
1:5f82aa3:                 // we don't want to copy anything if we're ascending and haven't copied anything previously,
1:5f82aa3:                 // as in this case we can return the original node. Leaving buildKeyPosition as 0 indicates
1:5f82aa3:                 // to buildFromRange that it should return the original instead of building a new node
1:5f82aa3:                 if (buildKeyPosition > 0)
1:5f82aa3:                     copyKeys(i);
1:5f82aa3:             }
1:412b053: 
1:412b053:             // if we don't own it, all we need to do is ensure we've copied everything in this node
1:412b053:             // (which we have done, since not owning means pos >= keyEnd), ascend, and let Modifier.update
1:412b053:             // retry against the parent node.  The if/ascend after the else branch takes care of that.
1:412b053:         }
3:412b053:         else
1:412b053:         {
1:412b053:             // branch
1:412b053:             if (found)
1:412b053:             {
2:412b053:                 copyKeys(i);
1:4b54b8a:                 replaceNextKey(key);
1:412b053:                 copyChildren(i + 1);
1:412b053:                 return null;
1:412b053:             }
1:412b053:             else if (owns)
1:412b053:             {
1:412b053:                 copyKeys(i);
1:412b053:                 copyChildren(i);
1:412b053: 
1:412b053:                 // belongs to the range owned by this node, but not equal to any key in the node
1:412b053:                 // so descend into the owning child
1:412b053:                 Object newUpperBound = i < copyFromKeyEnd ? copyFrom[i] : upperBound;
1:412b053:                 Object[] descendInto = (Object[]) copyFrom[copyFromKeyEnd + i];
1:4b54b8a:                 ensureChild().reset(descendInto, newUpperBound, updateFunction, comparator);
1:412b053:                 return child;
1:412b053:             }
1:5f82aa3:             else if (buildKeyPosition > 0 || buildChildPosition > 0)
1:412b053:             {
1:5f82aa3:                 // ensure we've copied all keys and children, but only if we've already copied something.
1:5f82aa3:                 // otherwise we want to return the original node
1:412b053:                 copyKeys(copyFromKeyEnd);
1:412b053:                 copyChildren(copyFromKeyEnd + 1); // since we know that there are exactly 1 more child nodes, than keys
1:412b053:             }
1:412b053:         }
1:412b053: 
1:412b053:         return ascend();
1:412b053:     }
1:412b053: 
1:5250d7f:     private static <V> int compareUpperBound(Comparator<V> comparator, Object value, Object upperBound)
1:5250d7f:     {
1:5250d7f:         return upperBound == POSITIVE_INFINITY ? -1 : comparator.compare((V)value, (V)upperBound);
1:5250d7f:     }
1:412b053: 
1:412b053:     // UTILITY METHODS FOR IMPLEMENTATION OF UPDATE/BUILD/DELETE
1:412b053: 
1:412b053:     boolean isRoot()
1:412b053:     {
1:412b053:         // if parent == null, or parent.upperBound == null, then we have not initialised a parent builder,
1:412b053:         // so we are the top level builder holding modifications; if we have more than FAN_FACTOR items, though,
1:412b053:         // we are not a valid root so we would need to spill-up to create a new root
1:412b053:         return (parent == null || parent.upperBound == null) && buildKeyPosition <= FAN_FACTOR;
1:412b053:     }
1:412b053: 
1:412b053:     // ascend to the root node, splitting into proper node sizes as we go; useful for building
1:412b053:     // where we work only on the newest child node, which may construct many spill-over parents as it goes
1:412b053:     NodeBuilder ascendToRoot()
1:412b053:     {
1:412b053:         NodeBuilder current = this;
1:412b053:         while (!current.isRoot())
1:412b053:             current = current.ascend();
1:412b053:         return current;
1:412b053:     }
1:412b053: 
1:412b053:     // builds a new root BTree node - must be called on root of operation
1:412b053:     Object[] toNode()
1:412b053:     {
1:639d4b2:         // we permit building empty trees as some constructions do not know in advance how many items they will contain
1:639d4b2:         assert buildKeyPosition <= FAN_FACTOR : buildKeyPosition;
1:4b54b8a:         return buildFromRange(0, buildKeyPosition, isLeaf(copyFrom), false);
1:412b053:     }
1:412b053: 
1:412b053:     // finish up this level and pass any constructed children up to our parent, ensuring a parent exists
1:412b053:     private NodeBuilder ascend()
1:412b053:     {
1:412b053:         ensureParent();
1:412b053:         boolean isLeaf = isLeaf(copyFrom);
1:412b053:         if (buildKeyPosition > FAN_FACTOR)
1:412b053:         {
1:412b053:             // split current node and move the midpoint into parent, with the two halves as children
1:412b053:             int mid = buildKeyPosition / 2;
1:4b54b8a:             parent.addExtraChild(buildFromRange(0, mid, isLeaf, true), buildKeys[mid]);
1:4b54b8a:             parent.finishChild(buildFromRange(mid + 1, buildKeyPosition - (mid + 1), isLeaf, false));
1:412b053:         }
1:412b053:         else
1:412b053:         {
1:4b54b8a:             parent.finishChild(buildFromRange(0, buildKeyPosition, isLeaf, false));
1:412b053:         }
1:412b053:         return parent;
1:412b053:     }
1:412b053: 
1:412b053:     // copy keys from copyf to the builder, up to the provided index in copyf (exclusive)
1:412b053:     private void copyKeys(int upToKeyPosition)
1:412b053:     {
1:412b053:         if (copyFromKeyPosition >= upToKeyPosition)
1:412b053:             return;
1:412b053: 
1:412b053:         int len = upToKeyPosition - copyFromKeyPosition;
1:412b053:         assert len <= FAN_FACTOR : upToKeyPosition + "," + copyFromKeyPosition;
1:412b053: 
1:412b053:         ensureRoom(buildKeyPosition + len);
1:5f82aa3:         if (len > 0)
1:5f82aa3:         {
1:5f82aa3:             System.arraycopy(copyFrom, copyFromKeyPosition, buildKeys, buildKeyPosition, len);
1:5f82aa3:             copyFromKeyPosition = upToKeyPosition;
1:5f82aa3:             buildKeyPosition += len;
1:5f82aa3:         }
1:412b053:     }
1:412b053: 
1:412b053:     // skips the next key in copyf, and puts the provided key in the builder instead
1:72507b7:     private void replaceNextKey(Object with)
1:412b053:     {
1:412b053:         // (this first part differs from addNewKey in that we pass the replaced object to replaceF as well)
1:412b053:         ensureRoom(buildKeyPosition + 1);
1:412b053:         buildKeys[buildKeyPosition++] = with;
1:412b053: 
1:412b053:         copyFromKeyPosition++;
1:412b053:     }
1:412b053: 
1:986a1a7:     // applies the updateFunction
1:986a1a7:     // puts the resulting key into the builder
1:986a1a7:     // splits the parent if necessary via ensureRoom
1:72507b7:     void addNewKey(Object key)
1:412b053:     {
1:412b053:         ensureRoom(buildKeyPosition + 1);
1:0cb1e3d:         buildKeys[buildKeyPosition++] = updateFunction.apply(key);
1:412b053:     }
1:412b053: 
1:412b053:     // copies children from copyf to the builder, up to the provided index in copyf (exclusive)
1:412b053:     private void copyChildren(int upToChildPosition)
1:412b053:     {
1:412b053:         // (ensureRoom isn't called here, as we should always be at/behind key additions)
1:412b053:         if (copyFromChildPosition >= upToChildPosition)
1:412b053:             return;
1:412b053:         int len = upToChildPosition - copyFromChildPosition;
1:5f82aa3:         if (len > 0)
1:5f82aa3:         {
1:5f82aa3:             System.arraycopy(copyFrom, getKeyEnd(copyFrom) + copyFromChildPosition, buildChildren, buildChildPosition, len);
1:5f82aa3:             copyFromChildPosition = upToChildPosition;
1:5f82aa3:             buildChildPosition += len;
1:5f82aa3:         }
1:412b053:     }
1:412b053: 
1:412b053:     // adds a new and unexpected child to the builder - called by children that overflow
1:412b053:     private void addExtraChild(Object[] child, Object upperBound)
1:412b053:     {
1:412b053:         ensureRoom(buildKeyPosition + 1);
1:412b053:         buildKeys[buildKeyPosition++] = upperBound;
1:412b053:         buildChildren[buildChildPosition++] = child;
1:412b053:     }
1:412b053: 
1:412b053:     // adds a replacement expected child to the builder - called by children prior to ascending
1:412b053:     private void finishChild(Object[] child)
1:412b053:     {
1:412b053:         buildChildren[buildChildPosition++] = child;
1:412b053:         copyFromChildPosition++;
1:412b053:     }
1:412b053: 
1:412b053:     // checks if we can add the requested keys+children to the builder, and if not we spill-over into our parent
1:412b053:     private void ensureRoom(int nextBuildKeyPosition)
1:412b053:     {
1:412b053:         if (nextBuildKeyPosition < MAX_KEYS)
1:412b053:             return;
1:412b053: 
1:412b053:         // flush even number of items so we don't waste leaf space repeatedly
1:4b54b8a:         Object[] flushUp = buildFromRange(0, FAN_FACTOR, isLeaf(copyFrom), true);
1:412b053:         ensureParent().addExtraChild(flushUp, buildKeys[FAN_FACTOR]);
1:412b053:         int size = FAN_FACTOR + 1;
1:412b053:         assert size <= buildKeyPosition : buildKeyPosition + "," + nextBuildKeyPosition;
1:412b053:         System.arraycopy(buildKeys, size, buildKeys, 0, buildKeyPosition - size);
1:412b053:         buildKeyPosition -= size;
1:412b053:         maxBuildKeyPosition = buildKeys.length;
1:412b053:         if (buildChildPosition > 0)
1:412b053:         {
1:412b053:             System.arraycopy(buildChildren, size, buildChildren, 0, buildChildPosition - size);
1:412b053:             buildChildPosition -= size;
1:412b053:         }
1:412b053:     }
1:412b053: 
1:412b053:     // builds and returns a node from the buffered objects in the given range
1:4b54b8a:     private Object[] buildFromRange(int offset, int keyLength, boolean isLeaf, boolean isExtra)
1:412b053:     {
1:5f82aa3:         // if keyLength is 0, we didn't copy anything from the original, which means we didn't
1:5f82aa3:         // modify any of the range owned by it, so can simply return it as is
1:5f82aa3:         if (keyLength == 0)
1:5f82aa3:             return copyFrom;
1:5f82aa3: 
1:412b053:         Object[] a;
1:412b053:         if (isLeaf)
1:412b053:         {
1:5250d7f:             a = new Object[keyLength | 1];
1:412b053:             System.arraycopy(buildKeys, offset, a, 0, keyLength);
1:412b053:         }
1:412b053:         else
1:4b54b8a:         {
1:5250d7f:             a = new Object[2 + (keyLength * 2)];
1:412b053:             System.arraycopy(buildKeys, offset, a, 0, keyLength);
1:412b053:             System.arraycopy(buildChildren, offset, a, keyLength, keyLength + 1);
1:5250d7f: 
1:5250d7f:             // calculate the indexOffsets of each key in this node, within the sub-tree rooted at this node
1:5250d7f:             int[] indexOffsets = new int[keyLength + 1];
1:5250d7f:             int size = BTree.size((Object[]) a[keyLength]);
1:5250d7f:             for (int i = 0 ; i < keyLength ; i++)
1:5250d7f:             {
1:5250d7f:                 indexOffsets[i] = size;
1:5250d7f:                 size += 1 + BTree.size((Object[]) a[keyLength + 1 + i]);
1:5250d7f:             }
1:5250d7f:             indexOffsets[keyLength] = size;
1:5250d7f:             a[a.length - 1] = indexOffsets;
1:412b053:         }
1:5f82aa3:         if (isExtra)
1:5f82aa3:             updateFunction.allocated(ObjectSizes.sizeOfArray(a));
1:5f82aa3:         else if (a.length != copyFrom.length)
1:5f82aa3:             updateFunction.allocated(ObjectSizes.sizeOfArray(a) -
1:5f82aa3:                                      (copyFrom.length == 0 ? 0 : ObjectSizes.sizeOfArray(copyFrom)));
1:412b053:         return a;
1:4b54b8a:     }
1:412b053: 
1:412b053:     // checks if there is an initialised parent, and if not creates/initialises one and returns it.
1:412b053:     // different to ensureChild, as we initialise here instead of caller, as parents in general should
1:412b053:     // already be initialised, and only aren't in the case where we are overflowing the original root node
1:412b053:     private NodeBuilder ensureParent()
1:412b053:     {
1:412b053:         if (parent == null)
1:412b053:         {
1:412b053:             parent = new NodeBuilder();
1:412b053:             parent.child = this;
1:412b053:         }
1:412b053:         if (parent.upperBound == null)
1:4b54b8a:             parent.reset(EMPTY_BRANCH, upperBound, updateFunction, comparator);
1:412b053:         return parent;
1:412b053:     }
1:412b053: 
1:412b053:     // ensures a child level exists and returns it
1:412b053:     NodeBuilder ensureChild()
1:412b053:     {
1:412b053:         if (child == null)
1:412b053:         {
1:412b053:             child = new NodeBuilder();
1:412b053:             child.parent = this;
1:412b053:         }
1:412b053:         return child;
1:412b053:     }
1:412b053: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:79f230f
commit:82aa796
commit:986a1a7
/////////////////////////////////////////////////////////////////////////
1:                     // if not found, we need to apply updateFunction still, which is handled in addNewKey
1:                     addNewKey(key);
/////////////////////////////////////////////////////////////////////////
1:     // applies the updateFunction
1:     // puts the resulting key into the builder
1:     // splits the parent if necessary via ensureRoom
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
1:         // we permit building empty trees as some constructions do not know in advance how many items they will contain
1:         assert buildKeyPosition <= FAN_FACTOR : buildKeyPosition;
commit:5250d7f
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.utils.btree.BTree.*;
/////////////////////////////////////////////////////////////////////////
1:                 i = Arrays.binarySearch(copyFrom, i + 1, copyFromKeyEnd, key, comparator);
/////////////////////////////////////////////////////////////////////////
1:         else if (i == copyFromKeyEnd && compareUpperBound(comparator, key, upperBound) >= 0)
/////////////////////////////////////////////////////////////////////////
1:     private static <V> int compareUpperBound(Comparator<V> comparator, Object value, Object upperBound)
1:     {
1:         return upperBound == POSITIVE_INFINITY ? -1 : comparator.compare((V)value, (V)upperBound);
1:     }
/////////////////////////////////////////////////////////////////////////
0:         assert buildKeyPosition <= FAN_FACTOR && (buildKeyPosition > 0 || getKeyEnd(copyFrom) > 0) : buildKeyPosition;
/////////////////////////////////////////////////////////////////////////
1:             a = new Object[keyLength | 1];
1:             a = new Object[2 + (keyLength * 2)];
1: 
1:             // calculate the indexOffsets of each key in this node, within the sub-tree rooted at this node
1:             int[] indexOffsets = new int[keyLength + 1];
1:             int size = BTree.size((Object[]) a[keyLength]);
1:             for (int i = 0 ; i < keyLength ; i++)
1:             {
1:                 indexOffsets[i] = size;
1:                 size += 1 + BTree.size((Object[]) a[keyLength + 1 + i]);
1:             }
1:             indexOffsets[keyLength] = size;
1:             a[a.length - 1] = indexOffsets;
commit:5ab1d95
/////////////////////////////////////////////////////////////////////////
1:         boolean owns = true; // true if this node (or a child) should contain the key
/////////////////////////////////////////////////////////////////////////
0:                     // if not found, we still need to apply the update function
/////////////////////////////////////////////////////////////////////////
0:         buildKeys[buildKeyPosition++] = key;
commit:e77ea12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int c = -comparator.compare(key, copyFrom[i]);
/////////////////////////////////////////////////////////////////////////
0:         else if (i == copyFromKeyEnd && compare(comparator, key, upperBound) >= 0)
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
1:     NodeBuilder finish()
1:     {
1:         assert copyFrom != null;
1:         int copyFromKeyEnd = getKeyEnd(copyFrom);
1: 
1:         if (buildKeyPosition + buildChildPosition > 0)
1:         {
1:             // only want to copy if we've already changed something, otherwise we'll return the original
1:             copyKeys(copyFromKeyEnd);
1:             if (!isLeaf(copyFrom))
1:                 copyChildren(copyFromKeyEnd + 1);
1:         }
1:         return isRoot() ? null : ascend();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         int i = copyFromKeyPosition;
1:         boolean found; // exact key match?
1:         if (i == copyFromKeyEnd)
1:         {
1:             found = false;
1:         }
1:         else
1:         {
1:             // this optimisation is for the common scenario of updating an existing row with the same columns/keys
1:             // and simply avoids performing a binary search until we've checked the proceeding key;
1:             // possibly we should disable this check if we determine that it fails more than a handful of times
1:             // during any given builder use to get the best of both worlds
0:             int c = comparator.compare(copyFrom[i], key);
1:             if (c >= 0)
1:             {
1:                 found = c == 0;
1:             }
1:             else
1:             {
0:                 i = find(comparator, key, copyFrom, i + 1, copyFromKeyEnd);
1:                 found = i >= 0;
1:                 if (!found)
1:                     i = -i - 1;
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         else if (i == copyFromKeyEnd && compare(comparator, upperBound, key) <= 0)
1:             owns = false;
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:e6e596d
/////////////////////////////////////////////////////////////////////////
1:         while (current != null && current.upperBound != null)
1:             current.clearSelf();
1:         current = parent;
1:         while (current != null && current.upperBound != null)
1:         {
1:             current.clearSelf();
1:             current = current.parent;
1:         }
1:     }
1: 
1:     void clearSelf()
1:     {
1:         reset(null, null, null, null);
1:         Arrays.fill(buildKeys, 0, maxBuildKeyPosition, null);
1:         Arrays.fill(buildChildren, 0, maxBuildKeyPosition + 1, null);
1:         maxBuildKeyPosition = 0;
commit:0cb1e3d
/////////////////////////////////////////////////////////////////////////
1:         buildKeys[buildKeyPosition++] = updateFunction.apply(key);
commit:5f82aa3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 Arrays.fill(current.buildChildren, 0, current.maxBuildKeyPosition + 1, null);
0:                 current.maxBuildKeyPosition = 0;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (found)
1:         {
1:             Object prev = copyFrom[i];
1:             Object next = updateFunction.apply(prev, key);
1:             // we aren't actually replacing anything, so leave our state intact and continue
1:             if (prev == next)
1:                 return null;
1:             key = next;
1:         }
1:         else
/////////////////////////////////////////////////////////////////////////
1:                 // copy keys from the original node up to prior to the found index
1:                 copyKeys(i);
1: 
1:                 {
1:                     // if found, we've applied updateFunction already
1:                 }
1:                 {
0:                     // if not found, we need to apply updateFunction still
0:                     key = updateFunction.apply(key);
1:                 }
1:             else
1:             {
1:                 // we don't want to copy anything if we're ascending and haven't copied anything previously,
1:                 // as in this case we can return the original node. Leaving buildKeyPosition as 0 indicates
1:                 // to buildFromRange that it should return the original instead of building a new node
1:                 if (buildKeyPosition > 0)
1:                     copyKeys(i);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             else if (buildKeyPosition > 0 || buildChildPosition > 0)
1:                 // ensure we've copied all keys and children, but only if we've already copied something.
1:                 // otherwise we want to return the original node
/////////////////////////////////////////////////////////////////////////
0:         assert buildKeyPosition <= FAN_FACTOR && (buildKeyPosition > 0 || copyFrom.length > 0) : buildKeyPosition;
/////////////////////////////////////////////////////////////////////////
1:         if (len > 0)
1:         {
1:             System.arraycopy(copyFrom, copyFromKeyPosition, buildKeys, buildKeyPosition, len);
1:             copyFromKeyPosition = upToKeyPosition;
1:             buildKeyPosition += len;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (len > 0)
1:         {
1:             System.arraycopy(copyFrom, getKeyEnd(copyFrom) + copyFromChildPosition, buildChildren, buildChildPosition, len);
1:             copyFromChildPosition = upToChildPosition;
1:             buildChildPosition += len;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // if keyLength is 0, we didn't copy anything from the original, which means we didn't
1:         // modify any of the range owned by it, so can simply return it as is
1:         if (keyLength == 0)
1:             return copyFrom;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isExtra)
1:             updateFunction.allocated(ObjectSizes.sizeOfArray(a));
1:         else if (a.length != copyFrom.length)
1:             updateFunction.allocated(ObjectSizes.sizeOfArray(a) -
1:                                      (copyFrom.length == 0 ? 0 : ObjectSizes.sizeOfArray(copyFrom)));
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ObjectSizes;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private UpdateFunction updateFunction;
1:     private Comparator comparator;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 current.reset(null, null, null, null);
/////////////////////////////////////////////////////////////////////////
1:     void reset(Object[] copyFrom, Object upperBound, UpdateFunction updateFunction, Comparator comparator)
1:         this.updateFunction = updateFunction;
1:         this.comparator = comparator;
/////////////////////////////////////////////////////////////////////////
0:     <V> NodeBuilder update(Object key)
/////////////////////////////////////////////////////////////////////////
1:                     replaceNextKey(key);
0:                     addNewKey(key); // handles splitting parent if necessary via ensureRoom
/////////////////////////////////////////////////////////////////////////
1:                 replaceNextKey(key);
/////////////////////////////////////////////////////////////////////////
1:                 ensureChild().reset(descendInto, newUpperBound, updateFunction, comparator);
/////////////////////////////////////////////////////////////////////////
1:         return buildFromRange(0, buildKeyPosition, isLeaf(copyFrom), false);
/////////////////////////////////////////////////////////////////////////
1:             parent.addExtraChild(buildFromRange(0, mid, isLeaf, true), buildKeys[mid]);
1:             parent.finishChild(buildFromRange(mid + 1, buildKeyPosition - (mid + 1), isLeaf, false));
1:             parent.finishChild(buildFromRange(0, buildKeyPosition, isLeaf, false));
/////////////////////////////////////////////////////////////////////////
0:     private <V> void replaceNextKey(Object with)
0:         if (updateFunction != null)
0:             with = updateFunction.apply((V) copyFrom[copyFromKeyPosition], (V) with);
0:     <V> void addNewKey(Object key)
0:         if (updateFunction != null)
0:             key = updateFunction.apply((V) key);
/////////////////////////////////////////////////////////////////////////
1:         Object[] flushUp = buildFromRange(0, FAN_FACTOR, isLeaf(copyFrom), true);
/////////////////////////////////////////////////////////////////////////
1:     private Object[] buildFromRange(int offset, int keyLength, boolean isLeaf, boolean isExtra)
/////////////////////////////////////////////////////////////////////////
0:         if (updateFunction != null)
1:         {
0:             if (isExtra)
0:                 updateFunction.allocated(ObjectSizes.sizeOfArray(a));
0:             else if (a.length != copyFrom.length)
0:                 updateFunction.allocated(ObjectSizes.sizeOfArray(a) -
0:                         (copyFrom.length == 0 ? 0 : ObjectSizes.sizeOfArray(copyFrom)));
1:         }
/////////////////////////////////////////////////////////////////////////
1:             parent.reset(EMPTY_BRANCH, upperBound, updateFunction, comparator);
commit:412b053
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.utils.btree;
1: 
1: import java.util.Arrays;
1: import java.util.Comparator;
1: 
0: import static org.apache.cassandra.utils.btree.BTree.EMPTY_BRANCH;
0: import static org.apache.cassandra.utils.btree.BTree.FAN_FACTOR;
0: import static org.apache.cassandra.utils.btree.BTree.POSITIVE_INFINITY;
0: import static org.apache.cassandra.utils.btree.BTree.compare;
0: import static org.apache.cassandra.utils.btree.BTree.find;
0: import static org.apache.cassandra.utils.btree.BTree.getKeyEnd;
0: import static org.apache.cassandra.utils.btree.BTree.isLeaf;
1: 
1: /**
1:  * Represents a level / stack item of in progress modifications to a BTree.
1:  */
1: final class NodeBuilder
1: {
1:     private static final int MAX_KEYS = 1 + (FAN_FACTOR * 2);
1: 
1:     // parent stack
1:     private NodeBuilder parent, child;
1: 
1:     // buffer for building new nodes
1:     private Object[] buildKeys = new Object[MAX_KEYS];  // buffers keys for branches and leaves
1:     private Object[] buildChildren = new Object[1 + MAX_KEYS]; // buffers children for branches only
1:     private int buildKeyPosition;
1:     private int buildChildPosition;
1:     // we null out the contents of buildKeys/buildChildren when clear()ing them for re-use; this is where
1:     // we track how much we actually have to null out
1:     private int maxBuildKeyPosition;
0:     private int maxBuildChildPosition;
1: 
1:     // current node of the btree we're modifying/copying from
1:     private Object[] copyFrom;
1:     // the index of the first key in copyFrom that has not yet been copied into the build arrays
1:     private int copyFromKeyPosition;
1:     // the index of the first child node in copyFrom that has not yet been copied into the build arrays
1:     private int copyFromChildPosition;
1: 
1:     // upper bound of range owned by this level; lets us know if we need to ascend back up the tree
1:     // for the next key we update when bsearch gives an insertion point past the end of the values
1:     // in the current node
1:     private Object upperBound;
1: 
1:     // ensure we aren't referencing any garbage
1:     void clear()
1:     {
1:         NodeBuilder current = this;
0:         while (current != null)
1:         {
0:             if (current.upperBound != null)
1:             {
0:                 current.reset(null, null);
0:                 Arrays.fill(current.buildKeys, 0, current.maxBuildKeyPosition, null);
0:                 Arrays.fill(current.buildChildren, 0, current.maxBuildChildPosition, null);
0:                 current.maxBuildChildPosition = current.maxBuildKeyPosition = 0;
1:             }
1:             current = current.child;
1:         }
1:     }
1: 
1:     // reset counters/setup to copy from provided node
0:     void reset(Object[] copyFrom, Object upperBound)
1:     {
1:         this.copyFrom = copyFrom;
1:         this.upperBound = upperBound;
1:         maxBuildKeyPosition = Math.max(maxBuildKeyPosition, buildKeyPosition);
0:         maxBuildChildPosition = Math.max(maxBuildChildPosition, buildChildPosition);
1:         buildKeyPosition = 0;
1:         buildChildPosition = 0;
1:         copyFromKeyPosition = 0;
1:         copyFromChildPosition = 0;
1:     }
1: 
1:     /**
1:      * Inserts or replaces the provided key, copying all not-yet-visited keys prior to it into our buffer.
1:      *
1:      * @param key key we are inserting/replacing
1:      * @return the NodeBuilder to retry the update against (a child if we own the range being updated,
1:      * a parent if we do not -- we got here from an earlier key -- and we need to ascend back up),
1:      * or null if we finished the update in this node.
1:      */
0:     <V> NodeBuilder update(Object key, Comparator<V> comparator, ReplaceFunction<V> replaceF)
1:     {
1:         assert copyFrom != null;
1:         int copyFromKeyEnd = getKeyEnd(copyFrom);
1: 
0:         int i = find(comparator, (V) key, copyFrom, copyFromKeyPosition, copyFromKeyEnd);
0:         boolean found = i >= 0; // exact key match?
0:         boolean owns = true; // true iff this node (or a child) should contain the key
0:         if (!found)
1:         {
0:             i = -i - 1;
0:             if (i == copyFromKeyEnd && compare(comparator, upperBound, key) <= 0)
0:                 owns = false;
1:         }
1: 
1:         if (isLeaf(copyFrom))
1:         {
0:             // copy keys from the original node up to prior to the found index
1:             copyKeys(i);
1: 
1:             if (owns)
1:             {
1:                 if (found)
0:                     replaceNextKey(key, replaceF);
1:                 else
0:                     addNewKey(key, replaceF); // handles splitting parent if necessary via ensureRoom
1: 
1:                 // done, so return null
1:                 return null;
1:             }
1: 
1:             // if we don't own it, all we need to do is ensure we've copied everything in this node
1:             // (which we have done, since not owning means pos >= keyEnd), ascend, and let Modifier.update
1:             // retry against the parent node.  The if/ascend after the else branch takes care of that.
1:         }
1:         else
1:         {
1:             // branch
1:             if (found)
1:             {
1:                 copyKeys(i);
0:                 replaceNextKey(key, replaceF);
1:                 copyChildren(i + 1);
1:                 return null;
1:             }
1:             else if (owns)
1:             {
1:                 copyKeys(i);
1:                 copyChildren(i);
1: 
1:                 // belongs to the range owned by this node, but not equal to any key in the node
1:                 // so descend into the owning child
1:                 Object newUpperBound = i < copyFromKeyEnd ? copyFrom[i] : upperBound;
1:                 Object[] descendInto = (Object[]) copyFrom[copyFromKeyEnd + i];
0:                 ensureChild().reset(descendInto, newUpperBound);
1:                 return child;
1:             }
1:             else
1:             {
0:                 // ensure we've copied all keys and children
1:                 copyKeys(copyFromKeyEnd);
1:                 copyChildren(copyFromKeyEnd + 1); // since we know that there are exactly 1 more child nodes, than keys
1:             }
1:         }
1: 
0:         if (key == POSITIVE_INFINITY && isRoot())
1:             return null;
1: 
1:         return ascend();
1:     }
1: 
1: 
1:     // UTILITY METHODS FOR IMPLEMENTATION OF UPDATE/BUILD/DELETE
1: 
1:     boolean isRoot()
1:     {
1:         // if parent == null, or parent.upperBound == null, then we have not initialised a parent builder,
1:         // so we are the top level builder holding modifications; if we have more than FAN_FACTOR items, though,
1:         // we are not a valid root so we would need to spill-up to create a new root
1:         return (parent == null || parent.upperBound == null) && buildKeyPosition <= FAN_FACTOR;
1:     }
1: 
1:     // ascend to the root node, splitting into proper node sizes as we go; useful for building
1:     // where we work only on the newest child node, which may construct many spill-over parents as it goes
1:     NodeBuilder ascendToRoot()
1:     {
1:         NodeBuilder current = this;
1:         while (!current.isRoot())
1:             current = current.ascend();
1:         return current;
1:     }
1: 
1:     // builds a new root BTree node - must be called on root of operation
1:     Object[] toNode()
1:     {
0:         assert buildKeyPosition <= FAN_FACTOR && buildKeyPosition > 0 : buildKeyPosition;
0:         return buildFromRange(0, buildKeyPosition, isLeaf(copyFrom));
1:     }
1: 
1:     // finish up this level and pass any constructed children up to our parent, ensuring a parent exists
1:     private NodeBuilder ascend()
1:     {
1:         ensureParent();
1:         boolean isLeaf = isLeaf(copyFrom);
1:         if (buildKeyPosition > FAN_FACTOR)
1:         {
1:             // split current node and move the midpoint into parent, with the two halves as children
1:             int mid = buildKeyPosition / 2;
0:             parent.addExtraChild(buildFromRange(0, mid, isLeaf), buildKeys[mid]);
0:             parent.finishChild(buildFromRange(mid + 1, buildKeyPosition - (mid + 1), isLeaf));
1:         }
1:         else
1:         {
0:             parent.finishChild(buildFromRange(0, buildKeyPosition, isLeaf));
1:         }
1:         return parent;
1:     }
1: 
1:     // copy keys from copyf to the builder, up to the provided index in copyf (exclusive)
1:     private void copyKeys(int upToKeyPosition)
1:     {
1:         if (copyFromKeyPosition >= upToKeyPosition)
1:             return;
1: 
1:         int len = upToKeyPosition - copyFromKeyPosition;
1:         assert len <= FAN_FACTOR : upToKeyPosition + "," + copyFromKeyPosition;
1: 
1:         ensureRoom(buildKeyPosition + len);
0:         System.arraycopy(copyFrom, copyFromKeyPosition, buildKeys, buildKeyPosition, len);
0:         copyFromKeyPosition = upToKeyPosition;
0:         buildKeyPosition += len;
1:     }
1: 
1:     // skips the next key in copyf, and puts the provided key in the builder instead
0:     private <V> void replaceNextKey(Object with, ReplaceFunction<V> replaceF)
1:     {
1:         // (this first part differs from addNewKey in that we pass the replaced object to replaceF as well)
1:         ensureRoom(buildKeyPosition + 1);
0:         if (replaceF != null)
0:             with = replaceF.apply((V) copyFrom[copyFromKeyPosition], (V) with);
1:         buildKeys[buildKeyPosition++] = with;
1: 
1:         copyFromKeyPosition++;
1:     }
1: 
0:     // puts the provided key in the builder, with no impact on treatment of data from copyf
0:     <V> void addNewKey(Object key, ReplaceFunction<V> replaceF)
1:     {
1:         ensureRoom(buildKeyPosition + 1);
0:         if (replaceF != null)
0:             key = replaceF.apply(null, (V) key);
0:         buildKeys[buildKeyPosition++] = key;
1:     }
1: 
1:     // copies children from copyf to the builder, up to the provided index in copyf (exclusive)
1:     private void copyChildren(int upToChildPosition)
1:     {
1:         // (ensureRoom isn't called here, as we should always be at/behind key additions)
1:         if (copyFromChildPosition >= upToChildPosition)
1:             return;
1:         int len = upToChildPosition - copyFromChildPosition;
0:         System.arraycopy(copyFrom, getKeyEnd(copyFrom) + copyFromChildPosition, buildChildren, buildChildPosition, len);
0:         copyFromChildPosition = upToChildPosition;
0:         buildChildPosition += len;
1:     }
1: 
1:     // adds a new and unexpected child to the builder - called by children that overflow
1:     private void addExtraChild(Object[] child, Object upperBound)
1:     {
1:         ensureRoom(buildKeyPosition + 1);
1:         buildKeys[buildKeyPosition++] = upperBound;
1:         buildChildren[buildChildPosition++] = child;
1:     }
1: 
1:     // adds a replacement expected child to the builder - called by children prior to ascending
1:     private void finishChild(Object[] child)
1:     {
1:         buildChildren[buildChildPosition++] = child;
1:         copyFromChildPosition++;
1:     }
1: 
1:     // checks if we can add the requested keys+children to the builder, and if not we spill-over into our parent
1:     private void ensureRoom(int nextBuildKeyPosition)
1:     {
1:         if (nextBuildKeyPosition < MAX_KEYS)
1:             return;
1: 
1:         // flush even number of items so we don't waste leaf space repeatedly
0:         Object[] flushUp = buildFromRange(0, FAN_FACTOR, isLeaf(copyFrom));
1:         ensureParent().addExtraChild(flushUp, buildKeys[FAN_FACTOR]);
1:         int size = FAN_FACTOR + 1;
1:         assert size <= buildKeyPosition : buildKeyPosition + "," + nextBuildKeyPosition;
1:         System.arraycopy(buildKeys, size, buildKeys, 0, buildKeyPosition - size);
1:         buildKeyPosition -= size;
1:         maxBuildKeyPosition = buildKeys.length;
1:         if (buildChildPosition > 0)
1:         {
1:             System.arraycopy(buildChildren, size, buildChildren, 0, buildChildPosition - size);
1:             buildChildPosition -= size;
0:             maxBuildChildPosition = buildChildren.length;
1:         }
1:     }
1: 
1:     // builds and returns a node from the buffered objects in the given range
0:     private Object[] buildFromRange(int offset, int keyLength, boolean isLeaf)
1:     {
1:         Object[] a;
1:         if (isLeaf)
1:         {
0:             a = new Object[keyLength + (keyLength & 1)];
1:             System.arraycopy(buildKeys, offset, a, 0, keyLength);
1:         }
1:         else
1:         {
0:             a = new Object[1 + (keyLength * 2)];
1:             System.arraycopy(buildKeys, offset, a, 0, keyLength);
1:             System.arraycopy(buildChildren, offset, a, keyLength, keyLength + 1);
1:         }
1:         return a;
1:     }
1: 
1:     // checks if there is an initialised parent, and if not creates/initialises one and returns it.
1:     // different to ensureChild, as we initialise here instead of caller, as parents in general should
1:     // already be initialised, and only aren't in the case where we are overflowing the original root node
1:     private NodeBuilder ensureParent()
1:     {
1:         if (parent == null)
1:         {
1:             parent = new NodeBuilder();
1:             parent.child = this;
1:         }
1:         if (parent.upperBound == null)
0:             parent.reset(EMPTY_BRANCH, upperBound);
1:         return parent;
1:     }
1: 
1:     // ensures a child level exists and returns it
1:     NodeBuilder ensureChild()
1:     {
1:         if (child == null)
1:         {
1:             child = new NodeBuilder();
1:             child.parent = this;
1:         }
1:         return child;
1:     }
1: }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
commit:2fd2d89
/////////////////////////////////////////////////////////////////////////
0:             key = replaceF.apply((V) key);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:72507b7
/////////////////////////////////////////////////////////////////////////
1:     NodeBuilder update(Object key)
0:         int i = find(comparator, key, copyFrom, copyFromKeyPosition, copyFromKeyEnd);
/////////////////////////////////////////////////////////////////////////
1:     private void replaceNextKey(Object with)
0:             with = updateFunction.apply(copyFrom[copyFromKeyPosition], with);
1:     void addNewKey(Object key)
0:             key = updateFunction.apply(key);
============================================================================