1:720c49a: /*
1:720c49a: * Licensed to the Apache Software Foundation (ASF) under one
1:720c49a: * or more contributor license agreements.  See the NOTICE file
1:720c49a: * distributed with this work for additional information
1:720c49a: * regarding copyright ownership.  The ASF licenses this file
1:720c49a: * to you under the Apache License, Version 2.0 (the
1:720c49a: * "License"); you may not use this file except in compliance
1:720c49a: * with the License.  You may obtain a copy of the License at
1:720c49a: *
1:720c49a: *    http://www.apache.org/licenses/LICENSE-2.0
1:720c49a: *
1:720c49a: * Unless required by applicable law or agreed to in writing,
1:720c49a: * software distributed under the License is distributed on an
1:720c49a: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:720c49a: * KIND, either express or implied.  See the License for the
1:720c49a: * specific language governing permissions and limitations
1:720c49a: * under the License.
2:720c49a: */
58:720c49a: 
1:720c49a: package org.apache.cassandra.service;
1:0789a58: 
1:720c49a: import java.net.InetAddress;
1:720c49a: import java.net.UnknownHostException;
1:d8755b3: import java.util.*;
1:d8755b3: 
1:3577fd8: import com.google.common.collect.HashMultimap;
1:3577fd8: import com.google.common.collect.Multimap;
1:438acfc: import org.junit.AfterClass;
1:ae03e1b: import org.junit.Before;
1:438acfc: import org.junit.BeforeClass;
1:438acfc: import org.junit.Test;
1:438acfc: 
1:9c1679d: import org.apache.cassandra.config.CFMetaData;
1:9c1679d: import org.apache.cassandra.config.DatabaseDescriptor;
1:9c1679d: import org.apache.cassandra.db.marshal.BytesType;
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:ba2cead: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.Schema;
1:a991b64: import org.apache.cassandra.dht.IPartitioner;
1:a991b64: import org.apache.cassandra.dht.RandomPartitioner;
1:07893d7: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:a991b64: import org.apache.cassandra.dht.Range;
1:a991b64: import org.apache.cassandra.dht.Token;
1:a991b64: import org.apache.cassandra.exceptions.ConfigurationException;
1:d8755b3: import org.apache.cassandra.gms.ApplicationState;
1:a991b64: import org.apache.cassandra.gms.Gossiper;
1:9c1679d: import org.apache.cassandra.locator.AbstractNetworkTopologySnitch;
1:9c1679d: import org.apache.cassandra.locator.NetworkTopologyStrategy;
1:9c1679d: import org.apache.cassandra.locator.PendingRangeMaps;
1:89fbc1b: import org.apache.cassandra.gms.VersionedValue;
1:720c49a: import org.apache.cassandra.locator.AbstractReplicationStrategy;
1:d8755b3: import org.apache.cassandra.locator.SimpleSnitch;
1:720c49a: import org.apache.cassandra.locator.TokenMetadata;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:9c1679d: import org.apache.cassandra.schema.KeyspaceParams;
1:9c1679d: import org.apache.cassandra.schema.Tables;
1:720c49a: 
1:a991b64: import static org.junit.Assert.assertEquals;
1:a991b64: import static org.junit.Assert.assertTrue;
1:9c1679d: import static org.junit.Assert.assertNotNull;
1:a991b64: 
1:438acfc: public class MoveTest
1:720c49a: {
1:07893d7:     private static final IPartitioner partitioner = RandomPartitioner.instance;
1:438acfc:     private static IPartitioner oldPartitioner;
1:9c1679d:     //Simple Strategy Keyspaces
1:9c1679d:     private static final String Simple_RF1_KeyspaceName = "MoveTestKeyspace1";
1:9c1679d:     private static final String Simple_RF2_KeyspaceName = "MoveTestKeyspace5";
1:9c1679d:     private static final String Simple_RF3_KeyspaceName = "MoveTestKeyspace4";
1:d2a3827:     private static final String KEYSPACE2 = "MoveTestKeyspace2";
1:d2a3827:     private static final String KEYSPACE3 = "MoveTestKeyspace3";
1:9c1679d: 
1:9c1679d:     //Network Strategy Keyspace with RF DC1=1 and DC2=1 and so on.
1:9c1679d:     private static final String Network_11_KeyspaceName = "MoveTestNetwork11";
1:9c1679d:     private static final String Network_22_KeyspaceName = "MoveTestNetwork22";
1:9c1679d:     private static final String Network_33_KeyspaceName = "MoveTestNetwork33";
1:438acfc: 
1:438acfc:     /*
1:438acfc:      * NOTE: the tests above uses RandomPartitioner, which is not the default
1:438acfc:      * test partitioner. Changing the partitioner should be done before
1:438acfc:      * loading the schema as loading the schema trigger the write of sstables.
1:438acfc:      * So instead of extending SchemaLoader, we call it's method below.
1:438acfc:      */
1:438acfc:     @BeforeClass
1:f2c5ad7:     public static void setup() throws Exception
1:438acfc:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:438acfc:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(partitioner);
1:438acfc:         SchemaLoader.loadSchema();
1:d2a3827:         SchemaLoader.schemaDefinition("MoveTest");
1:9c1679d:         addNetworkTopologyKeyspace(Network_11_KeyspaceName, 1, 1);
1:9c1679d:         addNetworkTopologyKeyspace(Network_22_KeyspaceName, 2, 2);
1:9c1679d:         addNetworkTopologyKeyspace(Network_33_KeyspaceName, 3, 3);
1:438acfc:     }
1:438acfc: 
1:438acfc:     @AfterClass
1:438acfc:     public static void tearDown()
1:438acfc:     {
1:438acfc:         StorageService.instance.setPartitionerUnsafe(oldPartitioner);
1:438acfc:     }
1:438acfc: 
1:ae03e1b:     @Before
1:ae03e1b:     public void clearTokenMetadata()
1:ae03e1b:     {
1:ae03e1b:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:ae03e1b:         StorageService.instance.getTokenMetadata().clearUnsafe();
1:ae03e1b:     }
1:9c1679d: 
1:f2c5ad7:     private static void addNetworkTopologyKeyspace(String keyspaceName, Integer... replicas) throws Exception
1:9c1679d:     {
1:ae03e1b: 
1:9c1679d:         DatabaseDescriptor.setEndpointSnitch(new AbstractNetworkTopologySnitch()
1:9c1679d:         {
1:9c1679d:             //Odd IPs are in DC1 and Even are in DC2. Endpoints upto .14 will have unique racks and
1:9c1679d:             // then will be same for a set of three.
1:9c1679d:             @Override
1:9c1679d:             public String getRack(InetAddress endpoint)
1:9c1679d:             {
1:9c1679d:                 int ipLastPart = getIPLastPart(endpoint);
1:9c1679d:                 if (ipLastPart <= 14)
1:9c1679d:                     return UUID.randomUUID().toString();
1:9c1679d:                 else
1:9c1679d:                     return "RAC" + (ipLastPart % 3);
1:9c1679d:             }
1:9c1679d: 
1:9c1679d:             @Override
1:9c1679d:             public String getDatacenter(InetAddress endpoint)
1:9c1679d:             {
1:9c1679d:                 if (getIPLastPart(endpoint) % 2 == 0)
1:9c1679d:                     return "DC2";
1:9c1679d:                 else
1:9c1679d:                     return "DC1";
1:9c1679d:             }
1:9c1679d: 
1:9c1679d:             private int getIPLastPart(InetAddress endpoint)
1:9c1679d:             {
1:9c1679d:                 String str = endpoint.toString();
1:9c1679d:                 int index = str.lastIndexOf(".");
1:9c1679d:                 return Integer.parseInt(str.substring(index + 1).trim());
1:9c1679d:             }
1:9c1679d:         });
1:9c1679d: 
1:f2c5ad7:         final TokenMetadata tmd = StorageService.instance.getTokenMetadata();
1:f2c5ad7:                 tmd.clearUnsafe();
1:f2c5ad7:                 tmd.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.0.0.1"));
1:f2c5ad7:                 tmd.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.0.0.2"));
1:f2c5ad7: 
1:9c1679d:         KeyspaceMetadata keyspace =  KeyspaceMetadata.create(keyspaceName,
1:9c1679d:                                                              KeyspaceParams.nts(configOptions(replicas)),
1:9c1679d:                                                              Tables.of(CFMetaData.Builder.create(keyspaceName, "CF1")
1:9c1679d:                                                                                          .addPartitionKey("key", BytesType.instance).build()));
1:9c1679d:         MigrationManager.announceNewKeyspace(keyspace);
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private static Object[] configOptions(Integer[] replicas)
1:9c1679d:     {
1:9c1679d:         Object[] configOptions = new Object[(replicas.length * 2)];
1:9c1679d:         int i = 1, j=0;
1:9c1679d:         for(Integer replica : replicas)
1:9c1679d:         {
1:9c1679d:             if(replica == null)
1:9c1679d:                 continue;
1:9c1679d:             configOptions[j++] = "DC" + i++;
1:9c1679d:             configOptions[j++] = replica;
1:9c1679d:         }
1:9c1679d:         return configOptions;
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     @Test
1:9c1679d:     public void testMoveWithPendingRangesNetworkStrategyRackAwareThirtyNodes() throws Exception
1:9c1679d:     {
1:9c1679d:         StorageService ss = StorageService.instance;
1:9c1679d:         final int RING_SIZE = 60;
1:9c1679d: 
1:9c1679d:         TokenMetadata tmd = ss.getTokenMetadata();
1:9c1679d:         tmd.clearUnsafe();
1:9c1679d:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:9c1679d:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:9c1679d:         ArrayList<Token> keyTokens = new ArrayList<>();
1:9c1679d:         List<InetAddress> hosts = new ArrayList<>();
1:9c1679d:         List<UUID> hostIds = new ArrayList<>();
1:9c1679d: 
1:9c1679d:         for(int i=0; i < RING_SIZE/2; i++)
1:9c1679d:         {
1:9c1679d:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:9c1679d:             endpointTokens.add(new BigIntegerToken(String.valueOf((10 * i) + 1)));
1:9c1679d:         }
1:9c1679d:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:9c1679d:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:9c1679d: 
1:9c1679d:         //Moving Endpoint 127.0.0.37 in RAC1 with current token 180
1:9c1679d:         int MOVING_NODE = 36;
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 215, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(150, 151, "127.0.0.43"),
1:9c1679d:                 generatePendingMapEntry(151, 160, "127.0.0.43"),generatePendingMapEntry(160, 161, "127.0.0.43"),
1:9c1679d:                 generatePendingMapEntry(161, 170, "127.0.0.43"), generatePendingMapEntry(170, 171, "127.0.0.43"),
1:9c1679d:                 generatePendingMapEntry(171, 180, "127.0.0.43"), generatePendingMapEntry(210, 211, "127.0.0.37"),
1:9c1679d:                 generatePendingMapEntry(211, 215, "127.0.0.37")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 215, tmd);
1:9c1679d: 
1:9c1679d:         //Moving it back to original spot
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 180, tmd, valueFactory);
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 180, tmd);
1:9c1679d: 
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     @Test
1:9c1679d:     public void testMoveWithPendingRangesNetworkStrategyTenNode() throws Exception
1:9c1679d:     {
1:9c1679d:         StorageService ss = StorageService.instance;
1:9c1679d:         final int RING_SIZE = 14;
1:9c1679d: 
1:9c1679d:         TokenMetadata tmd = ss.getTokenMetadata();
1:9c1679d:         tmd.clearUnsafe();
1:9c1679d:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:9c1679d:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:9c1679d:         ArrayList<Token> keyTokens = new ArrayList<>();
1:9c1679d:         List<InetAddress> hosts = new ArrayList<>();
1:9c1679d:         List<UUID> hostIds = new ArrayList<>();
1:9c1679d: 
1:9c1679d:         for(int i=0; i < RING_SIZE/2; i++)
1:9c1679d:         {
1:9c1679d:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:9c1679d:             endpointTokens.add(new BigIntegerToken(String.valueOf((10 * i) + 1)));
1:9c1679d:         }
1:9c1679d: 
1:9c1679d:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:9c1679d:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:9c1679d: 
1:9c1679d:         int MOVING_NODE = 0;
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 5, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 5, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.3"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.3")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.5"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.5")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.7"),
1:9c1679d:                 generatePendingMapEntry(1, 5, "127.0.0.7")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         MOVING_NODE = 1;
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 5, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 5, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 1, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.4")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.6")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.8")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 1, tmd);
1:9c1679d: 
1:9c1679d:         MOVING_NODE = 3;
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 25, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 10, "127.0.0.6"),
1:9c1679d:                 generatePendingMapEntry(10, 11, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(61, 0, "127.0.0.6"),
1:9c1679d:                 generatePendingMapEntry(0, 1, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(11, 20, "127.0.0.4"),generatePendingMapEntry(20, 21, "127.0.0.4")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(51, 60, "127.0.0.6"),
1:9c1679d:                 generatePendingMapEntry(60, 61, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(11, 20, "127.0.0.4"), generatePendingMapEntry(20, 21, "127.0.0.4")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 25, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 11, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 10, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(10, 11, "127.0.0.4"), generatePendingMapEntry(21, 25, "127.0.0.8")), Network_11_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(61, 0, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(0, 1, "127.0.0.4"), generatePendingMapEntry(11, 20, "127.0.0.8"),
1:9c1679d:                 generatePendingMapEntry(20, 21, "127.0.0.8"), generatePendingMapEntry(21, 25, "127.0.0.10")), Network_22_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(51, 60, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(60, 61, "127.0.0.4"), generatePendingMapEntry(21, 25, "127.0.0.12"),
1:9c1679d:                 generatePendingMapEntry(11, 20, "127.0.0.10"), generatePendingMapEntry(20, 21, "127.0.0.10")), Network_33_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 11, tmd);
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     @Test
1:9c1679d:     public void testMoveWithPendingRangesSimpleStrategyTenNode() throws Exception
1:9c1679d:     {
1:9c1679d:         StorageService ss = StorageService.instance;
1:9c1679d:         final int RING_SIZE = 10;
1:9c1679d: 
1:9c1679d:         TokenMetadata tmd = ss.getTokenMetadata();
1:9c1679d:         tmd.clearUnsafe();
1:9c1679d:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:9c1679d:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:9c1679d:         ArrayList<Token> keyTokens = new ArrayList<>();
1:9c1679d:         List<InetAddress> hosts = new ArrayList<>();
1:9c1679d:         List<UUID> hostIds = new ArrayList<>();
1:9c1679d: 
1:9c1679d:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:9c1679d:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:9c1679d: 
1:9c1679d:         final int MOVING_NODE = 0; // index of the moving node
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 2, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 2, tmd);
1:9c1679d: 
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 1000, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 1000, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 35, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(90, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(20, 30, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(80, 90, "127.0.0.2"), generatePendingMapEntry(90, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(20, 30, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(80, 90, "127.0.0.3"), generatePendingMapEntry(90, 0, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(10, 20, "127.0.0.1"), generatePendingMapEntry(70, 80, "127.0.0.2")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 35, tmd);
1:9c1679d: 
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     @Test
1:9c1679d:     public void testMoveWithPendingRangesForSimpleStrategyFourNode() throws Exception
1:9c1679d:     {
1:9c1679d:         StorageService ss = StorageService.instance;
1:9c1679d:         final int RING_SIZE = 4;
1:9c1679d: 
1:9c1679d:         TokenMetadata tmd = ss.getTokenMetadata();
1:9c1679d:         tmd.clearUnsafe();
1:9c1679d:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:9c1679d:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:9c1679d:         ArrayList<Token> keyTokens = new ArrayList<>();
1:9c1679d:         List<InetAddress> hosts = new ArrayList<>();
1:9c1679d:         List<UUID> hostIds = new ArrayList<>();
1:9c1679d: 
1:9c1679d:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:9c1679d:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:9c1679d: 
1:9c1679d:         int MOVING_NODE = 0; // index of the moving node
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 2, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 2, tmd);
1:9c1679d: 
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 1500, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 1500, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 15, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(10, 15, "127.0.0.1"), generatePendingMapEntry(30, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 30, "127.0.0.2"), generatePendingMapEntry(10, 15, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(0, 10, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(15, 20, "127.0.0.2"),
1:9c1679d:                 generatePendingMapEntry(0, 10, "127.0.0.1")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 15, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 0, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(10, 15, "127.0.0.3")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 30, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(10, 15, "127.0.0.4"), generatePendingMapEntry(0, 10, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(15, 20, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(0, 10, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 26, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 26, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(30, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(26, 30, "127.0.0.2"),
1:9c1679d:                 generatePendingMapEntry(30, 0, "127.0.0.3"), generatePendingMapEntry(10, 20, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 10, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(26, 30, "127.0.0.3")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 26, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 26, "127.0.0.4"),
1:9c1679d:                 generatePendingMapEntry(30, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 0, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(26, 30, "127.0.0.1"), generatePendingMapEntry(10, 20, "127.0.0.4")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(26, 30, "127.0.0.1"),
1:9c1679d:                 generatePendingMapEntry(0, 10, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1:9c1679d: 
1:9c1679d:         MOVING_NODE = 3;
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 33, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 33, tmd);
1:9c1679d: 
1:9c1679d:         moveHost(hosts.get(MOVING_NODE), 30, tmd, valueFactory);
1:9c1679d: 
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.2")), Simple_RF2_KeyspaceName);
1:9c1679d:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.3")), Simple_RF3_KeyspaceName);
1:9c1679d: 
1:9c1679d:         finishMove(hosts.get(MOVING_NODE), 30, tmd);
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private void moveHost(InetAddress host, int token, TokenMetadata tmd, VersionedValue.VersionedValueFactory valueFactory )
1:9c1679d:     {
1:9c1679d:         StorageService.instance.onChange(host, ApplicationState.STATUS, valueFactory.moving(new BigIntegerToken(String.valueOf(token))));
1:9c1679d:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:9c1679d:         assertTrue(tmd.isMoving(host));
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private void finishMove(InetAddress host, int token, TokenMetadata tmd)
1:9c1679d:     {
1:9c1679d:         tmd.removeFromMoving(host);
1:9c1679d:         assertTrue(!tmd.isMoving(host));
1:9c1679d:         tmd.updateNormalToken(new BigIntegerToken(String.valueOf(token)), host);
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private Map.Entry<Range<Token>, Collection<InetAddress>> generatePendingMapEntry(int start, int end, String... endpoints) throws UnknownHostException
1:9c1679d:     {
1:9c1679d:         Map<Range<Token>, Collection<InetAddress>> pendingRanges = new HashMap<>();
1:9c1679d:         pendingRanges.put(generateRange(start, end), makeAddrs(endpoints));
1:9c1679d:         return pendingRanges.entrySet().iterator().next();
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private Map<Range<Token>, Collection<InetAddress>> generatePendingRanges(Map.Entry<Range<Token>, Collection<InetAddress>>... entries)
1:9c1679d:     {
1:9c1679d:         Map<Range<Token>, Collection<InetAddress>> pendingRanges = new HashMap<>();
1:9c1679d:         for(Map.Entry<Range<Token>, Collection<InetAddress>> entry : entries)
1:9c1679d:         {
1:9c1679d:             pendingRanges.put(entry.getKey(), entry.getValue());
1:9c1679d:         }
1:9c1679d:         return pendingRanges;
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private void assertPendingRanges(TokenMetadata tmd, Map<Range<Token>,  Collection<InetAddress>> pendingRanges, String keyspaceName) throws ConfigurationException
1:9c1679d:     {
1:9c1679d:         boolean keyspaceFound = false;
1:a4e1182:         for (String nonSystemKeyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:9c1679d:         {
1:9c1679d:             if(!keyspaceName.equals(nonSystemKeyspaceName))
1:9c1679d:                 continue;
1:9c1679d:             assertMaps(pendingRanges, tmd.getPendingRanges(keyspaceName));
1:9c1679d:             keyspaceFound = true;
1:9c1679d:         }
1:9c1679d: 
1:9c1679d:         assert keyspaceFound;
1:9c1679d:     }
1:9c1679d: 
1:9c1679d:     private void assertMaps(Map<Range<Token>, Collection<InetAddress>> expected, PendingRangeMaps actual)
1:9c1679d:     {
1:9c1679d:         int sizeOfActual = 0;
1:9c1679d:         Iterator<Map.Entry<Range<Token>, List<InetAddress>>> iterator = actual.iterator();
1:9c1679d:         while(iterator.hasNext())
1:9c1679d:         {
1:9c1679d:             Map.Entry<Range<Token>, List<InetAddress>> actualEntry = iterator.next();
1:9c1679d:             assertNotNull(expected.get(actualEntry.getKey()));
1:9c1679d:             assertEquals(new HashSet<>(expected.get(actualEntry.getKey())), new HashSet<>(actualEntry.getValue()));
1:9c1679d:             sizeOfActual++;
1:9c1679d:         }
1:9c1679d: 
1:9c1679d:         assertEquals(expected.size(), sizeOfActual);
1:9c1679d:     }
1:9c1679d: 
1:133acbb:     /*
1:133acbb:      * Test whether write endpoints is correct when the node is moving. Uses
1:720c49a:      * StorageService.onChange and does not manipulate token metadata directly.
1:720c49a:      */
4:720c49a:     @Test
1:133acbb:     public void newTestWriteEndpointsDuringMove() throws Exception
1:720c49a:     {
1:a2e2c03:         StorageService ss = StorageService.instance;
1:133acbb:         final int RING_SIZE = 10;
1:133acbb:         final int MOVING_NODE = 3; // index of the moving node
1:720c49a: 
4:720c49a:         TokenMetadata tmd = ss.getTokenMetadata();
1:89fbc1b:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:720c49a: 
1:18b2a16:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
4:720c49a:         ArrayList<Token> keyTokens = new ArrayList<Token>();
4:720c49a:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:720c49a: 
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:720c49a: 
1:df8a933:         Map<Token, List<InetAddress>> expectedEndpoints = new HashMap<Token, List<InetAddress>>();
1:133acbb:         for (Token token : keyTokens)
1:0789a58:         {
1:0789a58:             List<InetAddress> endpoints = new ArrayList<InetAddress>();
1:389bac7:             Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token, false);
1:0789a58:             while (tokenIter.hasNext())
1:0789a58:             {
1:0789a58:                 endpoints.add(tmd.getEndpoint(tokenIter.next()));
1:0789a58:             }
1:e1206f3:             expectedEndpoints.put(token, endpoints);
1:0789a58:         }
1:0789a58: 
1:133acbb:         // node LEAVING_NODE should move to this token
1:133acbb:         Token newToken = positionToken(MOVING_NODE);
1:133acbb: 
1:720c49a:         // Third node leaves
1:133acbb:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.moving(newToken));
1:d8c4e89:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:133acbb: 
1:133acbb:         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
1:720c49a: 
1:df8a933:         AbstractReplicationStrategy strategy;
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:720c49a:         {
1:0e96e58:             strategy = getStrategy(keyspaceName, tmd);
1:9c1679d:             if(strategy instanceof NetworkTopologyStrategy)
1:9c1679d:                 continue;
1:e1206f3:             int numMoved = 0;
1:0789a58:             for (Token token : keyTokens)
1:720c49a:             {
1:2f5f0c2:                 int replicationFactor = strategy.getReplicationFactor();
1:720c49a: 
1:0e96e58:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, keyspaceName, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
1:0789a58:                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
1:0789a58: 
1:0789a58:                 for (int i = 0; i < replicationFactor; i++)
1:0789a58:                 {
1:df8a933:                     expected.add(expectedEndpoints.get(token).get(i));
1:0789a58:                 }
1:0789a58: 
1:e1206f3:                 if (expected.size() == actual.size()) {
1:0789a58:                 	assertEquals("mismatched endpoint sets", expected, actual);
1:e1206f3:                 } else {
1:e1206f3:                 	expected.add(hosts.get(MOVING_NODE));
2:e1206f3:                 	assertEquals("mismatched endpoint sets", expected, actual);
1:e1206f3:                 	numMoved++;
1:720c49a:                 }
1:720c49a:             }
1:ae03e1b:             assertEquals("mismatched number of moved token", 1, numMoved);
1:720c49a:         }
1:720c49a: 
1:133acbb:         // moving endpoint back to the normal state
1:b475bc6:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
1:e1206f3:     }
1:720c49a: 
1:133acbb:     /*
1:133acbb:      * Test ranges and write endpoints when multiple nodes are on the move simultaneously
1:720c49a:      */
1:720c49a:     @Test
1:9639f95:     public void testSimultaneousMove() throws UnknownHostException
1:720c49a:     {
1:a2e2c03:         StorageService ss = StorageService.instance;
1:3577fd8:         final int RING_SIZE = 10;
1:720c49a:         TokenMetadata tmd = ss.getTokenMetadata();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:89fbc1b:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:720c49a: 
1:18b2a16:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:720c49a:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:720c49a:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:720c49a: 
1:720c49a:         // create a ring or 10 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:720c49a: 
1:720c49a:         // nodes 6, 8 and 9 leave
1:133acbb:         final int[] MOVING = new int[] {6, 8, 9};
1:133acbb: 
1:133acbb:         Map<Integer, Token> newTokens = new HashMap<Integer, Token>();
1:133acbb: 
1:133acbb:         for (int movingIndex : MOVING)
1:133acbb:         {
1:133acbb:             Token newToken = positionToken(movingIndex);
1:133acbb:             ss.onChange(hosts.get(movingIndex), ApplicationState.STATUS, valueFactory.moving(newToken));
1:133acbb: 
1:133acbb:             // storing token associated with a node index
1:133acbb:             newTokens.put(movingIndex, newToken);
1:133acbb:         }
1:133acbb: 
1:133acbb:         Collection<InetAddress> endpoints;
1:133acbb: 
1:133acbb:         tmd = tmd.cloneAfterAllSettled();
1:133acbb:         ss.setTokenMetadataUnsafe(tmd);
1:720c49a: 
1:720c49a:         // boot two new nodes with keyTokens.get(5) and keyTokens.get(7)
1:720c49a:         InetAddress boot1 = InetAddress.getByName("127.0.1.1");
1:b475bc6:         Gossiper.instance.initializeNodeUnsafe(boot1, UUID.randomUUID(), 1);
1:b475bc6:         Gossiper.instance.injectApplicationState(boot1, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(5))));
1:66b96ee:         ss.onChange(boot1,
1:89fbc1b:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5))));
1:ae03e1b:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:ae03e1b: 
1:720c49a:         InetAddress boot2 = InetAddress.getByName("127.0.1.2");
1:b475bc6:         Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
1:b475bc6:         Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
1:66b96ee:         ss.onChange(boot2,
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
1:d8c4e89:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:720c49a: 
1:133acbb:         // don't require test update every time a new keyspace is added to test/conf/cassandra.yaml
1:0e96e58:         Map<String, AbstractReplicationStrategy> keyspaceStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
1:133acbb:         for (int i = 1; i <= 4; i++)
1:720c49a:         {
1:d2a3827:             keyspaceStrategyMap.put("MoveTestKeyspace" + i, getStrategy("MoveTestKeyspace" + i, tmd));
1:720c49a:         }
1:720c49a: 
1:133acbb:        /**
1:133acbb:         *  Keyspace1 & Keyspace2 RF=1
1:133acbb:         *  {
1:e1206f3:         *      /127.0.0.1=[(97,0]],
1:133acbb:         *      /127.0.0.2=[(0,10]],
1:133acbb:         *      /127.0.0.3=[(10,20]],
1:133acbb:         *      /127.0.0.4=[(20,30]],
1:133acbb:         *      /127.0.0.5=[(30,40]],
1:133acbb:         *      /127.0.0.6=[(40,50]],
1:e1206f3:         *      /127.0.0.7=[(50,67]],
1:e1206f3:         *      /127.0.0.8=[(67,70]],
1:e1206f3:         *      /127.0.0.9=[(70,87]],
1:e1206f3:         *      /127.0.0.10=[(87,97]]
1:133acbb:         *  }
1:133acbb:         */
1:133acbb: 
1:9c1679d:         Multimap<InetAddress, Range<Token>> keyspace1ranges = keyspaceStrategyMap.get(Simple_RF1_KeyspaceName).getAddressRanges();
1:554223b:         Collection<Range<Token>> ranges1 = keyspace1ranges.get(InetAddress.getByName("127.0.0.1"));
1:3020555:         assertEquals(1, collectionSize(ranges1));
1:3020555:         assertEquals(generateRange(97, 0), ranges1.iterator().next());
1:554223b:         Collection<Range<Token>> ranges2 = keyspace1ranges.get(InetAddress.getByName("127.0.0.2"));
1:3020555:         assertEquals(1, collectionSize(ranges2));
1:3020555:         assertEquals(generateRange(0, 10), ranges2.iterator().next());
1:554223b:         Collection<Range<Token>> ranges3 = keyspace1ranges.get(InetAddress.getByName("127.0.0.3"));
1:3020555:         assertEquals(1, collectionSize(ranges3));
1:3020555:         assertEquals(generateRange(10, 20), ranges3.iterator().next());
1:554223b:         Collection<Range<Token>> ranges4 = keyspace1ranges.get(InetAddress.getByName("127.0.0.4"));
1:3020555:         assertEquals(1, collectionSize(ranges4));
1:3020555:         assertEquals(generateRange(20, 30), ranges4.iterator().next());
1:554223b:         Collection<Range<Token>> ranges5 = keyspace1ranges.get(InetAddress.getByName("127.0.0.5"));
1:3020555:         assertEquals(1, collectionSize(ranges5));
1:3020555:         assertEquals(generateRange(30, 40), ranges5.iterator().next());
1:554223b:         Collection<Range<Token>> ranges6 = keyspace1ranges.get(InetAddress.getByName("127.0.0.6"));
1:3020555:         assertEquals(1, collectionSize(ranges6));
1:3020555:         assertEquals(generateRange(40, 50), ranges6.iterator().next());
1:554223b:         Collection<Range<Token>> ranges7 = keyspace1ranges.get(InetAddress.getByName("127.0.0.7"));
1:3020555:         assertEquals(1, collectionSize(ranges7));
1:3020555:         assertEquals(generateRange(50, 67), ranges7.iterator().next());
1:554223b:         Collection<Range<Token>> ranges8 = keyspace1ranges.get(InetAddress.getByName("127.0.0.8"));
1:3020555:         assertEquals(1, collectionSize(ranges8));
1:3020555:         assertEquals(generateRange(67, 70), ranges8.iterator().next());
1:554223b:         Collection<Range<Token>> ranges9 = keyspace1ranges.get(InetAddress.getByName("127.0.0.9"));
1:3020555:         assertEquals(1, collectionSize(ranges9));
1:3020555:         assertEquals(generateRange(70, 87), ranges9.iterator().next());
1:554223b:         Collection<Range<Token>> ranges10 = keyspace1ranges.get(InetAddress.getByName("127.0.0.10"));
1:3020555:         assertEquals(1, collectionSize(ranges10));
1:3020555:         assertEquals(generateRange(87, 97), ranges10.iterator().next());
1:133acbb: 
1:133acbb: 
1:133acbb:         /**
1:133acbb:         * Keyspace3 RF=5
1:133acbb:         * {
1:e1206f3:         *      /127.0.0.1=[(97,0], (70,87], (50,67], (87,97], (67,70]],
1:e1206f3:         *      /127.0.0.2=[(97,0], (70,87], (87,97], (0,10], (67,70]],
1:e1206f3:         *      /127.0.0.3=[(97,0], (70,87], (87,97], (0,10], (10,20]],
1:e1206f3:         *      /127.0.0.4=[(97,0], (20,30], (87,97], (0,10], (10,20]],
1:e1206f3:         *      /127.0.0.5=[(97,0], (30,40], (20,30], (0,10], (10,20]],
1:133acbb:         *      /127.0.0.6=[(40,50], (30,40], (20,30], (0,10], (10,20]],
1:e1206f3:         *      /127.0.0.7=[(40,50], (30,40], (50,67], (20,30], (10,20]],
1:e1206f3:         *      /127.0.0.8=[(40,50], (30,40], (50,67], (20,30], (67,70]],
1:e1206f3:         *      /127.0.0.9=[(40,50], (70,87], (30,40], (50,67], (67,70]],
1:e1206f3:         *      /127.0.0.10=[(40,50], (70,87], (50,67], (87,97], (67,70]]
1:133acbb:         * }
1:133acbb:         */
1:133acbb: 
1:d2a3827:         Multimap<InetAddress, Range<Token>> keyspace3ranges = keyspaceStrategyMap.get(KEYSPACE3).getAddressRanges();
1:133acbb:         ranges1 = keyspace3ranges.get(InetAddress.getByName("127.0.0.1"));
1:133acbb:         assertEquals(collectionSize(ranges1), 5);
1:e1206f3:         assertTrue(ranges1.equals(generateRanges(97, 0, 70, 87, 50, 67, 87, 97, 67, 70)));
1:133acbb:         ranges2 = keyspace3ranges.get(InetAddress.getByName("127.0.0.2"));
1:133acbb:         assertEquals(collectionSize(ranges2), 5);
1:e1206f3:         assertTrue(ranges2.equals(generateRanges(97, 0, 70, 87, 87, 97, 0, 10, 67, 70)));
1:133acbb:         ranges3 = keyspace3ranges.get(InetAddress.getByName("127.0.0.3"));
1:133acbb:         assertEquals(collectionSize(ranges3), 5);
1:e1206f3:         assertTrue(ranges3.equals(generateRanges(97, 0, 70, 87, 87, 97, 0, 10, 10, 20)));
1:133acbb:         ranges4 = keyspace3ranges.get(InetAddress.getByName("127.0.0.4"));
1:133acbb:         assertEquals(collectionSize(ranges4), 5);
1:e1206f3:         assertTrue(ranges4.equals(generateRanges(97, 0, 20, 30, 87, 97, 0, 10, 10, 20)));
1:133acbb:         ranges5 = keyspace3ranges.get(InetAddress.getByName("127.0.0.5"));
1:133acbb:         assertEquals(collectionSize(ranges5), 5);
1:e1206f3:         assertTrue(ranges5.equals(generateRanges(97, 0, 30, 40, 20, 30, 0, 10, 10, 20)));
1:133acbb:         ranges6 = keyspace3ranges.get(InetAddress.getByName("127.0.0.6"));
1:133acbb:         assertEquals(collectionSize(ranges6), 5);
1:133acbb:         assertTrue(ranges6.equals(generateRanges(40, 50, 30, 40, 20, 30, 0, 10, 10, 20)));
1:133acbb:         ranges7 = keyspace3ranges.get(InetAddress.getByName("127.0.0.7"));
1:133acbb:         assertEquals(collectionSize(ranges7), 5);
1:e1206f3:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 67, 20, 30, 10, 20)));
1:133acbb:         ranges8 = keyspace3ranges.get(InetAddress.getByName("127.0.0.8"));
1:133acbb:         assertEquals(collectionSize(ranges8), 5);
1:e1206f3:         assertTrue(ranges8.equals(generateRanges(40, 50, 30, 40, 50, 67, 20, 30, 67, 70)));
1:133acbb:         ranges9 = keyspace3ranges.get(InetAddress.getByName("127.0.0.9"));
1:133acbb:         assertEquals(collectionSize(ranges9), 5);
1:e1206f3:         assertTrue(ranges9.equals(generateRanges(40, 50, 70, 87, 30, 40, 50, 67, 67, 70)));
1:133acbb:         ranges10 = keyspace3ranges.get(InetAddress.getByName("127.0.0.10"));
1:133acbb:         assertEquals(collectionSize(ranges10), 5);
1:e1206f3:         assertTrue(ranges10.equals(generateRanges(40, 50, 70, 87, 50, 67, 87, 97, 67, 70)));
1:133acbb: 
1:133acbb: 
1:133acbb:         /**
1:133acbb:          * Keyspace4 RF=3
1:133acbb:          * {
1:e1206f3:          *      /127.0.0.1=[(97,0], (70,87], (87,97]],
1:e1206f3:          *      /127.0.0.2=[(97,0], (87,97], (0,10]],
1:e1206f3:          *      /127.0.0.3=[(97,0], (0,10], (10,20]],
1:133acbb:          *      /127.0.0.4=[(20,30], (0,10], (10,20]],
1:133acbb:          *      /127.0.0.5=[(30,40], (20,30], (10,20]],
1:133acbb:          *      /127.0.0.6=[(40,50], (30,40], (20,30]],
1:e1206f3:          *      /127.0.0.7=[(40,50], (30,40], (50,67]],
1:e1206f3:          *      /127.0.0.8=[(40,50], (50,67], (67,70]],
1:e1206f3:          *      /127.0.0.9=[(70,87], (50,67], (67,70]],
1:e1206f3:          *      /127.0.0.10=[(70,87], (87,97], (67,70]]
1:133acbb:          *  }
1:133acbb:          */
1:9c1679d:         Multimap<InetAddress, Range<Token>> keyspace4ranges = keyspaceStrategyMap.get(Simple_RF3_KeyspaceName).getAddressRanges();
1:133acbb:         ranges1 = keyspace4ranges.get(InetAddress.getByName("127.0.0.1"));
1:133acbb:         assertEquals(collectionSize(ranges1), 3);
1:e1206f3:         assertTrue(ranges1.equals(generateRanges(97, 0, 70, 87, 87, 97)));
1:133acbb:         ranges2 = keyspace4ranges.get(InetAddress.getByName("127.0.0.2"));
1:133acbb:         assertEquals(collectionSize(ranges2), 3);
1:e1206f3:         assertTrue(ranges2.equals(generateRanges(97, 0, 87, 97, 0, 10)));
1:133acbb:         ranges3 = keyspace4ranges.get(InetAddress.getByName("127.0.0.3"));
1:133acbb:         assertEquals(collectionSize(ranges3), 3);
1:e1206f3:         assertTrue(ranges3.equals(generateRanges(97, 0, 0, 10, 10, 20)));
1:133acbb:         ranges4 = keyspace4ranges.get(InetAddress.getByName("127.0.0.4"));
1:133acbb:         assertEquals(collectionSize(ranges4), 3);
1:133acbb:         assertTrue(ranges4.equals(generateRanges(20, 30, 0, 10, 10, 20)));
1:133acbb:         ranges5 = keyspace4ranges.get(InetAddress.getByName("127.0.0.5"));
1:133acbb:         assertEquals(collectionSize(ranges5), 3);
1:133acbb:         assertTrue(ranges5.equals(generateRanges(30, 40, 20, 30, 10, 20)));
1:133acbb:         ranges6 = keyspace4ranges.get(InetAddress.getByName("127.0.0.6"));
1:133acbb:         assertEquals(collectionSize(ranges6), 3);
1:133acbb:         assertTrue(ranges6.equals(generateRanges(40, 50, 30, 40, 20, 30)));
1:133acbb:         ranges7 = keyspace4ranges.get(InetAddress.getByName("127.0.0.7"));
1:133acbb:         assertEquals(collectionSize(ranges7), 3);
1:e1206f3:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 67)));
1:133acbb:         ranges8 = keyspace4ranges.get(InetAddress.getByName("127.0.0.8"));
1:133acbb:         assertEquals(collectionSize(ranges8), 3);
1:e1206f3:         assertTrue(ranges8.equals(generateRanges(40, 50, 50, 67, 67, 70)));
1:133acbb:         ranges9 = keyspace4ranges.get(InetAddress.getByName("127.0.0.9"));
1:133acbb:         assertEquals(collectionSize(ranges9), 3);
1:e1206f3:         assertTrue(ranges9.equals(generateRanges(70, 87, 50, 67, 67, 70)));
1:133acbb:         ranges10 = keyspace4ranges.get(InetAddress.getByName("127.0.0.10"));
1:133acbb:         assertEquals(collectionSize(ranges10), 3);
1:e1206f3:         assertTrue(ranges10.equals(generateRanges(70, 87, 87, 97, 67, 70)));
1:133acbb: 
1:3577fd8:         // pre-calculate the results.
1:3577fd8:         Map<String, Multimap<Token, InetAddress>> expectedEndpoints = new HashMap<String, Multimap<Token, InetAddress>>();
1:9c1679d:         expectedEndpoints.put(Simple_RF1_KeyspaceName, HashMultimap.<Token, InetAddress>create());
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
1:9c1679d:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.put(KEYSPACE2, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.put(KEYSPACE3, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4"));
1:9c1679d:         expectedEndpoints.put(Simple_RF3_KeyspaceName, HashMultimap.<Token, InetAddress>create());
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1"));
1:9c1679d:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2"));
1:720c49a: 
1:0e96e58:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:720c49a:         {
1:0e96e58:             String keyspaceName = keyspaceStrategy.getKey();
1:0e96e58:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:720c49a: 
1:0789a58:             for (Token token : keyTokens)
1:720c49a:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(token, keyspaceName, strategy.getNaturalEndpoints(token));
1:3020555:                 assertEquals(expectedEndpoints.get(keyspaceName).get(token).size(), endpoints.size());
1:0e96e58:                 assertTrue(expectedEndpoints.get(keyspaceName).get(token).containsAll(endpoints));
1:720c49a:             }
1:720c49a: 
1:3577fd8:             // just to be sure that things still work according to the old tests, run them:
1:2f5f0c2:             if (strategy.getReplicationFactor() != 3)
1:3577fd8:                 continue;
1:133acbb: 
2:720c49a:             // tokens 5, 15 and 25 should go three nodes
1:133acbb:             for (int i = 0; i < 3; i++)
1:720c49a:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
1:3020555:                 assertEquals(3, endpoints.size());
1:18b2a16:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:18b2a16:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:18b2a16:                 assertTrue(endpoints.contains(hosts.get(i+3)));
1:720c49a:             }
1:720c49a: 
1:133acbb:             // token 35 should go to nodes 4, 5, 6 and boot1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
1:3020555:             assertEquals(4, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(4)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(5)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(6)));
1:18b2a16:             assertTrue(endpoints.contains(boot1));
1:720c49a: 
1:133acbb:             // token 45 should go to nodes 5, 6, 7 boot1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
1:3020555:             assertEquals(4, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(5)));
1:e1206f3:             assertTrue(endpoints.contains(hosts.get(6)));
2:18b2a16:             assertTrue(endpoints.contains(hosts.get(7)));
1:18b2a16:             assertTrue(endpoints.contains(boot1));
1:720c49a: 
1:133acbb:             // token 55 should go to nodes 6, 7, 8 boot1 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
1:3020555:             assertEquals(5, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(6)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(7)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(8)));
1:18b2a16:             assertTrue(endpoints.contains(boot1));
2:18b2a16:             assertTrue(endpoints.contains(boot2));
1:720c49a: 
1:e1206f3:             // token 65 should go to nodes 6, 7, 8 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
1:3020555:             assertEquals(4, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(6)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(7)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(8)));
1:18b2a16:             assertTrue(endpoints.contains(boot2));
1:720c49a: 
1:133acbb:             // token 75 should to go nodes 8, 9, 0 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
1:3020555:             assertEquals(4, endpoints.size());
3:18b2a16:             assertTrue(endpoints.contains(hosts.get(8)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(9)));
4:18b2a16:             assertTrue(endpoints.contains(hosts.get(0)));
1:18b2a16:             assertTrue(endpoints.contains(boot2));
1:720c49a: 
1:e1206f3:             // token 85 should go to nodes 8, 9 and 0
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
1:3020555:             assertEquals(3, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(8)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(9)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(0)));
1:720c49a: 
1:e1206f3:             // token 95 should go to nodes 9, 0 and 1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
1:3020555:             assertEquals(3, endpoints.size());
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(9)));
1:18b2a16:             assertTrue(endpoints.contains(hosts.get(0)));
5:18b2a16:             assertTrue(endpoints.contains(hosts.get(1)));
1:720c49a:         }
1:720c49a: 
1:133acbb:         // all moving nodes are back to the normal state
1:133acbb:         for (Integer movingIndex : MOVING)
1:720c49a:         {
1:66b96ee:             ss.onChange(hosts.get(movingIndex),
1:66b96ee:                         ApplicationState.STATUS,
1:b475bc6:                         valueFactory.normal(Collections.singleton(newTokens.get(movingIndex))));
1:720c49a:         }
1:720c49a:     }
1:720c49a: 
1:720c49a:     @Test
1:720c49a:     public void testStateJumpToNormal() throws UnknownHostException
1:720c49a:     {
1:a2e2c03:         StorageService ss = StorageService.instance;
1:720c49a:         TokenMetadata tmd = ss.getTokenMetadata();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:89fbc1b:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:720c49a: 
1:18b2a16:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:720c49a:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:720c49a:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:720c49a: 
1:133acbb:         // create a ring or 6 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
1:720c49a: 
2:720c49a:         // node 2 leaves
1:133acbb:         Token newToken = positionToken(7);
1:133acbb:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.moving(newToken));
1:720c49a: 
1:133acbb:         assertTrue(tmd.isMoving(hosts.get(2)));
1:3020555:         assertEquals(endpointTokens.get(2), tmd.getToken(hosts.get(2)));
1:720c49a: 
1:720c49a:         // back to normal
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
1:b475bc6:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
1:720c49a: 
1:133acbb:         assertTrue(tmd.getMovingEndpoints().isEmpty());
1:3020555:         assertEquals(newToken, tmd.getToken(hosts.get(2)));
1:720c49a: 
1:133acbb:         newToken = positionToken(8);
1:133acbb:         // node 2 goes through leave and left and then jumps to normal at its new token
1:133acbb:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.moving(newToken));
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
1:b475bc6:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
1:720c49a: 
4:720c49a:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:133acbb:         assertTrue(tmd.getMovingEndpoints().isEmpty());
1:3020555:         assertEquals(newToken, tmd.getToken(hosts.get(2)));
1:720c49a:     }
1:720c49a: 
1:3577fd8:     private static Collection<InetAddress> makeAddrs(String... hosts) throws UnknownHostException
1:720c49a:     {
1:3577fd8:         ArrayList<InetAddress> addrs = new ArrayList<InetAddress>(hosts.length);
1:3577fd8:         for (String host : hosts)
1:3577fd8:             addrs.add(InetAddress.getByName(host));
1:3577fd8:         return addrs;
1:720c49a:     }
1:720c49a: 
1:9639f95:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
1:720c49a:     {
1:a89597d:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
1:df8a933:         return AbstractReplicationStrategy.createReplicationStrategy(
1:0e96e58:                 keyspaceName,
1:31e3f61:                 ksmd.params.replication.klass,
1:df8a933:                 tmd,
1:df8a933:                 new SimpleSnitch(),
1:31e3f61:                 ksmd.params.replication.options);
1:720c49a:     }
1:720c49a: 
1:133acbb:     private Token positionToken(int position)
1:133acbb:     {
1:e1206f3:         return new BigIntegerToken(String.valueOf(10 * position + 7));
1:133acbb:     }
1:133acbb: 
1:133acbb:     private int collectionSize(Collection<?> collection)
1:133acbb:     {
1:133acbb:         if (collection.isEmpty())
1:133acbb:             return 0;
1:133acbb: 
1:133acbb:         Iterator<?> iterator = collection.iterator();
1:133acbb: 
1:133acbb:         int count = 0;
1:133acbb:         while (iterator.hasNext())
1:133acbb:         {
1:133acbb:             iterator.next();
1:133acbb:             count++;
1:133acbb:         }
1:133acbb: 
1:133acbb:         return count;
1:133acbb:     }
1:133acbb: 
1:554223b:     private Collection<Range<Token>> generateRanges(int... rangePairs)
1:133acbb:     {
1:133acbb:         if (rangePairs.length % 2 == 1)
1:133acbb:             throw new RuntimeException("generateRanges argument count should be even");
1:133acbb: 
1:554223b:         Set<Range<Token>> ranges = new HashSet<Range<Token>>();
1:133acbb: 
1:133acbb:         for (int i = 0; i < rangePairs.length; i+=2)
1:133acbb:         {
1:133acbb:             ranges.add(generateRange(rangePairs[i], rangePairs[i+1]));
1:133acbb:         }
1:133acbb: 
1:133acbb:         return ranges;
1:133acbb:     }
1:133acbb: 
1:554223b:     private Range<Token> generateRange(int left, int right)
1:133acbb:     {
1:554223b:         return new Range<Token>(new BigIntegerToken(String.valueOf(left)), new BigIntegerToken(String.valueOf(right)));
1:133acbb:     }
1:720c49a: }
============================================================================
author:Jeff Jirsa
-------------------------------------------------------------------------------
commit:cd8a98a
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:     private static void addNetworkTopologyKeyspace(String keyspaceName, Integer... replicas) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
commit:d45f323
author:Nachiket Patil
-------------------------------------------------------------------------------
commit:f2c5ad7
/////////////////////////////////////////////////////////////////////////
1:     public static void setup() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     private static void addNetworkTopologyKeyspace(String keyspaceName, Integer... replicas) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         final TokenMetadata tmd = StorageService.instance.getTokenMetadata();
1:         tmd.clearUnsafe();
1:         tmd.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.0.0.1"));
1:         tmd.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.0.0.2"));
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:a4e1182
/////////////////////////////////////////////////////////////////////////
1:         for (String nonSystemKeyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
commit:85bcd2d
commit:1879d99
/////////////////////////////////////////////////////////////////////////
0:             // This assertion isn't reliable in 2.0 and 2.1.  See CASSANDRA-7390
0:             // assertEquals("mismatched number of moved token", numMoved, 1);
commit:70c72b7
/////////////////////////////////////////////////////////////////////////
0:             // This assertion isn't reliable in 2.1.  See CASSANDRA-7390
0:             // assertEquals("mismatched number of moved token", numMoved, 1);
author:sankalp kohli
-------------------------------------------------------------------------------
commit:9c1679d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.db.marshal.BytesType;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.locator.AbstractNetworkTopologySnitch;
1: import org.apache.cassandra.locator.NetworkTopologyStrategy;
1: import org.apache.cassandra.locator.PendingRangeMaps;
1: import org.apache.cassandra.schema.KeyspaceParams;
1: import org.apache.cassandra.schema.Tables;
1: import static org.junit.Assert.assertNotNull;
1:     //Simple Strategy Keyspaces
1:     private static final String Simple_RF1_KeyspaceName = "MoveTestKeyspace1";
1:     private static final String Simple_RF2_KeyspaceName = "MoveTestKeyspace5";
1:     private static final String Simple_RF3_KeyspaceName = "MoveTestKeyspace4";
1: 
1:     //Network Strategy Keyspace with RF DC1=1 and DC2=1 and so on.
1:     private static final String Network_11_KeyspaceName = "MoveTestNetwork11";
1:     private static final String Network_22_KeyspaceName = "MoveTestNetwork22";
1:     private static final String Network_33_KeyspaceName = "MoveTestNetwork33";
/////////////////////////////////////////////////////////////////////////
1:         addNetworkTopologyKeyspace(Network_11_KeyspaceName, 1, 1);
1:         addNetworkTopologyKeyspace(Network_22_KeyspaceName, 2, 2);
1:         addNetworkTopologyKeyspace(Network_33_KeyspaceName, 3, 3);
/////////////////////////////////////////////////////////////////////////
0:     private static void addNetworkTopologyKeyspace(String keyspaceName, Integer... replicas) throws ConfigurationException
1:     {
1: 
1:         DatabaseDescriptor.setEndpointSnitch(new AbstractNetworkTopologySnitch()
1:         {
1:             //Odd IPs are in DC1 and Even are in DC2. Endpoints upto .14 will have unique racks and
1:             // then will be same for a set of three.
1:             @Override
1:             public String getRack(InetAddress endpoint)
1:             {
1:                 int ipLastPart = getIPLastPart(endpoint);
1:                 if (ipLastPart <= 14)
1:                     return UUID.randomUUID().toString();
1:                 else
1:                     return "RAC" + (ipLastPart % 3);
1:             }
1: 
1:             @Override
1:             public String getDatacenter(InetAddress endpoint)
1:             {
1:                 if (getIPLastPart(endpoint) % 2 == 0)
1:                     return "DC2";
1:                 else
1:                     return "DC1";
1:             }
1: 
1:             private int getIPLastPart(InetAddress endpoint)
1:             {
1:                 String str = endpoint.toString();
1:                 int index = str.lastIndexOf(".");
1:                 return Integer.parseInt(str.substring(index + 1).trim());
1:             }
1:         });
1: 
1:         KeyspaceMetadata keyspace =  KeyspaceMetadata.create(keyspaceName,
1:                                                              KeyspaceParams.nts(configOptions(replicas)),
1:                                                              Tables.of(CFMetaData.Builder.create(keyspaceName, "CF1")
1:                                                                                          .addPartitionKey("key", BytesType.instance).build()));
1:         MigrationManager.announceNewKeyspace(keyspace);
1:     }
1: 
1:     private static Object[] configOptions(Integer[] replicas)
1:     {
1:         Object[] configOptions = new Object[(replicas.length * 2)];
1:         int i = 1, j=0;
1:         for(Integer replica : replicas)
1:         {
1:             if(replica == null)
1:                 continue;
1:             configOptions[j++] = "DC" + i++;
1:             configOptions[j++] = replica;
1:         }
1:         return configOptions;
1:     }
1: 
1:     @Test
1:     public void testMoveWithPendingRangesNetworkStrategyRackAwareThirtyNodes() throws Exception
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 60;
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:         ArrayList<Token> keyTokens = new ArrayList<>();
1:         List<InetAddress> hosts = new ArrayList<>();
1:         List<UUID> hostIds = new ArrayList<>();
1: 
1:         for(int i=0; i < RING_SIZE/2; i++)
1:         {
1:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:             endpointTokens.add(new BigIntegerToken(String.valueOf((10 * i) + 1)));
1:         }
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1: 
1:         //Moving Endpoint 127.0.0.37 in RAC1 with current token 180
1:         int MOVING_NODE = 36;
1:         moveHost(hosts.get(MOVING_NODE), 215, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(150, 151, "127.0.0.43"),
1:                 generatePendingMapEntry(151, 160, "127.0.0.43"),generatePendingMapEntry(160, 161, "127.0.0.43"),
1:                 generatePendingMapEntry(161, 170, "127.0.0.43"), generatePendingMapEntry(170, 171, "127.0.0.43"),
1:                 generatePendingMapEntry(171, 180, "127.0.0.43"), generatePendingMapEntry(210, 211, "127.0.0.37"),
1:                 generatePendingMapEntry(211, 215, "127.0.0.37")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 215, tmd);
1: 
1:         //Moving it back to original spot
1:         moveHost(hosts.get(MOVING_NODE), 180, tmd, valueFactory);
1:         finishMove(hosts.get(MOVING_NODE), 180, tmd);
1: 
1:     }
1: 
1:     @Test
1:     public void testMoveWithPendingRangesNetworkStrategyTenNode() throws Exception
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 14;
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:         ArrayList<Token> keyTokens = new ArrayList<>();
1:         List<InetAddress> hosts = new ArrayList<>();
1:         List<UUID> hostIds = new ArrayList<>();
1: 
1:         for(int i=0; i < RING_SIZE/2; i++)
1:         {
1:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:             endpointTokens.add(new BigIntegerToken(String.valueOf((10 * i) + 1)));
1:         }
1: 
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1: 
1:         int MOVING_NODE = 0;
1:         moveHost(hosts.get(MOVING_NODE), 5, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.1"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.1")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 5, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.3"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.3")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.5"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.5")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 1, "127.0.0.7"),
1:                 generatePendingMapEntry(1, 5, "127.0.0.7")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         MOVING_NODE = 1;
1:         moveHost(hosts.get(MOVING_NODE), 5, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.2")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 5, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 1, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.4")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.6")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 5, "127.0.0.8")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 1, tmd);
1: 
1:         MOVING_NODE = 3;
1:         moveHost(hosts.get(MOVING_NODE), 25, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 10, "127.0.0.6"),
1:                 generatePendingMapEntry(10, 11, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(61, 0, "127.0.0.6"),
1:                 generatePendingMapEntry(0, 1, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4"),
1:                 generatePendingMapEntry(11, 20, "127.0.0.4"),generatePendingMapEntry(20, 21, "127.0.0.4")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(51, 60, "127.0.0.6"),
1:                 generatePendingMapEntry(60, 61, "127.0.0.6"), generatePendingMapEntry(21, 25, "127.0.0.4"),
1:                 generatePendingMapEntry(11, 20, "127.0.0.4"), generatePendingMapEntry(20, 21, "127.0.0.4")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 25, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 11, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1, 10, "127.0.0.4"),
1:                 generatePendingMapEntry(10, 11, "127.0.0.4"), generatePendingMapEntry(21, 25, "127.0.0.8")), Network_11_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(61, 0, "127.0.0.4"),
1:                 generatePendingMapEntry(0, 1, "127.0.0.4"), generatePendingMapEntry(11, 20, "127.0.0.8"),
1:                 generatePendingMapEntry(20, 21, "127.0.0.8"), generatePendingMapEntry(21, 25, "127.0.0.10")), Network_22_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(51, 60, "127.0.0.4"),
1:                 generatePendingMapEntry(60, 61, "127.0.0.4"), generatePendingMapEntry(21, 25, "127.0.0.12"),
1:                 generatePendingMapEntry(11, 20, "127.0.0.10"), generatePendingMapEntry(20, 21, "127.0.0.10")), Network_33_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 11, tmd);
1:     }
1: 
1:     @Test
1:     public void testMoveWithPendingRangesSimpleStrategyTenNode() throws Exception
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 10;
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:         ArrayList<Token> keyTokens = new ArrayList<>();
1:         List<InetAddress> hosts = new ArrayList<>();
1:         List<UUID> hostIds = new ArrayList<>();
1: 
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1: 
1:         final int MOVING_NODE = 0; // index of the moving node
1:         moveHost(hosts.get(MOVING_NODE), 2, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 2, tmd);
1: 
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 1000, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 1000, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1000, 0, "127.0.0.1")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 35, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(90, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(20, 30, "127.0.0.1"),
1:                 generatePendingMapEntry(80, 90, "127.0.0.2"), generatePendingMapEntry(90, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 35, "127.0.0.1"), generatePendingMapEntry(20, 30, "127.0.0.1"),
1:                 generatePendingMapEntry(80, 90, "127.0.0.3"), generatePendingMapEntry(90, 0, "127.0.0.4"),
1:                 generatePendingMapEntry(10, 20, "127.0.0.1"), generatePendingMapEntry(70, 80, "127.0.0.2")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 35, tmd);
1: 
1:     }
1: 
1:     @Test
1:     public void testMoveWithPendingRangesForSimpleStrategyFourNode() throws Exception
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 4;
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:         ArrayList<Token> keyTokens = new ArrayList<>();
1:         List<InetAddress> hosts = new ArrayList<>();
1:         List<UUID> hostIds = new ArrayList<>();
1: 
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1: 
1:         int MOVING_NODE = 0; // index of the moving node
1:         moveHost(hosts.get(MOVING_NODE), 2, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.1")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 2, tmd);
1: 
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 2, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 1500, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 1500, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(1500, 0, "127.0.0.1")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 15, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(10, 15, "127.0.0.1"), generatePendingMapEntry(30, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 30, "127.0.0.2"), generatePendingMapEntry(10, 15, "127.0.0.1"),
1:                 generatePendingMapEntry(0, 10, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(15, 20, "127.0.0.2"),
1:                 generatePendingMapEntry(0, 10, "127.0.0.1")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 15, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 0, "127.0.0.1"),
1:                 generatePendingMapEntry(10, 15, "127.0.0.3")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 30, "127.0.0.1"),
1:                 generatePendingMapEntry(10, 15, "127.0.0.4"), generatePendingMapEntry(0, 10, "127.0.0.3")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(15, 20, "127.0.0.1"),
1:                 generatePendingMapEntry(0, 10, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 26, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 26, "127.0.0.1"),
1:                 generatePendingMapEntry(30, 0, "127.0.0.2")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(26, 30, "127.0.0.2"),
1:                 generatePendingMapEntry(30, 0, "127.0.0.3"), generatePendingMapEntry(10, 20, "127.0.0.1")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(0, 10, "127.0.0.1"),
1:                 generatePendingMapEntry(26, 30, "127.0.0.3")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 26, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 0, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(20, 26, "127.0.0.4"),
1:                 generatePendingMapEntry(30, 0, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 0, "127.0.0.1"),
1:                 generatePendingMapEntry(26, 30, "127.0.0.1"), generatePendingMapEntry(10, 20, "127.0.0.4")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(26, 30, "127.0.0.1"),
1:                 generatePendingMapEntry(0, 10, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 0, tmd);
1: 
1:         MOVING_NODE = 3;
1: 
1:         moveHost(hosts.get(MOVING_NODE), 33, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.4")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 33, tmd);
1: 
1:         moveHost(hosts.get(MOVING_NODE), 30, tmd, valueFactory);
1: 
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.1")), Simple_RF1_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.2")), Simple_RF2_KeyspaceName);
1:         assertPendingRanges(tmd, generatePendingRanges(generatePendingMapEntry(30, 33, "127.0.0.3")), Simple_RF3_KeyspaceName);
1: 
1:         finishMove(hosts.get(MOVING_NODE), 30, tmd);
1:     }
1: 
1:     private void moveHost(InetAddress host, int token, TokenMetadata tmd, VersionedValue.VersionedValueFactory valueFactory )
1:     {
1:         StorageService.instance.onChange(host, ApplicationState.STATUS, valueFactory.moving(new BigIntegerToken(String.valueOf(token))));
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:         assertTrue(tmd.isMoving(host));
1:     }
1: 
1:     private void finishMove(InetAddress host, int token, TokenMetadata tmd)
1:     {
1:         tmd.removeFromMoving(host);
1:         assertTrue(!tmd.isMoving(host));
1:         tmd.updateNormalToken(new BigIntegerToken(String.valueOf(token)), host);
1:     }
1: 
1:     private Map.Entry<Range<Token>, Collection<InetAddress>> generatePendingMapEntry(int start, int end, String... endpoints) throws UnknownHostException
1:     {
1:         Map<Range<Token>, Collection<InetAddress>> pendingRanges = new HashMap<>();
1:         pendingRanges.put(generateRange(start, end), makeAddrs(endpoints));
1:         return pendingRanges.entrySet().iterator().next();
1:     }
1: 
1:     private Map<Range<Token>, Collection<InetAddress>> generatePendingRanges(Map.Entry<Range<Token>, Collection<InetAddress>>... entries)
1:     {
1:         Map<Range<Token>, Collection<InetAddress>> pendingRanges = new HashMap<>();
1:         for(Map.Entry<Range<Token>, Collection<InetAddress>> entry : entries)
1:         {
1:             pendingRanges.put(entry.getKey(), entry.getValue());
1:         }
1:         return pendingRanges;
1:     }
1: 
1:     private void assertPendingRanges(TokenMetadata tmd, Map<Range<Token>,  Collection<InetAddress>> pendingRanges, String keyspaceName) throws ConfigurationException
1:     {
1:         boolean keyspaceFound = false;
0:         for (String nonSystemKeyspaceName : Schema.instance.getNonSystemKeyspaces())
1:         {
1:             if(!keyspaceName.equals(nonSystemKeyspaceName))
1:                 continue;
1:             assertMaps(pendingRanges, tmd.getPendingRanges(keyspaceName));
1:             keyspaceFound = true;
1:         }
1: 
1:         assert keyspaceFound;
1:     }
1: 
1:     private void assertMaps(Map<Range<Token>, Collection<InetAddress>> expected, PendingRangeMaps actual)
1:     {
1:         int sizeOfActual = 0;
1:         Iterator<Map.Entry<Range<Token>, List<InetAddress>>> iterator = actual.iterator();
1:         while(iterator.hasNext())
1:         {
1:             Map.Entry<Range<Token>, List<InetAddress>> actualEntry = iterator.next();
1:             assertNotNull(expected.get(actualEntry.getKey()));
1:             assertEquals(new HashSet<>(expected.get(actualEntry.getKey())), new HashSet<>(actualEntry.getValue()));
1:             sizeOfActual++;
1:         }
1: 
1:         assertEquals(expected.size(), sizeOfActual);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if(strategy instanceof NetworkTopologyStrategy)
1:                 continue;
/////////////////////////////////////////////////////////////////////////
1:         Multimap<InetAddress, Range<Token>> keyspace1ranges = keyspaceStrategyMap.get(Simple_RF1_KeyspaceName).getAddressRanges();
/////////////////////////////////////////////////////////////////////////
1:         Multimap<InetAddress, Range<Token>> keyspace4ranges = keyspaceStrategyMap.get(Simple_RF3_KeyspaceName).getAddressRanges();
/////////////////////////////////////////////////////////////////////////
1:         expectedEndpoints.put(Simple_RF1_KeyspaceName, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
1:         expectedEndpoints.get(Simple_RF1_KeyspaceName).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
/////////////////////////////////////////////////////////////////////////
1:         expectedEndpoints.put(Simple_RF3_KeyspaceName, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1"));
1:         expectedEndpoints.get(Simple_RF3_KeyspaceName).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2"));
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1:                 ksmd.params.replication.klass,
1:                 ksmd.params.replication.options);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             strategy = getStrategy(keyspaceName, tmd);
1:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, keyspaceName, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
/////////////////////////////////////////////////////////////////////////
1:         Map<String, AbstractReplicationStrategy> keyspaceStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
0:             keyspaceStrategyMap.put("Keyspace" + i, getStrategy("Keyspace" + i, tmd));
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace1ranges = keyspaceStrategyMap.get("Keyspace1").getAddressRanges();
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace3ranges = keyspaceStrategyMap.get("Keyspace3").getAddressRanges();
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace4ranges = keyspaceStrategyMap.get("Keyspace4").getAddressRanges();
/////////////////////////////////////////////////////////////////////////
1:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:             String keyspaceName = keyspaceStrategy.getKey();
1:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:                 endpoints = tmd.getWriteEndpoints(token, keyspaceName, strategy.getNaturalEndpoints(token));
0:                 assertTrue(expectedEndpoints.get(keyspaceName).get(token).size() == endpoints.size());
1:                 assertTrue(expectedEndpoints.get(keyspaceName).get(token).containsAll(endpoints));
/////////////////////////////////////////////////////////////////////////
1:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
/////////////////////////////////////////////////////////////////////////
0:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd) throws ConfigurationException
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(keyspaceName);
1:                 keyspaceName,
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.RandomPartitioner;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.gms.Gossiper;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
commit:438acfc
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import static org.junit.Assert.*;
1: import org.junit.AfterClass;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
1: public class MoveTest
0:     private static final IPartitioner partitioner = new RandomPartitioner();
1:     private static IPartitioner oldPartitioner;
1: 
1:     /*
1:      * NOTE: the tests above uses RandomPartitioner, which is not the default
1:      * test partitioner. Changing the partitioner should be done before
1:      * loading the schema as loading the schema trigger the write of sstables.
1:      * So instead of extending SchemaLoader, we call it's method below.
1:      */
1:     @BeforeClass
0:     public static void setup() throws IOException
1:     {
1:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(partitioner);
1:         SchemaLoader.loadSchema();
1:     }
1: 
1:     @AfterClass
1:     public static void tearDown()
1:     {
1:         StorageService.instance.setPartitionerUnsafe(oldPartitioner);
0:         SchemaLoader.stopGossiper();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:554223b
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace1ranges = tableStrategyMap.get("Keyspace1").getAddressRanges();
1:         Collection<Range<Token>> ranges1 = keyspace1ranges.get(InetAddress.getByName("127.0.0.1"));
1:         Collection<Range<Token>> ranges2 = keyspace1ranges.get(InetAddress.getByName("127.0.0.2"));
1:         Collection<Range<Token>> ranges3 = keyspace1ranges.get(InetAddress.getByName("127.0.0.3"));
1:         Collection<Range<Token>> ranges4 = keyspace1ranges.get(InetAddress.getByName("127.0.0.4"));
1:         Collection<Range<Token>> ranges5 = keyspace1ranges.get(InetAddress.getByName("127.0.0.5"));
1:         Collection<Range<Token>> ranges6 = keyspace1ranges.get(InetAddress.getByName("127.0.0.6"));
1:         Collection<Range<Token>> ranges7 = keyspace1ranges.get(InetAddress.getByName("127.0.0.7"));
1:         Collection<Range<Token>> ranges8 = keyspace1ranges.get(InetAddress.getByName("127.0.0.8"));
1:         Collection<Range<Token>> ranges9 = keyspace1ranges.get(InetAddress.getByName("127.0.0.9"));
1:         Collection<Range<Token>> ranges10 = keyspace1ranges.get(InetAddress.getByName("127.0.0.10"));
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace3ranges = tableStrategyMap.get("Keyspace3").getAddressRanges();
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace4ranges = tableStrategyMap.get("Keyspace4").getAddressRanges();
/////////////////////////////////////////////////////////////////////////
1:     private Collection<Range<Token>> generateRanges(int... rangePairs)
1:         Set<Range<Token>> ranges = new HashSet<Range<Token>>();
/////////////////////////////////////////////////////////////////////////
1:     private Range<Token> generateRange(int left, int right)
1:         return new Range<Token>(new BigIntegerToken(String.valueOf(left)), new BigIntegerToken(String.valueOf(right)));
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
/////////////////////////////////////////////////////////////////////////
1:     private static final IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:ae03e1b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Before;
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:     public void clearTokenMetadata()
1:     {
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:         StorageService.instance.getTokenMetadata().clearUnsafe();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("mismatched number of moved token", 1, numMoved);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
1: 
/////////////////////////////////////////////////////////////////////////
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0:     private static final String KEYSPACE1 = "MoveTestKeyspace1";
1:     private static final String KEYSPACE2 = "MoveTestKeyspace2";
1:     private static final String KEYSPACE3 = "MoveTestKeyspace3";
0:     private static final String KEYSPACE4 = "MoveTestKeyspace4";
/////////////////////////////////////////////////////////////////////////
1:         SchemaLoader.schemaDefinition("MoveTest");
/////////////////////////////////////////////////////////////////////////
1:             keyspaceStrategyMap.put("MoveTestKeyspace" + i, getStrategy("MoveTestKeyspace" + i, tmd));
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace1ranges = keyspaceStrategyMap.get(KEYSPACE1).getAddressRanges();
/////////////////////////////////////////////////////////////////////////
1:         Multimap<InetAddress, Range<Token>> keyspace3ranges = keyspaceStrategyMap.get(KEYSPACE3).getAddressRanges();
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> keyspace4ranges = keyspaceStrategyMap.get(KEYSPACE4).getAddressRanges();
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.put(KEYSPACE1, HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
0:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
1:         expectedEndpoints.put(KEYSPACE2, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
1:         expectedEndpoints.put(KEYSPACE3, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.put(KEYSPACE4, HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2"));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:     public void testSimultaneousMove() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
commit:3020555
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, collectionSize(ranges1));
1:         assertEquals(generateRange(97, 0), ranges1.iterator().next());
1:         assertEquals(1, collectionSize(ranges2));
1:         assertEquals(generateRange(0, 10), ranges2.iterator().next());
1:         assertEquals(1, collectionSize(ranges3));
1:         assertEquals(generateRange(10, 20), ranges3.iterator().next());
1:         assertEquals(1, collectionSize(ranges4));
1:         assertEquals(generateRange(20, 30), ranges4.iterator().next());
1:         assertEquals(1, collectionSize(ranges5));
1:         assertEquals(generateRange(30, 40), ranges5.iterator().next());
1:         assertEquals(1, collectionSize(ranges6));
1:         assertEquals(generateRange(40, 50), ranges6.iterator().next());
1:         assertEquals(1, collectionSize(ranges7));
1:         assertEquals(generateRange(50, 67), ranges7.iterator().next());
1:         assertEquals(1, collectionSize(ranges8));
1:         assertEquals(generateRange(67, 70), ranges8.iterator().next());
1:         assertEquals(1, collectionSize(ranges9));
1:         assertEquals(generateRange(70, 87), ranges9.iterator().next());
1:         assertEquals(1, collectionSize(ranges10));
1:         assertEquals(generateRange(87, 97), ranges10.iterator().next());
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(expectedEndpoints.get(keyspaceName).get(token).size(), endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(4, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(4, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(5, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(4, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(4, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(3, endpoints.size());
1:             assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(endpointTokens.get(2), tmd.getToken(hosts.get(2)));
1:         assertEquals(newToken, tmd.getToken(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(newToken, tmd.getToken(hosts.get(2)));
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:e4d4472
commit:32dbe58
commit:d8c4e89
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a9bd531
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws IOException, ConfigurationException
commit:893d1da
/////////////////////////////////////////////////////////////////////////
0:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd =  DatabaseDescriptor.getKSMetaData(table);
0:                 ksmd.strategyClass,
0:                 ksmd.strategyOptions);
commit:133acbb
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigInteger;
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Test whether write endpoints is correct when the node is moving. Uses
1:     public void newTestWriteEndpointsDuringMove() throws Exception
1:         final int RING_SIZE = 10;
1:         final int MOVING_NODE = 3; // index of the moving node
/////////////////////////////////////////////////////////////////////////
1:         // node LEAVING_NODE should move to this token
1:         Token newToken = positionToken(MOVING_NODE);
1: 
1:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.moving(newToken));
1: 
1:         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
/////////////////////////////////////////////////////////////////////////
1:         // moving endpoint back to the normal state
0:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(newToken));
1:     /*
1:      * Test ranges and write endpoints when multiple nodes are on the move simultaneously
/////////////////////////////////////////////////////////////////////////
1:         final int[] MOVING = new int[] {6, 8, 9};
1: 
1:         Map<Integer, Token> newTokens = new HashMap<Integer, Token>();
1: 
1:         for (int movingIndex : MOVING)
1:         {
1:             Token newToken = positionToken(movingIndex);
1:             ss.onChange(hosts.get(movingIndex), ApplicationState.STATUS, valueFactory.moving(newToken));
1: 
1:             // storing token associated with a node index
1:             newTokens.put(movingIndex, newToken);
1:         }
1: 
1:         Collection<InetAddress> endpoints;
1: 
1:         tmd = tmd.cloneAfterAllSettled();
1:         ss.setTokenMetadataUnsafe(tmd);
/////////////////////////////////////////////////////////////////////////
1:         // don't require test update every time a new keyspace is added to test/conf/cassandra.yaml
1:         for (int i = 1; i <= 4; i++)
1:        /**
1:         *  Keyspace1 & Keyspace2 RF=1
1:         *  {
0:         *      /127.0.0.1=[(92,0]],
1:         *      /127.0.0.2=[(0,10]],
1:         *      /127.0.0.3=[(10,20]],
1:         *      /127.0.0.4=[(20,30]],
1:         *      /127.0.0.5=[(30,40]],
1:         *      /127.0.0.6=[(40,50]],
0:         *      /127.0.0.7=[(50,62]],
0:         *      /127.0.0.8=[(62,70]],
0:         *      /127.0.0.9=[(70,82]],
0:         *      /127.0.0.10=[(82,92]]
1:         *  }
1:         */
1: 
0:         Multimap<InetAddress, Range> keyspace1ranges = tableStrategyMap.get("Keyspace1").getAddressRanges();
0:         Collection<Range> ranges1 = keyspace1ranges.get(InetAddress.getByName("127.0.0.1"));
0:         assertEquals(collectionSize(ranges1), 1);
0:         assertTrue(ranges1.iterator().next().equals(generateRange(92, 0)));
0:         Collection<Range> ranges2 = keyspace1ranges.get(InetAddress.getByName("127.0.0.2"));
0:         assertEquals(collectionSize(ranges2), 1);
0:         assertTrue(ranges2.iterator().next().equals(generateRange(0, 10)));
0:         Collection<Range> ranges3 = keyspace1ranges.get(InetAddress.getByName("127.0.0.3"));
0:         assertEquals(collectionSize(ranges3), 1);
0:         assertTrue(ranges3.iterator().next().equals(generateRange(10, 20)));
0:         Collection<Range> ranges4 = keyspace1ranges.get(InetAddress.getByName("127.0.0.4"));
0:         assertEquals(collectionSize(ranges4), 1);
0:         assertTrue(ranges4.iterator().next().equals(generateRange(20, 30)));
0:         Collection<Range> ranges5 = keyspace1ranges.get(InetAddress.getByName("127.0.0.5"));
0:         assertEquals(collectionSize(ranges5), 1);
0:         assertTrue(ranges5.iterator().next().equals(generateRange(30, 40)));
0:         Collection<Range> ranges6 = keyspace1ranges.get(InetAddress.getByName("127.0.0.6"));
0:         assertEquals(collectionSize(ranges6), 1);
0:         assertTrue(ranges6.iterator().next().equals(generateRange(40, 50)));
0:         Collection<Range> ranges7 = keyspace1ranges.get(InetAddress.getByName("127.0.0.7"));
0:         assertEquals(collectionSize(ranges7), 1);
0:         assertTrue(ranges7.iterator().next().equals(generateRange(50, 62)));
0:         Collection<Range> ranges8 = keyspace1ranges.get(InetAddress.getByName("127.0.0.8"));
0:         assertEquals(collectionSize(ranges8), 1);
0:         assertTrue(ranges8.iterator().next().equals(generateRange(62, 70)));
0:         Collection<Range> ranges9 = keyspace1ranges.get(InetAddress.getByName("127.0.0.9"));
0:         assertEquals(collectionSize(ranges9), 1);
0:         assertTrue(ranges9.iterator().next().equals(generateRange(70, 82)));
0:         Collection<Range> ranges10 = keyspace1ranges.get(InetAddress.getByName("127.0.0.10"));
0:         assertEquals(collectionSize(ranges10), 1);
0:         assertTrue(ranges10.iterator().next().equals(generateRange(82, 92)));
1: 
1: 
1:         /**
1:         * Keyspace3 RF=5
1:         * {
0:         *      /127.0.0.1=[(92,0], (70,82], (50,62], (82,92], (62,70]],
0:         *      /127.0.0.2=[(92,0], (70,82], (82,92], (0,10], (62,70]],
0:         *      /127.0.0.3=[(92,0], (70,82], (82,92], (0,10], (10,20]],
0:         *      /127.0.0.4=[(92,0], (20,30], (82,92], (0,10], (10,20]],
0:         *      /127.0.0.5=[(92,0], (30,40], (20,30], (0,10], (10,20]],
1:         *      /127.0.0.6=[(40,50], (30,40], (20,30], (0,10], (10,20]],
0:         *      /127.0.0.7=[(40,50], (30,40], (50,62], (20,30], (10,20]],
0:         *      /127.0.0.8=[(40,50], (30,40], (50,62], (20,30], (62,70]],
0:         *      /127.0.0.9=[(40,50], (70,82], (30,40], (50,62], (62,70]],
0:         *      /127.0.0.10=[(40,50], (70,82], (50,62], (82,92], (62,70]]
1:         * }
1:         */
1: 
0:         Multimap<InetAddress, Range> keyspace3ranges = tableStrategyMap.get("Keyspace3").getAddressRanges();
1:         ranges1 = keyspace3ranges.get(InetAddress.getByName("127.0.0.1"));
1:         assertEquals(collectionSize(ranges1), 5);
0:         assertTrue(ranges1.equals(generateRanges(92, 0, 70, 82, 50, 62, 82, 92, 62, 70)));
1:         ranges2 = keyspace3ranges.get(InetAddress.getByName("127.0.0.2"));
1:         assertEquals(collectionSize(ranges2), 5);
0:         assertTrue(ranges2.equals(generateRanges(92, 0, 70, 82, 82, 92, 0, 10, 62, 70)));
1:         ranges3 = keyspace3ranges.get(InetAddress.getByName("127.0.0.3"));
1:         assertEquals(collectionSize(ranges3), 5);
0:         assertTrue(ranges3.equals(generateRanges(92, 0, 70, 82, 82, 92, 0, 10, 10, 20)));
1:         ranges4 = keyspace3ranges.get(InetAddress.getByName("127.0.0.4"));
1:         assertEquals(collectionSize(ranges4), 5);
0:         assertTrue(ranges4.equals(generateRanges(92, 0, 20, 30, 82, 92, 0, 10, 10, 20)));
1:         ranges5 = keyspace3ranges.get(InetAddress.getByName("127.0.0.5"));
1:         assertEquals(collectionSize(ranges5), 5);
0:         assertTrue(ranges5.equals(generateRanges(92, 0, 30, 40, 20, 30, 0, 10, 10, 20)));
1:         ranges6 = keyspace3ranges.get(InetAddress.getByName("127.0.0.6"));
1:         assertEquals(collectionSize(ranges6), 5);
1:         assertTrue(ranges6.equals(generateRanges(40, 50, 30, 40, 20, 30, 0, 10, 10, 20)));
1:         ranges7 = keyspace3ranges.get(InetAddress.getByName("127.0.0.7"));
1:         assertEquals(collectionSize(ranges7), 5);
0:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 62, 20, 30, 10, 20)));
1:         ranges8 = keyspace3ranges.get(InetAddress.getByName("127.0.0.8"));
1:         assertEquals(collectionSize(ranges8), 5);
0:         assertTrue(ranges8.equals(generateRanges(40, 50, 30, 40, 50, 62, 20, 30, 62, 70)));
1:         ranges9 = keyspace3ranges.get(InetAddress.getByName("127.0.0.9"));
1:         assertEquals(collectionSize(ranges9), 5);
0:         assertTrue(ranges9.equals(generateRanges(40, 50, 70, 82, 30, 40, 50, 62, 62, 70)));
1:         ranges10 = keyspace3ranges.get(InetAddress.getByName("127.0.0.10"));
1:         assertEquals(collectionSize(ranges10), 5);
0:         assertTrue(ranges10.equals(generateRanges(40, 50, 70, 82, 50, 62, 82, 92, 62, 70)));
1: 
1: 
1:         /**
1:          * Keyspace4 RF=3
1:          * {
0:          *      /127.0.0.1=[(92,0], (70,82], (82,92]],
0:          *      /127.0.0.2=[(92,0], (82,92], (0,10]],
0:          *      /127.0.0.3=[(92,0], (0,10], (10,20]],
1:          *      /127.0.0.4=[(20,30], (0,10], (10,20]],
1:          *      /127.0.0.5=[(30,40], (20,30], (10,20]],
1:          *      /127.0.0.6=[(40,50], (30,40], (20,30]],
0:          *      /127.0.0.7=[(40,50], (30,40], (50,62]],
0:          *      /127.0.0.8=[(40,50], (50,62], (62,70]],
0:          *      /127.0.0.9=[(70,82], (50,62], (62,70]],
0:          *      /127.0.0.10=[(70,82], (82,92], (62,70]]
1:          *  }
1:          */
0:         Multimap<InetAddress, Range> keyspace4ranges = tableStrategyMap.get("Keyspace4").getAddressRanges();
1:         ranges1 = keyspace4ranges.get(InetAddress.getByName("127.0.0.1"));
1:         assertEquals(collectionSize(ranges1), 3);
0:         assertTrue(ranges1.equals(generateRanges(92, 0, 70, 82, 82, 92)));
1:         ranges2 = keyspace4ranges.get(InetAddress.getByName("127.0.0.2"));
1:         assertEquals(collectionSize(ranges2), 3);
0:         assertTrue(ranges2.equals(generateRanges(92, 0, 82, 92, 0, 10)));
1:         ranges3 = keyspace4ranges.get(InetAddress.getByName("127.0.0.3"));
1:         assertEquals(collectionSize(ranges3), 3);
0:         assertTrue(ranges3.equals(generateRanges(92, 0, 0, 10, 10, 20)));
1:         ranges4 = keyspace4ranges.get(InetAddress.getByName("127.0.0.4"));
1:         assertEquals(collectionSize(ranges4), 3);
1:         assertTrue(ranges4.equals(generateRanges(20, 30, 0, 10, 10, 20)));
1:         ranges5 = keyspace4ranges.get(InetAddress.getByName("127.0.0.5"));
1:         assertEquals(collectionSize(ranges5), 3);
1:         assertTrue(ranges5.equals(generateRanges(30, 40, 20, 30, 10, 20)));
1:         ranges6 = keyspace4ranges.get(InetAddress.getByName("127.0.0.6"));
1:         assertEquals(collectionSize(ranges6), 3);
1:         assertTrue(ranges6.equals(generateRanges(40, 50, 30, 40, 20, 30)));
1:         ranges7 = keyspace4ranges.get(InetAddress.getByName("127.0.0.7"));
1:         assertEquals(collectionSize(ranges7), 3);
0:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 62)));
1:         ranges8 = keyspace4ranges.get(InetAddress.getByName("127.0.0.8"));
1:         assertEquals(collectionSize(ranges8), 3);
0:         assertTrue(ranges8.equals(generateRanges(40, 50, 50, 62, 62, 70)));
1:         ranges9 = keyspace4ranges.get(InetAddress.getByName("127.0.0.9"));
1:         assertEquals(collectionSize(ranges9), 3);
0:         assertTrue(ranges9.equals(generateRanges(70, 82, 50, 62, 62, 70)));
1:         ranges10 = keyspace4ranges.get(InetAddress.getByName("127.0.0.10"));
1:         assertEquals(collectionSize(ranges10), 3);
0:         assertTrue(ranges10.equals(generateRanges(70, 82, 82, 92, 62, 70)));
1: 
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10"));
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2"));
/////////////////////////////////////////////////////////////////////////
1:             for (Token token : keyTokens)
0:                 endpoints = tmd.getWriteEndpoints(token, table, strategy.getNaturalEndpoints(token));
0:                 assertTrue(expectedEndpoints.get(table).get(token).size() == endpoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(token).containsAll(endpoints));
1: 
1:             for (int i = 0; i < 3; i++)
/////////////////////////////////////////////////////////////////////////
1:             // token 35 should go to nodes 4, 5, 6 and boot1
0:             assertTrue(endpoints.size() == 4);
1:             // token 45 should go to nodes 5, 6, 7 boot1
0:             assertTrue(endpoints.size() == 4);
1:             // token 55 should go to nodes 6, 7, 8 boot1 and boot2
0:             assertTrue(endpoints.size() == 5);
0:             // token 65 should go to nodes 7, 8, 9 and boot2
0:             assertTrue(endpoints.size() == 4);
1:             // token 75 should to go nodes 8, 9, 0 and boot2
0:             assertTrue(endpoints.size() == 4);
0:             // token 85 should go to nodes 9, 0, 1
0:             assertTrue(endpoints.size() == 3);
/////////////////////////////////////////////////////////////////////////
1:         // all moving nodes are back to the normal state
1:         for (Integer movingIndex : MOVING)
0:             ss.onChange(hosts.get(movingIndex), ApplicationState.STATUS, valueFactory.normal(newTokens.get(movingIndex)));
/////////////////////////////////////////////////////////////////////////
1:         // create a ring or 6 nodes
1:         Token newToken = positionToken(7);
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.moving(newToken));
1:         assertTrue(tmd.isMoving(hosts.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));
1:         assertTrue(tmd.getMovingEndpoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(newToken));
1:         newToken = positionToken(8);
1:         // node 2 goes through leave and left and then jumps to normal at its new token
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.moving(newToken));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));
1:         assertTrue(tmd.getMovingEndpoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(newToken));
/////////////////////////////////////////////////////////////////////////
1:     private Token positionToken(int position)
1:     {
0:         return new BigIntegerToken(String.valueOf(10 * position + 2));
1:     }
1: 
1:     private int collectionSize(Collection<?> collection)
1:     {
1:         if (collection.isEmpty())
1:             return 0;
1: 
1:         Iterator<?> iterator = collection.iterator();
1: 
1:         int count = 0;
1:         while (iterator.hasNext())
1:         {
1:             iterator.next();
1:             count++;
1:         }
1: 
1:         return count;
1:     }
1: 
0:     private Collection<Range> generateRanges(int... rangePairs)
1:     {
1:         if (rangePairs.length % 2 == 1)
1:             throw new RuntimeException("generateRanges argument count should be even");
1: 
0:         Set<Range> ranges = new HashSet<Range>();
1: 
1:         for (int i = 0; i < rangePairs.length; i+=2)
1:         {
1:             ranges.add(generateRange(rangePairs[i], rangePairs[i+1]));
1:         }
1: 
1:         return ranges;
1:     }
1: 
0:     private Range generateRange(int left, int right)
1:     {
0:         return new Range(new BigIntegerToken(String.valueOf(left)), new BigIntegerToken(String.valueOf(right)));
1:     }
commit:2f5f0c2
/////////////////////////////////////////////////////////////////////////
1:                 int replicationFactor = strategy.getReplicationFactor();
/////////////////////////////////////////////////////////////////////////
1:             if (strategy.getReplicationFactor() != 3)
/////////////////////////////////////////////////////////////////////////
0:             if (strategy.getReplicationFactor() != 3)
commit:389bac7
/////////////////////////////////////////////////////////////////////////
1:                 Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token, false);
commit:89fbc1b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.gms.VersionedValue;
/////////////////////////////////////////////////////////////////////////
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
1:                 ApplicationState.STATUS,
0:                 valueFactory.leaving(endpointTokens.get(LEAVING_NODE)));
/////////////////////////////////////////////////////////////////////////
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(hosts.get(leaving), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(leaving)));
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5)));
0:         ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(LEAVING[0]), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(LEAVING[0])));
0:         ss.onChange(hosts.get(LEAVING[2]), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(LEAVING[2])));
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(4)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(3)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(3)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
0:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(0)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(2)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(ep, ApplicationState.STATUS, new VersionedValue.VersionedValueFactory(partitioner).normal(endpointTokens.get(i)));
commit:629fa9e
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:                 ApplicationState.STATE_MOVE,
0:                 stateFactory.leaving(endpointTokens.get(LEAVING_NODE)));
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(hosts.get(leaving), ApplicationState.STATE_MOVE, stateFactory.leaving(endpointTokens.get(leaving)));
0:         ss.onChange(boot1, ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(5)));
0:         ss.onChange(boot2, ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(LEAVING[0]), ApplicationState.STATE_MOVE, stateFactory.left(endpointTokens.get(LEAVING[0])));
0:         ss.onChange(hosts.get(LEAVING[2]), ApplicationState.STATE_MOVE, stateFactory.left(endpointTokens.get(LEAVING[2])));
0:         ss.onChange(boot1, ApplicationState.STATE_MOVE, stateFactory.normal(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.leaving(endpointTokens.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(4)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(3)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.normal(keyTokens.get(3)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATE_MOVE, stateFactory.normal(keyTokens.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.leaving(endpointTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.normal(keyTokens.get(2)));
0:         // node 3 goes through leave and left and then jumps to normal at its new token
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.leaving(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.left(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.normal(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.leaving(keyTokens.get(0)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.leaving(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.left(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:         ApplicationState.ApplicationStateFactory stateFactory = new ApplicationState.ApplicationStateFactory(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.left(endpointTokens.get(2)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATE_MOVE, stateFactory.bootstrapping(keyTokens.get(1)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATE_MOVE, stateFactory.left(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(ep, ApplicationState.STATE_MOVE, new ApplicationState.ApplicationStateFactory(partitioner).normal(endpointTokens.get(i)));
commit:916c810
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 "org.apache.cassandra.locator.SimpleStrategy",
commit:0789a58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.Pair;
/////////////////////////////////////////////////////////////////////////
0:     public void newTestWriteEndpointsDuringLeave() throws Exception
0:         final int RING_SIZE = 6;
0:         final int LEAVING_NODE = 3;
/////////////////////////////////////////////////////////////////////////
0:         final Map<Pair<String, Token>, List<InetAddress>> expectedEndpoints = new HashMap<Pair<String, Token>, List<InetAddress>>();
1:             for (Token token : keyTokens)
1:             {
1:                 List<InetAddress> endpoints = new ArrayList<InetAddress>();
0:                 Pair<String, Token> key = new Pair<String, Token>(table, token);
0:                 Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token);
1:                 while (tokenIter.hasNext())
1:                 {
1:                     endpoints.add(tmd.getEndpoint(tokenIter.next()));
1:                 }
0:                 expectedEndpoints.put(key, endpoints);
1:             }
1: 
1:             for (Token token : keyTokens)
0:                 Pair<String, Token> key = new Pair<String, Token>(table, token);
0:                 int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
0:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, testStrategy.calculateNaturalEndpoints(token, tmd, table)));
1:                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
1:                 for (int i = 0; i < replicationFactor; i++)
1:                 {
0:                     expected.add(expectedEndpoints.get(key).get(i));
1:                 }
1: 
0:                 // if the leaving node is in the endpoint list,
0:                 // then we should expect it plus one extra for when it's gone
0:                 if (expected.contains(hosts.get(LEAVING_NODE)))
0:                     expected.add(expectedEndpoints.get(key).get(replicationFactor));
1: 
1:                 assertEquals("mismatched endpoint sets", expected, actual);
/////////////////////////////////////////////////////////////////////////
0:         final int[] LEAVING = new int[] {6, 8, 9};
/////////////////////////////////////////////////////////////////////////
0:         /* don't require test update every time a new keyspace is added to test/conf/cassandra.yaml */
0:         List<String> tables = Arrays.asList("Keyspace1", "Keyspace2", "Keyspace3", "Keyspace4");
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (String table : tables)
/////////////////////////////////////////////////////////////////////////
0:         for (String table : tables)
/////////////////////////////////////////////////////////////////////////
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
/////////////////////////////////////////////////////////////////////////
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
/////////////////////////////////////////////////////////////////////////
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
/////////////////////////////////////////////////////////////////////////
0:         // create a ring of 6 nodes
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
commit:d8755b3
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import org.junit.Test;
1: 
0: import static org.junit.Assert.*;
0: import org.apache.cassandra.dht.*;
1: import org.apache.cassandra.gms.ApplicationState;
1: import org.apache.cassandra.locator.SimpleSnitch;
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:                 Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
0:     public void testWriteEndpointsDuringLeave() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(LEAVING_NODE), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING_NODE))));
/////////////////////////////////////////////////////////////////////////
0:                 Collection<InetAddress> endpoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                     assertTrue(endpoints.size() == replicationFactor + 1);
0:                     assertTrue(endpoints.size() == replicationFactor);
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
0:             ss.onChange(hosts.get(leaving), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(leaving))));
/////////////////////////////////////////////////////////////////////////
0:         Collection<InetAddress> endpoints = null;
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endpoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(endpoints.size() == 3);
1:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:                 assertTrue(endpoints.contains(hosts.get(i+3)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
0:             assertTrue(endpoints.size() == 5);
1:             assertTrue(endpoints.contains(hosts.get(4)));
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(boot1));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(boot2));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
0:             assertTrue(endpoints.size() == 7);
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(boot2));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(boot2));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
1:             assertTrue(endpoints.contains(boot2));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
0:             assertTrue(endpoints.size() == 4);
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
0:         ss.onChange(hosts.get(LEAVING[0]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING[0]))));
0:         ss.onChange(hosts.get(LEAVING[2]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING[2]))));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endpoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(endpoints.size() == 3);
0:                 assertTrue(endpoints.contains(hosts.get(i+1)));
0:                 assertTrue(endpoints.contains(hosts.get(i+2)));
0:                 assertTrue(endpoints.contains(hosts.get(i+3)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
0:             assertTrue(endpoints.size() == 3);
0:             assertTrue(endpoints.contains(hosts.get(4)));
0:             assertTrue(endpoints.contains(hosts.get(5)));
0:             assertTrue(endpoints.contains(boot1));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
0:             assertTrue(endpoints.size() == 3);
0:             assertTrue(endpoints.contains(hosts.get(5)));
0:             assertTrue(endpoints.contains(boot1));
0:             assertTrue(endpoints.contains(hosts.get(7)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
0:             assertTrue(endpoints.size() == 5);
0:             assertTrue(endpoints.contains(boot1));
0:             assertTrue(endpoints.contains(hosts.get(7)));
0:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
0:             assertTrue(endpoints.contains(hosts.get(0)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
0:             assertTrue(endpoints.size() == 5);
0:             assertTrue(endpoints.contains(hosts.get(7)));
0:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
0:             assertTrue(endpoints.contains(hosts.get(0)));
0:             assertTrue(endpoints.contains(hosts.get(1)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
0:             assertTrue(endpoints.size() == 5);
0:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
0:             assertTrue(endpoints.contains(hosts.get(0)));
0:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
0:             assertTrue(endpoints.size() == 3);
0:             assertTrue(endpoints.contains(hosts.get(0)));
0:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
0:             endpoints = testStrategy.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
0:             assertTrue(endpoints.size() == 3);
0:             assertTrue(endpoints.contains(hosts.get(0)));
0:             assertTrue(endpoints.contains(hosts.get(1)));
0:             assertTrue(endpoints.contains(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 5);
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 5);
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(2))));
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(endpointTokens.get(2)));
0:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 5);
0:         assertTrue(tmd.getEndpoint(endpointTokens.get(2)) == null);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(tmd.getEndpoint(keyTokens.get(1)).equals(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 5);
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
0:     private void createInitialRing(StorageService ss, IPartitioner partitioner, List<Token> endpointTokens,
0:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
0:         for (int i=0; i<endpointTokens.size(); i++)
0:             ss.onChange(ep, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(i))));
0:         for (int i=0; i<endpointTokens.size(); ++i)
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
1:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
1:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
1:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
0:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
0:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
0:         StorageService ss = StorageService.instance;
commit:720c49a
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: 
1: package org.apache.cassandra.service;
1: 
0: import java.util.*;
1: 
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: 
0: import org.junit.Test;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.assertFalse;
1: 
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.RandomPartitioner;
0: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.dht.BigIntegerToken;
1: import org.apache.cassandra.locator.AbstractReplicationStrategy;
0: import org.apache.cassandra.locator.RackUnawareStrategy;
1: import org.apache.cassandra.locator.TokenMetadata;
0: import org.apache.cassandra.gms.ApplicationState;
1: 
0: public class MoveTest
1: {
0:     /**
0:      * Test whether write endpoints is correct when the node is leaving. Uses
1:      * StorageService.onChange and does not manipulate token metadata directly.
1:      */
1:     @Test
0:     public void testWriteEndPointsDuringLeave() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 5);
1: 
1:         // Third node leaves
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(2))));
1: 
0:         // check that it is correctly marked as leaving in tmd
0:         assertTrue(tmd.isLeaving(hosts.get(2)));
1: 
0:         // check that pending ranges are correct (primary range should go to 1st node, first
0:         // replica range to 4th node and 2nd replica range to 5th node)
0:         assertTrue(tmd.getPendingRanges(hosts.get(0)).get(0).equals(new Range(endPointTokens.get(1),
0:                                                                               endPointTokens.get(2))));
0:         assertTrue(tmd.getPendingRanges(hosts.get(3)).get(0).equals(new Range(endPointTokens.get(4),
0:                                                                               endPointTokens.get(0))));
0:         assertTrue(tmd.getPendingRanges(hosts.get(4)).get(0).equals(new Range(endPointTokens.get(0),
0:                                                                               endPointTokens.get(1))));
1: 
0:         for (int i=0; i<keyTokens.size(); ++i)
1:         {
0:             Collection<InetAddress> endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), testStrategy.getNaturalEndpoints(keyTokens.get(i)));
1: 
0:             // Original third node does not store replicas for 4th and 5th node (ranges 20-30
0:             // and 30-40 respectively), so their write endpoints count should be still 3. The
0:             // third node stores data for ranges 40-0, 0-10 and 10-20, so writes falling to
0:             // these ranges should have four endpoints now. keyTokens[2] is 25 and keyTokens[3]
0:             // is 35, so these are the ones that should have 3 endpoints.
0:             if (i==2 || i==3)
0:                 assertTrue(endPoints.size() == 3);
0:             else
0:                 assertTrue(endPoints.size() == 4);
1:         }
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
0:     /**
0:      * Test pending ranges and write endpoints when multiple nodes are on the move
0:      * simultaneously
1:      */
1:     @Test
0:     public void testSimultaneousMove() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring or 10 nodes
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 10);
1: 
1:         // nodes 6, 8 and 9 leave
0:         ss.onChange(hosts.get(6), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(6))));
0:         ss.onChange(hosts.get(8), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(8))));
0:         ss.onChange(hosts.get(9), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(9))));
1:         
1:         // boot two new nodes with keyTokens.get(5) and keyTokens.get(7)
1:         InetAddress boot1 = InetAddress.getByName("127.0.1.1");
0:         ss.onChange(boot1, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(5))));
1:         InetAddress boot2 = InetAddress.getByName("127.0.1.2");
0:         ss.onChange(boot2, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(7))));
1: 
0:         Collection<InetAddress> endPoints = null;
1: 
1:         // tokens 5, 15 and 25 should go three nodes
0:         for (int i=0; i<3; ++i)
1:         {
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), testStrategy.getNaturalEndpoints(keyTokens.get(i)));
0:             assertTrue(endPoints.size() == 3);
0:             assertTrue(endPoints.contains(hosts.get(i+1)));
0:             assertTrue(endPoints.contains(hosts.get(i+2)));
0:             assertTrue(endPoints.contains(hosts.get(i+3)));
1:         }
1: 
0:         // token 35 should go to nodes 4, 5, 6, 7 and boot1
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(3), testStrategy.getNaturalEndpoints(keyTokens.get(3)));
0:         assertTrue(endPoints.size() == 5);
0:         assertTrue(endPoints.contains(hosts.get(4)));
0:         assertTrue(endPoints.contains(hosts.get(5)));
0:         assertTrue(endPoints.contains(hosts.get(6)));
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(boot1));
1: 
0:         // token 45 should go to nodes 5, 6, 7, 0, boot1 and boot2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(4), testStrategy.getNaturalEndpoints(keyTokens.get(4)));
0:         assertTrue(endPoints.size() == 6);
0:         assertTrue(endPoints.contains(hosts.get(5)));
0:         assertTrue(endPoints.contains(hosts.get(6)));
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(boot1));
0:         assertTrue(endPoints.contains(boot2));
1: 
0:         // token 55 should go to nodes 6, 7, 8, 0, 1, boot1 and boot2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(5), testStrategy.getNaturalEndpoints(keyTokens.get(5)));
0:         assertTrue(endPoints.size() == 7);
0:         assertTrue(endPoints.contains(hosts.get(6)));
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(boot1));
0:         assertTrue(endPoints.contains(boot2));
1: 
0:         // token 65 should go to nodes 7, 8, 9, 0, 1 and boot2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(6), testStrategy.getNaturalEndpoints(keyTokens.get(6)));
0:         assertTrue(endPoints.size() == 6);
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(9)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(boot2));
1: 
0:         // token 75 should to go nodes 8, 9, 0, 1, 2 and boot2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(7), testStrategy.getNaturalEndpoints(keyTokens.get(7)));
0:         assertTrue(endPoints.size() == 6);
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(9)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
0:         assertTrue(endPoints.contains(boot2));
1: 
0:         // token 85 should go to nodes 9, 0, 1 and 2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(8), testStrategy.getNaturalEndpoints(keyTokens.get(8)));
0:         assertTrue(endPoints.size() == 4);
0:         assertTrue(endPoints.contains(hosts.get(9)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
1: 
0:         // token 95 should go to nodes 0, 1 and 2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(9), testStrategy.getNaturalEndpoints(keyTokens.get(9)));
0:         assertTrue(endPoints.size() == 3);
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
1: 
0:         // Now finish node 6 and node 9 leaving, as well as boot1 (after this node 8 is still
0:         // leaving and boot2 in progress
0:         ss.onChange(hosts.get(6), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(6))));
0:         ss.onChange(hosts.get(9), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(9))));
0:         ss.onChange(boot1, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(5))));
1: 
1:         // tokens 5, 15 and 25 should go three nodes
0:         for (int i=0; i<3; ++i)
1:         {
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), testStrategy.getNaturalEndpoints(keyTokens.get(i)));
0:             assertTrue(endPoints.size() == 3);
0:             assertTrue(endPoints.contains(hosts.get(i+1)));
0:             assertTrue(endPoints.contains(hosts.get(i+2)));
0:             assertTrue(endPoints.contains(hosts.get(i+3)));
1:         }
1: 
0:         // token 35 goes to nodes 4, 5 and boot1
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(3), testStrategy.getNaturalEndpoints(keyTokens.get(3)));
0:         assertTrue(endPoints.size() == 3);
0:         assertTrue(endPoints.contains(hosts.get(4)));
0:         assertTrue(endPoints.contains(hosts.get(5)));
0:         assertTrue(endPoints.contains(boot1));
1: 
0:         // token 45 goes to nodes 5, boot1 and node7
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(4), testStrategy.getNaturalEndpoints(keyTokens.get(4)));
0:         assertTrue(endPoints.size() == 3);
0:         assertTrue(endPoints.contains(hosts.get(5)));
0:         assertTrue(endPoints.contains(boot1));
0:         assertTrue(endPoints.contains(hosts.get(7)));
1: 
0:         // token 55 goes to boot1, 7, boot2, 8 and 0
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(5), testStrategy.getNaturalEndpoints(keyTokens.get(5)));
0:         assertTrue(endPoints.size() == 5);
0:         assertTrue(endPoints.contains(boot1));
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(boot2));
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
1: 
0:         // token 65 goes to nodes 7, boot2, 8, 0 and 1
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(6), testStrategy.getNaturalEndpoints(keyTokens.get(6)));
0:         assertTrue(endPoints.size() == 5);
0:         assertTrue(endPoints.contains(hosts.get(7)));
0:         assertTrue(endPoints.contains(boot2));
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
1: 
0:         // token 75 goes to nodes boot2, 8, 0, 1 and 2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(7), testStrategy.getNaturalEndpoints(keyTokens.get(7)));
0:         assertTrue(endPoints.size() == 5);
0:         assertTrue(endPoints.contains(boot2));
0:         assertTrue(endPoints.contains(hosts.get(8)));
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
1: 
0:         // token 85 goes to nodes 0, 1 and 2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(8), testStrategy.getNaturalEndpoints(keyTokens.get(8)));
0:         assertTrue(endPoints.size() == 3);
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
1: 
0:         // token 95 goes to nodes 0, 1 and 2
0:         endPoints = testStrategy.getWriteEndpoints(keyTokens.get(9), testStrategy.getNaturalEndpoints(keyTokens.get(9)));
0:         assertTrue(endPoints.size() == 3);
0:         assertTrue(endPoints.contains(hosts.get(0)));
0:         assertTrue(endPoints.contains(hosts.get(1)));
0:         assertTrue(endPoints.contains(hosts.get(2)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
1:     @Test
0:     public void testStateJumpToBootstrap() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         // create a ring or 5 nodes
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 5);
1: 
1:         // node 2 leaves
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(2))));
1: 
0:         // don't bother to test pending ranges here, that is extensively tested by other
0:         // tests. Just check that the node is in appropriate lists.
0:         assertTrue(tmd.isMember(hosts.get(2)));
0:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
0:         // Bootstrap the node immedidiately to keyTokens.get(4) without going through STATE_LEFT
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(4))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(2)));
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)).equals(hosts.get(2)));
1: 
0:         // Bootstrap node hosts.get(3) to keyTokens.get(1)
0:         ss.onChange(hosts.get(3), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(3)));
0:         assertFalse(tmd.isLeaving(hosts.get(3)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)).equals(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
0:         // Bootstrap node hosts.get(2) further to keyTokens.get(3)
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(3))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(2)));
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(3)).equals(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)) == null);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
0:         // Go to normal again for both nodes
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(3))));
0:         ss.onChange(hosts.get(3), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(2))));
1: 
0:         assertTrue(tmd.isMember(hosts.get(2)));
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(3)));
0:         assertTrue(tmd.isMember(hosts.get(3)));
0:         assertFalse(tmd.isLeaving(hosts.get(3)));
0:         assertTrue(tmd.getToken(hosts.get(3)).equals(keyTokens.get(2)));
1: 
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
1:     @Test
1:     public void testStateJumpToNormal() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         // create a ring or 5 nodes
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 5);
1: 
1:         // node 2 leaves
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(2))));
1: 
0:         assertTrue(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(endPointTokens.get(2)));
1: 
1:         // back to normal
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(2))));
1: 
0:         assertTrue(tmd.getLeavingEndPoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(2)));
1: 
0:         // node 3 goes through leave and left and then jumps to normal
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(2))));
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(2))));
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(4))));
1: 
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
0:         assertTrue(tmd.getLeavingEndPoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(4)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
1:     @Test
0:     public void testStateJumpToLeaving() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         // create a ring or 5 nodes
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 5);
1: 
0:         // node 2 leaves with _different_ token
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(0))));
1: 
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(0)));
0:         assertTrue(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getEndPoint(endPointTokens.get(2)) == null);
1: 
0:         // go to boostrap
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().size() == 1);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(2)));
1: 
0:         // jump to leaving again
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertTrue(tmd.getEndPoint(keyTokens.get(1)).equals(hosts.get(2)));
0:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
0:         // go to state left
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(2)));
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
1:     @Test
0:     public void testStateJumpToLeft() throws UnknownHostException
1:     {
0:         StorageService ss = StorageService.instance();
1:         TokenMetadata tmd = ss.getTokenMetadata();
0:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, partitioner, 3);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
0:         AbstractReplicationStrategy oldStrategy = ss.setReplicationStrategyUnsafe(testStrategy);
1: 
0:         ArrayList<Token> endPointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         // create a ring or 5 nodes
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, 5);
1: 
0:         // node hosts.get(2) goes jumps to left
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(2))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(2)));
1: 
0:         // node hosts.get(4) goes to bootstrap
0:         ss.onChange(hosts.get(3), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertFalse(tmd.isMember(hosts.get(3)));
0:         assertTrue(tmd.getBootstrapTokens().size() == 1);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
0:         // and then directly to 'left'
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
1: 
0:         assertTrue(tmd.getBootstrapTokens().size() == 0);
0:         assertFalse(tmd.isMember(hosts.get(2)));
0:         assertFalse(tmd.isLeaving(hosts.get(2)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
0:         ss.setReplicationStrategyUnsafe(oldStrategy);
1:     }
1: 
0:     /**
0:      * Creates initial set of nodes and tokens. Nodes are added to StorageService as 'normal'
1:      */
0:     private void createInitialRing(StorageService ss, IPartitioner partitioner, List<Token> endPointTokens,
0:                                    List<Token> keyTokens, List<InetAddress> hosts, int howMany)
0:         throws UnknownHostException
1:     {
0:         for (int i=0; i<howMany; i++)
1:         {
0:             endPointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
0:             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
1:         }
1: 
0:         for (int i=0; i<endPointTokens.size(); i++)
1:         {
0:             InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
0:             ss.onChange(ep, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(i))));
0:             hosts.add(ep);
1:         }
1: 
0:         // check that all nodes are in token metadata
0:         for (int i=0; i<endPointTokens.size(); ++i)
0:             assertTrue(ss.getTokenMetadata().isMember(hosts.get(i)));
1:     }
1: 
1: }
author:Brandon Williams
-------------------------------------------------------------------------------
commit:4ff5b0f
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:             PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
commit:9342ddd
commit:e1206f3
/////////////////////////////////////////////////////////////////////////
0:         for (Token token : keyTokens)
0:             List<InetAddress> endpoints = new ArrayList<InetAddress>();
0:             Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token, false);
0:             while (tokenIter.hasNext())
0:                 endpoints.add(tmd.getEndpoint(tokenIter.next()));
1:             expectedEndpoints.put(token, endpoints);
/////////////////////////////////////////////////////////////////////////
1:             int numMoved = 0;
/////////////////////////////////////////////////////////////////////////
1:                 if (expected.size() == actual.size()) {
1:                 	assertEquals("mismatched endpoint sets", expected, actual);
1:                 } else {
1:                 	expected.add(hosts.get(MOVING_NODE));
1:                 	assertEquals("mismatched endpoint sets", expected, actual);
1:                 	numMoved++;
1:                 }
0:             assertEquals("mismatched number of moved token", numMoved, 1);
/////////////////////////////////////////////////////////////////////////
1:         *      /127.0.0.1=[(97,0]],
1:         *      /127.0.0.7=[(50,67]],
1:         *      /127.0.0.8=[(67,70]],
1:         *      /127.0.0.9=[(70,87]],
1:         *      /127.0.0.10=[(87,97]]
0:         assertTrue(ranges1.iterator().next().equals(generateRange(97, 0)));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(ranges7.iterator().next().equals(generateRange(50, 67)));
0:         assertTrue(ranges8.iterator().next().equals(generateRange(67, 70)));
0:         assertTrue(ranges9.iterator().next().equals(generateRange(70, 87)));
0:         assertTrue(ranges10.iterator().next().equals(generateRange(87, 97)));
1:         *      /127.0.0.1=[(97,0], (70,87], (50,67], (87,97], (67,70]],
1:         *      /127.0.0.2=[(97,0], (70,87], (87,97], (0,10], (67,70]],
1:         *      /127.0.0.3=[(97,0], (70,87], (87,97], (0,10], (10,20]],
1:         *      /127.0.0.4=[(97,0], (20,30], (87,97], (0,10], (10,20]],
1:         *      /127.0.0.5=[(97,0], (30,40], (20,30], (0,10], (10,20]],
1:         *      /127.0.0.7=[(40,50], (30,40], (50,67], (20,30], (10,20]],
1:         *      /127.0.0.8=[(40,50], (30,40], (50,67], (20,30], (67,70]],
1:         *      /127.0.0.9=[(40,50], (70,87], (30,40], (50,67], (67,70]],
1:         *      /127.0.0.10=[(40,50], (70,87], (50,67], (87,97], (67,70]]
1:         assertTrue(ranges1.equals(generateRanges(97, 0, 70, 87, 50, 67, 87, 97, 67, 70)));
1:         assertTrue(ranges2.equals(generateRanges(97, 0, 70, 87, 87, 97, 0, 10, 67, 70)));
1:         assertTrue(ranges3.equals(generateRanges(97, 0, 70, 87, 87, 97, 0, 10, 10, 20)));
1:         assertTrue(ranges4.equals(generateRanges(97, 0, 20, 30, 87, 97, 0, 10, 10, 20)));
1:         assertTrue(ranges5.equals(generateRanges(97, 0, 30, 40, 20, 30, 0, 10, 10, 20)));
1:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 67, 20, 30, 10, 20)));
1:         assertTrue(ranges8.equals(generateRanges(40, 50, 30, 40, 50, 67, 20, 30, 67, 70)));
1:         assertTrue(ranges9.equals(generateRanges(40, 50, 70, 87, 30, 40, 50, 67, 67, 70)));
1:         assertTrue(ranges10.equals(generateRanges(40, 50, 70, 87, 50, 67, 87, 97, 67, 70)));
1:          *      /127.0.0.1=[(97,0], (70,87], (87,97]],
1:          *      /127.0.0.2=[(97,0], (87,97], (0,10]],
1:          *      /127.0.0.3=[(97,0], (0,10], (10,20]],
1:          *      /127.0.0.7=[(40,50], (30,40], (50,67]],
1:          *      /127.0.0.8=[(40,50], (50,67], (67,70]],
1:          *      /127.0.0.9=[(70,87], (50,67], (67,70]],
1:          *      /127.0.0.10=[(70,87], (87,97], (67,70]]
1:         assertTrue(ranges1.equals(generateRanges(97, 0, 70, 87, 87, 97)));
1:         assertTrue(ranges2.equals(generateRanges(97, 0, 87, 97, 0, 10)));
1:         assertTrue(ranges3.equals(generateRanges(97, 0, 0, 10, 10, 20)));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(ranges7.equals(generateRanges(40, 50, 30, 40, 50, 67)));
1:         assertTrue(ranges8.equals(generateRanges(40, 50, 50, 67, 67, 70)));
1:         assertTrue(ranges9.equals(generateRanges(70, 87, 50, 67, 67, 70)));
1:         assertTrue(ranges10.equals(generateRanges(70, 87, 87, 97, 67, 70)));
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10"));
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4"));
/////////////////////////////////////////////////////////////////////////
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2"));
/////////////////////////////////////////////////////////////////////////
1:             // token 65 should go to nodes 6, 7, 8 and boot2
1:             assertTrue(endpoints.contains(hosts.get(6)));
/////////////////////////////////////////////////////////////////////////
1:             // token 85 should go to nodes 8, 9 and 0
0:             assertTrue(endpoints.contains(hosts.get(8)));
0:             assertTrue(endpoints.contains(hosts.get(9)));
0:             assertTrue(endpoints.contains(hosts.get(0)));
0: 
1:             // token 95 should go to nodes 9, 0 and 1
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, strategy.getNaturalEndpoints(keyTokens.get(9)));
0:             assertTrue(endpoints.size() == 3);
/////////////////////////////////////////////////////////////////////////
1:         return new BigIntegerToken(String.valueOf(10 * position + 7));
commit:b475bc6
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.initializeNodeUnsafe(boot1, UUID.randomUUID(), 1);
1:         Gossiper.instance.injectApplicationState(boot1, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(5))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5))));
1:         Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
1:         Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
/////////////////////////////////////////////////////////////////////////
1:                         valueFactory.normal(Collections.singleton(newTokens.get(movingIndex))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
commit:877a8ca
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.gms.Gossiper;
/////////////////////////////////////////////////////////////////////////
0:         Gossiper.instance.initializeNodeUnsafe(boot1, 1);
0:         Gossiper.instance.initializeNodeUnsafe(boot2, 1);
author:Eric Evans
-------------------------------------------------------------------------------
commit:66b96ee
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken), hostIds.get(MOVING_NODE)));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(boot1,
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5)), UUID.randomUUID()));
1:         ss.onChange(boot2,
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7)), UUID.randomUUID()));
/////////////////////////////////////////////////////////////////////////
1:             ss.onChange(hosts.get(movingIndex),
0:                         ApplicationState.STATUS,
0:                         valueFactory.normal(Collections.singleton(newTokens.get(movingIndex)), hostIds.get(movingIndex)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken),
0:                                                                                hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken),
0:                                                                                hostIds.get(2)));
commit:ad685c4
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(newToken, hostIds.get(MOVING_NODE)));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5), UUID.randomUUID()));
0:         ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7), UUID.randomUUID()));
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(hosts.get(movingIndex), ApplicationState.STATUS, valueFactory.normal(newTokens.get(movingIndex), hostIds.get(movingIndex)));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken, hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken, hostIds.get(2)));
commit:df8a933
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Map<Token, List<InetAddress>> expectedEndpoints = new HashMap<Token, List<InetAddress>>();
0:                 expectedEndpoints.put(token, endpoints);
0:         ss.onChange(hosts.get(LEAVING_NODE),
0:                 StorageService.MOVE_STATE,
0:                 new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING_NODE))));
1:         AbstractReplicationStrategy strategy;
0:             strategy = getStrategy(table, tmd);
0:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd)));
1:                     expected.add(expectedEndpoints.get(token).get(i));
0:                     expected.add(expectedEndpoints.get(token).get(replicationFactor));
/////////////////////////////////////////////////////////////////////////
0:     public void testSimultaneousMove() throws UnknownHostException, ConfigurationException
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         Map<String, AbstractReplicationStrategy> tableStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
0:         for (int i=1; i<=4; i++)
0:         {
0:             tableStrategyMap.put("Keyspace" + i, getStrategy("Keyspace" + i, tmd));
0:         }
/////////////////////////////////////////////////////////////////////////
0:         for (Map.Entry<String, AbstractReplicationStrategy> tableStrategy : tableStrategyMap.entrySet())
0:             String table = tableStrategy.getKey();
0:             AbstractReplicationStrategy strategy = tableStrategy.getValue();
0: 
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, strategy.getNaturalEndpoints(keyTokens.get(3)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, strategy.getNaturalEndpoints(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, strategy.getNaturalEndpoints(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, strategy.getNaturalEndpoints(keyTokens.get(6)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, strategy.getNaturalEndpoints(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, strategy.getNaturalEndpoints(keyTokens.get(8)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, strategy.getNaturalEndpoints(keyTokens.get(9)));
/////////////////////////////////////////////////////////////////////////
0:         for (Map.Entry<String, AbstractReplicationStrategy> tableStrategy : tableStrategyMap.entrySet())
0:             String table = tableStrategy.getKey();
0:             AbstractReplicationStrategy strategy = tableStrategy.getValue();
0: 
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, strategy.getNaturalEndpoints(keyTokens.get(3)));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, strategy.getNaturalEndpoints(keyTokens.get(4)));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, strategy.getNaturalEndpoints(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, strategy.getNaturalEndpoints(keyTokens.get(6)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, strategy.getNaturalEndpoints(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, strategy.getNaturalEndpoints(keyTokens.get(8)));
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, strategy.getNaturalEndpoints(keyTokens.get(9)));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:     private AbstractReplicationStrategy getStrategy(String table, TokenMetadata tmd) throws ConfigurationException
0:     {
1:         return AbstractReplicationStrategy.createReplicationStrategy(
0:                 table,
0:                 "org.apache.cassandra.locator.RackUnawareStrategy",
1:                 tmd,
1:                 new SimpleSnitch(),
0:                 null);
0:     }
0: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:7b532bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(table);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:ba2cead
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
/////////////////////////////////////////////////////////////////////////
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
/////////////////////////////////////////////////////////////////////////
commit:cac6a28
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(LEAVING[0]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING[0]))));
0:         ss.onChange(hosts.get(LEAVING[2]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING[2]))));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + partitioner.getTokenFactory().toString(keyTokens.get(1))));
commit:8656417
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.CleanupHelper;
/////////////////////////////////////////////////////////////////////////
0: public class MoveTest extends CleanupHelper
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.HashMultimap;
1: import com.google.common.collect.Multimap;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.commons.lang.StringUtils;
0: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
0:     // handy way of creating a mapping of strategies to use in StorageService.
0:     private static Map<String, AbstractReplicationStrategy> createReplacements(AbstractReplicationStrategy strat)
0:     {
0:         Map<String, AbstractReplicationStrategy> replacements = new HashMap<String, AbstractReplicationStrategy>();
0:         for (String table : DatabaseDescriptor.getTables())
0:             replacements.put(table, strat);
0:         return replacements;
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:         final int RING_SIZE = 5;
0:         final int LEAVING_NODE = 2;
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategies = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, RING_SIZE);
0:         final Map<String, List<Range>> deadNodesRanges = new HashMap<String, List<Range>>();
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:         {
0:             List<Range> list = new ArrayList<Range>();
0:             list.addAll(testStrategy.getAddressRanges(table).get(hosts.get(LEAVING_NODE)));
0:             Collections.sort(list);
0:             deadNodesRanges.put(table, list);
0:         }
0:         
0:         ss.onChange(hosts.get(LEAVING_NODE), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(LEAVING_NODE))));
0:         assertTrue(tmd.isLeaving(hosts.get(LEAVING_NODE)));
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
0:             // if the ring minus the leaving node leaves us with less than RF, we're hosed.
0:             if (hosts.size()-1 < replicationFactor)
1:                 continue;
0:             
0:             // verify that the replicationFactor nodes after the leaving node are gatherings it's pending ranges.
0:             // in the case where rf==5, we're screwed because we basically just lost data.
0:             for (int i = 0; i < replicationFactor; i++)
0:             {
0:                 assertTrue(tmd.getPendingRanges(table, hosts.get((LEAVING_NODE + 1 + i) % RING_SIZE)).size() > 0);
0:                 assertEquals(tmd.getPendingRanges(table, hosts.get((LEAVING_NODE + 1 + i) % RING_SIZE)).get(0), deadNodesRanges.get(table).get(i));
0:             }
0: 
0:             // note that we're iterating over nodes and sample tokens.
0:             final int replicaStart = (LEAVING_NODE-replicationFactor+RING_SIZE)%RING_SIZE;
0:             for (int i=0; i<keyTokens.size(); ++i)
0:             {
0:                 Collection<InetAddress> endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 // figure out if this node is one of the nodes previous to the failed node (2).
0:                 boolean isReplica = (i - replicaStart + RING_SIZE) % RING_SIZE < replicationFactor;
0:                 // the preceeding leaving_node-replication_factor nodes should have and additional ep (replication_factor+1);
0:                 if (isReplica)
0:                     assertTrue(endPoints.size() == replicationFactor + 1);
0:                 else
0:                     assertTrue(endPoints.size() == replicationFactor);
0: 
0:             }
0:         ss.setReplicationStrategyUnsafe(oldStrategies);
/////////////////////////////////////////////////////////////////////////
1:         final int RING_SIZE = 10;
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategy = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
0:         createInitialRing(ss, partitioner, endPointTokens, keyTokens, hosts, RING_SIZE);
0:         final int[] LEAVING = new int[] { 6, 8, 9};
0:         for (int leaving : LEAVING)
0:             ss.onChange(hosts.get(leaving), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(leaving))));
/////////////////////////////////////////////////////////////////////////
1:         // pre-calculate the results.
1:         Map<String, Multimap<Token, InetAddress>> expectedEndpoints = new HashMap<String, Multimap<Token, InetAddress>>();
0:         expectedEndpoints.put("Keyspace1", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
0:         expectedEndpoints.put("Keyspace2", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
0:         expectedEndpoints.put("Keyspace3", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.1.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.put("Keyspace4", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2", "127.0.0.2", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3"));
0: 
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             for (int i = 0; i < keyTokens.size(); i++)
0:             {
0:                 endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endPoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endPoints));
0:             }
0: 
1:             // just to be sure that things still work according to the old tests, run them:
0:             if (DatabaseDescriptor.getReplicationFactor(table) != 3)
0:                 continue;
0:             // tokens 5, 15 and 25 should go three nodes
0:             for (int i=0; i<3; ++i)
0:             {
0:                 endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(endPoints.size() == 3);
0:                 assertTrue(endPoints.contains(hosts.get(i+1)));
0:                 assertTrue(endPoints.contains(hosts.get(i+2)));
0:                 assertTrue(endPoints.contains(hosts.get(i+3)));
0:             }
0: 
0:             // token 35 should go to nodes 4, 5, 6, 7 and boot1
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
0:             assertTrue(endPoints.size() == 5);
0:             assertTrue(endPoints.contains(hosts.get(4)));
0:             assertTrue(endPoints.contains(hosts.get(5)));
0:             assertTrue(endPoints.contains(hosts.get(6)));
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(boot1));
0: 
0:             // token 45 should go to nodes 5, 6, 7, 0, boot1 and boot2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
0:             assertTrue(endPoints.size() == 6);
0:             assertTrue(endPoints.contains(hosts.get(5)));
0:             assertTrue(endPoints.contains(hosts.get(6)));
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(boot1));
0:             assertTrue(endPoints.contains(boot2));
0: 
0:             // token 55 should go to nodes 6, 7, 8, 0, 1, boot1 and boot2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
0:             assertTrue(endPoints.size() == 7);
0:             assertTrue(endPoints.contains(hosts.get(6)));
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(boot1));
0:             assertTrue(endPoints.contains(boot2));
0: 
0:             // token 65 should go to nodes 7, 8, 9, 0, 1 and boot2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
0:             assertTrue(endPoints.size() == 6);
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(9)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(boot2));
0: 
0:             // token 75 should to go nodes 8, 9, 0, 1, 2 and boot2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
0:             assertTrue(endPoints.size() == 6);
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(9)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
0:             assertTrue(endPoints.contains(boot2));
0: 
0:             // token 85 should go to nodes 9, 0, 1 and 2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
0:             assertTrue(endPoints.size() == 4);
0:             assertTrue(endPoints.contains(hosts.get(9)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
0: 
0:             // token 95 should go to nodes 0, 1 and 2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
0: 
0:         ss.onChange(hosts.get(LEAVING[0]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(LEAVING[0]))));
0:         ss.onChange(hosts.get(LEAVING[2]), StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_LEFT + StorageService.Delimiter + StorageService.LEFT_NORMALLY + StorageService.Delimiter + partitioner.getTokenFactory().toString(endPointTokens.get(LEAVING[2]))));
0:         // adjust precalcuated results.  this changes what the epected endpoints are.
0:         expectedEndpoints.get("Keyspace1").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace1").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace2").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace2").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("15")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("25")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.2"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.2", "127.0.0.7"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0: 
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             for (int i = 0; i < keyTokens.size(); i++)
0:             {
0:                 endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endPoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endPoints));
0:             }
0: 
0:             if (DatabaseDescriptor.getReplicationFactor(table) != 3)
0:                 continue;
0:             // leave this stuff in to guarantee the old tests work the way they were supposed to.
0:             // tokens 5, 15 and 25 should go three nodes
0:             for (int i=0; i<3; ++i)
0:             {
0:                 endPoints = testStrategy.getWriteEndpoints(keyTokens.get(i), table, testStrategy.getNaturalEndpoints(keyTokens.get(i), table));
0:                 assertTrue(endPoints.size() == 3);
0:                 assertTrue(endPoints.contains(hosts.get(i+1)));
0:                 assertTrue(endPoints.contains(hosts.get(i+2)));
0:                 assertTrue(endPoints.contains(hosts.get(i+3)));
0:             }
0: 
0:             // token 35 goes to nodes 4, 5 and boot1
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(3), table, testStrategy.getNaturalEndpoints(keyTokens.get(3), table));
0:             assertTrue(endPoints.contains(hosts.get(4)));
0:             assertTrue(endPoints.contains(hosts.get(5)));
0:             assertTrue(endPoints.contains(boot1));
0: 
0:             // token 45 goes to nodes 5, boot1 and node7
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(4), table, testStrategy.getNaturalEndpoints(keyTokens.get(4), table));
0:             assertTrue(endPoints.size() == 3);
0:             assertTrue(endPoints.contains(hosts.get(5)));
0:             assertTrue(endPoints.contains(boot1));
0:             assertTrue(endPoints.contains(hosts.get(7)));
0: 
0:             // token 55 goes to boot1, 7, boot2, 8 and 0
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(5), table, testStrategy.getNaturalEndpoints(keyTokens.get(5), table));
0:             assertTrue(endPoints.size() == 5);
0:             assertTrue(endPoints.contains(boot1));
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(boot2));
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0: 
0:             // token 65 goes to nodes 7, boot2, 8, 0 and 1
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(6), table, testStrategy.getNaturalEndpoints(keyTokens.get(6), table));
0:             assertTrue(endPoints.size() == 5);
0:             assertTrue(endPoints.contains(hosts.get(7)));
0:             assertTrue(endPoints.contains(boot2));
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0: 
0:             // token 75 goes to nodes boot2, 8, 0, 1 and 2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(7), table, testStrategy.getNaturalEndpoints(keyTokens.get(7), table));
0:             assertTrue(endPoints.size() == 5);
0:             assertTrue(endPoints.contains(boot2));
0:             assertTrue(endPoints.contains(hosts.get(8)));
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
0: 
0:             // token 85 goes to nodes 0, 1 and 2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(8), table, testStrategy.getNaturalEndpoints(keyTokens.get(8), table));
0:             assertTrue(endPoints.size() == 3);
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
0: 
0:             // token 95 goes to nodes 0, 1 and 2
0:             endPoints = testStrategy.getWriteEndpoints(keyTokens.get(9), table, testStrategy.getNaturalEndpoints(keyTokens.get(9), table));
0:             assertTrue(endPoints.size() == 3);
0:             assertTrue(endPoints.contains(hosts.get(0)));
0:             assertTrue(endPoints.contains(hosts.get(1)));
0:             assertTrue(endPoints.contains(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategy = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategy = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategy = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, null);
0:         Map<String, AbstractReplicationStrategy> oldStrategy = ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
/////////////////////////////////////////////////////////////////////////
1:     private static Collection<InetAddress> makeAddrs(String... hosts) throws UnknownHostException
0:     {
1:         ArrayList<InetAddress> addrs = new ArrayList<InetAddress>(hosts.length);
1:         for (String host : hosts)
1:             addrs.add(InetAddress.getByName(host));
1:         return addrs;
0:     }
commit:dcaf84e
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy testStrategy = new RackUnawareStrategy(tmd, 3);
============================================================================