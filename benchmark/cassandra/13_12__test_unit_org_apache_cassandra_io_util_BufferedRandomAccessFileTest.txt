1:b4133f3: /*
1:78cbce1:  * Licensed to the Apache Software Foundation (ASF) under one
1:78cbce1:  * or more contributor license agreements.  See the NOTICE file
1:78cbce1:  * distributed with this work for additional information
1:78cbce1:  * regarding copyright ownership.  The ASF licenses this file
1:78cbce1:  * to you under the Apache License, Version 2.0 (the
1:78cbce1:  * "License"); you may not use this file except in compliance
1:78cbce1:  * with the License.  You may obtain a copy of the License at
1:bca6a24:  *
1:78cbce1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:bca6a24:  *
1:78cbce1:  * Unless required by applicable law or agreed to in writing,
1:78cbce1:  * software distributed under the License is distributed on an
1:78cbce1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:78cbce1:  * KIND, either express or implied.  See the License for the
1:78cbce1:  * specific language governing permissions and limitations
1:78cbce1:  * under the License.
1:bca6a24:  *
1:78cbce1:  */
1:bca6a24: package org.apache.cassandra.io.util;
1:d389047: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:9797511: import org.apache.cassandra.utils.ByteBufferUtil;
1:9797511: import org.apache.cassandra.utils.SyncUtil;
1:9797511: 
1:0de8e54: import java.io.File;
1:524290b: import java.io.FileOutputStream;
1:0de8e54: import java.io.IOException;
1:bca6a24: import java.nio.ByteBuffer;
1:524290b: import java.util.Arrays;
1:b4133f3: 
1:9797511: import org.junit.BeforeClass;
1:b4133f3: import org.junit.Test;
1:b4133f3: 
1:ba1821f: import static org.apache.cassandra.Util.expectEOF;
1:ba1821f: import static org.apache.cassandra.Util.expectException;
1:ece6605: import static org.junit.Assert.assertEquals;
1:b4133f3: import static org.junit.Assert.assertTrue;
1:d389047: 
1:0de8e54: public class BufferedRandomAccessFileTest
5:1f07312: {
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:1946cfd:     @Test
1:bca6a24:     public void testReadAndWrite() throws Exception
1:ad6ba3d:     {
1:d389047:         SequentialWriter w = createTempFile("braf");
1:91187b5: 
1:b4133f3:         // writing string of data to the file
1:bca6a24:         byte[] data = "Hello".getBytes();
1:d389047:         w.write(data);
1:d389047:         assertEquals(data.length, w.length());
1:753a943:         assertEquals(data.length, w.position());
1:91187b5: 
1:d389047:         w.sync();
1:561f6ef: 
1:bca6a24:         // reading small amount of data from file, this is handled by initial buffer
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath()))
1:ad6ba3d:         {
1:b4133f3:             try (FileHandle fh = builder.complete();
1:b4133f3:                  RandomAccessReader r = fh.createReader())
1:b4133f3:             {
1:b4133f3: 
1:b4133f3:                 byte[] buffer = new byte[data.length];
1:b4133f3:                 assertEquals(data.length, r.read(buffer));
1:b4133f3:                 assertTrue(Arrays.equals(buffer, data)); // we read exactly what we wrote
1:b4133f3:                 assertEquals(r.read(), -1); // nothing more to read EOF
1:b4133f3:                 assert r.bytesRemaining() == 0 && r.isEOF();
1:b4133f3:             }
1:b4133f3: 
1:b4133f3:             // writing buffer bigger than page size, which will trigger reBuffer()
1:b4133f3:             byte[] bigData = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE + 10];
1:b4133f3: 
1:b4133f3:             for (int i = 0; i < bigData.length; i++)
1:b4133f3:                 bigData[i] = 'd';
1:b4133f3: 
1:753a943:             long initialPosition = w.position();
1:b4133f3:             w.write(bigData); // writing data
1:753a943:             assertEquals(w.position(), initialPosition + bigData.length);
1:b4133f3:             assertEquals(w.length(), initialPosition + bigData.length); // file size should equals to last position
1:b4133f3: 
1:b4133f3:             w.sync();
1:b4133f3: 
1:b4133f3:             // re-opening file in read-only mode
1:b4133f3:             try (FileHandle fh = builder.complete();
1:b4133f3:                  RandomAccessReader r = fh.createReader())
1:b4133f3:             {
1:b4133f3: 
1:b4133f3:                 // reading written buffer
1:b4133f3:                 r.seek(initialPosition); // back to initial (before write) position
1:b4133f3:                 data = new byte[bigData.length];
1:b4133f3:                 long sizeRead = 0;
1:b4133f3:                 for (int i = 0; i < data.length; i++)
1:b4133f3:                 {
1:b4133f3:                     data[i] = (byte) r.read();
1:b4133f3:                     sizeRead++;
1:b4133f3:                 }
1:b4133f3: 
1:b4133f3:                 assertEquals(sizeRead, data.length); // read exactly data.length bytes
1:b4133f3:                 assertEquals(r.getFilePointer(), initialPosition + data.length);
1:b4133f3:                 assertEquals(r.length(), initialPosition + bigData.length);
1:b4133f3:                 assertTrue(Arrays.equals(bigData, data));
1:b4133f3:                 assertTrue(r.bytesRemaining() == 0 && r.isEOF()); // we are at the of the file
1:b4133f3: 
1:b4133f3:                 // test readBytes(int) method
1:b4133f3:                 r.seek(0);
1:b4133f3:                 ByteBuffer fileContent = ByteBufferUtil.read(r, (int) w.length());
1:b4133f3:                 assertEquals(fileContent.limit(), w.length());
1:b4133f3:                 assert ByteBufferUtil.string(fileContent).equals("Hello" + new String(bigData));
1:b4133f3: 
1:b4133f3:                 // read the same buffer but using readFully(int)
1:b4133f3:                 data = new byte[bigData.length];
1:b4133f3:                 r.seek(initialPosition);
1:b4133f3:                 r.readFully(data);
1:b4133f3:                 assert r.bytesRemaining() == 0 && r.isEOF(); // we should be at EOF
1:b4133f3:                 assertTrue(Arrays.equals(bigData, data));
1:b4133f3: 
1:b4133f3:                 // try to read past mark (all methods should return -1)
1:b4133f3:                 data = new byte[10];
1:b4133f3:                 assertEquals(r.read(), -1);
1:b4133f3:                 assertEquals(r.read(data), -1);
1:b4133f3:                 assertEquals(r.read(data, 0, data.length), -1);
1:b4133f3: 
1:b4133f3:                 // test read(byte[], int, int)
1:b4133f3:                 r.seek(0);
1:b4133f3:                 data = new byte[20];
1:b4133f3:                 assertEquals(15, r.read(data, 0, 15));
1:b4133f3:                 assertTrue(new String(data).contains("Hellodddddddddd"));
1:b4133f3:                 for (int i = 16; i < data.length; i++)
1:b4133f3:                 {
1:b4133f3:                     assert data[i] == 0;
1:b4133f3:                 }
1:b4133f3: 
1:b4133f3:                 w.finish();
1:b4133f3:             }
1:ad6ba3d:         }
1:ad6ba3d:     }
1:ad6ba3d: 
1:d389047:     @Test
1:d389047:     public void testReadAndWriteOnCapacity() throws IOException
1:b4133f3:     {
1:bca6a24:         File tmpFile = File.createTempFile("readtest", "bin");
1:9484783:         try (SequentialWriter w = new SequentialWriter(tmpFile))
1:17dd4cc:         {
1:9484783:             // Fully write the file and sync..
1:9484783:             byte[] in = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:9484783:             w.write(in);
1:9484783:     
1:9484783:             try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:9484783:                  FileHandle fh = builder.complete();
1:9484783:                  RandomAccessReader r = fh.createReader())
1:9484783:             {
1:9484783:                 // Read it into a same size array.
1:9484783:                 byte[] out = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE];
1:9484783:                 r.read(out);
1:9484783:     
1:9484783:                 // Cannot read any more.
1:9484783:                 int negone = r.read();
1:9484783:                 assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
1:9484783:     
1:9484783:                 w.finish();
1:9484783:             }
1:b4133f3:         }
1:ad6ba3d:     }
1:b4133f3: 
1:1f07312:     @Test
1:0de8e54:     public void testLength() throws IOException
1:b4133f3:     {
1:0de8e54:         File tmpFile = File.createTempFile("lengthtest", "bin");
1:9484783:         try (SequentialWriter w = new SequentialWriter(tmpFile))
1:b4133f3:         {
1:9484783:             assertEquals(0, w.length());
1:9484783:     
1:9484783:             // write a chunk smaller then our buffer, so will not be flushed
1:9484783:             // to disk
1:9484783:             byte[] lessThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE / 2);
1:9484783:             w.write(lessThenBuffer);
1:9484783:             assertEquals(lessThenBuffer.length, w.length());
1:9484783:     
1:9484783:             // sync the data and check length
1:9484783:             w.sync();
1:9484783:             assertEquals(lessThenBuffer.length, w.length());
1:9484783:     
1:9484783:             // write more then the buffer can hold and check length
1:9484783:             byte[] biggerThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE * 2);
1:9484783:             w.write(biggerThenBuffer);
1:9484783:             assertEquals(biggerThenBuffer.length + lessThenBuffer.length, w.length());
1:9484783:     
1:9484783:             w.finish();
1:9484783:     
1:9484783:             // will use cachedlength
1:9484783:             try (FileHandle.Builder builder = new FileHandle.Builder(tmpFile.getPath());
1:9484783:                  FileHandle fh = builder.complete();
1:9484783:                  RandomAccessReader r = fh.createReader())
1:9484783:             {
1:9484783:                 assertEquals(lessThenBuffer.length + biggerThenBuffer.length, r.length());
1:9484783:             }
1:17dd4cc:         }
1:ad6ba3d:     }
1:ad6ba3d: 
1:bca6a24:     @Test
1:bca6a24:     public void testReadBytes() throws IOException
1:ad6ba3d:     {
1:d389047:         final SequentialWriter w = createTempFile("brafReadBytes");
1:ad6ba3d: 
1:d389047:         byte[] data = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE + 10];
1:ad6ba3d: 
1:1f07312:         for (int i = 0; i < data.length; i++)
1:ad6ba3d:         {
1:1f07312:             data[i] = 'c';
1:d389047:         }
1:ad6ba3d: 
1:d389047:         w.write(data);
1:d389047:         w.sync();
1:ad6ba3d: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader r = fh.createReader())
1:ad6ba3d:         {
1:ad6ba3d: 
1:b4133f3:             ByteBuffer content = ByteBufferUtil.read(r, (int) r.length());
1:ad6ba3d: 
1:b4133f3:             // after reading whole file we should be at EOF
1:b4133f3:             assertEquals(0, ByteBufferUtil.compare(content, data));
1:b4133f3:             assert r.bytesRemaining() == 0 && r.isEOF();
1:ad6ba3d: 
1:b4133f3:             r.seek(0);
1:b4133f3:             content = ByteBufferUtil.read(r, 10); // reading first 10 bytes
1:b4133f3:             assertEquals(ByteBufferUtil.compare(content, "cccccccccc".getBytes()), 0);
1:b4133f3:             assertEquals(r.bytesRemaining(), r.length() - content.limit());
1:ad6ba3d: 
1:b4133f3:             // trying to read more than file has right now
1:b4133f3:             expectEOF(() -> ByteBufferUtil.read(r, (int) r.length() + 10));
1:ad6ba3d: 
1:b4133f3:             w.finish();
1:b4133f3:         }
1:1946cfd:     }
1:ad6ba3d: 
2:bca6a24:     @Test
1:bca6a24:     public void testSeek() throws Exception
1:ad6ba3d:     {
1:d389047:         SequentialWriter w = createTempFile("brafSeek");
1:d389047:         byte[] data = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE + 20);
1:d389047:         w.write(data);
1:b4133f3:         w.finish();
1:d389047: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader file = fh.createReader())
1:b4133f3:         {
1:b4133f3:             file.seek(0);
1:b4133f3:             assertEquals(file.getFilePointer(), 0);
1:b4133f3:             assertEquals(file.bytesRemaining(), file.length());
1:d389047: 
1:b4133f3:             file.seek(20);
1:b4133f3:             assertEquals(file.getFilePointer(), 20);
1:b4133f3:             assertEquals(file.bytesRemaining(), file.length() - 20);
1:d389047: 
1:b4133f3:             // trying to seek past the end of the file should produce EOFException
1:b4133f3:             expectException(() -> {
1:b4133f3:                 file.seek(file.length() + 30);
1:e026b7c:                 return null;
1:b4133f3:             }, IllegalArgumentException.class);
1:d389047: 
1:b4133f3:             expectException(() -> {
1:b4133f3:                 file.seek(-1);
2:b4133f3:                 return null;
1:b4133f3:             }, IllegalArgumentException.class); // throws IllegalArgumentException
1:b4133f3:         }
1:d389047:     }
1:d389047: 
1:1f07312:     @Test
1:bca6a24:     public void testSkipBytes() throws IOException
1:b4133f3:     {
1:d389047:         SequentialWriter w = createTempFile("brafSkipBytes");
1:d389047:         w.write(generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE * 2));
1:8704006:         w.finish();
1:d389047: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader file = fh.createReader())
1:b4133f3:         {
1:1946cfd: 
1:b4133f3:             file.seek(0); // back to the beginning of the file
1:b4133f3:             assertEquals(file.skipBytes(10), 10);
1:b4133f3:             assertEquals(file.bytesRemaining(), file.length() - 10);
1:1946cfd: 
1:b4133f3:             int initialPosition = (int) file.getFilePointer();
1:b4133f3:             // can't skip more than file size
1:b4133f3:             assertEquals(file.skipBytes((int) file.length() + 10), file.length() - initialPosition);
1:b4133f3:             assertEquals(file.getFilePointer(), file.length());
1:b4133f3:             assert file.bytesRemaining() == 0 && file.isEOF();
1:1946cfd: 
1:b4133f3:             file.seek(0);
1:1946cfd: 
1:b4133f3:             // skipping negative amount should return 0
1:b4133f3:             assertEquals(file.skipBytes(-1000), 0);
1:b4133f3:             assertEquals(file.getFilePointer(), 0);
1:b4133f3:             assertEquals(file.bytesRemaining(), file.length());
1:b4133f3:         }
1:1946cfd:     }
1:1946cfd: 
1:bca6a24:     @Test
1:bca6a24:     public void testGetFilePointer() throws IOException
1:ad6ba3d:     {
1:d389047:         final SequentialWriter w = createTempFile("brafGetFilePointer");
1:1946cfd: 
1:753a943:         assertEquals(w.position(), 0); // initial position should be 0
1:1946cfd: 
1:d389047:         w.write(generateByteArray(20));
1:753a943:         assertEquals(w.position(), 20); // position 20 after writing 20 bytes
1:1946cfd: 
1:d389047:         w.sync();
1:1f07312: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader r = fh.createReader())
1:ad6ba3d:         {
1:1f07312: 
1:b4133f3:             // position should change after skip bytes
1:b4133f3:             r.seek(0);
1:b4133f3:             r.skipBytes(15);
1:b4133f3:             assertEquals(r.getFilePointer(), 15);
1:1f07312: 
1:b4133f3:             r.read();
1:b4133f3:             assertEquals(r.getFilePointer(), 16);
1:b4133f3:             r.read(new byte[4]);
1:b4133f3:             assertEquals(r.getFilePointer(), 20);
3:bca6a24: 
1:b4133f3:             w.finish();
1:b4133f3:         }
1:1946cfd:     }
1:bca6a24: 
1:bca6a24:     @Test
1:bca6a24:     public void testGetPath() throws IOException
1:d389047:     {
1:d389047:         SequentialWriter file = createTempFile("brafGetPath");
1:bca6a24:         assert file.getPath().contains("brafGetPath");
1:8704006:         file.finish();
1:d389047:     }
1:bca6a24: 
1:d389047:     @Test
1:bca6a24:     public void testIsEOF() throws IOException
1:d389047:     {
1:d389047:         for (int bufferSize : Arrays.asList(1, 2, 3, 5, 8, 64))  // smaller, equal, bigger buffer sizes
1:d389047:         {
1:d389047:             final byte[] target = new byte[32];
1:d389047: 
1:d389047:             // single too-large read
1:d389047:             for (final int offset : Arrays.asList(0, 8))
1:d389047:             {
1:6773383:                 File file1 = writeTemporaryFile(new byte[16]);
1:b4133f3:                 try (FileHandle.Builder builder = new FileHandle.Builder(file1.getPath()).bufferSize(bufferSize);
1:b4133f3:                      FileHandle fh = builder.complete();
1:b4133f3:                      RandomAccessReader file = fh.createReader())
1:e026b7c:                 {
1:ce63ccc:                     expectEOF(() -> { file.readFully(target, offset, 17); return null; });
1:e026b7c:                 }
1:e026b7c:             }
1:bca6a24: 
1:d389047:             // first read is ok but eventually EOFs
1:d389047:             for (final int n : Arrays.asList(1, 2, 4, 8))
1:e026b7c:             {
1:6773383:                 File file1 = writeTemporaryFile(new byte[16]);
1:b4133f3:                 try (FileHandle.Builder builder = new FileHandle.Builder(file1.getPath()).bufferSize(bufferSize);
1:b4133f3:                      FileHandle fh = builder.complete();
1:b4133f3:                      RandomAccessReader file = fh.createReader())
1:d389047:                 {
1:ce63ccc:                     expectEOF(() -> {
1:e026b7c:                         while (true)
1:e026b7c:                             file.readFully(target, 0, n);
2:e026b7c:                     });
1:e026b7c:                 }
1:e026b7c:             }
1:ad6ba3d:         }
1:ad6ba3d:     }
1:ad6ba3d: 
1:ad6ba3d:     @Test
1:bca6a24:     public void testNotEOF() throws IOException
1:1946cfd:     {
1:4e29b7a:         try (final RandomAccessReader reader = RandomAccessReader.open(writeTemporaryFile(new byte[1])))
1:4e29b7a:         {
1:4e29b7a:             assertEquals(1, reader.read(new byte[2]));
1:4e29b7a:         }
1:ad6ba3d:     }
1:ad6ba3d: 
1:bca6a24:     @Test
1:bca6a24:     public void testBytesRemaining() throws IOException
1:1946cfd:     {
1:d389047:         SequentialWriter w = createTempFile("brafBytesRemaining");
1:ad6ba3d: 
1:d389047:         int toWrite = RandomAccessReader.DEFAULT_BUFFER_SIZE + 10;
1:1f07312: 
1:d389047:         w.write(generateByteArray(toWrite));
1:d389047: 
1:d389047:         w.sync();
1:d389047: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader r = fh.createReader())
1:1946cfd:         {
1:1f07312: 
1:b4133f3:             assertEquals(r.bytesRemaining(), toWrite);
1:b4133f3: 
1:b4133f3:             for (int i = 1; i <= r.length(); i++)
1:b4133f3:             {
1:b4133f3:                 r.read();
1:b4133f3:                 assertEquals(r.bytesRemaining(), r.length() - i);
1:b4133f3:             }
1:b4133f3: 
1:b4133f3:             r.seek(0);
1:b4133f3:             r.skipBytes(10);
1:b4133f3:             assertEquals(r.bytesRemaining(), r.length() - 10);
1:b4133f3: 
1:b4133f3:             w.finish();
1:d389047:         }
1:d389047:     }
1:1f07312: 
1:bca6a24:     @Test
1:bca6a24:     public void testBytesPastMark() throws IOException
1:1946cfd:     {
1:bca6a24:         File tmpFile = File.createTempFile("overflowtest", "bin");
1:bca6a24:         tmpFile.deleteOnExit();
1:bca6a24: 
1:bca6a24:         // Create the BRAF by filename instead of by file.
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(tmpFile.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader r = fh.createReader())
1:e026b7c:         {
1:e026b7c:             assert tmpFile.getPath().equals(r.getPath());
1:e026b7c: 
1:e026b7c:             // Create a mark and move the rw there.
1:e8651b6:             final DataPosition mark = r.mark();
1:e026b7c:             r.reset(mark);
1:e026b7c: 
1:e026b7c:             // Expect this call to succeed.
1:e026b7c:             r.bytesPastMark(mark);
1:e026b7c:         }
3:1f07312:     }
1:91187b5: 
1:bca6a24:     @Test
1:bca6a24:     public void testClose() throws IOException
1:1f07312:     {
1:d389047:         final SequentialWriter w = createTempFile("brafClose");
1:d389047: 
1:d389047:         byte[] data = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE + 20);
1:bca6a24: 
1:d389047:         w.write(data);
1:8704006:         w.finish();
1:bca6a24: 
1:d389047:         final RandomAccessReader r = RandomAccessReader.open(new File(w.getPath()));
1:d389047: 
1:d389047:         r.close(); // closing to test read after close
1:bca6a24: 
1:ce63ccc:         expectException(() -> r.read(), NullPointerException.class);
1:bca6a24: 
1:29687a8:         //Used to throw ClosedChannelException, but now that it extends BDOSP it just NPEs on the buffer
1:29687a8:         //Writing to a BufferedOutputStream that is closed generates no error
1:29687a8:         //Going to allow the NPE to throw to catch as a bug any use after close. Notably it won't throw NPE for a
1:29687a8:         //write of a 0 length, but that is kind of a corner case
1:ce63ccc:         expectException(() -> { w.write(generateByteArray(1)); return null; }, NullPointerException.class);
1:bca6a24: 
1:e026b7c:         try (RandomAccessReader copy = RandomAccessReader.open(new File(r.getPath())))
1:e026b7c:         {
1:ce63ccc:             ByteBuffer contents = ByteBufferUtil.read(copy, (int) copy.length());
1:e026b7c: 
1:e026b7c:             assertEquals(contents.limit(), data.length);
1:e026b7c:             assertEquals(ByteBufferUtil.compare(contents, data), 0);
1:e026b7c:         }
1:1f07312:     }
1:bca6a24: 
1:bca6a24:     @Test
1:bca6a24:     public void testMarkAndReset() throws IOException
1:1f07312:     {
1:d389047:         SequentialWriter w = createTempFile("brafTestMark");
1:d389047:         w.write(new byte[30]);
1:91187b5: 
1:8704006:         w.finish();
1:d389047: 
1:b4133f3:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:              FileHandle fh = builder.complete();
1:b4133f3:              RandomAccessReader file = fh.createReader())
1:1f07312:         {
1:b4133f3:             file.seek(10);
1:b4133f3:             DataPosition mark = file.mark();
1:d389047: 
1:b4133f3:             file.seek(file.length());
1:b4133f3:             assertTrue(file.isEOF());
1:bca6a24: 
1:b4133f3:             file.reset();
1:b4133f3:             assertEquals(file.bytesRemaining(), 20);
1:bca6a24: 
1:b4133f3:             file.seek(file.length());
1:b4133f3:             assertTrue(file.isEOF());
1:bca6a24: 
1:b4133f3:             file.reset(mark);
1:b4133f3:             assertEquals(file.bytesRemaining(), 20);
1:bca6a24: 
1:b4133f3:             file.seek(file.length());
1:b4133f3:             assertEquals(file.bytesPastMark(), 20);
1:b4133f3:             assertEquals(file.bytesPastMark(mark), 20);
1:bca6a24: 
1:b4133f3:             file.reset(mark);
1:b4133f3:             assertEquals(file.bytesPastMark(), 0);
1:b4133f3:         }
1:1f07312:     }
1:bca6a24: 
1:ce63ccc:     @Test(expected = AssertionError.class)
1:bca6a24:     public void testAssertionErrorWhenBytesPastMarkIsNegative() throws IOException
1:1f07312:     {
1:e026b7c:         try (SequentialWriter w = createTempFile("brafAssertionErrorWhenBytesPastMarkIsNegative"))
1:e026b7c:         {
1:e026b7c:             w.write(new byte[30]);
1:e026b7c:             w.flush();
1:e026b7c: 
1:b4133f3:             try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:b4133f3:                  FileHandle fh = builder.complete();
1:b4133f3:                  RandomAccessReader r = fh.createReader())
1:e026b7c:             {
1:e026b7c:                 r.seek(10);
1:e026b7c:                 r.mark();
1:e026b7c: 
1:e026b7c:                 r.seek(0);
1:e026b7c:                 r.bytesPastMark();
1:e026b7c:             }
1:e026b7c:         }
1:1f07312:     }
1:91187b5: 
1:bca6a24:     @Test
1:1f07312:     public void testReadOnly() throws IOException
1:1f07312:     {
1:d389047:         SequentialWriter file = createTempFile("brafReadOnlyTest");
1:bca6a24: 
1:1f07312:         byte[] data = new byte[20];
1:bca6a24:         for (int i = 0; i < data.length; i++)
2:bca6a24:             data[i] = 'c';
1:1f07312: 
1:1f07312:         file.write(data);
1:1f07312:         file.sync(); // flushing file to the disk
1:1f07312: 
1:1f07312:         // read-only copy of the file, with fixed file length
1:d389047:         final RandomAccessReader copy = RandomAccessReader.open(new File(file.getPath()));
1:1f07312: 
1:1f07312:         copy.seek(copy.length());
1:1f07312:         assertTrue(copy.bytesRemaining() == 0 && copy.isEOF());
1:1f07312: 
1:1f07312:         // can't seek past the end of the file for read-only files
1:ce63ccc:         expectException(() -> { copy.seek(copy.length() + 1); return null; }, IllegalArgumentException.class);
1:1f07312: 
1:1f07312:         copy.seek(0);
1:1f07312:         copy.skipBytes(5);
1:1f07312: 
1:1f07312:         assertEquals(copy.bytesRemaining(), 15);
1:1f07312:         assertEquals(copy.getFilePointer(), 5);
1:1f07312:         assertTrue(!copy.isEOF());
1:1f07312: 
1:1f07312:         copy.seek(0);
1:ce63ccc:         ByteBuffer contents = ByteBufferUtil.read(copy, (int) copy.length());
1:1f07312: 
1:1f07312:         assertEquals(contents.limit(), copy.length());
1:1f07312:         assertTrue(ByteBufferUtil.compare(contents, data) == 0);
1:1f07312: 
1:1f07312:         copy.seek(0);
1:1f07312: 
1:1f07312:         int count = 0;
1:1f07312:         while (!copy.isEOF())
1:1f07312:         {
1:1f07312:             assertEquals((byte) copy.read(), 'c');
1:1f07312:             count++;
1:1f07312:         }
1:1f07312: 
1:1f07312:         assertEquals(count, copy.length());
1:1f07312: 
1:1f07312:         copy.seek(0);
1:1f07312:         byte[] content = new byte[10];
1:1f07312:         copy.read(content);
1:1f07312: 
1:1f07312:         assertEquals(new String(content), "cccccccccc");
1:1f07312: 
1:8704006:         file.finish();
1:1f07312:         copy.close();
1:d389047:     }
1:d389047: 
1:d389047:     @Test (expected=IllegalArgumentException.class)
1:d389047:     public void testSetNegativeLength() throws IOException, IllegalArgumentException
1:d389047:     {
1:d389047:         File tmpFile = File.createTempFile("set_negative_length", "bin");
1:fb22109:         try (SequentialWriter file = new SequentialWriter(tmpFile))
1:e026b7c:         {
1:e026b7c:             file.truncate(-8L);
1:e026b7c:         }
1:e026b7c:     }
1:d389047: 
1:d389047:     private SequentialWriter createTempFile(String name) throws IOException
1:e026b7c:     {
1:d389047:         File tempFile = File.createTempFile(name, null);
1:d389047:         tempFile.deleteOnExit();
1:d389047: 
1:fb22109:         return new SequentialWriter(tempFile);
1:d389047:     }
1:d389047: 
1:d389047:     private File writeTemporaryFile(byte[] data) throws IOException
1:d389047:     {
1:d389047:         File f = File.createTempFile("BRAFTestFile", null);
1:d389047:         f.deleteOnExit();
1:d389047:         FileOutputStream fout = new FileOutputStream(f);
1:d389047:         fout.write(data);
1:91187b5:         SyncUtil.sync(fout);
1:d389047:         fout.close();
1:d389047:         return f;
1:d389047:     }
1:d389047: 
1:d389047:     private byte[] generateByteArray(int length)
1:d389047:     {
1:d389047:         byte[] arr = new byte[length];
1:d389047: 
1:d389047:         for (int i = 0; i < length; i++)
1:d389047:             arr[i] = 'a';
1:d389047: 
1:d389047:         return arr;
1:d389047:     }
1:1946cfd: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9484783
/////////////////////////////////////////////////////////////////////////
1:         try (SequentialWriter w = new SequentialWriter(tmpFile))
1:             // Fully write the file and sync..
1:             byte[] in = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE);
1:             w.write(in);
1:     
1:             try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:                  FileHandle fh = builder.complete();
1:                  RandomAccessReader r = fh.createReader())
1:             {
1:                 // Read it into a same size array.
1:                 byte[] out = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE];
1:                 r.read(out);
1:     
1:                 // Cannot read any more.
1:                 int negone = r.read();
1:                 assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
1:     
1:                 w.finish();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         try (SequentialWriter w = new SequentialWriter(tmpFile))
1:             assertEquals(0, w.length());
1:     
1:             // write a chunk smaller then our buffer, so will not be flushed
1:             // to disk
1:             byte[] lessThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE / 2);
1:             w.write(lessThenBuffer);
1:             assertEquals(lessThenBuffer.length, w.length());
1:     
1:             // sync the data and check length
1:             w.sync();
1:             assertEquals(lessThenBuffer.length, w.length());
1:     
1:             // write more then the buffer can hold and check length
1:             byte[] biggerThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE * 2);
1:             w.write(biggerThenBuffer);
1:             assertEquals(biggerThenBuffer.length + lessThenBuffer.length, w.length());
1:     
1:             w.finish();
1:     
1:             // will use cachedlength
1:             try (FileHandle.Builder builder = new FileHandle.Builder(tmpFile.getPath());
1:                  FileHandle fh = builder.complete();
1:                  RandomAccessReader r = fh.createReader())
1:             {
1:                 assertEquals(lessThenBuffer.length + biggerThenBuffer.length, r.length());
1:             }
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:e026b7c
/////////////////////////////////////////////////////////////////////////
0:                 try (final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null))
0:                     expectEOF(new Callable<Object>()
0:                         public Object call() throws IOException
1:                         {
0:                             file.readFully(target, offset, 17);
1:                             return null;
1:                         }
1:                     });
1:                 }
0:                 try (final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null))
0:                     expectEOF(new Callable<Object>()
0:                         public Object call() throws IOException
1:                         {
1:                             while (true)
1:                                 file.readFully(target, 0, n);
1:                         }
1:                     });
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         try (final RandomAccessReader r = RandomAccessReader.open(new File(tmpFile.getPath())))
1:         {
1:             assert tmpFile.getPath().equals(r.getPath());
1:     
1:             // Create a mark and move the rw there.
0:             final FileMark mark = r.mark();
1:             r.reset(mark);
1:     
1:             // Expect this call to succeed.
1:             r.bytesPastMark(mark);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (RandomAccessReader copy = RandomAccessReader.open(new File(r.getPath())))
1:         {
0:             ByteBuffer contents = copy.readBytes((int) copy.length());
1:     
1:             assertEquals(contents.limit(), data.length);
1:             assertEquals(ByteBufferUtil.compare(contents, data), 0);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (SequentialWriter w = createTempFile("brafAssertionErrorWhenBytesPastMarkIsNegative"))
1:         {
1:             w.write(new byte[30]);
1:             w.flush();
1:     
0:             try (RandomAccessReader r = RandomAccessReader.open(w))
1:             {
1:                 r.seek(10);
1:                 r.mark();
1:         
1:                 r.seek(0);
1:                 r.bytesPastMark();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         try (SequentialWriter file = SequentialWriter.open(tmpFile))
1:         {
1:             file.truncate(-8L);
1:         }
0:         try (RandomAccessReader file = RandomAccessReader.open(tmpFile))
1:         {
0:             file.setLength(4L);
1:         }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.SyncUtil;
1: 
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
commit:753a943
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(data.length, w.position());
/////////////////////////////////////////////////////////////////////////
1:         long initialPosition = w.position();
1:         assertEquals(w.position(), initialPosition + bigData.length);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(w.position(), 0); // initial position should be 0
1:         assertEquals(w.position(), 20); // position 20 after writing 20 bytes
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:b4133f3
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.SyncUtil;
1: 
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:         // writing string of data to the file
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath()))
1:             try (FileHandle fh = builder.complete();
1:                  RandomAccessReader r = fh.createReader())
1:             {
1: 
1:                 byte[] buffer = new byte[data.length];
1:                 assertEquals(data.length, r.read(buffer));
1:                 assertTrue(Arrays.equals(buffer, data)); // we read exactly what we wrote
1:                 assertEquals(r.read(), -1); // nothing more to read EOF
1:                 assert r.bytesRemaining() == 0 && r.isEOF();
1:             }
1: 
1:             // writing buffer bigger than page size, which will trigger reBuffer()
1:             byte[] bigData = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE + 10];
1: 
1:             for (int i = 0; i < bigData.length; i++)
1:                 bigData[i] = 'd';
1: 
0:             long initialPosition = w.position();
1:             w.write(bigData); // writing data
0:             assertEquals(w.position(), initialPosition + bigData.length);
1:             assertEquals(w.length(), initialPosition + bigData.length); // file size should equals to last position
1: 
1:             w.sync();
1: 
1:             // re-opening file in read-only mode
1:             try (FileHandle fh = builder.complete();
1:                  RandomAccessReader r = fh.createReader())
1:             {
1: 
1:                 // reading written buffer
1:                 r.seek(initialPosition); // back to initial (before write) position
1:                 data = new byte[bigData.length];
1:                 long sizeRead = 0;
1:                 for (int i = 0; i < data.length; i++)
1:                 {
1:                     data[i] = (byte) r.read();
1:                     sizeRead++;
1:                 }
1: 
1:                 assertEquals(sizeRead, data.length); // read exactly data.length bytes
1:                 assertEquals(r.getFilePointer(), initialPosition + data.length);
1:                 assertEquals(r.length(), initialPosition + bigData.length);
1:                 assertTrue(Arrays.equals(bigData, data));
1:                 assertTrue(r.bytesRemaining() == 0 && r.isEOF()); // we are at the of the file
1: 
1:                 // test readBytes(int) method
1:                 r.seek(0);
1:                 ByteBuffer fileContent = ByteBufferUtil.read(r, (int) w.length());
1:                 assertEquals(fileContent.limit(), w.length());
1:                 assert ByteBufferUtil.string(fileContent).equals("Hello" + new String(bigData));
1: 
1:                 // read the same buffer but using readFully(int)
1:                 data = new byte[bigData.length];
1:                 r.seek(initialPosition);
1:                 r.readFully(data);
1:                 assert r.bytesRemaining() == 0 && r.isEOF(); // we should be at EOF
1:                 assertTrue(Arrays.equals(bigData, data));
1: 
1:                 // try to read past mark (all methods should return -1)
1:                 data = new byte[10];
1:                 assertEquals(r.read(), -1);
1:                 assertEquals(r.read(data), -1);
1:                 assertEquals(r.read(data, 0, data.length), -1);
1: 
1:                 // test read(byte[], int, int)
1:                 r.seek(0);
1:                 data = new byte[20];
1:                 assertEquals(15, r.read(data, 0, 15));
1:                 assertTrue(new String(data).contains("Hellodddddddddd"));
1:                 for (int i = 16; i < data.length; i++)
1:                 {
1:                     assert data[i] == 0;
1:                 }
1: 
1:                 w.finish();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader r = fh.createReader())
1:         {
0:             // Read it into a same size array.
0:             byte[] out = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE];
0:             r.read(out);
0:             // Cannot read any more.
0:             int negone = r.read();
0:             assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
1:             w.finish();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(tmpFile.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader r = fh.createReader())
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader r = fh.createReader())
1:         {
1:             ByteBuffer content = ByteBufferUtil.read(r, (int) r.length());
1:             // after reading whole file we should be at EOF
1:             assertEquals(0, ByteBufferUtil.compare(content, data));
1:             assert r.bytesRemaining() == 0 && r.isEOF();
1:             r.seek(0);
1:             content = ByteBufferUtil.read(r, 10); // reading first 10 bytes
1:             assertEquals(ByteBufferUtil.compare(content, "cccccccccc".getBytes()), 0);
1:             assertEquals(r.bytesRemaining(), r.length() - content.limit());
1:             // trying to read more than file has right now
1:             expectEOF(() -> ByteBufferUtil.read(r, (int) r.length() + 10));
1:             w.finish();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader file = fh.createReader())
1:         {
1:             file.seek(0);
1:             assertEquals(file.getFilePointer(), 0);
1:             assertEquals(file.bytesRemaining(), file.length());
1:             file.seek(20);
1:             assertEquals(file.getFilePointer(), 20);
1:             assertEquals(file.bytesRemaining(), file.length() - 20);
1:             // trying to seek past the end of the file should produce EOFException
1:             expectException(() -> {
1:                 file.seek(file.length() + 30);
1:                 return null;
1:             }, IllegalArgumentException.class);
1:             expectException(() -> {
1:                 file.seek(-1);
1:                 return null;
1:             }, IllegalArgumentException.class); // throws IllegalArgumentException
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader file = fh.createReader())
1:         {
1:             file.seek(0); // back to the beginning of the file
1:             assertEquals(file.skipBytes(10), 10);
1:             assertEquals(file.bytesRemaining(), file.length() - 10);
1:             int initialPosition = (int) file.getFilePointer();
1:             // can't skip more than file size
1:             assertEquals(file.skipBytes((int) file.length() + 10), file.length() - initialPosition);
1:             assertEquals(file.getFilePointer(), file.length());
1:             assert file.bytesRemaining() == 0 && file.isEOF();
1:             file.seek(0);
1:             // skipping negative amount should return 0
1:             assertEquals(file.skipBytes(-1000), 0);
1:             assertEquals(file.getFilePointer(), 0);
1:             assertEquals(file.bytesRemaining(), file.length());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader r = fh.createReader())
1:         {
1:             // position should change after skip bytes
1:             r.seek(0);
1:             r.skipBytes(15);
1:             assertEquals(r.getFilePointer(), 15);
1:             r.read();
1:             assertEquals(r.getFilePointer(), 16);
1:             r.read(new byte[4]);
1:             assertEquals(r.getFilePointer(), 20);
1:             w.finish();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 try (FileHandle.Builder builder = new FileHandle.Builder(file1.getPath()).bufferSize(bufferSize);
1:                      FileHandle fh = builder.complete();
1:                      RandomAccessReader file = fh.createReader())
/////////////////////////////////////////////////////////////////////////
1:                 try (FileHandle.Builder builder = new FileHandle.Builder(file1.getPath()).bufferSize(bufferSize);
1:                      FileHandle fh = builder.complete();
1:                      RandomAccessReader file = fh.createReader())
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
1:              FileHandle fh = builder.complete();
1:              RandomAccessReader r = fh.createReader())
1: 
1:             assertEquals(r.bytesRemaining(), toWrite);
1: 
1:             for (int i = 1; i <= r.length(); i++)
1:             {
1:                 r.read();
1:                 assertEquals(r.bytesRemaining(), r.length() - i);
1:             }
1: 
1:             r.seek(0);
1:             r.skipBytes(10);
1:             assertEquals(r.bytesRemaining(), r.length() - 10);
1: 
1:             w.finish();
/////////////////////////////////////////////////////////////////////////
0:         try (FileHandle.Builder builder = new FileHandle.Builder(tmpFile.getPath());
1:              FileHandle fh = builder.complete();
0:              RandomAccessReader r = fh.createReader())
/////////////////////////////////////////////////////////////////////////
1:         try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
0:              FileHandle fh = builder.complete();
1:              RandomAccessReader file = fh.createReader())
1:         {
1:             file.seek(10);
1:             DataPosition mark = file.mark();
1:             file.seek(file.length());
1:             assertTrue(file.isEOF());
1:             file.reset();
1:             assertEquals(file.bytesRemaining(), 20);
1:             file.seek(file.length());
1:             assertTrue(file.isEOF());
1:             file.reset(mark);
1:             assertEquals(file.bytesRemaining(), 20);
1:             file.seek(file.length());
1:             assertEquals(file.bytesPastMark(), 20);
1:             assertEquals(file.bytesPastMark(mark), 20);
1:             file.reset(mark);
1:             assertEquals(file.bytesPastMark(), 0);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             try (FileHandle.Builder builder = new FileHandle.Builder(w.getPath());
0:                  FileHandle fh = builder.complete();
0:                  RandomAccessReader r = fh.createReader())
commit:fb22109
/////////////////////////////////////////////////////////////////////////
0:         SequentialWriter w = new SequentialWriter(tmpFile);
/////////////////////////////////////////////////////////////////////////
0:         SequentialWriter w = new SequentialWriter(tmpFile);
/////////////////////////////////////////////////////////////////////////
1:         try (SequentialWriter file = new SequentialWriter(tmpFile))
/////////////////////////////////////////////////////////////////////////
1:         return new SequentialWriter(tempFile);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:30bb255
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.FSReadError;
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = RandomAccessReader.builder(channel)
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = RandomAccessReader.builder(channel).bufferSize(bufferSize).build())
author:Paulo Motta
-------------------------------------------------------------------------------
commit:e8651b6
/////////////////////////////////////////////////////////////////////////
1:             final DataPosition mark = r.mark();
/////////////////////////////////////////////////////////////////////////
0:         DataPosition mark = file.mark();
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:ce63ccc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer fileContent = ByteBufferUtil.read(r, (int) w.length());
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer content = ByteBufferUtil.read(r, (int) r.length());
0:         content = ByteBufferUtil.read(r, 10); // reading first 10 bytes
0:         expectEOF(() -> ByteBufferUtil.read(r, (int) r.length() + 10));
/////////////////////////////////////////////////////////////////////////
0:         expectException(() -> { file.seek(file.length() + 30); return null; }, IllegalArgumentException.class);
0:         expectException(() -> { file.seek(-1); return null; }, IllegalArgumentException.class); // throws IllegalArgumentException
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = new RandomAccessReader.Builder(channel)
0:                                                      .bufferSize(bufferSize)
0:                                                      .build())
1:                     expectEOF(() -> { file.readFully(target, offset, 17); return null; });
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = new RandomAccessReader.Builder(channel).bufferSize(bufferSize).build())
1:                     expectEOF(() -> {
0:                         while (true)
0:                             file.readFully(target, 0, n);
/////////////////////////////////////////////////////////////////////////
1:         expectException(() -> r.read(), NullPointerException.class);
1:         expectException(() -> { w.write(generateByteArray(1)); return null; }, NullPointerException.class);
1:             ByteBuffer contents = ByteBufferUtil.read(copy, (int) copy.length());
/////////////////////////////////////////////////////////////////////////
1:     @Test(expected = AssertionError.class)
/////////////////////////////////////////////////////////////////////////
1:         expectException(() -> { copy.seek(copy.length() + 1); return null; }, IllegalArgumentException.class);
/////////////////////////////////////////////////////////////////////////
1:         ByteBuffer contents = ByteBufferUtil.read(copy, (int) copy.length());
commit:4e29b7a
/////////////////////////////////////////////////////////////////////////
0:                 try (final ChannelProxy channel = new ChannelProxy(file1);
0:                      final RandomAccessReader file = RandomAccessReader.open(channel, bufferSize, null))
/////////////////////////////////////////////////////////////////////////
0:                 try (final ChannelProxy channel = new ChannelProxy(file1);
0:                      final RandomAccessReader file = RandomAccessReader.open(channel, bufferSize, null))
/////////////////////////////////////////////////////////////////////////
1:         try (final RandomAccessReader reader = RandomAccessReader.open(writeTemporaryFile(new byte[1])))
1:         {
1:             assertEquals(1, reader.read(new byte[2]));
1:         }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:29687a8
/////////////////////////////////////////////////////////////////////////
1:         //Used to throw ClosedChannelException, but now that it extends BDOSP it just NPEs on the buffer
1:         //Writing to a BufferedOutputStream that is closed generates no error
1:         //Going to allow the NPE to throw to catch as a bug any use after close. Notably it won't throw NPE for a
1:         //write of a 0 length, but that is kind of a corner case
/////////////////////////////////////////////////////////////////////////
0:         }, NullPointerException.class);
commit:91187b5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.SyncUtil;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         SyncUtil.sync(fout);
author:stefania
-------------------------------------------------------------------------------
commit:17dd4cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
/////////////////////////////////////////////////////////////////////////
0:         RandomAccessReader r = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         r = RandomAccessReader.open(channel); // re-opening file in read-only mode
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
0:         RandomAccessReader r = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         try (ChannelProxy channel = new ChannelProxy(tmpFile);
0:             RandomAccessReader r = RandomAccessReader.open(channel))
1:         {
0:             assertEquals(lessThenBuffer.length + biggerThenBuffer.length, r.length());
1:         }
/////////////////////////////////////////////////////////////////////////
0:         final ChannelProxy channel = new ChannelProxy(w.getPath());
0:         final RandomAccessReader r = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         final ChannelProxy channel = new ChannelProxy(w.getPath());
0:         final RandomAccessReader file = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
0:         RandomAccessReader file = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
0:         RandomAccessReader r = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = RandomAccessReader.open(channel, bufferSize, -1L))
/////////////////////////////////////////////////////////////////////////
0:                      final RandomAccessReader file = RandomAccessReader.open(channel, bufferSize, -1L))
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
0:         RandomAccessReader r = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:         ChannelProxy channel = new ChannelProxy(w.getPath());
0:         RandomAccessReader file = RandomAccessReader.open(channel);
/////////////////////////////////////////////////////////////////////////
0:         channel.close();
/////////////////////////////////////////////////////////////////////////
0:             try (ChannelProxy channel = new ChannelProxy(w.getPath());
0:                  RandomAccessReader r = RandomAccessReader.open(channel))
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:8704006
/////////////////////////////////////////////////////////////////////////
1:         w.finish();
/////////////////////////////////////////////////////////////////////////
1:         w.finish();
/////////////////////////////////////////////////////////////////////////
1:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
1:         file.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w.finish();
/////////////////////////////////////////////////////////////////////////
0:         w1.finish();
0:         w2.finish();
/////////////////////////////////////////////////////////////////////////
1:         file.finish();
author:Jake Luciani
-------------------------------------------------------------------------------
commit:561f6ef
/////////////////////////////////////////////////////////////////////////
0:         final FileCacheService.CacheKey cacheKey = new FileCacheService.CacheKey();
1: 
/////////////////////////////////////////////////////////////////////////
0:             FileCacheService.instance.put(cacheKey, r1);
0:             FileCacheService.instance.put(cacheKey, r2);
commit:fe8829f
commit:e9d0214
commit:ad6ba3d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.FileCacheService;
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0:     public void testFileCacheService() throws IOException, InterruptedException
1:     {
0:         //see https://issues.apache.org/jira/browse/CASSANDRA-7756
1: 
0:         final int THREAD_COUNT = 40;
0:         ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);
1: 
0:         SequentialWriter w1 = createTempFile("fscache1");
0:         SequentialWriter w2 = createTempFile("fscache2");
1: 
0:         w1.write(new byte[30]);
0:         w1.close();
1: 
0:         w2.write(new byte[30]);
0:         w2.close();
1: 
0:         for (int i = 0; i < 20; i++)
1:         {
1: 
1: 
0:             RandomAccessReader r1 = RandomAccessReader.open(w1);
0:             RandomAccessReader r2 = RandomAccessReader.open(w2);
1: 
1: 
0:             FileCacheService.instance.put(r1);
0:             FileCacheService.instance.put(r2);
1: 
0:             final CountDownLatch finished = new CountDownLatch(THREAD_COUNT);
0:             final AtomicBoolean hadError = new AtomicBoolean(false);
1: 
0:             for (int k = 0; k < THREAD_COUNT; k++)
1:             {
0:                 executorService.execute( new Runnable()
1:                 {
0:                     @Override
0:                     public void run()
1:                     {
0:                         try
1:                         {
0:                             long size = FileCacheService.instance.sizeInBytes();
1: 
0:                             while (size > 0)
0:                                 size = FileCacheService.instance.sizeInBytes();
1:                         }
0:                         catch (Throwable t)
1:                         {
0:                             t.printStackTrace();
0:                             hadError.set(true);
1:                         }
0:                         finally
1:                         {
0:                             finished.countDown();
1:                         }
1:                     }
0:                 });
1: 
1:             }
1: 
0:             finished.await();
0:             assert !hadError.get();
1:         }
1:     }
1: 
1:     @Test
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:c18ce58
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:01bc564
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
commit:edcc7f1
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
commit:6773383
/////////////////////////////////////////////////////////////////////////
1:                 File file1 = writeTemporaryFile(new byte[16]);
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false);
/////////////////////////////////////////////////////////////////////////
1:                 File file1 = writeTemporaryFile(new byte[16]);
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false);
commit:debb15e
/////////////////////////////////////////////////////////////////////////
0:         expectException(new Callable<Object>()
0:             public Object call()
0:         }, IllegalArgumentException.class);
/////////////////////////////////////////////////////////////////////////
0:             public Object call()
0:         }, AssertionError.class);
/////////////////////////////////////////////////////////////////////////
0:         expectException(new Callable<Object>()
0:             public Object call()
0:         }, IllegalArgumentException.class);
commit:d389047
/////////////////////////////////////////////////////////////////////////
1:         SequentialWriter w = createTempFile("braf");
1:         w.write(data);
1:         assertEquals(data.length, w.length());
0:         assertEquals(data.length, w.getFilePointer());
1: 
1:         w.sync();
0:         RandomAccessReader r = RandomAccessReader.open(w);
1: 
0:         assertEquals(data.length, r.read(buffer));
0:         assertEquals(r.read(), -1); // nothing more to read EOF
0:         assert r.bytesRemaining() == 0 && r.isEOF();
1: 
0:         r.close();
0:         byte[] bigData = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE + 10];
0:         long initialPosition = w.getFilePointer();
0:         w.write(bigData); // writing data
0:         assertEquals(w.getFilePointer(), initialPosition + bigData.length);
0:         assertEquals(w.length(), initialPosition + bigData.length); // file size should equals to last position
1: 
1:         w.sync();
1: 
0:         r = RandomAccessReader.open(w); // re-opening file in read-only mode
0:         r.seek(initialPosition); // back to initial (before write) position
0:             data[i] = (byte) r.read();
0:         assertEquals(r.getFilePointer(), initialPosition + data.length);
0:         assertEquals(r.length(), initialPosition + bigData.length);
0:         assertTrue(r.bytesRemaining() == 0 && r.isEOF()); // we are at the of the file
0:         r.seek(0);
0:         ByteBuffer fileContent = r.readBytes((int) w.length());
0:         assertEquals(fileContent.limit(), w.length());
0:         r.seek(initialPosition);
0:         r.readFully(data);
0:         assert r.bytesRemaining() == 0 && r.isEOF(); // we should be at EOF
0:         assertEquals(r.read(), -1);
0:         assertEquals(r.read(data), -1);
0:         assertEquals(r.read(data, 0, data.length), -1);
0:         r.seek(0);
0:         assertEquals(15, r.read(data, 0, 15));
0:         w.close();
0:         r.close();
1:     @Test
1:     public void testReadAndWriteOnCapacity() throws IOException
0:         SequentialWriter w = SequentialWriter.open(tmpFile);
0:         byte[] in = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE);
0:         w.write(in);
1: 
0:         RandomAccessReader r = RandomAccessReader.open(w);
0:         byte[] out = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE];
0:         r.read(out);
0:         int negone = r.read();
0:         r.close();
0:         w.close();
0:         SequentialWriter w = SequentialWriter.open(tmpFile);
0:         assertEquals(0, w.length());
0:         byte[] lessThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE / 2);
0:         w.write(lessThenBuffer);
0:         assertEquals(lessThenBuffer.length, w.length());
1:         w.sync();
0:         assertEquals(lessThenBuffer.length, w.length());
0:         byte[] biggerThenBuffer = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE * 2);
0:         w.write(biggerThenBuffer);
0:         assertEquals(biggerThenBuffer.length + lessThenBuffer.length, w.length());
0:         w.close();
0:         RandomAccessReader r = RandomAccessReader.open(tmpFile);
/////////////////////////////////////////////////////////////////////////
1:         final SequentialWriter w = createTempFile("brafReadBytes");
1:         byte[] data = new byte[RandomAccessReader.DEFAULT_BUFFER_SIZE + 10];
1:         w.write(data);
1:         w.sync();
0:         final RandomAccessReader r = RandomAccessReader.open(w);
1: 
0:         ByteBuffer content = r.readBytes((int) r.length());
0:         assertEquals(0, ByteBufferUtil.compare(content, data));
0:         assert r.bytesRemaining() == 0 && r.isEOF();
0:         r.seek(0);
0:         content = r.readBytes(10); // reading first 10 bytes
0:         assertEquals(r.bytesRemaining(), r.length() - content.limit());
0:                 return r.readBytes((int) r.length() + 10);
0:         w.close();
0:         r.close();
1:         SequentialWriter w = createTempFile("brafSeek");
1:         byte[] data = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE + 20);
1:         w.write(data);
0:         w.close();
0:         final RandomAccessReader file = RandomAccessReader.open(w);
/////////////////////////////////////////////////////////////////////////
0:         // trying to seek past the end of the file should produce EOFException
0:         expectEOF(new Callable<Object>()
1:         {
0:             public Object call() throws Exception
1:             {
0:                 file.seek(file.length() + 30);
0:                 return null;
1:             }
0:         });
/////////////////////////////////////////////////////////////////////////
1:         SequentialWriter w = createTempFile("brafSkipBytes");
1:         w.write(generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE * 2));
0:         w.close();
0:         RandomAccessReader file = RandomAccessReader.open(w);
/////////////////////////////////////////////////////////////////////////
1:         final SequentialWriter w = createTempFile("brafGetFilePointer");
0:         assertEquals(w.getFilePointer(), 0); // initial position should be 0
1:         w.write(generateByteArray(20));
0:         assertEquals(w.getFilePointer(), 20); // position 20 after writing 20 bytes
0:         w.sync();
0:         RandomAccessReader r = RandomAccessReader.open(w);
0:         r.seek(0);
0:         r.skipBytes(15);
0:         assertEquals(r.getFilePointer(), 15);
0:         r.read();
0:         assertEquals(r.getFilePointer(), 16);
0:         r.read(new byte[4]);
0:         assertEquals(r.getFilePointer(), 20);
0:         w.close();
0:         r.close();
1:         SequentialWriter file = createTempFile("brafGetPath");
0:         file.close();
1:     @Test
1:         for (int bufferSize : Arrays.asList(1, 2, 3, 5, 8, 64))  // smaller, equal, bigger buffer sizes
1:             final byte[] target = new byte[32];
1: 
1:             // single too-large read
1:             for (final int offset : Arrays.asList(0, 8))
0:                 final RandomAccessReader file = RandomAccessReader.open(writeTemporaryFile(new byte[16]), bufferSize);
0:                 expectEOF(new Callable<Object>()
0:                     public Object call() throws IOException
0:                         file.readFully(target, offset, 17);
0:                         return null;
1:                     }
0:                 });
1:             }
1:             // first read is ok but eventually EOFs
1:             for (final int n : Arrays.asList(1, 2, 4, 8))
1:             {
0:                 final RandomAccessReader file = RandomAccessReader.open(writeTemporaryFile(new byte[16]), bufferSize);
0:                 expectEOF(new Callable<Object>()
0:                     public Object call() throws IOException
0:                         while (true)
0:                             file.readFully(target, 0, n);
1:                     }
0:                 });
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(1, RandomAccessReader.open(writeTemporaryFile(new byte[1])).read(new byte[2]));
1:         SequentialWriter w = createTempFile("brafBytesRemaining");
1:         int toWrite = RandomAccessReader.DEFAULT_BUFFER_SIZE + 10;
1:         w.write(generateByteArray(toWrite));
0:         w.sync();
0:         RandomAccessReader r = RandomAccessReader.open(w);
1: 
0:         assertEquals(r.bytesRemaining(), toWrite);
1: 
0:         for (int i = 1; i <= r.length(); i++)
0:             r.read();
0:             assertEquals(r.bytesRemaining(), r.length() - i);
0:         r.seek(0);
0:         r.skipBytes(10);
0:         assertEquals(r.bytesRemaining(), r.length() - 10);
0:         w.close();
0:         r.close();
/////////////////////////////////////////////////////////////////////////
0:         final RandomAccessReader r = RandomAccessReader.open(new File(tmpFile.getPath()));
0:         assert tmpFile.getPath().equals(r.getPath());
0:         final FileMark mark = r.mark();
0:         r.reset(mark);
0:         r.bytesPastMark(mark);
1:         final SequentialWriter w = createTempFile("brafClose");
1:         byte[] data = generateByteArray(RandomAccessReader.DEFAULT_BUFFER_SIZE + 20);
1:         w.write(data);
0:         w.close(); // will flush
1: 
1:         final RandomAccessReader r = RandomAccessReader.open(new File(w.getPath()));
1: 
1:         r.close(); // closing to test read after close
0:                 return r.read();
/////////////////////////////////////////////////////////////////////////
0:                 w.write(generateByteArray(1));
0:         RandomAccessReader copy = RandomAccessReader.open(new File(r.getPath()));
/////////////////////////////////////////////////////////////////////////
1:         SequentialWriter w = createTempFile("brafTestMark");
1:         w.write(new byte[30]);
1: 
0:         w.close();
1: 
0:         RandomAccessReader file = RandomAccessReader.open(w);
/////////////////////////////////////////////////////////////////////////
0:         SequentialWriter w = createTempFile("brafAssertionErrorWhenBytesPastMarkIsNegative");
0:         w.write(new byte[30]);
0:         w.close();
0:         RandomAccessReader r = RandomAccessReader.open(w);
0:         r.seek(10);
0:         r.mark();
0:         r.seek(0);
0:         r.bytesPastMark();
1:         SequentialWriter file = createTempFile("brafReadOnlyTest");
/////////////////////////////////////////////////////////////////////////
1:         final RandomAccessReader copy = RandomAccessReader.open(new File(file.getPath()));
/////////////////////////////////////////////////////////////////////////
0:         // Any write() call should fail
/////////////////////////////////////////////////////////////////////////
0:         }, UnsupportedOperationException.class);
/////////////////////////////////////////////////////////////////////////
0:         }, UnsupportedOperationException.class);
/////////////////////////////////////////////////////////////////////////
0:         }, UnsupportedOperationException.class);
/////////////////////////////////////////////////////////////////////////
1:     @Test (expected=IllegalArgumentException.class)
1:     public void testSetNegativeLength() throws IOException, IllegalArgumentException
1:         File tmpFile = File.createTempFile("set_negative_length", "bin");
0:         SequentialWriter file = SequentialWriter.open(tmpFile);
0:         file.truncate(-8L);
1:     }
1: 
0:     @Test (expected=IOException.class)
0:     public void testSetLengthDuringReadMode() throws IOException
1:     {
0:         File tmpFile = File.createTempFile("set_length_during_read_mode", "bin");
0:         RandomAccessReader file = RandomAccessReader.open(tmpFile);
0:         file.setLength(4L);
1:     }
1: 
1:     private SequentialWriter createTempFile(String name) throws IOException
1:     {
1:         File tempFile = File.createTempFile(name, null);
1:         tempFile.deleteOnExit();
1: 
0:         return SequentialWriter.open(tempFile);
1:     }
1: 
1:     private File writeTemporaryFile(byte[] data) throws IOException
1:     {
1:         File f = File.createTempFile("BRAFTestFile", null);
1:         f.deleteOnExit();
1:         FileOutputStream fout = new FileOutputStream(f);
1:         fout.write(data);
0:         fout.getFD().sync();
1:         fout.close();
1:         return f;
1:     }
1: 
1:     private byte[] generateByteArray(int length)
1:     {
1:         byte[] arr = new byte[length];
1: 
1:         for (int i = 0; i < length; i++)
1:             arr[i] = 'a';
1: 
1:         return arr;
1:     }
1: 
0:     private void expectEOF(Callable<?> callable)
1:     {
0:         expectException(callable, EOFException.class);
/////////////////////////////////////////////////////////////////////////
commit:139203d
commit:a4b7112
/////////////////////////////////////////////////////////////////////////
commit:1946cfd
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void assertSetLength(BufferedRandomAccessFile file, long length) throws IOException
1:     {
0:         assert file.getFilePointer() == length;
0:         assert file.length() == file.getFilePointer();
0:         assert file.getChannel().size() == file.length();
1:     }
1: 
1:     @Test
0:     public void testSetLength() throws IOException
1:     {
0:         File tmpFile = File.createTempFile("set_length", "bin");
0:         BufferedRandomAccessFile file = new BufferedRandomAccessFile(tmpFile, "rw", 8*1024*1024);
1: 
0:         // test that data in buffer is truncated
0:         file.writeLong(1L);
0:         file.writeLong(2L);
0:         file.writeLong(3L);
0:         file.writeLong(4L);
0:         file.setLength(16L);
0:         assertSetLength(file, 16L);
1: 
0:         // seek back and truncate within file
0:         file.writeLong(3L);
0:         file.seek(8L);
0:         file.setLength(24L);
0:         assertSetLength(file, 24L);
1: 
0:         // seek back and truncate past end of file
0:         file.setLength(64L);
0:         assertSetLength(file, 64L);
1: 
0:         // make sure file is consistent after sync
0:         file.sync();
0:         assertSetLength(file, 64L);
1:     }
1: 
0:     @Test (expected=IllegalArgumentException.class)
0:     public void testSetNegativeLength() throws IOException, IllegalArgumentException
1:     {
0:         File tmpFile = File.createTempFile("set_negative_length", "bin");
0:         BufferedRandomAccessFile file = new BufferedRandomAccessFile(tmpFile, "rw", 8*1024*1024);
0:         file.setLength(-8L);
1:     }
1: 
0:     @Test (expected=IOException.class)
0:     public void testSetLengthDuringReadMode() throws IOException
1:     {
0:         File tmpFile = File.createTempFile("set_length_during_read_mode", "bin");
0:         BufferedRandomAccessFile file = new BufferedRandomAccessFile(tmpFile, "r", 8*1024*1024);
0:         file.setLength(4L);
1:     }
commit:1f07312
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testReadOnly() throws IOException
1:     {
0:         BufferedRandomAccessFile file = createTempFile("brafReadOnlyTest");
1: 
1:         byte[] data = new byte[20];
1:         for (int i = 0; i < data.length; i++)
1:             data[i] = 'c';
1: 
1:         file.write(data);
1:         file.sync(); // flushing file to the disk
1: 
1:         // read-only copy of the file, with fixed file length
0:         final BufferedRandomAccessFile copy = new BufferedRandomAccessFile(file.getPath(), "r");
1: 
1:         copy.seek(copy.length());
1:         assertTrue(copy.bytesRemaining() == 0 && copy.isEOF());
1: 
1:         // can't seek past the end of the file for read-only files
0:         expectEOF(new Callable<Object>()
1:         {
0:             public Object call() throws IOException
1:             {
0:                 copy.seek(copy.length() + 1);
0:                 return null;
1:             }
0:         });
1: 
0:         /* Any write() call should fail */
0:         expectException(new Callable<Object>()
1:         {
0:             public Object call() throws IOException
1:             {
0:                 copy.write(1);
0:                 return null;
1:             }
0:         }, IOException.class);
1: 
0:         expectException(new Callable<Object>()
1:         {
0:             public Object call() throws IOException
1:             {
0:                 copy.write(new byte[1]);
0:                 return null;
1:             }
0:         }, IOException.class);
1: 
0:         expectException(new Callable<Object>()
1:         {
0:             public Object call() throws IOException
1:             {
0:                 copy.write(new byte[3], 0, 2);
0:                 return null;
1:             }
0:         }, IOException.class);
1: 
1:         copy.seek(0);
1:         copy.skipBytes(5);
1: 
1:         assertEquals(copy.bytesRemaining(), 15);
1:         assertEquals(copy.getFilePointer(), 5);
1:         assertTrue(!copy.isEOF());
1: 
1:         copy.seek(0);
0:         ByteBuffer contents = copy.readBytes((int) copy.length());
1: 
1:         assertEquals(contents.limit(), copy.length());
1:         assertTrue(ByteBufferUtil.compare(contents, data) == 0);
1: 
1:         copy.seek(0);
1: 
1:         int count = 0;
1:         while (!copy.isEOF())
1:         {
1:             assertEquals((byte) copy.read(), 'c');
1:             count++;
1:         }
1: 
1:         assertEquals(count, copy.length());
1: 
1:         copy.seek(0);
1:         byte[] content = new byte[10];
1:         copy.read(content);
1: 
1:         assertEquals(new String(content), "cccccccccc");
1: 
0:         file.close();
1:         copy.close();
1:     }
1: 
1:     @Test
0:     public void testSeekPastEOF() throws IOException
1:     {
0:         BufferedRandomAccessFile file = createTempFile("brafTestSeekPastEOF");
0:         file.seek(1);
0:         file.write(1);
0:         file.seek(0);
0:         assertEquals(0, file.read());
0:         assertEquals(1, file.read());
1:     }
1: 
commit:bca6a24
/////////////////////////////////////////////////////////////////////////
0: /**
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
1: package org.apache.cassandra.io.util;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: import java.nio.ByteBuffer;
0: import java.nio.channels.ClosedChannelException;
0: import static org.junit.Assert.assertTrue;
0: import org.junit.Test;
1: 
1:     @Test
1:     public void testReadAndWrite() throws Exception
0:     {
0:         BufferedRandomAccessFile file = createTempFile("braf");
1: 
0:         // writting string of data to the file
1:         byte[] data = "Hello".getBytes();
0:         file.write(data);
0:         assertEquals(file.length(), data.length);
0:         assertEquals(file.getFilePointer(), data.length);
1: 
1:         // reading small amount of data from file, this is handled by initial buffer
0:         file.seek(0);
0:         byte[] buffer = new byte[data.length];
0:         assertEquals(file.read(buffer), data.length);
0:         assertTrue(Arrays.equals(buffer, data)); // we read exactly what we wrote
0:         assertEquals(file.read(), -1); // nothing more to read EOF
0:         assert file.bytesRemaining() == 0 && file.isEOF();
1: 
0:         // writing buffer bigger than page size, which will trigger reBuffer()
0:         byte[] bigData = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10];
1: 
0:         for (int i = 0; i < bigData.length; i++)
0:             bigData[i] = 'd';
1: 
0:         long initialPosition = file.getFilePointer();
0:         file.write(bigData); // writing data
0:         assertEquals(file.getFilePointer(), initialPosition + bigData.length);
0:         assertEquals(file.length(), initialPosition + bigData.length); // file size should equals to last position
1: 
0:         // reading written buffer
0:         file.seek(initialPosition); // back to initial (before write) position
0:         data = new byte[bigData.length];
0:         long sizeRead = 0;
1:         for (int i = 0; i < data.length; i++)
0:         {
0:             data[i] = (byte) file.read(); // this will trigger reBuffer()
0:             sizeRead++;
0:         }
1: 
0:         assertEquals(sizeRead, data.length); // read exactly data.length bytes
0:         assertEquals(file.getFilePointer(), initialPosition + data.length);
0:         assertEquals(file.length(), initialPosition + bigData.length);
0:         assertTrue(Arrays.equals(bigData, data));
0:         assert file.bytesRemaining() == 0 && file.isEOF(); // we are at the of the file
1: 
0:         // test readBytes(int) method
0:         file.seek(0);
0:         ByteBuffer fileContent = file.readBytes((int) file.length());
0:         assertEquals(fileContent.limit(), file.length());
0:         assert ByteBufferUtil.string(fileContent).equals("Hello" + new String(bigData));
1: 
0:         // read the same buffer but using readFully(int)
0:         data = new byte[bigData.length];
0:         file.seek(initialPosition);
0:         file.readFully(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF(); // we should be at EOF
0:         assertTrue(Arrays.equals(bigData, data));
1: 
0:         // try to read past mark (all methods should return -1)
0:         data = new byte[10];
0:         assertEquals(file.read(), -1);
0:         assertEquals(file.read(data), -1);
0:         assertEquals(file.read(data, 0, data.length), -1);
1: 
0:         // test read(byte[], int, int)
0:         file.seek(0);
0:         data = new byte[20];
0:         assertEquals(file.read(data, 0, 15), 15);
0:         assertTrue(new String(data).contains("Hellodddddddddd"));
0:         for (int i = 16; i < data.length; i++)
0:         {
0:             assert data[i] == 0;
0:         }
1: 
0:         // try to seek past EOF
0:         file.seek(file.length() + 10); // should not throw an exception
0:         assert file.bytesRemaining() == 0 && file.isEOF();
1: 
0:         file.close();
0:     }
1: 
1:      @Test
0:     public void testReadsAndWriteOnCapacity() throws IOException
0:     {
1:         File tmpFile = File.createTempFile("readtest", "bin");
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
1: 
0:         // Fully write the file and sync..
0:         byte[] in = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.write(in);
1: 
0:         // Read it into a same size array.
0:         byte[] out = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.read(out);
1: 
0:         // We're really at the end.
0:         long rem = rw.bytesRemaining();
0:         assert rw.isEOF();
0:         assert rem == 0 : "BytesRemaining should be 0 but it's " + rem;
1: 
0:         // Cannot read any more.
0:         int negone = rw.read();
0:         assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
1: 
0:         // Writing will succeed
0:         rw.write(new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE]);
0:         // Forcing a rebuffer here
0:         rw.write(42);
0:     }
/////////////////////////////////////////////////////////////////////////
1:     public void testReadBytes() throws IOException
0:         final BufferedRandomAccessFile file = createTempFile("brafReadBytes");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10];
0:         for (int i = 0; i < data.length; i++)
0:         {
1:             data[i] = 'c';
0:         }
0:         file.write(data);
0:         file.seek(0);
0:         ByteBuffer content = file.readBytes((int) file.length());
0:         // after reading whole file we should be at EOF
0:         assertEquals(ByteBufferUtil.compare(content, data), 0);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0:         content = file.readBytes(10); // reading first 10 bytes
0:         assertEquals(ByteBufferUtil.compare(content, "cccccccccc".getBytes()), 0);
0:         assertEquals(file.bytesRemaining(), file.length() - content.limit());
0: 
0:         // trying to read more than file has right now
0:         expectEOF(new Callable<Object>()
0:         {
0:             public Object call() throws IOException
0:             {
0:                 return file.readBytes((int) file.length() + 10);
0:             }
0:         });
0: 
0:         file.close();
1:     public void testSeek() throws Exception
0:         final BufferedRandomAccessFile file = createTempFile("brafSeek");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 20];
0:         for (int i = 0; i < data.length; i++)
1:             data[i] = 'c';
0: 
0:         file.write(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0:         assertEquals(file.getFilePointer(), 0);
0:         assertEquals(file.bytesRemaining(), file.length());
0: 
0:         file.seek(20);
0:         assertEquals(file.getFilePointer(), 20);
0:         assertEquals(file.bytesRemaining(), file.length() - 20);
0: 
0:         // trying to seek past the end of the file
0:         file.seek(file.length() + 30);
0:         assertEquals(file.getFilePointer(), data.length + 30);
0:         assertEquals(file.getFilePointer(), file.length()); // length should be at seek position
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         expectException(new Callable<Object>()
0:             public Object call() throws IOException
0:             {
0:                 file.seek(-1);
0:                 return null;
0:             }
0:         }, IllegalArgumentException.class); // throws IllegalArgumentException
0: 
0:         file.close();
1:     public void testSkipBytes() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafSkipBytes");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE * 2];
0: 
0:         file.write(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0); // back to the beginning of the file
0:         assertEquals(file.skipBytes(10), 10);
0:         assertEquals(file.bytesRemaining(), file.length() - 10);
0: 
0:         int initialPosition = (int) file.getFilePointer();
0:         // can't skip more than file size
0:         assertEquals(file.skipBytes((int) file.length() + 10), file.length() - initialPosition);
0:         assertEquals(file.getFilePointer(), file.length());
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0: 
0:         // skipping negative amount should return 0
0:         assertEquals(file.skipBytes(-1000), 0);
0:         assertEquals(file.getFilePointer(), 0);
0:         assertEquals(file.bytesRemaining(), file.length());
0: 
0:         file.close();
0:     }
0: 
1:     @Test
1:     public void testGetFilePointer() throws IOException
0:     {
0:         final BufferedRandomAccessFile file = createTempFile("brafGetFilePointer");
0: 
0:         assertEquals(file.getFilePointer(), 0); // initial position should be 0
0: 
0:         file.write(new byte[20]);
0:         assertEquals(file.getFilePointer(), 20); // position 20 after writing 20 bytes
0: 
0:         file.seek(10);
0:         assertEquals(file.getFilePointer(), 10); // after seek to 10 should be 10
0: 
0:         expectException(new Callable<Object>()
0:         {
0:             public Object call() throws IOException
0:             {
0:                 file.seek(-1);
0:                 return null;
0:             }
0:         }, IllegalArgumentException.class);
0: 
0:         assertEquals(file.getFilePointer(), 10);
0: 
0:         file.seek(30); // past previous end file
0:         assertEquals(file.getFilePointer(), 30);
0: 
0:         // position should change after skip bytes
0:         file.seek(0);
0:         file.skipBytes(15);
0:         assertEquals(file.getFilePointer(), 15);
0: 
0:         file.read();
0:         assertEquals(file.getFilePointer(), 16);
0:         file.read(new byte[4]);
0:         assertEquals(file.getFilePointer(), 20);
0: 
0:         file.close();
0:     }
0: 
1:     @Test
1:     public void testGetPath() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafGetPath");
1:         assert file.getPath().contains("brafGetPath");
0:     }
0: 
1:      @Test
1:     public void testIsEOF() throws IOException
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testNotEOF() throws IOException
0:     {
0:         assertEquals(1, new BufferedRandomAccessFile(writeTemporaryFile(new byte[1]), "rw").read(new byte[2]));
0:     }
0: 
1:     @Test
1:     public void testBytesRemaining() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafBytesRemaining");
0:         assertEquals(file.bytesRemaining(), 0);
0: 
0:         int toWrite = BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10;
0: 
0:         file.write(new byte[toWrite]);
0:         assertEquals(file.bytesRemaining(), 0);
0: 
0:         file.seek(0);
0:         assertEquals(file.bytesRemaining(), toWrite);
0: 
0:         for (int i = 1; i <= file.length(); i++)
0:         {
0:             file.read();
0:             assertEquals(file.bytesRemaining(), file.length() - i);
0:         }
0: 
0:         file.seek(0);
0:         file.skipBytes(10);
0:         assertEquals(file.bytesRemaining(), file.length() - 10);
0: 
0:         file.close();
0:     }
0: 
1:     @Test
1:     public void testBytesPastMark() throws IOException
0:     {
1:         File tmpFile = File.createTempFile("overflowtest", "bin");
1:         tmpFile.deleteOnExit();
0: 
1:         // Create the BRAF by filename instead of by file.
0:         final BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         assert tmpFile.getPath().equals(rw.getPath());
0: 
0:         // Create a mark and move the rw there.
0:         final FileMark mark = rw.mark();
0:         rw.reset(mark);
0: 
0:         // Expect this call to succeed.
0:         rw.bytesPastMark(mark);
0: 
0:         // Seek 4gb
0:         rw.seek(4L*1024L*1024L*1024L*1024L);
0: 
0:         // Expect this call to fail -- the distance from mark to current file pointer > 2gb.
0:         expectException(new Callable<Object>()
0:         {
0:             public Object call() throws IOException
0:             {
0:                 return rw.bytesPastMark(mark);
0:             }
0:         }, UnsupportedOperationException.class);
0:     }
0: 
1:     @Test
1:     public void testClose() throws IOException
0:     {
0:         final BufferedRandomAccessFile file = createTempFile("brafClose");
0: 
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 20];
0:         for (int i = 0; i < data.length; i++)
0:         {
0:             data[i] = 'c';
0:         }
0: 
0:         file.write(data);
0:         file.close();
0: 
0:         expectException(new Callable<Object>()
0:         {
0:             public Object call() throws IOException
0:             {
0:                 return file.read();
0:             }
0:         }, ClosedChannelException.class);
0: 
0:         expectException(new Callable<Object>()
0:         {
0:             public Object call() throws IOException
0:             {
0:                 file.write(new byte[1]);
0:                 return null;
0:             }
0:         }, ClosedChannelException.class);
0: 
0:         BufferedRandomAccessFile copy = new BufferedRandomAccessFile(file.getPath(), "r");
0:         ByteBuffer contents = copy.readBytes((int) copy.length());
0: 
0:         assertEquals(contents.limit(), data.length);
0:         assertEquals(ByteBufferUtil.compare(contents, data), 0);
0:     }
0: 
1:     @Test
1:     public void testMarkAndReset() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafTestMark");
0:         file.write(new byte[30]);
0: 
0:         file.seek(10);
0:         FileMark mark = file.mark();
0: 
0:         file.seek(file.length());
0:         assertTrue(file.isEOF());
0: 
0:         file.reset();
0:         assertEquals(file.bytesRemaining(), 20);
0: 
0:         file.seek(file.length());
0:         assertTrue(file.isEOF());
0: 
0:         file.reset(mark);
0:         assertEquals(file.bytesRemaining(), 20);
0: 
0:         file.seek(file.length());
0:         assertEquals(file.bytesPastMark(), 20);
0:         assertEquals(file.bytesPastMark(mark), 20);
0: 
0:         file.reset(mark);
0:         assertEquals(file.bytesPastMark(), 0);
0: 
0:         file.close();
0:     }
0: 
0:     @Test (expected = AssertionError.class)
1:     public void testAssertionErrorWhenBytesPastMarkIsNegative() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafAssertionErrorWhenBytesPastMarkIsNegative");
0:         file.write(new byte[30]);
0: 
0:         file.seek(10);
0:         file.mark();
0: 
0:         file.seek(0);
0:         file.bytesPastMark();
0:     }
0: 
0:     private void expectException(Callable<?> callable, Class<?> exception)
0:     {
0:         boolean thrown = false;
0: 
0:         try
0:         {
0:             callable.call();
0:         }
0:         catch (Exception e)
0:         {
0:             assert e.getClass().equals(exception) : e.getClass().getName() + " is not " + exception.getName();
0:             thrown = true;
0:         }
0: 
0:         assert thrown : exception.getName() + " not received";
0:     }
0: 
0:     private void expectEOF(Callable<?> callable)
0:     {
0:         expectException(callable, EOFException.class);
0:     }
0: 
0:     private BufferedRandomAccessFile createTempFile(String name) throws IOException
0:     {
0:         File tempFile = File.createTempFile(name, null);
0:         tempFile.deleteOnExit();
0: 
0:         return new BufferedRandomAccessFile(tempFile, "rw");
0:     }
0: 
0:     private File writeTemporaryFile(byte[] data) throws IOException
/////////////////////////////////////////////////////////////////////////
commit:ece6605
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.io.util;
0: /*
0:  * 
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * 
1: import static org.junit.Assert.assertEquals;
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testReadsAndWriteOnCapacity() throws IOException
0:         File tmpFile = File.createTempFile("readtest", "bin");
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
0:         // Fully write the file and sync..
0:         byte[] in = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.write(in);
0:         // Read it into a same size array.
0:         byte[] out = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.read(out);
0:         // We're really at the end.
0:         long rem = rw.bytesRemaining();
0:         assert rw.isEOF();
0:         assert rem == 0 : "BytesRemaining should be 0 but it's " + rem;
0:         // Cannot read any more.
0:         int negone = rw.read();
0:         assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
0:         // Writing will succeed
0:         rw.write(new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE]);
0:         // Forcing a rebuffer here
0:         rw.write(42);
0:     public void testNotEOF() throws IOException
0:         assertEquals(1, new BufferedRandomAccessFile(writeTemporaryFile(new byte[1]), "rw").read(new byte[2]));
0: 
0:     protected void expectEOF(Callable<?> callable)
0:         boolean threw = false;
0:         try
0:         {
0:             callable.call();
0:         }
0:         catch (Exception e)
0:         {
0:             assert e.getClass().equals(EOFException.class) : e.getClass().getName() + " is not " + EOFException.class.getName();
0:             threw = true;
0:         }
0:         assert threw : EOFException.class.getName() + " not received";
0:     public void testEOF() throws IOException
/////////////////////////////////////////////////////////////////////////
0:     protected File writeTemporaryFile(byte[] data) throws IOException
0:         File f = File.createTempFile("BRAFTestFile", null);
0:         f.deleteOnExit();
0:         FileOutputStream fout = new FileOutputStream(f);
0:         fout.write(data);
0:         fout.getFD().sync();
0:         fout.close();
0:         return f;
0:     @Test (expected=UnsupportedOperationException.class)
0:     public void testOverflowMark() throws IOException
/////////////////////////////////////////////////////////////////////////
0:         int bpm = rw.bytesPastMark(mark);
0:         
0:         bpm = rw.bytesPastMark(mark);
0:     @Test
0:     public void testRead() throws IOException
0:         File tmpFile = File.createTempFile("readtest", "bin");
0:         tmpFile.deleteOnExit();
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         rw.write(new byte[]{ 1 });
0:         rw.seek(0);
0:         // test read of buffered-but-not-yet-written data
0:         byte[] buffer = new byte[1];
0:         assertEquals(1, rw.read(buffer));
0:         assertEquals(1, buffer[0]);
0:         rw.close();
0:         // test read of not-yet-buffered data
0:         rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         assert rw.read(buffer) == 1;
0:         assert buffer[0] == 1;
commit:2b414b1
/////////////////////////////////////////////////////////////////////////
0: /**
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
0: package org.apache.cassandra.io.util;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import java.nio.ByteBuffer;
0: import java.nio.channels.ClosedChannelException;
0: import static org.junit.Assert.assertTrue;
0: import org.junit.Test;
0: 
0:     @Test
0:     public void testReadAndWrite() throws Exception
0:     {
0:         BufferedRandomAccessFile file = createTempFile("braf");
0: 
0:         // writting string of data to the file
0:         byte[] data = "Hello".getBytes();
0:         file.write(data);
0:         assertEquals(file.length(), data.length);
0:         assertEquals(file.getFilePointer(), data.length);
0: 
0:         // reading small amount of data from file, this is handled by initial buffer
0:         file.seek(0);
0:         byte[] buffer = new byte[data.length];
0:         assertEquals(file.read(buffer), data.length);
0:         assertTrue(Arrays.equals(buffer, data)); // we read exactly what we wrote
0:         assertEquals(file.read(), -1); // nothing more to read EOF
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         // writing buffer bigger than page size, which will trigger reBuffer()
0:         byte[] bigData = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10];
0: 
0:         for (int i = 0; i < bigData.length; i++)
0:             bigData[i] = 'd';
0: 
0:         long initialPosition = file.getFilePointer();
0:         file.write(bigData); // writing data
0:         assertEquals(file.getFilePointer(), initialPosition + bigData.length);
0:         assertEquals(file.length(), initialPosition + bigData.length); // file size should equals to last position
0: 
0:         // reading written buffer
0:         file.seek(initialPosition); // back to initial (before write) position
0:         data = new byte[bigData.length];
0:         long sizeRead = 0;
0:         for (int i = 0; i < data.length; i++)
0:         {
0:             data[i] = (byte) file.read(); // this will trigger reBuffer()
0:             sizeRead++;
0:         }
0: 
0:         assertEquals(sizeRead, data.length); // read exactly data.length bytes
0:         assertEquals(file.getFilePointer(), initialPosition + data.length);
0:         assertEquals(file.length(), initialPosition + bigData.length);
0:         assertTrue(Arrays.equals(bigData, data));
0:         assert file.bytesRemaining() == 0 && file.isEOF(); // we are at the of the file
0: 
0:         // test readBytes(int) method
0:         file.seek(0);
0:         ByteBuffer fileContent = file.readBytes((int) file.length());
0:         assertEquals(fileContent.limit(), file.length());
0:         assert ByteBufferUtil.string(fileContent).equals("Hello" + new String(bigData));
0: 
0:         // read the same buffer but using readFully(int)
0:         data = new byte[bigData.length];
0:         file.seek(initialPosition);
0:         file.readFully(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF(); // we should be at EOF
0:         assertTrue(Arrays.equals(bigData, data));
0: 
0:         // try to read past mark (all methods should return -1)
0:         data = new byte[10];
0:         assertEquals(file.read(), -1);
0:         assertEquals(file.read(data), -1);
0:         assertEquals(file.read(data, 0, data.length), -1);
0: 
0:         // test read(byte[], int, int)
0:         file.seek(0);
0:         data = new byte[20];
0:         assertEquals(file.read(data, 0, 15), 15);
0:         assertTrue(new String(data).contains("Hellodddddddddd"));
0:         for (int i = 16; i < data.length; i++)
0:         {
0:             assert data[i] == 0;
0:         }
0: 
0:         // try to seek past EOF
0:         file.seek(file.length() + 10); // should not throw an exception
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.close();
0:     }
0: 
0:     @Test
0:     public void testReadsAndWriteOnCapacity() throws IOException
0:     {
0:         File tmpFile = File.createTempFile("readtest", "bin");
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
0: 
0:         // Fully write the file and sync..
0:         byte[] in = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.write(in);
0: 
0:         // Read it into a same size array.
0:         byte[] out = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         rw.read(out);
0: 
0:         // We're really at the end.
0:         long rem = rw.bytesRemaining();
0:         assert rw.isEOF();
0:         assert rem == 0 : "BytesRemaining should be 0 but it's " + rem;
0: 
0:         // Cannot read any more.
0:         int negone = rw.read();
0:         assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
0: 
0:         // Writing will succeed
0:         rw.write(new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE]);
0:         // Forcing a rebuffer here
0:         rw.write(42);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     @Test (expected = EOFException.class)
0:     public void testReadBytes() throws IOException
0:         BufferedRandomAccessFile file = createTempFile("brafReadBytes");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10];
0:         for (int i = 0; i < data.length; i++)
0:             data[i] = 'c';
0: 
0:         file.write(data);
0: 
0:         file.seek(0);
0:         ByteBuffer content = file.readBytes((int) file.length());
0: 
0:         // after reading whole file we should be at EOF
0:         assertEquals(ByteBufferUtil.compare(content, data), 0);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0:         content = file.readBytes(10); // reading first 10 bytes
0:         assertEquals(ByteBufferUtil.compare(content, "cccccccccc".getBytes()), 0);
0:         assertEquals(file.bytesRemaining(), file.length() - content.limit());
0: 
0:         // trying to read more than file has right now
0:         file.readBytes((int) file.length() + 10); // this throws expected EOFException
0: 
0:         file.close();
0:     }
0: 
0:     @Test (expected = IllegalArgumentException.class)
0:     public void testSeek() throws Exception
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafSeek");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 20];
0:         for (int i = 0; i < data.length; i++)
0:             data[i] = 'c';
0: 
0:         file.write(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0:         assertEquals(file.getFilePointer(), 0);
0:         assertEquals(file.bytesRemaining(), file.length());
0: 
0:         file.seek(20);
0:         assertEquals(file.getFilePointer(), 20);
0:         assertEquals(file.bytesRemaining(), file.length() - 20);
0: 
0:         // trying to seek past the end of the file
0:         file.seek(file.length() + 30);
0:         assertEquals(file.getFilePointer(), data.length + 30);
0:         assertEquals(file.getFilePointer(), file.length()); // length should be at seek position
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(-1); // throws IllegalArgumentException
0: 
0:         file.close();
0:     public void testSkipBytes() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafSkipBytes");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE * 2];
0: 
0:         file.write(data);
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0); // back to the beginning of the file
0:         assertEquals(file.skipBytes(10), 10);
0:         assertEquals(file.bytesRemaining(), file.length() - 10);
0: 
0:         int initialPosition = (int) file.getFilePointer();
0:         // can't skip more than file size
0:         assertEquals(file.skipBytes((int) file.length() + 10), file.length() - initialPosition);
0:         assertEquals(file.getFilePointer(), file.length());
0:         assert file.bytesRemaining() == 0 && file.isEOF();
0: 
0:         file.seek(0);
0: 
0:         // skipping negative amount should return 0
0:         assertEquals(file.skipBytes(-1000), 0);
0:         assertEquals(file.getFilePointer(), 0);
0:         assertEquals(file.bytesRemaining(), file.length());
0: 
0:         file.close();
0:     }
0: 
0:     @Test (expected = IllegalArgumentException.class)
0:     public void testGetFilePointer() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafGetFilePointer");
0: 
0:         assertEquals(file.getFilePointer(), 0); // initial position should be 0
0: 
0:         file.write(new byte[20]);
0:         assertEquals(file.getFilePointer(), 20); // position 20 after writing 20 bytes
0: 
0:         file.seek(10);
0:         assertEquals(file.getFilePointer(), 10); // after seek to 10 should be 10
0: 
0:         file.seek(-1);
0:         assertEquals(file.getFilePointer(), 10);
0: 
0:         file.seek(30); // past previous end file
0:         assertEquals(file.getFilePointer(), 30);
0: 
0:         // position should change after skip bytes
0:         file.seek(0);
0:         file.skipBytes(15);
0:         assertEquals(file.getFilePointer(), 15);
0: 
0:         file.read();
0:         assertEquals(file.getFilePointer(), 16);
0:         file.read(new byte[4]);
0:         assertEquals(file.getFilePointer(), 20);
0: 
0:         file.close();
0:     }
0: 
0:     @Test
0:     public void testGetPath() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafGetPath");
0:         assert file.getPath().contains("brafGetPath");
0:     }
0: 
0:      @Test
0:     public void testIsEOF() throws IOException
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testNotEOF() throws IOException
0:         assertEquals(1, new BufferedRandomAccessFile(writeTemporaryFile(new byte[1]), "rw").read(new byte[2]));
0:     @Test
0:     public void testBytesRemaining() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafBytesRemaining");
0:         assertEquals(file.bytesRemaining(), 0);
0:         int toWrite = BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 10;
0: 
0:         file.write(new byte[toWrite]);
0:         assertEquals(file.bytesRemaining(), 0);
0: 
0:         file.seek(0);
0:         assertEquals(file.bytesRemaining(), toWrite);
0: 
0:         for (int i = 1; i <= file.length(); i++)
0:         {
0:             file.read();
0:             assertEquals(file.bytesRemaining(), file.length() - i);
0:         }
0: 
0:         file.seek(0);
0:         file.skipBytes(10);
0:         assertEquals(file.bytesRemaining(), file.length() - 10);
0: 
0:         file.close();
0:     }
0: 
0:     @Test (expected = UnsupportedOperationException.class)
0:     public void testBytesPastMark() throws IOException
/////////////////////////////////////////////////////////////////////////
0:         rw.bytesPastMark(mark);
0: 
0:         rw.bytesPastMark(mark);
0:     @Test (expected = ClosedChannelException.class)
0:     public void testClose() throws IOException
0:         BufferedRandomAccessFile file = createTempFile("brafClose");
0:         byte[] data = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE + 20];
0:         for (int i = 0; i < data.length; i++)
0:         {
0:             data[i] = 'c';
0:         }
0:         file.write(data);
0:         file.close();
0:         file.read(); // trying to read throws ClosedChannelException
0:         file.write(new byte[1]); // try to write throws ClosedChannelException
0: 
0:         BufferedRandomAccessFile copy = new BufferedRandomAccessFile(file.getPath(), "r");
0:         ByteBuffer contents = copy.readBytes((int) copy.length());
0: 
0:         assertEquals(contents.limit(), data.length);
0:         assertEquals(ByteBufferUtil.compare(contents, data), 0);
0:     @Test (expected = AssertionError.class)
0:     public void testMarkAndReset() throws IOException
0:     {
0:         BufferedRandomAccessFile file = createTempFile("brafTestMark");
0:         file.write(new byte[30]);
0: 
0:         file.seek(10);
0:         FileMark mark = file.mark();
0: 
0:         file.seek(file.length());
0:         assertTrue(file.isEOF());
0: 
0:         file.reset();
0:         assertEquals(file.bytesRemaining(), 20);
0: 
0:         file.seek(file.length());
0:         assertTrue(file.isEOF());
0: 
0:         file.reset(mark);
0:         assertEquals(file.bytesRemaining(), 20);
0: 
0:         file.seek(file.length());
0:         assertEquals(file.bytesPastMark(), 20);
0:         assertEquals(file.bytesPastMark(mark), 20);
0: 
0:         file.reset(mark);
0:         assertEquals(file.bytesPastMark(), 0);
0: 
0:         file.seek(0);
0:         file.bytesPastMark(); // throws AssertionError
0: 
0:         file.close();
0:     }
0: 
0:     private void expectEOF(Callable<?> callable)
0:     {
0:         boolean threw = false;
0:         try
0:         {
0:             callable.call();
0:         }
0:         catch (Exception e)
0:         {
0:             assert e.getClass().equals(EOFException.class) : e.getClass().getName() + " is not " + EOFException.class.getName();
0:             threw = true;
0:         }
0:         assert threw : EOFException.class.getName() + " not received";
0:     }
0: 
0:     private BufferedRandomAccessFile createTempFile(String name) throws IOException
0:     {
0:         File tempFile = File.createTempFile(name, null);
0:         tempFile.deleteOnExit();
0: 
0:         return new BufferedRandomAccessFile(tempFile, "rw");
0:     }
0: 
0:     private File writeTemporaryFile(byte[] data) throws IOException
0:     {
0:         File f = File.createTempFile("BRAFTestFile", null);
0:         f.deleteOnExit();
0:         FileOutputStream fout = new FileOutputStream(f);
0:         fout.write(data);
0:         fout.getFD().sync();
0:         fout.close();
0:         return f;
0:     }
commit:0792766
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testNotEOF() throws IOException
0:     {
0:         assertEquals(1, new BufferedRandomAccessFile(writeTemporaryFile(new byte[1]), "rw").read(new byte[2]));
0:     }
0: 
0: 
0:     protected void expectEOF(Callable<?> callable)
0:             callable.call();
0:         catch (Exception e)
0:             assert e.getClass().equals(EOFException.class) : e.getClass().getName() + " is not " + EOFException.class.getName();
0:     public void testEOF() throws IOException
0:             for (int bufferSize : Arrays.asList(1, 2, 3, 5, 8, 64))  // smaller, equal, bigger buffer sizes
0:                 final byte[] target = new byte[32];
0: 
0:                 // single too-large read
0:                 for (final int offset : Arrays.asList(0, 8))
0:                     final BufferedRandomAccessFile file = new BufferedRandomAccessFile(writeTemporaryFile(new byte[16]), mode, bufferSize);
0:                     expectEOF(new Callable<Object>()
0:                     {
0:                         public Object call() throws IOException
0:                         {
0:                             file.readFully(target, offset, 17);
0:                             return null;
0:                         }
0:                     });
0:                 }
0: 
0:                 // first read is ok but eventually EOFs
0:                 for (final int n : Arrays.asList(1, 2, 4, 8))
0:                 {
0:                     final BufferedRandomAccessFile file = new BufferedRandomAccessFile(writeTemporaryFile(new byte[16]), mode, bufferSize);
0:                     expectEOF(new Callable<Object>()
0:                     {
0:                         public Object call() throws IOException
0:                         {
0:                             while (true)
0:                                 file.readFully(target, 0, n);
0:                         }
0:                     });
0:     protected File writeTemporaryFile(byte[] data) throws IOException
/////////////////////////////////////////////////////////////////////////
0: 
0:         assertEquals(1, rw.read(buffer));
0:         assertEquals(1, buffer[0]);
commit:92d5315
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testRead() throws IOException
0:     {
0:         File tmpFile = File.createTempFile("readtest", "bin");
0:         tmpFile.deleteOnExit();
0: 
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         rw.write(new byte[]{ 1 });
0: 
0:         rw.seek(0);
0:         // test read of buffered-but-not-yet-written data
0:         byte[] buffer = new byte[1];
0:         assert rw.read(buffer) == 1;
0:         assert buffer[0] == 1;
0:         rw.close();
0: 
0:         // test read of not-yet-buffered data
0:         rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         assert rw.read(buffer) == 1;
0:         assert buffer[0] == 1;
0:     }
0: 
commit:3991fba
/////////////////////////////////////////////////////////////////////////
0:         byte[] lessThenBuffer = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE / 2];
/////////////////////////////////////////////////////////////////////////
0:         byte[] biggerThenBuffer = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE * 2];
/////////////////////////////////////////////////////////////////////////
0:         byte[] in = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
0:         byte[] out = new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE];
/////////////////////////////////////////////////////////////////////////
0:         rw.write(new byte[BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE]);
commit:1208a20
/////////////////////////////////////////////////////////////////////////
0:     public void testReadsAndWriteOnCapacity() throws IOException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         assert rw.isEOF();
0: 
0:         // Writing will succeed
0:         rw.write(new byte[BufferedRandomAccessFile.BuffSz_]);
0:         // Forcing a rebuffer here
0:         rw.write(42);
/////////////////////////////////////////////////////////////////////////
0:         // Create the BRAF by filename instead of by file.
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile.getPath(), "rw");
0:         assert tmpFile.getPath().equals(rw.getPath());
0: 
0:         // Create a mark and move the rw there.
0:         FileMark mark = rw.mark();
0:         rw.reset(mark);
0: 
0:         // Expect this call to succeed.
0: 
0:         // Seek 4gb
0:         rw.seek(4L*1024L*1024L*1024L*1024L);
0:         
0:         // Expect this call to fail -- the distance from mark to current file pointer > 2gb.
0:         bpm = rw.bytesPastMark(mark);
commit:73644f1
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testReadsOnCapacity() throws IOException
0:     {
0:         File tmpFile = File.createTempFile("readtest", "bin");
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
0: 
0:         // Fully write the file and sync..
0:         byte[] in = new byte[BufferedRandomAccessFile.BuffSz_];
0:         rw.write(in);
0:         rw.sync();
0: 
0:         // Read it into a same size array.
0:         byte[] out = new byte[BufferedRandomAccessFile.BuffSz_];
0:         rw.read(out);
0: 
0:         // We're really at the end.
0:         long rem = rw.bytesRemaining();
0:         assert rem == 0 : "BytesRemaining should be 0 but it's " + rem;
0: 
0:         // Cannot read any more.
0:         int negone = rw.read();
0:         assert negone == -1 : "We read past the end of the file, should have gotten EOF -1. Instead, " + negone;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test (expected=UnsupportedOperationException.class)
0:     public void testOverflowMark() throws IOException
0:     {
0:         File tmpFile = File.createTempFile("overflowtest", "bin");
0:         tmpFile.deleteOnExit();
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
0:         FileMark mark = rw.mark();
0:         rw.seek(4L*1024L*1024L*1024L*1024L); //seek 4gb
0: 
0:         //Expect this call to fail, because the distance from mark to current file pointer > 2gb.
0:         int bpm = rw.bytesPastMark(mark);
0:     }
commit:524290b
/////////////////////////////////////////////////////////////////////////
0: import java.io.EOFException;
1: import java.io.FileOutputStream;
1: import java.util.Arrays;
0: import static org.junit.Assert.assertEquals;
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected void expectException(int size, int offset, int len, BufferedRandomAccessFile braf)
0:     {
0:         boolean threw = false;
0:         try
0:         {
0:             braf.readFully(new byte[size], offset, len);
0:         }
0:         catch(Throwable t)
0:         {
0:             assert t.getClass().equals(EOFException.class) : t.getClass().getName() + " is not " + EOFException.class.getName();
0:             threw = true;
0:         }
0:         assert threw : EOFException.class.getName() + " not received";
0:     }
0: 
0:     @Test
0:     public void testEOF() throws Exception
0:     {
0:         for (String mode : Arrays.asList("r", "rw")) // read, read+write
0:         {
0:             for (int buf : Arrays.asList(8, 16, 32, 0))  // smaller, equal, bigger, zero
0:             {
0:                 for (int off : Arrays.asList(0, 8))
0:                 {
0:                     expectException(32, off, 17, new BufferedRandomAccessFile(writeTemporaryFile(new byte[16]), mode, buf));
0:                 }
0:             }
0:         }
0:     }
0: 
0:     protected File writeTemporaryFile(byte[] data) throws Exception
0:     {
0:         File f = File.createTempFile("BRAFTestFile", null);
0:         f.deleteOnExit();
0:         FileOutputStream fout = new FileOutputStream(f);
0:         fout.write(data);
0:         fout.getFD().sync();
0:         fout.close();
0:         return f;
0:     }
0: 
commit:78cbce1
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  * 
1:  */
0: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:27ed655
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null);
/////////////////////////////////////////////////////////////////////////
0:                 final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null);
commit:ba1821f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.Util.expectEOF;
1: import static org.apache.cassandra.Util.expectException;
0: 
/////////////////////////////////////////////////////////////////////////
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:0de8e54
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.io.util;
0: 
0: import static org.junit.Assert.*;
0: 
1: import java.io.File;
1: import java.io.IOException;
0: 
0: import org.junit.Test;
0: 
1: public class BufferedRandomAccessFileTest
0: {
0: 
0:     @Test
1:     public void testLength() throws IOException
0:     {
1:         File tmpFile = File.createTempFile("lengthtest", "bin");
0:         BufferedRandomAccessFile rw = new BufferedRandomAccessFile(tmpFile, "rw");
0:         assertEquals(0, rw.length());
0: 
0:         // write a chunk smaller then our buffer, so will not be flushed
0:         // to disk
0:         byte[] lessThenBuffer = new byte[BufferedRandomAccessFile.BuffSz_ / 2];
0:         rw.write(lessThenBuffer);
0:         assertEquals(lessThenBuffer.length, rw.length());
0: 
0:         // sync the data and check length
0:         rw.sync();
0:         assertEquals(lessThenBuffer.length, rw.length());
0: 
0:         // write more then the buffer can hold and check length
0:         byte[] biggerThenBuffer = new byte[BufferedRandomAccessFile.BuffSz_ * 2];
0:         rw.write(biggerThenBuffer);
0:         assertEquals(biggerThenBuffer.length + lessThenBuffer.length, rw.length());
0: 
0:         // checking that reading doesn't interfere
0:         rw.seek(0);
0:         rw.read();
0:         assertEquals(biggerThenBuffer.length + lessThenBuffer.length, rw.length());
0: 
0:         rw.close();
0: 
0:         // will use cachedlength
0:         BufferedRandomAccessFile r = new BufferedRandomAccessFile(tmpFile, "r");
0:         assertEquals(lessThenBuffer.length + biggerThenBuffer.length, r.length());
0:         r.close();
0:     }
0: 
0: }
============================================================================