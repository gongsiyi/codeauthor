1:0160ad5: /*
1:0160ad5:  * Licensed to the Apache Software Foundation (ASF) under one
1:0160ad5:  * or more contributor license agreements.  See the NOTICE file
1:0160ad5:  * distributed with this work for additional information
1:0160ad5:  * regarding copyright ownership.  The ASF licenses this file
1:0160ad5:  * to you under the Apache License, Version 2.0 (the
1:0160ad5:  * "License"); you may not use this file except in compliance
1:0160ad5:  * with the License.  You may obtain a copy of the License at
3:0160ad5:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:0160ad5:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
2:0160ad5:  */
1:0160ad5: package org.apache.cassandra.streaming;
6:0160ad5: 
1:5a6f0b8: import java.io.IOException;
1:5a6f0b8: import java.util.ArrayList;
1:5a6f0b8: import java.util.Collection;
1:5151169: import java.util.HashSet;
1:5a6f0b8: import java.util.List;
1:0160ad5: 
1:2ae5272: import org.apache.cassandra.db.TypeSizes;
1:8b9beaa: import org.apache.cassandra.dht.Range;
1:554223b: import org.apache.cassandra.dht.Token;
1:84eeb28: import org.apache.cassandra.io.IVersionedSerializer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:806facc: import org.apache.cassandra.net.MessagingService;
1:0160ad5: 
1:9471e8d: public class StreamRequest
7:0160ad5: {
1:587cb58:     public static final IVersionedSerializer<StreamRequest> serializer = new StreamRequestSerializer();
1:0160ad5: 
1:5151169:     public final String keyspace;
1:5151169:     public final Collection<Range<Token>> ranges;
1:5151169:     public final Collection<String> columnFamilies = new HashSet<>();
1:a7b7214:     public final long repairedAt;
1:a7b7214:     public StreamRequest(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, long repairedAt)
1:0160ad5:     {
1:5151169:         this.keyspace = keyspace;
1:8b9beaa:         this.ranges = ranges;
1:5151169:         this.columnFamilies.addAll(columnFamilies);
1:a7b7214:         this.repairedAt = repairedAt;
7:0160ad5:     }
1:5b9fc26: 
1:5151169:     public static class StreamRequestSerializer implements IVersionedSerializer<StreamRequest>
1:5b9fc26:     {
1:75508ec:         public void serialize(StreamRequest request, DataOutputPlus out, int version) throws IOException
1:84eeb28:         {
1:5151169:             out.writeUTF(request.keyspace);
1:a7b7214:             out.writeLong(request.repairedAt);
1:5151169:             out.writeInt(request.ranges.size());
1:5151169:             for (Range<Token> range : request.ranges)
1:0160ad5:             {
1:806facc:                 MessagingService.validatePartitioner(range);
1:806facc:                 Token.serializer.serialize(range.left, out, version);
1:806facc:                 Token.serializer.serialize(range.right, out, version);
1:5b9fc26:             }
1:5151169:             out.writeInt(request.columnFamilies.size());
1:5151169:             for (String cf : request.columnFamilies)
1:5151169:                 out.writeUTF(cf);
1:84eeb28:         }
1:84eeb28: 
1:03f72ac:         public StreamRequest deserialize(DataInputPlus in, int version) throws IOException
1:0160ad5:         {
1:5151169:             String keyspace = in.readUTF();
1:a7b7214:             long repairedAt = in.readLong();
1:5151169:             int rangeCount = in.readInt();
1:5151169:             List<Range<Token>> ranges = new ArrayList<>(rangeCount);
1:5151169:             for (int i = 0; i < rangeCount; i++)
1:0160ad5:             {
1:806facc:                 Token left = Token.serializer.deserialize(in, MessagingService.globalPartitioner(), version);
1:806facc:                 Token right = Token.serializer.deserialize(in, MessagingService.globalPartitioner(), version);
1:5151169:                 ranges.add(new Range<>(left, right));
1:0160ad5:             }
1:5151169:             int cfCount = in.readInt();
1:5151169:             List<String> columnFamilies = new ArrayList<>(cfCount);
1:5151169:             for (int i = 0; i < cfCount; i++)
1:5151169:                 columnFamilies.add(in.readUTF());
1:a7b7214:             return new StreamRequest(keyspace, ranges, columnFamilies, repairedAt);
1:0160ad5:         }
1:0160ad5: 
1:5151169:         public long serializedSize(StreamRequest request, int version)
1:5151169:         {
1:03f72ac:             int size = TypeSizes.sizeof(request.keyspace);
1:03f72ac:             size += TypeSizes.sizeof(request.repairedAt);
1:03f72ac:             size += TypeSizes.sizeof(request.ranges.size());
1:5151169:             for (Range<Token> range : request.ranges)
1:0160ad5:             {
1:806facc:                 size += Token.serializer.serializedSize(range.left, version);
1:806facc:                 size += Token.serializer.serializedSize(range.right, version);
1:5151169:             }
1:03f72ac:             size += TypeSizes.sizeof(request.columnFamilies.size());
1:5151169:             for (String cf : request.columnFamilies)
1:03f72ac:                 size += TypeSizes.sizeof(cf);
1:5b9fc26:             return size;
1:0160ad5:         }
1:0160ad5:     }
1:0160ad5: }
============================================================================
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public StreamRequest deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             int size = TypeSizes.sizeof(request.keyspace);
1:             size += TypeSizes.sizeof(request.repairedAt);
1:             size += TypeSizes.sizeof(request.ranges.size());
1:             size += TypeSizes.sizeof(request.columnFamilies.size());
1:                 size += TypeSizes.sizeof(cf);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:806facc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
1:                 MessagingService.validatePartitioner(range);
1:                 Token.serializer.serialize(range.left, out, version);
1:                 Token.serializer.serialize(range.right, out, version);
/////////////////////////////////////////////////////////////////////////
1:                 Token left = Token.serializer.deserialize(in, MessagingService.globalPartitioner(), version);
1:                 Token right = Token.serializer.deserialize(in, MessagingService.globalPartitioner(), version);
/////////////////////////////////////////////////////////////////////////
1:                 size += Token.serializer.serializedSize(range.left, version);
1:                 size += Token.serializer.serializedSize(range.right, version);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public void serialize(StreamRequest request, DataOutputPlus out, int version) throws IOException
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:a7b7214
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.ActiveRepairService;
/////////////////////////////////////////////////////////////////////////
1:     public final long repairedAt;
1:     public StreamRequest(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, long repairedAt)
1:         this.repairedAt = repairedAt;
/////////////////////////////////////////////////////////////////////////
1:             out.writeLong(request.repairedAt);
/////////////////////////////////////////////////////////////////////////
1:             long repairedAt = in.readLong();
/////////////////////////////////////////////////////////////////////////
1:             return new StreamRequest(keyspace, ranges, columnFamilies, repairedAt);
0:             size += TypeSizes.NATIVE.sizeof(request.repairedAt);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:5151169
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1:     public final String keyspace;
1:     public final Collection<Range<Token>> ranges;
1:     public final Collection<String> columnFamilies = new HashSet<>();
0:     public StreamRequest(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies)
1:         this.keyspace = keyspace;
1:         this.columnFamilies.addAll(columnFamilies);
1:     public static class StreamRequestSerializer implements IVersionedSerializer<StreamRequest>
0:         public void serialize(StreamRequest request, DataOutput out, int version) throws IOException
1:             out.writeUTF(request.keyspace);
1:             out.writeInt(request.ranges.size());
1:             for (Range<Token> range : request.ranges)
0:                 Token.serializer.serialize(range.left, out);
0:                 Token.serializer.serialize(range.right, out);
1:             out.writeInt(request.columnFamilies.size());
1:             for (String cf : request.columnFamilies)
1:                 out.writeUTF(cf);
1:             String keyspace = in.readUTF();
1:             int rangeCount = in.readInt();
1:             List<Range<Token>> ranges = new ArrayList<>(rangeCount);
1:             for (int i = 0; i < rangeCount; i++)
0:                 Token left = Token.serializer.deserialize(in);
0:                 Token right = Token.serializer.deserialize(in);
1:                 ranges.add(new Range<>(left, right));
1:             int cfCount = in.readInt();
1:             List<String> columnFamilies = new ArrayList<>(cfCount);
1:             for (int i = 0; i < cfCount; i++)
1:                 columnFamilies.add(in.readUTF());
0:             return new StreamRequest(keyspace, ranges, columnFamilies);
1:         public long serializedSize(StreamRequest request, int version)
0:             int size = TypeSizes.NATIVE.sizeof(request.keyspace);
0:             size += TypeSizes.NATIVE.sizeof(request.ranges.size());
1:             for (Range<Token> range : request.ranges)
1:             {
0:                 size += Token.serializer.serializedSize(range.left, TypeSizes.NATIVE);
0:                 size += Token.serializer.serializedSize(range.right, TypeSizes.NATIVE);
1:             }
0:             size += TypeSizes.NATIVE.sizeof(request.columnFamilies.size());
1:             for (String cf : request.columnFamilies)
0:                 size += TypeSizes.NATIVE.sizeof(cf);
commit:901a54a
/////////////////////////////////////////////////////////////////////////
0: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.UUIDSerializer;
/////////////////////////////////////////////////////////////////////////
0:     protected final UUID sessionId;
0:     // if these are specified, file should not be.
0:     StreamRequest(InetAddress target, Collection<Range<Token>> ranges, String table, Iterable<ColumnFamilyStore> columnFamilies, UUID sessionId, OperationType type)
/////////////////////////////////////////////////////////////////////////
0:     StreamRequest(InetAddress target, PendingFile file, UUID sessionId)
/////////////////////////////////////////////////////////////////////////
0:             for (Range<Token> range : ranges)
/////////////////////////////////////////////////////////////////////////
0:             UUIDSerializer.serializer.serialize(srm.sessionId, dos, MessagingService.current_version);
/////////////////////////////////////////////////////////////////////////
0:             UUID sessionId = UUIDSerializer.serializer.deserialize(dis, MessagingService.current_version);
/////////////////////////////////////////////////////////////////////////
0:                 for (int i = 0; i < size; ++i)
0:                 OperationType type = OperationType.valueOf(dis.readUTF());
commit:587cb58
/////////////////////////////////////////////////////////////////////////
1:     public static final IVersionedSerializer<StreamRequest> serializer = new StreamRequestSerializer();
/////////////////////////////////////////////////////////////////////////
0:                 PendingFile.serializer.serialize(srm.file, dos, version);
/////////////////////////////////////////////////////////////////////////
0:                     AbstractBounds.serializer.serialize(range, dos, version);
/////////////////////////////////////////////////////////////////////////
0:                 PendingFile file = PendingFile.serializer.deserialize(dis, version);
/////////////////////////////////////////////////////////////////////////
0:                     ranges.add((Range<Token>) AbstractBounds.serializer.deserialize(dis, version).toTokenBounds());
/////////////////////////////////////////////////////////////////////////
0:                 return size + PendingFile.serializer.serializedSize(sr.file, version);
0:                 size += AbstractBounds.serializer.serializedSize(range, version);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(StreamRequest srm, DataOutput out, int version) throws IOException
0:             UUIDSerializer.serializer.serialize(srm.sessionId, out, MessagingService.current_version);
0:             CompactEndpointSerializationHelper.serialize(srm.target, out);
0:                 out.writeBoolean(true);
0:                 PendingFile.serializer.serialize(srm.file, out, version);
0:                 out.writeBoolean(false);
0:                 out.writeUTF(srm.table);
0:                 out.writeInt(srm.ranges.size());
0:                     AbstractBounds.serializer.serialize(range, out, version);
0:                 out.writeUTF(srm.type.name());
0:                 out.writeInt(Iterables.size(srm.columnFamilies));
0:                     ColumnFamily.serializer.serializeCfId(cfs.metadata.cfId, out, version);
0:         public StreamRequest deserialize(DataInput in, int version) throws IOException
0:             UUID sessionId = UUIDSerializer.serializer.deserialize(in, MessagingService.current_version);
0:             InetAddress target = CompactEndpointSerializationHelper.deserialize(in);
0:             boolean singleFile = in.readBoolean();
0:                 PendingFile file = PendingFile.serializer.deserialize(in, version);
0:                 String table = in.readUTF();
0:                 int size = in.readInt();
0:                     ranges.add((Range<Token>) AbstractBounds.serializer.deserialize(in, version).toTokenBounds());
0:                 OperationType type = OperationType.valueOf(in.readUTF());
0:                 int cfsSize = in.readInt();
0:                     stores.add(Table.open(table).getColumnFamilyStore(ColumnFamily.serializer.deserializeCfId(in, version)));
commit:1693a9b
/////////////////////////////////////////////////////////////////////////
0:                 dos.writeUTF(srm.type.name());
0:                 dos.writeInt(Iterables.size(srm.columnFamilies));
0:                 for (ColumnFamilyStore cfs : srm.columnFamilies)
0:                     dos.writeInt(cfs.metadata.cfId);
/////////////////////////////////////////////////////////////////////////
0:                 type = OperationType.valueOf(dis.readUTF());
0:                 int cfsSize = dis.readInt();
0:                 for (int i = 0; i < cfsSize; ++i)
0:                     stores.add(Table.open(table).getColumnFamilyStore(dis.readInt()));
/////////////////////////////////////////////////////////////////////////
0:             size += TypeSizes.NATIVE.sizeof(sr.type.name());
0:             size += TypeSizes.NATIVE.sizeof(Iterables.size(sr.columnFamilies));
0:             for (ColumnFamilyStore cfs : sr.columnFamilies)
0:                 size += TypeSizes.NATIVE.sizeof(cfs.metadata.cfId);
commit:70554b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             size += TypeSizes.NATIVE.sizeof(sr.table);
0:                 size += TypeSizes.NATIVE.sizeof(sr.type.name());
commit:2ae5272
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
0:             long size = TypeSizes.NATIVE.sizeof(sr.sessionId);
0:             size += TypeSizes.NATIVE.sizeof(true);
0:             size += TypeSizes.NATIVE.sizeof(sr.ranges.size());
0:                 size += TypeSizes.NATIVE.sizeof(Iterables.size(sr.columnFamilies));
0:                     size += TypeSizes.NATIVE.sizeof(cfs.metadata.cfId);
commit:5b9fc26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DBTypeSizes;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public long serializedSize(StreamRequest sr, int version)
0:             long size = DBTypeSizes.NATIVE.sizeof(sr.sessionId);
0:             size += CompactEndpointSerializationHelper.serializedSize(sr.target);
0:             size += DBTypeSizes.NATIVE.sizeof(true);
0:             if (sr.file != null)
0:                 return size + PendingFile.serializer().serializedSize(sr.file, version);
1: 
0:             size += FBUtilities.serializedUTF8Size(sr.table);
0:             size += DBTypeSizes.NATIVE.sizeof(sr.ranges.size());
0:             for (Range<Token> range : sr.ranges)
0:                 size += AbstractBounds.serializer().serializedSize(range, version);
0:             if (version > MessagingService.VERSION_07)
0:                 size += FBUtilities.serializedUTF8Size(sr.type.name());
0:             if (version > MessagingService.VERSION_080)
1:             {
0:                 size += DBTypeSizes.NATIVE.sizeof(Iterables.size(sr.columnFamilies));
0:                 for (ColumnFamilyStore cfs : sr.columnFamilies)
0:                     size += DBTypeSizes.NATIVE.sizeof(cfs.metadata.cfId);
1:             }
1:             return size;
commit:9471e8d
/////////////////////////////////////////////////////////////////////////
1: public class StreamRequest
0:     private static final IVersionedSerializer<StreamRequest> serializer;
0:         serializer = new StreamRequestSerializer();
0:     public static IVersionedSerializer<StreamRequest> serializer()
/////////////////////////////////////////////////////////////////////////
0:     StreamRequest(InetAddress target, Collection<Range<Token>> ranges, String table, Iterable<ColumnFamilyStore> columnFamilies, long sessionId, OperationType type)
/////////////////////////////////////////////////////////////////////////
0:     StreamRequest(InetAddress target, PendingFile file, long sessionId)
/////////////////////////////////////////////////////////////////////////
0:     public MessageOut<StreamRequest> createMessage()
0:         return new MessageOut<StreamRequest>(MessagingService.Verb.STREAM_REQUEST, this, serializer);
/////////////////////////////////////////////////////////////////////////
0:     private static class StreamRequestSerializer implements IVersionedSerializer<StreamRequest>
0:         public void serialize(StreamRequest srm, DataOutput dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public StreamRequest deserialize(DataInput dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                 return new StreamRequest(target, file, sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 return new StreamRequest(target, ranges, table, stores, sessionId, type);
0:         public long serializedSize(StreamRequest streamRequestMessage, int version)
commit:a06be23
/////////////////////////////////////////////////////////////////////////
0: public class StreamRequestMessage // TODO rename to StreamRequest
/////////////////////////////////////////////////////////////////////////
0:     public static IVersionedSerializer<StreamRequestMessage> serializer()
commit:021ec71
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new MessageOut<StreamRequestMessage>(MessagingService.Verb.STREAM_REQUEST, this, serializer);
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.MessageOut;
/////////////////////////////////////////////////////////////////////////
0: class StreamRequestMessage // TODO rename to StreamRequest
/////////////////////////////////////////////////////////////////////////
0:     public MessageOut<StreamRequestMessage> createMessage()
0:         return new MessageOut<StreamRequestMessage>(StorageService.Verb.STREAM_REQUEST, this, serializer);
commit:38ee718
/////////////////////////////////////////////////////////////////////////
0:                 List<Range<Token>> ranges = (size == 0) ? null : new ArrayList<Range<Token>>(size);
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.IVersionedSerializer;
/////////////////////////////////////////////////////////////////////////
0:     private static IVersionedSerializer<StreamRequestMessage> serializer_;
0:     protected static IVersionedSerializer<StreamRequestMessage> serializer()
/////////////////////////////////////////////////////////////////////////
0:     private static class StreamRequestMessageSerializer implements IVersionedSerializer<StreamRequestMessage>
0:         public void serialize(StreamRequestMessage srm, DataOutput dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public StreamRequestMessage deserialize(DataInput dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
1: 
0:         public long serializedSize(StreamRequestMessage streamRequestMessage, int version)
1:         {
0:             throw new UnsupportedOperationException();
1:         }
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
commit:ef25537
/////////////////////////////////////////////////////////////////////////
commit:4023c3b
/////////////////////////////////////////////////////////////////////////
0:         return new Message(FBUtilities.getLocalAddress(), StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
commit:52b6edc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.Stage;
/////////////////////////////////////////////////////////////////////////
0:         return new Message(FBUtilities.getLocalAddress(), Stage.STREAM, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
commit:0160ad5
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.streaming;
1: /*
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  * 
1:  */
1: 
1: 
0: import java.io.*;
1: 
0: import org.apache.cassandra.concurrent.StageManager;
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
0: /**
0: * This class encapsulates the message that needs to be sent to nodes
0: * that handoff data. The message contains information about ranges
0: * that need to be transferred and the target node.
1: */
0: class StreamRequestMessage
1: {
0:    private static ICompactSerializer<StreamRequestMessage> serializer_;
0:    static
1:    {
0:        serializer_ = new StreamRequestMessageSerializer();
1:    }
1: 
0:    protected static ICompactSerializer<StreamRequestMessage> serializer()
1:    {
0:        return serializer_;
1:    }
1: 
0:    protected static Message makeStreamRequestMessage(StreamRequestMessage streamRequestMessage)
1:    {
0:        ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:        DataOutputStream dos = new DataOutputStream(bos);
0:        try
1:        {
0:            StreamRequestMessage.serializer().serialize(streamRequestMessage, dos);
1:        }
0:        catch (IOException e)
1:        {
0:            throw new IOError(e);
1:        }
0:        return new Message(FBUtilities.getLocalAddress(), StageManager.STREAM_STAGE, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
1:    }
1: 
0:    protected StreamRequestMetadata[] streamRequestMetadata_ = new StreamRequestMetadata[0];
1: 
0:    // TODO only actually ever need one BM, not an array
0:    StreamRequestMessage(StreamRequestMetadata... streamRequestMetadata)
1:    {
0:        assert streamRequestMetadata != null;
0:        streamRequestMetadata_ = streamRequestMetadata;
1:    }
1: 
0:     private static class StreamRequestMessageSerializer implements ICompactSerializer<StreamRequestMessage>
1:     {
0:         public void serialize(StreamRequestMessage streamRequestMessage, DataOutputStream dos) throws IOException
1:         {
0:             StreamRequestMetadata[] streamRequestMetadata = streamRequestMessage.streamRequestMetadata_;
0:             dos.writeInt(streamRequestMetadata.length);
0:             for (StreamRequestMetadata bsmd : streamRequestMetadata)
1:             {
0:                 StreamRequestMetadata.serializer().serialize(bsmd, dos);
1:             }
1:         }
1: 
0:         public StreamRequestMessage deserialize(DataInputStream dis) throws IOException
1:         {
0:             int size = dis.readInt();
0:             StreamRequestMetadata[] streamRequestMetadata = new StreamRequestMetadata[size];
0:             for (int i = 0; i < size; ++i)
1:             {
0:                 streamRequestMetadata[i] = StreamRequestMetadata.serializer().deserialize(dis);
1:             }
0:             return new StreamRequestMessage(streamRequestMetadata);
1:         }
1:     }
1: }
commit:cc9737a
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.streaming;
0: 
0: import java.io.*;
0: 
0: import org.apache.cassandra.concurrent.StageManager;
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.FBUtilities;
0: 
0: /**
0: * This class encapsulates the message that needs to be sent to nodes
0: * that handoff data. The message contains information about ranges
0: * that need to be transferred and the target node.
0: */
0: class StreamRequestMessage
0: {
0:    private static ICompactSerializer<StreamRequestMessage> serializer_;
0:    static
0:    {
0:        serializer_ = new StreamRequestMessageSerializer();
0:    }
0: 
0:    protected static ICompactSerializer<StreamRequestMessage> serializer()
0:    {
0:        return serializer_;
0:    }
0: 
0:    protected static Message makeStreamRequestMessage(StreamRequestMessage streamRequestMessage)
0:    {
0:        ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:        DataOutputStream dos = new DataOutputStream(bos);
0:        try
0:        {
0:            StreamRequestMessage.serializer().serialize(streamRequestMessage, dos);
0:        }
0:        catch (IOException e)
0:        {
0:            throw new IOError(e);
0:        }
0:        return new Message(FBUtilities.getLocalAddress(), StageManager.STREAM_STAGE, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
0:    }
0: 
0:    protected StreamRequestMetadata[] streamRequestMetadata_ = new StreamRequestMetadata[0];
0: 
0:    // TODO only actually ever need one BM, not an array
0:    StreamRequestMessage(StreamRequestMetadata... streamRequestMetadata)
0:    {
0:        assert streamRequestMetadata != null;
0:        streamRequestMetadata_ = streamRequestMetadata;
0:    }
0: 
0:     private static class StreamRequestMessageSerializer implements ICompactSerializer<StreamRequestMessage>
0:     {
0:         public void serialize(StreamRequestMessage streamRequestMessage, DataOutputStream dos) throws IOException
0:         {
0:             StreamRequestMetadata[] streamRequestMetadata = streamRequestMessage.streamRequestMetadata_;
0:             dos.writeInt(streamRequestMetadata.length);
0:             for (StreamRequestMetadata bsmd : streamRequestMetadata)
0:             {
0:                 StreamRequestMetadata.serializer().serialize(bsmd, dos);
0:             }
0:         }
0: 
0:         public StreamRequestMessage deserialize(DataInputStream dis) throws IOException
0:         {
0:             int size = dis.readInt();
0:             StreamRequestMetadata[] streamRequestMetadata = new StreamRequestMetadata[size];
0:             for (int i = 0; i < size; ++i)
0:             {
0:                 streamRequestMetadata[i] = StreamRequestMetadata.serializer().deserialize(dis);
0:             }
0:             return new StreamRequestMessage(streamRequestMetadata);
0:         }
0:     }
0: }
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:90170d1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.ColumnFamily;
/////////////////////////////////////////////////////////////////////////
0:                     ColumnFamily.serializer.serializeCfId(cfs.metadata.cfId, dos, version);
/////////////////////////////////////////////////////////////////////////
0:                     stores.add(Table.open(table).getColumnFamilyStore(ColumnFamily.serializer.deserializeCfId(dis, version)));
/////////////////////////////////////////////////////////////////////////
0:                 size += ColumnFamily.serializer.cfIdSerializedSize(cfs.metadata.cfId, TypeSizes.NATIVE, version);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:5f43a69
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0: *
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: *
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0:     private static final IVersionedSerializer<StreamRequestMessage> serializer;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0: package org.apache.cassandra.streaming;
commit:686139a
/////////////////////////////////////////////////////////////////////////
0:         FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
commit:910b663
/////////////////////////////////////////////////////////////////////////
0:     private static IVersionedSerializer<StreamRequestMessage> serializer;
0:         serializer = new StreamRequestMessageSerializer();
0:         return serializer;
commit:554223b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:     protected final Collection<Range<Token>> ranges;
0:     StreamRequestMessage(InetAddress target, Collection<Range<Token>> ranges, String table, Iterable<ColumnFamilyStore> columnFamilies, long sessionId, OperationType type)
/////////////////////////////////////////////////////////////////////////
0:             for ( Range<Token> range : ranges )
/////////////////////////////////////////////////////////////////////////
0:                 for (Range<Token> range : srm.ranges)
0:                     AbstractBounds.serializer().serialize(range, dos, version);
/////////////////////////////////////////////////////////////////////////
0:                 List<Range<Token>> ranges = (size == 0) ? null : new ArrayList<Range<Token>>();
0:                     ranges.add((Range<Token>) AbstractBounds.serializer().deserialize(dis, version).toTokenBounds());
author:Brandon Williams
-------------------------------------------------------------------------------
commit:01883da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.FastByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
0:     	FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:         return new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.STREAM_REQUEST, bos.toByteArray(), version);
author:Eric Evans
-------------------------------------------------------------------------------
commit:21afd78
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:feca0aa
/////////////////////////////////////////////////////////////////////////
0:     public Message getMessage(Integer version)
commit:75148e1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
0:                 if (version > MessagingService.VERSION_07)
0:                     dos.writeUTF(srm.type.name());
/////////////////////////////////////////////////////////////////////////
0:                 OperationType type = OperationType.RESTORE_REPLICA_COUNT;
0:                 if (version > MessagingService.VERSION_07)
0:                     type = OperationType.valueOf(dis.readUTF());
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
0:             StreamRequestMessage.serializer().serialize(this, dos, version);
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(StreamRequestMessage srm, DataOutputStream dos, int version) throws IOException
0:                 PendingFile.serializer().serialize(srm.file, dos, version);
/////////////////////////////////////////////////////////////////////////
0:         public StreamRequestMessage deserialize(DataInputStream dis, int version) throws IOException
0:                 PendingFile file = PendingFile.serializer().deserialize(dis, version);
commit:5d02c51
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.MessageProducer;
/////////////////////////////////////////////////////////////////////////
0: class StreamRequestMessage implements MessageProducer
/////////////////////////////////////////////////////////////////////////
0:     public Message getMessage(int version)
/////////////////////////////////////////////////////////////////////////
0:         return new Message(FBUtilities.getLocalAddress(), StorageService.Verb.STREAM_REQUEST, bos.toByteArray(), version);
commit:8b9beaa
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.List;
0: import org.apache.cassandra.dht.AbstractBounds;
1: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.net.CompactEndpointSerializationHelper;
/////////////////////////////////////////////////////////////////////////
0: * 
0: * If a file is specified, ranges and table will not. vice-versa should hold as well.
0:     private static ICompactSerializer<StreamRequestMessage> serializer_;
0:     static
0:     {
0:         serializer_ = new StreamRequestMessageSerializer();
0:     }
0:     protected static ICompactSerializer<StreamRequestMessage> serializer()
0:     {
0:         return serializer_;
0:     }
0:     protected final long sessionId;
0:     protected final InetAddress target;
0:     
0:     // if this is specified, ranges and table should not be.
0:     protected final PendingFile file;
0:     
0:     // if these are specified, file shoud not be.
0:     protected final Collection<Range> ranges;
0:     protected final String table;
0:     StreamRequestMessage(InetAddress target, Collection<Range> ranges, String table, long sessionId)
0:     {
0:         this.target = target;
1:         this.ranges = ranges;
0:         this.table = table;
0:         this.sessionId = sessionId;
0:         file = null;
0:     }
0:     StreamRequestMessage(InetAddress target, PendingFile file, long sessionId)
0:     {
0:         this.target = target;
0:         this.file = file;
0:         this.sessionId = sessionId;
0:         ranges = null;
0:         table = null;
0:     }
0:     
0:     Message makeMessage()
0:     {
0:         ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:         DataOutputStream dos = new DataOutputStream(bos);
0:         try
0:         {
0:             StreamRequestMessage.serializer().serialize(this, dos);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new IOError(e);
0:         }
0:         return new Message(FBUtilities.getLocalAddress(), StageManager.STREAM_STAGE, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
0:     }
0: 
0:     public String toString()
0:     {
0:         StringBuilder sb = new StringBuilder("");
0:         if (file == null)
0:         {
0:             sb.append(table);
0:             sb.append("@");
0:             sb.append(target);
0:             sb.append("------->");
0:             for ( Range range : ranges )
0:             {
0:                 sb.append(range);
0:                 sb.append(" ");
0:             }
0:         }
0:         else
0:         {
0:             sb.append(file.toString());
0:         }
0:         return sb.toString();
0:     }
0:         public void serialize(StreamRequestMessage srm, DataOutputStream dos) throws IOException
0:             dos.writeLong(srm.sessionId);
0:             CompactEndpointSerializationHelper.serialize(srm.target, dos);
0:             if (srm.file != null)
0:                 dos.writeBoolean(true);
0:                 PendingFile.serializer().serialize(srm.file, dos);
0:             }
0:             else
0:             {
0:                 dos.writeBoolean(false);
0:                 dos.writeUTF(srm.table);
0:                 dos.writeInt(srm.ranges.size());
0:                 for (Range range : srm.ranges)
0:                 {
0:                     AbstractBounds.serializer().serialize(range, dos);
0:                 }
0:             long sessionId = dis.readLong();
0:             InetAddress target = CompactEndpointSerializationHelper.deserialize(dis);
0:             boolean singleFile = dis.readBoolean();
0:             if (singleFile)
0:                 PendingFile file = PendingFile.serializer().deserialize(dis);
0:                 return new StreamRequestMessage(target, file, sessionId);
0:             else
0:             {
0:                 String table = dis.readUTF();
0:                 int size = dis.readInt();
0:                 List<Range> ranges = (size == 0) ? null : new ArrayList<Range>();
0:                 for( int i = 0; i < size; ++i )
0:                 {
0:                     ranges.add((Range) AbstractBounds.serializer().deserialize(dis));
0:                 }
0:                 return new StreamRequestMessage(target, ranges, table, sessionId);
0:             }
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:2c4ac98
/////////////////////////////////////////////////////////////////////////
0:     protected final OperationType type;
0:     StreamRequestMessage(InetAddress target, Collection<Range> ranges, String table, long sessionId, OperationType type)
0:         this.type = type;
/////////////////////////////////////////////////////////////////////////
0:         this.type = file.type;
/////////////////////////////////////////////////////////////////////////
0:             sb.append(type);
/////////////////////////////////////////////////////////////////////////
0:                 dos.writeUTF(srm.type.name());
/////////////////////////////////////////////////////////////////////////
0:                 OperationType type = OperationType.valueOf(dis.readUTF());
0:                 return new StreamRequestMessage(target, ranges, table, sessionId, type);
============================================================================