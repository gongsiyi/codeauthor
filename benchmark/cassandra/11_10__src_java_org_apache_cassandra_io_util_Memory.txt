1:07cf56f: /*
1:6fa1eaa:  * Licensed to the Apache Software Foundation (ASF) under one
1:6fa1eaa:  * or more contributor license agreements.  See the NOTICE file
1:6fa1eaa:  * distributed with this work for additional information
1:6fa1eaa:  * regarding copyright ownership.  The ASF licenses this file
1:6fa1eaa:  * to you under the Apache License, Version 2.0 (the
1:6fa1eaa:  * "License"); you may not use this file except in compliance
1:6fa1eaa:  * with the License.  You may obtain a copy of the License at
2:6fa1eaa:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6fa1eaa:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:6fa1eaa:  */
1:6fa1eaa: package org.apache.cassandra.io.util;
1:89fc576: 
1:0d2ec11: import java.lang.reflect.Field;
1:75508ec: import java.nio.ByteBuffer;
1:039e9b9: import java.nio.ByteOrder;
1:039e9b9: 
1:746c458: import net.nicoulaj.compilecommand.annotations.Inline;
1:73b5cab: 
1:73b5cab: import org.apache.cassandra.utils.Architecture;
1:e77ea12: import org.apache.cassandra.utils.FastByteOperations;
1:f3c0e11: import org.apache.cassandra.utils.concurrent.Ref;
1:1ac72f6: import org.apache.cassandra.utils.memory.MemoryUtil;
1:039e9b9: import sun.misc.Unsafe;
1:4e95953: import sun.nio.ch.DirectBuffer;
1:89fc576: 
1:af97b0f: /**
1:af97b0f:  * An off-heap region of memory that must be manually free'd when no longer needed.
1:af97b0f:  */
1:61384c5: public class Memory implements AutoCloseable
8:6fa1eaa: {
1:0d2ec11:     private static final Unsafe unsafe;
1:0d2ec11:     static
1:0d2ec11:     {
1:0d2ec11:         try
1:0d2ec11:         {
1:0d2ec11:             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
1:0d2ec11:             field.setAccessible(true);
1:0d2ec11:             unsafe = (sun.misc.Unsafe) field.get(null);
1:0d2ec11:         }
1:0d2ec11:         catch (Exception e)
1:0d2ec11:         {
1:0d2ec11:             throw new AssertionError(e);
1:0d2ec11:         }
1:0d2ec11:     }
1:5da4c4b: 
1:89fc576:     private static final long BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);
1:0d2ec11: 
1:039e9b9:     private static final boolean bigEndian = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
1:039e9b9: 
1:0d2ec11:     public static final ByteBuffer[] NO_BYTE_BUFFERS = new ByteBuffer[0];
1:0d2ec11: 
1:6fa1eaa:     protected long peer;
1:6fa1eaa:     // size of the memory region
1:746c458:     protected final long size;
8:6fa1eaa: 
1:6fa1eaa:     protected Memory(long bytes)
1:039e9b9:     {
1:5da4c4b:         if (bytes <= 0)
1:5da4c4b:             throw new AssertionError();
1:6fa1eaa:         size = bytes;
1:0d2ec11:         peer = MemoryUtil.allocate(size);
1:5da4c4b:         // we permit a 0 peer iff size is zero, since such an allocation makes no sense, and an allocator would be
1:5da4c4b:         // justified in returning a null pointer (and permitted to do so: http://www.cplusplus.com/reference/cstdlib/malloc)
1:5da4c4b:         if (peer == 0)
1:a72869c:             throw new OutOfMemoryError();
1:039e9b9:     }
1:6fa1eaa: 
1:746c458:     // create a memory object that references the exacy same memory location as the one provided.
1:746c458:     // this should ONLY be used by SafeMemory
1:746c458:     protected Memory(Memory copyOf)
1:746c458:     {
1:746c458:         size = copyOf.size;
1:746c458:         peer = copyOf.peer;
1:746c458:     }
1:746c458: 
1:6fa1eaa:     public static Memory allocate(long bytes)
1:6fa1eaa:     {
1:6fa1eaa:         if (bytes < 0)
1:6fa1eaa:             throw new IllegalArgumentException();
1:6fa1eaa: 
1:f3c0e11:         if (Ref.DEBUG_ENABLED)
1:f3c0e11:             return new SafeMemory(bytes);
1:f3c0e11: 
1:6fa1eaa:         return new Memory(bytes);
9:6fa1eaa:     }
1:6fa1eaa: 
1:6fa1eaa:     public void setByte(long offset, byte b)
1:6fa1eaa:     {
1:5da4c4b:         checkBounds(offset, offset + 1);
1:6fa1eaa:         unsafe.putByte(peer + offset, b);
1:6fa1eaa:     }
1:6fa1eaa: 
1:dc37dea:     public void setMemory(long offset, long bytes, byte b)
1:dc37dea:     {
1:5da4c4b:         checkBounds(offset, offset + bytes);
1:dc37dea:         // check if the last element will fit into the memory
1:dc37dea:         unsafe.setMemory(peer + offset, bytes, b);
1:dc37dea:     }
1:dc37dea: 
1:4549a98:     public void setLong(long offset, long l)
1:039e9b9:     {
1:5da4c4b:         checkBounds(offset, offset + 8);
1:73b5cab:         if (Architecture.IS_UNALIGNED)
1:4549a98:         {
1:039e9b9:             unsafe.putLong(peer + offset, l);
1:039e9b9:         }
1:039e9b9:         else
1:039e9b9:         {
1:039e9b9:             putLongByByte(peer + offset, l);
1:039e9b9:         }
1:039e9b9:     }
1:039e9b9: 
1:039e9b9:     private void putLongByByte(long address, long value)
1:039e9b9:     {
1:039e9b9:         if (bigEndian)
1:039e9b9:         {
1:039e9b9:             unsafe.putByte(address, (byte) (value >> 56));
1:039e9b9:             unsafe.putByte(address + 1, (byte) (value >> 48));
1:039e9b9:             unsafe.putByte(address + 2, (byte) (value >> 40));
1:039e9b9:             unsafe.putByte(address + 3, (byte) (value >> 32));
1:039e9b9:             unsafe.putByte(address + 4, (byte) (value >> 24));
1:039e9b9:             unsafe.putByte(address + 5, (byte) (value >> 16));
1:039e9b9:             unsafe.putByte(address + 6, (byte) (value >> 8));
1:039e9b9:             unsafe.putByte(address + 7, (byte) (value));
1:039e9b9:         }
1:039e9b9:         else
1:039e9b9:         {
1:039e9b9:             unsafe.putByte(address + 7, (byte) (value >> 56));
1:039e9b9:             unsafe.putByte(address + 6, (byte) (value >> 48));
1:039e9b9:             unsafe.putByte(address + 5, (byte) (value >> 40));
1:039e9b9:             unsafe.putByte(address + 4, (byte) (value >> 32));
1:039e9b9:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:039e9b9:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:039e9b9:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:039e9b9:             unsafe.putByte(address, (byte) (value));
1:039e9b9:         }
1:4549a98:     }
1:4549a98: 
1:c33ccd9:     public void setInt(long offset, int l)
1:039e9b9:     {
1:f3c0e11:         checkBounds(offset, offset + 4);
1:73b5cab:         if (Architecture.IS_UNALIGNED)
1:c33ccd9:         {
1:039e9b9:             unsafe.putInt(peer + offset, l);
1:039e9b9:         }
1:039e9b9:         else
1:039e9b9:         {
1:039e9b9:             putIntByByte(peer + offset, l);
1:039e9b9:         }
1:039e9b9:     }
1:039e9b9: 
1:039e9b9:     private void putIntByByte(long address, int value)
1:039e9b9:     {
1:039e9b9:         if (bigEndian)
1:039e9b9:         {
1:039e9b9:             unsafe.putByte(address, (byte) (value >> 24));
1:039e9b9:             unsafe.putByte(address + 1, (byte) (value >> 16));
1:039e9b9:             unsafe.putByte(address + 2, (byte) (value >> 8));
1:039e9b9:             unsafe.putByte(address + 3, (byte) (value));
1:039e9b9:         }
1:039e9b9:         else
1:039e9b9:         {
1:039e9b9:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:039e9b9:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:039e9b9:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:039e9b9:             unsafe.putByte(address, (byte) (value));
1:039e9b9:         }
1:c33ccd9:     }
1:c33ccd9: 
1:f3c0e11:     public void setShort(long offset, short l)
1:f3c0e11:     {
1:bf9c503:         checkBounds(offset, offset + 2);
1:73b5cab:         if (Architecture.IS_UNALIGNED)
1:f3c0e11:         {
1:f3c0e11:             unsafe.putShort(peer + offset, l);
1:f3c0e11:         }
1:f3c0e11:         else
1:f3c0e11:         {
1:f3c0e11:             putShortByByte(peer + offset, l);
1:f3c0e11:         }
1:f3c0e11:     }
1:f3c0e11: 
1:f3c0e11:     private void putShortByByte(long address, short value)
1:f3c0e11:     {
1:f3c0e11:         if (bigEndian)
1:f3c0e11:         {
1:f3c0e11:             unsafe.putByte(address, (byte) (value >> 8));
1:f3c0e11:             unsafe.putByte(address + 1, (byte) (value));
1:f3c0e11:         }
1:f3c0e11:         else
1:f3c0e11:         {
1:f3c0e11:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:f3c0e11:             unsafe.putByte(address, (byte) (value));
1:f3c0e11:         }
1:f3c0e11:     }
1:f3c0e11: 
1:4e95953:     public void setBytes(long memoryOffset, ByteBuffer buffer)
1:4e95953:     {
1:4e95953:         if (buffer == null)
1:4e95953:             throw new NullPointerException();
1:4e95953:         else if (buffer.remaining() == 0)
1:4e95953:             return;
1:5da4c4b: 
1:5da4c4b:         checkBounds(memoryOffset, memoryOffset + buffer.remaining());
1:4e95953:         if (buffer.hasArray())
1:4e95953:         {
1:4e95953:             setBytes(memoryOffset, buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
1:4e95953:         }
1:4e95953:         else if (buffer instanceof DirectBuffer)
1:4e95953:         {
1:4e95953:             unsafe.copyMemory(((DirectBuffer) buffer).address() + buffer.position(), peer + memoryOffset, buffer.remaining());
1:4e95953:         }
1:4e95953:         else
1:4e95953:             throw new IllegalStateException();
1:4e95953:     }
2:6fa1eaa:     /**
1:6fa1eaa:      * Transfers count bytes from buffer to Memory
1:6fa1eaa:      *
1:6fa1eaa:      * @param memoryOffset start offset in the memory
1:6fa1eaa:      * @param buffer the data buffer
1:6fa1eaa:      * @param bufferOffset start offset of the buffer
1:6fa1eaa:      * @param count number of bytes to transfer
1:6fa1eaa:      */
1:6fa1eaa:     public void setBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
1:6fa1eaa:     {
1:6fa1eaa:         if (buffer == null)
1:6fa1eaa:             throw new NullPointerException();
1:6fa1eaa:         else if (bufferOffset < 0
1:6fa1eaa:                  || count < 0
1:6fa1eaa:                  || bufferOffset + count > buffer.length)
1:6fa1eaa:             throw new IndexOutOfBoundsException();
1:6fa1eaa:         else if (count == 0)
1:6fa1eaa:             return;
1:6fa1eaa: 
1:bf9c503:         checkBounds(memoryOffset, memoryOffset + count);
1:65f189b:         unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, null, peer + memoryOffset, count);
1:6fa1eaa:     }
1:6fa1eaa: 
1:6fa1eaa:     public byte getByte(long offset)
1:6fa1eaa:     {
1:5da4c4b:         checkBounds(offset, offset + 1);
1:6fa1eaa:         return unsafe.getByte(peer + offset);
1:6fa1eaa:     }
1:6fa1eaa: 
1:4549a98:     public long getLong(long offset)
1:68d2526:     {
1:5da4c4b:         checkBounds(offset, offset + 8);
1:68d2526:         if (Architecture.IS_UNALIGNED)
1:4549a98:         {
1:039e9b9:             return unsafe.getLong(peer + offset);
4:039e9b9:         } else {
1:039e9b9:             return getLongByByte(peer + offset);
1:039e9b9:         }
1:039e9b9:     }
1:039e9b9: 
1:68d2526:     private long getLongByByte(long address)
1:68d2526:     {
1:68d2526:         if (bigEndian)
1:68d2526:         {
1:039e9b9:             return  (((long) unsafe.getByte(address    )       ) << 56) |
1:039e9b9:                     (((long) unsafe.getByte(address + 1) & 0xff) << 48) |
1:039e9b9:                     (((long) unsafe.getByte(address + 2) & 0xff) << 40) |
1:039e9b9:                     (((long) unsafe.getByte(address + 3) & 0xff) << 32) |
1:039e9b9:                     (((long) unsafe.getByte(address + 4) & 0xff) << 24) |
1:039e9b9:                     (((long) unsafe.getByte(address + 5) & 0xff) << 16) |
1:039e9b9:                     (((long) unsafe.getByte(address + 6) & 0xff) <<  8) |
1:039e9b9:                     (((long) unsafe.getByte(address + 7) & 0xff)      );
1:68d2526:         }
1:68d2526:         else
1:68d2526:         {
1:039e9b9:             return  (((long) unsafe.getByte(address + 7)       ) << 56) |
1:039e9b9:                     (((long) unsafe.getByte(address + 6) & 0xff) << 48) |
1:039e9b9:                     (((long) unsafe.getByte(address + 5) & 0xff) << 40) |
1:039e9b9:                     (((long) unsafe.getByte(address + 4) & 0xff) << 32) |
1:039e9b9:                     (((long) unsafe.getByte(address + 3) & 0xff) << 24) |
1:039e9b9:                     (((long) unsafe.getByte(address + 2) & 0xff) << 16) |
1:039e9b9:                     (((long) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:039e9b9:                     (((long) unsafe.getByte(address    ) & 0xff)      );
1:039e9b9:         }
1:4549a98:     }
1:4549a98: 
1:c33ccd9:     public int getInt(long offset)
1:68d2526:     {
1:5da4c4b:         checkBounds(offset, offset + 4);
1:68d2526:         if (Architecture.IS_UNALIGNED)
1:c33ccd9:         {
1:039e9b9:             return unsafe.getInt(peer + offset);
1:68d2526:         }
1:68d2526:         else
1:68d2526:         {
1:039e9b9:             return getIntByByte(peer + offset);
1:039e9b9:         }
1:039e9b9:     }
1:039e9b9: 
1:68d2526:     private int getIntByByte(long address)
1:68d2526:     {
1:68d2526:         if (bigEndian)
1:68d2526:         {
1:68d2526:             return  ((unsafe.getByte(address    )       ) << 24) |
1:68d2526:                     ((unsafe.getByte(address + 1) & 0xff) << 16) |
1:68d2526:                     ((unsafe.getByte(address + 2) & 0xff) << 8 ) |
1:68d2526:                     ((unsafe.getByte(address + 3) & 0xff)      );
1:68d2526:         }
1:68d2526:         else
1:68d2526:         {
1:68d2526:             return  ((unsafe.getByte(address + 3)       ) << 24) |
1:68d2526:                     ((unsafe.getByte(address + 2) & 0xff) << 16) |
1:68d2526:                     ((unsafe.getByte(address + 1) & 0xff) <<  8) |
1:68d2526:                     ((unsafe.getByte(address    ) & 0xff)      );
1:039e9b9:         }
1:c33ccd9:     }
1:c33ccd9: 
1:6fa1eaa:     /**
1:6fa1eaa:      * Transfers count bytes from Memory starting at memoryOffset to buffer starting at bufferOffset
1:6fa1eaa:      *
1:6fa1eaa:      * @param memoryOffset start offset in the memory
1:6fa1eaa:      * @param buffer the data buffer
1:6fa1eaa:      * @param bufferOffset start offset of the buffer
1:6fa1eaa:      * @param count number of bytes to transfer
1:6fa1eaa:      */
1:6fa1eaa:     public void getBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
1:6fa1eaa:     {
1:6fa1eaa:         if (buffer == null)
1:6fa1eaa:             throw new NullPointerException();
1:6fa1eaa:         else if (bufferOffset < 0 || count < 0 || count > buffer.length - bufferOffset)
1:6fa1eaa:             throw new IndexOutOfBoundsException();
1:6fa1eaa:         else if (count == 0)
1:6fa1eaa:             return;
1:6fa1eaa: 
1:5da4c4b:         checkBounds(memoryOffset, memoryOffset + count);
1:e77ea12:         FastByteOperations.UnsafeOperations.copy(null, peer + memoryOffset, buffer, bufferOffset, count);
1:6fa1eaa:     }
1:6fa1eaa: 
1:746c458:     @Inline
1:5da4c4b:     protected void checkBounds(long start, long end)
1:6fa1eaa:     {
1:98721bf:         assert peer != 0 : "Memory was freed";
1:5da4c4b:         assert start >= 0 && end <= size && start <= end : "Illegal bounds [" + start + ".." + end + "); size: " + size;
1:6fa1eaa:     }
1:6fa1eaa: 
1:4e95953:     public void put(long trgOffset, Memory memory, long srcOffset, long size)
1:4e95953:     {
1:bf9c503:         checkBounds(trgOffset, trgOffset + size);
1:bf9c503:         memory.checkBounds(srcOffset, srcOffset + size);
1:4e95953:         unsafe.copyMemory(memory.peer + srcOffset, peer + trgOffset, size);
1:4e95953:     }
1:4e95953: 
1:4e95953:     public Memory copy(long newSize)
1:4e95953:     {
1:4e95953:         Memory copy = Memory.allocate(newSize);
1:4e95953:         copy.put(0, this, 0, Math.min(size(), newSize));
1:4e95953:         return copy;
1:4e95953:     }
1:4e95953: 
1:6fa1eaa:     public void free()
1:6fa1eaa:     {
1:0d2ec11:         if (peer != 0) MemoryUtil.free(peer);
1:5da4c4b:         else assert size == 0;
1:6fa1eaa:         peer = 0;
1:6fa1eaa:     }
1:6fa1eaa: 
1:746c458:     public void close()
1:61384c5:     {
1:61384c5:         free();
1:61384c5:     }
1:61384c5: 
1:6fa1eaa:     public long size()
1:6fa1eaa:     {
1:0c65759:         assert peer != 0;
1:6fa1eaa:         return size;
1:6fa1eaa:     }
1:dc37dea: 
1:dc37dea:     @Override
1:dc37dea:     public boolean equals(Object o)
1:dc37dea:     {
1:dc37dea:         if (this == o)
1:dc37dea:             return true;
1:dc37dea:         if (!(o instanceof Memory))
1:dc37dea:             return false;
1:dc37dea:         Memory b = (Memory) o;
1:dc37dea:         if (peer == b.peer && size == b.size)
1:dc37dea:             return true;
1:dc37dea:         return false;
1:dc37dea:     }
1:6fa1eaa: 
1:f3c0e11:     public ByteBuffer[] asByteBuffers(long offset, long length)
1:75508ec:     {
1:16499ca:         checkBounds(offset, offset + length);
1:75508ec:         if (size() == 0)
1:0d2ec11:             return NO_BYTE_BUFFERS;
1:75508ec: 
1:f3c0e11:         ByteBuffer[] result = new ByteBuffer[(int) (length / Integer.MAX_VALUE) + 1];
1:75508ec:         int size = (int) (size() / result.length);
1:75508ec:         for (int i = 0 ; i < result.length - 1 ; i++)
1:75508ec:         {
1:1ac72f6:             result[i] = MemoryUtil.getByteBuffer(peer + offset, size);
1:75508ec:             offset += size;
1:f3c0e11:             length -= size;
1:75508ec:         }
1:f3c0e11:         result[result.length - 1] = MemoryUtil.getByteBuffer(peer + offset, (int) length);
1:75508ec:         return result;
1:75508ec:     }
1:746c458: 
1:bf9c503:     public ByteBuffer asByteBuffer(long offset, int length)
1:bf9c503:     {
1:bf9c503:         checkBounds(offset, offset + length);
1:bf9c503:         return MemoryUtil.getByteBuffer(peer + offset, length);
1:bf9c503:     }
1:bf9c503: 
1:bf9c503:     // MUST provide a buffer created via MemoryUtil.getHollowDirectByteBuffer()
1:bf9c503:     public void setByteBuffer(ByteBuffer buffer, long offset, int length)
1:bf9c503:     {
1:bf9c503:         checkBounds(offset, offset + length);
1:bf9c503:         MemoryUtil.setByteBuffer(buffer, peer + offset, length);
1:bf9c503:     }
1:bf9c503: 
1:746c458:     public String toString()
1:746c458:     {
1:746c458:         return toString(peer, size);
1:746c458:     }
1:746c458: 
1:746c458:     protected static String toString(long peer, long size)
1:746c458:     {
1:746c458:         return String.format("Memory@[%x..%x)", peer, peer + size);
1:746c458:     }
1:75508ec: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
1:         {
1:     private long getLongByByte(long address)
1:     {
1:         if (bigEndian)
1:         {
/////////////////////////////////////////////////////////////////////////
1:         }
1:         else
1:         {
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
1:         {
1:         }
1:         else
1:         {
1:     private int getIntByByte(long address)
1:     {
1:         if (bigEndian)
1:         {
1:             return  ((unsafe.getByte(address    )       ) << 24) |
1:                     ((unsafe.getByte(address + 1) & 0xff) << 16) |
1:                     ((unsafe.getByte(address + 2) & 0xff) << 8 ) |
1:                     ((unsafe.getByte(address + 3) & 0xff)      );
1:         }
1:         else
1:         {
1:             return  ((unsafe.getByte(address + 3)       ) << 24) |
1:                     ((unsafe.getByte(address + 2) & 0xff) << 16) |
1:                     ((unsafe.getByte(address + 1) & 0xff) <<  8) |
1:                     ((unsafe.getByte(address    ) & 0xff)      );
commit:73b5cab
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.utils.Architecture;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
/////////////////////////////////////////////////////////////////////////
0:         if (Architecture.IS_UNALIGNED) {
/////////////////////////////////////////////////////////////////////////
0:         if (Architecture.IS_UNALIGNED) {
commit:1def02f
/////////////////////////////////////////////////////////////////////////
author:Jason Brown
-------------------------------------------------------------------------------
commit:4ac4335
/////////////////////////////////////////////////////////////////////////
0:                     || arch.equals("amd64") || arch.equals("x86_64") || arch.equals("s390x");
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(offset, offset + length);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:bf9c503
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(offset, offset + 2);
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(memoryOffset, memoryOffset + count);
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(trgOffset, trgOffset + size);
1:         memory.checkBounds(srcOffset, srcOffset + size);
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer asByteBuffer(long offset, int length)
1:     {
1:         checkBounds(offset, offset + length);
1:         return MemoryUtil.getByteBuffer(peer + offset, length);
1:     }
1: 
1:     // MUST provide a buffer created via MemoryUtil.getHollowDirectByteBuffer()
1:     public void setByteBuffer(ByteBuffer buffer, long offset, int length)
1:     {
1:         checkBounds(offset, offset + length);
1:         MemoryUtil.setByteBuffer(buffer, peer + offset, length);
1:     }
1: 
commit:e473ce0
commit:f3c0e11
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.concurrent.Ref;
/////////////////////////////////////////////////////////////////////////
1:         if (Ref.DEBUG_ENABLED)
1:             return new SafeMemory(bytes);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setShort(long offset, short l)
1:     {
1:         checkBounds(offset, offset + 4);
0:         if (unaligned)
1:         {
1:             unsafe.putShort(peer + offset, l);
1:         }
1:         else
1:         {
1:             putShortByByte(peer + offset, l);
1:         }
1:     }
1: 
1:     private void putShortByByte(long address, short value)
1:     {
1:         if (bigEndian)
1:         {
1:             unsafe.putByte(address, (byte) (value >> 8));
1:             unsafe.putByte(address + 1, (byte) (value));
1:         }
1:         else
1:         {
1:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:             unsafe.putByte(address, (byte) (value));
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer[] asByteBuffers(long offset, long length)
1:         ByteBuffer[] result = new ByteBuffer[(int) (length / Integer.MAX_VALUE) + 1];
1:             length -= size;
1:         result[result.length - 1] = MemoryUtil.getByteBuffer(peer + offset, (int) length);
/////////////////////////////////////////////////////////////////////////
commit:65617aa
commit:5da4c4b
/////////////////////////////////////////////////////////////////////////
1:         if (bytes <= 0)
1:             throw new AssertionError();
1:         // we permit a 0 peer iff size is zero, since such an allocation makes no sense, and an allocator would be
1:         // justified in returning a null pointer (and permitted to do so: http://www.cplusplus.com/reference/cstdlib/malloc)
1:         if (peer == 0)
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(offset, offset + 1);
1:         checkBounds(offset, offset + bytes);
1:         checkBounds(offset, offset + 8);
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(offset, offset + 4);
/////////////////////////////////////////////////////////////////////////
1: 
1:         checkBounds(memoryOffset, memoryOffset + buffer.remaining());
/////////////////////////////////////////////////////////////////////////
0:         checkBounds(memoryOffset, end);
1:         checkBounds(offset, offset + 1);
1:         checkBounds(offset, offset + 8);
/////////////////////////////////////////////////////////////////////////
0:         checkBounds(offset, offset + 4);
/////////////////////////////////////////////////////////////////////////
1:         checkBounds(memoryOffset, memoryOffset + count);
1:     protected void checkBounds(long start, long end)
1:         assert start >= 0 && end <= size && start <= end : "Illegal bounds [" + start + ".." + end + "); size: " + size;
/////////////////////////////////////////////////////////////////////////
0:         if (peer != 0) allocator.free(peer);
1:         else assert size == 0;
/////////////////////////////////////////////////////////////////////////
1: 
commit:a4d0758
commit:746c458
/////////////////////////////////////////////////////////////////////////
1: import net.nicoulaj.compilecommand.annotations.Inline;
/////////////////////////////////////////////////////////////////////////
0:     static final IAllocator allocator = DatabaseDescriptor.getoffHeapMemoryAllocator();
/////////////////////////////////////////////////////////////////////////
1:     protected final long size;
/////////////////////////////////////////////////////////////////////////
1:     // create a memory object that references the exacy same memory location as the one provided.
1:     // this should ONLY be used by SafeMemory
1:     protected Memory(Memory copyOf)
1:     {
1:         size = copyOf.size;
1:         peer = copyOf.peer;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Inline
0:     protected void checkPosition(long offset)
/////////////////////////////////////////////////////////////////////////
1:     public void close()
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String toString()
1:     {
1:         return toString(peer, size);
1:     }
1: 
1:     protected static String toString(long peer, long size)
1:     {
1:         return String.format("Memory@[%x..%x)", peer, peer + size);
1:     }
commit:f41bac7
commit:bf43534
commit:a72869c
/////////////////////////////////////////////////////////////////////////
0:         if (size != 0 && peer == 0)
1:             throw new OutOfMemoryError();
commit:02c3489
commit:61384c5
/////////////////////////////////////////////////////////////////////////
0: import java.io.Closeable;
/////////////////////////////////////////////////////////////////////////
1: public class Memory implements AutoCloseable
/////////////////////////////////////////////////////////////////////////
0:     public void close() throws Exception
1:     {
1:         free();
1:     }
1: 
commit:51cdeed
commit:e77ea12
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FastByteOperations;
/////////////////////////////////////////////////////////////////////////
1:         FastByteOperations.UnsafeOperations.copy(null, peer + memoryOffset, buffer, bufferOffset, count);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0d2ec11
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
1:     private static final Unsafe unsafe;
1:     static
1:     {
1:         try
1:         {
1:             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
1:             field.setAccessible(true);
1:             unsafe = (sun.misc.Unsafe) field.get(null);
1:         }
1:         catch (Exception e)
1:         {
1:             throw new AssertionError(e);
1:         }
1:     }
1: 
1:     public static final ByteBuffer[] NO_BYTE_BUFFERS = new ByteBuffer[0];
1: 
/////////////////////////////////////////////////////////////////////////
1:         peer = MemoryUtil.allocate(size);
/////////////////////////////////////////////////////////////////////////
1:         if (peer != 0) MemoryUtil.free(peer);
/////////////////////////////////////////////////////////////////////////
1:             return NO_BYTE_BUFFERS;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:1ac72f6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.memory.MemoryUtil;
/////////////////////////////////////////////////////////////////////////
1:             result[i] = MemoryUtil.getByteBuffer(peer + offset, size);
0:         result[result.length - 1] = MemoryUtil.getByteBuffer(peer + offset, (int) (size() - offset));
commit:039e9b9
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteOrder;
1: import sun.misc.Unsafe;
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean bigEndian = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
0:     private static final boolean unaligned;
1: 
0:     static
1:     {
0:         String arch = System.getProperty("os.arch");
0:         unaligned = arch.equals("i386") || arch.equals("x86")
0:                     || arch.equals("amd64") || arch.equals("x86_64");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (unaligned)
1:         {
1:             unsafe.putLong(peer + offset, l);
1:         }
1:         else
1:         {
1:             putLongByByte(peer + offset, l);
1:         }
1:     }
1: 
1:     private void putLongByByte(long address, long value)
1:     {
1:         if (bigEndian)
1:         {
1:             unsafe.putByte(address, (byte) (value >> 56));
1:             unsafe.putByte(address + 1, (byte) (value >> 48));
1:             unsafe.putByte(address + 2, (byte) (value >> 40));
1:             unsafe.putByte(address + 3, (byte) (value >> 32));
1:             unsafe.putByte(address + 4, (byte) (value >> 24));
1:             unsafe.putByte(address + 5, (byte) (value >> 16));
1:             unsafe.putByte(address + 6, (byte) (value >> 8));
1:             unsafe.putByte(address + 7, (byte) (value));
1:         }
1:         else
1:         {
1:             unsafe.putByte(address + 7, (byte) (value >> 56));
1:             unsafe.putByte(address + 6, (byte) (value >> 48));
1:             unsafe.putByte(address + 5, (byte) (value >> 40));
1:             unsafe.putByte(address + 4, (byte) (value >> 32));
1:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:             unsafe.putByte(address, (byte) (value));
1:         }
0:         if (unaligned)
1:         {
1:             unsafe.putInt(peer + offset, l);
1:         }
1:         else
1:         {
1:             putIntByByte(peer + offset, l);
1:         }
1:     }
1: 
1:     private void putIntByByte(long address, int value)
1:     {
1:         if (bigEndian)
1:         {
1:             unsafe.putByte(address, (byte) (value >> 24));
1:             unsafe.putByte(address + 1, (byte) (value >> 16));
1:             unsafe.putByte(address + 2, (byte) (value >> 8));
1:             unsafe.putByte(address + 3, (byte) (value));
1:         }
1:         else
1:         {
1:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:             unsafe.putByte(address, (byte) (value));
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (unaligned) {
1:             return unsafe.getLong(peer + offset);
1:         } else {
1:             return getLongByByte(peer + offset);
1:         }
1:     }
1: 
0:     private long getLongByByte(long address) {
0:         if (bigEndian) {
1:             return  (((long) unsafe.getByte(address    )       ) << 56) |
1:                     (((long) unsafe.getByte(address + 1) & 0xff) << 48) |
1:                     (((long) unsafe.getByte(address + 2) & 0xff) << 40) |
1:                     (((long) unsafe.getByte(address + 3) & 0xff) << 32) |
1:                     (((long) unsafe.getByte(address + 4) & 0xff) << 24) |
1:                     (((long) unsafe.getByte(address + 5) & 0xff) << 16) |
1:                     (((long) unsafe.getByte(address + 6) & 0xff) <<  8) |
1:                     (((long) unsafe.getByte(address + 7) & 0xff)      );
1:         } else {
1:             return  (((long) unsafe.getByte(address + 7)       ) << 56) |
1:                     (((long) unsafe.getByte(address + 6) & 0xff) << 48) |
1:                     (((long) unsafe.getByte(address + 5) & 0xff) << 40) |
1:                     (((long) unsafe.getByte(address + 4) & 0xff) << 32) |
1:                     (((long) unsafe.getByte(address + 3) & 0xff) << 24) |
1:                     (((long) unsafe.getByte(address + 2) & 0xff) << 16) |
1:                     (((long) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:                     (((long) unsafe.getByte(address    ) & 0xff)      );
1:         }
0:         if (unaligned) {
1:             return unsafe.getInt(peer + offset);
1:         } else {
1:             return getIntByByte(peer + offset);
1:         }
1:     }
1: 
0:     private int getIntByByte(long address) {
0:         if (bigEndian) {
0:             return  (((int) unsafe.getByte(address    )       ) << 24) |
0:                     (((int) unsafe.getByte(address + 1) & 0xff) << 16) |
0:                     (((int) unsafe.getByte(address + 2) & 0xff) << 8 ) |
0:                     (((int) unsafe.getByte(address + 3) & 0xff)      );
1:         } else {
0:             return  (((int) unsafe.getByte(address + 3)       ) << 24) |
0:                     (((int) unsafe.getByte(address + 2) & 0xff) << 16) |
0:                     (((int) unsafe.getByte(address + 1) & 0xff) <<  8) |
0:                     (((int) unsafe.getByte(address    ) & 0xff)      );
1:         }
commit:0c65759
/////////////////////////////////////////////////////////////////////////
1:         assert peer != 0;
commit:4549a98
/////////////////////////////////////////////////////////////////////////
1:     public void setLong(long offset, long l)
1:     {
0:         checkPosition(offset);
0:         unsafe.putLong(peer + offset, l);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public long getLong(long offset)
1:     {
0:         checkPosition(offset);
0:         return unsafe.getLong(peer + offset);
1:     }
1: 
commit:dc37dea
/////////////////////////////////////////////////////////////////////////
1:     public void setMemory(long offset, long bytes, byte b)
1:     {
1:         // check if the last element will fit into the memory
0:         checkPosition(offset + bytes - 1);
1:         unsafe.setMemory(peer + offset, bytes, b);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public boolean equals(Object o)
1:     {
1:         if (this == o)
1:             return true;
1:         if (!(o instanceof Memory))
1:             return false;
1:         Memory b = (Memory) o;
1:         if (peer == b.peer && size == b.size)
1:             return true;
1:         return false;
1:     }
commit:af97b0f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * An off-heap region of memory that must be manually free'd when no longer needed.
1:  */
commit:98721bf
/////////////////////////////////////////////////////////////////////////
1:         assert peer != 0 : "Memory was freed";
0:         assert offset >= 0 && offset < size : "Illegal offset: " + offset + ", size: " + size;
commit:14912ba
commit:4e2e547
/////////////////////////////////////////////////////////////////////////
author:belliottsmith
-------------------------------------------------------------------------------
commit:4e95953
/////////////////////////////////////////////////////////////////////////
1: import sun.nio.ch.DirectBuffer;
/////////////////////////////////////////////////////////////////////////
1:     public void setBytes(long memoryOffset, ByteBuffer buffer)
1:     {
1:         if (buffer == null)
1:             throw new NullPointerException();
1:         else if (buffer.remaining() == 0)
1:             return;
0:         checkPosition(memoryOffset + buffer.remaining());
1:         if (buffer.hasArray())
1:         {
1:             setBytes(memoryOffset, buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
1:         }
1:         else if (buffer instanceof DirectBuffer)
1:         {
1:             unsafe.copyMemory(((DirectBuffer) buffer).address() + buffer.position(), peer + memoryOffset, buffer.remaining());
1:         }
1:         else
1:             throw new IllegalStateException();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void put(long trgOffset, Memory memory, long srcOffset, long size)
1:     {
1:         unsafe.copyMemory(memory.peer + srcOffset, peer + trgOffset, size);
1:     }
1: 
1:     public Memory copy(long newSize)
1:     {
1:         Memory copy = Memory.allocate(newSize);
1:         copy.put(0, this, 0, Math.min(size(), newSize));
1:         return copy;
1:     }
1: 
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
0: import com.sun.jna.Native;
0: import com.sun.jna.Pointer;
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer[] asByteBuffers()
1:     {
1:         if (size() == 0)
0:             return new ByteBuffer[0];
1: 
0:         ByteBuffer[] result = new ByteBuffer[(int) (size() / Integer.MAX_VALUE) + 1];
0:         long offset = 0;
1:         int size = (int) (size() / result.length);
1:         for (int i = 0 ; i < result.length - 1 ; i++)
1:         {
0:             result[i] = Native.getDirectByteBuffer(peer + offset, size);
1:             offset += size;
1:         }
0:         result[result.length - 1] = Native.getDirectByteBuffer(peer + offset, (int) (size() - offset));
1:         return result;
1:     }
1: }
author:Jake Luciani
-------------------------------------------------------------------------------
commit:65f189b
/////////////////////////////////////////////////////////////////////////
1:         unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, null, peer + memoryOffset, count);
/////////////////////////////////////////////////////////////////////////
0:         unsafe.copyMemory(null, peer + memoryOffset, buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, count);
commit:89fc576
/////////////////////////////////////////////////////////////////////////
1:     private static final long BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);
/////////////////////////////////////////////////////////////////////////
1: 
0:         unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET, null, peer + memoryOffset, count);
/////////////////////////////////////////////////////////////////////////
1: 
0:         unsafe.copyMemory(null, peer + memoryOffset, buffer, BYTE_ARRAY_BASE_OFFSET, count);
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:c33ccd9
/////////////////////////////////////////////////////////////////////////
1:     public void setInt(long offset, int l)
1:     {
0:         checkPosition(offset);
0:         unsafe.putInt(peer + offset, l);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getInt(long offset)
1:     {
0:         checkPosition(offset);
0:         return unsafe.getInt(peer + offset);
1:     }
1: 
commit:a8e8482
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
0:     private static final Unsafe unsafe = NativeAllocator.unsafe;
0:     private static final IAllocator allocator = DatabaseDescriptor.getoffHeapMemoryAllocator();
/////////////////////////////////////////////////////////////////////////
0:         peer = allocator.allocate(size);
/////////////////////////////////////////////////////////////////////////
0:         allocator.free(peer);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:6fa1eaa
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  *
1:  */
1: package org.apache.cassandra.io.util;
1: 
0: import sun.misc.Unsafe;
1: 
0: import java.lang.reflect.Field;
1: 
0: public class Memory
1: {
0:     private static final Unsafe unsafe;
1: 
0:     static
1:     {
0:         try
1:         {
0:             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
0:             field.setAccessible(true);
0:             unsafe = (sun.misc.Unsafe) field.get(null);
1:         }
0:         catch (Exception e)
1:         {
0:             throw new AssertionError(e);
1:         }
1:     }
1: 
1:     protected long peer;
1:     // size of the memory region
0:     private final long size;
1: 
1:     protected Memory(long bytes)
1:     {
1:         size = bytes;
0:         peer = unsafe.allocateMemory(size);
1:     }
1: 
1:     public static Memory allocate(long bytes)
1:     {
1:         if (bytes < 0)
1:             throw new IllegalArgumentException();
1: 
1:         return new Memory(bytes);
1:     }
1: 
1:     public void setByte(long offset, byte b)
1:     {
0:         checkPosition(offset);
1:         unsafe.putByte(peer + offset, b);
1:     }
1: 
1:     /**
1:      * Transfers count bytes from buffer to Memory
1:      *
1:      * @param memoryOffset start offset in the memory
1:      * @param buffer the data buffer
1:      * @param bufferOffset start offset of the buffer
1:      * @param count number of bytes to transfer
1:      */
1:     public void setBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
1:     {
1:         if (buffer == null)
1:             throw new NullPointerException();
1:         else if (bufferOffset < 0
1:                  || count < 0
1:                  || bufferOffset + count > buffer.length)
1:             throw new IndexOutOfBoundsException();
1:         else if (count == 0)
1:             return;
1: 
0:         checkPosition(memoryOffset);
0:         long end = memoryOffset + count;
0:         checkPosition(end - 1);
0:         while (memoryOffset < end)
0:             unsafe.putByte(peer + memoryOffset++, buffer[bufferOffset++]);
1:     }
1: 
1:     public byte getByte(long offset)
1:     {
0:         checkPosition(offset);
1:         return unsafe.getByte(peer + offset);
1:     }
1: 
1:     /**
1:      * Transfers count bytes from Memory starting at memoryOffset to buffer starting at bufferOffset
1:      *
1:      * @param memoryOffset start offset in the memory
1:      * @param buffer the data buffer
1:      * @param bufferOffset start offset of the buffer
1:      * @param count number of bytes to transfer
1:      */
1:     public void getBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
1:     {
1:         if (buffer == null)
1:             throw new NullPointerException();
1:         else if (bufferOffset < 0 || count < 0 || count > buffer.length - bufferOffset)
1:             throw new IndexOutOfBoundsException();
1:         else if (count == 0)
1:             return;
1: 
0:         checkPosition(memoryOffset);
0:         long end = memoryOffset + count;
0:         checkPosition(end - 1);
0:         while (memoryOffset < end)
0:             buffer[bufferOffset++] = unsafe.getByte(peer + memoryOffset++);
1:     }
1: 
0:     private void checkPosition(long offset)
1:     {
0:         if (peer == 0)
0:             throw new IllegalStateException("Memory was freed");
1: 
0:         if (offset < 0 || offset >= size)
0:             throw new IndexOutOfBoundsException("Illegal offset: " + offset + ", size: " + size);
1:     }
1: 
1:     public void free()
1:     {
0:         assert peer != 0;
0:         unsafe.freeMemory(peer);
1:         peer = 0;
1:     }
1: 
0:     @Override
0:     protected void finalize() throws Throwable
1:     {
0:         try
1:         {
0:             if (peer != 0)
0:                 free();
1:         }
0:         finally
1:         {
0:             super.finalize();
1:         }
1:     }
1: 
1:     public long size()
1:     {
1:         return size;
1:     }
1: }
1: 
============================================================================