1:1e978df: /*
1:1e978df:  * Licensed to the Apache Software Foundation (ASF) under one
1:1e978df:  * or more contributor license agreements.  See the NOTICE file
1:1e978df:  * distributed with this work for additional information
1:1e978df:  * regarding copyright ownership.  The ASF licenses this file
1:1e978df:  * to you under the Apache License, Version 2.0 (the
1:1e978df:  * "License"); you may not use this file except in compliance
1:1e978df:  * with the License.  You may obtain a copy of the License at
1:1e978df:  *
1:1e978df:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1e978df:  *
1:1e978df:  * Unless required by applicable law or agreed to in writing, software
1:1e978df:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1e978df:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1e978df:  * See the License for the specific language governing permissions and
1:1e978df:  * limitations under the License.
1:1e978df:  */
1:1e978df: package org.apache.cassandra.db.partition;
1:1e978df: 
1:1e978df: import static org.junit.Assert.*;
1:1e978df: 
1:1e978df: import java.util.*;
1:1e978df: import java.util.function.Function;
1:1e978df: import java.util.function.Predicate;
1:1e978df: import java.util.function.Supplier;
1:1e978df: import java.util.stream.Collectors;
1:1e978df: import java.util.stream.Stream;
1:1e978df: import java.util.stream.StreamSupport;
1:1e978df: 
1:1e978df: import com.google.common.collect.Iterables;
1:1e978df: import com.google.common.collect.Iterators;
1:1e978df: 
1:1e978df: import org.junit.BeforeClass;
1:1e978df: import org.junit.Test;
1:1e978df: 
1:1e978df: import org.apache.cassandra.SchemaLoader;
1:1e978df: import org.apache.cassandra.Util;
1:1e978df: import org.apache.cassandra.config.CFMetaData;
1:1e978df: import org.apache.cassandra.config.ColumnDefinition;
1:1e978df: import org.apache.cassandra.cql3.ColumnIdentifier;
1:1e978df: import org.apache.cassandra.db.*;
1:1e978df: import org.apache.cassandra.db.filter.ColumnFilter;
1:1e978df: import org.apache.cassandra.db.marshal.AsciiType;
1:1e978df: import org.apache.cassandra.db.partitions.AbstractBTreePartition;
1:1e978df: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1:1e978df: import org.apache.cassandra.db.partitions.Partition;
1:1e978df: import org.apache.cassandra.db.rows.*;
1:1e978df: import org.apache.cassandra.db.rows.Row.Deletion;
1:1e978df: import org.apache.cassandra.exceptions.ConfigurationException;
1:1e978df: import org.apache.cassandra.schema.KeyspaceParams;
1:1e978df: import org.apache.cassandra.utils.ByteBufferUtil;
1:1e978df: import org.apache.cassandra.utils.SearchIterator;
1:1e978df: 
1:1e978df: public class PartitionImplementationTest
1:1e978df: {
1:1e978df:     private static final String KEYSPACE = "PartitionImplementationTest";
1:1e978df:     private static final String CF = "Standard";
1:1e978df: 
1:1e978df:     private static final int ENTRIES = 250;
1:1e978df:     private static final int TESTS = 1000;
1:1e978df:     private static final int KEY_RANGE = ENTRIES * 5;
1:1e978df: 
1:1e978df:     private static final int TIMESTAMP = KEY_RANGE + 1;
1:1e978df: 
1:1e978df:     private static CFMetaData cfm;
1:1e978df:     private Random rand = new Random(2);
1:1e978df: 
1:1e978df:     @BeforeClass
1:1e978df:     public static void defineSchema() throws ConfigurationException
1:1e978df:     {
1:1e978df:         SchemaLoader.prepareServer();
1:1e978df: 
1:1e978df:         cfm = CFMetaData.Builder.create(KEYSPACE, CF)
1:1e978df:                                         .addPartitionKey("pk", AsciiType.instance)
1:1e978df:                                         .addClusteringColumn("ck", AsciiType.instance)
1:1e978df:                                         .addRegularColumn("col", AsciiType.instance)
1:1e978df:                                         .addStaticColumn("static_col", AsciiType.instance)
1:1e978df:                                         .build();
1:1e978df:         SchemaLoader.createKeyspace(KEYSPACE,
1:1e978df:                                     KeyspaceParams.simple(1),
1:1e978df:                                     cfm);
1:1e978df:     }
1:1e978df: 
1:1e978df:     private List<Row> generateRows()
1:1e978df:     {
1:1e978df:         List<Row> content = new ArrayList<>();
1:1e978df:         Set<Integer> keysUsed = new HashSet<>();
1:1e978df:         for (int i = 0; i < ENTRIES; ++i)
1:1e978df:         {
1:1e978df:             int rk;
1:1e978df:             do
1:1e978df:             {
1:1e978df:                 rk = rand.nextInt(KEY_RANGE);
1:1e978df:             }
1:1e978df:             while (!keysUsed.add(rk));
1:1e978df:             content.add(makeRow(clustering(rk), "Col" + rk));
1:1e978df:         }
1:1e978df:         return content; // not sorted
1:1e978df:     }
1:1e978df: 
1:1e978df:     Row makeRow(Clustering clustering, String colValue)
1:1e978df:     {
1:1e978df:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("col", true));
1:1e978df:         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
1:1e978df:         row.newRow(clustering);
1:e017f94:         row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes(colValue)));
1:1e978df:         return row.build();
1:1e978df:     }
1:1e978df: 
1:1e978df:     Row makeStaticRow()
1:1e978df:     {
1:1e978df:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("static_col", true));
1:1e978df:         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
1:1e978df:         row.newRow(Clustering.STATIC_CLUSTERING);
1:e017f94:         row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes("static value")));
1:1e978df:         return row.build();
1:1e978df:     }
1:1e978df: 
1:1e978df:     private List<Unfiltered> generateMarkersOnly()
1:1e978df:     {
1:1e978df:         return addMarkers(new ArrayList<>());
1:1e978df:     }
1:1e978df: 
1:1e978df:     private List<Unfiltered> generateUnfiltereds()
1:1e978df:     {
1:1e978df:         List<Unfiltered> content = new ArrayList<>(generateRows());
1:1e978df:         return addMarkers(content);
1:1e978df:     }
1:1e978df: 
1:1e978df:     List<Unfiltered> addMarkers(List<Unfiltered> content)
1:1e978df:     {
1:1e978df:         List<RangeTombstoneMarker> markers = new ArrayList<>();
1:1e978df:         Set<Integer> delTimes = new HashSet<>();
1:1e978df:         for (int i = 0; i < ENTRIES / 10; ++i)
1:1e978df:         {
1:1e978df:             int delTime;
1:1e978df:             do
1:1e978df:             {
1:1e978df:                 delTime = rand.nextInt(KEY_RANGE);
1:1e978df:             }
1:1e978df:             while (!delTimes.add(delTime));
1:1e978df: 
1:1e978df:             int start = rand.nextInt(KEY_RANGE);
1:1e978df:             DeletionTime dt = new DeletionTime(delTime, delTime);
1:1e978df:             RangeTombstoneMarker open = RangeTombstoneBoundMarker.inclusiveOpen(false, clustering(start).getRawValues(), dt);
1:1e978df:             int end = start + rand.nextInt((KEY_RANGE - start) / 4 + 1);
1:1e978df:             RangeTombstoneMarker close = RangeTombstoneBoundMarker.inclusiveClose(false, clustering(end).getRawValues(), dt);
1:1e978df:             markers.add(open);
1:1e978df:             markers.add(close);
1:1e978df:         }
1:1e978df:         markers.sort(cfm.comparator);
1:1e978df: 
1:1e978df:         RangeTombstoneMarker toAdd = null;
1:1e978df:         Set<DeletionTime> open = new HashSet<>();
1:1e978df:         DeletionTime current = DeletionTime.LIVE;
1:1e978df:         for (RangeTombstoneMarker marker : markers)
1:1e978df:         {
1:1e978df:             if (marker.isOpen(false))
1:1e978df:             {
1:1e978df:                 DeletionTime delTime = marker.openDeletionTime(false);
1:1e978df:                 open.add(delTime);
1:1e978df:                 if (delTime.supersedes(current))
1:1e978df:                 {
1:1e978df:                     if (toAdd != null)
1:1e978df:                     {
1:1e978df:                         if (cfm.comparator.compare(toAdd, marker) != 0)
1:1e978df:                             content.add(toAdd);
1:1e978df:                         else
1:1e978df:                         {
1:1e978df:                             // gotta join
1:1e978df:                             current = toAdd.isClose(false) ? toAdd.closeDeletionTime(false) : DeletionTime.LIVE;
1:1e978df:                         }
1:1e978df:                     }
1:1e978df:                     if (current != DeletionTime.LIVE)
1:1e978df:                         marker = RangeTombstoneBoundaryMarker.makeBoundary(false, marker.openBound(false).invert(), marker.openBound(false), current, delTime);
1:1e978df:                     toAdd = marker;
1:1e978df:                     current = delTime;
1:1e978df:                 }
1:1e978df:             }
1:1e978df:             else
1:1e978df:             {
1:1e978df:                 assert marker.isClose(false);
1:1e978df:                 DeletionTime delTime = marker.closeDeletionTime(false);
1:1e978df:                 boolean removed = open.remove(delTime);
1:1e978df:                 assert removed;
1:1e978df:                 if (current.equals(delTime))
1:1e978df:                 {
1:1e978df:                     if (toAdd != null)
1:1e978df:                     {
1:1e978df:                         if (cfm.comparator.compare(toAdd, marker) != 0)
1:1e978df:                             content.add(toAdd);
1:1e978df:                         else
1:1e978df:                         {
1:1e978df:                             // gotta join
1:1e978df:                             current = toAdd.closeDeletionTime(false);
1:1e978df:                             marker = new RangeTombstoneBoundMarker(marker.closeBound(false), current);
1:1e978df:                         }
1:1e978df:                     }
1:1e978df:                     DeletionTime best = open.stream().max(DeletionTime::compareTo).orElse(DeletionTime.LIVE);
1:1e978df:                     if (best != DeletionTime.LIVE)
1:1e978df:                         marker = RangeTombstoneBoundaryMarker.makeBoundary(false, marker.closeBound(false), marker.closeBound(false).invert(), current, best);
1:1e978df:                     toAdd = marker;
1:1e978df:                     current = best;
1:1e978df:                 }
1:1e978df:             }
1:1e978df:         }
1:1e978df:         content.add(toAdd);
1:1e978df:         assert current == DeletionTime.LIVE;
1:1e978df:         assert open.isEmpty();
1:1e978df:         return content;
1:1e978df:     }
1:1e978df: 
1:1e978df:     private Clustering clustering(int i)
1:1e978df:     {
1:1e978df:         return cfm.comparator.make(String.format("Row%06d", i));
1:1e978df:     }
1:1e978df: 
1:1e978df:     private void test(Supplier<Collection<? extends Unfiltered>> content, Row staticRow)
1:1e978df:     {
1:1e978df:         for (int i = 0; i<TESTS; ++i)
1:1e978df:         {
1:1e978df:             try
1:1e978df:             {
1:1e978df:                 rand = new Random(i);
1:1e978df:                 testIter(content, staticRow);
1:1e978df:             }
1:1e978df:             catch (Throwable t)
1:1e978df:             {
1:1e978df:                 throw new AssertionError("Test failed with seed " + i, t);
1:1e978df:             }
1:1e978df:         }
1:1e978df:     }
1:1e978df: 
1:1e978df:     private void testIter(Supplier<Collection<? extends Unfiltered>> contentSupplier, Row staticRow)
1:1e978df:     {
1:1e978df:         NavigableSet<Clusterable> sortedContent = new TreeSet<Clusterable>(cfm.comparator);
1:1e978df:         sortedContent.addAll(contentSupplier.get());
1:1e978df:         AbstractBTreePartition partition;
1:1e978df:         try (UnfilteredRowIterator iter = new Util.UnfilteredSource(cfm, Util.dk("pk"), staticRow, sortedContent.stream().map(x -> (Unfiltered) x).iterator()))
1:1e978df:         {
1:1e978df:             partition = ImmutableBTreePartition.create(iter);
1:1e978df:         }
1:1e978df: 
1:1e978df:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("col", true));
1:1e978df:         ColumnFilter cf = ColumnFilter.selectionBuilder().add(defCol).build();
1:1e978df:         Function<? super Clusterable, ? extends Clusterable> colFilter = x -> x instanceof Row ? ((Row) x).filter(cf, cfm) : x;
1:1e978df:         Slices slices = Slices.with(cfm.comparator, Slice.make(clustering(KEY_RANGE / 4), clustering(KEY_RANGE * 3 / 4)));
1:1e978df:         Slices multiSlices = makeSlices();
1:1e978df: 
1:1e978df:         // lastRow
1:1e978df:         assertRowsEqual((Row) get(sortedContent.descendingSet(), x -> x instanceof Row),
1:1e978df:                         partition.lastRow());
1:1e978df:         // get(static)
1:1e978df:         assertRowsEqual(staticRow,
1:1e978df:                         partition.getRow(Clustering.STATIC_CLUSTERING));
1:1e978df: 
1:1e978df:         // get
1:1e978df:         for (int i=0; i < KEY_RANGE; ++i)
1:1e978df:         {
1:1e978df:             Clustering cl = clustering(i);
1:1e978df:             assertRowsEqual(getRow(sortedContent, cl),
1:1e978df:                             partition.getRow(cl));
1:1e978df:         }
1:1e978df:         // isEmpty
1:1e978df:         assertEquals(sortedContent.isEmpty() && staticRow == null,
1:1e978df:                      partition.isEmpty());
1:1e978df:         // hasRows
1:1e978df:         assertEquals(sortedContent.stream().anyMatch(x -> x instanceof Row),
1:1e978df:                      partition.hasRows());
1:1e978df: 
1:1e978df:         // iterator
1:1e978df:         assertIteratorsEqual(sortedContent.stream().filter(x -> x instanceof Row).iterator(),
1:1e978df:                              partition.iterator());
1:1e978df: 
1:1e978df:         // unfiltered iterator
1:1e978df:         assertIteratorsEqual(sortedContent.iterator(),
1:1e978df:                              partition.unfilteredIterator());
1:1e978df: 
1:1e978df:         // unfiltered iterator
1:1e978df:         assertIteratorsEqual(sortedContent.iterator(),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), Slices.ALL, false));
1:1e978df:         // column-filtered
1:1e978df:         assertIteratorsEqual(sortedContent.stream().map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, Slices.ALL, false));
1:1e978df:         // sliced
1:1e978df:         assertIteratorsEqual(slice(sortedContent, slices.get(0)),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), slices, false));
1:1e978df:         assertIteratorsEqual(streamOf(slice(sortedContent, slices.get(0))).map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, slices, false));
1:1e978df:         // randomly multi-sliced
1:1e978df:         assertIteratorsEqual(slice(sortedContent, multiSlices),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), multiSlices, false));
1:1e978df:         assertIteratorsEqual(streamOf(slice(sortedContent, multiSlices)).map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, multiSlices, false));
1:1e978df:         // reversed
1:1e978df:         assertIteratorsEqual(sortedContent.descendingIterator(),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), Slices.ALL, true));
1:1e978df:         assertIteratorsEqual(sortedContent.descendingSet().stream().map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, Slices.ALL, true));
1:1e978df:         assertIteratorsEqual(invert(slice(sortedContent, slices.get(0))),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), slices, true));
1:1e978df:         assertIteratorsEqual(streamOf(invert(slice(sortedContent, slices.get(0)))).map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, slices, true));
1:1e978df:         assertIteratorsEqual(invert(slice(sortedContent, multiSlices)),
1:1e978df:                              partition.unfilteredIterator(ColumnFilter.all(cfm), multiSlices, true));
1:1e978df:         assertIteratorsEqual(streamOf(invert(slice(sortedContent, multiSlices))).map(colFilter).iterator(),
1:1e978df:                              partition.unfilteredIterator(cf, multiSlices, true));
1:1e978df: 
1:1e978df:         // search iterator
1:1e978df:         testSearchIterator(sortedContent, partition, ColumnFilter.all(cfm), false);
1:1e978df:         testSearchIterator(sortedContent, partition, cf, false);
1:1e978df:         testSearchIterator(sortedContent, partition, ColumnFilter.all(cfm), true);
1:1e978df:         testSearchIterator(sortedContent, partition, cf, true);
1:1e978df: 
1:1e978df:         // sliceable iter
1:4fb559b:         testSlicingOfIterators(sortedContent, partition, ColumnFilter.all(cfm), false);
1:4fb559b:         testSlicingOfIterators(sortedContent, partition, cf, false);
1:4fb559b:         testSlicingOfIterators(sortedContent, partition, ColumnFilter.all(cfm), true);
1:4fb559b:         testSlicingOfIterators(sortedContent, partition, cf, true);
1:1e978df:     }
1:1e978df: 
1:1e978df:     void testSearchIterator(NavigableSet<Clusterable> sortedContent, Partition partition, ColumnFilter cf, boolean reversed)
1:1e978df:     {
1:1e978df:         SearchIterator<Clustering, Row> searchIter = partition.searchIterator(cf, reversed);
1:1e978df:         int pos = reversed ? KEY_RANGE : 0;
1:1e978df:         int mul = reversed ? -1 : 1;
1:1e978df:         boolean started = false;
1:1e978df:         while (searchIter.hasNext())
1:1e978df:         {
1:1e978df:             int skip = rand.nextInt(KEY_RANGE / 10);
1:1e978df:             pos += skip * mul;
1:1e978df:             Clustering cl = clustering(pos);
1:1e978df:             Row row = searchIter.next(cl);  // returns row with deletion, incl. empty row with deletion
1:1e978df:             if (row == null && skip == 0 && started)    // allowed to return null if already reported row
1:1e978df:                 continue;
1:1e978df:             started = true;
1:1e978df:             Row expected = getRow(sortedContent, cl);
1:1e978df:             assertEquals(expected == null, row == null);
1:1e978df:             if (row == null)
1:1e978df:                 continue;
1:1e978df:             assertRowsEqual(expected.filter(cf, cfm), row);
1:1e978df:         }
1:1e978df:     }
1:1e978df: 
1:1e978df:     Slices makeSlices()
1:1e978df:     {
1:1e978df:         int pos = 0;
1:1e978df:         Slices.Builder builder = new Slices.Builder(cfm.comparator);
1:1e978df:         while (pos <= KEY_RANGE)
1:1e978df:         {
1:1e978df:             int skip = rand.nextInt(KEY_RANGE / 10) * (rand.nextInt(3) + 2 / 3); // increased chance of getting 0
1:1e978df:             pos += skip;
1:1e978df:             int sz = rand.nextInt(KEY_RANGE / 10) + (skip == 0 ? 1 : 0);    // if start is exclusive need at least sz 1
1:1e978df:             Clustering start = clustering(pos);
1:1e978df:             pos += sz;
1:1e978df:             Clustering end = clustering(pos);
1:2cc26eb:             Slice slice = Slice.make(skip == 0 ? ClusteringBound.exclusiveStartOf(start) : ClusteringBound.inclusiveStartOf(start), ClusteringBound.inclusiveEndOf(end));
1:1e978df:             builder.add(slice);
1:1e978df:         }
1:1e978df:         return builder.build();
1:1e978df:     }
1:1e978df: 
1:4fb559b:     void testSlicingOfIterators(NavigableSet<Clusterable> sortedContent, AbstractBTreePartition partition, ColumnFilter cf, boolean reversed)
1:1e978df:     {
1:1e978df:         Function<? super Clusterable, ? extends Clusterable> colFilter = x -> x instanceof Row ? ((Row) x).filter(cf, cfm) : x;
1:1e978df:         Slices slices = makeSlices();
1:4fb559b: 
1:4fb559b:         // fetch each slice in turn
1:1e978df:         for (Slice slice : (Iterable<Slice>) () -> directed(slices, reversed))
1:1e978df:         {
1:4fb559b:             try (UnfilteredRowIterator slicedIter = partition.unfilteredIterator(cf, Slices.with(cfm.comparator, slice), reversed))
1:4fb559b:             {
1:1e978df:                 assertIteratorsEqual(streamOf(directed(slice(sortedContent, slice), reversed)).map(colFilter).iterator(),
1:4fb559b:                                      slicedIter);
1:1e978df:             }
1:1e978df:         }
1:1e978df: 
1:4fb559b:         // Fetch all slices at once
1:4fb559b:         try (UnfilteredRowIterator slicedIter = partition.unfilteredIterator(cf, slices, reversed))
1:1e978df:         {
1:4fb559b:             List<Iterator<? extends Clusterable>> slicelist = new ArrayList<>();
1:4fb559b:             slices.forEach(slice -> slicelist.add(directed(slice(sortedContent, slice), reversed)));
1:4fb559b:             if (reversed)
1:4fb559b:                 Collections.reverse(slicelist);
1:1e978df: 
1:4fb559b:             assertIteratorsEqual(Iterators.concat(slicelist.toArray(new Iterator[0])), slicedIter);
1:1e978df:         }
1:4fb559b:     }
1:4fb559b: 
1:1e978df:     private<T> Iterator<T> invert(Iterator<T> slice)
1:1e978df:     {
1:1e978df:         Deque<T> dest = new LinkedList<>();
1:1e978df:         Iterators.addAll(dest, slice);
1:1e978df:         return dest.descendingIterator();
1:1e978df:     }
1:1e978df: 
1:1e978df:     private Iterator<Clusterable> slice(NavigableSet<Clusterable> sortedContent, Slices slices)
1:1e978df:     {
1:1e978df:         return Iterators.concat(streamOf(slices).map(slice -> slice(sortedContent, slice)).iterator());
1:1e978df:     }
1:1e978df: 
1:1e978df:     private Iterator<Clusterable> slice(NavigableSet<Clusterable> sortedContent, Slice slice)
1:1e978df:     {
1:1e978df:         // Slice bounds are inclusive bounds, equal only to markers. Matched markers should be returned as one-sided boundaries.
1:1e978df:         RangeTombstoneMarker prev = (RangeTombstoneMarker) sortedContent.headSet(slice.start(), true).descendingSet().stream().filter(x -> x instanceof RangeTombstoneMarker).findFirst().orElse(null);
1:1e978df:         RangeTombstoneMarker next = (RangeTombstoneMarker) sortedContent.tailSet(slice.end(), true).stream().filter(x -> x instanceof RangeTombstoneMarker).findFirst().orElse(null);
1:1e978df:         Iterator<Clusterable> result = sortedContent.subSet(slice.start(), false, slice.end(), false).iterator();
1:1e978df:         if (prev != null && prev.isOpen(false))
1:1e978df:             result = Iterators.concat(Iterators.singletonIterator(new RangeTombstoneBoundMarker(slice.start(), prev.openDeletionTime(false))), result);
1:1e978df:         if (next != null && next.isClose(false))
1:1e978df:             result = Iterators.concat(result, Iterators.singletonIterator(new RangeTombstoneBoundMarker(slice.end(), next.closeDeletionTime(false))));
1:1e978df:         return result;
1:1e978df:     }
1:1e978df: 
1:1e978df:     private Iterator<Slice> directed(Slices slices, boolean reversed)
1:1e978df:     {
1:1e978df:         return directed(slices.iterator(), reversed);
1:1e978df:     }
1:1e978df: 
1:1e978df:     private <T> Iterator<T> directed(Iterator<T> iter, boolean reversed)
1:1e978df:     {
1:1e978df:         if (!reversed)
1:1e978df:             return iter;
1:1e978df:         return invert(iter);
1:1e978df:     }
1:1e978df: 
1:1e978df:     private <T> Stream<T> streamOf(Iterator<T> iterator)
1:1e978df:     {
1:1e978df:         Iterable<T> iterable = () -> iterator;
1:1e978df:         return streamOf(iterable);
1:1e978df:     }
1:1e978df: 
1:1e978df:     <T> Stream<T> streamOf(Iterable<T> iterable)
1:1e978df:     {
1:1e978df:         return StreamSupport.stream(iterable.spliterator(), false);
1:1e978df:     }
1:1e978df: 
1:1e978df:     private void assertIteratorsEqual(Iterator<? extends Clusterable> it1, Iterator<? extends Clusterable> it2)
1:1e978df:     {
1:1e978df:         Clusterable[] a1 = (Clusterable[]) Iterators.toArray(it1, Clusterable.class);
1:1e978df:         Clusterable[] a2 = (Clusterable[]) Iterators.toArray(it2, Clusterable.class);
1:1e978df:         if (Arrays.equals(a1, a2))
1:1e978df:             return;
1:1e978df:         String a1s = Stream.of(a1).map(x -> "\n" + (x instanceof Unfiltered ? ((Unfiltered) x).toString(cfm) : x.toString())).collect(Collectors.toList()).toString();
1:1e978df:         String a2s = Stream.of(a2).map(x -> "\n" + (x instanceof Unfiltered ? ((Unfiltered) x).toString(cfm) : x.toString())).collect(Collectors.toList()).toString();
1:1e978df:         assertArrayEquals("Arrays differ. Expected " + a1s + " was " + a2s, a1, a2);
1:1e978df:     }
1:1e978df: 
1:1e978df:     private Row getRow(NavigableSet<Clusterable> sortedContent, Clustering cl)
1:1e978df:     {
1:1e978df:         NavigableSet<Clusterable> nexts = sortedContent.tailSet(cl, true);
1:1e978df:         if (nexts.isEmpty())
1:1e978df:             return null;
1:1e978df:         Row row = nexts.first() instanceof Row && cfm.comparator.compare(cl, nexts.first()) == 0 ? (Row) nexts.first() : null;
1:1e978df:         for (Clusterable next : nexts)
1:1e978df:             if (next instanceof RangeTombstoneMarker)
1:1e978df:             {
1:1e978df:                 RangeTombstoneMarker rt = (RangeTombstoneMarker) next;
1:1e978df:                 if (!rt.isClose(false))
1:1e978df:                     return row;
1:1e978df:                 DeletionTime delTime = rt.closeDeletionTime(false);
1:1e978df:                 return row == null ? BTreeRow.emptyDeletedRow(cl, Deletion.regular(delTime)) : row.filter(ColumnFilter.all(cfm), delTime, true, cfm);
1:1e978df:             }
1:1e978df:         return row;
1:1e978df:     }
1:1e978df: 
1:1e978df:     private void assertRowsEqual(Row expected, Row actual)
1:1e978df:     {
1:1e978df:         try
1:1e978df:         {
1:1e978df:             assertEquals(expected == null, actual == null);
1:1e978df:             if (expected == null)
1:1e978df:                 return;
1:1e978df:             assertEquals(expected.clustering(), actual.clustering());
1:1e978df:             assertEquals(expected.deletion(), actual.deletion());
1:1e978df:             assertArrayEquals(Iterables.toArray(expected.cells(), Cell.class), Iterables.toArray(expected.cells(), Cell.class));
1:1e978df:         } catch (Throwable t)
1:1e978df:         {
1:1e978df:             throw new AssertionError(String.format("Row comparison failed, expected %s got %s", expected, actual), t);
1:1e978df:         }
1:1e978df:     }
1:1e978df: 
1:1e978df:     private static<T> T get(NavigableSet<T> sortedContent, Predicate<T> test)
1:1e978df:     {
1:1e978df:         return sortedContent.stream().filter(test).findFirst().orElse(null);
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testEmpty()
1:1e978df:     {
1:1e978df:         test(() -> Collections.<Row>emptyList(), null);
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testStaticOnly()
1:1e978df:     {
1:1e978df:         test(() -> Collections.<Row>emptyList(), makeStaticRow());
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testRows()
1:1e978df:     {
1:1e978df:         test(this::generateRows, null);
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testRowsWithStatic()
1:1e978df:     {
1:1e978df:         test(this::generateRows, makeStaticRow());
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testMarkersOnly()
1:1e978df:     {
1:1e978df:         test(this::generateMarkersOnly, null);
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testMarkersWithStatic()
1:1e978df:     {
1:1e978df:         test(this::generateMarkersOnly, makeStaticRow());
1:1e978df:     }
1:1e978df: 
1:1e978df:     @Test
1:1e978df:     public void testUnfiltereds()
1:1e978df:     {
1:1e978df:         test(this::generateUnfiltereds, makeStaticRow());
1:1e978df:     }
1:1e978df: 
1:1e978df: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Slice slice = Slice.make(skip == 0 ? ClusteringBound.exclusiveStartOf(start) : ClusteringBound.inclusiveStartOf(start), ClusteringBound.inclusiveEndOf(end));
commit:1e978df
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.partition;
1: 
1: import static org.junit.Assert.*;
1: 
1: import java.util.*;
1: import java.util.function.Function;
1: import java.util.function.Predicate;
1: import java.util.function.Supplier;
1: import java.util.stream.Collectors;
1: import java.util.stream.Stream;
1: import java.util.stream.StreamSupport;
1: 
1: import com.google.common.collect.Iterables;
1: import com.google.common.collect.Iterators;
1: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.Slice.Bound;
1: import org.apache.cassandra.db.filter.ColumnFilter;
1: import org.apache.cassandra.db.marshal.AsciiType;
1: import org.apache.cassandra.db.partitions.AbstractBTreePartition;
1: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1: import org.apache.cassandra.db.partitions.Partition;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.db.rows.Row.Deletion;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.schema.KeyspaceParams;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.SearchIterator;
1: 
1: public class PartitionImplementationTest
1: {
1:     private static final String KEYSPACE = "PartitionImplementationTest";
1:     private static final String CF = "Standard";
1: 
1:     private static final int ENTRIES = 250;
1:     private static final int TESTS = 1000;
1:     private static final int KEY_RANGE = ENTRIES * 5;
1: 
1:     private static final int TIMESTAMP = KEY_RANGE + 1;
1: 
1:     private static CFMetaData cfm;
1:     private Random rand = new Random(2);
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1: 
1:         cfm = CFMetaData.Builder.create(KEYSPACE, CF)
1:                                         .addPartitionKey("pk", AsciiType.instance)
1:                                         .addClusteringColumn("ck", AsciiType.instance)
1:                                         .addRegularColumn("col", AsciiType.instance)
1:                                         .addStaticColumn("static_col", AsciiType.instance)
1:                                         .build();
1:         SchemaLoader.createKeyspace(KEYSPACE,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1:     }
1: 
1:     private List<Row> generateRows()
1:     {
1:         List<Row> content = new ArrayList<>();
1:         Set<Integer> keysUsed = new HashSet<>();
1:         for (int i = 0; i < ENTRIES; ++i)
1:         {
1:             int rk;
1:             do
1:             {
1:                 rk = rand.nextInt(KEY_RANGE);
1:             }
1:             while (!keysUsed.add(rk));
1:             content.add(makeRow(clustering(rk), "Col" + rk));
1:         }
1:         return content; // not sorted
1:     }
1: 
1:     Row makeRow(Clustering clustering, String colValue)
1:     {
1:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("col", true));
1:         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
1:         row.newRow(clustering);
0:         row.addCell(BufferCell.live(cfm, defCol, TIMESTAMP, ByteBufferUtil.bytes(colValue)));
1:         return row.build();
1:     }
1: 
1:     Row makeStaticRow()
1:     {
1:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("static_col", true));
1:         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
1:         row.newRow(Clustering.STATIC_CLUSTERING);
0:         row.addCell(BufferCell.live(cfm, defCol, TIMESTAMP, ByteBufferUtil.bytes("static value")));
1:         return row.build();
1:     }
1: 
1:     private List<Unfiltered> generateMarkersOnly()
1:     {
1:         return addMarkers(new ArrayList<>());
1:     }
1: 
1:     private List<Unfiltered> generateUnfiltereds()
1:     {
1:         List<Unfiltered> content = new ArrayList<>(generateRows());
1:         return addMarkers(content);
1:     }
1: 
1:     List<Unfiltered> addMarkers(List<Unfiltered> content)
1:     {
1:         List<RangeTombstoneMarker> markers = new ArrayList<>();
1:         Set<Integer> delTimes = new HashSet<>();
1:         for (int i = 0; i < ENTRIES / 10; ++i)
1:         {
1:             int delTime;
1:             do
1:             {
1:                 delTime = rand.nextInt(KEY_RANGE);
1:             }
1:             while (!delTimes.add(delTime));
1: 
1:             int start = rand.nextInt(KEY_RANGE);
1:             DeletionTime dt = new DeletionTime(delTime, delTime);
1:             RangeTombstoneMarker open = RangeTombstoneBoundMarker.inclusiveOpen(false, clustering(start).getRawValues(), dt);
1:             int end = start + rand.nextInt((KEY_RANGE - start) / 4 + 1);
1:             RangeTombstoneMarker close = RangeTombstoneBoundMarker.inclusiveClose(false, clustering(end).getRawValues(), dt);
1:             markers.add(open);
1:             markers.add(close);
1:         }
1:         markers.sort(cfm.comparator);
1: 
1:         RangeTombstoneMarker toAdd = null;
1:         Set<DeletionTime> open = new HashSet<>();
1:         DeletionTime current = DeletionTime.LIVE;
1:         for (RangeTombstoneMarker marker : markers)
1:         {
1:             if (marker.isOpen(false))
1:             {
1:                 DeletionTime delTime = marker.openDeletionTime(false);
1:                 open.add(delTime);
1:                 if (delTime.supersedes(current))
1:                 {
1:                     if (toAdd != null)
1:                     {
1:                         if (cfm.comparator.compare(toAdd, marker) != 0)
1:                             content.add(toAdd);
1:                         else
1:                         {
1:                             // gotta join
1:                             current = toAdd.isClose(false) ? toAdd.closeDeletionTime(false) : DeletionTime.LIVE;
1:                         }
1:                     }
1:                     if (current != DeletionTime.LIVE)
1:                         marker = RangeTombstoneBoundaryMarker.makeBoundary(false, marker.openBound(false).invert(), marker.openBound(false), current, delTime);
1:                     toAdd = marker;
1:                     current = delTime;
1:                 }
1:             }
1:             else
1:             {
1:                 assert marker.isClose(false);
1:                 DeletionTime delTime = marker.closeDeletionTime(false);
1:                 boolean removed = open.remove(delTime);
1:                 assert removed;
1:                 if (current.equals(delTime))
1:                 {
1:                     if (toAdd != null)
1:                     {
1:                         if (cfm.comparator.compare(toAdd, marker) != 0)
1:                             content.add(toAdd);
1:                         else
1:                         {
1:                             // gotta join
1:                             current = toAdd.closeDeletionTime(false);
1:                             marker = new RangeTombstoneBoundMarker(marker.closeBound(false), current);
1:                         }
1:                     }
1:                     DeletionTime best = open.stream().max(DeletionTime::compareTo).orElse(DeletionTime.LIVE);
1:                     if (best != DeletionTime.LIVE)
1:                         marker = RangeTombstoneBoundaryMarker.makeBoundary(false, marker.closeBound(false), marker.closeBound(false).invert(), current, best);
1:                     toAdd = marker;
1:                     current = best;
1:                 }
1:             }
1:         }
1:         content.add(toAdd);
1:         assert current == DeletionTime.LIVE;
1:         assert open.isEmpty();
1:         return content;
1:     }
1: 
1:     private Clustering clustering(int i)
1:     {
1:         return cfm.comparator.make(String.format("Row%06d", i));
1:     }
1: 
1:     private void test(Supplier<Collection<? extends Unfiltered>> content, Row staticRow)
1:     {
1:         for (int i = 0; i<TESTS; ++i)
1:         {
1:             try
1:             {
1:                 rand = new Random(i);
1:                 testIter(content, staticRow);
1:             }
1:             catch (Throwable t)
1:             {
1:                 throw new AssertionError("Test failed with seed " + i, t);
1:             }
1:         }
1:     }
1: 
1:     private void testIter(Supplier<Collection<? extends Unfiltered>> contentSupplier, Row staticRow)
1:     {
1:         NavigableSet<Clusterable> sortedContent = new TreeSet<Clusterable>(cfm.comparator);
1:         sortedContent.addAll(contentSupplier.get());
1:         AbstractBTreePartition partition;
1:         try (UnfilteredRowIterator iter = new Util.UnfilteredSource(cfm, Util.dk("pk"), staticRow, sortedContent.stream().map(x -> (Unfiltered) x).iterator()))
1:         {
1:             partition = ImmutableBTreePartition.create(iter);
1:         }
1: 
1:         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("col", true));
1:         ColumnFilter cf = ColumnFilter.selectionBuilder().add(defCol).build();
1:         Function<? super Clusterable, ? extends Clusterable> colFilter = x -> x instanceof Row ? ((Row) x).filter(cf, cfm) : x;
1:         Slices slices = Slices.with(cfm.comparator, Slice.make(clustering(KEY_RANGE / 4), clustering(KEY_RANGE * 3 / 4)));
1:         Slices multiSlices = makeSlices();
1: 
1:         // lastRow
1:         assertRowsEqual((Row) get(sortedContent.descendingSet(), x -> x instanceof Row),
1:                         partition.lastRow());
1:         // get(static)
1:         assertRowsEqual(staticRow,
1:                         partition.getRow(Clustering.STATIC_CLUSTERING));
1: 
1:         // get
1:         for (int i=0; i < KEY_RANGE; ++i)
1:         {
1:             Clustering cl = clustering(i);
1:             assertRowsEqual(getRow(sortedContent, cl),
1:                             partition.getRow(cl));
1:         }
1:         // isEmpty
1:         assertEquals(sortedContent.isEmpty() && staticRow == null,
1:                      partition.isEmpty());
1:         // hasRows
1:         assertEquals(sortedContent.stream().anyMatch(x -> x instanceof Row),
1:                      partition.hasRows());
1: 
1:         // iterator
1:         assertIteratorsEqual(sortedContent.stream().filter(x -> x instanceof Row).iterator(),
1:                              partition.iterator());
1: 
1:         // unfiltered iterator
1:         assertIteratorsEqual(sortedContent.iterator(),
1:                              partition.unfilteredIterator());
1: 
1:         // unfiltered iterator
1:         assertIteratorsEqual(sortedContent.iterator(),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), Slices.ALL, false));
1:         // column-filtered
1:         assertIteratorsEqual(sortedContent.stream().map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, Slices.ALL, false));
1:         // sliced
1:         assertIteratorsEqual(slice(sortedContent, slices.get(0)),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), slices, false));
1:         assertIteratorsEqual(streamOf(slice(sortedContent, slices.get(0))).map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, slices, false));
1:         // randomly multi-sliced
1:         assertIteratorsEqual(slice(sortedContent, multiSlices),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), multiSlices, false));
1:         assertIteratorsEqual(streamOf(slice(sortedContent, multiSlices)).map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, multiSlices, false));
1:         // reversed
1:         assertIteratorsEqual(sortedContent.descendingIterator(),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), Slices.ALL, true));
1:         assertIteratorsEqual(sortedContent.descendingSet().stream().map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, Slices.ALL, true));
1:         assertIteratorsEqual(invert(slice(sortedContent, slices.get(0))),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), slices, true));
1:         assertIteratorsEqual(streamOf(invert(slice(sortedContent, slices.get(0)))).map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, slices, true));
1:         assertIteratorsEqual(invert(slice(sortedContent, multiSlices)),
1:                              partition.unfilteredIterator(ColumnFilter.all(cfm), multiSlices, true));
1:         assertIteratorsEqual(streamOf(invert(slice(sortedContent, multiSlices))).map(colFilter).iterator(),
1:                              partition.unfilteredIterator(cf, multiSlices, true));
1: 
1:         // search iterator
1:         testSearchIterator(sortedContent, partition, ColumnFilter.all(cfm), false);
1:         testSearchIterator(sortedContent, partition, cf, false);
1:         testSearchIterator(sortedContent, partition, ColumnFilter.all(cfm), true);
1:         testSearchIterator(sortedContent, partition, cf, true);
1: 
1:         // sliceable iter
0:         testSliceableIterator(sortedContent, partition, ColumnFilter.all(cfm), false);
0:         testSliceableIterator(sortedContent, partition, cf, false);
0:         testSliceableIterator(sortedContent, partition, ColumnFilter.all(cfm), true);
0:         testSliceableIterator(sortedContent, partition, cf, true);
1:     }
1: 
1:     void testSearchIterator(NavigableSet<Clusterable> sortedContent, Partition partition, ColumnFilter cf, boolean reversed)
1:     {
1:         SearchIterator<Clustering, Row> searchIter = partition.searchIterator(cf, reversed);
1:         int pos = reversed ? KEY_RANGE : 0;
1:         int mul = reversed ? -1 : 1;
1:         boolean started = false;
1:         while (searchIter.hasNext())
1:         {
1:             int skip = rand.nextInt(KEY_RANGE / 10);
1:             pos += skip * mul;
1:             Clustering cl = clustering(pos);
1:             Row row = searchIter.next(cl);  // returns row with deletion, incl. empty row with deletion
1:             if (row == null && skip == 0 && started)    // allowed to return null if already reported row
1:                 continue;
1:             started = true;
1:             Row expected = getRow(sortedContent, cl);
1:             assertEquals(expected == null, row == null);
1:             if (row == null)
1:                 continue;
1:             assertRowsEqual(expected.filter(cf, cfm), row);
1:         }
1:     }
1: 
1:     Slices makeSlices()
1:     {
1:         int pos = 0;
1:         Slices.Builder builder = new Slices.Builder(cfm.comparator);
1:         while (pos <= KEY_RANGE)
1:         {
1:             int skip = rand.nextInt(KEY_RANGE / 10) * (rand.nextInt(3) + 2 / 3); // increased chance of getting 0
1:             pos += skip;
1:             int sz = rand.nextInt(KEY_RANGE / 10) + (skip == 0 ? 1 : 0);    // if start is exclusive need at least sz 1
1:             Clustering start = clustering(pos);
1:             pos += sz;
1:             Clustering end = clustering(pos);
0:             Slice slice = Slice.make(skip == 0 ? Bound.exclusiveStartOf(start) : Bound.inclusiveStartOf(start), Bound.inclusiveEndOf(end));
1:             builder.add(slice);
1:         }
1:         return builder.build();
1:     }
1: 
0:     void testSliceableIterator(NavigableSet<Clusterable> sortedContent, AbstractBTreePartition partition, ColumnFilter cf, boolean reversed)
1:     {
1:         Function<? super Clusterable, ? extends Clusterable> colFilter = x -> x instanceof Row ? ((Row) x).filter(cf, cfm) : x;
1:         Slices slices = makeSlices();
0:         try (SliceableUnfilteredRowIterator sliceableIter = partition.sliceableUnfilteredIterator(cf, reversed))
1:         {
1:             for (Slice slice : (Iterable<Slice>) () -> directed(slices, reversed))
1:                 assertIteratorsEqual(streamOf(directed(slice(sortedContent, slice), reversed)).map(colFilter).iterator(),
0:                                      sliceableIter.slice(slice));
1:         }
1: 
0:         // Try using sliceable as unfiltered iterator
0:         try (SliceableUnfilteredRowIterator sliceableIter = partition.sliceableUnfilteredIterator(cf, reversed))
1:         {
0:             assertIteratorsEqual((reversed ? sortedContent.descendingSet() : sortedContent).
0:                                      stream().map(colFilter).iterator(),
0:                                  sliceableIter);
1:         }
1:     }
1: 
1:     private<T> Iterator<T> invert(Iterator<T> slice)
1:     {
1:         Deque<T> dest = new LinkedList<>();
1:         Iterators.addAll(dest, slice);
1:         return dest.descendingIterator();
1:     }
1: 
1:     private Iterator<Clusterable> slice(NavigableSet<Clusterable> sortedContent, Slices slices)
1:     {
1:         return Iterators.concat(streamOf(slices).map(slice -> slice(sortedContent, slice)).iterator());
1:     }
1: 
1:     private Iterator<Clusterable> slice(NavigableSet<Clusterable> sortedContent, Slice slice)
1:     {
1:         // Slice bounds are inclusive bounds, equal only to markers. Matched markers should be returned as one-sided boundaries.
1:         RangeTombstoneMarker prev = (RangeTombstoneMarker) sortedContent.headSet(slice.start(), true).descendingSet().stream().filter(x -> x instanceof RangeTombstoneMarker).findFirst().orElse(null);
1:         RangeTombstoneMarker next = (RangeTombstoneMarker) sortedContent.tailSet(slice.end(), true).stream().filter(x -> x instanceof RangeTombstoneMarker).findFirst().orElse(null);
1:         Iterator<Clusterable> result = sortedContent.subSet(slice.start(), false, slice.end(), false).iterator();
1:         if (prev != null && prev.isOpen(false))
1:             result = Iterators.concat(Iterators.singletonIterator(new RangeTombstoneBoundMarker(slice.start(), prev.openDeletionTime(false))), result);
1:         if (next != null && next.isClose(false))
1:             result = Iterators.concat(result, Iterators.singletonIterator(new RangeTombstoneBoundMarker(slice.end(), next.closeDeletionTime(false))));
1:         return result;
1:     }
1: 
1:     private Iterator<Slice> directed(Slices slices, boolean reversed)
1:     {
1:         return directed(slices.iterator(), reversed);
1:     }
1: 
1:     private <T> Iterator<T> directed(Iterator<T> iter, boolean reversed)
1:     {
1:         if (!reversed)
1:             return iter;
1:         return invert(iter);
1:     }
1: 
1:     private <T> Stream<T> streamOf(Iterator<T> iterator)
1:     {
1:         Iterable<T> iterable = () -> iterator;
1:         return streamOf(iterable);
1:     }
1: 
1:     <T> Stream<T> streamOf(Iterable<T> iterable)
1:     {
1:         return StreamSupport.stream(iterable.spliterator(), false);
1:     }
1: 
1:     private void assertIteratorsEqual(Iterator<? extends Clusterable> it1, Iterator<? extends Clusterable> it2)
1:     {
1:         Clusterable[] a1 = (Clusterable[]) Iterators.toArray(it1, Clusterable.class);
1:         Clusterable[] a2 = (Clusterable[]) Iterators.toArray(it2, Clusterable.class);
1:         if (Arrays.equals(a1, a2))
1:             return;
1:         String a1s = Stream.of(a1).map(x -> "\n" + (x instanceof Unfiltered ? ((Unfiltered) x).toString(cfm) : x.toString())).collect(Collectors.toList()).toString();
1:         String a2s = Stream.of(a2).map(x -> "\n" + (x instanceof Unfiltered ? ((Unfiltered) x).toString(cfm) : x.toString())).collect(Collectors.toList()).toString();
1:         assertArrayEquals("Arrays differ. Expected " + a1s + " was " + a2s, a1, a2);
1:     }
1: 
1:     private Row getRow(NavigableSet<Clusterable> sortedContent, Clustering cl)
1:     {
1:         NavigableSet<Clusterable> nexts = sortedContent.tailSet(cl, true);
1:         if (nexts.isEmpty())
1:             return null;
1:         Row row = nexts.first() instanceof Row && cfm.comparator.compare(cl, nexts.first()) == 0 ? (Row) nexts.first() : null;
1:         for (Clusterable next : nexts)
1:             if (next instanceof RangeTombstoneMarker)
1:             {
1:                 RangeTombstoneMarker rt = (RangeTombstoneMarker) next;
1:                 if (!rt.isClose(false))
1:                     return row;
1:                 DeletionTime delTime = rt.closeDeletionTime(false);
1:                 return row == null ? BTreeRow.emptyDeletedRow(cl, Deletion.regular(delTime)) : row.filter(ColumnFilter.all(cfm), delTime, true, cfm);
1:             }
1:         return row;
1:     }
1: 
1:     private void assertRowsEqual(Row expected, Row actual)
1:     {
1:         try
1:         {
1:             assertEquals(expected == null, actual == null);
1:             if (expected == null)
1:                 return;
1:             assertEquals(expected.clustering(), actual.clustering());
1:             assertEquals(expected.deletion(), actual.deletion());
1:             assertArrayEquals(Iterables.toArray(expected.cells(), Cell.class), Iterables.toArray(expected.cells(), Cell.class));
1:         } catch (Throwable t)
1:         {
1:             throw new AssertionError(String.format("Row comparison failed, expected %s got %s", expected, actual), t);
1:         }
1:     }
1: 
1:     private static<T> T get(NavigableSet<T> sortedContent, Predicate<T> test)
1:     {
1:         return sortedContent.stream().filter(test).findFirst().orElse(null);
1:     }
1: 
1:     @Test
1:     public void testEmpty()
1:     {
1:         test(() -> Collections.<Row>emptyList(), null);
1:     }
1: 
1:     @Test
1:     public void testStaticOnly()
1:     {
1:         test(() -> Collections.<Row>emptyList(), makeStaticRow());
1:     }
1: 
1:     @Test
1:     public void testRows()
1:     {
1:         test(this::generateRows, null);
1:     }
1: 
1:     @Test
1:     public void testRowsWithStatic()
1:     {
1:         test(this::generateRows, makeStaticRow());
1:     }
1: 
1:     @Test
1:     public void testMarkersOnly()
1:     {
1:         test(this::generateMarkersOnly, null);
1:     }
1: 
1:     @Test
1:     public void testMarkersWithStatic()
1:     {
1:         test(this::generateMarkersOnly, makeStaticRow());
1:     }
1: 
1:     @Test
1:     public void testUnfiltereds()
1:     {
1:         test(this::generateUnfiltereds, makeStaticRow());
1:     }
1: 
1: }
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1:         row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes(colValue)));
/////////////////////////////////////////////////////////////////////////
1:         row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes("static value")));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:4fb559b
/////////////////////////////////////////////////////////////////////////
1:         testSlicingOfIterators(sortedContent, partition, ColumnFilter.all(cfm), false);
1:         testSlicingOfIterators(sortedContent, partition, cf, false);
1:         testSlicingOfIterators(sortedContent, partition, ColumnFilter.all(cfm), true);
1:         testSlicingOfIterators(sortedContent, partition, cf, true);
/////////////////////////////////////////////////////////////////////////
1:     void testSlicingOfIterators(NavigableSet<Clusterable> sortedContent, AbstractBTreePartition partition, ColumnFilter cf, boolean reversed)
1: 
1:         // fetch each slice in turn
0:         for (Slice slice : (Iterable<Slice>) () -> directed(slices, reversed))
1:             try (UnfilteredRowIterator slicedIter = partition.unfilteredIterator(cf, Slices.with(cfm.comparator, slice), reversed))
1:             {
1:                                      slicedIter);
1:             }
1:         // Fetch all slices at once
1:         try (UnfilteredRowIterator slicedIter = partition.unfilteredIterator(cf, slices, reversed))
1:             List<Iterator<? extends Clusterable>> slicelist = new ArrayList<>();
1:             slices.forEach(slice -> slicelist.add(directed(slice(sortedContent, slice), reversed)));
1:             if (reversed)
1:                 Collections.reverse(slicelist);
1: 
1:             assertIteratorsEqual(Iterators.concat(slicelist.toArray(new Iterator[0])), slicedIter);
============================================================================