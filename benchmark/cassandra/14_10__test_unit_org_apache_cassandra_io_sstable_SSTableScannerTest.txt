1:9e846d9: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:9e846d9: package org.apache.cassandra.io.sstable;
1:9e846d9: 
1:4e29b7a: import java.io.IOException;
1:a991b64: import java.util.ArrayList;
1:a991b64: import java.util.Arrays;
1:a991b64: import java.util.Collection;
1:a991b64: import java.util.List;
1:9e846d9: 
1:572ef50: import com.google.common.collect.Iterables;
1:71b1c4a: import com.google.common.util.concurrent.RateLimiter;
1:71b1c4a: 
1:a991b64: import org.junit.BeforeClass;
1:9e846d9: import org.junit.Test;
1:9e846d9: 
1:9e846d9: import org.apache.cassandra.SchemaLoader;
1:9e846d9: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.db.ColumnFamilyStore;
1:a991b64: import org.apache.cassandra.db.DataRange;
1:a991b64: import org.apache.cassandra.db.DecoratedKey;
1:a991b64: import org.apache.cassandra.db.Keyspace;
1:a991b64: import org.apache.cassandra.db.PartitionPosition;
1:a991b64: import org.apache.cassandra.db.RowUpdateBuilder;
1:a991b64: import org.apache.cassandra.db.Slices;
1:a991b64: import org.apache.cassandra.db.filter.ClusteringIndexSliceFilter;
1:a991b64: import org.apache.cassandra.db.filter.ColumnFilter;
1:a991b64: import org.apache.cassandra.dht.AbstractBounds;
1:a991b64: import org.apache.cassandra.dht.ByteOrderedPartitioner;
1:a991b64: import org.apache.cassandra.dht.Range;
1:a991b64: import org.apache.cassandra.dht.Token;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:9e846d9: import org.apache.cassandra.utils.ByteBufferUtil;
1:9e846d9: 
1:572ef50: import static org.apache.cassandra.dht.AbstractBounds.isEmpty;
1:a991b64: import static org.junit.Assert.assertEquals;
1:a991b64: import static org.junit.Assert.assertFalse;
1:a991b64: import static org.junit.Assert.assertTrue;
1:9e846d9: 
1:d2a3827: public class SSTableScannerTest
1:9e846d9: {
1:d2a3827:     public static final String KEYSPACE = "SSTableScannerTest";
1:9e846d9:     public static final String TABLE = "Standard1";
1:9e846d9: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws Exception
1:d2a3827:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE, TABLE));
1:d2a3827:     }
1:d2a3827: 
1:9e846d9:     private static String toKey(int key)
1:9e846d9:     {
1:9e846d9:         return String.format("%03d", key);
1:9e846d9:     }
1:9e846d9: 
1:572ef50:     // we produce all DataRange variations that produce an inclusive start and exclusive end range
1:a991b64:     private static Iterable<DataRange> dataRanges(CFMetaData metadata, int start, int end)
1:9e846d9:     {
1:572ef50:         if (end < start)
1:a991b64:             return dataRanges(metadata, start, end, false, true);
1:a991b64:         return Iterables.concat(dataRanges(metadata, start, end, false, false),
1:a991b64:                                 dataRanges(metadata, start, end, false, true),
1:a991b64:                                 dataRanges(metadata, start, end, true, false),
1:a991b64:                                 dataRanges(metadata, start, end, true, true)
1:572ef50:         );
1:9e846d9:     }
1:9e846d9: 
1:a991b64:     private static Iterable<DataRange> dataRanges(CFMetaData metadata, int start, int end, boolean inclusiveStart, boolean inclusiveEnd)
1:572ef50:     {
1:572ef50:         List<DataRange> ranges = new ArrayList<>();
1:572ef50:         if (start == end + 1)
1:572ef50:         {
1:572ef50:             assert !inclusiveStart && inclusiveEnd;
1:a991b64:             ranges.add(dataRange(metadata, min(start), false, max(end), true));
1:a991b64:             ranges.add(dataRange(metadata, min(start), false, min(end + 1), true));
1:a991b64:             ranges.add(dataRange(metadata, max(start - 1), false, max(end), true));
1:a991b64:             ranges.add(dataRange(metadata, dk(start - 1), false, dk(start - 1), true));
1:572ef50:         }
1:572ef50:         else
1:572ef50:         {
1:a991b64:             for (PartitionPosition s : starts(start, inclusiveStart))
1:572ef50:             {
1:a991b64:                 for (PartitionPosition e : ends(end, inclusiveEnd))
1:572ef50:                 {
1:572ef50:                     if (end < start && e.compareTo(s) > 0)
1:572ef50:                         continue;
1:572ef50:                     if (!isEmpty(new AbstractBounds.Boundary<>(s, inclusiveStart), new AbstractBounds.Boundary<>(e, inclusiveEnd)))
1:572ef50:                         continue;
1:a991b64:                     ranges.add(dataRange(metadata, s, inclusiveStart, e, inclusiveEnd));
1:572ef50:                 }
1:572ef50:             }
1:572ef50:         }
1:572ef50:         return ranges;
1:572ef50:     }
1:572ef50: 
1:a991b64:     private static Iterable<PartitionPosition> starts(int key, boolean inclusive)
1:572ef50:     {
1:572ef50:         return Arrays.asList(min(key), max(key - 1), dk(inclusive ? key : key - 1));
1:572ef50:     }
1:572ef50: 
1:a991b64:     private static Iterable<PartitionPosition> ends(int key, boolean inclusive)
1:572ef50:     {
1:572ef50:         return Arrays.asList(max(key), min(key + 1), dk(inclusive ? key : key + 1));
1:572ef50:     }
1:572ef50: 
1:572ef50:     private static DecoratedKey dk(int key)
1:572ef50:     {
1:572ef50:         return Util.dk(toKey(key));
1:572ef50:     }
1:572ef50: 
1:572ef50:     private static Token token(int key)
1:572ef50:     {
1:f36fe9f:         return key == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(key).getBytes());
1:572ef50:     }
1:572ef50: 
1:a991b64:     private static PartitionPosition min(int key)
1:572ef50:     {
1:572ef50:         return token(key).minKeyBound();
1:572ef50:     }
1:572ef50: 
1:a991b64:     private static PartitionPosition max(int key)
1:572ef50:     {
1:572ef50:         return token(key).maxKeyBound();
1:572ef50:     }
1:572ef50: 
1:a991b64:     private static DataRange dataRange(CFMetaData metadata, PartitionPosition start, boolean startInclusive, PartitionPosition end, boolean endInclusive)
1:572ef50:     {
1:a991b64:         Slices.Builder sb = new Slices.Builder(metadata.comparator);
1:a991b64:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(sb.build(), false);
1:a991b64: 
1:a991b64:         return new DataRange(AbstractBounds.bounds(start, startInclusive, end, endInclusive), filter);
1:572ef50:     }
1:9e846d9: 
1:9e846d9:     private static Range<Token> rangeFor(int start, int end)
1:9e846d9:     {
1:f36fe9f:         return new Range<Token>(new ByteOrderedPartitioner.BytesToken(toKey(start).getBytes()),
1:f36fe9f:                                 end == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(end).getBytes()));
1:9e846d9:     }
1:9e846d9: 
1:9e846d9:     private static Collection<Range<Token>> makeRanges(int ... keys)
1:9e846d9:     {
1:9e846d9:         Collection<Range<Token>> ranges = new ArrayList<Range<Token>>(keys.length / 2);
1:9e846d9:         for (int i = 0; i < keys.length; i += 2)
1:9e846d9:             ranges.add(rangeFor(keys[i], keys[i + 1]));
1:9e846d9:         return ranges;
1:9e846d9:     }
1:9e846d9: 
1:a991b64:     private static void insertRowWithKey(CFMetaData metadata, int key)
1:9e846d9:     {
1:9e846d9:         long timestamp = System.currentTimeMillis();
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(metadata, timestamp, toKey(key))
1:a991b64:             .clustering("col")
1:a991b64:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:             .build()
1:a991b64:             .applyUnsafe();
1:a991b64: 
1:9e846d9:     }
1:9e846d9: 
1:572ef50:     private static void assertScanMatches(SSTableReader sstable, int scanStart, int scanEnd, int ... boundaries)
1:9e846d9:     {
1:572ef50:         assert boundaries.length % 2 == 0;
1:a991b64:         for (DataRange range : dataRanges(sstable.metadata, scanStart, scanEnd))
1:572ef50:         {
1:a991b64:             try(ISSTableScanner scanner = sstable.getScanner(ColumnFilter.all(sstable.metadata), range, false))
1:4e29b7a:             {
1:4e29b7a:                 for (int b = 0; b < boundaries.length; b += 2)
1:4e29b7a:                     for (int i = boundaries[b]; i <= boundaries[b + 1]; i++)
1:a991b64:                         assertEquals(toKey(i), new String(scanner.next().partitionKey().getKey().array()));
1:572ef50:                 assertFalse(scanner.hasNext());
1:572ef50:             }
1:4e29b7a:             catch (Exception e)
1:4e29b7a:             {
1:4e29b7a:                 throw new RuntimeException(e);
1:4e29b7a:             }
1:4e29b7a:         }
1:9e846d9:     }
1:81fcc33: 
1:9e846d9:     private static void assertScanEmpty(SSTableReader sstable, int scanStart, int scanEnd)
1:9e846d9:     {
1:572ef50:         assertScanMatches(sstable, scanStart, scanEnd);
1:9e846d9:     }
1:9e846d9: 
1:81fcc33:     @Test
1:4e29b7a:     public void testSingleDataRange() throws IOException
1:81fcc33:     {
1:81fcc33:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:81fcc33:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:81fcc33:         store.clearUnsafe();
1:81fcc33: 
1:81fcc33:         // disable compaction while flushing
1:81fcc33:         store.disableAutoCompaction();
1:81fcc33: 
1:9e846d9:         for (int i = 2; i < 10; i++)
1:a991b64:             insertRowWithKey(store.metadata, i);
1:81fcc33:         store.forceBlockingFlush();
1:81fcc33: 
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
1:81fcc33: 
1:81fcc33:         // full range scan
1:f2a3547:         ISSTableScanner scanner = sstable.getScanner();
1:9e846d9:         for (int i = 2; i < 10; i++)
1:a991b64:             assertEquals(toKey(i), new String(scanner.next().partitionKey().getKey().array()));
1:81fcc33: 
1:4e29b7a:         scanner.close();
1:4e29b7a: 
1:9e846d9:         // a simple read of a chunk in the middle
1:9e846d9:         assertScanMatches(sstable, 3, 6, 3, 6);
1:9e846d9: 
1:9e846d9:         // start of range edge conditions
1:9e846d9:         assertScanMatches(sstable, 1, 9, 2, 9);
1:9e846d9:         assertScanMatches(sstable, 2, 9, 2, 9);
1:9e846d9:         assertScanMatches(sstable, 3, 9, 3, 9);
1:9e846d9: 
1:9e846d9:         // end of range edge conditions
1:9e846d9:         assertScanMatches(sstable, 1, 8, 2, 8);
1:9e846d9:         assertScanMatches(sstable, 1, 9, 2, 9);
1:9e846d9:         assertScanMatches(sstable, 1, 9, 2, 9);
1:9e846d9: 
1:9e846d9:         // single item ranges
1:9e846d9:         assertScanMatches(sstable, 2, 2, 2, 2);
1:9e846d9:         assertScanMatches(sstable, 5, 5, 5, 5);
1:9e846d9:         assertScanMatches(sstable, 9, 9, 9, 9);
1:9e846d9: 
1:9e846d9:         // empty ranges
1:9e846d9:         assertScanEmpty(sstable, 0, 1);
1:9e846d9:         assertScanEmpty(sstable, 10, 11);
1:572ef50: 
1:572ef50:         // wrapping, starts in middle
1:572ef50:         assertScanMatches(sstable, 5, 3, 2, 3, 5, 9);
1:572ef50:         assertScanMatches(sstable, 5, 2, 2, 2, 5, 9);
1:572ef50:         assertScanMatches(sstable, 5, 1, 5, 9);
1:572ef50:         assertScanMatches(sstable, 5, Integer.MIN_VALUE, 5, 9);
1:572ef50:         // wrapping, starts at end
1:572ef50:         assertScanMatches(sstable, 9, 8, 2, 8, 9, 9);
1:572ef50:         assertScanMatches(sstable, 9, 3, 2, 3, 9, 9);
1:572ef50:         assertScanMatches(sstable, 9, 2, 2, 2, 9, 9);
1:572ef50:         assertScanMatches(sstable, 9, 1, 9, 9);
1:572ef50:         assertScanMatches(sstable, 9, Integer.MIN_VALUE, 9, 9);
1:572ef50:         assertScanMatches(sstable, 8, 3, 2, 3, 8, 9);
1:572ef50:         assertScanMatches(sstable, 8, 2, 2, 2, 8, 9);
1:572ef50:         assertScanMatches(sstable, 8, 1, 8, 9);
1:572ef50:         assertScanMatches(sstable, 8, Integer.MIN_VALUE, 8, 9);
1:572ef50:         // wrapping, starts past end
1:572ef50:         assertScanMatches(sstable, 10, 9, 2, 9);
1:572ef50:         assertScanMatches(sstable, 10, 5, 2, 5);
1:572ef50:         assertScanMatches(sstable, 10, 2, 2, 2);
1:572ef50:         assertScanEmpty(sstable, 10, 1);
1:572ef50:         assertScanEmpty(sstable, 10, Integer.MIN_VALUE);
1:572ef50:         assertScanMatches(sstable, 11, 10, 2, 9);
1:572ef50:         assertScanMatches(sstable, 11, 9, 2, 9);
1:572ef50:         assertScanMatches(sstable, 11, 5, 2, 5);
1:572ef50:         assertScanMatches(sstable, 11, 2, 2, 2);
1:572ef50:         assertScanEmpty(sstable, 11, 1);
1:572ef50:         assertScanEmpty(sstable, 11, Integer.MIN_VALUE);
1:572ef50:         // wrapping, starts at start
1:572ef50:         assertScanMatches(sstable, 3, 1, 3, 9);
1:572ef50:         assertScanMatches(sstable, 3, Integer.MIN_VALUE, 3, 9);
1:572ef50:         assertScanMatches(sstable, 2, 1, 2, 9);
1:572ef50:         assertScanMatches(sstable, 2, Integer.MIN_VALUE, 2, 9);
1:572ef50:         assertScanMatches(sstable, 1, 0, 2, 9);
1:572ef50:         assertScanMatches(sstable, 1, Integer.MIN_VALUE, 2, 9);
1:572ef50:         // wrapping, starts before
1:572ef50:         assertScanMatches(sstable, 1, -1, 2, 9);
1:572ef50:         assertScanMatches(sstable, 1, Integer.MIN_VALUE, 2, 9);
1:572ef50:         assertScanMatches(sstable, 1, 0, 2, 9);
1:9e846d9:     }
1:9e846d9: 
1:4e29b7a:     private static void assertScanContainsRanges(ISSTableScanner scanner, int ... rangePairs) throws IOException
1:9e846d9:     {
1:9e846d9:         assert rangePairs.length % 2 == 0;
1:9e846d9: 
1:9e846d9:         for (int pairIdx = 0; pairIdx < rangePairs.length; pairIdx += 2)
1:9e846d9:         {
1:9e846d9:             int rangeStart = rangePairs[pairIdx];
1:9e846d9:             int rangeEnd = rangePairs[pairIdx + 1];
1:9e846d9: 
1:9e846d9:             for (int expected = rangeStart; expected <= rangeEnd; expected++)
1:9e846d9:             {
1:9e846d9:                 assertTrue(String.format("Expected to see key %03d", expected), scanner.hasNext());
1:a991b64:                 assertEquals(toKey(expected), new String(scanner.next().partitionKey().getKey().array()));
1:9e846d9:             }
1:9e846d9:         }
1:4e29b7a:         assertFalse(scanner.hasNext());
1:4e29b7a:         scanner.close();
1:9e846d9:     }
1:9e846d9: 
1:9e846d9:     @Test
1:4e29b7a:     public void testMultipleRanges() throws IOException
1:9e846d9:     {
1:9e846d9:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:9e846d9:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:9e846d9:         store.clearUnsafe();
1:9e846d9: 
1:9e846d9:         // disable compaction while flushing
1:9e846d9:         store.disableAutoCompaction();
1:9e846d9: 
1:9e846d9:         for (int i = 0; i < 3; i++)
1:9e846d9:             for (int j = 2; j < 10; j++)
1:a991b64:                 insertRowWithKey(store.metadata, i * 100 + j);
1:9e846d9:         store.forceBlockingFlush();
1:9e846d9: 
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
1:9e846d9: 
1:9e846d9:         // full range scan
1:f2a3547:         ISSTableScanner fullScanner = sstable.getScanner();
1:9e846d9:         assertScanContainsRanges(fullScanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9: 
1:9e846d9:         // scan all three ranges separately
1:1fec4a4:         ISSTableScanner scanner = sstable.getScanner(makeRanges(1, 9,
1:81fcc33:                                                                    101, 109,
1:f2a3547:                                                                    201, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9:         // skip the first range
1:9e846d9:         scanner = sstable.getScanner(makeRanges(101, 109,
1:f2a3547:                                                 201, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9:         // skip the second range
1:9e846d9:         scanner = sstable.getScanner(makeRanges(1, 9,
1:f2a3547:                                                 201, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9: 
1:9e846d9:         // skip the last range
1:9e846d9:         scanner = sstable.getScanner(makeRanges(1, 9,
1:f2a3547:                                                 101, 109));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  102, 109);
1:9e846d9: 
1:9e846d9:         // the first scanned range stops short of the actual data in the first range
1:9e846d9:         scanner = sstable.getScanner(makeRanges(1, 5,
2:9e846d9:                                                 101, 109,
1:f2a3547:                                                 201, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 5,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9:         // the first scanned range requests data beyond actual data in the first range
1:9e846d9:         scanner = sstable.getScanner(makeRanges(1, 20,
1:9e846d9:                                                 101, 109,
1:f2a3547:                                                 201, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9: 
1:9e846d9:         // the middle scan range splits the outside two data ranges
1:9e846d9:         scanner = sstable.getScanner(makeRanges(1, 5,
1:9e846d9:                                                 6, 205,
1:f2a3547:                                                 206, 209));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 5,
1:9e846d9:                                  7, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 205,
1:9e846d9:                                  207, 209);
1:9e846d9: 
1:9e846d9:         // empty ranges
1:9e846d9:         scanner = sstable.getScanner(makeRanges(0, 1,
1:9e846d9:                                                 2, 20,
1:9e846d9:                                                 101, 109,
1:9e846d9:                                                 150, 159,
1:9e846d9:                                                 201, 209,
1:f2a3547:                                                 1000, 1001));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  3, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9:         // out of order ranges
1:9e846d9:         scanner = sstable.getScanner(makeRanges(201, 209,
1:9e846d9:                                                 1, 20,
1:9e846d9:                                                 201, 209,
1:9e846d9:                                                 101, 109,
1:9e846d9:                                                 1000, 1001,
1:f2a3547:                                                 150, 159));
1:9e846d9:         assertScanContainsRanges(scanner,
1:9e846d9:                                  2, 9,
1:9e846d9:                                  102, 109,
1:9e846d9:                                  202, 209);
1:9e846d9: 
1:9e846d9:         // only empty ranges
1:9e846d9:         scanner = sstable.getScanner(makeRanges(0, 1,
1:9e846d9:                                                 150, 159,
1:f2a3547:                                                 250, 259));
3:9e846d9:         assertFalse(scanner.hasNext());
1:9e846d9: 
1:9e846d9:         // no ranges is equivalent to a full scan
1:f2a3547:         scanner = sstable.getScanner(new ArrayList<Range<Token>>());
1:9e846d9:         assertFalse(scanner.hasNext());
1:9e846d9:     }
1:9e846d9: 
1:9e846d9:     @Test
1:4e29b7a:     public void testSingleKeyMultipleRanges() throws IOException
1:9e846d9:     {
1:9e846d9:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:9e846d9:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:9e846d9:         store.clearUnsafe();
1:9e846d9: 
1:9e846d9:         // disable compaction while flushing
1:9e846d9:         store.disableAutoCompaction();
1:9e846d9: 
1:a991b64:         insertRowWithKey(store.metadata, 205);
1:9e846d9:         store.forceBlockingFlush();
1:9e846d9: 
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
1:9e846d9: 
1:9e846d9:         // full range scan
1:f2a3547:         ISSTableScanner fullScanner = sstable.getScanner();
1:81fcc33:         assertScanContainsRanges(fullScanner, 205, 205);
1:9e846d9: 
1:81fcc33:         // scan three ranges separately
1:1fec4a4:         ISSTableScanner scanner = sstable.getScanner(makeRanges(101, 109,
1:f2a3547:                                                                    201, 209));
1:81fcc33: 
1:cd26f48:         // this will currently fail
1:81fcc33:         assertScanContainsRanges(scanner, 205, 205);
1:81fcc33:     }
1:9e846d9: }
============================================================================
author:Anthony Grasso
-------------------------------------------------------------------------------
commit:f2a3547
/////////////////////////////////////////////////////////////////////////
1:         ISSTableScanner scanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
1:         ISSTableScanner fullScanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
1:                                                                    201, 209));
/////////////////////////////////////////////////////////////////////////
1:                                                 201, 209));
1:                                                 201, 209));
/////////////////////////////////////////////////////////////////////////
1:                                                 101, 109));
/////////////////////////////////////////////////////////////////////////
1:                                                 201, 209));
/////////////////////////////////////////////////////////////////////////
1:                                                 201, 209));
/////////////////////////////////////////////////////////////////////////
1:                                                 206, 209));
/////////////////////////////////////////////////////////////////////////
1:                                                 1000, 1001));
/////////////////////////////////////////////////////////////////////////
1:                                                 150, 159));
/////////////////////////////////////////////////////////////////////////
1:                                                 250, 259));
1:         scanner = sstable.getScanner(new ArrayList<Range<Token>>());
/////////////////////////////////////////////////////////////////////////
1:         ISSTableScanner fullScanner = sstable.getScanner();
1:                                                                    201, 209));
author:Chris Lohfink
-------------------------------------------------------------------------------
commit:71b1c4a
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.util.concurrent.RateLimiter;
1: 
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner scanner = sstable.getScanner(RateLimiter.create(Double.MAX_VALUE));
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner fullScanner = sstable.getScanner(RateLimiter.create(Double.MAX_VALUE));
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner fullScanner = sstable.getScanner(RateLimiter.create(Double.MAX_VALUE));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         SSTableReader sstable = store.getLiveSSTables().iterator().next();
commit:f36fe9f
/////////////////////////////////////////////////////////////////////////
1:         return key == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(key).getBytes());
/////////////////////////////////////////////////////////////////////////
1:         return new Range<Token>(new ByteOrderedPartitioner.BytesToken(toKey(start).getBytes()),
1:                                 end == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(end).getBytes()));
commit:7aefd91
commit:572ef50
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
1: import com.google.common.collect.Iterables;
0: import org.apache.cassandra.dht.*;
1: import static org.apache.cassandra.dht.AbstractBounds.isEmpty;
/////////////////////////////////////////////////////////////////////////
1:     // we produce all DataRange variations that produce an inclusive start and exclusive end range
0:     private static Iterable<DataRange> dataRanges(int start, int end)
1:         if (end < start)
0:             return dataRanges(start, end, false, true);
0:         return Iterables.concat(dataRanges(start, end, false, false),
0:                                 dataRanges(start, end, false, true),
0:                                 dataRanges(start, end, true, false),
0:                                 dataRanges(start, end, true, true)
1:         );
0:     private static Iterable<DataRange> dataRanges(int start, int end, boolean inclusiveStart, boolean inclusiveEnd)
1:     {
1:         List<DataRange> ranges = new ArrayList<>();
1:         if (start == end + 1)
1:         {
1:             assert !inclusiveStart && inclusiveEnd;
0:             ranges.add(dataRange(min(start), false, max(end), true));
0:             ranges.add(dataRange(min(start), false, min(end + 1), true));
0:             ranges.add(dataRange(max(start - 1), false, max(end), true));
0:             ranges.add(dataRange(dk(start - 1), false, dk(start - 1), true));
1:         }
1:         else
1:         {
0:             for (RowPosition s : starts(start, inclusiveStart))
1:             {
0:                 for (RowPosition e : ends(end, inclusiveEnd))
1:                 {
1:                     if (end < start && e.compareTo(s) > 0)
1:                         continue;
1:                     if (!isEmpty(new AbstractBounds.Boundary<>(s, inclusiveStart), new AbstractBounds.Boundary<>(e, inclusiveEnd)))
1:                         continue;
0:                     ranges.add(dataRange(s, inclusiveStart, e, inclusiveEnd));
1:                 }
1:             }
1:         }
1:         return ranges;
1:     }
1: 
0:     private static Iterable<RowPosition> starts(int key, boolean inclusive)
1:     {
1:         return Arrays.asList(min(key), max(key - 1), dk(inclusive ? key : key - 1));
1:     }
1: 
0:     private static Iterable<RowPosition> ends(int key, boolean inclusive)
1:     {
1:         return Arrays.asList(max(key), min(key + 1), dk(inclusive ? key : key + 1));
1:     }
1: 
1:     private static DecoratedKey dk(int key)
1:     {
1:         return Util.dk(toKey(key));
1:     }
1: 
1:     private static Token token(int key)
1:     {
0:         return key == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new BytesToken(toKey(key).getBytes());
1:     }
1: 
0:     private static RowPosition min(int key)
1:     {
1:         return token(key).minKeyBound();
1:     }
1: 
0:     private static RowPosition max(int key)
1:     {
1:         return token(key).maxKeyBound();
1:     }
1: 
0:     private static DataRange dataRange(RowPosition start, boolean startInclusive, RowPosition end, boolean endInclusive)
1:     {
0:         return new DataRange(AbstractBounds.bounds(start, startInclusive, end, endInclusive), new IdentityQueryFilter());
1:     }
0:                                 end == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new BytesToken(toKey(end).getBytes()));
/////////////////////////////////////////////////////////////////////////
1:     private static void assertScanMatches(SSTableReader sstable, int scanStart, int scanEnd, int ... boundaries)
1:         assert boundaries.length % 2 == 0;
0:         for (DataRange range : dataRanges(scanStart, scanEnd))
1:         {
0:             ISSTableScanner scanner = sstable.getScanner(range);
0:             for (int b = 0 ; b < boundaries.length ; b += 2)
0:                 for (int i = boundaries[b] ; i <= boundaries[b + 1] ; i++)
0:                     assertEquals(toKey(i), new String(scanner.next().getKey().getKey().array()));
1:             assertFalse(scanner.hasNext());
1:         }
1:         assertScanMatches(sstable, scanStart, scanEnd);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // wrapping, starts in middle
1:         assertScanMatches(sstable, 5, 3, 2, 3, 5, 9);
1:         assertScanMatches(sstable, 5, 2, 2, 2, 5, 9);
1:         assertScanMatches(sstable, 5, 1, 5, 9);
1:         assertScanMatches(sstable, 5, Integer.MIN_VALUE, 5, 9);
1:         // wrapping, starts at end
1:         assertScanMatches(sstable, 9, 8, 2, 8, 9, 9);
1:         assertScanMatches(sstable, 9, 3, 2, 3, 9, 9);
1:         assertScanMatches(sstable, 9, 2, 2, 2, 9, 9);
1:         assertScanMatches(sstable, 9, 1, 9, 9);
1:         assertScanMatches(sstable, 9, Integer.MIN_VALUE, 9, 9);
1:         assertScanMatches(sstable, 8, 3, 2, 3, 8, 9);
1:         assertScanMatches(sstable, 8, 2, 2, 2, 8, 9);
1:         assertScanMatches(sstable, 8, 1, 8, 9);
1:         assertScanMatches(sstable, 8, Integer.MIN_VALUE, 8, 9);
1:         // wrapping, starts past end
1:         assertScanMatches(sstable, 10, 9, 2, 9);
1:         assertScanMatches(sstable, 10, 5, 2, 5);
1:         assertScanMatches(sstable, 10, 2, 2, 2);
1:         assertScanEmpty(sstable, 10, 1);
1:         assertScanEmpty(sstable, 10, Integer.MIN_VALUE);
1:         assertScanMatches(sstable, 11, 10, 2, 9);
1:         assertScanMatches(sstable, 11, 9, 2, 9);
1:         assertScanMatches(sstable, 11, 5, 2, 5);
1:         assertScanMatches(sstable, 11, 2, 2, 2);
1:         assertScanEmpty(sstable, 11, 1);
1:         assertScanEmpty(sstable, 11, Integer.MIN_VALUE);
1:         // wrapping, starts at start
1:         assertScanMatches(sstable, 3, 1, 3, 9);
1:         assertScanMatches(sstable, 3, Integer.MIN_VALUE, 3, 9);
1:         assertScanMatches(sstable, 2, 1, 2, 9);
1:         assertScanMatches(sstable, 2, Integer.MIN_VALUE, 2, 9);
1:         assertScanMatches(sstable, 1, 0, 2, 9);
1:         assertScanMatches(sstable, 1, Integer.MIN_VALUE, 2, 9);
1:         // wrapping, starts before
1:         assertScanMatches(sstable, 1, -1, 2, 9);
1:         assertScanMatches(sstable, 1, Integer.MIN_VALUE, 2, 9);
1:         assertScanMatches(sstable, 1, 0, 2, 9);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE, decoratedKey.key);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.List;
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.db.ColumnFamilyStore;
1: import org.apache.cassandra.db.DataRange;
1: import org.apache.cassandra.db.DecoratedKey;
1: import org.apache.cassandra.db.Keyspace;
1: import org.apache.cassandra.db.PartitionPosition;
1: import org.apache.cassandra.db.RowUpdateBuilder;
1: import org.apache.cassandra.db.Slices;
1: import org.apache.cassandra.db.filter.ClusteringIndexSliceFilter;
1: import org.apache.cassandra.db.filter.ColumnFilter;
1: import org.apache.cassandra.dht.AbstractBounds;
1: import org.apache.cassandra.dht.ByteOrderedPartitioner;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:     private static Iterable<DataRange> dataRanges(CFMetaData metadata, int start, int end)
1:             return dataRanges(metadata, start, end, false, true);
1:         return Iterables.concat(dataRanges(metadata, start, end, false, false),
1:                                 dataRanges(metadata, start, end, false, true),
1:                                 dataRanges(metadata, start, end, true, false),
1:                                 dataRanges(metadata, start, end, true, true)
1:     private static Iterable<DataRange> dataRanges(CFMetaData metadata, int start, int end, boolean inclusiveStart, boolean inclusiveEnd)
1:             ranges.add(dataRange(metadata, min(start), false, max(end), true));
1:             ranges.add(dataRange(metadata, min(start), false, min(end + 1), true));
1:             ranges.add(dataRange(metadata, max(start - 1), false, max(end), true));
1:             ranges.add(dataRange(metadata, dk(start - 1), false, dk(start - 1), true));
1:             for (PartitionPosition s : starts(start, inclusiveStart))
1:                 for (PartitionPosition e : ends(end, inclusiveEnd))
1:                     ranges.add(dataRange(metadata, s, inclusiveStart, e, inclusiveEnd));
1:     private static Iterable<PartitionPosition> starts(int key, boolean inclusive)
1:     private static Iterable<PartitionPosition> ends(int key, boolean inclusive)
/////////////////////////////////////////////////////////////////////////
1:     private static PartitionPosition min(int key)
1:     private static PartitionPosition max(int key)
1:     private static DataRange dataRange(CFMetaData metadata, PartitionPosition start, boolean startInclusive, PartitionPosition end, boolean endInclusive)
1:         Slices.Builder sb = new Slices.Builder(metadata.comparator);
1:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(sb.build(), false);
1: 
1:         return new DataRange(AbstractBounds.bounds(start, startInclusive, end, endInclusive), filter);
/////////////////////////////////////////////////////////////////////////
1:     private static void insertRowWithKey(CFMetaData metadata, int key)
1: 
1:         new RowUpdateBuilder(metadata, timestamp, toKey(key))
1:             .clustering("col")
1:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:             .build()
1:             .applyUnsafe();
1: 
1:         for (DataRange range : dataRanges(sstable.metadata, scanStart, scanEnd))
1:             try(ISSTableScanner scanner = sstable.getScanner(ColumnFilter.all(sstable.metadata), range, false))
1:                         assertEquals(toKey(i), new String(scanner.next().partitionKey().getKey().array()));
/////////////////////////////////////////////////////////////////////////
1:             insertRowWithKey(store.metadata, i);
0:         ISSTableScanner scanner = sstable.getScanner(null);
1:             assertEquals(toKey(i), new String(scanner.next().partitionKey().getKey().array()));
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(toKey(expected), new String(scanner.next().partitionKey().getKey().array()));
/////////////////////////////////////////////////////////////////////////
1:                 insertRowWithKey(store.metadata, i * 100 + j);
0:         ISSTableScanner fullScanner = sstable.getScanner(null);
/////////////////////////////////////////////////////////////////////////
1:         insertRowWithKey(store.metadata, 205);
0:         ISSTableScanner fullScanner = sstable.getScanner(null);
commit:b5a3303
commit:81fcc33
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testSingleKeyMultipleRanges()
1:     {
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:         store.clearUnsafe();
1: 
1:         // disable compaction while flushing
1:         store.disableAutoCompaction();
1: 
0:         insertRowWithKey(205);
1:         store.forceBlockingFlush();
1: 
0:         assertEquals(1, store.getSSTables().size());
0:         SSTableReader sstable = store.getSSTables().iterator().next();
1: 
1:         // full range scan
0:         SSTableScanner fullScanner = sstable.getScanner();
1:         assertScanContainsRanges(fullScanner, 205, 205);
1: 
1:         // scan three ranges separately
0:         ICompactionScanner scanner = sstable.getScanner(makeRanges(
1:                 101, 109,
0:                 201, 209),
0:                 null);
1: 
0:         // Test for #6638 bug
1:         assertScanContainsRanges(scanner, 205, 205);
1:     }
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0:         rm.add(TABLE, Util.cellname("col"), ByteBufferUtil.EMPTY_BYTE_BUFFER, timestamp, 1000);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:4e29b7a
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:             try(ISSTableScanner scanner = sstable.getScanner(range))
1:             {
1:                 for (int b = 0; b < boundaries.length; b += 2)
1:                     for (int i = boundaries[b]; i <= boundaries[b + 1]; i++)
0:                         assertEquals(toKey(i), new String(scanner.next().getKey().getKey().array()));
1:                 assertFalse(scanner.hasNext());
1:             }
1:             catch (Exception e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public void testSingleDataRange() throws IOException
/////////////////////////////////////////////////////////////////////////
1:         scanner.close();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static void assertScanContainsRanges(ISSTableScanner scanner, int ... rangePairs) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         scanner.close();
1:     public void testMultipleRanges() throws IOException
/////////////////////////////////////////////////////////////////////////
1:     public void testSingleKeyMultipleRanges() throws IOException
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:bee53d7
commit:1fec4a4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner scanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
0:     private static void assertScanContainsRanges(ISSTableScanner scanner, int ... rangePairs)
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner fullScanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
1:         ISSTableScanner scanner = sstable.getScanner(makeRanges(1, 9,
/////////////////////////////////////////////////////////////////////////
0:         ISSTableScanner fullScanner = sstable.getScanner();
1:         ISSTableScanner scanner = sstable.getScanner(makeRanges(101, 109,
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:07893d7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.ByteOrderedPartitioner.BytesToken;
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner scanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner fullScanner = sstable.getScanner();
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner fullScanner = sstable.getScanner();
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.SimpleStrategy;
1: public class SSTableScannerTest
1:     public static final String KEYSPACE = "SSTableScannerTest";
1:     @BeforeClass
1:     public static void defineSchema() throws Exception
1:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE, TABLE));
1:     }
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE, decoratedKey.getKey());
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(toKey(i), new String(scanner.next().getKey().getKey().array()));
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(toKey(i), new String(scanner.next().getKey().getKey().array()));
/////////////////////////////////////////////////////////////////////////
0:                 assertEquals(toKey(expected), new String(scanner.next().getKey().getKey().array()));
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:5653516
commit:cd26f48
/////////////////////////////////////////////////////////////////////////
0:         ICompactionScanner scanner = sstable.getScanner(makeRanges(101, 109,
0:                                                                    201, 209), null);
1:         // this will currently fail
author:Dave Brosius
-------------------------------------------------------------------------------
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:9e846d9
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
1: package org.apache.cassandra.io.sstable;
1: 
0: import java.util.ArrayList;
0: import java.util.Collection;
1: 
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
0: import org.apache.cassandra.db.compaction.ICompactionScanner;
0: import org.apache.cassandra.dht.Bounds;
0: import org.apache.cassandra.dht.BytesToken;
0: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: import static junit.framework.Assert.*;
1: 
0: public class SSTableScannerTest extends SchemaLoader
1: {
0:     public static final String KEYSPACE = "Keyspace1";
1:     public static final String TABLE = "Standard1";
1: 
1:     private static String toKey(int key)
1:     {
1:         return String.format("%03d", key);
1:     }
1: 
0:     private static Bounds<RowPosition> boundsFor(int start, int end)
1:     {
0:         return new Bounds<RowPosition>(new BytesToken(toKey(start).getBytes()).minKeyBound(),
0:                                        new BytesToken(toKey(end).getBytes()).maxKeyBound());
1:     }
1: 
1: 
1:     private static Range<Token> rangeFor(int start, int end)
1:     {
0:         return new Range<Token>(new BytesToken(toKey(start).getBytes()),
0:                                 new BytesToken(toKey(end).getBytes()));
1:     }
1: 
1:     private static Collection<Range<Token>> makeRanges(int ... keys)
1:     {
1:         Collection<Range<Token>> ranges = new ArrayList<Range<Token>>(keys.length / 2);
1:         for (int i = 0; i < keys.length; i += 2)
1:             ranges.add(rangeFor(keys[i], keys[i + 1]));
1:         return ranges;
1:     }
1: 
0:     private static void insertRowWithKey(int key)
1:     {
1:         long timestamp = System.currentTimeMillis();
0:         DecoratedKey decoratedKey = Util.dk(toKey(key));
0:         RowMutation rm = new RowMutation(KEYSPACE, decoratedKey.key);
0:         rm.add(TABLE, ByteBufferUtil.bytes("col"), ByteBufferUtil.EMPTY_BYTE_BUFFER, timestamp, 1000);
0:         rm.apply();
1:     }
1: 
0:     private static void assertScanMatches(SSTableReader sstable, int scanStart, int scanEnd, int expectedStart, int expectedEnd)
1:     {
0:         SSTableScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
0:         for (int i = expectedStart; i <= expectedEnd; i++)
0:             assertEquals(toKey(i), new String(scanner.next().getKey().key.array()));
1:         assertFalse(scanner.hasNext());
1:     }
1: 
1:     private static void assertScanEmpty(SSTableReader sstable, int scanStart, int scanEnd)
1:     {
0:         SSTableScanner scanner = sstable.getScanner(new DataRange(boundsFor(scanStart, scanEnd), new IdentityQueryFilter()));
0:         assertFalse(String.format("scan of (%03d, %03d] should be empty", scanStart, scanEnd), scanner.hasNext());
1:     }
1: 
1:     @Test
0:     public void testSingleDataRange()
1:     {
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:         store.clearUnsafe();
1: 
1:         // disable compaction while flushing
1:         store.disableAutoCompaction();
1: 
1:         for (int i = 2; i < 10; i++)
0:             insertRowWithKey(i);
1:         store.forceBlockingFlush();
1: 
0:         assertEquals(1, store.getSSTables().size());
0:         SSTableReader sstable = store.getSSTables().iterator().next();
1: 
1:         // full range scan
0:         SSTableScanner scanner = sstable.getScanner();
1:         for (int i = 2; i < 10; i++)
0:             assertEquals(toKey(i), new String(scanner.next().getKey().key.array()));
1: 
1:         // a simple read of a chunk in the middle
1:         assertScanMatches(sstable, 3, 6, 3, 6);
1: 
1:         // start of range edge conditions
1:         assertScanMatches(sstable, 1, 9, 2, 9);
1:         assertScanMatches(sstable, 2, 9, 2, 9);
1:         assertScanMatches(sstable, 3, 9, 3, 9);
1: 
1:         // end of range edge conditions
1:         assertScanMatches(sstable, 1, 8, 2, 8);
1:         assertScanMatches(sstable, 1, 9, 2, 9);
1:         assertScanMatches(sstable, 1, 9, 2, 9);
1: 
1:         // single item ranges
1:         assertScanMatches(sstable, 2, 2, 2, 2);
1:         assertScanMatches(sstable, 5, 5, 5, 5);
1:         assertScanMatches(sstable, 9, 9, 9, 9);
1: 
1:         // empty ranges
1:         assertScanEmpty(sstable, 0, 1);
1:         assertScanEmpty(sstable, 10, 11);
1:     }
1: 
0:     private static void assertScanContainsRanges(ICompactionScanner scanner, int ... rangePairs)
1:     {
1:         assert rangePairs.length % 2 == 0;
1: 
1:         for (int pairIdx = 0; pairIdx < rangePairs.length; pairIdx += 2)
1:         {
1:             int rangeStart = rangePairs[pairIdx];
1:             int rangeEnd = rangePairs[pairIdx + 1];
1: 
1:             for (int expected = rangeStart; expected <= rangeEnd; expected++)
1:             {
1:                 assertTrue(String.format("Expected to see key %03d", expected), scanner.hasNext());
0:                 assertEquals(toKey(expected), new String(scanner.next().getKey().key.array()));
1:             }
1:         }
1:         assertFalse(scanner.hasNext());
1:     }
1: 
1:     @Test
0:     public void testMultipleRanges()
1:     {
1:         Keyspace keyspace = Keyspace.open(KEYSPACE);
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore(TABLE);
1:         store.clearUnsafe();
1: 
1:         // disable compaction while flushing
1:         store.disableAutoCompaction();
1: 
1:         for (int i = 0; i < 3; i++)
1:             for (int j = 2; j < 10; j++)
0:                 insertRowWithKey(i * 100 + j);
1:         store.forceBlockingFlush();
1: 
0:         assertEquals(1, store.getSSTables().size());
0:         SSTableReader sstable = store.getSSTables().iterator().next();
1: 
1:         // full range scan
0:         SSTableScanner fullScanner = sstable.getScanner();
1:         assertScanContainsRanges(fullScanner,
1:                                  2, 9,
1:                                  102, 109,
1:                                  202, 209);
1: 
1: 
1:         // scan all three ranges separately
0:         ICompactionScanner scanner = sstable.getScanner(makeRanges(1, 9,
1:                                                                    101, 109,
0:                                                                    201, 209),
0:                                                         null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 9,
1:                                  102, 109,
1:                                  202, 209);
1: 
1:         // skip the first range
1:         scanner = sstable.getScanner(makeRanges(101, 109,
0:                                                 201, 209),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  102, 109,
1:                                  202, 209);
1: 
1:         // skip the second range
1:         scanner = sstable.getScanner(makeRanges(1, 9,
0:                                                 201, 209),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 9,
1:                                  202, 209);
1: 
1: 
1:         // skip the last range
1:         scanner = sstable.getScanner(makeRanges(1, 9,
0:                                                 101, 109),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 9,
1:                                  102, 109);
1: 
1:         // the first scanned range stops short of the actual data in the first range
1:         scanner = sstable.getScanner(makeRanges(1, 5,
1:                                                 101, 109,
0:                                                 201, 209),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 5,
1:                                  102, 109,
1:                                  202, 209);
1: 
1:         // the first scanned range requests data beyond actual data in the first range
1:         scanner = sstable.getScanner(makeRanges(1, 20,
1:                                                 101, 109,
0:                                                 201, 209),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 9,
1:                                  102, 109,
1:                                  202, 209);
1: 
1: 
1:         // the middle scan range splits the outside two data ranges
1:         scanner = sstable.getScanner(makeRanges(1, 5,
1:                                                 6, 205,
0:                                                 206, 209),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 5,
1:                                  7, 9,
1:                                  102, 109,
1:                                  202, 205,
1:                                  207, 209);
1: 
1:         // empty ranges
1:         scanner = sstable.getScanner(makeRanges(0, 1,
1:                                                 2, 20,
1:                                                 101, 109,
1:                                                 150, 159,
1:                                                 201, 209,
0:                                                 1000, 1001),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  3, 9,
1:                                  102, 109,
1:                                  202, 209);
1: 
1:         // out of order ranges
1:         scanner = sstable.getScanner(makeRanges(201, 209,
1:                                                 1, 20,
1:                                                 201, 209,
1:                                                 101, 109,
1:                                                 1000, 1001,
0:                                                 150, 159),
0:                                      null);
1:         assertScanContainsRanges(scanner,
1:                                  2, 9,
1:                                  102, 109,
1:                                  202, 209);
1: 
1:         // only empty ranges
1:         scanner = sstable.getScanner(makeRanges(0, 1,
1:                                                 150, 159,
0:                                                 250, 259),
0:                                      null);
1:         assertFalse(scanner.hasNext());
1: 
1:         // no ranges is equivalent to a full scan
0:         scanner = sstable.getScanner(new ArrayList<Range<Token>>(), null);
1:         assertFalse(scanner.hasNext());
1:     }
1: }
============================================================================