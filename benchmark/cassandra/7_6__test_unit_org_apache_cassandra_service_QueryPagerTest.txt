2:e48ff29: /*
1:e48ff29: * Licensed to the Apache Software Foundation (ASF) under one
1:e48ff29: * or more contributor license agreements.  See the NOTICE file
1:e48ff29: * distributed with this work for additional information
1:e48ff29: * regarding copyright ownership.  The ASF licenses this file
1:e48ff29: * to you under the Apache License, Version 2.0 (the
1:e48ff29: * "License"); you may not use this file except in compliance
1:e48ff29: * with the License.  You may obtain a copy of the License at
1:e48ff29: *
1:e48ff29: *    http://www.apache.org/licenses/LICENSE-2.0
1:e48ff29: *
1:e48ff29: * Unless required by applicable law or agreed to in writing,
1:e48ff29: * software distributed under the License is distributed on an
1:e48ff29: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e48ff29: * KIND, either express or implied.  See the License for the
1:e48ff29: * specific language governing permissions and limitations
1:e48ff29: * under the License.
2:e48ff29: */
1:e48ff29: package org.apache.cassandra.service;
12:e48ff29: 
1:e48ff29: import java.nio.ByteBuffer;
1:e48ff29: import java.nio.charset.CharacterCodingException;
1:a991b64: import java.util.*;
1:e48ff29: 
1:e48ff29: import org.junit.BeforeClass;
1:e48ff29: import org.junit.Test;
1:e48ff29: import org.junit.runner.RunWith;
1:e48ff29: 
1:a991b64: import org.apache.cassandra.*;
1:d2a3827: import org.apache.cassandra.config.CFMetaData;
1:e48ff29: import org.apache.cassandra.db.*;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:a991b64: import org.apache.cassandra.db.rows.RowIterator;
1:e48ff29: import org.apache.cassandra.db.filter.*;
1:a991b64: import org.apache.cassandra.db.partitions.FilteredPartition;
1:a991b64: import org.apache.cassandra.db.partitions.PartitionIterator;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:a991b64: import org.apache.cassandra.service.pager.QueryPager;
1:b99c863: import org.apache.cassandra.service.pager.PagingState;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:e48ff29: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:e48ff29: 
1:1147ee3: import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
1:e48ff29: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1:a991b64: import static org.junit.Assert.*;
1:e48ff29: 
1:e48ff29: @RunWith(OrderedJUnit4ClassRunner.class)
1:d2a3827: public class QueryPagerTest
1:362cc05: {
1:d2a3827:     public static final String KEYSPACE1 = "QueryPagerTest";
1:d2a3827:     public static final String CF_STANDARD = "Standard1";
1:d2a3827:     public static final String KEYSPACE_CQL = "cql_keyspace";
1:d2a3827:     public static final String CF_CQL = "table2";
1:9dac99f:     public static final int nowInSec = FBUtilities.nowInSeconds();
1:e48ff29: 
1:e48ff29:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:e48ff29:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD));
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE_CQL,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:d2a3827:                                     CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
1:a991b64:                                             + "k text,"
1:a991b64:                                             + "c text,"
1:a991b64:                                             + "v text,"
1:a991b64:                                             + "PRIMARY KEY (k, c))", KEYSPACE_CQL));
1:d2a3827:         addData();
1:362cc05:     }
1:362cc05: 
1:e48ff29:     private static String string(ByteBuffer bb)
1:b99c863:     {
1:e48ff29:         try
1:e48ff29:         {
1:e48ff29:             return ByteBufferUtil.string(bb);
1:e48ff29:         }
1:e48ff29:         catch (CharacterCodingException e)
1:e48ff29:         {
1:e48ff29:             throw new RuntimeException(e);
1:e48ff29:         }
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     public static void addData()
1:e48ff29:     {
1:e48ff29:         cfs().clearUnsafe();
1:e48ff29: 
1:e48ff29:         int nbKeys = 10;
1:e48ff29:         int nbCols = 10;
1:e48ff29: 
1:a991b64:         // *
1:a991b64:         // * Creates the following data:
1:a991b64:         // *   k1: c1 ... cn
1:a991b64:         // *   ...
1:a991b64:         // *   ki: c1 ... cn
1:a991b64:         // *
1:e48ff29:         for (int i = 0; i < nbKeys; i++)
1:e48ff29:         {
1:e48ff29:             for (int j = 0; j < nbCols; j++)
1:a991b64:             {
1:a991b64:                 RowUpdateBuilder builder = new RowUpdateBuilder(cfs().metadata, FBUtilities.timestampMicros(), "k" + i);
1:a991b64:                 builder.clustering("c" + j).add("val", "").build().applyUnsafe();
1:a991b64:             }
1:e48ff29:         }
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     private static ColumnFamilyStore cfs()
1:e48ff29:     {
1:d2a3827:         return Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD);
1:e48ff29:     }
1:e48ff29: 
1:a991b64:     private static List<FilteredPartition> query(QueryPager pager, int expectedSize)
1:e48ff29:     {
1:a991b64:         return query(pager, expectedSize, expectedSize);
1:e48ff29:     }
1:e48ff29: 
1:a991b64:     private static List<FilteredPartition> query(QueryPager pager, int toQuery, int expectedSize)
1:e48ff29:     {
2:e48ff29:         StringBuilder sb = new StringBuilder();
1:a991b64:         List<FilteredPartition> partitionList = new ArrayList<>();
1:a991b64:         int rows = 0;
1:557bbbc:         try (ReadExecutionController executionController = pager.executionController();
1:557bbbc:              PartitionIterator iterator = pager.fetchPageInternal(toQuery, executionController))
1:a991b64:         {
1:a991b64:             while (iterator.hasNext())
1:a991b64:             {
1:a991b64:                 try (RowIterator rowIter = iterator.next())
1:a991b64:                 {
1:a991b64:                     FilteredPartition partition = FilteredPartition.create(rowIter);
1:a991b64:                     sb.append(partition);
1:a991b64:                     partitionList.add(partition);
1:a991b64:                     rows += partition.rowCount();
1:a991b64:                 }
1:a991b64:             }
1:a991b64:         }
1:a991b64:         assertEquals(sb.toString(), expectedSize, rows);
1:a991b64:         return partitionList;
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     private static ReadCommand namesQuery(String key, String... names)
1:e48ff29:     {
1:a991b64:         AbstractReadCommandBuilder builder = Util.cmd(cfs(), key);
1:e48ff29:         for (String name : names)
1:a991b64:             builder.includeRow(name);
1:a991b64:         return builder.withPagingLimit(100).build();
1:e48ff29:     }
1:e48ff29: 
1:4beb54d:     private static SinglePartitionReadCommand sliceQuery(String key, String start, String end, int count)
1:e48ff29:     {
1:5008507:         return sliceQuery(key, start, end, false, count);
1:5008507:     }
1:5008507: 
1:4beb54d:     private static SinglePartitionReadCommand sliceQuery(String key, String start, String end, boolean reversed, int count)
1:5008507:     {
1:a991b64:         ClusteringComparator cmp = cfs().getComparator();
1:a991b64:         CFMetaData metadata = cfs().metadata;
1:a991b64: 
1:a991b64:         Slice slice = Slice.make(cmp.make(start), cmp.make(end));
1:a991b64:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.with(cmp, slice), reversed);
1:a991b64: 
1:9dac99f:         return SinglePartitionReadCommand.create(cfs().metadata, nowInSec, ColumnFilter.all(metadata), RowFilter.NONE, DataLimits.NONE, Util.dk(key), filter);
1:e48ff29:     }
1:a991b64: 
1:a991b64:     private static ReadCommand rangeNamesQuery(String keyStart, String keyEnd, int count, String... names)
1:e48ff29:     {
1:a991b64:         AbstractReadCommandBuilder builder = Util.cmd(cfs())
1:a991b64:                                                  .fromKeyExcl(keyStart)
1:a991b64:                                                  .toKeyIncl(keyEnd)
1:a991b64:                                                  .withPagingLimit(count);
1:e48ff29:         for (String name : names)
1:a991b64:             builder.includeRow(name);
1:a991b64: 
1:a991b64:         return builder.build();
1:e48ff29:     }
1:e48ff29: 
1:a991b64:     private static ReadCommand rangeSliceQuery(String keyStart, String keyEnd, int count, String start, String end)
1:e48ff29:     {
1:a991b64:         return Util.cmd(cfs())
1:a991b64:                    .fromKeyExcl(keyStart)
1:a991b64:                    .toKeyIncl(keyEnd)
1:a991b64:                    .fromIncl(start)
1:a991b64:                    .toIncl(end)
1:a991b64:                    .withPagingLimit(count)
1:a991b64:                    .build();
1:e48ff29:     }
1:e48ff29: 
1:a991b64:     private static void assertRow(FilteredPartition r, String key, String... names)
1:e48ff29:     {
1:cd2c438:         ByteBuffer[] bbs = new ByteBuffer[names.length];
1:cd2c438:         for (int i = 0; i < names.length; i++)
1:cd2c438:             bbs[i] = bytes(names[i]);
1:cd2c438:         assertRow(r, key, bbs);
1:cd2c438:     }
1:cd2c438: 
1:a991b64:     private static void assertRow(FilteredPartition partition, String key, ByteBuffer... names)
1:cd2c438:     {
1:a991b64:         assertEquals(key, string(partition.partitionKey().getKey()));
1:a991b64:         assertFalse(partition.isEmpty());
1:e48ff29:         int i = 0;
1:a991b64:         for (Row row : Util.once(partition.iterator()))
1:e48ff29:         {
1:cd2c438:             ByteBuffer expected = names[i++];
1:a991b64:             assertEquals("column " + i + " doesn't match "+string(expected)+" vs "+string(row.clustering().get(0)), expected, row.clustering().get(0));
1:e48ff29:         }
1:e48ff29:     }
1:cd2c438: 
1:e0adc16:     private QueryPager maybeRecreate(QueryPager pager, ReadQuery command, boolean testPagingState, ProtocolVersion protocolVersion)
1:e48ff29:     {
1:b99c863:         if (!testPagingState)
1:b99c863:             return pager;
1:b99c863: 
1:b99c863:         PagingState state = PagingState.deserialize(pager.state().serialize(protocolVersion), protocolVersion);
1:b99c863:         return command.getPager(state, protocolVersion);
1:b99c863:     }
1:b99c863: 
1:e48ff29:     @Test
1:9f3a7f8:     public void namesQueryTest() throws Exception
1:e48ff29:     {
1:e0adc16:         QueryPager pager = namesQuery("k0", "c1", "c5", "c7", "c8").getPager(null, ProtocolVersion.CURRENT);
1:e48ff29: 
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partition = query(pager, 5, 4);
1:a991b64:         assertRow(partition.get(0), "k0", "c1", "c5", "c7", "c8");
1:e48ff29: 
1:e48ff29:         assertTrue(pager.isExhausted());
1:e48ff29:     }
1:cd2c438: 
1:cd2c438:     @Test
1:9f3a7f8:     public void sliceQueryTest() throws Exception
1:b99c863:     {
1:e0adc16:         sliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         sliceQueryTest(true, ProtocolVersion.V4);
1:e0adc16:         sliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         sliceQueryTest(true, ProtocolVersion.V4);
1:b99c863:     }
1:b99c863: 
1:e0adc16:     public void sliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
1:e48ff29:     {
1:b99c863:         ReadCommand command = sliceQuery("k0", "c1", "c8", 10);
1:b99c863:         QueryPager pager = command.getPager(null, protocolVersion);
1:e48ff29: 
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partition = query(pager, 3);
1:a991b64:         assertRow(partition.get(0), "k0", "c1", "c2", "c3");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager, 3);
1:a991b64:         assertRow(partition.get(0), "k0", "c4", "c5", "c6");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager, 3, 2);
1:a991b64:         assertRow(partition.get(0), "k0", "c7", "c8");
1:e48ff29: 
1:e48ff29:         assertTrue(pager.isExhausted());
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     @Test
1:5008507:     public void reversedSliceQueryTest() throws Exception
1:b99c863:     {
1:e0adc16:         reversedSliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         reversedSliceQueryTest(true, ProtocolVersion.V4);
1:e0adc16:         reversedSliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         reversedSliceQueryTest(true, ProtocolVersion.V4);
1:b99c863:     }
1:b99c863: 
1:e0adc16:     public void reversedSliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
1:5008507:     {
1:b99c863:         ReadCommand command = sliceQuery("k0", "c1", "c8", true, 10);
1:b99c863:         QueryPager pager = command.getPager(null, protocolVersion);
1:5008507: 
1:5008507:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partition = query(pager, 3);
1:a991b64:         assertRow(partition.get(0), "k0", "c6", "c7", "c8");
1:b99c863:         assertFalse(pager.isExhausted());
1:5008507: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:5008507:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager, 3);
1:a991b64:         assertRow(partition.get(0), "k0", "c3", "c4", "c5");
1:b99c863:         assertFalse(pager.isExhausted());
1:5008507: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:5008507:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager, 3, 2);
1:a991b64:         assertRow(partition.get(0), "k0", "c1", "c2");
1:5008507: 
1:5008507:         assertTrue(pager.isExhausted());
1:5008507:     }
1:5008507: 
1:5008507:     @Test
1:9f3a7f8:     public void multiQueryTest() throws Exception
1:b99c863:     {
1:e0adc16:         multiQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         multiQueryTest(true, ProtocolVersion.V4);
1:e0adc16:         multiQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         multiQueryTest(true, ProtocolVersion.V4);
1:b99c863:     }
1:b99c863: 
1:e0adc16:     public void multiQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
1:e48ff29:     {
1:4beb54d:         ReadQuery command = new SinglePartitionReadCommand.Group(new ArrayList<SinglePartitionReadCommand>()
1:a991b64:         {{
1:e48ff29:             add(sliceQuery("k1", "c2", "c6", 10));
1:e48ff29:             add(sliceQuery("k4", "c3", "c5", 10));
1:b99c863:         }}, DataLimits.NONE);
1:b99c863:         QueryPager pager = command.getPager(null, protocolVersion);
1:5008507: 
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partition = query(pager, 3);
1:a991b64:         assertRow(partition.get(0), "k1", "c2", "c3", "c4");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager , 4);
1:a991b64:         assertRow(partition.get(0), "k1", "c5", "c6");
1:a991b64:         assertRow(partition.get(1), "k4", "c3", "c4");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partition = query(pager, 3, 1);
1:a991b64:         assertRow(partition.get(0), "k4", "c5");
1:e48ff29: 
1:e48ff29:         assertTrue(pager.isExhausted());
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     @Test
1:9f3a7f8:     public void rangeNamesQueryTest() throws Exception
1:b99c863:     {
1:e0adc16:         rangeNamesQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         rangeNamesQueryTest(true, ProtocolVersion.V4);
1:e0adc16:         rangeNamesQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         rangeNamesQueryTest(true, ProtocolVersion.V4);
1:b99c863:     }
1:b99c863: 
1:e0adc16:     public void rangeNamesQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
1:e48ff29:     {
1:b99c863:         ReadCommand command = rangeNamesQuery("k0", "k5", 100, "c1", "c4", "c8");
1:b99c863:         QueryPager pager = command.getPager(null, protocolVersion);
1:e48ff29: 
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partitions = query(pager, 3 * 3);
1:e48ff29:         for (int i = 1; i <= 3; i++)
1:a991b64:             assertRow(partitions.get(i-1), "k" + i, "c1", "c4", "c8");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 3 * 3, 2 * 3);
1:e48ff29:         for (int i = 4; i <= 5; i++)
1:a991b64:             assertRow(partitions.get(i-4), "k" + i, "c1", "c4", "c8");
1:e48ff29: 
1:e48ff29:         assertTrue(pager.isExhausted());
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     @Test
1:9f3a7f8:     public void rangeSliceQueryTest() throws Exception
1:b99c863:     {
1:e0adc16:         rangeSliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         rangeSliceQueryTest(true, ProtocolVersion.V4);
1:e0adc16:         rangeSliceQueryTest(false, ProtocolVersion.V3);
1:e0adc16:         rangeSliceQueryTest(true, ProtocolVersion.V4);
1:b99c863:     }
1:b99c863: 
1:e0adc16:     public void rangeSliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
1:e48ff29:     {
1:b99c863:         ReadCommand command = rangeSliceQuery("k1", "k5", 100, "c1", "c7");
1:b99c863:         QueryPager pager = command.getPager(null, protocolVersion);
1:e48ff29: 
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         List<FilteredPartition> partitions = query(pager, 5);
1:a991b64:         assertRow(partitions.get(0), "k2", "c1", "c2", "c3", "c4", "c5");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 4);
1:a991b64:         assertRow(partitions.get(0), "k2", "c6", "c7");
1:a991b64:         assertRow(partitions.get(1), "k3", "c1", "c2");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 6);
1:a991b64:         assertRow(partitions.get(0), "k3", "c3", "c4", "c5", "c6", "c7");
1:a991b64:         assertRow(partitions.get(1), "k4", "c1");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 5);
1:a991b64:         assertRow(partitions.get(0), "k4", "c2", "c3", "c4", "c5", "c6");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 5);
1:a991b64:         assertRow(partitions.get(0), "k4", "c7");
1:a991b64:         assertRow(partitions.get(1), "k5", "c1", "c2", "c3", "c4");
1:b99c863:         assertFalse(pager.isExhausted());
1:e48ff29: 
1:b99c863:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:e48ff29:         assertFalse(pager.isExhausted());
1:a991b64:         partitions = query(pager, 5, 3);
1:a991b64:         assertRow(partitions.get(0), "k5", "c5", "c6", "c7");
1:a991b64: 
1:e48ff29:         assertTrue(pager.isExhausted());
1:e48ff29:     }
1:e48ff29: 
1:e48ff29:     @Test
1:cd2c438:     public void SliceQueryWithTombstoneTest() throws Exception
1:cd2c438:     {
1:cd2c438:         // Testing for the bug of #6748
1:cd2c438:         String keyspace = "cql_keyspace";
1:cd2c438:         String table = "table2";
1:cd2c438:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:cd2c438: 
1:cd2c438:         // Insert rows but with a tombstone as last cell
1:cd2c438:         for (int i = 0; i < 5; i++)
1:1147ee3:             executeInternal(String.format("INSERT INTO %s.%s (k, c, v) VALUES ('k%d', 'c%d', null)", keyspace, table, 0, i));
1:a991b64: 
1:9dac99f:         ReadCommand command = SinglePartitionReadCommand.create(cfs.metadata, nowInSec, Util.dk("k0"), Slice.ALL);
1:cd2c438: 
1:e0adc16:         QueryPager pager = command.getPager(null, ProtocolVersion.CURRENT);
1:cd2c438: 
1:cd2c438:         for (int i = 0; i < 5; i++)
1:cd2c438:         {
1:a991b64:             List<FilteredPartition> partitions = query(pager, 1);
1:cd2c438:             // The only live cell we should have each time is the row marker
1:a991b64:             assertRow(partitions.get(0), "k0", "c" + i);
1:cd2c438:         }
1:cd2c438:     }
1:e48ff29: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:     private QueryPager maybeRecreate(QueryPager pager, ReadQuery command, boolean testPagingState, ProtocolVersion protocolVersion)
/////////////////////////////////////////////////////////////////////////
1:         QueryPager pager = namesQuery("k0", "c1", "c5", "c7", "c8").getPager(null, ProtocolVersion.CURRENT);
/////////////////////////////////////////////////////////////////////////
1:         sliceQueryTest(false, ProtocolVersion.V3);
1:         sliceQueryTest(true, ProtocolVersion.V4);
1:         sliceQueryTest(false, ProtocolVersion.V3);
1:         sliceQueryTest(true, ProtocolVersion.V4);
1:     public void sliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         reversedSliceQueryTest(false, ProtocolVersion.V3);
1:         reversedSliceQueryTest(true, ProtocolVersion.V4);
1:         reversedSliceQueryTest(false, ProtocolVersion.V3);
1:         reversedSliceQueryTest(true, ProtocolVersion.V4);
1:     public void reversedSliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         multiQueryTest(false, ProtocolVersion.V3);
1:         multiQueryTest(true, ProtocolVersion.V4);
1:         multiQueryTest(false, ProtocolVersion.V3);
1:         multiQueryTest(true, ProtocolVersion.V4);
1:     public void multiQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         rangeNamesQueryTest(false, ProtocolVersion.V3);
1:         rangeNamesQueryTest(true, ProtocolVersion.V4);
1:         rangeNamesQueryTest(false, ProtocolVersion.V3);
1:         rangeNamesQueryTest(true, ProtocolVersion.V4);
1:     public void rangeNamesQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         rangeSliceQueryTest(false, ProtocolVersion.V3);
1:         rangeSliceQueryTest(true, ProtocolVersion.V4);
1:         rangeSliceQueryTest(false, ProtocolVersion.V3);
1:         rangeSliceQueryTest(true, ProtocolVersion.V4);
1:     public void rangeSliceQueryTest(boolean testPagingState, ProtocolVersion protocolVersion) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         QueryPager pager = command.getPager(null, ProtocolVersion.CURRENT);
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
1:         try (ReadExecutionController executionController = pager.executionController();
1:              PartitionIterator iterator = pager.fetchPageInternal(toQuery, executionController))
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:ba14431
commit:b1f2d14
commit:4beb54d
/////////////////////////////////////////////////////////////////////////
1:     private static SinglePartitionReadCommand sliceQuery(String key, String start, String end, int count)
1:     private static SinglePartitionReadCommand sliceQuery(String key, String start, String end, boolean reversed, int count)
/////////////////////////////////////////////////////////////////////////
0:         return SinglePartitionReadCommand.create(cfs().metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(metadata), RowFilter.NONE, DataLimits.NONE, Util.dk(key), filter);
/////////////////////////////////////////////////////////////////////////
1:         ReadQuery command = new SinglePartitionReadCommand.Group(new ArrayList<SinglePartitionReadCommand>()
/////////////////////////////////////////////////////////////////////////
0:         ReadCommand command = SinglePartitionReadCommand.create(cfs.metadata, FBUtilities.nowInSeconds(), Util.dk("k0"), Slice.ALL);
commit:b99c863
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.service.pager.PagingState;
0: import org.apache.cassandra.transport.Server;
/////////////////////////////////////////////////////////////////////////
0:     private QueryPager maybeRecreate(QueryPager pager, ReadQuery command, boolean testPagingState, int protocolVersion)
1:     {
1:         if (!testPagingState)
1:             return pager;
1: 
1:         PagingState state = PagingState.deserialize(pager.state().serialize(protocolVersion), protocolVersion);
1:         return command.getPager(state, protocolVersion);
1:     }
1: 
0:         QueryPager pager = namesQuery("k0", "c1", "c5", "c7", "c8").getPager(null, Server.CURRENT_VERSION);
/////////////////////////////////////////////////////////////////////////
0:         sliceQueryTest(false, Server.VERSION_3);
0:         sliceQueryTest(true, Server.VERSION_4);
0:         sliceQueryTest(false, Server.VERSION_3);
0:         sliceQueryTest(true, Server.VERSION_4);
1:     }
1: 
0:     public void sliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
1:     {
1:         ReadCommand command = sliceQuery("k0", "c1", "c8", 10);
1:         QueryPager pager = command.getPager(null, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
/////////////////////////////////////////////////////////////////////////
0:         reversedSliceQueryTest(false, Server.VERSION_3);
0:         reversedSliceQueryTest(true, Server.VERSION_4);
0:         reversedSliceQueryTest(false, Server.VERSION_3);
0:         reversedSliceQueryTest(true, Server.VERSION_4);
1:     }
1: 
0:     public void reversedSliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
1:     {
1:         ReadCommand command = sliceQuery("k0", "c1", "c8", true, 10);
1:         QueryPager pager = command.getPager(null, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
/////////////////////////////////////////////////////////////////////////
0:         multiQueryTest(false, Server.VERSION_3);
0:         multiQueryTest(true, Server.VERSION_4);
0:         multiQueryTest(false, Server.VERSION_3);
0:         multiQueryTest(true, Server.VERSION_4);
1:     }
1: 
0:     public void multiQueryTest(boolean testPagingState, int protocolVersion) throws Exception
1:     {
0:         ReadQuery command = new SinglePartitionReadCommand.Group(new ArrayList<SinglePartitionReadCommand<?>>()
1:         }}, DataLimits.NONE);
1:         QueryPager pager = command.getPager(null, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
/////////////////////////////////////////////////////////////////////////
0:         rangeNamesQueryTest(false, Server.VERSION_3);
0:         rangeNamesQueryTest(true, Server.VERSION_4);
0:         rangeNamesQueryTest(false, Server.VERSION_3);
0:         rangeNamesQueryTest(true, Server.VERSION_4);
1:     }
1: 
0:     public void rangeNamesQueryTest(boolean testPagingState, int protocolVersion) throws Exception
1:     {
1:         ReadCommand command = rangeNamesQuery("k0", "k5", 100, "c1", "c4", "c8");
1:         QueryPager pager = command.getPager(null, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
/////////////////////////////////////////////////////////////////////////
0:         rangeSliceQueryTest(false, Server.VERSION_3);
0:         rangeSliceQueryTest(true, Server.VERSION_4);
0:         rangeSliceQueryTest(false, Server.VERSION_3);
0:         rangeSliceQueryTest(true, Server.VERSION_4);
1:     }
1: 
0:     public void rangeSliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
1:     {
1:         ReadCommand command = rangeSliceQuery("k1", "k5", 100, "c1", "c7");
1:         QueryPager pager = command.getPager(null, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
1:         assertFalse(pager.isExhausted());
1:         pager = maybeRecreate(pager, command, testPagingState, protocolVersion);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = command.getPager(null, Server.CURRENT_VERSION);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: import org.apache.cassandra.*;
1: import org.apache.cassandra.db.rows.Row;
1: import org.apache.cassandra.db.rows.RowIterator;
1: import org.apache.cassandra.db.partitions.FilteredPartition;
1: import org.apache.cassandra.db.partitions.PartitionIterator;
1: import org.apache.cassandra.service.pager.QueryPager;
1: import org.apache.cassandra.utils.FBUtilities;
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1:                                             + "k text,"
1:                                             + "c text,"
1:                                             + "v text,"
1:                                             + "PRIMARY KEY (k, c))", KEYSPACE_CQL));
/////////////////////////////////////////////////////////////////////////
1:         // *
1:         // * Creates the following data:
1:         // *   k1: c1 ... cn
1:         // *   ...
1:         // *   ki: c1 ... cn
1:         // *
1:             {
1:                 RowUpdateBuilder builder = new RowUpdateBuilder(cfs().metadata, FBUtilities.timestampMicros(), "k" + i);
1:                 builder.clustering("c" + j).add("val", "").build().applyUnsafe();
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private static List<FilteredPartition> query(QueryPager pager, int expectedSize)
1:         return query(pager, expectedSize, expectedSize);
1:     private static List<FilteredPartition> query(QueryPager pager, int toQuery, int expectedSize)
1:         List<FilteredPartition> partitionList = new ArrayList<>();
1:         int rows = 0;
0:         try (ReadOrderGroup orderGroup = pager.startOrderGroup(); PartitionIterator iterator = pager.fetchPageInternal(toQuery, orderGroup))
1:         {
1:             while (iterator.hasNext())
1:             {
1:                 try (RowIterator rowIter = iterator.next())
1:                 {
1:                     FilteredPartition partition = FilteredPartition.create(rowIter);
1:                     sb.append(partition);
1:                     partitionList.add(partition);
1:                     rows += partition.rowCount();
1:                 }
1:             }
1:         }
1:         assertEquals(sb.toString(), expectedSize, rows);
1:         return partitionList;
1:         AbstractReadCommandBuilder builder = Util.cmd(cfs(), key);
1:             builder.includeRow(name);
1:         return builder.withPagingLimit(100).build();
0:     private static SinglePartitionSliceCommand sliceQuery(String key, String start, String end, int count)
0:     private static SinglePartitionSliceCommand sliceQuery(String key, String start, String end, boolean reversed, int count)
1:         ClusteringComparator cmp = cfs().getComparator();
1:         CFMetaData metadata = cfs().metadata;
1: 
1:         Slice slice = Slice.make(cmp.make(start), cmp.make(end));
1:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.with(cmp, slice), reversed);
1: 
0:         SinglePartitionSliceCommand command = new SinglePartitionSliceCommand(cfs().metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(metadata), RowFilter.NONE, DataLimits.NONE, Util.dk(key), filter);
1: 
0:         return command;
1:     private static ReadCommand rangeNamesQuery(String keyStart, String keyEnd, int count, String... names)
1:         AbstractReadCommandBuilder builder = Util.cmd(cfs())
1:                                                  .fromKeyExcl(keyStart)
1:                                                  .toKeyIncl(keyEnd)
1:                                                  .withPagingLimit(count);
1:             builder.includeRow(name);
1: 
1:         return builder.build();
1:     private static ReadCommand rangeSliceQuery(String keyStart, String keyEnd, int count, String start, String end)
1:         return Util.cmd(cfs())
1:                    .fromKeyExcl(keyStart)
1:                    .toKeyIncl(keyEnd)
1:                    .fromIncl(start)
1:                    .toIncl(end)
1:                    .withPagingLimit(count)
1:                    .build();
1:     private static void assertRow(FilteredPartition r, String key, String... names)
/////////////////////////////////////////////////////////////////////////
1:     private static void assertRow(FilteredPartition partition, String key, ByteBuffer... names)
1:         assertEquals(key, string(partition.partitionKey().getKey()));
1:         assertFalse(partition.isEmpty());
1:         for (Row row : Util.once(partition.iterator()))
1:             assertEquals("column " + i + " doesn't match "+string(expected)+" vs "+string(row.clustering().get(0)), expected, row.clustering().get(0));
0:         QueryPager pager = namesQuery("k0", "c1", "c5", "c7", "c8").getPager(null);
1:         List<FilteredPartition> partition = query(pager, 5, 4);
1:         assertRow(partition.get(0), "k0", "c1", "c5", "c7", "c8");
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = sliceQuery("k0", "c1", "c8", 10).getPager(null);
1:         List<FilteredPartition> partition = query(pager, 3);
1:         assertRow(partition.get(0), "k0", "c1", "c2", "c3");
1:         partition = query(pager, 3);
1:         assertRow(partition.get(0), "k0", "c4", "c5", "c6");
1:         partition = query(pager, 3, 2);
1:         assertRow(partition.get(0), "k0", "c7", "c8");
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = sliceQuery("k0", "c1", "c8", true, 10).getPager(null);
1:         List<FilteredPartition> partition = query(pager, 3);
1:         assertRow(partition.get(0), "k0", "c6", "c7", "c8");
1:         partition = query(pager, 3);
1:         assertRow(partition.get(0), "k0", "c3", "c4", "c5");
1:         partition = query(pager, 3, 2);
1:         assertRow(partition.get(0), "k0", "c1", "c2");
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = new SinglePartitionReadCommand.Group(new ArrayList<SinglePartitionReadCommand<?>>()
1:         {{
0:         }}, DataLimits.NONE).getPager(null);
1:         List<FilteredPartition> partition = query(pager, 3);
1:         assertRow(partition.get(0), "k1", "c2", "c3", "c4");
1:         partition = query(pager , 4);
1:         assertRow(partition.get(0), "k1", "c5", "c6");
1:         assertRow(partition.get(1), "k4", "c3", "c4");
1:         partition = query(pager, 3, 1);
1:         assertRow(partition.get(0), "k4", "c5");
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = rangeNamesQuery("k0", "k5", 100, "c1", "c4", "c8").getPager(null);
1:         List<FilteredPartition> partitions = query(pager, 3 * 3);
1:             assertRow(partitions.get(i-1), "k" + i, "c1", "c4", "c8");
1:         partitions = query(pager, 3 * 3, 2 * 3);
1:             assertRow(partitions.get(i-4), "k" + i, "c1", "c4", "c8");
/////////////////////////////////////////////////////////////////////////
0:         QueryPager pager = rangeSliceQuery("k1", "k5", 100, "c1", "c7").getPager(null);
1:         List<FilteredPartition> partitions = query(pager, 5);
1:         assertRow(partitions.get(0), "k2", "c1", "c2", "c3", "c4", "c5");
1:         partitions = query(pager, 4);
1:         assertRow(partitions.get(0), "k2", "c6", "c7");
1:         assertRow(partitions.get(1), "k3", "c1", "c2");
1:         partitions = query(pager, 6);
1:         assertRow(partitions.get(0), "k3", "c3", "c4", "c5", "c6", "c7");
1:         assertRow(partitions.get(1), "k4", "c1");
1:         partitions = query(pager, 5);
1:         assertRow(partitions.get(0), "k4", "c2", "c3", "c4", "c5", "c6");
1:         partitions = query(pager, 5);
1:         assertRow(partitions.get(0), "k4", "c7");
1:         assertRow(partitions.get(1), "k5", "c1", "c2", "c3", "c4");
1:         partitions = query(pager, 5, 3);
1:         assertRow(partitions.get(0), "k5", "c5", "c6", "c7");
1: 
/////////////////////////////////////////////////////////////////////////
0:         ReadCommand command = SinglePartitionSliceCommand.create(cfs.metadata, FBUtilities.nowInSeconds(), Util.dk("k0"), Slice.ALL);
1: 
0:         QueryPager pager = command.getPager(null);
1:             List<FilteredPartition> partitions = query(pager, 1);
1:             assertRow(partitions.get(0), "k0", "c" + i);
commit:9616a88
commit:7c6993f
commit:6218993
/////////////////////////////////////////////////////////////////////////
0:         }}, 10));
commit:1147ee3
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
/////////////////////////////////////////////////////////////////////////
1:             executeInternal(String.format("INSERT INTO %s.%s (k, c, v) VALUES ('k%d', 'c%d', null)", keyspace, table, 0, i));
commit:e0857f2
/////////////////////////////////////////////////////////////////////////
0:             assertEquals("column " + i + " doesn't match: " + toString(r.cf), expected, c.name().toByteBuffer());
/////////////////////////////////////////////////////////////////////////
0:         CompositeType ct = (CompositeType)cfs.metadata.comparator.asAbstractType();
commit:3d93053
commit:cd2c438
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import static org.apache.cassandra.cql3.QueryProcessor.processInternal;
/////////////////////////////////////////////////////////////////////////
1:         ByteBuffer[] bbs = new ByteBuffer[names.length];
1:         for (int i = 0; i < names.length; i++)
1:             bbs[i] = bytes(names[i]);
1:         assertRow(r, key, bbs);
1:     }
1: 
0:     private static void assertRow(Row r, String key, ByteBuffer... names)
1:     {
0:             // Ignore deleted cells if we have them
0:             if (!c.isLive(0))
0:                 continue;
1: 
1:             ByteBuffer expected = names[i++];
0:             assertEquals("column " + i + " doesn't match: " + toString(r.cf), expected, c.name());
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void SliceQueryWithTombstoneTest() throws Exception
1:     {
1:         // Testing for the bug of #6748
1:         String keyspace = "cql_keyspace";
1:         String table = "table2";
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0:         CompositeType ct = (CompositeType)cfs.metadata.comparator;
1: 
1:         // Insert rows but with a tombstone as last cell
1:         for (int i = 0; i < 5; i++)
0:             processInternal(String.format("INSERT INTO %s.%s (k, c, v) VALUES ('k%d', 'c%d', null)", keyspace, table, 0, i));
1: 
0:         SliceQueryFilter filter = new SliceQueryFilter(ColumnSlice.ALL_COLUMNS_ARRAY, false, 100);
0:         QueryPager pager = QueryPagers.localPager(new SliceFromReadCommand(keyspace, bytes("k0"), table, 0, filter));
1: 
1:         for (int i = 0; i < 5; i++)
1:         {
0:             List<Row> page = pager.fetchPage(1);
0:             assertEquals(toString(page), 1, page.size());
1:             // The only live cell we should have each time is the row marker
0:             assertRow(page.get(0), "k0", ct.decompose("c" + i, ""));
1:         }
1:     }
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf)
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : r.cf)
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.*;
/////////////////////////////////////////////////////////////////////////
0:     private static String string(CellName name)
1:     {
0:         return string(name.toByteBuffer());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         SortedSet<CellName> s = new TreeSet<CellName>(cfs().metadata.comparator);
0:             s.add(CellNames.simpleDense(bytes(name)));
/////////////////////////////////////////////////////////////////////////
0:         SliceQueryFilter filter = new SliceQueryFilter(CellNames.simpleDense(bytes(start)), CellNames.simpleDense(bytes(end)), reversed, count);
0:         SortedSet<CellName> s = new TreeSet<CellName>(cfs().metadata.comparator);
0:             s.add(CellNames.simpleDense(bytes(name)));
0:         SliceQueryFilter filter = new SliceQueryFilter(CellNames.simpleDense(bytes(start)), CellNames.simpleDense(bytes(end)), false, Integer.MAX_VALUE);
commit:5008507
/////////////////////////////////////////////////////////////////////////
1:         return sliceQuery(key, start, end, false, count);
1:     }
1: 
0:     private static ReadCommand sliceQuery(String key, String start, String end, boolean reversed, int count)
1:     {
0:         SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), reversed, count);
/////////////////////////////////////////////////////////////////////////
1:     public void reversedSliceQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(sliceQuery("k0", "c8", "c1", true, 10));
1: 
0:         List<Row> page;
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c6", "c7", "c8");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c3", "c4", "c5");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c1", "c2");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: 
1:     @Test
commit:c284786
/////////////////////////////////////////////////////////////////////////
0:         // Note: for MultiQueryTest, we need the same timestamp/expireBefore for all queries, so we just use 0 as it doesn't matter here.
0:         return new SliceFromReadCommand(KS, bytes(key), CF, 0, filter);
commit:e48ff29
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.service;
1: 
0: import java.util.*;
1: import java.nio.ByteBuffer;
1: import java.nio.charset.CharacterCodingException;
1: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: 
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.SchemaLoader;
0: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.db.filter.*;
0: import org.apache.cassandra.dht.*;
0: import org.apache.cassandra.service.pager.*;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: import static junit.framework.Assert.*;
0: import static org.apache.cassandra.Util.bounds;
0: import static org.apache.cassandra.Util.range;
1: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1: 
1: @RunWith(OrderedJUnit4ClassRunner.class)
0: public class QueryPagerTest extends SchemaLoader
1: {
0:     private static final String KS = "Keyspace1";
0:     private static final String CF = "Standard1";
1: 
1:     private static String string(ByteBuffer bb)
1:     {
1:         try
1:         {
1:             return ByteBufferUtil.string(bb);
1:         }
1:         catch (CharacterCodingException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     @BeforeClass
1:     public static void addData()
1:     {
1:         cfs().clearUnsafe();
1: 
1:         int nbKeys = 10;
1:         int nbCols = 10;
1: 
1:         /*
0:          * Creates the following data:
0:          *   k1: c1 ... cn
0:          *   ...
0:          *   ki: c1 ... cn
1:          */
1:         for (int i = 0; i < nbKeys; i++)
1:         {
0:             RowMutation rm = new RowMutation(KS, bytes("k" + i));
0:             ColumnFamily cf = rm.addOrGet(CF);
1: 
1:             for (int j = 0; j < nbCols; j++)
0:                 cf.addColumn(Util.column("c" + j, "", 0));
1: 
0:             rm.applyUnsafe();
1:         }
1:     }
1: 
1:     private static ColumnFamilyStore cfs()
1:     {
0:         return Table.open(KS).getColumnFamilyStore(CF);
1:     }
1: 
0:     private static String toString(List<Row> rows)
1:     {
1:         StringBuilder sb = new StringBuilder();
0:         for (Row row : rows)
0:             sb.append(string(row.key.key)).append(":").append(toString(row.cf)).append("\n");
0:         return sb.toString();
1:     }
1: 
0:     private static String toString(ColumnFamily cf)
1:     {
0:         if (cf == null)
0:             return "";
1: 
1:         StringBuilder sb = new StringBuilder();
0:         for (Column c : cf)
0:             sb.append(" ").append(string(c.name()));
0:         return sb.toString();
1:     }
1: 
1:     private static ReadCommand namesQuery(String key, String... names)
1:     {
0:         SortedSet<ByteBuffer> s = new TreeSet<ByteBuffer>(cfs().metadata.comparator);
1:         for (String name : names)
0:             s.add(bytes(name));
0:         return new SliceByNamesReadCommand(KS, bytes(key), CF, System.currentTimeMillis(), new NamesQueryFilter(s, true));
1:     }
1: 
0:     private static ReadCommand sliceQuery(String key, String start, String end, int count)
1:     {
0:         SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), false, count);
0:         return new SliceFromReadCommand(KS, bytes(key), CF, System.currentTimeMillis(), filter);
1:     }
1: 
0:     private static RangeSliceCommand rangeNamesQuery(AbstractBounds<RowPosition> range, int count, String... names)
1:     {
0:         SortedSet<ByteBuffer> s = new TreeSet<ByteBuffer>(cfs().metadata.comparator);
1:         for (String name : names)
0:             s.add(bytes(name));
0:         return new RangeSliceCommand(KS, CF, System.currentTimeMillis(), new NamesQueryFilter(s, true), range, count);
1:     }
1: 
0:     private static RangeSliceCommand rangeSliceQuery(AbstractBounds<RowPosition> range, int count, String start, String end)
1:     {
0:         SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), false, Integer.MAX_VALUE);
0:         return new RangeSliceCommand(KS, CF, System.currentTimeMillis(), filter, range, count);
1:     }
1: 
0:     private static void assertRow(Row r, String key, String... names)
1:     {
0:         assertEquals(key, string(r.key.key));
0:         assertNotNull(r.cf);
0:         assertEquals(toString(r.cf), names.length, r.cf.getColumnCount());
1:         int i = 0;
0:         for (Column c : r.cf)
1:         {
0:             String expected = names[i++];
0:             assertEquals("column " + i + " doesn't match: " + toString(r.cf), expected, string(c.name()));
1:         }
1:     }
1: 
1:     @Test
0:     public void NamesQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(namesQuery("k0", "c1", "c5", "c7", "c8"));
1: 
1:         assertFalse(pager.isExhausted());
0:         List<Row> page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c1", "c5", "c7", "c8");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: 
1:     @Test
0:     public void SliceQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(sliceQuery("k0", "c1", "c8", 10));
1: 
0:         List<Row> page;
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c1", "c2", "c3");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c4", "c5", "c6");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k0", "c7", "c8");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: 
1:     @Test
0:     public void MultiQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(new Pageable.ReadCommands(new ArrayList<ReadCommand>() {{
1:             add(sliceQuery("k1", "c2", "c6", 10));
1:             add(sliceQuery("k4", "c3", "c5", 10));
0:         }}));
1: 
0:         List<Row> page;
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k1", "c2", "c3", "c4");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(4);
0:         assertEquals(toString(page), 2, page.size());
0:         assertRow(page.get(0), "k1", "c5", "c6");
0:         assertRow(page.get(1), "k4", "c3", "c4");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k4", "c5");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: 
1:     @Test
0:     public void RangeNamesQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(rangeNamesQuery(range("k0", "k5"), 100, "c1", "c4", "c8"));
1: 
0:         List<Row> page;
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 3, page.size());
1:         for (int i = 1; i <= 3; i++)
0:             assertRow(page.get(i-1), "k" + i, "c1", "c4", "c8");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(3);
0:         assertEquals(toString(page), 2, page.size());
1:         for (int i = 4; i <= 5; i++)
0:             assertRow(page.get(i-4), "k" + i, "c1", "c4", "c8");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: 
1:     @Test
0:     public void RangeSliceQueryTest() throws Exception
1:     {
0:         QueryPager pager = QueryPagers.localPager(rangeSliceQuery(range("k1", "k5"), 100, "c1", "c7"));
1: 
0:         List<Row> page;
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(5);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k2", "c1", "c2", "c3", "c4", "c5");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(4);
0:         assertEquals(toString(page), 2, page.size());
0:         assertRow(page.get(0), "k2", "c6", "c7");
0:         assertRow(page.get(1), "k3", "c1", "c2");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(6);
0:         assertEquals(toString(page), 2, page.size());
0:         assertRow(page.get(0), "k3", "c3", "c4", "c5", "c6", "c7");
0:         assertRow(page.get(1), "k4", "c1");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(5);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k4", "c2", "c3", "c4", "c5", "c6");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(5);
0:         assertEquals(toString(page), 2, page.size());
0:         assertRow(page.get(0), "k4", "c7");
0:         assertRow(page.get(1), "k5", "c1", "c2", "c3", "c4");
1: 
1:         assertFalse(pager.isExhausted());
0:         page = pager.fetchPage(5);
0:         assertEquals(toString(page), 1, page.size());
0:         assertRow(page.get(0), "k5", "c5", "c6", "c7");
1: 
1:         assertTrue(pager.isExhausted());
1:     }
1: }
author:Joel Knighton
-------------------------------------------------------------------------------
commit:9dac99f
/////////////////////////////////////////////////////////////////////////
1:     public static final int nowInSec = FBUtilities.nowInSeconds();
/////////////////////////////////////////////////////////////////////////
1:         return SinglePartitionReadCommand.create(cfs().metadata, nowInSec, ColumnFilter.all(metadata), RowFilter.NONE, DataLimits.NONE, Util.dk(key), filter);
/////////////////////////////////////////////////////////////////////////
1:         ReadCommand command = SinglePartitionReadCommand.create(cfs.metadata, nowInSec, Util.dk("k0"), Slice.ALL);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
1:                                     KeyspaceParams.simple(1),
commit:4485e6d
/////////////////////////////////////////////////////////////////////////
0:             if (!c.isLive())
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation(KS, bytes("k" + i));
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         return Keyspace.open(KS).getColumnFamilyStore(CF);
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
1: public class QueryPagerTest
1:     public static final String KEYSPACE1 = "QueryPagerTest";
1:     public static final String CF_STANDARD = "Standard1";
1:     public static final String KEYSPACE_CQL = "cql_keyspace";
1:     public static final String CF_CQL = "table2";
0: 
0:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
0:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD));
1:         SchemaLoader.createKeyspace(KEYSPACE_CQL,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     CFMetaData.compile("CREATE TABLE " + CF_CQL + " ("
0:                                                      + "k text,"
0:                                                      + "c text,"
0:                                                      + "v text,"
0:                                                      + "PRIMARY KEY (k, c))", KEYSPACE_CQL));
1:         addData();
0:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation(KEYSPACE1, bytes("k" + i));
0:             ColumnFamily cf = rm.addOrGet(CF_STANDARD);
/////////////////////////////////////////////////////////////////////////
1:         return Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD);
/////////////////////////////////////////////////////////////////////////
0:         return new SliceByNamesReadCommand(KEYSPACE1, bytes(key), CF_STANDARD, System.currentTimeMillis(), new NamesQueryFilter(s, true));
/////////////////////////////////////////////////////////////////////////
0:         return new SliceFromReadCommand(KEYSPACE1, bytes(key), CF_STANDARD, 0, filter);
/////////////////////////////////////////////////////////////////////////
0:         return new RangeSliceCommand(KEYSPACE1, CF_STANDARD, System.currentTimeMillis(), new NamesQueryFilter(s, true), range, count);
0:         return new RangeSliceCommand(KEYSPACE1, CF_STANDARD, System.currentTimeMillis(), filter, range, count);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:             sb.append(string(row.key.getKey())).append(":").append(toString(row.cf)).append("\n");
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(key, string(r.key.getKey()));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9f3a7f8
/////////////////////////////////////////////////////////////////////////
1:     public void namesQueryTest() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     public void sliceQueryTest() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     public void multiQueryTest() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     public void rangeNamesQueryTest() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     public void rangeSliceQueryTest() throws Exception
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
============================================================================