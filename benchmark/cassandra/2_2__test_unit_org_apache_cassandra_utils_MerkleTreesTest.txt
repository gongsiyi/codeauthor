1:0dd50a6: /*
1:0dd50a6: * Licensed to the Apache Software Foundation (ASF) under one
1:0dd50a6: * or more contributor license agreements.  See the NOTICE file
1:0dd50a6: * distributed with this work for additional information
1:0dd50a6: * regarding copyten ownership.  The ASF licenses this file
1:0dd50a6: * to you under the Apache License, Version 2.0 (the
1:0dd50a6: * "License"); you may not use this file except in compliance
1:0dd50a6: * with the License.  You may obtain a copy of the License at
1:0dd50a6: *
1:0dd50a6: *    http://www.apache.org/licenses/LICENSE-2.0
1:0dd50a6: *
1:0dd50a6: * Unless required by applicable law or agreed to in writing,
1:0dd50a6: * software distributed under the License is distributed on an
1:0dd50a6: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:0dd50a6: * KIND, either express or implied.  See the License for the
1:0dd50a6: * specific language governing permissions and limitations
1:0dd50a6: * under the License.
1:0dd50a6: */
1:0dd50a6: package org.apache.cassandra.utils;
1:0dd50a6: 
1:0dd50a6: import java.math.BigInteger;
1:0dd50a6: import java.util.*;
1:0dd50a6: 
1:0dd50a6: import com.google.common.collect.AbstractIterator;
1:0dd50a6: 
1:0dd50a6: import org.junit.Before;
1:0dd50a6: import org.junit.BeforeClass;
1:0dd50a6: import org.junit.Test;
1:9797511: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:0dd50a6: import org.apache.cassandra.dht.*;
1:0dd50a6: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:0dd50a6: import org.apache.cassandra.io.util.DataInputBuffer;
1:0dd50a6: import org.apache.cassandra.io.util.DataOutputBuffer;
1:0dd50a6: import org.apache.cassandra.net.MessagingService;
1:0dd50a6: import org.apache.cassandra.service.StorageService;
1:0dd50a6: import org.apache.cassandra.utils.MerkleTree.Hashable;
1:0dd50a6: import org.apache.cassandra.utils.MerkleTree.RowHash;
1:0dd50a6: import org.apache.cassandra.utils.MerkleTree.TreeRange;
1:0dd50a6: import org.apache.cassandra.utils.MerkleTrees.TreeRangeIterator;
1:0dd50a6: 
1:0dd50a6: import static org.junit.Assert.*;
1:0dd50a6: 
1:0dd50a6: public class MerkleTreesTest
1:0dd50a6: {
1:0dd50a6:     public static byte[] DUMMY = "blah".getBytes();
1:0dd50a6: 
1:0dd50a6:     /**
1:0dd50a6:      * If a test assumes that the tree is 8 units wide, then it should set this value
1:0dd50a6:      * to 8.
1:0dd50a6:      */
1:0dd50a6:     public static BigInteger TOKEN_SCALE = new BigInteger("8");
1:0dd50a6: 
1:0dd50a6:     protected static final IPartitioner partitioner = RandomPartitioner.instance;
1:0dd50a6:     protected MerkleTrees mts;
1:0dd50a6: 
1:0dd50a6:     private Range<Token> fullRange()
1:0dd50a6:     {
1:0dd50a6:         return new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @BeforeClass
1:0dd50a6:     public static void setUp()
1:0dd50a6:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:0dd50a6:         StorageService.instance.setPartitionerUnsafe(partitioner);
1:0dd50a6:     }
1:0dd50a6:     @Before
1:0dd50a6:     public void clear()
1:0dd50a6:     {
1:0dd50a6:         TOKEN_SCALE = new BigInteger("8");
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6:         mts.addMerkleTree(Integer.MAX_VALUE, fullRange());
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     public static void assertHashEquals(final byte[] left, final byte[] right)
1:0dd50a6:     {
1:0dd50a6:         assertHashEquals("", left, right);
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     public static void assertHashEquals(String message, final byte[] left, final byte[] right)
1:0dd50a6:     {
1:0dd50a6:         String lstring = left == null ? "null" : Hex.bytesToHex(left);
1:0dd50a6:         String rstring = right == null ? "null" : Hex.bytesToHex(right);
1:0dd50a6:         assertEquals(message, lstring, rstring);
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     /**
1:0dd50a6:      * The value returned by this method is affected by TOKEN_SCALE: setting TOKEN_SCALE
1:0dd50a6:      * to 8 means that passing -1 through 8 for this method will return values mapped
1:0dd50a6:      * between -1 and Token.MAX_VALUE.
1:0dd50a6:      */
1:0dd50a6:     public static Token tok(int i)
1:0dd50a6:     {
1:0dd50a6:         if (i == -1)
1:0dd50a6:             return new BigIntegerToken(new BigInteger("-1"));
1:0dd50a6:         BigInteger bint = RandomPartitioner.MAXIMUM.divide(TOKEN_SCALE).multiply(new BigInteger(""+i));
1:0dd50a6:         return new BigIntegerToken(bint);
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testIntersectingRanges()
1:0dd50a6:     {
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6: 
1:0dd50a6:         boolean failure = true;
1:0dd50a6:         mts.addMerkleTree(1, new Range<>(tok(1), tok(3)));
1:0dd50a6: 
1:0dd50a6:         try
1:0dd50a6:         {
1:0dd50a6:             mts.addMerkleTree(1, new Range<>(tok(2), tok(4)));
1:0dd50a6:         }
1:0dd50a6:         catch (AssertionError e)
1:0dd50a6:         {
1:0dd50a6:             failure = false;
1:0dd50a6:         }
1:0dd50a6: 
1:0dd50a6:         assertFalse(failure);
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testSplit()
1:0dd50a6:     {
1:0dd50a6:         // split the range  (zero, zero] into:
1:0dd50a6:         //  (zero,four], (four,six], (six,seven] and (seven, zero]
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(6));
1:0dd50a6:         mts.split(tok(7));
1:0dd50a6: 
1:0dd50a6:         assertEquals(4, mts.size());
1:0dd50a6:         assertEquals(new Range<>(tok(7), tok(-1)), mts.get(tok(-1)));
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(3)));
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(4)));
1:0dd50a6:         assertEquals(new Range<>(tok(4), tok(6)), mts.get(tok(6)));
1:0dd50a6:         assertEquals(new Range<>(tok(6), tok(7)), mts.get(tok(7)));
1:0dd50a6: 
1:0dd50a6:         // check depths
1:0dd50a6:         assertEquals((byte) 1, mts.get(tok(4)).depth);
1:0dd50a6:         assertEquals((byte) 2, mts.get(tok(6)).depth);
1:0dd50a6:         assertEquals((byte) 3, mts.get(tok(7)).depth);
1:0dd50a6:         assertEquals((byte) 3, mts.get(tok(-1)).depth);
1:0dd50a6: 
1:0dd50a6:         try
1:0dd50a6:         {
1:0dd50a6:             mts.split(tok(-1));
1:0dd50a6:             fail("Shouldn't be able to split outside the initial range.");
1:0dd50a6:         }
1:0dd50a6:         catch (AssertionError e)
1:0dd50a6:         {
1:0dd50a6:             // pass
1:0dd50a6:         }
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testSplitLimitDepth()
1:0dd50a6:     {
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6: 
1:0dd50a6:         mts.addMerkleTree(Integer.MAX_VALUE, (byte) 2, fullRange());
1:0dd50a6: 
1:0dd50a6:         assertTrue(mts.split(tok(4)));
1:0dd50a6:         assertTrue(mts.split(tok(2)));
1:0dd50a6:         assertEquals(3, mts.size());
1:0dd50a6: 
1:0dd50a6:         // should fail to split below hashdepth
1:0dd50a6:         assertFalse(mts.split(tok(1)));
1:0dd50a6:         assertEquals(3, mts.size());
1:0dd50a6:         assertEquals(new Range<>(tok(4), tok(-1)), mts.get(tok(-1)));
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(2)), mts.get(tok(2)));
1:0dd50a6:         assertEquals(new Range<>(tok(2), tok(4)), mts.get(tok(4)));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testSplitLimitSize()
1:0dd50a6:     {
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6: 
1:0dd50a6:         mts.addMerkleTree(2, fullRange());
1:0dd50a6: 
1:0dd50a6:         assertTrue(mts.split(tok(4)));
1:0dd50a6:         assertEquals(2, mts.size());
1:0dd50a6: 
1:0dd50a6:         // should fail to split above maxsize
1:0dd50a6:         assertFalse(mts.split(tok(2)));
1:0dd50a6:         assertEquals(2, mts.size());
1:0dd50a6:         assertEquals(new Range<>(tok(4), tok(-1)), mts.get(tok(-1)));
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(4)));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testInvalids()
1:0dd50a6:     {
1:0dd50a6:         Iterator<TreeRange> ranges;
1:0dd50a6: 
1:0dd50a6:         // (zero, zero]
1:0dd50a6:         ranges = mts.invalids();
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(-1)), ranges.next());
1:0dd50a6:         assertFalse(ranges.hasNext());
1:0dd50a6: 
1:0dd50a6:         // all invalid
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(2));
1:0dd50a6:         mts.split(tok(6));
1:0dd50a6:         mts.split(tok(3));
1:0dd50a6:         mts.split(tok(5));
1:0dd50a6:         ranges = mts.invalids();
1:0dd50a6:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(-1), tok(2)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(2), tok(3)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(3), tok(4)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(4), tok(5)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(5), tok(6)), ranges.next());
1:0dd50a6:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:0dd50a6:         assertFalse(ranges.hasNext());
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testHashFull()
1:0dd50a6:     {
1:0dd50a6:         byte[] val = DUMMY;
1:0dd50a6:         Range<Token> range = new Range<>(tok(-1), tok(-1));
1:0dd50a6: 
1:0dd50a6:         // (zero, zero]
1:0dd50a6:         assertNull(mts.hash(range));
1:0dd50a6: 
1:0dd50a6:         // validate the range
1:0dd50a6:         mts.get(tok(-1)).hash(val);
1:0dd50a6: 
1:0dd50a6:         assertHashEquals(val, mts.hash(range));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testHashPartial()
1:0dd50a6:     {
1:0dd50a6:         byte[] val = DUMMY;
1:0dd50a6:         byte[] leftval = hashed(val, 1, 1);
1:0dd50a6:         byte[] partialval = hashed(val, 1);
1:0dd50a6:         Range<Token> left = new Range<>(tok(-1), tok(4));
1:0dd50a6:         Range<Token> partial = new Range<>(tok(2), tok(4));
1:0dd50a6:         Range<Token> right = new Range<>(tok(4), tok(-1));
1:0dd50a6:         Range<Token> linvalid = new Range<>(tok(1), tok(4));
1:0dd50a6:         Range<Token> rinvalid = new Range<>(tok(4), tok(6));
1:0dd50a6: 
1:0dd50a6:         // (zero,two] (two,four] (four, zero]
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(2));
1:0dd50a6:         assertNull(mts.hash(left));
1:0dd50a6:         assertNull(mts.hash(partial));
1:0dd50a6:         assertNull(mts.hash(right));
1:0dd50a6:         assertNull(mts.hash(linvalid));
1:0dd50a6:         assertNull(mts.hash(rinvalid));
1:0dd50a6: 
1:0dd50a6:         // validate the range
1:0dd50a6:         mts.get(tok(2)).hash(val);
1:0dd50a6:         mts.get(tok(4)).hash(val);
1:0dd50a6:         mts.get(tok(-1)).hash(val);
1:0dd50a6: 
1:0dd50a6:         assertHashEquals(leftval, mts.hash(left));
1:0dd50a6:         assertHashEquals(partialval, mts.hash(partial));
1:0dd50a6:         assertHashEquals(val, mts.hash(right));
1:0dd50a6:         assertNull(mts.hash(linvalid));
1:0dd50a6:         assertNull(mts.hash(rinvalid));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testHashInner()
1:0dd50a6:     {
1:0dd50a6:         byte[] val = DUMMY;
1:0dd50a6:         byte[] lchildval = hashed(val, 3, 3, 2);
1:0dd50a6:         byte[] rchildval = hashed(val, 2, 2);
1:0dd50a6:         byte[] fullval = hashed(val, 3, 3, 2, 2, 2);
1:0dd50a6:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:0dd50a6:         Range<Token> lchild = new Range<>(tok(-1), tok(4));
1:0dd50a6:         Range<Token> rchild = new Range<>(tok(4), tok(-1));
1:0dd50a6:         Range<Token> invalid = new Range<>(tok(1), tok(-1));
1:0dd50a6: 
1:0dd50a6:         // (zero,one] (one, two] (two,four] (four, six] (six, zero]
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(2));
1:0dd50a6:         mts.split(tok(6));
1:0dd50a6:         mts.split(tok(1));
1:0dd50a6:         assertNull(mts.hash(full));
1:0dd50a6:         assertNull(mts.hash(lchild));
1:0dd50a6:         assertNull(mts.hash(rchild));
1:0dd50a6:         assertNull(mts.hash(invalid));
1:0dd50a6: 
1:0dd50a6:         // validate the range
1:0dd50a6:         mts.get(tok(1)).hash(val);
1:0dd50a6:         mts.get(tok(2)).hash(val);
1:0dd50a6:         mts.get(tok(4)).hash(val);
1:0dd50a6:         mts.get(tok(6)).hash(val);
1:0dd50a6:         mts.get(tok(-1)).hash(val);
1:0dd50a6: 
1:0dd50a6:         assertHashEquals(fullval, mts.hash(full));
1:0dd50a6:         assertHashEquals(lchildval, mts.hash(lchild));
1:0dd50a6:         assertHashEquals(rchildval, mts.hash(rchild));
1:0dd50a6:         assertNull(mts.hash(invalid));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testHashDegenerate()
1:0dd50a6:     {
1:0dd50a6:         TOKEN_SCALE = new BigInteger("32");
1:0dd50a6: 
1:0dd50a6:         byte[] val = DUMMY;
1:0dd50a6:         byte[] childfullval = hashed(val, 5, 5, 4);
1:0dd50a6:         byte[] fullval = hashed(val, 5, 5, 4, 3, 2, 1);
1:0dd50a6:         Range<Token> childfull = new Range<>(tok(-1), tok(4));
1:0dd50a6:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:0dd50a6:         Range<Token> invalid = new Range<>(tok(4), tok(-1));
1:0dd50a6: 
1:0dd50a6:         mts.split(tok(16));
1:0dd50a6:         mts.split(tok(8));
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(2));
1:0dd50a6:         mts.split(tok(1));
1:0dd50a6:         assertNull(mts.hash(full));
1:0dd50a6:         assertNull(mts.hash(childfull));
1:0dd50a6:         assertNull(mts.hash(invalid));
1:0dd50a6: 
1:0dd50a6:         // validate the range
1:0dd50a6:         mts.get(tok(1)).hash(val);
1:0dd50a6:         mts.get(tok(2)).hash(val);
1:0dd50a6:         mts.get(tok(4)).hash(val);
1:0dd50a6:         mts.get(tok(8)).hash(val);
1:0dd50a6:         mts.get(tok(16)).hash(val);
1:0dd50a6:         mts.get(tok(-1)).hash(val);
1:0dd50a6: 
1:0dd50a6:         assertHashEquals(fullval, mts.hash(full));
1:0dd50a6:         assertHashEquals(childfullval, mts.hash(childfull));
1:0dd50a6:         assertNull(mts.hash(invalid));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testHashRandom()
1:0dd50a6:     {
1:0dd50a6:         int max = 1000000;
1:0dd50a6:         TOKEN_SCALE = new BigInteger("" + max);
1:0dd50a6: 
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6:         mts.addMerkleTree(32, fullRange());
1:0dd50a6: 
1:0dd50a6:         Random random = new Random();
1:0dd50a6:         while (true)
1:0dd50a6:         {
1:0dd50a6:             if (!mts.split(tok(random.nextInt(max))))
1:0dd50a6:                 break;
1:0dd50a6:         }
1:0dd50a6: 
1:0dd50a6:         // validate the tree
1:0dd50a6:         TreeRangeIterator ranges = mts.invalids();
1:0dd50a6:         for (TreeRange range : ranges)
1:0dd50a6:             range.addHash(new RowHash(range.right, new byte[0], 0));
1:0dd50a6: 
1:0dd50a6:         assert mts.hash(new Range<>(tok(-1), tok(-1))) != null : "Could not hash tree " + mts;
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     /**
1:0dd50a6:      * Generate two trees with different splits, but containing the same keys, and
1:0dd50a6:      * check that they compare equally.
1:0dd50a6:      *
1:0dd50a6:      * The set of keys used in this test is: #{2,4,6,8,12,14,0}
1:0dd50a6:      */
1:0dd50a6:     @Test
1:0dd50a6:     public void testValidateTree()
1:0dd50a6:     {
1:0dd50a6:         TOKEN_SCALE = new BigInteger("16"); // this test needs slightly more resolution
1:0dd50a6: 
1:0dd50a6:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:0dd50a6:         Iterator<TreeRange> ranges;
1:0dd50a6:         MerkleTrees mts2 = new MerkleTrees(partitioner);
1:0dd50a6:         mts2.addMerkleTree(Integer.MAX_VALUE, fullRange());
1:0dd50a6: 
1:0dd50a6:         mts.split(tok(8));
1:0dd50a6:         mts.split(tok(4));
1:0dd50a6:         mts.split(tok(12));
1:0dd50a6:         mts.split(tok(6));
1:0dd50a6:         mts.split(tok(10));
1:0dd50a6: 
1:0dd50a6:         ranges = mts.invalids();
1:0dd50a6:         ranges.next().addAll(new HIterator(2, 4)); // (-1,4]: depth 2
1:0dd50a6:         ranges.next().addAll(new HIterator(6)); // (4,6]
1:0dd50a6:         ranges.next().addAll(new HIterator(8)); // (6,8]
1:0dd50a6:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,10]
1:0dd50a6:         ranges.next().addAll(new HIterator(12)); // (10,12]
1:0dd50a6:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1:0dd50a6: 
1:0dd50a6: 
1:0dd50a6:         mts2.split(tok(8));
1:0dd50a6:         mts2.split(tok(4));
1:0dd50a6:         mts2.split(tok(12));
1:0dd50a6:         mts2.split(tok(2));
1:0dd50a6:         mts2.split(tok(10));
1:0dd50a6:         mts2.split(tok(9));
1:0dd50a6:         mts2.split(tok(11));
1:0dd50a6: 
1:0dd50a6:         ranges = mts2.invalids();
1:0dd50a6:         ranges.next().addAll(new HIterator(2)); // (-1,2]
1:0dd50a6:         ranges.next().addAll(new HIterator(4)); // (2,4]
1:0dd50a6:         ranges.next().addAll(new HIterator(6, 8)); // (4,8]: depth 2
1:0dd50a6:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,9]
1:0dd50a6:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (9,10]
1:0dd50a6:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (10,11]: depth 4
1:0dd50a6:         ranges.next().addAll(new HIterator(12)); // (11,12]: depth 4
1:0dd50a6:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1:0dd50a6: 
1:0dd50a6:         byte[] mthash = mts.hash(full);
1:0dd50a6:         byte[] mt2hash = mts2.hash(full);
1:0dd50a6:         assertHashEquals("Tree hashes did not match: " + mts + " && " + mts2, mthash, mt2hash);
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testSerialization() throws Exception
1:0dd50a6:     {
1:0dd50a6:         Range<Token> first = new Range<>(tok(3), tok(4));
1:0dd50a6: 
1:0dd50a6:         Collection<Range<Token>> ranges = new ArrayList<>();
1:0dd50a6: 
1:0dd50a6:         ranges.add(first);
1:0dd50a6:         ranges.add(new Range<Token>(tok(5), tok(2)));
1:0dd50a6: 
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6:         mts.addMerkleTrees(256, ranges);
1:0dd50a6: 
1:0dd50a6:         // populate and validate the tree
1:0dd50a6:         mts.init();
1:0dd50a6:         for (TreeRange range : mts.invalids())
1:0dd50a6:             range.addAll(new HIterator(range.right));
1:0dd50a6: 
1:0dd50a6:         byte[] initialhash = mts.hash(first);
1:0dd50a6: 
1:0dd50a6:         long serializedSize = MerkleTrees.serializer.serializedSize(mts, MessagingService.current_version);
1:0dd50a6:         DataOutputBuffer out = new DataOutputBuffer();
1:0dd50a6:         MerkleTrees.serializer.serialize(mts, out, MessagingService.current_version);
1:0dd50a6:         byte[] serialized = out.toByteArray();
1:0dd50a6: 
1:0dd50a6:         assertEquals(serializedSize, serialized.length);
1:0dd50a6: 
1:0dd50a6:         DataInputBuffer in = new DataInputBuffer(serialized);
1:0dd50a6:         MerkleTrees restored = MerkleTrees.serializer.deserialize(in, MessagingService.current_version);
1:0dd50a6: 
1:0dd50a6:         assertHashEquals(initialhash, restored.hash(first));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     @Test
1:0dd50a6:     public void testDifference()
1:0dd50a6:     {
1:0dd50a6:         int maxsize = 16;
1:0dd50a6:         mts = new MerkleTrees(partitioner);
1:0dd50a6:         mts.addMerkleTree(32, fullRange());
1:0dd50a6: 
1:0dd50a6:         MerkleTrees mts2 = new MerkleTrees(partitioner);
1:0dd50a6:         mts2.addMerkleTree(32, fullRange());
1:0dd50a6: 
1:0dd50a6:         mts.init();
1:0dd50a6:         mts2.init();
1:0dd50a6: 
1:0dd50a6:         // add dummy hashes to both trees
1:0dd50a6:         for (TreeRange range : mts.invalids())
1:0dd50a6:             range.addAll(new HIterator(range.right));
1:0dd50a6:         for (TreeRange range : mts2.invalids())
1:0dd50a6:             range.addAll(new HIterator(range.right));
1:0dd50a6: 
1:0dd50a6:         TreeRange leftmost = null;
1:0dd50a6:         TreeRange middle = null;
1:0dd50a6: 
1:0dd50a6:         mts.maxsize(fullRange(), maxsize + 2); // give some room for splitting
1:0dd50a6: 
1:0dd50a6:         // split the leftmost
1:0dd50a6:         Iterator<TreeRange> ranges = mts.invalids();
1:0dd50a6:         leftmost = ranges.next();
1:0dd50a6:         mts.split(leftmost.right);
1:0dd50a6: 
1:0dd50a6:         // set the hashes for the leaf of the created split
1:0dd50a6:         middle = mts.get(leftmost.right);
1:0dd50a6:         middle.hash("arbitrary!".getBytes());
1:0dd50a6:         mts.get(partitioner.midpoint(leftmost.left, leftmost.right)).hash("even more arbitrary!".getBytes());
1:0dd50a6: 
1:0dd50a6:         // trees should disagree for (leftmost.left, middle.right]
1:0dd50a6:         List<Range<Token>> diffs = MerkleTrees.difference(mts, mts2);
1:0dd50a6:         assertEquals(diffs + " contains wrong number of differences:", 1, diffs.size());
1:0dd50a6:         assertTrue(diffs.contains(new Range<>(leftmost.left, middle.right)));
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     /**
1:0dd50a6:      * Return the root hash of a binary tree with leaves at the given depths
1:0dd50a6:      * and with the given hash val in each leaf.
1:0dd50a6:      */
1:0dd50a6:     byte[] hashed(byte[] val, Integer... depths)
1:0dd50a6:     {
1:0dd50a6:         ArrayDeque<Integer> dstack = new ArrayDeque<Integer>();
1:0dd50a6:         ArrayDeque<byte[]> hstack = new ArrayDeque<byte[]>();
1:0dd50a6:         Iterator<Integer> depthiter = Arrays.asList(depths).iterator();
1:0dd50a6:         if (depthiter.hasNext())
1:0dd50a6:         {
1:0dd50a6:             dstack.push(depthiter.next());
1:0dd50a6:             hstack.push(val);
1:0dd50a6:         }
1:0dd50a6:         while (depthiter.hasNext())
1:0dd50a6:         {
1:0dd50a6:             Integer depth = depthiter.next();
1:0dd50a6:             byte[] hash = val;
1:0dd50a6:             while (depth.equals(dstack.peek()))
1:0dd50a6:             {
1:0dd50a6:                 // consume the stack
1:0dd50a6:                 hash = Hashable.binaryHash(hstack.pop(), hash);
1:0dd50a6:                 depth = dstack.pop()-1;
1:0dd50a6:             }
1:0dd50a6:             dstack.push(depth);
1:0dd50a6:             hstack.push(hash);
1:0dd50a6:         }
1:0dd50a6:         assert hstack.size() == 1;
1:0dd50a6:         return hstack.pop();
1:0dd50a6:     }
1:0dd50a6: 
1:0dd50a6:     static class HIterator extends AbstractIterator<RowHash>
1:0dd50a6:     {
1:0dd50a6:         private Iterator<Token> tokens;
1:0dd50a6: 
1:0dd50a6:         public HIterator(int... tokens)
1:0dd50a6:         {
1:0dd50a6:             List<Token> tlist = new LinkedList<Token>();
1:0dd50a6:             for (int token : tokens)
1:0dd50a6:                 tlist.add(tok(token));
1:0dd50a6:             this.tokens = tlist.iterator();
1:0dd50a6:         }
1:0dd50a6: 
1:0dd50a6:         public HIterator(Token... tokens)
1:0dd50a6:         {
1:0dd50a6:             this.tokens = Arrays.asList(tokens).iterator();
1:0dd50a6:         }
1:0dd50a6: 
1:0dd50a6:         public RowHash computeNext()
1:0dd50a6:         {
1:0dd50a6:             if (tokens.hasNext())
1:0dd50a6:                 return new RowHash(tokens.next(), DUMMY, DUMMY.length);
1:0dd50a6:             return endOfData();
1:0dd50a6:         }
1:0dd50a6:     }
1:0dd50a6: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Marcus Olsson
-------------------------------------------------------------------------------
commit:0dd50a6
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyten ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.utils;
1: 
1: import java.math.BigInteger;
1: import java.util.*;
1: 
1: import com.google.common.collect.AbstractIterator;
1: 
1: import org.junit.Before;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.apache.cassandra.dht.*;
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1: import org.apache.cassandra.io.util.DataInputBuffer;
1: import org.apache.cassandra.io.util.DataOutputBuffer;
1: import org.apache.cassandra.net.MessagingService;
1: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.utils.MerkleTree.Hashable;
1: import org.apache.cassandra.utils.MerkleTree.RowHash;
1: import org.apache.cassandra.utils.MerkleTree.TreeRange;
1: import org.apache.cassandra.utils.MerkleTrees.TreeRangeIterator;
1: 
1: import static org.junit.Assert.*;
1: 
1: public class MerkleTreesTest
1: {
1:     public static byte[] DUMMY = "blah".getBytes();
1: 
1:     /**
1:      * If a test assumes that the tree is 8 units wide, then it should set this value
1:      * to 8.
1:      */
1:     public static BigInteger TOKEN_SCALE = new BigInteger("8");
1: 
1:     protected static final IPartitioner partitioner = RandomPartitioner.instance;
1:     protected MerkleTrees mts;
1: 
1:     private Range<Token> fullRange()
1:     {
1:         return new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
1:     }
1: 
1:     @BeforeClass
1:     public static void setUp()
1:     {
1:         StorageService.instance.setPartitionerUnsafe(partitioner);
1:     }
1:     @Before
1:     public void clear()
1:     {
1:         TOKEN_SCALE = new BigInteger("8");
1:         mts = new MerkleTrees(partitioner);
1:         mts.addMerkleTree(Integer.MAX_VALUE, fullRange());
1:     }
1: 
1:     public static void assertHashEquals(final byte[] left, final byte[] right)
1:     {
1:         assertHashEquals("", left, right);
1:     }
1: 
1:     public static void assertHashEquals(String message, final byte[] left, final byte[] right)
1:     {
1:         String lstring = left == null ? "null" : Hex.bytesToHex(left);
1:         String rstring = right == null ? "null" : Hex.bytesToHex(right);
1:         assertEquals(message, lstring, rstring);
1:     }
1: 
1:     /**
1:      * The value returned by this method is affected by TOKEN_SCALE: setting TOKEN_SCALE
1:      * to 8 means that passing -1 through 8 for this method will return values mapped
1:      * between -1 and Token.MAX_VALUE.
1:      */
1:     public static Token tok(int i)
1:     {
1:         if (i == -1)
1:             return new BigIntegerToken(new BigInteger("-1"));
1:         BigInteger bint = RandomPartitioner.MAXIMUM.divide(TOKEN_SCALE).multiply(new BigInteger(""+i));
1:         return new BigIntegerToken(bint);
1:     }
1: 
1:     @Test
1:     public void testIntersectingRanges()
1:     {
1:         mts = new MerkleTrees(partitioner);
1: 
1:         boolean failure = true;
1:         mts.addMerkleTree(1, new Range<>(tok(1), tok(3)));
1: 
1:         try
1:         {
1:             mts.addMerkleTree(1, new Range<>(tok(2), tok(4)));
1:         }
1:         catch (AssertionError e)
1:         {
1:             failure = false;
1:         }
1: 
1:         assertFalse(failure);
1:     }
1: 
1:     @Test
1:     public void testSplit()
1:     {
1:         // split the range  (zero, zero] into:
1:         //  (zero,four], (four,six], (six,seven] and (seven, zero]
1:         mts.split(tok(4));
1:         mts.split(tok(6));
1:         mts.split(tok(7));
1: 
1:         assertEquals(4, mts.size());
1:         assertEquals(new Range<>(tok(7), tok(-1)), mts.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(3)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(4)));
1:         assertEquals(new Range<>(tok(4), tok(6)), mts.get(tok(6)));
1:         assertEquals(new Range<>(tok(6), tok(7)), mts.get(tok(7)));
1: 
1:         // check depths
1:         assertEquals((byte) 1, mts.get(tok(4)).depth);
1:         assertEquals((byte) 2, mts.get(tok(6)).depth);
1:         assertEquals((byte) 3, mts.get(tok(7)).depth);
1:         assertEquals((byte) 3, mts.get(tok(-1)).depth);
1: 
1:         try
1:         {
1:             mts.split(tok(-1));
1:             fail("Shouldn't be able to split outside the initial range.");
1:         }
1:         catch (AssertionError e)
1:         {
1:             // pass
1:         }
1:     }
1: 
1:     @Test
1:     public void testSplitLimitDepth()
1:     {
1:         mts = new MerkleTrees(partitioner);
1: 
1:         mts.addMerkleTree(Integer.MAX_VALUE, (byte) 2, fullRange());
1: 
1:         assertTrue(mts.split(tok(4)));
1:         assertTrue(mts.split(tok(2)));
1:         assertEquals(3, mts.size());
1: 
1:         // should fail to split below hashdepth
1:         assertFalse(mts.split(tok(1)));
1:         assertEquals(3, mts.size());
1:         assertEquals(new Range<>(tok(4), tok(-1)), mts.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(2)), mts.get(tok(2)));
1:         assertEquals(new Range<>(tok(2), tok(4)), mts.get(tok(4)));
1:     }
1: 
1:     @Test
1:     public void testSplitLimitSize()
1:     {
1:         mts = new MerkleTrees(partitioner);
1: 
1:         mts.addMerkleTree(2, fullRange());
1: 
1:         assertTrue(mts.split(tok(4)));
1:         assertEquals(2, mts.size());
1: 
1:         // should fail to split above maxsize
1:         assertFalse(mts.split(tok(2)));
1:         assertEquals(2, mts.size());
1:         assertEquals(new Range<>(tok(4), tok(-1)), mts.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mts.get(tok(4)));
1:     }
1: 
1:     @Test
1:     public void testInvalids()
1:     {
1:         Iterator<TreeRange> ranges;
1: 
1:         // (zero, zero]
1:         ranges = mts.invalids();
1:         assertEquals(new Range<>(tok(-1), tok(-1)), ranges.next());
1:         assertFalse(ranges.hasNext());
1: 
1:         // all invalid
1:         mts.split(tok(4));
1:         mts.split(tok(2));
1:         mts.split(tok(6));
1:         mts.split(tok(3));
1:         mts.split(tok(5));
1:         ranges = mts.invalids();
1:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:         assertEquals(new Range<>(tok(-1), tok(2)), ranges.next());
1:         assertEquals(new Range<>(tok(2), tok(3)), ranges.next());
1:         assertEquals(new Range<>(tok(3), tok(4)), ranges.next());
1:         assertEquals(new Range<>(tok(4), tok(5)), ranges.next());
1:         assertEquals(new Range<>(tok(5), tok(6)), ranges.next());
1:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:         assertFalse(ranges.hasNext());
1:     }
1: 
1: 
1:     @Test
1:     public void testHashFull()
1:     {
1:         byte[] val = DUMMY;
1:         Range<Token> range = new Range<>(tok(-1), tok(-1));
1: 
1:         // (zero, zero]
1:         assertNull(mts.hash(range));
1: 
1:         // validate the range
1:         mts.get(tok(-1)).hash(val);
1: 
1:         assertHashEquals(val, mts.hash(range));
1:     }
1: 
1:     @Test
1:     public void testHashPartial()
1:     {
1:         byte[] val = DUMMY;
1:         byte[] leftval = hashed(val, 1, 1);
1:         byte[] partialval = hashed(val, 1);
1:         Range<Token> left = new Range<>(tok(-1), tok(4));
1:         Range<Token> partial = new Range<>(tok(2), tok(4));
1:         Range<Token> right = new Range<>(tok(4), tok(-1));
1:         Range<Token> linvalid = new Range<>(tok(1), tok(4));
1:         Range<Token> rinvalid = new Range<>(tok(4), tok(6));
1: 
1:         // (zero,two] (two,four] (four, zero]
1:         mts.split(tok(4));
1:         mts.split(tok(2));
1:         assertNull(mts.hash(left));
1:         assertNull(mts.hash(partial));
1:         assertNull(mts.hash(right));
1:         assertNull(mts.hash(linvalid));
1:         assertNull(mts.hash(rinvalid));
1: 
1:         // validate the range
1:         mts.get(tok(2)).hash(val);
1:         mts.get(tok(4)).hash(val);
1:         mts.get(tok(-1)).hash(val);
1: 
1:         assertHashEquals(leftval, mts.hash(left));
1:         assertHashEquals(partialval, mts.hash(partial));
1:         assertHashEquals(val, mts.hash(right));
1:         assertNull(mts.hash(linvalid));
1:         assertNull(mts.hash(rinvalid));
1:     }
1: 
1:     @Test
1:     public void testHashInner()
1:     {
1:         byte[] val = DUMMY;
1:         byte[] lchildval = hashed(val, 3, 3, 2);
1:         byte[] rchildval = hashed(val, 2, 2);
1:         byte[] fullval = hashed(val, 3, 3, 2, 2, 2);
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:         Range<Token> lchild = new Range<>(tok(-1), tok(4));
1:         Range<Token> rchild = new Range<>(tok(4), tok(-1));
1:         Range<Token> invalid = new Range<>(tok(1), tok(-1));
1: 
1:         // (zero,one] (one, two] (two,four] (four, six] (six, zero]
1:         mts.split(tok(4));
1:         mts.split(tok(2));
1:         mts.split(tok(6));
1:         mts.split(tok(1));
1:         assertNull(mts.hash(full));
1:         assertNull(mts.hash(lchild));
1:         assertNull(mts.hash(rchild));
1:         assertNull(mts.hash(invalid));
1: 
1:         // validate the range
1:         mts.get(tok(1)).hash(val);
1:         mts.get(tok(2)).hash(val);
1:         mts.get(tok(4)).hash(val);
1:         mts.get(tok(6)).hash(val);
1:         mts.get(tok(-1)).hash(val);
1: 
1:         assertHashEquals(fullval, mts.hash(full));
1:         assertHashEquals(lchildval, mts.hash(lchild));
1:         assertHashEquals(rchildval, mts.hash(rchild));
1:         assertNull(mts.hash(invalid));
1:     }
1: 
1:     @Test
1:     public void testHashDegenerate()
1:     {
1:         TOKEN_SCALE = new BigInteger("32");
1: 
1:         byte[] val = DUMMY;
1:         byte[] childfullval = hashed(val, 5, 5, 4);
1:         byte[] fullval = hashed(val, 5, 5, 4, 3, 2, 1);
1:         Range<Token> childfull = new Range<>(tok(-1), tok(4));
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:         Range<Token> invalid = new Range<>(tok(4), tok(-1));
1: 
1:         mts.split(tok(16));
1:         mts.split(tok(8));
1:         mts.split(tok(4));
1:         mts.split(tok(2));
1:         mts.split(tok(1));
1:         assertNull(mts.hash(full));
1:         assertNull(mts.hash(childfull));
1:         assertNull(mts.hash(invalid));
1: 
1:         // validate the range
1:         mts.get(tok(1)).hash(val);
1:         mts.get(tok(2)).hash(val);
1:         mts.get(tok(4)).hash(val);
1:         mts.get(tok(8)).hash(val);
1:         mts.get(tok(16)).hash(val);
1:         mts.get(tok(-1)).hash(val);
1: 
1:         assertHashEquals(fullval, mts.hash(full));
1:         assertHashEquals(childfullval, mts.hash(childfull));
1:         assertNull(mts.hash(invalid));
1:     }
1: 
1:     @Test
1:     public void testHashRandom()
1:     {
1:         int max = 1000000;
1:         TOKEN_SCALE = new BigInteger("" + max);
1: 
1:         mts = new MerkleTrees(partitioner);
1:         mts.addMerkleTree(32, fullRange());
1: 
1:         Random random = new Random();
1:         while (true)
1:         {
1:             if (!mts.split(tok(random.nextInt(max))))
1:                 break;
1:         }
1: 
1:         // validate the tree
1:         TreeRangeIterator ranges = mts.invalids();
1:         for (TreeRange range : ranges)
1:             range.addHash(new RowHash(range.right, new byte[0], 0));
1: 
1:         assert mts.hash(new Range<>(tok(-1), tok(-1))) != null : "Could not hash tree " + mts;
1:     }
1: 
1:     /**
1:      * Generate two trees with different splits, but containing the same keys, and
1:      * check that they compare equally.
1:      *
1:      * The set of keys used in this test is: #{2,4,6,8,12,14,0}
1:      */
1:     @Test
1:     public void testValidateTree()
1:     {
1:         TOKEN_SCALE = new BigInteger("16"); // this test needs slightly more resolution
1: 
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:         Iterator<TreeRange> ranges;
1:         MerkleTrees mts2 = new MerkleTrees(partitioner);
1:         mts2.addMerkleTree(Integer.MAX_VALUE, fullRange());
1: 
1:         mts.split(tok(8));
1:         mts.split(tok(4));
1:         mts.split(tok(12));
1:         mts.split(tok(6));
1:         mts.split(tok(10));
1: 
1:         ranges = mts.invalids();
1:         ranges.next().addAll(new HIterator(2, 4)); // (-1,4]: depth 2
1:         ranges.next().addAll(new HIterator(6)); // (4,6]
1:         ranges.next().addAll(new HIterator(8)); // (6,8]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,10]
1:         ranges.next().addAll(new HIterator(12)); // (10,12]
1:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1: 
1: 
1:         mts2.split(tok(8));
1:         mts2.split(tok(4));
1:         mts2.split(tok(12));
1:         mts2.split(tok(2));
1:         mts2.split(tok(10));
1:         mts2.split(tok(9));
1:         mts2.split(tok(11));
1: 
1:         ranges = mts2.invalids();
1:         ranges.next().addAll(new HIterator(2)); // (-1,2]
1:         ranges.next().addAll(new HIterator(4)); // (2,4]
1:         ranges.next().addAll(new HIterator(6, 8)); // (4,8]: depth 2
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,9]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (9,10]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (10,11]: depth 4
1:         ranges.next().addAll(new HIterator(12)); // (11,12]: depth 4
1:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1: 
1:         byte[] mthash = mts.hash(full);
1:         byte[] mt2hash = mts2.hash(full);
1:         assertHashEquals("Tree hashes did not match: " + mts + " && " + mts2, mthash, mt2hash);
1:     }
1: 
1:     @Test
1:     public void testSerialization() throws Exception
1:     {
1:         Range<Token> first = new Range<>(tok(3), tok(4));
1: 
1:         Collection<Range<Token>> ranges = new ArrayList<>();
1: 
1:         ranges.add(first);
1:         ranges.add(new Range<Token>(tok(5), tok(2)));
1: 
1:         mts = new MerkleTrees(partitioner);
1:         mts.addMerkleTrees(256, ranges);
1: 
1:         // populate and validate the tree
1:         mts.init();
1:         for (TreeRange range : mts.invalids())
1:             range.addAll(new HIterator(range.right));
1: 
1:         byte[] initialhash = mts.hash(first);
1: 
1:         long serializedSize = MerkleTrees.serializer.serializedSize(mts, MessagingService.current_version);
1:         DataOutputBuffer out = new DataOutputBuffer();
1:         MerkleTrees.serializer.serialize(mts, out, MessagingService.current_version);
1:         byte[] serialized = out.toByteArray();
1: 
1:         assertEquals(serializedSize, serialized.length);
1: 
1:         DataInputBuffer in = new DataInputBuffer(serialized);
1:         MerkleTrees restored = MerkleTrees.serializer.deserialize(in, MessagingService.current_version);
1: 
1:         assertHashEquals(initialhash, restored.hash(first));
1:     }
1: 
1:     @Test
1:     public void testDifference()
1:     {
1:         int maxsize = 16;
1:         mts = new MerkleTrees(partitioner);
1:         mts.addMerkleTree(32, fullRange());
1: 
1:         MerkleTrees mts2 = new MerkleTrees(partitioner);
1:         mts2.addMerkleTree(32, fullRange());
1: 
1:         mts.init();
1:         mts2.init();
1: 
1:         // add dummy hashes to both trees
1:         for (TreeRange range : mts.invalids())
1:             range.addAll(new HIterator(range.right));
1:         for (TreeRange range : mts2.invalids())
1:             range.addAll(new HIterator(range.right));
1: 
1:         TreeRange leftmost = null;
1:         TreeRange middle = null;
1: 
1:         mts.maxsize(fullRange(), maxsize + 2); // give some room for splitting
1: 
1:         // split the leftmost
1:         Iterator<TreeRange> ranges = mts.invalids();
1:         leftmost = ranges.next();
1:         mts.split(leftmost.right);
1: 
1:         // set the hashes for the leaf of the created split
1:         middle = mts.get(leftmost.right);
1:         middle.hash("arbitrary!".getBytes());
1:         mts.get(partitioner.midpoint(leftmost.left, leftmost.right)).hash("even more arbitrary!".getBytes());
1: 
1:         // trees should disagree for (leftmost.left, middle.right]
1:         List<Range<Token>> diffs = MerkleTrees.difference(mts, mts2);
1:         assertEquals(diffs + " contains wrong number of differences:", 1, diffs.size());
1:         assertTrue(diffs.contains(new Range<>(leftmost.left, middle.right)));
1:     }
1: 
1:     /**
1:      * Return the root hash of a binary tree with leaves at the given depths
1:      * and with the given hash val in each leaf.
1:      */
1:     byte[] hashed(byte[] val, Integer... depths)
1:     {
1:         ArrayDeque<Integer> dstack = new ArrayDeque<Integer>();
1:         ArrayDeque<byte[]> hstack = new ArrayDeque<byte[]>();
1:         Iterator<Integer> depthiter = Arrays.asList(depths).iterator();
1:         if (depthiter.hasNext())
1:         {
1:             dstack.push(depthiter.next());
1:             hstack.push(val);
1:         }
1:         while (depthiter.hasNext())
1:         {
1:             Integer depth = depthiter.next();
1:             byte[] hash = val;
1:             while (depth.equals(dstack.peek()))
1:             {
1:                 // consume the stack
1:                 hash = Hashable.binaryHash(hstack.pop(), hash);
1:                 depth = dstack.pop()-1;
1:             }
1:             dstack.push(depth);
1:             hstack.push(hash);
1:         }
1:         assert hstack.size() == 1;
1:         return hstack.pop();
1:     }
1: 
1:     static class HIterator extends AbstractIterator<RowHash>
1:     {
1:         private Iterator<Token> tokens;
1: 
1:         public HIterator(int... tokens)
1:         {
1:             List<Token> tlist = new LinkedList<Token>();
1:             for (int token : tokens)
1:                 tlist.add(tok(token));
1:             this.tokens = tlist.iterator();
1:         }
1: 
1:         public HIterator(Token... tokens)
1:         {
1:             this.tokens = Arrays.asList(tokens).iterator();
1:         }
1: 
1:         public RowHash computeNext()
1:         {
1:             if (tokens.hasNext())
1:                 return new RowHash(tokens.next(), DUMMY, DUMMY.length);
1:             return endOfData();
1:         }
1:     }
1: }
============================================================================