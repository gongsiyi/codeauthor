1:69cedbf: /*
1:69cedbf:  * Licensed to the Apache Software Foundation (ASF) under one
1:69cedbf:  * or more contributor license agreements.  See the NOTICE file
1:69cedbf:  * distributed with this work for additional information
1:69cedbf:  * regarding copyright ownership.  The ASF licenses this file
1:69cedbf:  * to you under the Apache License, Version 2.0 (the
1:69cedbf:  * "License"); you may not use this file except in compliance
1:69cedbf:  * with the License.  You may obtain a copy of the License at
1:69cedbf:  *
1:69cedbf:  *     http://www.apache.org/licenses/LICENSE-2.0
1:69cedbf:  *
1:69cedbf:  * Unless required by applicable law or agreed to in writing, software
1:69cedbf:  * distributed under the License is distributed on an "AS IS" BASIS,
1:69cedbf:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:69cedbf:  * See the License for the specific language governing permissions and
1:69cedbf:  * limitations under the License.
4:94ff639:  */
1:69cedbf: package org.apache.cassandra.metrics;
1:9b47dd5: 
1:faf9181: import java.nio.ByteBuffer;
1:faf9181: import java.util.*;
1:52be7ba: import java.util.concurrent.ConcurrentHashMap;
1:05660a5: import java.util.concurrent.ConcurrentMap;
1:62ffa35: import java.util.concurrent.TimeUnit;
1:ab6eaed: 
1:05660a5: import com.google.common.collect.Maps;
1:05660a5: 
1:8896a70: import com.codahale.metrics.*;
1:8896a70: import com.codahale.metrics.Timer;
1:9b47dd5: import org.apache.cassandra.config.Schema;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:69cedbf: import org.apache.cassandra.db.ColumnFamilyStore;
1:5b8ac8c: import org.apache.cassandra.db.Keyspace;
1:ae04861: import org.apache.cassandra.db.Memtable;
1:ad8cad7: import org.apache.cassandra.db.lifecycle.SSTableSet;
1:9b47dd5: import org.apache.cassandra.index.SecondaryIndexManager;
1:fa92ae6: import org.apache.cassandra.io.compress.CompressionMetadata;
1:0368e97: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:10649b1: import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
1:69cedbf: import org.apache.cassandra.utils.EstimatedHistogram;
1:faf9181: import org.apache.cassandra.utils.TopKSampler;
1:8896a70: 
1:8896a70: import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
1:8896a70: 
5:94ff639: /**
1:69cedbf:  * Metrics for {@link ColumnFamilyStore}.
1:94ff639:  */
1:0bd5170: public class TableMetrics
1:9685622: {
1:0f5e780: 
1:0f5e780:     public static final long[] EMPTY = new long[0];
1:0f5e780: 
1:0bd5170:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
1:1a3b5db:     public final Gauge<Long> memtableOnHeapSize;
1:0bd5170:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
1:1a3b5db:     public final Gauge<Long> memtableOffHeapSize;
1:4b54b8a:     /** Total amount of live data stored in the memtable, excluding any data structure overhead */
1:4b54b8a:     public final Gauge<Long> memtableLiveDataSize;
1:4b54b8a:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
1:1a3b5db:     public final Gauge<Long> allMemtablesOnHeapSize;
1:1a3b5db:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
1:1a3b5db:     public final Gauge<Long> allMemtablesOffHeapSize;
1:4b54b8a:     /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
1:4b54b8a:     public final Gauge<Long> allMemtablesLiveDataSize;
1:69cedbf:     /** Total number of columns present in the memtable. */
1:69cedbf:     public final Gauge<Long> memtableColumnsCount;
1:69cedbf:     /** Number of times flush has resulted in the memtable being switched out. */
1:69cedbf:     public final Counter memtableSwitchCount;
1:69cedbf:     /** Current compression ratio for all SSTables */
1:69cedbf:     public final Gauge<Double> compressionRatio;
1:0bd5170:     /** Histogram of estimated partition size (in bytes). */
1:0bd5170:     public final Gauge<long[]> estimatedPartitionSizeHistogram;
1:ae04861:     /** Approximate number of keys in table. */
1:0bd5170:     public final Gauge<Long> estimatedPartitionCount;
1:69cedbf:     /** Histogram of estimated number of columns. */
1:69cedbf:     public final Gauge<long[]> estimatedColumnCountHistogram;
1:69cedbf:     /** Histogram of the number of sstable data files accessed per read */
1:0bd5170:     public final TableHistogram sstablesPerReadHistogram;
1:8693a26:     /** (Local) read metrics */
1:69cedbf:     public final LatencyMetrics readLatency;
1:05ffa8f:     /** (Local) range slice metrics */
1:05ffa8f:     public final LatencyMetrics rangeLatency;
1:8693a26:     /** (Local) write metrics */
1:69cedbf:     public final LatencyMetrics writeLatency;
1:0bd5170:     /** Estimated number of tasks pending for this table */
1:4b54b8a:     public final Counter pendingFlushes;
1:a0a9494:     /** Total number of bytes flushed since server [re]start */
1:a0a9494:     public final Counter bytesFlushed;
1:a0a9494:     /** Total number of bytes written by compaction since server [re]start */
1:a0a9494:     public final Counter compactionBytesWritten;
1:0bd5170:     /** Estimate of number of pending compactios for this table */
1:e3a88b9:     public final Gauge<Integer> pendingCompactions;
1:69cedbf:     /** Number of SSTables on disk for this CF */
1:69cedbf:     public final Gauge<Integer> liveSSTableCount;
1:0bd5170:     /** Disk space used by SSTables belonging to this table */
1:69cedbf:     public final Counter liveDiskSpaceUsed;
1:0bd5170:     /** Total disk space used by SSTables belonging to this table, including obsolete ones waiting to be GC'd */
1:69cedbf:     public final Counter totalDiskSpaceUsed;
1:0bd5170:     /** Size of the smallest compacted partition */
1:0bd5170:     public final Gauge<Long> minPartitionSize;
1:0bd5170:     /** Size of the largest compacted partition */
1:0bd5170:     public final Gauge<Long> maxPartitionSize;
1:0bd5170:     /** Size of the smallest compacted partition */
1:0bd5170:     public final Gauge<Long> meanPartitionSize;
1:69cedbf:     /** Number of false positives in bloom filter */
1:69cedbf:     public final Gauge<Long> bloomFilterFalsePositives;
1:69cedbf:     /** Number of false positives in bloom filter from last read */
1:69cedbf:     public final Gauge<Long> recentBloomFilterFalsePositives;
1:69cedbf:     /** False positive ratio of bloom filter */
1:69cedbf:     public final Gauge<Double> bloomFilterFalseRatio;
1:69cedbf:     /** False positive ratio of bloom filter from last read */
1:69cedbf:     public final Gauge<Double> recentBloomFilterFalseRatio;
1:69cedbf:     /** Disk space used by bloom filter */
1:69cedbf:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
1:7a14a77:     /** Off heap memory used by bloom filter */
1:7a14a77:     public final Gauge<Long> bloomFilterOffHeapMemoryUsed;
1:7a14a77:     /** Off heap memory used by index summary */
1:7a14a77:     public final Gauge<Long> indexSummaryOffHeapMemoryUsed;
1:7a14a77:     /** Off heap memory used by compression meta data*/
1:7a14a77:     public final Gauge<Long> compressionMetadataOffHeapMemoryUsed;
1:f5d632f:     /** Key cache hit rate  for this CF */
1:f5d632f:     public final Gauge<Double> keyCacheHitRate;
1:2267c20:     /** Tombstones scanned in queries on this CF */
1:0bd5170:     public final TableHistogram tombstoneScannedHistogram;
1:2267c20:     /** Live cells scanned in queries on this CF */
1:0bd5170:     public final TableHistogram liveScannedHistogram;
1:5acc7a9:     /** Column update time delta on this CF */
1:0bd5170:     public final TableHistogram colUpdateTimeDeltaHistogram;
1:62ffa35:     /** time taken acquiring the partition lock for materialized view updates for this table */
1:62ffa35:     public final TableTimer viewLockAcquireTime;
1:62ffa35:     /** time taken during the local read of a materialized view update */
1:62ffa35:     public final TableTimer viewReadTime;
1:e178ff4:     /** Disk space used by snapshot files which */
1:e178ff4:     public final Gauge<Long> trueSnapshotsSize;
1:eae3b02:     /** Row cache hits, but result out of range */
1:eae3b02:     public final Counter rowCacheHitOutOfRange;
1:eae3b02:     /** Number of row cache hits */
1:eae3b02:     public final Counter rowCacheHit;
1:eae3b02:     /** Number of row cache misses */
1:eae3b02:     public final Counter rowCacheMiss;
1:1bd6960:     /** CAS Prepare metrics */
1:1bd6960:     public final LatencyMetrics casPrepare;
1:1bd6960:     /** CAS Propose metrics */
1:1bd6960:     public final LatencyMetrics casPropose;
1:1bd6960:     /** CAS Commit metrics */
1:1bd6960:     public final LatencyMetrics casCommit;
1:9b47dd5:     /** percent of the data that is repaired */
1:9b47dd5:     public final Gauge<Double> percentRepaired;
1:8896a70: 
1:8693a26:     public final Timer coordinatorReadLatency;
1:8693a26:     public final Timer coordinatorScanLatency;
1:ca16e5b: 
1:4b54b8a:     /** Time spent waiting for free memtable space, either on- or off-heap */
1:8896a70:     public final Histogram waitingOnFreeMemtableSpace;
1:5b8ac8c: 
1:66d3428:     /** Dropped Mutations Count */
1:66d3428:     public final Counter droppedMutations;
1:66d3428: 
1:69cedbf:     private final MetricNameFactory factory;
1:0bd5170:     private final MetricNameFactory aliasFactory;
1:0bd5170:     private static final MetricNameFactory globalFactory = new AllTableMetricNameFactory("Table");
1:0bd5170:     private static final MetricNameFactory globalAliasFactory = new AllTableMetricNameFactory("ColumnFamily");
1:5b8ac8c: 
1:8693a26:     public final Counter speculativeRetries;
1:5b8ac8c: 
1:0bd5170:     public final static LatencyMetrics globalReadLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Read");
1:0bd5170:     public final static LatencyMetrics globalWriteLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Write");
1:0bd5170:     public final static LatencyMetrics globalRangeLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Range");
1:0bd5170: 
1:9b47dd5:     public final static Gauge<Double> globalPercentRepaired = Metrics.register(globalFactory.createMetricName("PercentRepaired"),
1:9b47dd5:             new Gauge<Double>()
1:9b47dd5:     {
1:8896a70:         public Double getValue()
1:9b47dd5:         {
1:9b47dd5:             double repaired = 0;
1:9b47dd5:             double total = 0;
1:9b47dd5:             for (String keyspace : Schema.instance.getNonSystemKeyspaces())
1:9b47dd5:             {
1:9b47dd5:                 Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);
1:9797511:                 if (SchemaConstants.DISTRIBUTED_KEYSPACE_NAME.equals(k.getName()))
1:9b47dd5:                     continue;
1:9b47dd5:                 if (k.getReplicationStrategy().getReplicationFactor() < 2)
1:9b47dd5:                     continue;
1:9b47dd5: 
1:9b47dd5:                 for (ColumnFamilyStore cf : k.getColumnFamilyStores())
1:9b47dd5:                 {
1:9b47dd5:                     if (!SecondaryIndexManager.isIndexColumnFamily(cf.name))
1:9b47dd5:                     {
1:9b47dd5:                         for (SSTableReader sstable : cf.getSSTables(SSTableSet.CANONICAL))
1:9b47dd5:                         {
1:9b47dd5:                             if (sstable.isRepaired())
1:9b47dd5:                             {
1:9b47dd5:                                 repaired += sstable.uncompressedLength();
1:9b47dd5:                             }
1:9b47dd5:                             total += sstable.uncompressedLength();
1:9b47dd5:                         }
1:9b47dd5:                     }
1:9b47dd5:                 }
1:9b47dd5:             }
1:9b47dd5:             return total > 0 ? (repaired / total) * 100 : 100.0;
1:9b47dd5:         }
1:9b47dd5:     });
1:0bd5170: 
1:faf9181:     public final Map<Sampler, TopKSampler<ByteBuffer>> samplers;
1:5b8ac8c:     /**
1:5b8ac8c:      * stores metrics that will be rolled into a single global metric
1:5b8ac8c:      */
1:0bd5170:     public final static ConcurrentMap<String, Set<Metric>> allTableMetrics = Maps.newConcurrentMap();
1:0bd5170: 
1:5b8ac8c:     /**
1:0bd5170:      * Stores all metric names created that can be used when unregistering, optionally mapped to an alias name.
1:5b8ac8c:      */
1:0bd5170:     public final static Map<String, String> all = Maps.newHashMap();
1:0bd5170: 
1:9685622:     private interface GetHistogram
1:ae04861:     {
1:0bd5170:         EstimatedHistogram getHistogram(SSTableReader reader);
1:e3a88b9:     }
1:9b47dd5: 
1:9685622:     private static long[] combineHistograms(Iterable<SSTableReader> sstables, GetHistogram getHistogram)
1:ae04861:     {
1:9685622:         Iterator<SSTableReader> iterator = sstables.iterator();
1:9685622:         if (!iterator.hasNext())
1:e3a88b9:         {
1:0f5e780:             return EMPTY;
1:5b8ac8c:         }
1:9685622:         long[] firstBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);
1:9685622:         long[] values = new long[firstBucket.length];
1:9685622:         System.arraycopy(firstBucket, 0, values, 0, values.length);
1:faf9181: 
1:9685622:         while (iterator.hasNext())
1:e3a88b9:         {
1:9685622:             long[] nextBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);
1:9685622:             if (nextBucket.length > values.length)
1:faf9181:             {
1:9685622:                 long[] newValues = new long[nextBucket.length];
1:9685622:                 System.arraycopy(firstBucket, 0, newValues, 0, firstBucket.length);
1:9685622:                 for (int i = 0; i < newValues.length; i++)
1:5b8ac8c:                 {
1:9685622:                     newValues[i] += nextBucket[i];
1:5b8ac8c:                 }
1:9685622:                 values = newValues;
1:5b8ac8c:             }
1:9685622:             else
1:5b8ac8c:             {
1:9685622:                 for (int i = 0; i < values.length; i++)
1:5b8ac8c:                 {
1:9685622:                     values[i] += nextBucket[i];
1:94ff639:                 }
1:94ff639:             }
1:94ff639:         }
1:9685622:         return values;
1:94ff639:     }
1:0bd5170: 
1:94ff639:     /**
1:69cedbf:      * Creates metrics for given {@link ColumnFamilyStore}.
1:69cedbf:      *
1:69cedbf:      * @param cfs ColumnFamilyStore to measure metrics
1:94ff639:      */
1:0bd5170:     public TableMetrics(final ColumnFamilyStore cfs)
1:5b8ac8c:     {
1:0bd5170:         factory = new TableMetricNameFactory(cfs, "Table");
1:0bd5170:         aliasFactory = new TableMetricNameFactory(cfs, "ColumnFamily");
1:5b8ac8c: 
1:faf9181:         samplers = Maps.newHashMap();
1:faf9181:         for (Sampler sampler : Sampler.values())
1:faf9181:         {
1:0bd5170:             samplers.put(sampler, new TopKSampler<>());
1:faf9181:         }
1:faf9181: 
1:0bd5170:         memtableColumnsCount = createTableGauge("MemtableColumnsCount", new Gauge<Long>()
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:e5a76bd:                 return cfs.getTracker().getView().getCurrentMemtable().getOperations();
1:94ff639:             }
1:e3a88b9:         });
1:0bd5170:         memtableOnHeapSize = createTableGauge("MemtableOnHeapSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:e5a76bd:                 return cfs.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
1:94ff639:             }
1:d41a746:         });
1:0bd5170:         memtableOffHeapSize = createTableGauge("MemtableOffHeapSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:e5a76bd:                 return cfs.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
1:94ff639:             }
1:9685622:         });
1:0bd5170:         memtableLiveDataSize = createTableGauge("MemtableLiveDataSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:e5a76bd:                 return cfs.getTracker().getView().getCurrentMemtable().getLiveDataSize();
1:94ff639:             }
1:1a3b5db:         });
1:0bd5170:         allMemtablesOnHeapSize = createTableGauge("AllMemtablesHeapSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:4b54b8a:                 long size = 0;
1:4b54b8a:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
1:e5a76bd:                     size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
1:1a3b5db:                 return size;
1:94ff639:             }
1:1a3b5db:         });
1:0bd5170:         allMemtablesOffHeapSize = createTableGauge("AllMemtablesOffHeapSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:1a3b5db:                 long size = 0;
1:1a3b5db:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
1:e5a76bd:                     size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
1:4b54b8a:                 return size;
1:94ff639:             }
1:4b54b8a:         });
1:0bd5170:         allMemtablesLiveDataSize = createTableGauge("AllMemtablesLiveDataSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:4b54b8a:                 long size = 0;
1:4b54b8a:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
1:e5a76bd:                     size += cfs2.getTracker().getView().getCurrentMemtable().getLiveDataSize();
1:4b54b8a:                 return size;
1:94ff639:             }
1:4b54b8a:         });
1:0bd5170:         memtableSwitchCount = createTableCounter("MemtableSwitchCount");
1:0bd5170:         estimatedPartitionSizeHistogram = Metrics.register(factory.createMetricName("EstimatedPartitionSizeHistogram"),
1:0bd5170:                                                            aliasFactory.createMetricName("EstimatedRowSizeHistogram"),
1:0bd5170:                                                            new Gauge<long[]>()
1:0bd5170:                                                            {
1:8896a70:                                                                public long[] getValue()
1:0bd5170:                                                                {
1:ad8cad7:                                                                    return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()
1:0bd5170:                                                                    {
1:0bd5170:                                                                        public EstimatedHistogram getHistogram(SSTableReader reader)
1:0bd5170:                                                                        {
1:0bd5170:                                                                            return reader.getEstimatedPartitionSize();
1:0bd5170:                                                                        }
1:0bd5170:                                                                    });
1:0bd5170:                                                                }
1:0bd5170:                                                            });
1:0bd5170:         estimatedPartitionCount = Metrics.register(factory.createMetricName("EstimatedPartitionCount"),
1:0bd5170:                                                    aliasFactory.createMetricName("EstimatedRowCount"),
1:0bd5170:                                                    new Gauge<Long>()
1:0bd5170:                                                    {
1:8896a70:                                                        public Long getValue()
1:0bd5170:                                                        {
1:0bd5170:                                                            long memtablePartitions = 0;
1:0bd5170:                                                            for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())
1:0bd5170:                                                                memtablePartitions += memtable.partitionCount();
1:ad8cad7:                                                            return SSTableReader.getApproximateKeyCount(cfs.getSSTables(SSTableSet.CANONICAL)) + memtablePartitions;
1:0bd5170:                                                        }
1:0bd5170:                                                    });
1:0bd5170:         estimatedColumnCountHistogram = Metrics.register(factory.createMetricName("EstimatedColumnCountHistogram"),
1:0bd5170:                                                          aliasFactory.createMetricName("EstimatedColumnCountHistogram"),
1:0bd5170:                                                          new Gauge<long[]>()
1:0bd5170:                                                          {
1:8896a70:                                                              public long[] getValue()
1:0bd5170:                                                              {
1:ad8cad7:                                                                  return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()
1:0bd5170:                                                                  {
1:0bd5170:                                                                      public EstimatedHistogram getHistogram(SSTableReader reader)
1:0bd5170:                                                                      {
1:0bd5170:                                                                          return reader.getEstimatedColumnCount();
1:0bd5170:                                                                      }
1:0bd5170:                                                                  });
1:ae04861:             }
1:ae04861:         });
1:5aa19cb:         sstablesPerReadHistogram = createTableHistogram("SSTablesPerReadHistogram", cfs.keyspace.metric.sstablesPerReadHistogram, true);
1:0bd5170:         compressionRatio = createTableGauge("CompressionRatio", new Gauge<Double>()
1:d41a746:         {
1:8896a70:             public Double getValue()
1:d41a746:             {
1:fa92ae6:                 return computeCompressionRatio(cfs.getSSTables(SSTableSet.CANONICAL));
1:d41a746:             }
1:5b8ac8c:         }, new Gauge<Double>() // global gauge
1:5b8ac8c:         {
1:8896a70:             public Double getValue()
1:5b8ac8c:             {
1:05660a5:                 List<SSTableReader> sstables = new ArrayList<>();
1:05660a5:                 Keyspace.all().forEach(ks -> sstables.addAll(ks.getAllSSTables(SSTableSet.CANONICAL)));
1:05660a5:                 return computeCompressionRatio(sstables);
1:5b8ac8c:             }
1:9685622:         });
1:9b47dd5:         percentRepaired = createTableGauge("PercentRepaired", new Gauge<Double>()
1:9b47dd5:         {
1:8896a70:             public Double getValue()
1:9b47dd5:             {
1:9b47dd5:                 double repaired = 0;
1:9b47dd5:                 double total = 0;
1:9b47dd5:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
1:9b47dd5:                 {
1:9b47dd5:                     if (sstable.isRepaired())
1:9b47dd5:                     {
1:9b47dd5:                         repaired += sstable.uncompressedLength();
1:9b47dd5:                     }
1:9b47dd5:                     total += sstable.uncompressedLength();
1:9b47dd5:                 }
1:9b47dd5:                 return total > 0 ? (repaired / total) * 100 : 100.0;
1:9b47dd5:             }
1:9b47dd5:         });
1:5b8ac8c:         readLatency = new LatencyMetrics(factory, "Read", cfs.keyspace.metric.readLatency, globalReadLatency);
1:5b8ac8c:         writeLatency = new LatencyMetrics(factory, "Write", cfs.keyspace.metric.writeLatency, globalWriteLatency);
1:5b8ac8c:         rangeLatency = new LatencyMetrics(factory, "Range", cfs.keyspace.metric.rangeLatency, globalRangeLatency);
1:0bd5170:         pendingFlushes = createTableCounter("PendingFlushes");
1:a0a9494:         bytesFlushed = createTableCounter("BytesFlushed");
1:a0a9494:         compactionBytesWritten = createTableCounter("CompactionBytesWritten");
1:0bd5170:         pendingCompactions = createTableGauge("PendingCompactions", new Gauge<Integer>()
1:94ff639:         {
1:8896a70:             public Integer getValue()
1:94ff639:             {
1:7df3a5c:                 return cfs.getCompactionStrategyManager().getEstimatedRemainingTasks();
1:7a14a77:             }
1:f5d632f:         });
1:0bd5170:         liveSSTableCount = createTableGauge("LiveSSTableCount", new Gauge<Integer>()
1:94ff639:         {
1:8896a70:             public Integer getValue()
1:94ff639:             {
1:ad8cad7:                 return cfs.getTracker().getView().liveSSTables().size();
1:7a14a77:             }
8:69cedbf:         });
1:0bd5170:         liveDiskSpaceUsed = createTableCounter("LiveDiskSpaceUsed");
1:0bd5170:         totalDiskSpaceUsed = createTableCounter("TotalDiskSpaceUsed");
1:0bd5170:         minPartitionSize = createTableGauge("MinPartitionSize", "MinRowSize", new Gauge<Long>()
1:7a14a77:         {
1:8896a70:             public Long getValue()
1:7a14a77:             {
1:69cedbf:                 long min = 0;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
1:7a14a77:                 {
1:0bd5170:                     if (min == 0 || sstable.getEstimatedPartitionSize().min() < min)
1:0bd5170:                         min = sstable.getEstimatedPartitionSize().min();
1:7a14a77:                 }
1:94ff639:                 return min;
8:9685622:             }
1:5b8ac8c:         }, new Gauge<Long>() // global gauge
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long min = Long.MAX_VALUE;
1:0bd5170:                 for (Metric cfGauge : allTableMetrics.get("MinPartitionSize"))
1:5b8ac8c:                 {
1:8896a70:                     min = Math.min(min, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
1:5b8ac8c:                 }
1:5b8ac8c:                 return min;
1:5b8ac8c:             }
1:69cedbf:         });
1:0bd5170:         maxPartitionSize = createTableGauge("MaxPartitionSize", "MaxRowSize", new Gauge<Long>()
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:94ff639:                 long max = 0;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
1:94ff639:                 {
1:0bd5170:                     if (sstable.getEstimatedPartitionSize().max() > max)
1:0bd5170:                         max = sstable.getEstimatedPartitionSize().max();
1:94ff639:                 }
1:94ff639:                 return max;
1:5b8ac8c:             }
1:5b8ac8c:         }, new Gauge<Long>() // global gauge
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long max = 0;
1:0bd5170:                 for (Metric cfGauge : allTableMetrics.get("MaxPartitionSize"))
1:94ff639:                 {
1:8896a70:                     max = Math.max(max, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
1:5b8ac8c:                 }
1:5b8ac8c:                 return max;
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         meanPartitionSize = createTableGauge("MeanPartitionSize", "MeanRowSize", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:94ff639:                 long sum = 0;
1:94ff639:                 long count = 0;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
1:94ff639:                 {
1:0bd5170:                     long n = sstable.getEstimatedPartitionSize().count();
1:0bd5170:                     sum += sstable.getEstimatedPartitionSize().mean() * n;
1:94ff639:                     count += n;
1:94ff639:                 }
1:94ff639:                 return count > 0 ? sum / count : 0;
1:5b8ac8c:             }
1:5b8ac8c:         }, new Gauge<Long>() // global gauge
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long sum = 0;
1:5b8ac8c:                 long count = 0;
1:5b8ac8c:                 for (Keyspace keyspace : Keyspace.all())
1:5b8ac8c:                 {
1:ad8cad7:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))
1:5b8ac8c:                     {
1:0bd5170:                         long n = sstable.getEstimatedPartitionSize().count();
1:0bd5170:                         sum += sstable.getEstimatedPartitionSize().mean() * n;
1:5b8ac8c:                         count += n;
1:5b8ac8c:                     }
1:5b8ac8c:                 }
1:5b8ac8c:                 return count > 0 ? sum / count : 0;
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         bloomFilterFalsePositives = createTableGauge("BloomFilterFalsePositives", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:9685622:             {
1:69cedbf:                 long count = 0L;
1:ad8cad7:                 for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
1:69cedbf:                     count += sstable.getBloomFilterFalsePositiveCount();
1:69cedbf:                 return count;
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         recentBloomFilterFalsePositives = createTableGauge("RecentBloomFilterFalsePositives", new Gauge<Long>()
1:9685622:         {
1:8896a70:             public Long getValue()
1:9685622:             {
1:69cedbf:                 long count = 0L;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
1:69cedbf:                     count += sstable.getRecentBloomFilterFalsePositiveCount();
1:69cedbf:                 return count;
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         bloomFilterFalseRatio = createTableGauge("BloomFilterFalseRatio", new Gauge<Double>()
1:9685622:         {
1:8896a70:             public Double getValue()
1:9685622:             {
1:94ff639:                 long falseCount = 0L;
1:94ff639:                 long trueCount = 0L;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
1:94ff639:                 {
1:94ff639:                     falseCount += sstable.getBloomFilterFalsePositiveCount();
1:94ff639:                     trueCount += sstable.getBloomFilterTruePositiveCount();
1:94ff639:                 }
1:94ff639:                 if (falseCount == 0L && trueCount == 0L)
1:94ff639:                     return 0d;
1:94ff639:                 return (double) falseCount / (trueCount + falseCount);
1:5b8ac8c:             }
1:5b8ac8c:         }, new Gauge<Double>() // global gauge
1:5b8ac8c:         {
1:8896a70:             public Double getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long falseCount = 0L;
1:5b8ac8c:                 long trueCount = 0L;
1:5b8ac8c:                 for (Keyspace keyspace : Keyspace.all())
1:5b8ac8c:                 {
1:ad8cad7:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
1:5b8ac8c:                     {
1:5b8ac8c:                         falseCount += sstable.getBloomFilterFalsePositiveCount();
1:5b8ac8c:                         trueCount += sstable.getBloomFilterTruePositiveCount();
1:5b8ac8c:                     }
1:5b8ac8c:                 }
1:5b8ac8c:                 if (falseCount == 0L && trueCount == 0L)
1:5b8ac8c:                     return 0d;
1:5b8ac8c:                 return (double) falseCount / (trueCount + falseCount);
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         recentBloomFilterFalseRatio = createTableGauge("RecentBloomFilterFalseRatio", new Gauge<Double>()
1:5b8ac8c:         {
1:9b47dd5:             public Double getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long falseCount = 0L;
1:5b8ac8c:                 long trueCount = 0L;
1:ad8cad7:                 for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
1:5b8ac8c:                 {
1:5b8ac8c:                     falseCount += sstable.getRecentBloomFilterFalsePositiveCount();
1:5b8ac8c:                     trueCount += sstable.getRecentBloomFilterTruePositiveCount();
1:5b8ac8c:                 }
1:5b8ac8c:                 if (falseCount == 0L && trueCount == 0L)
1:5b8ac8c:                     return 0d;
1:5b8ac8c:                 return (double) falseCount / (trueCount + falseCount);
1:5b8ac8c:             }
1:5b8ac8c:         }, new Gauge<Double>() // global gauge
1:5b8ac8c:         {
1:9b47dd5:             public Double getValue()
1:94ff639:             {
1:94ff639:                 long falseCount = 0L;
1:94ff639:                 long trueCount = 0L;
1:5b8ac8c:                 for (Keyspace keyspace : Keyspace.all())
1:94ff639:                 {
1:ad8cad7:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
1:94ff639:                     {
1:94ff639:                         falseCount += sstable.getRecentBloomFilterFalsePositiveCount();
1:94ff639:                         trueCount += sstable.getRecentBloomFilterTruePositiveCount();
1:5b8ac8c:                     }
1:94ff639:                 }
1:94ff639:                 if (falseCount == 0L && trueCount == 0L)
1:94ff639:                     return 0d;
1:94ff639:                 return (double) falseCount / (trueCount + falseCount);
1:94ff639:             }
1:69cedbf:         });
1:0bd5170:         bloomFilterDiskSpaceUsed = createTableGauge("BloomFilterDiskSpaceUsed", new Gauge<Long>()
1:9685622:         {
1:8896a70:             public Long getValue()
1:9685622:             {
1:94ff639:                 long total = 0;
1:ad8cad7:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.CANONICAL))
1:69cedbf:                     total += sst.getBloomFilterSerializedSize();
1:94ff639:                 return total;
1:94ff639:             }
1:94ff639:         });
1:0bd5170:         bloomFilterOffHeapMemoryUsed = createTableGauge("BloomFilterOffHeapMemoryUsed", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:94ff639:                 long total = 0;
1:ad8cad7:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
1:7a14a77:                     total += sst.getBloomFilterOffHeapSize();
1:94ff639:                 return total;
1:94ff639:             }
1:94ff639:         });
1:0bd5170:         indexSummaryOffHeapMemoryUsed = createTableGauge("IndexSummaryOffHeapMemoryUsed", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
2:7a14a77:                 long total = 0;
1:ad8cad7:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
1:7a14a77:                     total += sst.getIndexSummaryOffHeapSize();
2:7a14a77:                 return total;
1:94ff639:             }
1:7a14a77:         });
1:0bd5170:         compressionMetadataOffHeapMemoryUsed = createTableGauge("CompressionMetadataOffHeapMemoryUsed", new Gauge<Long>()
1:94ff639:         {
1:8896a70:             public Long getValue()
1:94ff639:             {
1:7a14a77:                 long total = 0;
1:ad8cad7:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
1:7a14a77:                     total += sst.getCompressionMetadataOffHeapSize();
1:7a14a77:                 return total;
1:94ff639:             }
1:7a14a77:         });
1:0bd5170:         speculativeRetries = createTableCounter("SpeculativeRetries");
1:0bd5170:         keyCacheHitRate = Metrics.register(factory.createMetricName("KeyCacheHitRate"),
1:0bd5170:                                            aliasFactory.createMetricName("KeyCacheHitRate"),
1:0bd5170:                                            new RatioGauge()
1:94ff639:         {
1:8896a70:             @Override
1:8896a70:             public Ratio getRatio()
1:8896a70:             {
1:8896a70:                 return Ratio.of(getNumerator(), getDenominator());
1:8896a70:             }
1:8896a70: 
1:f5d632f:             protected double getNumerator()
1:94ff639:             {
1:f5d632f:                 long hits = 0L;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
1:f5d632f:                     hits += sstable.getKeyCacheHit();
1:f5d632f:                 return hits;
1:94ff639:             }
1:5b8ac8c: 
1:f5d632f:             protected double getDenominator()
1:94ff639:             {
1:f5d632f:                 long requests = 0L;
1:ad8cad7:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
1:f5d632f:                     requests += sstable.getKeyCacheRequest();
1:f5d632f:                 return Math.max(requests, 1); // to avoid NaN.
1:94ff639:             }
1:7a14a77:         });
1:5aa19cb:         tombstoneScannedHistogram = createTableHistogram("TombstoneScannedHistogram", cfs.keyspace.metric.tombstoneScannedHistogram, false);
1:5aa19cb:         liveScannedHistogram = createTableHistogram("LiveScannedHistogram", cfs.keyspace.metric.liveScannedHistogram, false);
1:5aa19cb:         colUpdateTimeDeltaHistogram = createTableHistogram("ColUpdateTimeDeltaHistogram", cfs.keyspace.metric.colUpdateTimeDeltaHistogram, false);
1:8896a70:         coordinatorReadLatency = Metrics.timer(factory.createMetricName("CoordinatorReadLatency"));
1:8896a70:         coordinatorScanLatency = Metrics.timer(factory.createMetricName("CoordinatorScanLatency"));
1:5aa19cb:         waitingOnFreeMemtableSpace = Metrics.histogram(factory.createMetricName("WaitingOnFreeMemtableSpace"), false);
1:5b8ac8c: 
1:62ffa35:         // We do not want to capture view mutation specific metrics for a view
1:62ffa35:         // They only makes sense to capture on the base table
1:62ffa35:         if (cfs.metadata.isView())
1:62ffa35:         {
1:62ffa35:             viewLockAcquireTime = null;
1:62ffa35:             viewReadTime = null;
1:62ffa35:         }
1:62ffa35:         else
1:62ffa35:         {
1:62ffa35:             viewLockAcquireTime = createTableTimer("ViewLockAcquireTime", cfs.keyspace.metric.viewLockAcquireTime);
1:62ffa35:             viewReadTime = createTableTimer("ViewReadTime", cfs.keyspace.metric.viewReadTime);
1:62ffa35:         }
1:62ffa35: 
1:0bd5170:         trueSnapshotsSize = createTableGauge("SnapshotsSize", new Gauge<Long>()
1:7a14a77:         {
1:8896a70:             public Long getValue()
1:7a14a77:             {
1:e178ff4:                 return cfs.trueSnapshotsSize();
1:94ff639:             }
1:e178ff4:         });
1:eae3b02:         rowCacheHitOutOfRange = createTableCounter("RowCacheHitOutOfRange");
1:eae3b02:         rowCacheHit = createTableCounter("RowCacheHit");
1:eae3b02:         rowCacheMiss = createTableCounter("RowCacheMiss");
1:66d3428:         droppedMutations = createTableCounter("DroppedMutations");
1:5b8ac8c: 
1:1bd6960:         casPrepare = new LatencyMetrics(factory, "CasPrepare", cfs.keyspace.metric.casPrepare);
1:1bd6960:         casPropose = new LatencyMetrics(factory, "CasPropose", cfs.keyspace.metric.casPropose);
1:1bd6960:         casCommit = new LatencyMetrics(factory, "CasCommit", cfs.keyspace.metric.casCommit);
1:94ff639:     }
1:5b8ac8c: 
1:69cedbf:     public void updateSSTableIterated(int count)
1:7a14a77:     {
1:69cedbf:         sstablesPerReadHistogram.update(count);
1:94ff639:     }
1:94ff639: 
1:94ff639:     /**
1:69cedbf:      * Release all associated metrics.
1:94ff639:      */
1:69cedbf:     public void release()
1:5b8ac8c:     {
1:0bd5170:         for(Map.Entry<String, String> entry : all.entrySet())
1:94ff639:         {
1:0bd5170:             CassandraMetricsRegistry.MetricName name = factory.createMetricName(entry.getKey());
1:0bd5170:             CassandraMetricsRegistry.MetricName alias = aliasFactory.createMetricName(entry.getValue());
1:0bd5170:             allTableMetrics.get(entry.getKey()).remove(Metrics.getMetrics().get(name.getMetricName()));
1:0bd5170:             Metrics.remove(name, alias);
1:5b8ac8c:         }
1:69cedbf:         readLatency.release();
1:69cedbf:         writeLatency.release();
1:05ffa8f:         rangeLatency.release();
1:0bd5170:         Metrics.remove(factory.createMetricName("EstimatedPartitionSizeHistogram"), aliasFactory.createMetricName("EstimatedRowSizeHistogram"));
1:0bd5170:         Metrics.remove(factory.createMetricName("EstimatedPartitionCount"), aliasFactory.createMetricName("EstimatedRowCount"));
1:0bd5170:         Metrics.remove(factory.createMetricName("EstimatedColumnCountHistogram"), aliasFactory.createMetricName("EstimatedColumnCountHistogram"));
1:0bd5170:         Metrics.remove(factory.createMetricName("KeyCacheHitRate"), aliasFactory.createMetricName("KeyCacheHitRate"));
1:0bd5170:         Metrics.remove(factory.createMetricName("CoordinatorReadLatency"), aliasFactory.createMetricName("CoordinatorReadLatency"));
1:0bd5170:         Metrics.remove(factory.createMetricName("CoordinatorScanLatency"), aliasFactory.createMetricName("CoordinatorScanLatency"));
1:0bd5170:         Metrics.remove(factory.createMetricName("WaitingOnFreeMemtableSpace"), aliasFactory.createMetricName("WaitingOnFreeMemtableSpace"));
1:94ff639:     }
1:5b8ac8c: 
1:5b8ac8c: 
1:5b8ac8c:     /**
1:5b8ac8c:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
1:0bd5170:      * will merge each CF gauge by adding their values
1:5b8ac8c:      */
1:0bd5170:     protected <T extends Number> Gauge<T> createTableGauge(final String name, Gauge<T> gauge)
1:5b8ac8c:     {
1:0bd5170:         return createTableGauge(name, gauge, new Gauge<Long>()
1:5b8ac8c:         {
1:8896a70:             public Long getValue()
1:5b8ac8c:             {
1:5b8ac8c:                 long total = 0;
1:0bd5170:                 for (Metric cfGauge : allTableMetrics.get(name))
1:5b8ac8c:                 {
1:8896a70:                     total = total + ((Gauge<? extends Number>) cfGauge).getValue().longValue();
1:5b8ac8c:                 }
1:5b8ac8c:                 return total;
1:5b8ac8c:             }
1:5b8ac8c:         });
1:5b8ac8c:     }
1:5b8ac8c: 
1:5b8ac8c:     /**
1:5b8ac8c:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
1:5b8ac8c:      * is defined as the globalGauge parameter
1:5b8ac8c:      */
1:0bd5170:     protected <G,T> Gauge<T> createTableGauge(String name, Gauge<T> gauge, Gauge<G> globalGauge)
1:5b8ac8c:     {
1:0bd5170:         return createTableGauge(name, name, gauge, globalGauge);
1:0bd5170:     }
1:0bd5170: 
1:0bd5170:     protected <G,T> Gauge<T> createTableGauge(String name, String alias, Gauge<T> gauge, Gauge<G> globalGauge)
1:0bd5170:     {
1:0bd5170:         Gauge<T> cfGauge = Metrics.register(factory.createMetricName(name), aliasFactory.createMetricName(alias), gauge);
1:0bd5170:         if (register(name, alias, cfGauge))
1:5b8ac8c:         {
1:0bd5170:             Metrics.register(globalFactory.createMetricName(name), globalAliasFactory.createMetricName(alias), globalGauge);
1:5b8ac8c:         }
1:5b8ac8c:         return cfGauge;
1:5b8ac8c:     }
1:0bd5170: 
1:5b8ac8c:     /**
1:0bd5170:      * Creates a counter that will also have a global counter thats the sum of all counters across
1:5b8ac8c:      * different column families
1:5b8ac8c:      */
1:0bd5170:     protected Counter createTableCounter(final String name)
1:5b8ac8c:     {
1:0bd5170:         return createTableCounter(name, name);
1:0bd5170:     }
1:0bd5170: 
1:0bd5170:     protected Counter createTableCounter(final String name, final String alias)
1:0bd5170:     {
1:0bd5170:         Counter cfCounter = Metrics.counter(factory.createMetricName(name), aliasFactory.createMetricName(alias));
1:0bd5170:         if (register(name, alias, cfCounter))
1:5b8ac8c:         {
1:0bd5170:             Metrics.register(globalFactory.createMetricName(name),
1:0bd5170:                              globalAliasFactory.createMetricName(alias),
1:0bd5170:                              new Gauge<Long>()
1:5b8ac8c:             {
1:0bd5170:                 public Long getValue()
1:5b8ac8c:                 {
1:5b8ac8c:                     long total = 0;
1:0bd5170:                     for (Metric cfGauge : allTableMetrics.get(name))
1:5b8ac8c:                     {
1:8896a70:                         total += ((Counter) cfGauge).getCount();
1:5b8ac8c:                     }
1:5b8ac8c:                     return total;
1:5b8ac8c:                 }
1:5b8ac8c:             });
1:5b8ac8c:         }
1:5b8ac8c:         return cfCounter;
1:5b8ac8c:     }
1:0bd5170: 
1:5b8ac8c:     /**
1:fa92ae6:      * Computes the compression ratio for the specified SSTables
1:fa92ae6:      *
1:fa92ae6:      * @param sstables the SSTables
1:fa92ae6:      * @return the compression ratio for the specified SSTables
1:fa92ae6:      */
1:fa92ae6:     private static Double computeCompressionRatio(Iterable<SSTableReader> sstables)
1:fa92ae6:     {
1:fa92ae6:         double compressedLengthSum = 0;
1:fa92ae6:         double dataLengthSum = 0;
1:fa92ae6:         for (SSTableReader sstable : sstables)
1:fa92ae6:         {
1:fa92ae6:             if (sstable.compression)
1:fa92ae6:             {
1:fa92ae6:                 // We should not have any sstable which are in an open early mode as the sstable were selected
1:fa92ae6:                 // using SSTableSet.CANONICAL.
1:fa92ae6:                 assert sstable.openReason != SSTableReader.OpenReason.EARLY;
1:0bd5170: 
1:fa92ae6:                 CompressionMetadata compressionMetadata = sstable.getCompressionMetadata();
1:fa92ae6:                 compressedLengthSum += compressionMetadata.compressedFileLength;
1:fa92ae6:                 dataLengthSum += compressionMetadata.dataLength;
1:fa92ae6:             }
1:fa92ae6:         }
1:10649b1:         return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : MetadataCollector.NO_COMPRESSION_RATIO;
1:fa92ae6:     }
1:fa92ae6: 
1:fa92ae6:     /**
1:5b8ac8c:      * Create a histogram-like interface that will register both a CF, keyspace and global level
1:5b8ac8c:      * histogram and forward any updates to both
1:5b8ac8c:      */
1:5aa19cb:     protected TableHistogram createTableHistogram(String name, Histogram keyspaceHistogram, boolean considerZeroes)
1:0bd5170:     {
1:5aa19cb:         return createTableHistogram(name, name, keyspaceHistogram, considerZeroes);
1:0bd5170:     }
1:8896a70: 
1:5aa19cb:     protected TableHistogram createTableHistogram(String name, String alias, Histogram keyspaceHistogram, boolean considerZeroes)
1:5b8ac8c:     {
1:5aa19cb:         Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias), considerZeroes);
1:0bd5170:         register(name, alias, cfHistogram);
1:0bd5170:         return new TableHistogram(cfHistogram,
1:0bd5170:                                   keyspaceHistogram,
1:0bd5170:                                   Metrics.histogram(globalFactory.createMetricName(name),
1:5aa19cb:                                                     globalAliasFactory.createMetricName(alias),
1:5aa19cb:                                                     considerZeroes));
1:5b8ac8c:     }
1:fa92ae6: 
1:62ffa35:     protected TableTimer createTableTimer(String name, Timer keyspaceTimer)
1:62ffa35:     {
1:62ffa35:         return createTableTimer(name, name, keyspaceTimer);
1:62ffa35:     }
1:62ffa35: 
1:62ffa35:     protected TableTimer createTableTimer(String name, String alias, Timer keyspaceTimer)
1:62ffa35:     {
1:62ffa35:         Timer cfTimer = Metrics.timer(factory.createMetricName(name), aliasFactory.createMetricName(alias));
1:62ffa35:         register(name, alias, cfTimer);
1:62ffa35:         return new TableTimer(cfTimer,
1:62ffa35:                               keyspaceTimer,
1:62ffa35:                               Metrics.timer(globalFactory.createMetricName(name),
1:0bd5170:                                             globalAliasFactory.createMetricName(alias)));
1:62ffa35:     }
1:62ffa35: 
1:5b8ac8c:     /**
1:5b8ac8c:      * Registers a metric to be removed when unloading CF.
1:5b8ac8c:      * @return true if first time metric with that name has been registered
1:5b8ac8c:      */
1:0bd5170:     private boolean register(String name, String alias, Metric metric)
1:0bd5170:     {
1:52be7ba:         boolean ret = allTableMetrics.putIfAbsent(name, ConcurrentHashMap.newKeySet()) == null;
1:0bd5170:         allTableMetrics.get(name).add(metric);
1:0bd5170:         all.put(name, alias);
1:5b8ac8c:         return ret;
1:5b8ac8c:     }
1:0bd5170: 
1:0bd5170:     public static class TableHistogram
1:5b8ac8c:     {
1:5b8ac8c:         public final Histogram[] all;
1:5b8ac8c:         public final Histogram cf;
1:0bd5170:         private TableHistogram(Histogram cf, Histogram keyspace, Histogram global)
1:5b8ac8c:         {
1:5b8ac8c:             this.cf = cf;
1:5b8ac8c:             this.all = new Histogram[]{cf, keyspace, global};
1:5b8ac8c:         }
1:8896a70: 
1:8896a70:         public void update(long i)
1:5b8ac8c:         {
1:5b8ac8c:             for(Histogram histo : all)
1:5b8ac8c:             {
1:5b8ac8c:                 histo.update(i);
1:5b8ac8c:             }
1:5b8ac8c:         }
1:5b8ac8c:     }
1:5b8ac8c: 
1:62ffa35:     public static class TableTimer
1:62ffa35:     {
1:62ffa35:         public final Timer[] all;
1:62ffa35:         public final Timer cf;
1:62ffa35:         private TableTimer(Timer cf, Timer keyspace, Timer global)
1:62ffa35:         {
1:62ffa35:             this.cf = cf;
1:62ffa35:             this.all = new Timer[]{cf, keyspace, global};
1:62ffa35:         }
1:62ffa35: 
1:62ffa35:         public void update(long i, TimeUnit unit)
1:62ffa35:         {
1:62ffa35:             for(Timer timer : all)
1:62ffa35:             {
1:62ffa35:                 timer.update(i, unit);
1:62ffa35:             }
1:62ffa35:         }
1:62ffa35:     }
1:62ffa35: 
1:0bd5170:     static class TableMetricNameFactory implements MetricNameFactory
1:5b8ac8c:     {
1:69cedbf:         private final String keyspaceName;
1:0bd5170:         private final String tableName;
1:69cedbf:         private final boolean isIndex;
1:0bd5170:         private final String type;
1:5b8ac8c: 
1:0bd5170:         TableMetricNameFactory(ColumnFamilyStore cfs, String type)
1:94ff639:         {
1:0e96e58:             this.keyspaceName = cfs.keyspace.getName();
1:0bd5170:             this.tableName = cfs.name;
1:0bd5170:             this.isIndex = cfs.isIndex();
1:0bd5170:             this.type = type;
1:94ff639:         }
1:5b8ac8c: 
1:8896a70:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
1:94ff639:         {
1:0bd5170:             String groupName = TableMetrics.class.getPackage().getName();
1:0bd5170:             String type = isIndex ? "Index" + this.type : this.type;
2:94ff639: 
1:5b8ac8c:             StringBuilder mbeanName = new StringBuilder();
1:5b8ac8c:             mbeanName.append(groupName).append(":");
1:3c95d47:             mbeanName.append("type=").append(type);
1:69cedbf:             mbeanName.append(",keyspace=").append(keyspaceName);
1:0bd5170:             mbeanName.append(",scope=").append(tableName);
1:5b8ac8c:             mbeanName.append(",name=").append(metricName);
1:94ff639: 
1:0bd5170:             return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, keyspaceName + "." + tableName, mbeanName.toString());
1:5b8ac8c:         }
1:5b8ac8c:     }
1:0bd5170: 
1:0bd5170:     static class AllTableMetricNameFactory implements MetricNameFactory
1:94ff639:     {
1:0bd5170:         private final String type;
1:0bd5170:         public AllTableMetricNameFactory(String type)
1:0bd5170:         {
1:0bd5170:             this.type = type;
1:0bd5170:         }
1:0bd5170: 
1:8896a70:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
1:94ff639:         {
1:0bd5170:             String groupName = TableMetrics.class.getPackage().getName();
1:94ff639:             StringBuilder mbeanName = new StringBuilder();
1:94ff639:             mbeanName.append(groupName).append(":");
1:69cedbf:             mbeanName.append("type=").append(type);
1:94ff639:             mbeanName.append(",name=").append(metricName);
1:0bd5170:             return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, "all", mbeanName.toString());
1:94ff639:         }
1:94ff639:     }
1:94ff639: 
1:0bd5170:     public enum Sampler
1:94ff639:     {
1:faf9181:         READS, WRITES
1:faf9181:     }
1:94ff639: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:3c95d47
/////////////////////////////////////////////////////////////////////////
1:             mbeanName.append("type=").append(type);
commit:be13d35
/////////////////////////////////////////////////////////////////////////
0:     public static class ColumnFamilyHistogram
/////////////////////////////////////////////////////////////////////////
0:     static class ColumnFamilyMetricNameFactory implements MetricNameFactory
commit:48a7e64
/////////////////////////////////////////////////////////////////////////
0:             allColumnFamilyMetrics.get(name).remove(Metrics.getMetrics().get(factory.createMetricName(name).getMetricName()));
commit:686a17c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.SSTableMetadata;
/////////////////////////////////////////////////////////////////////////
0:                     if (sstable.getCompressionRatio() != SSTableMetadata.NO_COMPRESSION_RATIO)
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:05660a5
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
1: import com.google.common.collect.Maps;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 List<SSTableReader> sstables = new ArrayList<>();
1:                 Keyspace.all().forEach(ks -> sstables.addAll(ks.getAllSSTables(SSTableSet.CANONICAL)));
1:                 return computeCompressionRatio(sstables);
commit:868e720
commit:05ffa8f
/////////////////////////////////////////////////////////////////////////
1:     /** (Local) range slice metrics */
1:     public final LatencyMetrics rangeLatency;
/////////////////////////////////////////////////////////////////////////
0:         rangeLatency = new LatencyMetrics(factory, "Range");
/////////////////////////////////////////////////////////////////////////
1:         rangeLatency.release();
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (SchemaConstants.DISTRIBUTED_KEYSPACE_NAME.equals(k.getName()))
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static final long[] EMPTY = new long[0];
1: 
/////////////////////////////////////////////////////////////////////////
1:             return EMPTY;
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:10649b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
/////////////////////////////////////////////////////////////////////////
1:         return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : MetadataCollector.NO_COMPRESSION_RATIO;
commit:8896a70
/////////////////////////////////////////////////////////////////////////
1: import com.codahale.metrics.*;
1: import com.codahale.metrics.Timer;
/////////////////////////////////////////////////////////////////////////
1: 
1: import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public final Histogram waitingOnFreeMemtableSpace;
0:     private static final MetricNameFactory globalNameFactory = new AllColumnFamilyMetricNameFactory();
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
1:             public Long getValue()
1:             public Long getValue()
1:             public Long getValue()
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
0:         estimatedRowSizeHistogram = Metrics.register(factory.createMetricName("EstimatedRowSizeHistogram"), new Gauge<long[]>()
1:             public long[] getValue()
/////////////////////////////////////////////////////////////////////////
0:         estimatedColumnCountHistogram = Metrics.register(factory.createMetricName("EstimatedColumnCountHistogram"), new Gauge<long[]>()
1:             public long[] getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Integer getValue()
1:             public Integer getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
1:                     min = Math.min(min, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
1:                     max = Math.max(max, ((Gauge<? extends Number>) cfGauge).getValue().longValue());
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Double getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
0:         keyCacheHitRate = Metrics.register(factory.createMetricName("KeyCacheHitRate"), new RatioGauge()
1:             @Override
1:             public Ratio getRatio()
1:             {
1:                 return Ratio.of(getNumerator(), getDenominator());
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         coordinatorReadLatency = Metrics.timer(factory.createMetricName("CoordinatorReadLatency"));
1:         coordinatorScanLatency = Metrics.timer(factory.createMetricName("CoordinatorScanLatency"));
0:         waitingOnFreeMemtableSpace = Metrics.histogram(factory.createMetricName("WaitingOnFreeMemtableSpace"));
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             allColumnFamilyMetrics.get(name).remove(Metrics.getMetrics().get(factory.createMetricName(name)));
0:             Metrics.remove(factory.createMetricName(name));
0:         Metrics.remove(factory.createMetricName("EstimatedRowSizeHistogram"));
0:         Metrics.remove(factory.createMetricName("EstimatedColumnCountHistogram"));
0:         Metrics.remove(factory.createMetricName("KeyCacheHitRate"));
0:         Metrics.remove(factory.createMetricName("CoordinatorReadLatency"));
0:         Metrics.remove(factory.createMetricName("CoordinatorScanLatency"));
0:         Metrics.remove(factory.createMetricName("WaitingOnFreeMemtableSpace"));
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue()
1:                     total = total + ((Gauge<? extends Number>) cfGauge).getValue().longValue();
/////////////////////////////////////////////////////////////////////////
0:         Gauge<T> cfGauge = Metrics.register(factory.createMetricName(name), gauge);
0:             Metrics.register(globalNameFactory.createMetricName(name), globalGauge);
/////////////////////////////////////////////////////////////////////////
0:         Counter cfCounter = Metrics.counter(factory.createMetricName(name));
0:             Metrics.register(globalNameFactory.createMetricName(name), new Gauge<Long>()
1:                 public Long getValue()
1:                         total += ((Counter) cfGauge).getCount();
/////////////////////////////////////////////////////////////////////////
0:     protected ColumnFamilyHistogram createColumnFamilyHistogram(String name, Histogram keyspaceHistogram)
0:         Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name));
0:         return new ColumnFamilyHistogram(cfHistogram, keyspaceHistogram, Metrics.histogram(globalNameFactory.createMetricName(name)));
1: 
/////////////////////////////////////////////////////////////////////////
0:         private ColumnFamilyHistogram(Histogram cf, Histogram keyspace, Histogram global)
1: 
1:         public void update(long i)
/////////////////////////////////////////////////////////////////////////
1:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
/////////////////////////////////////////////////////////////////////////
0:             return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, keyspaceName + "." + columnFamilyName, mbeanName.toString());
1:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
0:             return new CassandraMetricsRegistry.MetricName(groupName, "ColumnFamily", metricName, "all", mbeanName.toString());
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:042e1f7
commit:eae3b02
/////////////////////////////////////////////////////////////////////////
1:     /** Row cache hits, but result out of range */
1:     public final Counter rowCacheHitOutOfRange;
1:     /** Number of row cache hits */
1:     public final Counter rowCacheHit;
1:     /** Number of row cache misses */
1:     public final Counter rowCacheMiss;
/////////////////////////////////////////////////////////////////////////
1:         rowCacheHitOutOfRange = createTableCounter("RowCacheHitOutOfRange");
1:         rowCacheHit = createTableCounter("RowCacheHit");
1:         rowCacheMiss = createTableCounter("RowCacheMiss");
commit:0bd5170
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class TableMetrics
1:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
1:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
/////////////////////////////////////////////////////////////////////////
1:     /** Histogram of estimated partition size (in bytes). */
1:     public final Gauge<long[]> estimatedPartitionSizeHistogram;
1:     public final Gauge<Long> estimatedPartitionCount;
1:     public final TableHistogram sstablesPerReadHistogram;
1:     /** Estimated number of tasks pending for this table */
1:     /** Estimate of number of pending compactios for this table */
1:     /** Disk space used by SSTables belonging to this table */
1:     /** Total disk space used by SSTables belonging to this table, including obsolete ones waiting to be GC'd */
1:     /** Size of the smallest compacted partition */
1:     public final Gauge<Long> minPartitionSize;
1:     /** Size of the largest compacted partition */
1:     public final Gauge<Long> maxPartitionSize;
1:     /** Size of the smallest compacted partition */
1:     public final Gauge<Long> meanPartitionSize;
/////////////////////////////////////////////////////////////////////////
1:     public final TableHistogram tombstoneScannedHistogram;
1:     public final TableHistogram liveScannedHistogram;
1:     public final TableHistogram colUpdateTimeDeltaHistogram;
0:     /** Partition cache hits, but result out of range */
0:     public final Counter partitionCacheHitOutOfRange;
0:     /** Number of partition cache hits */
0:     public final Counter partitionCacheHit;
0:     /** Number of partition cache misses */
0:     public final Counter partitionCacheMiss;
/////////////////////////////////////////////////////////////////////////
1:     private final MetricNameFactory aliasFactory;
1:     private static final MetricNameFactory globalFactory = new AllTableMetricNameFactory("Table");
1:     private static final MetricNameFactory globalAliasFactory = new AllTableMetricNameFactory("ColumnFamily");
1:     public final static LatencyMetrics globalReadLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Read");
1:     public final static LatencyMetrics globalWriteLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Write");
1:     public final static LatencyMetrics globalRangeLatency = new LatencyMetrics(globalFactory, globalAliasFactory, "Range");
1: 
1:     public final static ConcurrentMap<String, Set<Metric>> allTableMetrics = Maps.newConcurrentMap();
1: 
1:      * Stores all metric names created that can be used when unregistering, optionally mapped to an alias name.
1:     public final static Map<String, String> all = Maps.newHashMap();
1:         EstimatedHistogram getHistogram(SSTableReader reader);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public TableMetrics(final ColumnFamilyStore cfs)
1:         factory = new TableMetricNameFactory(cfs, "Table");
1:         aliasFactory = new TableMetricNameFactory(cfs, "ColumnFamily");
1:             samplers.put(sampler, new TopKSampler<>());
1:         memtableColumnsCount = createTableGauge("MemtableColumnsCount", new Gauge<Long>()
1:         memtableOnHeapSize = createTableGauge("MemtableOnHeapSize", new Gauge<Long>()
1:         memtableOffHeapSize = createTableGauge("MemtableOffHeapSize", new Gauge<Long>()
1:         memtableLiveDataSize = createTableGauge("MemtableLiveDataSize", new Gauge<Long>()
1:         allMemtablesOnHeapSize = createTableGauge("AllMemtablesHeapSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         allMemtablesOffHeapSize = createTableGauge("AllMemtablesOffHeapSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         allMemtablesLiveDataSize = createTableGauge("AllMemtablesLiveDataSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         memtableSwitchCount = createTableCounter("MemtableSwitchCount");
1:         estimatedPartitionSizeHistogram = Metrics.register(factory.createMetricName("EstimatedPartitionSizeHistogram"),
1:                                                            aliasFactory.createMetricName("EstimatedRowSizeHistogram"),
1:                                                            new Gauge<long[]>()
1:                                                            {
0:                                                                public long[] getValue()
1:                                                                {
0:                                                                    return combineHistograms(cfs.getSSTables(), new GetHistogram()
1:                                                                    {
1:                                                                        public EstimatedHistogram getHistogram(SSTableReader reader)
1:                                                                        {
1:                                                                            return reader.getEstimatedPartitionSize();
1:                                                                        }
1:                                                                    });
1:                                                                }
1:                                                            });
1:         estimatedPartitionCount = Metrics.register(factory.createMetricName("EstimatedPartitionCount"),
1:                                                    aliasFactory.createMetricName("EstimatedRowCount"),
1:                                                    new Gauge<Long>()
1:                                                    {
1:                                                        public Long getValue()
1:                                                        {
1:                                                            long memtablePartitions = 0;
1:                                                            for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())
1:                                                                memtablePartitions += memtable.partitionCount();
0:                                                            return SSTableReader.getApproximateKeyCount(cfs.getSSTables()) + memtablePartitions;
1:                                                        }
1:                                                    });
1:         estimatedColumnCountHistogram = Metrics.register(factory.createMetricName("EstimatedColumnCountHistogram"),
1:                                                          aliasFactory.createMetricName("EstimatedColumnCountHistogram"),
1:                                                          new Gauge<long[]>()
1:                                                          {
0:                                                              public long[] getValue()
1:                                                              {
0:                                                                  return combineHistograms(cfs.getSSTables(), new GetHistogram()
1:                                                                  {
1:                                                                      public EstimatedHistogram getHistogram(SSTableReader reader)
1:                                                                      {
1:                                                                          return reader.getEstimatedColumnCount();
1:                                                                      }
1:                                                                  });
0:         sstablesPerReadHistogram = createTableHistogram("SSTablesPerReadHistogram", cfs.keyspace.metric.sstablesPerReadHistogram);
1:         compressionRatio = createTableGauge("CompressionRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
1:         pendingFlushes = createTableCounter("PendingFlushes");
1:         pendingCompactions = createTableGauge("PendingCompactions", new Gauge<Integer>()
1:         liveSSTableCount = createTableGauge("LiveSSTableCount", new Gauge<Integer>()
1:         liveDiskSpaceUsed = createTableCounter("LiveDiskSpaceUsed");
1:         totalDiskSpaceUsed = createTableCounter("TotalDiskSpaceUsed");
1:         minPartitionSize = createTableGauge("MinPartitionSize", "MinRowSize", new Gauge<Long>()
1:                     if (min == 0 || sstable.getEstimatedPartitionSize().min() < min)
1:                         min = sstable.getEstimatedPartitionSize().min();
/////////////////////////////////////////////////////////////////////////
1:                 for (Metric cfGauge : allTableMetrics.get("MinPartitionSize"))
1:         maxPartitionSize = createTableGauge("MaxPartitionSize", "MaxRowSize", new Gauge<Long>()
1:                     if (sstable.getEstimatedPartitionSize().max() > max)
1:                         max = sstable.getEstimatedPartitionSize().max();
/////////////////////////////////////////////////////////////////////////
1:                 for (Metric cfGauge : allTableMetrics.get("MaxPartitionSize"))
1:         meanPartitionSize = createTableGauge("MeanPartitionSize", "MeanRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:                     long n = sstable.getEstimatedPartitionSize().count();
1:                     sum += sstable.getEstimatedPartitionSize().mean() * n;
/////////////////////////////////////////////////////////////////////////
1:                         long n = sstable.getEstimatedPartitionSize().count();
1:                         sum += sstable.getEstimatedPartitionSize().mean() * n;
1:         bloomFilterFalsePositives = createTableGauge("BloomFilterFalsePositives", new Gauge<Long>()
0:                 for (SSTableReader sstable : cfs.getSSTables())
1:         recentBloomFilterFalsePositives = createTableGauge("RecentBloomFilterFalsePositives", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         bloomFilterFalseRatio = createTableGauge("BloomFilterFalseRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
1:         recentBloomFilterFalseRatio = createTableGauge("RecentBloomFilterFalseRatio", new Gauge<Double>()
0:                 for (SSTableReader sstable : cfs.getSSTables())
/////////////////////////////////////////////////////////////////////////
1:         bloomFilterDiskSpaceUsed = createTableGauge("BloomFilterDiskSpaceUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         bloomFilterOffHeapMemoryUsed = createTableGauge("BloomFilterOffHeapMemoryUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         indexSummaryOffHeapMemoryUsed = createTableGauge("IndexSummaryOffHeapMemoryUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         compressionMetadataOffHeapMemoryUsed = createTableGauge("CompressionMetadataOffHeapMemoryUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         speculativeRetries = createTableCounter("SpeculativeRetries");
1:         keyCacheHitRate = Metrics.register(factory.createMetricName("KeyCacheHitRate"),
1:                                            aliasFactory.createMetricName("KeyCacheHitRate"),
1:                                            new RatioGauge()
/////////////////////////////////////////////////////////////////////////
0:         tombstoneScannedHistogram = createTableHistogram("TombstoneScannedHistogram", cfs.keyspace.metric.tombstoneScannedHistogram);
0:         liveScannedHistogram = createTableHistogram("LiveScannedHistogram", cfs.keyspace.metric.liveScannedHistogram);
0:         colUpdateTimeDeltaHistogram = createTableHistogram("ColUpdateTimeDeltaHistogram", cfs.keyspace.metric.colUpdateTimeDeltaHistogram);
1:         trueSnapshotsSize = createTableGauge("SnapshotsSize", new Gauge<Long>()
0:         partitionCacheHitOutOfRange = createTableCounter("PartitionCacheHitOutOfRange", "RowCacheHitOutOfRange");
0:         partitionCacheHit = createTableCounter("PartitionCacheHit", "RowCacheHit");
0:         partitionCacheMiss = createTableCounter("PartitionCacheMiss", "RowCacheMiss");
/////////////////////////////////////////////////////////////////////////
1:         for(Map.Entry<String, String> entry : all.entrySet())
1:             CassandraMetricsRegistry.MetricName name = factory.createMetricName(entry.getKey());
1:             CassandraMetricsRegistry.MetricName alias = aliasFactory.createMetricName(entry.getValue());
1:             allTableMetrics.get(entry.getKey()).remove(Metrics.getMetrics().get(name.getMetricName()));
1:             Metrics.remove(name, alias);
1:         Metrics.remove(factory.createMetricName("EstimatedPartitionSizeHistogram"), aliasFactory.createMetricName("EstimatedRowSizeHistogram"));
1:         Metrics.remove(factory.createMetricName("EstimatedPartitionCount"), aliasFactory.createMetricName("EstimatedRowCount"));
1:         Metrics.remove(factory.createMetricName("EstimatedColumnCountHistogram"), aliasFactory.createMetricName("EstimatedColumnCountHistogram"));
1:         Metrics.remove(factory.createMetricName("KeyCacheHitRate"), aliasFactory.createMetricName("KeyCacheHitRate"));
1:         Metrics.remove(factory.createMetricName("CoordinatorReadLatency"), aliasFactory.createMetricName("CoordinatorReadLatency"));
1:         Metrics.remove(factory.createMetricName("CoordinatorScanLatency"), aliasFactory.createMetricName("CoordinatorScanLatency"));
1:         Metrics.remove(factory.createMetricName("WaitingOnFreeMemtableSpace"), aliasFactory.createMetricName("WaitingOnFreeMemtableSpace"));
1:      * will merge each CF gauge by adding their values
1:     protected <T extends Number> Gauge<T> createTableGauge(final String name, Gauge<T> gauge)
1:         return createTableGauge(name, gauge, new Gauge<Long>()
1:                 for (Metric cfGauge : allTableMetrics.get(name))
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected <G,T> Gauge<T> createTableGauge(String name, Gauge<T> gauge, Gauge<G> globalGauge)
1:         return createTableGauge(name, name, gauge, globalGauge);
1:     }
1: 
1:     protected <G,T> Gauge<T> createTableGauge(String name, String alias, Gauge<T> gauge, Gauge<G> globalGauge)
1:     {
1:         Gauge<T> cfGauge = Metrics.register(factory.createMetricName(name), aliasFactory.createMetricName(alias), gauge);
1:         if (register(name, alias, cfGauge))
1:             Metrics.register(globalFactory.createMetricName(name), globalAliasFactory.createMetricName(alias), globalGauge);
1: 
1:      * Creates a counter that will also have a global counter thats the sum of all counters across
1:     protected Counter createTableCounter(final String name)
1:         return createTableCounter(name, name);
1:     }
1: 
1:     protected Counter createTableCounter(final String name, final String alias)
1:     {
1:         Counter cfCounter = Metrics.counter(factory.createMetricName(name), aliasFactory.createMetricName(alias));
1:         if (register(name, alias, cfCounter))
1:             Metrics.register(globalFactory.createMetricName(name),
1:                              globalAliasFactory.createMetricName(alias),
1:                              new Gauge<Long>()
1:                     for (Metric cfGauge : allTableMetrics.get(name))
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected TableHistogram createTableHistogram(String name, Histogram keyspaceHistogram)
0:         return createTableHistogram(name, name, keyspaceHistogram);
1:     }
1: 
0:     protected TableHistogram createTableHistogram(String name, String alias, Histogram keyspaceHistogram)
1:     {
0:         Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias));
1:         register(name, alias, cfHistogram);
1:         return new TableHistogram(cfHistogram,
1:                                   keyspaceHistogram,
1:                                   Metrics.histogram(globalFactory.createMetricName(name),
1:                                                     globalAliasFactory.createMetricName(alias)));
1:     private boolean register(String name, String alias, Metric metric)
1:     {
0:         boolean ret = allTableMetrics.putIfAbsent(name,  new HashSet<>()) == null;
1:         allTableMetrics.get(name).add(metric);
1:         all.put(name, alias);
1: 
1:     public static class TableHistogram
1:         private TableHistogram(Histogram cf, Histogram keyspace, Histogram global)
/////////////////////////////////////////////////////////////////////////
1: 
1:     static class TableMetricNameFactory implements MetricNameFactory
1:         private final String tableName;
1:         private final String type;
1:         TableMetricNameFactory(ColumnFamilyStore cfs, String type)
1:             this.tableName = cfs.name;
1:             this.isIndex = cfs.isIndex();
1:             this.type = type;
1:             String groupName = TableMetrics.class.getPackage().getName();
1:             String type = isIndex ? "Index" + this.type : this.type;
1:             mbeanName.append(",scope=").append(tableName);
1:             return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, keyspaceName + "." + tableName, mbeanName.toString());
1: 
1:     static class AllTableMetricNameFactory implements MetricNameFactory
1:         private final String type;
1:         public AllTableMetricNameFactory(String type)
1:         {
1:             this.type = type;
1:         }
1: 
1:             String groupName = TableMetrics.class.getPackage().getName();
0:             mbeanName.append("type=" + type);
1:             return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, "all", mbeanName.toString());
1:     public enum Sampler
author:Edward Ribeiro
-------------------------------------------------------------------------------
commit:52be7ba
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:         boolean ret = allTableMetrics.putIfAbsent(name, ConcurrentHashMap.newKeySet()) == null;
author:Chris Lohfink
-------------------------------------------------------------------------------
commit:9b47dd5
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.index.SecondaryIndexManager;
0: import org.apache.cassandra.repair.SystemDistributedKeyspace;
/////////////////////////////////////////////////////////////////////////
1:     /** percent of the data that is repaired */
1:     public final Gauge<Double> percentRepaired;
/////////////////////////////////////////////////////////////////////////
1:     public final static Gauge<Double> globalPercentRepaired = Metrics.register(globalFactory.createMetricName("PercentRepaired"),
1:             new Gauge<Double>()
1:     {
1:         public Double getValue()
1:         {
1:             double repaired = 0;
1:             double total = 0;
1:             for (String keyspace : Schema.instance.getNonSystemKeyspaces())
1:             {
1:                 Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);
0:                 if (SystemDistributedKeyspace.NAME.equals(k.getName()))
1:                     continue;
1:                 if (k.getReplicationStrategy().getReplicationFactor() < 2)
1:                     continue;
1: 
1:                 for (ColumnFamilyStore cf : k.getColumnFamilyStores())
1:                 {
1:                     if (!SecondaryIndexManager.isIndexColumnFamily(cf.name))
1:                     {
1:                         for (SSTableReader sstable : cf.getSSTables(SSTableSet.CANONICAL))
1:                         {
1:                             if (sstable.isRepaired())
1:                             {
1:                                 repaired += sstable.uncompressedLength();
1:                             }
1:                             total += sstable.uncompressedLength();
1:                         }
1:                     }
1:                 }
1:             }
1:             return total > 0 ? (repaired / total) * 100 : 100.0;
1:         }
1:     });
1: 
/////////////////////////////////////////////////////////////////////////
1:         percentRepaired = createTableGauge("PercentRepaired", new Gauge<Double>()
1:         {
1:             public Double getValue()
1:             {
1:                 double repaired = 0;
1:                 double total = 0;
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
1:                 {
1:                     if (sstable.isRepaired())
1:                     {
1:                         repaired += sstable.uncompressedLength();
1:                     }
1:                     total += sstable.uncompressedLength();
1:                 }
1:                 return total > 0 ? (repaired / total) * 100 : 100.0;
1:             }
1:         });
commit:62ffa35
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
0: import com.google.common.collect.Maps;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** time taken acquiring the partition lock for materialized view updates for this table */
1:     public final TableTimer viewLockAcquireTime;
1:     /** time taken during the local read of a materialized view update */
1:     public final TableTimer viewReadTime;
/////////////////////////////////////////////////////////////////////////
1:         // We do not want to capture view mutation specific metrics for a view
1:         // They only makes sense to capture on the base table
1:         if (cfs.metadata.isView())
1:         {
1:             viewLockAcquireTime = null;
1:             viewReadTime = null;
1:         }
1:         else
1:         {
1:             viewLockAcquireTime = createTableTimer("ViewLockAcquireTime", cfs.keyspace.metric.viewLockAcquireTime);
1:             viewReadTime = createTableTimer("ViewReadTime", cfs.keyspace.metric.viewReadTime);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected TableTimer createTableTimer(String name, Timer keyspaceTimer)
1:     {
1:         return createTableTimer(name, name, keyspaceTimer);
1:     }
1: 
1:     protected TableTimer createTableTimer(String name, String alias, Timer keyspaceTimer)
1:     {
1:         Timer cfTimer = Metrics.timer(factory.createMetricName(name), aliasFactory.createMetricName(alias));
1:         register(name, alias, cfTimer);
1:         return new TableTimer(cfTimer,
1:                               keyspaceTimer,
1:                               Metrics.timer(globalFactory.createMetricName(name),
0:                                             globalAliasFactory.createMetricName(alias)));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static class TableTimer
1:     {
1:         public final Timer[] all;
1:         public final Timer cf;
1:         private TableTimer(Timer cf, Timer keyspace, Timer global)
1:         {
1:             this.cf = cf;
1:             this.all = new Timer[]{cf, keyspace, global};
1:         }
1: 
1:         public void update(long i, TimeUnit unit)
1:         {
1:             for(Timer timer : all)
1:             {
1:                 timer.update(i, unit);
1:             }
1:         }
1:     }
1: 
commit:ae04861
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Memtable;
/////////////////////////////////////////////////////////////////////////
1:     /** Approximate number of keys in table. */
0:     public final Gauge<Long> estimatedRowCount;
/////////////////////////////////////////////////////////////////////////
0:         estimatedRowCount = Metrics.newGauge(factory.createMetricName("EstimatedRowCount"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long memtablePartitions = 0;
0:                 for (Memtable memtable : cfs.getDataTracker().getView().getAllMemtables())
0:                     memtablePartitions += memtable.partitionCount();
0:                 return SSTableReader.getApproximateKeyCount(cfs.getSSTables()) + memtablePartitions;
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedRowCount"));
author:Dikang Gu
-------------------------------------------------------------------------------
commit:a0a9494
/////////////////////////////////////////////////////////////////////////
1:     /** Total number of bytes flushed since server [re]start */
1:     public final Counter bytesFlushed;
1:     /** Total number of bytes written by compaction since server [re]start */
1:     public final Counter compactionBytesWritten;
/////////////////////////////////////////////////////////////////////////
1:         bytesFlushed = createTableCounter("BytesFlushed");
1:         compactionBytesWritten = createTableCounter("CompactionBytesWritten");
author:anubhavkale
-------------------------------------------------------------------------------
commit:66d3428
/////////////////////////////////////////////////////////////////////////
1:     /** Dropped Mutations Count */
1:     public final Counter droppedMutations;
1: 
/////////////////////////////////////////////////////////////////////////
1:         droppedMutations = createTableCounter("DroppedMutations");
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:084590c
commit:5aa19cb
/////////////////////////////////////////////////////////////////////////
1:         sstablesPerReadHistogram = createTableHistogram("SSTablesPerReadHistogram", cfs.keyspace.metric.sstablesPerReadHistogram, true);
/////////////////////////////////////////////////////////////////////////
1:         tombstoneScannedHistogram = createTableHistogram("TombstoneScannedHistogram", cfs.keyspace.metric.tombstoneScannedHistogram, false);
1:         liveScannedHistogram = createTableHistogram("LiveScannedHistogram", cfs.keyspace.metric.liveScannedHistogram, false);
1:         colUpdateTimeDeltaHistogram = createTableHistogram("ColUpdateTimeDeltaHistogram", cfs.keyspace.metric.colUpdateTimeDeltaHistogram, false);
1:         waitingOnFreeMemtableSpace = Metrics.histogram(factory.createMetricName("WaitingOnFreeMemtableSpace"), false);
/////////////////////////////////////////////////////////////////////////
1:     protected TableHistogram createTableHistogram(String name, Histogram keyspaceHistogram, boolean considerZeroes)
1:         return createTableHistogram(name, name, keyspaceHistogram, considerZeroes);
1:     protected TableHistogram createTableHistogram(String name, String alias, Histogram keyspaceHistogram, boolean considerZeroes)
1:         Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias), considerZeroes);
1:                                                     globalAliasFactory.createMetricName(alias),
1:                                                     considerZeroes));
commit:b4cbb28
commit:254cd85
author:Brett Snyder
-------------------------------------------------------------------------------
commit:fa92ae6
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Iterables;
1: import org.apache.cassandra.io.compress.CompressionMetadata;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 return computeCompressionRatio(cfs.getSSTables(SSTableSet.CANONICAL));
0:                 return computeCompressionRatio(Iterables.concat(Iterables.transform(Keyspace.all(),
0:                                                                                     p -> p.getAllSSTables(SSTableSet.CANONICAL))));
/////////////////////////////////////////////////////////////////////////
1:      * Computes the compression ratio for the specified SSTables
1:      *
1:      * @param sstables the SSTables
1:      * @return the compression ratio for the specified SSTables
1:      */
1:     private static Double computeCompressionRatio(Iterable<SSTableReader> sstables)
1:     {
1:         double compressedLengthSum = 0;
1:         double dataLengthSum = 0;
1:         for (SSTableReader sstable : sstables)
1:         {
1:             if (sstable.compression)
1:             {
1:                 // We should not have any sstable which are in an open early mode as the sstable were selected
1:                 // using SSTableSet.CANONICAL.
1:                 assert sstable.openReason != SSTableReader.OpenReason.EARLY;
1: 
1:                 CompressionMetadata compressionMetadata = sstable.getCompressionMetadata();
1:                 compressedLengthSum += compressionMetadata.compressedFileLength;
1:                 dataLengthSum += compressionMetadata.dataLength;
1:             }
1:         }
0:         return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : 0;
1:     }
1: 
1:     /**
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.lifecycle.SSTableSet;
0: import org.apache.cassandra.db.lifecycle.View;
/////////////////////////////////////////////////////////////////////////
1:                                                                    return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()
/////////////////////////////////////////////////////////////////////////
1:                                                            return SSTableReader.getApproximateKeyCount(cfs.getSSTables(SSTableSet.CANONICAL)) + memtablePartitions;
/////////////////////////////////////////////////////////////////////////
1:                                                                  return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
1:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
1:                 return cfs.getTracker().getView().liveSSTables().size();
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
0:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
0:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                     for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.CANONICAL))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
/////////////////////////////////////////////////////////////////////////
1:                 for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))
commit:e5a76bd
/////////////////////////////////////////////////////////////////////////
1:                 return cfs.getTracker().getView().getCurrentMemtable().getOperations();
1:                 return cfs.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
1:                 return cfs.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
1:                 return cfs.getTracker().getView().getCurrentMemtable().getLiveDataSize();
/////////////////////////////////////////////////////////////////////////
1:                     size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
/////////////////////////////////////////////////////////////////////////
1:                     size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
/////////////////////////////////////////////////////////////////////////
1:                     size += cfs2.getTracker().getView().getCurrentMemtable().getLiveDataSize();
/////////////////////////////////////////////////////////////////////////
0:                 for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())
/////////////////////////////////////////////////////////////////////////
0:                 return cfs.getTracker().getSSTables().size();
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:7df3a5c
/////////////////////////////////////////////////////////////////////////
1:                 return cfs.getCompactionStrategyManager().getEstimatedRemainingTasks();
commit:518c3cf
commit:e3a88b9
/////////////////////////////////////////////////////////////////////////
0:     /** Estimate of number of pending compactios for this CF */
1:     public final Gauge<Integer> pendingCompactions;
/////////////////////////////////////////////////////////////////////////
0:         pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
1:         {
0:             public Integer value()
1:             {
0:                 return cfs.getCompactionStrategy().getEstimatedRemainingTasks();
1:             }
1:         });
commit:ab6eaed
/////////////////////////////////////////////////////////////////////////
0:     /** Row cache hits, but result out of range */
0:     public final Counter rowCacheHitOutOfRange;
0:     /** Number of row cache hits */
0:     public final Counter rowCacheHit;
0:     /** Number of row cache misses */
0:     public final Counter rowCacheMiss;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         rowCacheHitOutOfRange = Metrics.newCounter(factory.createMetricName("RowCacheHitOutOfRange"));
0:         rowCacheHit = Metrics.newCounter(factory.createMetricName("RowCacheHit"));
0:         rowCacheMiss = Metrics.newCounter(factory.createMetricName("RowCacheMiss"));
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RowCacheHitOutOfRange"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RowCacheHit"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RowCacheHitMiss"));
author:Brandon Williams
-------------------------------------------------------------------------------
commit:0a09b87
commit:faf9181
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.TopKSampler;
0: import com.yammer.metrics.core.Timer;
/////////////////////////////////////////////////////////////////////////
1:     public final Map<Sampler, TopKSampler<ByteBuffer>> samplers;
/////////////////////////////////////////////////////////////////////////
1:         samplers = Maps.newHashMap();
1:         for (Sampler sampler : Sampler.values())
1:         {
0:             samplers.put(sampler, new TopKSampler<ByteBuffer>());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static enum Sampler
1:     {
1:         READS, WRITES
1:     }
commit:1bd6960
/////////////////////////////////////////////////////////////////////////
1:     /** CAS Prepare metrics */
1:     public final LatencyMetrics casPrepare;
1:     /** CAS Propose metrics */
1:     public final LatencyMetrics casPropose;
1:     /** CAS Commit metrics */
1:     public final LatencyMetrics casCommit;
/////////////////////////////////////////////////////////////////////////
1:         casPrepare = new LatencyMetrics(factory, "CasPrepare", cfs.keyspace.metric.casPrepare);
1:         casPropose = new LatencyMetrics(factory, "CasPropose", cfs.keyspace.metric.casPropose);
1:         casCommit = new LatencyMetrics(factory, "CasCommit", cfs.keyspace.metric.casCommit);
commit:ca16e5b
/////////////////////////////////////////////////////////////////////////
0:     /** CAS Prepare metrics */
0:     public final LatencyMetrics casPrepare;
0:     /** CAS Propose metrics */
0:     public final LatencyMetrics casPropose;
0:     /** CAS Commit metrics */
0:     public final LatencyMetrics casCommit;
/////////////////////////////////////////////////////////////////////////
1: 
0:         casPrepare = new LatencyMetrics(factory, "CasPrepare", cfs.keyspace.metric.casPrepare);
0:         casPropose = new LatencyMetrics(factory, "CasPropose", cfs.keyspace.metric.casPropose);
0:         casCommit = new LatencyMetrics(factory, "CasCommit", cfs.keyspace.metric.casCommit);
commit:5b8ac8c
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentMap;
1: import org.apache.cassandra.db.Keyspace;
0: import com.google.common.collect.Maps;
0: import com.google.common.collect.Sets;
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: import com.yammer.metrics.util.RatioGauge;
1: 
/////////////////////////////////////////////////////////////////////////
0:     public final ColumnFamilyHistogram sstablesPerReadHistogram;
/////////////////////////////////////////////////////////////////////////
0:     public final ColumnFamilyHistogram tombstoneScannedHistogram;
0:     public final ColumnFamilyHistogram liveScannedHistogram;
/////////////////////////////////////////////////////////////////////////
0:     private static final MetricNameFactory globalNameFactory = new AllColumnFamilyMetricNameFactory();;
1:     
0:     public final static LatencyMetrics globalReadLatency = new LatencyMetrics(globalNameFactory, "Read");
0:     public final static LatencyMetrics globalWriteLatency = new LatencyMetrics(globalNameFactory, "Write");
0:     public final static LatencyMetrics globalRangeLatency = new LatencyMetrics(globalNameFactory, "Range");
1:     
1:     /**
1:      * stores metrics that will be rolled into a single global metric
1:      */
0:     public final static ConcurrentMap<String, Set<Metric>> allColumnFamilyMetrics = Maps.newConcurrentMap();
1:     
1:     /**
0:      * Stores all metric names created that can be used when unregistering
1:      */
0:     public final static Set<String> all = Sets.newHashSet();
1:     
/////////////////////////////////////////////////////////////////////////
0:         memtableColumnsCount = createColumnFamilyGauge("MemtableColumnsCount", new Gauge<Long>()
0:         memtableOnHeapSize = createColumnFamilyGauge("MemtableOnHeapSize", new Gauge<Long>()
0:         memtableOffHeapSize = createColumnFamilyGauge("MemtableOffHeapSize", new Gauge<Long>()
0:         memtableLiveDataSize = createColumnFamilyGauge("MemtableLiveDataSize", new Gauge<Long>()
0:         allMemtablesOnHeapSize = createColumnFamilyGauge("AllMemtablesHeapSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         allMemtablesOffHeapSize = createColumnFamilyGauge("AllMemtablesOffHeapSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         allMemtablesLiveDataSize = createColumnFamilyGauge("AllMemtablesLiveDataSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         memtableSwitchCount = createColumnFamilyCounter("MemtableSwitchCount");
/////////////////////////////////////////////////////////////////////////
0:         sstablesPerReadHistogram = createColumnFamilyHistogram("SSTablesPerReadHistogram", cfs.keyspace.metric.sstablesPerReadHistogram);
0:         compressionRatio = createColumnFamilyGauge("CompressionRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
0:                 double sum = 0;
0:                 int total = 0;
1:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
0:                         if (sstable.getCompressionRatio() != MetadataCollector.NO_COMPRESSION_RATIO)
1:                         {
0:                             sum += sstable.getCompressionRatio();
0:                             total++;
1:                         }
1:                     }
1:                 }
0:                 return total != 0 ? sum / total : 0;
1:             }
1:         readLatency = new LatencyMetrics(factory, "Read", cfs.keyspace.metric.readLatency, globalReadLatency);
1:         writeLatency = new LatencyMetrics(factory, "Write", cfs.keyspace.metric.writeLatency, globalWriteLatency);
1:         rangeLatency = new LatencyMetrics(factory, "Range", cfs.keyspace.metric.rangeLatency, globalRangeLatency);
0:         pendingFlushes = createColumnFamilyCounter("PendingFlushes");
0:         pendingCompactions = createColumnFamilyGauge("PendingCompactions", new Gauge<Integer>()
0:         liveSSTableCount = createColumnFamilyGauge("LiveSSTableCount", new Gauge<Integer>()
0:         liveDiskSpaceUsed = createColumnFamilyCounter("LiveDiskSpaceUsed");
0:         totalDiskSpaceUsed = createColumnFamilyCounter("TotalDiskSpaceUsed");
0:         minRowSize = createColumnFamilyGauge("MinRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
1:                 long min = Long.MAX_VALUE;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get("MinRowSize"))
1:                 {
0:                     min = Math.min(min, ((Gauge<? extends Number>) cfGauge).value().longValue());
1:                 }
1:                 return min;
1:             }
0:         maxRowSize = createColumnFamilyGauge("MaxRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
1:                 long max = 0;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get("MaxRowSize"))
1:                 {
0:                     max = Math.max(max, ((Gauge<? extends Number>) cfGauge).value().longValue());
1:                 }
1:                 return max;
1:             }
0:         meanRowSize = createColumnFamilyGauge("MeanRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
1:                 long sum = 0;
1:                 long count = 0;
1:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
0:                         long n = sstable.getEstimatedRowSize().count();
0:                         sum += sstable.getEstimatedRowSize().mean() * n;
1:                         count += n;
1:                     }
1:                 }
1:                 return count > 0 ? sum / count : 0;
1:             }
0:         bloomFilterFalsePositives = createColumnFamilyGauge("BloomFilterFalsePositives", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         recentBloomFilterFalsePositives = createColumnFamilyGauge("RecentBloomFilterFalsePositives", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         bloomFilterFalseRatio = createColumnFamilyGauge("BloomFilterFalseRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
1:                 long falseCount = 0L;
1:                 long trueCount = 0L;
1:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
1:                         falseCount += sstable.getBloomFilterFalsePositiveCount();
1:                         trueCount += sstable.getBloomFilterTruePositiveCount();
1:                     }
1:                 }
1:                 if (falseCount == 0L && trueCount == 0L)
1:                     return 0d;
1:                 return (double) falseCount / (trueCount + falseCount);
1:             }
0:         recentBloomFilterFalseRatio = createColumnFamilyGauge("RecentBloomFilterFalseRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
1:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
1:                 long falseCount = 0L;
1:                 long trueCount = 0L;
0:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
1:                         falseCount += sstable.getRecentBloomFilterFalsePositiveCount();
1:                         trueCount += sstable.getRecentBloomFilterTruePositiveCount();
1:                     }
1:                 }
1:                 if (falseCount == 0L && trueCount == 0L)
1:                     return 0d;
1:                 return (double) falseCount / (trueCount + falseCount);
1:             }
0:         bloomFilterDiskSpaceUsed = createColumnFamilyGauge("BloomFilterDiskSpaceUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         speculativeRetries = createColumnFamilyCounter("SpeculativeRetries");
/////////////////////////////////////////////////////////////////////////
0:         tombstoneScannedHistogram = createColumnFamilyHistogram("TombstoneScannedHistogram", cfs.keyspace.metric.tombstoneScannedHistogram);
0:         liveScannedHistogram = createColumnFamilyHistogram("LiveScannedHistogram", cfs.keyspace.metric.liveScannedHistogram);
0:         trueSnapshotsSize = createColumnFamilyGauge("SnapshotsSize", new Gauge<Long>()
0:         rowCacheHitOutOfRange = createColumnFamilyCounter("RowCacheHitOutOfRange");
0:         rowCacheHit = createColumnFamilyCounter("RowCacheHit");
0:         rowCacheMiss = createColumnFamilyCounter("RowCacheMiss");
/////////////////////////////////////////////////////////////////////////
0:         for(String name : all)
1:         {
0:             allColumnFamilyMetrics.get(name).remove(Metrics.defaultRegistry().allMetrics().get(factory.createMetricName(name)));
0:             Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
1:         }
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("WaitingOnFreeMemtableSpace"));
1: 
1:     /**
1:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
0:      * will merge each CF gauge by adding their values 
1:      */
0:     protected <T extends Number> Gauge<T> createColumnFamilyGauge(final String name, Gauge<T> gauge)
1:     {
0:         return createColumnFamilyGauge(name, gauge, new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long total = 0;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get(name))
1:                 {
0:                     total = total + ((Gauge<? extends Number>) cfGauge).value().longValue();
1:                 }
1:                 return total;
1:             }
1:         });
1:     }
1:     
1:     /**
1:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
1:      * is defined as the globalGauge parameter
1:      */
0:     protected <G,T> Gauge<T> createColumnFamilyGauge(String name, Gauge<T> gauge, Gauge<G> globalGauge)
1:     {
0:         Gauge<T> cfGauge = Metrics.newGauge(factory.createMetricName(name), gauge);
0:         if (register(name, cfGauge))
1:         {
0:             Metrics.newGauge(globalNameFactory.createMetricName(name), globalGauge);
1:         }
1:         return cfGauge;
1:     }
1:     
1:     /**
0:      * Creates a counter that will also have a global counter thats the sum of all counters across 
1:      * different column families
1:      */
0:     protected Counter createColumnFamilyCounter(final String name)
1:     {
0:         Counter cfCounter = Metrics.newCounter(factory.createMetricName(name));
0:         if (register(name, cfCounter))
1:         {
0:             Metrics.newGauge(globalNameFactory.createMetricName(name), new Gauge<Long>()
1:             {
0:                 public Long value()
1:                 {
1:                     long total = 0;
0:                     for (Metric cfGauge : allColumnFamilyMetrics.get(name))
1:                     {
0:                         total += ((Counter) cfGauge).count();
1:                     }
1:                     return total;
1:                 }
1:             });
1:         }
1:         return cfCounter;
1:     }
1:     
1:     /**
1:      * Create a histogram-like interface that will register both a CF, keyspace and global level
1:      * histogram and forward any updates to both
1:      */
0:     protected ColumnFamilyHistogram createColumnFamilyHistogram(String name, Histogram keyspaceHistogram) 
1:     {
0:         Histogram cfHistogram = Metrics.newHistogram(factory.createMetricName(name), true);  
0:         register(name, cfHistogram);
0:         return new ColumnFamilyHistogram(cfHistogram, keyspaceHistogram, Metrics.newHistogram(globalNameFactory.createMetricName(name), true));
1:     }
1:     
1:     /**
1:      * Registers a metric to be removed when unloading CF.
1:      * @return true if first time metric with that name has been registered
1:      */
0:     private boolean register(String name, Metric metric)
1:     { 
0:         boolean ret = allColumnFamilyMetrics.putIfAbsent(name,  new HashSet<Metric>()) == null;
0:         allColumnFamilyMetrics.get(name).add(metric);
0:         all.add(name);
1:         return ret;
1:     }
1:     
0:     public class ColumnFamilyHistogram
1:     {
1:         public final Histogram[] all;
1:         public final Histogram cf;
0:         private ColumnFamilyHistogram(Histogram cf, Histogram keyspace, Histogram global) 
1:         {
1:             this.cf = cf;
1:             this.all = new Histogram[]{cf, keyspace, global};
1:         }
1:         
0:         public void update(long i) 
1:         {
1:             for(Histogram histo : all)
1:             {
1:                 histo.update(i);
1:             }
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
0:     static class AllColumnFamilyMetricNameFactory implements MetricNameFactory
1:     {
0:         public MetricName createMetricName(String metricName)
1:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName(); 
1:             StringBuilder mbeanName = new StringBuilder();
1:             mbeanName.append(groupName).append(":");
0:             mbeanName.append("type=ColumnFamily");
1:             mbeanName.append(",name=").append(metricName);
0:             return new MetricName(groupName, "ColumnFamily", metricName, "all", mbeanName.toString());
1:         }
1:     }
commit:94ff639
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentMap;
0: import com.google.common.collect.Maps;
0: import com.google.common.collect.Sets;
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: import com.yammer.metrics.util.RatioGauge;
1: 
/////////////////////////////////////////////////////////////////////////
0:     public final ColumnFamilyHistogram sstablesPerReadHistogram;
/////////////////////////////////////////////////////////////////////////
0:     public final ColumnFamilyHistogram tombstoneScannedHistogram;
0:     public final ColumnFamilyHistogram liveScannedHistogram;
0:     private static final MetricNameFactory globalNameFactory = new AllColumnFamilyMetricNameFactory();;
1:     
0:     public final static LatencyMetrics globalReadLatency = new LatencyMetrics(globalNameFactory, "Read");
0:     public final static LatencyMetrics globalWriteLatency = new LatencyMetrics(globalNameFactory, "Write");
0:     public final static LatencyMetrics globalRangeLatency = new LatencyMetrics(globalNameFactory, "Range");
1:     
1:     /**
0:      * stores metrics that will be rolled into a single global metric
1:      */
0:     public final static ConcurrentMap<String, Set<Metric>> allColumnFamilyMetrics = Maps.newConcurrentMap();
1:     
1:     /**
0:      * Stores all metric names created that can be used when unregistering
1:      */
0:     public final static Set<String> all = Sets.newHashSet();
1:     
/////////////////////////////////////////////////////////////////////////
0:         memtableColumnsCount = createColumnFamilyGauge("MemtableColumnsCount", new Gauge<Long>()
0:         memtableDataSize = createColumnFamilyGauge("MemtableDataSize", new Gauge<Long>()
0:         allMemtablesDataSize = createColumnFamilyGauge("AllMemtablesDataSize", new Gauge<Long>()
0:         memtableSwitchCount = createColumnFamilyCounter("MemtableSwitchCount");
/////////////////////////////////////////////////////////////////////////
0:         sstablesPerReadHistogram = createColumnFamilyHistogram("SSTablesPerReadHistogram", cfs.keyspace.metric.sstablesPerReadHistogram);
0:         compressionRatio = createColumnFamilyGauge("CompressionRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
0:                 return total != 0 ? sum / total : 0;
1:             }
0:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
0:                 double sum = 0;
0:                 int total = 0;
0:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
0:                         if (sstable.getCompressionRatio() != SSTableMetadata.NO_COMPRESSION_RATIO)
1:                         {
0:                             sum += sstable.getCompressionRatio();
0:                             total++;
1:                         }
1:                     }
1:                 }
0:                 return total != 0 ? sum / total : 0;
0:         readLatency = new LatencyMetrics(factory, "Read", cfs.keyspace.metric.readLatency, globalReadLatency);
0:         writeLatency = new LatencyMetrics(factory, "Write", cfs.keyspace.metric.writeLatency, globalWriteLatency);
0:         rangeLatency = new LatencyMetrics(factory, "Range", cfs.keyspace.metric.rangeLatency, globalRangeLatency);
0:         pendingCompactions = createColumnFamilyGauge("PendingCompactions", new Gauge<Integer>()
/////////////////////////////////////////////////////////////////////////
0:         liveSSTableCount = createColumnFamilyGauge("LiveSSTableCount", new Gauge<Integer>()
0:         liveDiskSpaceUsed = createColumnFamilyCounter("LiveDiskSpaceUsed");
0:         totalDiskSpaceUsed = createColumnFamilyCounter("TotalDiskSpaceUsed");
0:         minRowSize = createColumnFamilyGauge("MinRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
0:                 long min = Long.MAX_VALUE;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get("MinRowSize"))
1:                 {
0:                     min = Math.min(min, ((Gauge<? extends Number>) cfGauge).value().longValue());
1:                 }
1:                 return min;
1:             }
0:         maxRowSize = createColumnFamilyGauge("MaxRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
1:                 long max = 0;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get("MaxRowSize"))
1:                 {
0:                     max = Math.max(max, ((Gauge<? extends Number>) cfGauge).value().longValue());
1:                 }
1:                 return max;
1:             }
0:         meanRowSize = createColumnFamilyGauge("MeanRowSize", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         }, new Gauge<Long>() // global gauge
1:         {
0:             public Long value()
1:             {
1:                 long sum = 0;
1:                 long count = 0;
0:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
0:                         long n = sstable.getEstimatedRowSize().count();
0:                         sum += sstable.getEstimatedRowSize().mean() * n;
1:                         count += n;
1:                     }
1:                 }
1:                 return count > 0 ? sum / count : 0;
1:             }
0:         bloomFilterFalsePositives = createColumnFamilyGauge("BloomFilterFalsePositives", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         recentBloomFilterFalsePositives = createColumnFamilyGauge("RecentBloomFilterFalsePositives", new Gauge<Long>()
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:         bloomFilterFalseRatio = createColumnFamilyGauge("BloomFilterFalseRatio", new Gauge<Double>()
0:                 for (SSTableReader sstable : cfs.getSSTables())
/////////////////////////////////////////////////////////////////////////
0:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
1:                 long falseCount = 0L;
1:                 long trueCount = 0L;
0:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
1:                         falseCount += sstable.getBloomFilterFalsePositiveCount();
1:                         trueCount += sstable.getBloomFilterTruePositiveCount();
1:                     }
1:                 }
1:                 if (falseCount == 0L && trueCount == 0L)
1:                     return 0d;
1:                 return (double) falseCount / (trueCount + falseCount);
1:             }
0:         recentBloomFilterFalseRatio = createColumnFamilyGauge("RecentBloomFilterFalseRatio", new Gauge<Double>()
/////////////////////////////////////////////////////////////////////////
0:         }, new Gauge<Double>() // global gauge
1:         {
0:             public Double value()
1:             {
1:                 long falseCount = 0L;
1:                 long trueCount = 0L;
0:                 for (Keyspace keyspace : Keyspace.all())
1:                 {
0:                     for (SSTableReader sstable : keyspace.getAllSSTables())
1:                     {
1:                         falseCount += sstable.getRecentBloomFilterFalsePositiveCount();
1:                         trueCount += sstable.getRecentBloomFilterTruePositiveCount();
1:                     }
1:                 }
1:                 if (falseCount == 0L && trueCount == 0L)
1:                     return 0d;
1:                 return (double) falseCount / (trueCount + falseCount);
1:             }
0:         bloomFilterDiskSpaceUsed = createColumnFamilyGauge("BloomFilterDiskSpaceUsed", new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         speculativeRetries = createColumnFamilyCounter("SpeculativeRetries");
/////////////////////////////////////////////////////////////////////////
0:         tombstoneScannedHistogram = createColumnFamilyHistogram("TombstoneScannedHistogram", cfs.keyspace.metric.tombstoneScannedHistogram);
0:         liveScannedHistogram = createColumnFamilyHistogram("LiveScannedHistogram", cfs.keyspace.metric.liveScannedHistogram);
/////////////////////////////////////////////////////////////////////////
0:         for(String name : all)
1:         {
0:             allColumnFamilyMetrics.get(name).remove(Metrics.defaultRegistry().allMetrics().get(factory.createMetricName(name)));
0:             Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
1:         }
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
1:     /**
0:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
0:      * will merge each CF gauge by adding their values 
1:      */
0:     protected <T extends Number> Gauge<T> createColumnFamilyGauge(final String name, Gauge<T> gauge)
1:     {
0:         return createColumnFamilyGauge(name, gauge, new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long total = 0;
0:                 for (Metric cfGauge : allColumnFamilyMetrics.get(name))
1:                 {
0:                     total = total + ((Gauge<? extends Number>) cfGauge).value().longValue();
1:                 }
1:                 return total;
1:             }
1:         });
1:     }
0:     
1:     /**
0:      * Create a gauge that will be part of a merged version of all column families.  The global gauge
0:      * is defined as the globalGauge parameter
1:      */
0:     protected <G,T> Gauge<T> createColumnFamilyGauge(String name, Gauge<T> gauge, Gauge<G> globalGauge)
1:     {
0:         Gauge<T> cfGauge = Metrics.newGauge(factory.createMetricName(name), gauge);
0:         if (register(name, cfGauge))
1:         {
0:             Metrics.newGauge(globalNameFactory.createMetricName(name), globalGauge);
1:         }
0:         return cfGauge;
1:     }
0:     
1:     /**
0:      * Creates a counter that will also have a global counter thats the sum of all counters across 
0:      * different column families
1:      */
0:     protected Counter createColumnFamilyCounter(final String name)
1:     {
0:         Counter cfCounter = Metrics.newCounter(factory.createMetricName(name));
0:         if (register(name, cfCounter))
1:         {
0:             Metrics.newGauge(globalNameFactory.createMetricName(name), new Gauge<Long>()
1:             {
0:                 public Long value()
1:                 {
1:                     long total = 0;
0:                     for (Metric cfGauge : allColumnFamilyMetrics.get(name))
1:                     {
0:                         total += ((Counter) cfGauge).count();
1:                     }
1:                     return total;
1:                 }
1:             });
1:         }
0:         return cfCounter;
1:     }
0:     
1:     /**
0:      * Create a histogram-like interface that will register both a CF, keyspace and global level
0:      * histogram and forward any updates to both
1:      */
0:     protected ColumnFamilyHistogram createColumnFamilyHistogram(String name, Histogram keyspaceHistogram) 
1:     {
0:         Histogram cfHistogram = Metrics.newHistogram(factory.createMetricName(name), true);  
0:         register(name, cfHistogram);
0:         return new ColumnFamilyHistogram(cfHistogram, keyspaceHistogram, Metrics.newHistogram(globalNameFactory.createMetricName(name), true));
1:     }
0:     
1:     /**
0:      * Registers a metric to be removed when unloading CF.
0:      * @return true if first time metric with that name has been registered
1:      */
0:     private boolean register(String name, Metric metric)
1:     { 
0:         boolean ret = allColumnFamilyMetrics.putIfAbsent(name,  new HashSet<Metric>()) == null;
0:         allColumnFamilyMetrics.get(name).add(metric);
0:         all.add(name);
0:         return ret;
1:     }
0:     
0:     public class ColumnFamilyHistogram
1:     {
0:         public final Histogram[] all;
0:         public final Histogram cf;
0:         private ColumnFamilyHistogram(Histogram cf, Histogram keyspace, Histogram global) 
1:         {
0:             this.cf = cf;
0:             this.all = new Histogram[]{cf, keyspace, global};
1:         }
0:         
0:         public void update(long i) 
1:         {
0:             for(Histogram histo : all)
1:             {
0:                 histo.update(i);
1:             }
1:         }
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     static class AllColumnFamilyMetricNameFactory implements MetricNameFactory
1:     {
0:         public MetricName createMetricName(String metricName)
1:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName(); 
1:             StringBuilder mbeanName = new StringBuilder();
1:             mbeanName.append(groupName).append(":");
0:             mbeanName.append("type=ColumnFamily");
1:             mbeanName.append(",name=").append(metricName);
0:             return new MetricName(groupName, "ColumnFamily", metricName, "all", mbeanName.toString());
1:         }
1:     }
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:371ad9e
commit:9aaea24
commit:2d76d9f
commit:458bcf2
commit:2ddf2cd
commit:d41a746
/////////////////////////////////////////////////////////////////////////
0:     /** Total amount of data stored in the memtables (2i and pending flush memtables included). */
0:     public final Gauge<Long> allMemtablesDataSize;
/////////////////////////////////////////////////////////////////////////
0:         allMemtablesDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 return cfs.getTotalAllMemtablesLiveSize();
1:             }
1:         });
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
0:                 return Keyspace.switchLock.getQueueLength();
/////////////////////////////////////////////////////////////////////////
1:             this.keyspaceName = cfs.keyspace.getName();
author:blerer
-------------------------------------------------------------------------------
commit:7a14a77
/////////////////////////////////////////////////////////////////////////
1:     /** Off heap memory used by bloom filter */
1:     public final Gauge<Long> bloomFilterOffHeapMemoryUsed;
1:     /** Off heap memory used by index summary */
1:     public final Gauge<Long> indexSummaryOffHeapMemoryUsed;
1:     /** Off heap memory used by compression meta data*/
1:     public final Gauge<Long> compressionMetadataOffHeapMemoryUsed;
/////////////////////////////////////////////////////////////////////////
0:         bloomFilterOffHeapMemoryUsed = createColumnFamilyGauge("BloomFilterOffHeapMemoryUsed", new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long total = 0;
0:                 for (SSTableReader sst : cfs.getSSTables())
1:                     total += sst.getBloomFilterOffHeapSize();
1:                 return total;
1:             }
1:         });
0:         indexSummaryOffHeapMemoryUsed = createColumnFamilyGauge("IndexSummaryOffHeapMemoryUsed", new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long total = 0;
0:                 for (SSTableReader sst : cfs.getSSTables())
1:                     total += sst.getIndexSummaryOffHeapSize();
1:                 return total;
1:             }
1:         });
0:         compressionMetadataOffHeapMemoryUsed = createColumnFamilyGauge("CompressionMetadataOffHeapMemoryUsed", new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long total = 0;
0:                 for (SSTableReader sst : cfs.getSSTables())
1:                     total += sst.getCompressionMetadataOffHeapSize();
1:                 return total;
1:             }
1:         });
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:9685622
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: 
1:     private interface GetHistogram
1:     {
0:         public EstimatedHistogram getHistogram(SSTableReader reader);
1:     }
0: 
1:     private static long[] combineHistograms(Iterable<SSTableReader> sstables, GetHistogram getHistogram)
1:     {
1:         Iterator<SSTableReader> iterator = sstables.iterator();
1:         if (!iterator.hasNext())
1:         {
0:             return new long[0];
1:         }
1:         long[] firstBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);
1:         long[] values = new long[firstBucket.length];
1:         System.arraycopy(firstBucket, 0, values, 0, values.length);
0: 
1:         while (iterator.hasNext())
1:         {
1:             long[] nextBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);
1:             if (nextBucket.length > values.length)
1:             {
1:                 long[] newValues = new long[nextBucket.length];
1:                 System.arraycopy(firstBucket, 0, newValues, 0, firstBucket.length);
1:                 for (int i = 0; i < newValues.length; i++)
1:                 {
1:                     newValues[i] += nextBucket[i];
1:                 }
1:                 values = newValues;
1:             }
1:             else
1:             {
1:                 for (int i = 0; i < values.length; i++)
1:                 {
1:                     values[i] += nextBucket[i];
1:                 }
1:             }
1:         }
1:         return values;
1:     }
/////////////////////////////////////////////////////////////////////////
0:                 return combineHistograms(cfs.getSSTables(), new GetHistogram()
0:                     public EstimatedHistogram getHistogram(SSTableReader reader)
0:                     {
0:                         return reader.getEstimatedRowSize();
0:                     }
1:                 });
0:                 return combineHistograms(cfs.getSSTables(), new GetHistogram()
0:                     public EstimatedHistogram getHistogram(SSTableReader reader)
0:                     {
0:                         return reader.getEstimatedColumnCount();
0:                     }
1:                 });
author:Sankalp Kohli
-------------------------------------------------------------------------------
commit:5acc7a9
/////////////////////////////////////////////////////////////////////////
1:     /** Column update time delta on this CF */
0:     public final ColumnFamilyHistogram colUpdateTimeDeltaHistogram;
/////////////////////////////////////////////////////////////////////////
0:         colUpdateTimeDeltaHistogram = createColumnFamilyHistogram("ColUpdateTimeDeltaHistogram", cfs.keyspace.metric.colUpdateTimeDeltaHistogram);
commit:e019760
/////////////////////////////////////////////////////////////////////////
0:     /** Column update time delta on this CF */
0:     public final ColumnFamilyHistogram colUpdateTimeDeltaHistogram;
/////////////////////////////////////////////////////////////////////////
0:         colUpdateTimeDeltaHistogram = createColumnFamilyHistogram("ColUpdateTimeDeltaHistogram", cfs.keyspace.metric.colUpdateTimeDeltaHistogram);
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:1a3b5db
/////////////////////////////////////////////////////////////////////////
1:     public final Gauge<Long> memtableOnHeapSize;
0:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and overwritten rows. */
1:     public final Gauge<Long> memtableOffHeapSize;
1:     public final Gauge<Long> allMemtablesOnHeapSize;
1:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
1:     public final Gauge<Long> allMemtablesOffHeapSize;
/////////////////////////////////////////////////////////////////////////
0:         memtableOnHeapSize = Metrics.newGauge(factory.createMetricName("MemtableHeapSize"), new Gauge<Long>()
0:                 return cfs.getDataTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
0:             }
1:         });
0:         memtableOffHeapSize = Metrics.newGauge(factory.createMetricName("MemtableHeapSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 return cfs.getDataTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
/////////////////////////////////////////////////////////////////////////
0:         allMemtablesOnHeapSize = Metrics.newGauge(factory.createMetricName("AllMemtablesHeapSize"), new Gauge<Long>()
0:                     size += cfs2.getDataTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();
1:                 return size;
0:             }
1:         });
0:         allMemtablesOffHeapSize = Metrics.newGauge(factory.createMetricName("AllMemtablesHeapSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long size = 0;
1:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
0:                     size += cfs2.getDataTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();
author:Mikhail Stepura
-------------------------------------------------------------------------------
commit:d529ab9
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingFlushes"));
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:ef6d42c
commit:56a615d
commit:beefd0b
/////////////////////////////////////////////////////////////////////////
0:                     long n = sstable.getEstimatedRowSize().count();
0:                     sum += sstable.getEstimatedRowSize().mean() * n;
0:                     count += n;
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and overwritten rows. */
0:     public final Gauge<Long> memtableHeapSize;
1:     /** Total amount of live data stored in the memtable, excluding any data structure overhead */
1:     public final Gauge<Long> memtableLiveDataSize;
1:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
0:     public final Gauge<Long> allMemtablesHeapSize;
1:     /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
1:     public final Gauge<Long> allMemtablesLiveDataSize;
/////////////////////////////////////////////////////////////////////////
1:     public final Counter pendingFlushes;
/////////////////////////////////////////////////////////////////////////
1:     /** Time spent waiting for free memtable space, either on- or off-heap */
0:     public final Timer waitingOnFreeMemtableSpace;
0: 
/////////////////////////////////////////////////////////////////////////
0:                 return cfs.getDataTracker().getView().getCurrentMemtable().getOperations();
0:         memtableHeapSize = Metrics.newGauge(factory.createMetricName("MemtableHeapSize"), new Gauge<Long>()
0:                 return cfs.getDataTracker().getView().getCurrentMemtable().getAllocator().owns();
0:         memtableLiveDataSize = Metrics.newGauge(factory.createMetricName("MemtableLiveDataSize"), new Gauge<Long>()
0:                 return cfs.getDataTracker().getView().getCurrentMemtable().getLiveDataSize();
0:             }
1:         });
0:         allMemtablesHeapSize = Metrics.newGauge(factory.createMetricName("AllMemtablesHeapSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long size = 0;
1:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
0:                     size += cfs2.getDataTracker().getView().getCurrentMemtable().getAllocator().owns();
1:                 return size;
0:             }
1:         });
0:         allMemtablesLiveDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesLiveDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long size = 0;
1:                 for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())
0:                     size += cfs2.getDataTracker().getView().getCurrentMemtable().getLiveDataSize();
1:                 return size;
/////////////////////////////////////////////////////////////////////////
0:         pendingFlushes = Metrics.newCounter(factory.createMetricName("PendingFlushes"));
/////////////////////////////////////////////////////////////////////////
0:         waitingOnFreeMemtableSpace = Metrics.newTimer(factory.createMetricName("WaitingOnFreeMemtableSpace"), TimeUnit.MICROSECONDS, TimeUnit.SECONDS);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:e178ff4
/////////////////////////////////////////////////////////////////////////
1:     /** Disk space used by snapshot files which */
1:     public final Gauge<Long> trueSnapshotsSize;
/////////////////////////////////////////////////////////////////////////
0:                 for (SSTableReader sstable : cfs.getSSTables())
/////////////////////////////////////////////////////////////////////////
0:                 for (SSTableReader sstable : cfs.getSSTables())
/////////////////////////////////////////////////////////////////////////
0:         
0:         trueSnapshotsSize = Metrics.newGauge(factory.createMetricName("SnapshotsSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 return cfs.trueSnapshotsSize();
0:             }
1:         });
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("SnapshotsSize"));
commit:9620e0c
commit:99b40fd
/////////////////////////////////////////////////////////////////////////
0:         sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
/////////////////////////////////////////////////////////////////////////
0:         tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName("TombstoneScannedHistogram"), true);
0:         liveScannedHistogram = Metrics.newHistogram(factory.createMetricName("LiveScannedHistogram"), true);
commit:8693a26
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
0: 
0: import com.yammer.metrics.core.*;
/////////////////////////////////////////////////////////////////////////
1:     /** (Local) read metrics */
1:     /** (Local) write metrics */
/////////////////////////////////////////////////////////////////////////
1:     public final Timer coordinatorReadLatency;
1:     public final Timer coordinatorScanLatency;
0: 
1:     public final Counter speculativeRetries;
/////////////////////////////////////////////////////////////////////////
0:                 return total != 0 ? (double) sum / total : 0;
/////////////////////////////////////////////////////////////////////////
0:         speculativeRetries = Metrics.newCounter(factory.createMetricName("SpeculativeRetries"));
/////////////////////////////////////////////////////////////////////////
0:         coordinatorReadLatency = Metrics.newTimer(factory.createMetricName("CoordinatorReadLatency"), TimeUnit.MICROSECONDS, TimeUnit.SECONDS);
0:         coordinatorScanLatency = Metrics.newTimer(factory.createMetricName("CoordinatorScanLatency"), TimeUnit.MICROSECONDS, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("CoordinatorReadLatency"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("CoordinatorScanLatency"));
commit:52b4fc3
commit:2267c20
/////////////////////////////////////////////////////////////////////////
1:     /** Tombstones scanned in queries on this CF */
0:     public final Histogram tombstoneScannedHistogram;
1:     /** Live cells scanned in queries on this CF */
0:     public final Histogram liveScannedHistogram;
/////////////////////////////////////////////////////////////////////////
0:         tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName("TombstoneScannedHistogram"));
0:         liveScannedHistogram = Metrics.newHistogram(factory.createMetricName("LiveScannedHistogram"));
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TombstoneScannedHistogram"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveScannedHistogram"));
commit:e4d5d33
/////////////////////////////////////////////////////////////////////////
0:             this.keyspaceName = cfs.table.getName();
commit:9e14e19
/////////////////////////////////////////////////////////////////////////
0:             this.columnFamilyName = cfs.name;
author:Russell Spitzer
-------------------------------------------------------------------------------
commit:5c86f36
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("SpeculativeRetries"));
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:74bf5aa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
/////////////////////////////////////////////////////////////////////////
0:                     if (sstable.getCompressionRatio() != MetadataCollector.NO_COMPRESSION_RATIO)
0:                 return total != 0 ? sum / total : 0;
commit:e15dee2
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("KeyCacheHitRate"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("SpeculativeRetry"));
commit:2d20997
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("KeyCacheHitRate"));
commit:d62382b
commit:f5d632f
/////////////////////////////////////////////////////////////////////////
0: import com.yammer.metrics.util.RatioGauge;
/////////////////////////////////////////////////////////////////////////
1:     /** Key cache hit rate  for this CF */
1:     public final Gauge<Double> keyCacheHitRate;
/////////////////////////////////////////////////////////////////////////
0:         keyCacheHitRate = Metrics.newGauge(factory.createMetricName("KeyCacheHitRate"), new RatioGauge()
0:         {
1:             protected double getNumerator()
0:             {
1:                 long hits = 0L;
0:                 for (SSTableReader sstable : cfs.getSSTables())
1:                     hits += sstable.getKeyCacheHit();
1:                 return hits;
0:             }
0: 
1:             protected double getDenominator()
0:             {
1:                 long requests = 0L;
0:                 for (SSTableReader sstable : cfs.getSSTables())
1:                     requests += sstable.getKeyCacheRequest();
1:                 return Math.max(requests, 1); // to avoid NaN.
0:             }
1:         });
commit:69cedbf
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.metrics;
0: 
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.Counter;
0: import com.yammer.metrics.core.Gauge;
0: import com.yammer.metrics.core.Histogram;
0: import com.yammer.metrics.core.MetricName;
0: 
1: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.Table;
0: import org.apache.cassandra.io.sstable.SSTableReader;
1: import org.apache.cassandra.utils.EstimatedHistogram;
0: 
0: /**
1:  * Metrics for {@link ColumnFamilyStore}.
0:  */
0: public class ColumnFamilyMetrics
0: {
0:     /** Total amount of data stored in the memtable, including column related overhead. */
0:     public final Gauge<Long> memtableDataSize;
1:     /** Total number of columns present in the memtable. */
1:     public final Gauge<Long> memtableColumnsCount;
1:     /** Number of times flush has resulted in the memtable being switched out. */
1:     public final Counter memtableSwitchCount;
1:     /** Current compression ratio for all SSTables */
1:     public final Gauge<Double> compressionRatio;
0:     /** Histogram of estimated row size (in bytes). */
0:     public final Gauge<long[]> estimatedRowSizeHistogram;
1:     /** Histogram of estimated number of columns. */
1:     public final Gauge<long[]> estimatedColumnCountHistogram;
1:     /** Histogram of the number of sstable data files accessed per read */
0:     public final Histogram sstablesPerReadHistogram;
0:     /** Read metrics */
1:     public final LatencyMetrics readLatency;
0:     /** Write metrics */
1:     public final LatencyMetrics writeLatency;
0:     /** Estimated number of tasks pending for this column family */
0:     public final Gauge<Integer> pendingTasks;
1:     /** Number of SSTables on disk for this CF */
1:     public final Gauge<Integer> liveSSTableCount;
0:     /** Disk space used by SSTables belonging to this CF */
1:     public final Counter liveDiskSpaceUsed;
0:     /** Total disk space used by SSTables belonging to this CF, including obsolete ones waiting to be GC'd */
1:     public final Counter totalDiskSpaceUsed;
0:     /** Size of the smallest compacted row */
0:     public final Gauge<Long> minRowSize;
0:     /** Size of the largest compacted row */
0:     public final Gauge<Long> maxRowSize;
0:     /** Size of the smallest compacted row */
0:     public final Gauge<Long> meanRowSize;
1:     /** Number of false positives in bloom filter */
1:     public final Gauge<Long> bloomFilterFalsePositives;
1:     /** Number of false positives in bloom filter from last read */
1:     public final Gauge<Long> recentBloomFilterFalsePositives;
1:     /** False positive ratio of bloom filter */
1:     public final Gauge<Double> bloomFilterFalseRatio;
1:     /** False positive ratio of bloom filter from last read */
1:     public final Gauge<Double> recentBloomFilterFalseRatio;
1:     /** Disk space used by bloom filter */
1:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
0: 
1:     private final MetricNameFactory factory;
0: 
0:     // for backward compatibility
0:     @Deprecated public final EstimatedHistogram sstablesPerRead = new EstimatedHistogram(35);
0:     @Deprecated public final EstimatedHistogram recentSSTablesPerRead = new EstimatedHistogram(35);
0: 
0:     /**
1:      * Creates metrics for given {@link ColumnFamilyStore}.
1:      *
1:      * @param cfs ColumnFamilyStore to measure metrics
0:      */
0:     public ColumnFamilyMetrics(final ColumnFamilyStore cfs)
0:     {
0:         factory = new ColumnFamilyMetricNameFactory(cfs);
0: 
0:         memtableColumnsCount = Metrics.newGauge(factory.createMetricName("MemtableColumnsCount"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 return cfs.getDataTracker().getMemtable().getOperations();
0:             }
1:         });
0:         memtableDataSize = Metrics.newGauge(factory.createMetricName("MemtableDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 return cfs.getDataTracker().getMemtable().getLiveSize();
0:             }
1:         });
0:         memtableSwitchCount = Metrics.newCounter(factory.createMetricName("MemtableSwitchCount"));
0:         estimatedRowSizeHistogram = Metrics.newGauge(factory.createMetricName("EstimatedRowSizeHistogram"), new Gauge<long[]>()
0:         {
0:             public long[] value()
0:             {
0:                 long[] histogram = new long[90];
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     long[] rowSize = sstable.getEstimatedRowSize().getBuckets(false);
0:                     for (int i = 0; i < histogram.length; i++)
0:                         histogram[i] += rowSize[i];
0:                 }
0:                 return histogram;
0:             }
1:         });
0:         estimatedColumnCountHistogram = Metrics.newGauge(factory.createMetricName("EstimatedColumnCountHistogram"), new Gauge<long[]>()
0:         {
0:             public long[] value()
0:             {
0:                 long[] histogram = new long[90];
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     long[] columnSize = sstable.getEstimatedColumnCount().getBuckets(false);
0:                     for (int i = 0; i < histogram.length; i++)
0:                         histogram[i] += columnSize[i];
0:                 }
0:                 return histogram;
0:             }
1:         });
0:         sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName("SSTablesPerReadHistogram"));
0:         compressionRatio = Metrics.newGauge(factory.createMetricName("CompressionRatio"), new Gauge<Double>()
0:         {
0:             public Double value()
0:             {
0:                 double sum = 0;
0:                 int total = 0;
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     if (sstable.getCompressionRatio() != Double.MIN_VALUE)
0:                     {
0:                         sum += sstable.getCompressionRatio();
0:                         total++;
0:                     }
0:                 }
0:                 return total != 0 ? (double)sum/total: 0;
0:             }
1:         });
0:         readLatency = new LatencyMetrics(factory, "Read");
0:         writeLatency = new LatencyMetrics(factory, "Write");
0:         pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 // TODO this actually isn't a good measure of pending tasks
0:                 return Table.switchLock.getQueueLength();
0:             }
1:         });
0:         liveSSTableCount = Metrics.newGauge(factory.createMetricName("LiveSSTableCount"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 return cfs.getDataTracker().getSSTables().size();
0:             }
1:         });
0:         liveDiskSpaceUsed = Metrics.newCounter(factory.createMetricName("LiveDiskSpaceUsed"));
0:         totalDiskSpaceUsed = Metrics.newCounter(factory.createMetricName("TotalDiskSpaceUsed"));
0:         minRowSize = Metrics.newGauge(factory.createMetricName("MinRowSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long min = 0;
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     if (min == 0 || sstable.getEstimatedRowSize().min() < min)
0:                         min = sstable.getEstimatedRowSize().min();
0:                 }
0:                 return min;
0:             }
1:         });
0:         maxRowSize = Metrics.newGauge(factory.createMetricName("MaxRowSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long max = 0;
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     if (sstable.getEstimatedRowSize().max() > max)
0:                         max = sstable.getEstimatedRowSize().max();
0:                 }
0:                 return max;
0:             }
1:         });
0:         meanRowSize = Metrics.newGauge(factory.createMetricName("MeanRowSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 long count = 0;
0:                 for (SSTableReader sstable : cfs.getSSTables())
0:                 {
0:                     sum += sstable.getEstimatedRowSize().mean();
0:                     count++;
0:                 }
0:                 return count > 0 ? sum / count : 0;
0:             }
1:         });
0:         bloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName("BloomFilterFalsePositives"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long count = 0L;
0:                 for (SSTableReader sstable: cfs.getSSTables())
1:                     count += sstable.getBloomFilterFalsePositiveCount();
1:                 return count;
0:             }
1:         });
0:         recentBloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName("RecentBloomFilterFalsePositives"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
1:                 long count = 0L;
0:                 for (SSTableReader sstable: cfs.getSSTables())
1:                     count += sstable.getRecentBloomFilterFalsePositiveCount();
1:                 return count;
0:             }
1:         });
0:         bloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName("BloomFilterFalseRatio"), new Gauge<Double>()
0:         {
0:             public Double value()
0:             {
0:                 long falseCount = 0L;
0:                 long trueCount = 0L;
0:                 for (SSTableReader sstable: cfs.getSSTables())
0:                 {
0:                     falseCount += sstable.getBloomFilterFalsePositiveCount();
0:                     trueCount += sstable.getBloomFilterTruePositiveCount();
0:                 }
0:                 if (falseCount == 0L && trueCount == 0L)
0:                     return 0d;
0:                 return (double) falseCount / (trueCount + falseCount);
0:             }
1:         });
0:         recentBloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName("RecentBloomFilterFalseRatio"), new Gauge<Double>()
0:         {
0:             public Double value()
0:             {
0:                 long falseCount = 0L;
0:                 long trueCount = 0L;
0:                 for (SSTableReader sstable: cfs.getSSTables())
0:                 {
0:                     falseCount += sstable.getRecentBloomFilterFalsePositiveCount();
0:                     trueCount += sstable.getRecentBloomFilterTruePositiveCount();
0:                 }
0:                 if (falseCount == 0L && trueCount == 0L)
0:                     return 0d;
0:                 return (double) falseCount / (trueCount + falseCount);
0:             }
1:         });
0:         bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("BloomFilterDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (SSTableReader sst : cfs.getSSTables())
1:                     total += sst.getBloomFilterSerializedSize();
0:                 return total;
0:             }
1:         });
0:     }
0: 
1:     public void updateSSTableIterated(int count)
0:     {
1:         sstablesPerReadHistogram.update(count);
0:         recentSSTablesPerRead.add(count);
0:         sstablesPerRead.add(count);
0:     }
0: 
0:     /**
1:      * Release all associated metrics.
0:      */
1:     public void release()
0:     {
1:         readLatency.release();
1:         writeLatency.release();
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("CompressionRatio"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedRowSizeHistogram"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedColumnCountHistogram"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("SSTablesPerReadHistogram"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveSSTableCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MinRowSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MaxRowSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MeanRowSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalsePositives"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalsePositives"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalseRatio"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalseRatio"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
0:     }
0: 
0:     class ColumnFamilyMetricNameFactory implements MetricNameFactory
0:     {
1:         private final String keyspaceName;
0:         private final String columnFamilyName;
1:         private final boolean isIndex;
0: 
0:         ColumnFamilyMetricNameFactory(ColumnFamilyStore cfs)
0:         {
0:             this.keyspaceName = cfs.table.name;
0:             this.columnFamilyName = cfs.getColumnFamilyName();
0:             isIndex = cfs.isIndex();
0:         }
0: 
0:         public MetricName createMetricName(String metricName)
0:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName();
0:             String type = isIndex ? "IndexColumnFamily" : "ColumnFamily";
0: 
0:             StringBuilder mbeanName = new StringBuilder();
0:             mbeanName.append(groupName).append(":");
1:             mbeanName.append("type=").append(type);
1:             mbeanName.append(",keyspace=").append(keyspaceName);
0:             mbeanName.append(",scope=").append(columnFamilyName);
0:             mbeanName.append(",name=").append(metricName);
0: 
0:             return new MetricName(groupName, type, metricName, keyspaceName + "." + columnFamilyName, mbeanName.toString());
0:         }
0:     }
0: }
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:c25a6a1
/////////////////////////////////////////////////////////////////////////
0:     public final Counter speculativeRetry;
0: 
/////////////////////////////////////////////////////////////////////////
0:         speculativeRetry = Metrics.newCounter(factory.createMetricName("SpeculativeRetry"));
============================================================================