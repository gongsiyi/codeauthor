1:53a177a: /*
1:53a177a:  * Licensed to the Apache Software Foundation (ASF) under one
1:53a177a:  * or more contributor license agreements.  See the NOTICE file
1:53a177a:  * distributed with this work for additional information
1:53a177a:  * regarding copyright ownership.  The ASF licenses this file
1:53a177a:  * to you under the Apache License, Version 2.0 (the
1:53a177a:  * "License"); you may not use this file except in compliance
1:53a177a:  * with the License.  You may obtain a copy of the License at
1:53a177a:  *
1:53a177a:  *     http://www.apache.org/licenses/LICENSE-2.0
1:53a177a:  *
1:53a177a:  * Unless required by applicable law or agreed to in writing, software
1:53a177a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:53a177a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:53a177a:  * See the License for the specific language governing permissions and
1:53a177a:  * limitations under the License.
1:53a177a:  */
1:53a177a: package org.apache.cassandra.batchlog;
1:53a177a: 
1:53a177a: import java.io.IOException;
1:53a177a: import java.net.InetAddress;
1:53a177a: import java.util.*;
1:53a177a: import java.util.concurrent.ExecutionException;
1:53a177a: import java.util.concurrent.TimeUnit;
1:53a177a: 
1:53a177a: import com.google.common.collect.Lists;
1:1492be0: 
1:53a177a: import org.junit.*;
1:53a177a: 
1:53a177a: import org.apache.cassandra.SchemaLoader;
1:53a177a: import org.apache.cassandra.Util;
1:53a177a: import org.apache.cassandra.Util.PartitionerSwitcher;
1:53a177a: import org.apache.cassandra.config.CFMetaData;
1:53a177a: import org.apache.cassandra.config.DatabaseDescriptor;
1:53a177a: import org.apache.cassandra.config.Schema;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:53a177a: import org.apache.cassandra.cql3.UntypedResultSet;
1:53a177a: import org.apache.cassandra.db.ColumnFamilyStore;
1:53a177a: import org.apache.cassandra.db.DecoratedKey;
1:53a177a: import org.apache.cassandra.db.Keyspace;
1:53a177a: import org.apache.cassandra.db.Mutation;
1:53a177a: import org.apache.cassandra.db.RowUpdateBuilder;
1:53a177a: import org.apache.cassandra.db.SystemKeyspace;
1:e31e216: import org.apache.cassandra.db.commitlog.CommitLogPosition;
1:53a177a: import org.apache.cassandra.db.marshal.BytesType;
1:53a177a: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1:53a177a: import org.apache.cassandra.db.partitions.PartitionUpdate;
1:53a177a: import org.apache.cassandra.db.rows.Row;
1:53a177a: import org.apache.cassandra.dht.Murmur3Partitioner;
1:53a177a: import org.apache.cassandra.exceptions.ConfigurationException;
1:53a177a: import org.apache.cassandra.locator.TokenMetadata;
1:53a177a: import org.apache.cassandra.net.MessagingService;
1:53a177a: import org.apache.cassandra.service.StorageService;
1:53a177a: import org.apache.cassandra.schema.KeyspaceParams;
1:53a177a: import org.apache.cassandra.utils.ByteBufferUtil;
1:53a177a: import org.apache.cassandra.utils.FBUtilities;
1:53a177a: import org.apache.cassandra.utils.UUIDGen;
1:53a177a: 
1:53a177a: import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
1:53a177a: import static org.junit.Assert.*;
1:53a177a: 
1:53a177a: public class BatchlogManagerTest
1:53a177a: {
1:53a177a:     private static final String KEYSPACE1 = "BatchlogManagerTest1";
1:53a177a:     private static final String CF_STANDARD1 = "Standard1";
1:53a177a:     private static final String CF_STANDARD2 = "Standard2";
1:53a177a:     private static final String CF_STANDARD3 = "Standard3";
1:53a177a:     private static final String CF_STANDARD4 = "Standard4";
1:53a177a:     private static final String CF_STANDARD5 = "Standard5";
1:53a177a: 
1:53a177a:     static PartitionerSwitcher sw;
1:53a177a: 
1:53a177a:     @BeforeClass
1:53a177a:     public static void defineSchema() throws ConfigurationException
1:53a177a:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:53a177a:         sw = Util.switchPartitioner(Murmur3Partitioner.instance);
1:53a177a:         SchemaLoader.prepareServer();
1:53a177a:         SchemaLoader.createKeyspace(KEYSPACE1,
1:53a177a:                                     KeyspaceParams.simple(1),
1:53a177a:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1, 1, BytesType.instance),
1:53a177a:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2, 1, BytesType.instance),
1:53a177a:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD3, 1, BytesType.instance),
1:53a177a:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD4, 1, BytesType.instance),
1:53a177a:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD5, 1, BytesType.instance));
1:53a177a:     }
1:53a177a: 
1:53a177a:     @AfterClass
1:53a177a:     public static void cleanup()
1:53a177a:     {
1:53a177a:         sw.close();
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Before
1:53a177a:     @SuppressWarnings("deprecation")
1:53a177a:     public void setUp() throws Exception
1:53a177a:     {
1:53a177a:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:53a177a:         InetAddress localhost = InetAddress.getByName("127.0.0.1");
1:53a177a:         metadata.updateNormalToken(Util.token("A"), localhost);
1:53a177a:         metadata.updateHostId(UUIDGen.getTimeUUID(), localhost);
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).truncateBlocking();
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).truncateBlocking();
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testDelete()
1:53a177a:     {
1:53a177a:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1);
1:53a177a:         CFMetaData cfm = cfs.metadata;
1:53a177a:         new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes("1234"))
1:53a177a:                 .clustering("c")
1:53a177a:                 .add("val", "val" + 1234)
1:53a177a:                 .build()
1:53a177a:                 .applyUnsafe();
1:53a177a: 
1:53a177a:         DecoratedKey dk = cfs.decorateKey(ByteBufferUtil.bytes("1234"));
1:53a177a:         ImmutableBTreePartition results = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, dk).build());
1:53a177a:         Iterator<Row> iter = results.iterator();
1:53a177a:         assert iter.hasNext();
1:53a177a: 
1:53a177a:         Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(cfm,
1:53a177a:                                                          dk,
1:53a177a:                                                          FBUtilities.timestampMicros(),
1:53a177a:                                                          FBUtilities.nowInSeconds()));
1:53a177a:         mutation.applyUnsafe();
1:53a177a: 
1:53a177a:         Util.assertEmpty(Util.cmd(cfs, dk).build());
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testReplay() throws Exception
1:53a177a:     {
1:53a177a:         testReplay(false);
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testLegacyReplay() throws Exception
1:53a177a:     {
1:53a177a:         testReplay(true);
1:53a177a:     }
1:53a177a: 
1:53a177a:     @SuppressWarnings("deprecation")
1:53a177a:     private static void testReplay(boolean legacy) throws Exception
1:53a177a:     {
1:53a177a:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:53a177a:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1:53a177a: 
1:53a177a:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1).metadata;
1:53a177a: 
1:53a177a:         // Generate 1000 mutations (100 batches of 10 mutations each) and put them all into the batchlog.
1:53a177a:         // Half batches (50) ready to be replayed, half not.
1:53a177a:         for (int i = 0; i < 100; i++)
1:53a177a:         {
1:53a177a:             List<Mutation> mutations = new ArrayList<>(10);
1:53a177a:             for (int j = 0; j < 10; j++)
1:53a177a:             {
1:53a177a:                 mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:53a177a:                               .clustering("name" + j)
1:53a177a:                               .add("val", "val" + j)
1:53a177a:                               .build());
1:53a177a:             }
1:53a177a: 
1:53a177a:             long timestamp = i < 50
1:53a177a:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:53a177a:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1:53a177a: 
1:53a177a:             if (legacy)
1:53a177a:                 LegacyBatchlogMigrator.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), timestamp * 1000, mutations), MessagingService.current_version);
1:53a177a:             else
1:53a177a:                 BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), timestamp * 1000, mutations));
1:53a177a:         }
1:53a177a: 
1:53a177a:         if (legacy)
1:53a177a:         {
1:9797511:             Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).forceBlockingFlush();
1:53a177a:             LegacyBatchlogMigrator.migrate();
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Flush the batchlog to disk (see CASSANDRA-6822).
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1:53a177a: 
1:53a177a:         assertEquals(100, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:53a177a:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1:53a177a: 
1:53a177a:         // Force batchlog replay and wait for it to complete.
1:53a177a:         BatchlogManager.instance.startBatchlogReplay().get();
1:53a177a: 
1:53a177a:         // Ensure that the first half, and only the first half, got replayed.
1:53a177a:         assertEquals(50, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:53a177a:         assertEquals(50, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1:53a177a: 
1:53a177a:         for (int i = 0; i < 100; i++)
1:53a177a:         {
1:53a177a:             String query = String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD1, i);
1:53a177a:             UntypedResultSet result = executeInternal(query);
1:53a177a:             assertNotNull(result);
1:53a177a:             if (i < 50)
1:53a177a:             {
1:53a177a:                 Iterator<UntypedResultSet.Row> it = result.iterator();
1:53a177a:                 assertNotNull(it);
1:53a177a:                 for (int j = 0; j < 10; j++)
1:53a177a:                 {
1:53a177a:                     assertTrue(it.hasNext());
1:53a177a:                     UntypedResultSet.Row row = it.next();
1:1492be0: 
1:53a177a:                     assertEquals(ByteBufferUtil.bytes(i), row.getBytes("key"));
1:53a177a:                     assertEquals("name" + j, row.getString("name"));
1:53a177a:                     assertEquals("val" + j, row.getString("val"));
1:53a177a:                 }
1:53a177a: 
1:53a177a:                 assertFalse(it.hasNext());
1:53a177a:             }
1:53a177a:             else
1:53a177a:             {
1:53a177a:                 assertTrue(result.isEmpty());
1:53a177a:             }
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Ensure that no stray mutations got somehow applied.
1:53a177a:         UntypedResultSet result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", KEYSPACE1, CF_STANDARD1));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals(500, result.one().getLong("count"));
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testTruncatedReplay() throws InterruptedException, ExecutionException
1:53a177a:     {
1:53a177a:         CFMetaData cf2 = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD2);
1:53a177a:         CFMetaData cf3 = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD3);
1:53a177a:         // Generate 2000 mutations (1000 batchlog entries) and put them all into the batchlog.
1:53a177a:         // Each batchlog entry with a mutation for Standard2 and Standard3.
1:53a177a:         // In the middle of the process, 'truncate' Standard2.
1:53a177a:         for (int i = 0; i < 1000; i++)
1:53a177a:         {
1:53a177a:             Mutation mutation1 = new RowUpdateBuilder(cf2, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:53a177a:                 .clustering("name" + i)
1:53a177a:                 .add("val", "val" + i)
1:53a177a:                 .build();
1:53a177a:             Mutation mutation2 = new RowUpdateBuilder(cf3, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:53a177a:                 .clustering("name" + i)
1:53a177a:                 .add("val", "val" + i)
1:53a177a:                 .build();
1:53a177a: 
1:53a177a:             List<Mutation> mutations = Lists.newArrayList(mutation1, mutation2);
1:53a177a: 
1:53a177a:             // Make sure it's ready to be replayed, so adjust the timestamp.
1:53a177a:             long timestamp = System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout();
1:53a177a: 
1:53a177a:             if (i == 500)
1:53a177a:                 SystemKeyspace.saveTruncationRecord(Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD2),
1:53a177a:                                                     timestamp,
1:e31e216:                                                     CommitLogPosition.NONE);
1:53a177a: 
1:53a177a:             // Adjust the timestamp (slightly) to make the test deterministic.
1:53a177a:             if (i >= 500)
1:53a177a:                 timestamp++;
1:53a177a:             else
1:53a177a:                 timestamp--;
1:53a177a: 
1:53a177a:             BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), FBUtilities.timestampMicros(), mutations));
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Flush the batchlog to disk (see CASSANDRA-6822).
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1:53a177a: 
1:53a177a:         // Force batchlog replay and wait for it to complete.
1:53a177a:         BatchlogManager.instance.startBatchlogReplay().get();
1:53a177a: 
1:53a177a:         // We should see half of Standard2-targeted mutations written after the replay and all of Standard3 mutations applied.
1:53a177a:         for (int i = 0; i < 1000; i++)
1:53a177a:         {
1:53a177a:             UntypedResultSet result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD2,i));
1:53a177a:             assertNotNull(result);
1:53a177a:             if (i >= 500)
1:53a177a:             {
1:53a177a:                 assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:53a177a:                 assertEquals("name" + i, result.one().getString("name"));
1:53a177a:                 assertEquals("val" + i, result.one().getString("val"));
1:53a177a:             }
1:53a177a:             else
1:53a177a:             {
1:53a177a:                 assertTrue(result.isEmpty());
1:53a177a:             }
1:53a177a:         }
1:53a177a: 
1:53a177a:         for (int i = 0; i < 1000; i++)
1:53a177a:         {
1:53a177a:             UntypedResultSet result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD3, i));
1:53a177a:             assertNotNull(result);
1:53a177a:             assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:53a177a:             assertEquals("name" + i, result.one().getString("name"));
1:53a177a:             assertEquals("val" + i, result.one().getString("val"));
1:53a177a:         }
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     @SuppressWarnings("deprecation")
1:53a177a:     public void testConversion() throws Exception
1:53a177a:     {
1:53a177a:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:53a177a:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1:53a177a:         CFMetaData cfm = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD4);
1:53a177a: 
1:53a177a:         // Generate 1400 version 2.0 mutations and put them all into the batchlog.
1:53a177a:         // Half ready to be replayed, half not.
1:53a177a:         for (int i = 0; i < 1400; i++)
1:53a177a:         {
1:53a177a:             Mutation mutation = new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:53a177a:                 .clustering("name" + i)
1:53a177a:                 .add("val", "val" + i)
1:53a177a:                 .build();
1:53a177a: 
1:53a177a:             long timestamp = i < 700
1:53a177a:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:53a177a:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1:53a177a: 
1:53a177a: 
1:53a177a:             Mutation batchMutation = LegacyBatchlogMigrator.getStoreMutation(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i),
1:53a177a:                                                                                                TimeUnit.MILLISECONDS.toMicros(timestamp),
1:53a177a:                                                                                                Collections.singleton(mutation)),
1:53a177a:                                                                              MessagingService.VERSION_20);
1:53a177a:             assertTrue(LegacyBatchlogMigrator.isLegacyBatchlogMutation(batchMutation));
1:53a177a:             LegacyBatchlogMigrator.handleLegacyMutation(batchMutation);
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Mix in 100 current version mutations, 50 ready for replay.
1:53a177a:         for (int i = 1400; i < 1500; i++)
1:53a177a:         {
1:53a177a:             Mutation mutation = new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:53a177a:                 .clustering("name" + i)
1:53a177a:                 .add("val", "val" + i)
1:53a177a:                 .build();
1:53a177a: 
1:53a177a:             long timestamp = i < 1450
1:53a177a:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:53a177a:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1:53a177a: 
1:53a177a: 
1:53a177a:             BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i),
1:53a177a:                                                     FBUtilities.timestampMicros(),
1:53a177a:                                                     Collections.singleton(mutation)));
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Flush the batchlog to disk (see CASSANDRA-6822).
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1:53a177a: 
1:53a177a:         assertEquals(1500, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:53a177a:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1:53a177a: 
1:9797511:         UntypedResultSet result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.LEGACY_BATCHLOG));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals("Count in blog legacy", 0, result.one().getLong("count"));
1:9797511:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.BATCHES));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals("Count in blog", 1500, result.one().getLong("count"));
1:53a177a: 
1:53a177a:         // Force batchlog replay and wait for it to complete.
1:53a177a:         BatchlogManager.instance.performInitialReplay();
1:53a177a: 
1:53a177a:         // Ensure that the first half, and only the first half, got replayed.
1:53a177a:         assertEquals(750, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:53a177a:         assertEquals(750, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1:53a177a: 
1:53a177a:         for (int i = 0; i < 1500; i++)
1:53a177a:         {
1:53a177a:             result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD4, i));
1:53a177a:             assertNotNull(result);
1:53a177a:             if (i < 700 || i >= 1400 && i < 1450)
1:53a177a:             {
1:53a177a:                 assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:53a177a:                 assertEquals("name" + i, result.one().getString("name"));
1:53a177a:                 assertEquals("val" + i, result.one().getString("val"));
1:53a177a:             }
1:53a177a:             else
1:53a177a:             {
1:53a177a:                 assertTrue("Present at " + i, result.isEmpty());
1:53a177a:             }
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Ensure that no stray mutations got somehow applied.
1:53a177a:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", KEYSPACE1, CF_STANDARD4));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals(750, result.one().getLong("count"));
1:53a177a: 
1:53a177a:         // Ensure batchlog is left as expected.
1:9797511:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.BATCHES));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals("Count in blog after initial replay", 750, result.one().getLong("count"));
1:9797511:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.LEGACY_BATCHLOG));
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals("Count in blog legacy after initial replay ", 0, result.one().getLong("count"));
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testAddBatch() throws IOException
1:53a177a:     {
1:53a177a:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:53a177a:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD5).metadata;
1:53a177a: 
1:53a177a:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:53a177a:         UUID uuid = UUIDGen.getTimeUUID();
1:53a177a: 
1:53a177a:         // Add a batch with 10 mutations
1:53a177a:         List<Mutation> mutations = new ArrayList<>(10);
1:53a177a:         for (int j = 0; j < 10; j++)
1:53a177a:         {
1:53a177a:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:53a177a:                           .clustering("name" + j)
1:53a177a:                           .add("val", "val" + j)
1:53a177a:                           .build());
1:53a177a:         }
1:53a177a: 
1:53a177a: 
1:53a177a:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:53a177a:         Assert.assertEquals(initialAllBatches + 1, BatchlogManager.instance.countAllBatches());
1:53a177a: 
1:53a177a:         String query = String.format("SELECT count(*) FROM %s.%s where id = %s",
1:9797511:                                      SchemaConstants.SYSTEM_KEYSPACE_NAME,
1:53a177a:                                      SystemKeyspace.BATCHES,
1:53a177a:                                      uuid);
1:53a177a:         UntypedResultSet result = executeInternal(query);
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals(1L, result.one().getLong("count"));
1:53a177a:     }
1:53a177a: 
1:53a177a:     @Test
1:53a177a:     public void testRemoveBatch()
1:53a177a:     {
1:53a177a:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:53a177a:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD5).metadata;
1:53a177a: 
1:53a177a:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:53a177a:         UUID uuid = UUIDGen.getTimeUUID();
1:53a177a: 
1:53a177a:         // Add a batch with 10 mutations
1:53a177a:         List<Mutation> mutations = new ArrayList<>(10);
1:53a177a:         for (int j = 0; j < 10; j++)
1:53a177a:         {
1:53a177a:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:53a177a:                           .clustering("name" + j)
1:53a177a:                           .add("val", "val" + j)
1:53a177a:                           .build());
1:53a177a:         }
1:53a177a: 
1:53a177a:         // Store the batch
1:53a177a:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:53a177a:         Assert.assertEquals(initialAllBatches + 1, BatchlogManager.instance.countAllBatches());
1:53a177a: 
1:53a177a:         // Remove the batch
1:53a177a:         BatchlogManager.remove(uuid);
1:53a177a: 
1:53a177a:         assertEquals(initialAllBatches, BatchlogManager.instance.countAllBatches());
1:53a177a: 
1:53a177a:         String query = String.format("SELECT count(*) FROM %s.%s where id = %s",
1:9797511:                                      SchemaConstants.SYSTEM_KEYSPACE_NAME,
1:53a177a:                                      SystemKeyspace.BATCHES,
1:53a177a:                                      uuid);
1:53a177a:         UntypedResultSet result = executeInternal(query);
1:53a177a:         assertNotNull(result);
1:53a177a:         assertEquals(0L, result.one().getLong("count"));
1:53a177a:     }
1:1492be0: 
1:1492be0:     // CASSANRDA-9223
1:1492be0:     @Test
1:1492be0:     public void testReplayWithNoPeers() throws Exception
1:1492be0:     {
1:1492be0:         StorageService.instance.getTokenMetadata().removeEndpoint(InetAddress.getByName("127.0.0.1"));
1:1492be0: 
1:1492be0:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:1492be0:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1:1492be0: 
1:1492be0:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1).metadata;
1:1492be0: 
1:1492be0:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:1492be0:         UUID uuid = UUIDGen.getTimeUUID();
1:1492be0: 
1:1492be0:         // Add a batch with 10 mutations
1:1492be0:         List<Mutation> mutations = new ArrayList<>(10);
1:1492be0:         for (int j = 0; j < 10; j++)
1:1492be0:         {
1:1492be0:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:1492be0:                           .clustering("name" + j)
1:1492be0:                           .add("val", "val" + j)
1:1492be0:                           .build());
1:1492be0:         }
1:1492be0:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:1492be0:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:1492be0: 
1:1492be0:         // Flush the batchlog to disk (see CASSANDRA-6822).
1:9797511:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1:1492be0: 
1:1492be0:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:1492be0:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1:1492be0: 
1:1492be0:         // Force batchlog replay and wait for it to complete.
1:1492be0:         BatchlogManager.instance.startBatchlogReplay().get();
1:53a177a: 
1:1492be0:         // Replay should be cancelled as there are no peers in the ring.
1:1492be0:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:1492be0:     }
1:53a177a: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).truncateBlocking();
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).truncateBlocking();
/////////////////////////////////////////////////////////////////////////
1:             Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).forceBlockingFlush();
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1:         UntypedResultSet result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.LEGACY_BATCHLOG));
1:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.BATCHES));
/////////////////////////////////////////////////////////////////////////
1:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.BATCHES));
1:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.LEGACY_BATCHLOG));
/////////////////////////////////////////////////////////////////////////
1:                                      SchemaConstants.SYSTEM_KEYSPACE_NAME,
/////////////////////////////////////////////////////////////////////////
1:                                      SchemaConstants.SYSTEM_KEYSPACE_NAME,
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:e31e216
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.commitlog.CommitLogPosition;
/////////////////////////////////////////////////////////////////////////
1:                                                     CommitLogPosition.NONE);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:1492be0
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     // CASSANRDA-9223
1:     @Test
1:     public void testReplayWithNoPeers() throws Exception
1:     {
1:         StorageService.instance.getTokenMetadata().removeEndpoint(InetAddress.getByName("127.0.0.1"));
1: 
1:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1: 
1:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1).metadata;
1: 
1:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:         UUID uuid = UUIDGen.getTimeUUID();
1: 
1:         // Add a batch with 10 mutations
1:         List<Mutation> mutations = new ArrayList<>(10);
1:         for (int j = 0; j < 10; j++)
1:         {
1:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:                           .clustering("name" + j)
1:                           .add("val", "val" + j)
1:                           .build());
1:         }
1:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1: 
1:         // Flush the batchlog to disk (see CASSANDRA-6822).
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1: 
1:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1: 
1:         // Force batchlog replay and wait for it to complete.
1:         BatchlogManager.instance.startBatchlogReplay().get();
1: 
1:         // Replay should be cancelled as there are no peers in the ring.
1:         assertEquals(1, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:     }
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:53a177a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.batchlog;
1: 
1: import java.io.IOException;
1: import java.net.InetAddress;
1: import java.util.*;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.TimeUnit;
1: 
1: import com.google.common.collect.Lists;
1: import org.junit.*;
1: 
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.Util.PartitionerSwitcher;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.cql3.UntypedResultSet;
1: import org.apache.cassandra.db.ColumnFamilyStore;
1: import org.apache.cassandra.db.DecoratedKey;
1: import org.apache.cassandra.db.Keyspace;
1: import org.apache.cassandra.db.Mutation;
1: import org.apache.cassandra.db.RowUpdateBuilder;
1: import org.apache.cassandra.db.SystemKeyspace;
0: import org.apache.cassandra.db.commitlog.ReplayPosition;
1: import org.apache.cassandra.db.marshal.BytesType;
1: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1: import org.apache.cassandra.db.partitions.PartitionUpdate;
1: import org.apache.cassandra.db.rows.Row;
1: import org.apache.cassandra.dht.Murmur3Partitioner;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.locator.TokenMetadata;
1: import org.apache.cassandra.net.MessagingService;
1: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.schema.KeyspaceParams;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.UUIDGen;
1: 
1: import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
1: import static org.junit.Assert.*;
1: 
1: public class BatchlogManagerTest
1: {
1:     private static final String KEYSPACE1 = "BatchlogManagerTest1";
1:     private static final String CF_STANDARD1 = "Standard1";
1:     private static final String CF_STANDARD2 = "Standard2";
1:     private static final String CF_STANDARD3 = "Standard3";
1:     private static final String CF_STANDARD4 = "Standard4";
1:     private static final String CF_STANDARD5 = "Standard5";
1: 
1:     static PartitionerSwitcher sw;
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         sw = Util.switchPartitioner(Murmur3Partitioner.instance);
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
1:                                     KeyspaceParams.simple(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1, 1, BytesType.instance),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2, 1, BytesType.instance),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD3, 1, BytesType.instance),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD4, 1, BytesType.instance),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD5, 1, BytesType.instance));
1:     }
1: 
1:     @AfterClass
1:     public static void cleanup()
1:     {
1:         sw.close();
1:     }
1: 
1:     @Before
1:     @SuppressWarnings("deprecation")
1:     public void setUp() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         InetAddress localhost = InetAddress.getByName("127.0.0.1");
1:         metadata.updateNormalToken(Util.token("A"), localhost);
1:         metadata.updateHostId(UUIDGen.getTimeUUID(), localhost);
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).truncateBlocking();
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).truncateBlocking();
1:     }
1: 
1:     @Test
1:     public void testDelete()
1:     {
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1);
1:         CFMetaData cfm = cfs.metadata;
1:         new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes("1234"))
1:                 .clustering("c")
1:                 .add("val", "val" + 1234)
1:                 .build()
1:                 .applyUnsafe();
1: 
1:         DecoratedKey dk = cfs.decorateKey(ByteBufferUtil.bytes("1234"));
1:         ImmutableBTreePartition results = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, dk).build());
1:         Iterator<Row> iter = results.iterator();
1:         assert iter.hasNext();
1: 
1:         Mutation mutation = new Mutation(PartitionUpdate.fullPartitionDelete(cfm,
1:                                                          dk,
1:                                                          FBUtilities.timestampMicros(),
1:                                                          FBUtilities.nowInSeconds()));
1:         mutation.applyUnsafe();
1: 
1:         Util.assertEmpty(Util.cmd(cfs, dk).build());
1:     }
1: 
1:     @Test
1:     public void testReplay() throws Exception
1:     {
1:         testReplay(false);
1:     }
1: 
1:     @Test
1:     public void testLegacyReplay() throws Exception
1:     {
1:         testReplay(true);
1:     }
1: 
1:     @SuppressWarnings("deprecation")
1:     private static void testReplay(boolean legacy) throws Exception
1:     {
1:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1: 
1:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1).metadata;
1: 
1:         // Generate 1000 mutations (100 batches of 10 mutations each) and put them all into the batchlog.
1:         // Half batches (50) ready to be replayed, half not.
1:         for (int i = 0; i < 100; i++)
1:         {
1:             List<Mutation> mutations = new ArrayList<>(10);
1:             for (int j = 0; j < 10; j++)
1:             {
1:                 mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:                               .clustering("name" + j)
1:                               .add("val", "val" + j)
1:                               .build());
1:             }
1: 
1:             long timestamp = i < 50
1:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1: 
1:             if (legacy)
1:                 LegacyBatchlogMigrator.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), timestamp * 1000, mutations), MessagingService.current_version);
1:             else
1:                 BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), timestamp * 1000, mutations));
1:         }
1: 
1:         if (legacy)
1:         {
0:             Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_BATCHLOG).forceBlockingFlush();
1:             LegacyBatchlogMigrator.migrate();
1:         }
1: 
1:         // Flush the batchlog to disk (see CASSANDRA-6822).
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1: 
1:         assertEquals(100, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1: 
1:         // Force batchlog replay and wait for it to complete.
1:         BatchlogManager.instance.startBatchlogReplay().get();
1: 
1:         // Ensure that the first half, and only the first half, got replayed.
1:         assertEquals(50, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:         assertEquals(50, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1: 
1:         for (int i = 0; i < 100; i++)
1:         {
1:             String query = String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD1, i);
1:             UntypedResultSet result = executeInternal(query);
1:             assertNotNull(result);
1:             if (i < 50)
1:             {
1:                 Iterator<UntypedResultSet.Row> it = result.iterator();
1:                 assertNotNull(it);
1:                 for (int j = 0; j < 10; j++)
1:                 {
1:                     assertTrue(it.hasNext());
1:                     UntypedResultSet.Row row = it.next();
1: 
1:                     assertEquals(ByteBufferUtil.bytes(i), row.getBytes("key"));
1:                     assertEquals("name" + j, row.getString("name"));
1:                     assertEquals("val" + j, row.getString("val"));
1:                 }
1: 
1:                 assertFalse(it.hasNext());
1:             }
1:             else
1:             {
1:                 assertTrue(result.isEmpty());
1:             }
1:         }
1: 
1:         // Ensure that no stray mutations got somehow applied.
1:         UntypedResultSet result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", KEYSPACE1, CF_STANDARD1));
1:         assertNotNull(result);
1:         assertEquals(500, result.one().getLong("count"));
1:     }
1: 
1:     @Test
1:     public void testTruncatedReplay() throws InterruptedException, ExecutionException
1:     {
1:         CFMetaData cf2 = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD2);
1:         CFMetaData cf3 = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD3);
1:         // Generate 2000 mutations (1000 batchlog entries) and put them all into the batchlog.
1:         // Each batchlog entry with a mutation for Standard2 and Standard3.
1:         // In the middle of the process, 'truncate' Standard2.
1:         for (int i = 0; i < 1000; i++)
1:         {
1:             Mutation mutation1 = new RowUpdateBuilder(cf2, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:                 .clustering("name" + i)
1:                 .add("val", "val" + i)
1:                 .build();
1:             Mutation mutation2 = new RowUpdateBuilder(cf3, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:                 .clustering("name" + i)
1:                 .add("val", "val" + i)
1:                 .build();
1: 
1:             List<Mutation> mutations = Lists.newArrayList(mutation1, mutation2);
1: 
1:             // Make sure it's ready to be replayed, so adjust the timestamp.
1:             long timestamp = System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout();
1: 
1:             if (i == 500)
1:                 SystemKeyspace.saveTruncationRecord(Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD2),
1:                                                     timestamp,
0:                                                     ReplayPosition.NONE);
1: 
1:             // Adjust the timestamp (slightly) to make the test deterministic.
1:             if (i >= 500)
1:                 timestamp++;
1:             else
1:                 timestamp--;
1: 
1:             BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i), FBUtilities.timestampMicros(), mutations));
1:         }
1: 
1:         // Flush the batchlog to disk (see CASSANDRA-6822).
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1: 
1:         // Force batchlog replay and wait for it to complete.
1:         BatchlogManager.instance.startBatchlogReplay().get();
1: 
1:         // We should see half of Standard2-targeted mutations written after the replay and all of Standard3 mutations applied.
1:         for (int i = 0; i < 1000; i++)
1:         {
1:             UntypedResultSet result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD2,i));
1:             assertNotNull(result);
1:             if (i >= 500)
1:             {
1:                 assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:                 assertEquals("name" + i, result.one().getString("name"));
1:                 assertEquals("val" + i, result.one().getString("val"));
1:             }
1:             else
1:             {
1:                 assertTrue(result.isEmpty());
1:             }
1:         }
1: 
1:         for (int i = 0; i < 1000; i++)
1:         {
1:             UntypedResultSet result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD3, i));
1:             assertNotNull(result);
1:             assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:             assertEquals("name" + i, result.one().getString("name"));
1:             assertEquals("val" + i, result.one().getString("val"));
1:         }
1:     }
1: 
1:     @Test
1:     @SuppressWarnings("deprecation")
1:     public void testConversion() throws Exception
1:     {
1:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:         long initialReplayedBatches = BatchlogManager.instance.getTotalBatchesReplayed();
1:         CFMetaData cfm = Schema.instance.getCFMetaData(KEYSPACE1, CF_STANDARD4);
1: 
1:         // Generate 1400 version 2.0 mutations and put them all into the batchlog.
1:         // Half ready to be replayed, half not.
1:         for (int i = 0; i < 1400; i++)
1:         {
1:             Mutation mutation = new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:                 .clustering("name" + i)
1:                 .add("val", "val" + i)
1:                 .build();
1: 
1:             long timestamp = i < 700
1:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1: 
1: 
1:             Mutation batchMutation = LegacyBatchlogMigrator.getStoreMutation(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i),
1:                                                                                                TimeUnit.MILLISECONDS.toMicros(timestamp),
1:                                                                                                Collections.singleton(mutation)),
1:                                                                              MessagingService.VERSION_20);
1:             assertTrue(LegacyBatchlogMigrator.isLegacyBatchlogMutation(batchMutation));
1:             LegacyBatchlogMigrator.handleLegacyMutation(batchMutation);
1:         }
1: 
1:         // Mix in 100 current version mutations, 50 ready for replay.
1:         for (int i = 1400; i < 1500; i++)
1:         {
1:             Mutation mutation = new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(i))
1:                 .clustering("name" + i)
1:                 .add("val", "val" + i)
1:                 .build();
1: 
1:             long timestamp = i < 1450
1:                            ? (System.currentTimeMillis() - BatchlogManager.getBatchlogTimeout())
1:                            : (System.currentTimeMillis() + BatchlogManager.getBatchlogTimeout());
1: 
1: 
1:             BatchlogManager.store(Batch.createLocal(UUIDGen.getTimeUUID(timestamp, i),
1:                                                     FBUtilities.timestampMicros(),
1:                                                     Collections.singleton(mutation)));
1:         }
1: 
1:         // Flush the batchlog to disk (see CASSANDRA-6822).
0:         Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHES).forceBlockingFlush();
1: 
1:         assertEquals(1500, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1: 
0:         UntypedResultSet result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SystemKeyspace.NAME, SystemKeyspace.LEGACY_BATCHLOG));
1:         assertNotNull(result);
1:         assertEquals("Count in blog legacy", 0, result.one().getLong("count"));
0:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SystemKeyspace.NAME, SystemKeyspace.BATCHES));
1:         assertNotNull(result);
1:         assertEquals("Count in blog", 1500, result.one().getLong("count"));
1: 
1:         // Force batchlog replay and wait for it to complete.
1:         BatchlogManager.instance.performInitialReplay();
1: 
1:         // Ensure that the first half, and only the first half, got replayed.
1:         assertEquals(750, BatchlogManager.instance.countAllBatches() - initialAllBatches);
1:         assertEquals(750, BatchlogManager.instance.getTotalBatchesReplayed() - initialReplayedBatches);
1: 
1:         for (int i = 0; i < 1500; i++)
1:         {
1:             result = executeInternal(String.format("SELECT * FROM \"%s\".\"%s\" WHERE key = intAsBlob(%d)", KEYSPACE1, CF_STANDARD4, i));
1:             assertNotNull(result);
1:             if (i < 700 || i >= 1400 && i < 1450)
1:             {
1:                 assertEquals(ByteBufferUtil.bytes(i), result.one().getBytes("key"));
1:                 assertEquals("name" + i, result.one().getString("name"));
1:                 assertEquals("val" + i, result.one().getString("val"));
1:             }
1:             else
1:             {
1:                 assertTrue("Present at " + i, result.isEmpty());
1:             }
1:         }
1: 
1:         // Ensure that no stray mutations got somehow applied.
1:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", KEYSPACE1, CF_STANDARD4));
1:         assertNotNull(result);
1:         assertEquals(750, result.one().getLong("count"));
1: 
1:         // Ensure batchlog is left as expected.
0:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SystemKeyspace.NAME, SystemKeyspace.BATCHES));
1:         assertNotNull(result);
1:         assertEquals("Count in blog after initial replay", 750, result.one().getLong("count"));
0:         result = executeInternal(String.format("SELECT count(*) FROM \"%s\".\"%s\"", SystemKeyspace.NAME, SystemKeyspace.LEGACY_BATCHLOG));
1:         assertNotNull(result);
1:         assertEquals("Count in blog legacy after initial replay ", 0, result.one().getLong("count"));
1:     }
1: 
1:     @Test
1:     public void testAddBatch() throws IOException
1:     {
1:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD5).metadata;
1: 
1:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:         UUID uuid = UUIDGen.getTimeUUID();
1: 
1:         // Add a batch with 10 mutations
1:         List<Mutation> mutations = new ArrayList<>(10);
1:         for (int j = 0; j < 10; j++)
1:         {
1:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:                           .clustering("name" + j)
1:                           .add("val", "val" + j)
1:                           .build());
1:         }
1: 
1: 
1:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:         Assert.assertEquals(initialAllBatches + 1, BatchlogManager.instance.countAllBatches());
1: 
1:         String query = String.format("SELECT count(*) FROM %s.%s where id = %s",
0:                                      SystemKeyspace.NAME,
1:                                      SystemKeyspace.BATCHES,
1:                                      uuid);
1:         UntypedResultSet result = executeInternal(query);
1:         assertNotNull(result);
1:         assertEquals(1L, result.one().getLong("count"));
1:     }
1: 
1:     @Test
1:     public void testRemoveBatch()
1:     {
1:         long initialAllBatches = BatchlogManager.instance.countAllBatches();
1:         CFMetaData cfm = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD5).metadata;
1: 
1:         long timestamp = (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000;
1:         UUID uuid = UUIDGen.getTimeUUID();
1: 
1:         // Add a batch with 10 mutations
1:         List<Mutation> mutations = new ArrayList<>(10);
1:         for (int j = 0; j < 10; j++)
1:         {
1:             mutations.add(new RowUpdateBuilder(cfm, FBUtilities.timestampMicros(), ByteBufferUtil.bytes(j))
1:                           .clustering("name" + j)
1:                           .add("val", "val" + j)
1:                           .build());
1:         }
1: 
1:         // Store the batch
1:         BatchlogManager.store(Batch.createLocal(uuid, timestamp, mutations));
1:         Assert.assertEquals(initialAllBatches + 1, BatchlogManager.instance.countAllBatches());
1: 
1:         // Remove the batch
1:         BatchlogManager.remove(uuid);
1: 
1:         assertEquals(initialAllBatches, BatchlogManager.instance.countAllBatches());
1: 
1:         String query = String.format("SELECT count(*) FROM %s.%s where id = %s",
0:                                      SystemKeyspace.NAME,
1:                                      SystemKeyspace.BATCHES,
1:                                      uuid);
1:         UntypedResultSet result = executeInternal(query);
1:         assertNotNull(result);
1:         assertEquals(0L, result.one().getLong("count"));
1:     }
1: }
============================================================================