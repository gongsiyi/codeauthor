1:07cf56f: /*
1:07cf56f:  * Licensed to the Apache Software Foundation (ASF) under one
1:07cf56f:  * or more contributor license agreements.  See the NOTICE file
1:07cf56f:  * distributed with this work for additional information
1:07cf56f:  * regarding copyright ownership.  The ASF licenses this file
1:07cf56f:  * to you under the Apache License, Version 2.0 (the
1:07cf56f:  * "License"); you may not use this file except in compliance
1:07cf56f:  * with the License.  You may obtain a copy of the License at
1:6cb811b:  *
1:6cb811b:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6cb811b:  *
1:6cb811b:  * Unless required by applicable law or agreed to in writing, software
1:6cb811b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6cb811b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6cb811b:  * See the License for the specific language governing permissions and
1:6cb811b:  * limitations under the License.
1:6cb811b:  */
1:6cb811b: package org.apache.cassandra.utils.obs;
2:6cb811b: 
1:6cb811b: /**  A variety of high efficiency bit twiddling routines.
1:6cb811b:  * @lucene.internal
1:6cb811b:  */
1:7d857b4: public final class BitUtil
1:68d2526: {
1:6cb811b: 
1:6cb811b:   /** Returns the number of bits set in the long */
1:68d2526:   public static int pop(long x)
1:68d2526:   {
1:6cb811b:   /* Hacker's Delight 32 bit pop function:
1:6cb811b:    * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc
1:6cb811b:    *
1:6cb811b:   int pop(unsigned x) {
1:6cb811b:      x = x - ((x >> 1) & 0x55555555);
1:6cb811b:      x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
1:6cb811b:      x = (x + (x >> 4)) & 0x0F0F0F0F;
1:6cb811b:      x = x + (x >> 8);
1:6cb811b:      x = x + (x >> 16);
1:6cb811b:      return x & 0x0000003F;
1:6cb811b:     }
1:6cb811b:   ***/
1:6cb811b: 
1:6cb811b:     // 64 bit java version of the C function from above
1:6cb811b:     x = x - ((x >>> 1) & 0x5555555555555555L);
1:6cb811b:     x = (x & 0x3333333333333333L) + ((x >>>2 ) & 0x3333333333333333L);
1:6cb811b:     x = (x + (x >>> 4)) & 0x0F0F0F0F0F0F0F0FL;
1:6cb811b:     x = x + (x >>> 8);
1:6cb811b:     x = x + (x >>> 16);
1:6cb811b:     x = x + (x >>> 32);
1:6cb811b:     return ((int)x) & 0x7F;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /*** Returns the number of set bits in an array of longs. */
1:68d2526:   public static long pop_array(long A[], int wordOffset, int numWords)
1:68d2526:   {
1:6cb811b:     /*
1:6cb811b:     * Robert Harley and David Seal's bit counting algorithm, as documented
1:6cb811b:     * in the revisions of Hacker's Delight
1:6cb811b:     * http://www.hackersdelight.org/revisions.pdf
1:6cb811b:     * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc
1:6cb811b:     *
1:6cb811b:     * This function was adapted to Java, and extended to use 64 bit words.
1:6cb811b:     * if only we had access to wider registers like SSE from java...
1:6cb811b:     *
1:6cb811b:     * This function can be transformed to compute the popcount of other functions
1:6cb811b:     * on bitsets via something like this:
1:6cb811b:     * sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'
1:6cb811b:     *
1:6cb811b:     */
1:6cb811b:     int n = wordOffset+numWords;
1:6cb811b:     long tot=0, tot8=0;
1:6cb811b:     long ones=0, twos=0, fours=0;
1:6cb811b: 
1:6cb811b:     int i;
1:68d2526:     for (i = wordOffset; i <= n - 8; i+=8)
1:68d2526:     {
1:6cb811b:       /***  C macro from Hacker's Delight
1:6cb811b:        #define CSA(h,l, a,b,c) \
1:6cb811b:        {unsigned u = a ^ b; unsigned v = c; \
1:6cb811b:        h = (a & b) | (u & v); l = u ^ v;}
1:6cb811b:        ***/
1:6cb811b: 
1:6cb811b:       long twosA,twosB,foursA,foursB,eights;
1:6cb811b: 
1:6cb811b:       // CSA(twosA, ones, ones, A[i], A[i+1])
1:6cb811b:       {
1:6cb811b:         long b=A[i], c=A[i+1];
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, A[i+2], A[i+3])
1:6cb811b:       {
1:6cb811b:         long b=A[i+2], c=A[i+3];
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursA, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       //CSA(twosA, ones, ones, A[i+4], A[i+5])
1:6cb811b:       {
1:6cb811b:         long b=A[i+4], c=A[i+5];
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosA=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, A[i+6], A[i+7])
1:6cb811b:       {
1:6cb811b:         long b=A[i+6], c=A[i+7];
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursB, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursB=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b: 
1:6cb811b:       //CSA(eights, fours, fours, foursA, foursB)
1:6cb811b:       {
1:6cb811b:         long u=fours^foursA;
1:6cb811b:         eights=(fours&foursA)|(u&foursB);
1:6cb811b:         fours=u^foursB;
1:6cb811b:       }
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     // handle trailing words in a binary-search manner...
1:6cb811b:     // derived from the loop above by setting specific elements to 0.
1:6cb811b:     // the original method in Hackers Delight used a simple for loop:
1:6cb811b:     //   for (i = i; i < n; i++)      // Add in the last elements
1:6cb811b:     //  tot = tot + pop(A[i]);
1:6cb811b: 
1:68d2526:     if (i<=n-4)
1:68d2526:     {
1:6cb811b:       long twosA, twosB, foursA, eights;
1:68d2526:       {
1:6cb811b:         long b=A[i], c=A[i+1];
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:68d2526:       {
1:6cb811b:         long b=A[i+2], c=A[i+3];
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:68d2526:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=4;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<=n-2)
1:68d2526:     {
1:6cb811b:       long b=A[i], c=A[i+1];
1:6cb811b:       long u=ones ^ b;
1:6cb811b:       long twosA=(ones & b)|( u & c);
1:6cb811b:       ones=u^c;
1:6cb811b: 
1:6cb811b:       long foursA=twos&twosA;
1:6cb811b:       twos=twos^twosA;
1:6cb811b: 
1:6cb811b:       long eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=2;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<n)
1:68d2526:     {
1:6cb811b:       tot += pop(A[i]);
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     tot += (pop(fours)<<2)
1:6cb811b:             + (pop(twos)<<1)
1:6cb811b:             + pop(ones)
1:6cb811b:             + (tot8<<3);
1:6cb811b: 
1:6cb811b:     return tot;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** Returns the popcount or cardinality of the two sets after an intersection.
1:6cb811b:    * Neither array is modified.
1:6cb811b:    */
1:68d2526:   public static long pop_intersect(long A[], long B[], int wordOffset, int numWords)
1:68d2526:   {
1:6cb811b:     // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'
1:6cb811b:     int n = wordOffset+numWords;
1:6cb811b:     long tot=0, tot8=0;
1:6cb811b:     long ones=0, twos=0, fours=0;
1:6cb811b: 
1:6cb811b:     int i;
1:68d2526:     for (i = wordOffset; i <= n - 8; i+=8)
1:68d2526:     {
1:6cb811b:       long twosA,twosB,foursA,foursB,eights;
1:6cb811b: 
1:6cb811b:       // CSA(twosA, ones, ones, (A[i] & B[i]), (A[i+1] & B[i+1]))
1:68d2526:       {
1:6cb811b:         long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+2] & B[i+2]), (A[i+3] & B[i+3]))
1:68d2526:       {
1:6cb811b:         long b=(A[i+2] & B[i+2]), c=(A[i+3] & B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursA, twos, twos, twosA, twosB)
1:68d2526:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       //CSA(twosA, ones, ones, (A[i+4] & B[i+4]), (A[i+5] & B[i+5]))
1:68d2526:       {
1:6cb811b:         long b=(A[i+4] & B[i+4]), c=(A[i+5] & B[i+5]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosA=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+6] & B[i+6]), (A[i+7] & B[i+7]))
1:68d2526:       {
1:6cb811b:         long b=(A[i+6] & B[i+6]), c=(A[i+7] & B[i+7]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursB, twos, twos, twosA, twosB)
1:68d2526:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursB=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b: 
1:6cb811b:       //CSA(eights, fours, fours, foursA, foursB)
1:68d2526:       {
1:6cb811b:         long u=fours^foursA;
1:6cb811b:         eights=(fours&foursA)|(u&foursB);
1:6cb811b:         fours=u^foursB;
1:6cb811b:       }
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:     }
1:6cb811b: 
1:6cb811b: 
1:68d2526:     if (i<=n-4)
1:68d2526:     {
1:6cb811b:       long twosA, twosB, foursA, eights;
1:68d2526:       {
1:6cb811b:         long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:68d2526:       {
1:6cb811b:         long b=(A[i+2] & B[i+2]), c=(A[i+3] & B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=4;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<=n-2)
1:6cb811b:     {
1:6cb811b:       long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:6cb811b:       long u=ones ^ b;
1:6cb811b:       long twosA=(ones & b)|( u & c);
1:6cb811b:       ones=u^c;
1:6cb811b: 
1:6cb811b:       long foursA=twos&twosA;
1:6cb811b:       twos=twos^twosA;
1:6cb811b: 
1:6cb811b:       long eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=2;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<n)
1:6cb811b:     {
1:6cb811b:       tot += pop((A[i] & B[i]));
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     tot += (pop(fours)<<2)
1:6cb811b:             + (pop(twos)<<1)
1:6cb811b:             + pop(ones)
1:6cb811b:             + (tot8<<3);
1:6cb811b: 
1:6cb811b:     return tot;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** Returns the popcount or cardinality of the union of two sets.
1:6cb811b:     * Neither array is modified.
1:6cb811b:     */
1:68d2526:    public static long pop_union(long A[], long B[], int wordOffset, int numWords)
1:68d2526:    {
1:6cb811b:      // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \| B[\1]\)/g'
1:6cb811b:      int n = wordOffset+numWords;
1:6cb811b:      long tot=0, tot8=0;
1:6cb811b:      long ones=0, twos=0, fours=0;
1:6cb811b: 
1:6cb811b:      int i;
1:68d2526:      for (i = wordOffset; i <= n - 8; i+=8)
1:68d2526:      {
1:6cb811b:        /***  C macro from Hacker's Delight
1:6cb811b:         #define CSA(h,l, a,b,c) \
1:6cb811b:         {unsigned u = a ^ b; unsigned v = c; \
1:6cb811b:         h = (a & b) | (u & v); l = u ^ v;}
1:6cb811b:         ***/
1:6cb811b: 
1:6cb811b:        long twosA,twosB,foursA,foursB,eights;
1:6cb811b: 
1:6cb811b:        // CSA(twosA, ones, ones, (A[i] | B[i]), (A[i+1] | B[i+1]))
1:6cb811b:        {
1:6cb811b:          long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:6cb811b:          long u=ones ^ b;
1:6cb811b:          twosA=(ones & b)|( u & c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        // CSA(twosB, ones, ones, (A[i+2] | B[i+2]), (A[i+3] | B[i+3]))
1:6cb811b:        {
1:6cb811b:          long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
1:6cb811b:          long u=ones^b;
1:6cb811b:          twosB =(ones&b)|(u&c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        //CSA(foursA, twos, twos, twosA, twosB)
1:6cb811b:        {
1:6cb811b:          long u=twos^twosA;
1:6cb811b:          foursA=(twos&twosA)|(u&twosB);
1:6cb811b:          twos=u^twosB;
1:6cb811b:        }
1:6cb811b:        //CSA(twosA, ones, ones, (A[i+4] | B[i+4]), (A[i+5] | B[i+5]))
1:6cb811b:        {
1:6cb811b:          long b=(A[i+4] | B[i+4]), c=(A[i+5] | B[i+5]);
1:6cb811b:          long u=ones^b;
1:6cb811b:          twosA=(ones&b)|(u&c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        // CSA(twosB, ones, ones, (A[i+6] | B[i+6]), (A[i+7] | B[i+7]))
1:6cb811b:        {
1:6cb811b:          long b=(A[i+6] | B[i+6]), c=(A[i+7] | B[i+7]);
1:6cb811b:          long u=ones^b;
1:6cb811b:          twosB=(ones&b)|(u&c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        //CSA(foursB, twos, twos, twosA, twosB)
1:6cb811b:        {
1:6cb811b:          long u=twos^twosA;
1:6cb811b:          foursB=(twos&twosA)|(u&twosB);
1:6cb811b:          twos=u^twosB;
1:6cb811b:        }
1:6cb811b: 
1:6cb811b:        //CSA(eights, fours, fours, foursA, foursB)
1:6cb811b:        {
1:6cb811b:          long u=fours^foursA;
1:6cb811b:          eights=(fours&foursA)|(u&foursB);
1:6cb811b:          fours=u^foursB;
1:6cb811b:        }
1:6cb811b:        tot8 += pop(eights);
1:6cb811b:      }
1:6cb811b: 
1:6cb811b: 
1:68d2526:      if (i<=n-4)
1:6cb811b:      {
1:6cb811b:        long twosA, twosB, foursA, eights;
1:6cb811b:        {
1:6cb811b:          long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:6cb811b:          long u=ones ^ b;
1:6cb811b:          twosA=(ones & b)|( u & c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        {
1:6cb811b:          long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
1:6cb811b:          long u=ones^b;
1:6cb811b:          twosB =(ones&b)|(u&c);
1:6cb811b:          ones=u^c;
1:6cb811b:        }
1:6cb811b:        {
1:6cb811b:          long u=twos^twosA;
1:6cb811b:          foursA=(twos&twosA)|(u&twosB);
1:6cb811b:          twos=u^twosB;
1:6cb811b:        }
1:6cb811b:        eights=fours&foursA;
1:6cb811b:        fours=fours^foursA;
1:6cb811b: 
1:6cb811b:        tot8 += pop(eights);
1:6cb811b:        i+=4;
1:6cb811b:      }
1:6cb811b: 
1:68d2526:      if (i<=n-2)
1:6cb811b:      {
1:6cb811b:        long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:6cb811b:        long u=ones ^ b;
1:6cb811b:        long twosA=(ones & b)|( u & c);
1:6cb811b:        ones=u^c;
1:6cb811b: 
1:6cb811b:        long foursA=twos&twosA;
1:6cb811b:        twos=twos^twosA;
1:6cb811b: 
1:6cb811b:        long eights=fours&foursA;
1:6cb811b:        fours=fours^foursA;
1:6cb811b: 
1:6cb811b:        tot8 += pop(eights);
1:6cb811b:        i+=2;
1:6cb811b:      }
1:6cb811b: 
1:68d2526:      if (i<n)
1:6cb811b:      {
1:6cb811b:        tot += pop((A[i] | B[i]));
1:6cb811b:      }
1:6cb811b: 
1:6cb811b:      tot += (pop(fours)<<2)
1:6cb811b:              + (pop(twos)<<1)
1:6cb811b:              + pop(ones)
1:6cb811b:              + (tot8<<3);
1:6cb811b: 
1:6cb811b:      return tot;
1:6cb811b:    }
1:6cb811b: 
1:6cb811b:   /** Returns the popcount or cardinality of A & ~B
1:6cb811b:    * Neither array is modified.
1:6cb811b:    */
1:68d2526:   public static long pop_andnot(long A[], long B[], int wordOffset, int numWords)
1:68d2526:   {
1:6cb811b:     // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& ~B[\1]\)/g'
1:6cb811b:     int n = wordOffset+numWords;
1:6cb811b:     long tot=0, tot8=0;
1:6cb811b:     long ones=0, twos=0, fours=0;
1:6cb811b: 
1:6cb811b:     int i;
1:68d2526:     for (i = wordOffset; i <= n - 8; i+=8)
1:68d2526:     {
1:6cb811b:       /***  C macro from Hacker's Delight
1:6cb811b:        #define CSA(h,l, a,b,c) \
1:6cb811b:        {unsigned u = a ^ b; unsigned v = c; \
1:6cb811b:        h = (a & b) | (u & v); l = u ^ v;}
1:6cb811b:        ***/
1:6cb811b: 
1:6cb811b:       long twosA,twosB,foursA,foursB,eights;
1:6cb811b: 
1:6cb811b:       // CSA(twosA, ones, ones, (A[i] & ~B[i]), (A[i+1] & ~B[i+1]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+2] & ~B[i+2]), (A[i+3] & ~B[i+3]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursA, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       //CSA(twosA, ones, ones, (A[i+4] & ~B[i+4]), (A[i+5] & ~B[i+5]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+4] & ~B[i+4]), c=(A[i+5] & ~B[i+5]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosA=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+6] & ~B[i+6]), (A[i+7] & ~B[i+7]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+6] & ~B[i+6]), c=(A[i+7] & ~B[i+7]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursB, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursB=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b: 
1:6cb811b:       //CSA(eights, fours, fours, foursA, foursB)
1:6cb811b:       {
1:6cb811b:         long u=fours^foursA;
1:6cb811b:         eights=(fours&foursA)|(u&foursB);
1:6cb811b:         fours=u^foursB;
1:6cb811b:       }
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:     }
1:6cb811b: 
1:6cb811b: 
1:68d2526:     if (i<=n-4)
1:6cb811b:     {
1:6cb811b:       long twosA, twosB, foursA, eights;
1:6cb811b:       {
1:6cb811b:         long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       {
1:6cb811b:         long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=4;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<=n-2)
1:6cb811b:     {
1:6cb811b:       long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:6cb811b:       long u=ones ^ b;
1:6cb811b:       long twosA=(ones & b)|( u & c);
1:6cb811b:       ones=u^c;
1:6cb811b: 
1:6cb811b:       long foursA=twos&twosA;
1:6cb811b:       twos=twos^twosA;
1:6cb811b: 
1:6cb811b:       long eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=2;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<n)
1:6cb811b:     {
1:6cb811b:       tot += pop((A[i] & ~B[i]));
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     tot += (pop(fours)<<2)
1:6cb811b:             + (pop(twos)<<1)
1:6cb811b:             + pop(ones)
1:6cb811b:             + (tot8<<3);
1:6cb811b: 
1:6cb811b:     return tot;
1:6cb811b:   }
1:6cb811b: 
1:68d2526:   public static long pop_xor(long A[], long B[], int wordOffset, int numWords)
1:68d2526:   {
1:6cb811b:     int n = wordOffset+numWords;
1:6cb811b:     long tot=0, tot8=0;
1:6cb811b:     long ones=0, twos=0, fours=0;
1:6cb811b: 
1:6cb811b:     int i;
1:68d2526:     for (i = wordOffset; i <= n - 8; i+=8)
1:6cb811b:     {
1:6cb811b:       /***  C macro from Hacker's Delight
1:6cb811b:        #define CSA(h,l, a,b,c) \
1:6cb811b:        {unsigned u = a ^ b; unsigned v = c; \
1:6cb811b:        h = (a & b) | (u & v); l = u ^ v;}
1:6cb811b:        ***/
1:6cb811b: 
1:6cb811b:       long twosA,twosB,foursA,foursB,eights;
1:6cb811b: 
1:6cb811b:       // CSA(twosA, ones, ones, (A[i] ^ B[i]), (A[i+1] ^ B[i+1]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+2] ^ B[i+2]), (A[i+3] ^ B[i+3]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+2] ^ B[i+2]), c=(A[i+3] ^ B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursA, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       //CSA(twosA, ones, ones, (A[i+4] ^ B[i+4]), (A[i+5] ^ B[i+5]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+4] ^ B[i+4]), c=(A[i+5] ^ B[i+5]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosA=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       // CSA(twosB, ones, ones, (A[i+6] ^ B[i+6]), (A[i+7] ^ B[i+7]))
1:6cb811b:       {
1:6cb811b:         long b=(A[i+6] ^ B[i+6]), c=(A[i+7] ^ B[i+7]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB=(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       //CSA(foursB, twos, twos, twosA, twosB)
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursB=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b: 
1:6cb811b:       //CSA(eights, fours, fours, foursA, foursB)
1:6cb811b:       {
1:6cb811b:         long u=fours^foursA;
1:6cb811b:         eights=(fours&foursA)|(u&foursB);
1:6cb811b:         fours=u^foursB;
1:6cb811b:       }
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:     }
1:6cb811b: 
1:6cb811b: 
1:68d2526:     if (i<=n-4)
1:6cb811b:     {
1:6cb811b:       long twosA, twosB, foursA, eights;
1:6cb811b:       {
1:6cb811b:         long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:6cb811b:         long u=ones ^ b;
1:6cb811b:         twosA=(ones & b)|( u & c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       {
1:6cb811b:         long b=(A[i+2] ^ B[i+2]), c=(A[i+3] ^ B[i+3]);
1:6cb811b:         long u=ones^b;
1:6cb811b:         twosB =(ones&b)|(u&c);
1:6cb811b:         ones=u^c;
1:6cb811b:       }
1:6cb811b:       {
1:6cb811b:         long u=twos^twosA;
1:6cb811b:         foursA=(twos&twosA)|(u&twosB);
1:6cb811b:         twos=u^twosB;
1:6cb811b:       }
1:6cb811b:       eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=4;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<=n-2)
1:6cb811b:     {
1:6cb811b:       long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:6cb811b:       long u=ones ^ b;
1:6cb811b:       long twosA=(ones & b)|( u & c);
1:6cb811b:       ones=u^c;
1:6cb811b: 
1:6cb811b:       long foursA=twos&twosA;
1:6cb811b:       twos=twos^twosA;
1:6cb811b: 
1:6cb811b:       long eights=fours&foursA;
1:6cb811b:       fours=fours^foursA;
1:6cb811b: 
1:6cb811b:       tot8 += pop(eights);
1:6cb811b:       i+=2;
1:6cb811b:     }
1:6cb811b: 
1:68d2526:     if (i<n)
1:6cb811b:     {
1:6cb811b:       tot += pop((A[i] ^ B[i]));
1:6cb811b:     }
1:6cb811b: 
1:6cb811b:     tot += (pop(fours)<<2)
1:6cb811b:             + (pop(twos)<<1)
1:6cb811b:             + pop(ones)
1:6cb811b:             + (tot8<<3);
1:6cb811b: 
1:6cb811b:     return tot;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /* python code to generate ntzTable
1:6cb811b:   def ntz(val):
1:6cb811b:     if val==0: return 8
1:6cb811b:     i=0
1:6cb811b:     while (val&0x01)==0:
1:6cb811b:       i = i+1
1:6cb811b:       val >>= 1
1:6cb811b:     return i
1:6cb811b:   print ','.join([ str(ntz(i)) for i in range(256) ])
1:6cb811b:   ***/
1:0e96e58:   /** keyspaceName of number of trailing zeros in a byte */
1:6cb811b:   public static final byte[] ntzTable = {8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0};
1:6cb811b: 
1:6cb811b: 
1:6cb811b:   /** Returns number of trailing zeros in a 64 bit long value. */
1:68d2526:   public static int ntz(long val)
1:68d2526:   {
1:6cb811b:     // A full binary search to determine the low byte was slower than
1:6cb811b:     // a linear search for nextSetBit().  This is most likely because
1:6cb811b:     // the implementation of nextSetBit() shifts bits to the right, increasing
1:6cb811b:     // the probability that the first non-zero byte is in the rhs.
1:6cb811b:     //
1:6cb811b:     // This implementation does a single binary search at the top level only
1:6cb811b:     // so that all other bit shifting can be done on ints instead of longs to
1:6cb811b:     // remain friendly to 32 bit architectures.  In addition, the case of a
1:6cb811b:     // non-zero first byte is checked for first because it is the most common
1:6cb811b:     // in dense bit arrays.
1:6cb811b: 
1:6cb811b:     int lower = (int)val;
1:6cb811b:     int lowByte = lower & 0xff;
1:6cb811b:     if (lowByte != 0) return ntzTable[lowByte];
1:6cb811b: 
1:68d2526:     if (lower!=0)
1:68d2526:     {
1:6cb811b:       lowByte = (lower>>>8) & 0xff;
1:6cb811b:       if (lowByte != 0) return ntzTable[lowByte] + 8;
1:6cb811b:       lowByte = (lower>>>16) & 0xff;
1:6cb811b:       if (lowByte != 0) return ntzTable[lowByte] + 16;
1:6cb811b:       // no need to mask off low byte for the last byte in the 32 bit word
1:6cb811b:       // no need to check for zero on the last byte either.
1:6cb811b:       return ntzTable[lower>>>24] + 24;
1:68d2526:     }
1:68d2526:     else
1:68d2526:     {
1:6cb811b:       // grab upper 32 bits
1:6cb811b:       int upper=(int)(val>>32);
1:6cb811b:       lowByte = upper & 0xff;
1:6cb811b:       if (lowByte != 0) return ntzTable[lowByte] + 32;
1:6cb811b:       lowByte = (upper>>>8) & 0xff;
1:6cb811b:       if (lowByte != 0) return ntzTable[lowByte] + 40;
1:6cb811b:       lowByte = (upper>>>16) & 0xff;
1:6cb811b:       if (lowByte != 0) return ntzTable[lowByte] + 48;
1:6cb811b:       // no need to mask off low byte for the last byte in the 32 bit word
1:6cb811b:       // no need to check for zero on the last byte either.
1:6cb811b:       return ntzTable[upper>>>24] + 56;
1:6cb811b:     }
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** Returns number of trailing zeros in a 32 bit int value. */
1:68d2526:   public static int ntz(int val)
1:68d2526:   {
1:6cb811b:     // This implementation does a single binary search at the top level only.
1:6cb811b:     // In addition, the case of a non-zero first byte is checked for first
1:6cb811b:     // because it is the most common in dense bit arrays.
1:6cb811b: 
1:6cb811b:     int lowByte = val & 0xff;
1:6cb811b:     if (lowByte != 0) return ntzTable[lowByte];
1:6cb811b:     lowByte = (val>>>8) & 0xff;
1:6cb811b:     if (lowByte != 0) return ntzTable[lowByte] + 8;
1:6cb811b:     lowByte = (val>>>16) & 0xff;
1:6cb811b:     if (lowByte != 0) return ntzTable[lowByte] + 16;
1:6cb811b:     // no need to mask off low byte for the last byte.
1:6cb811b:     // no need to check for zero on the last byte either.
1:6cb811b:     return ntzTable[val>>>24] + 24;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns 0 based index of first set bit
1:6cb811b:    * (only works for x!=0)
1:6cb811b:    * <br/> This is an alternate implementation of ntz()
1:6cb811b:    */
1:68d2526:   public static int ntz2(long x)
1:68d2526:   {
1:6cb811b:    int n = 0;
1:6cb811b:    int y = (int)x;
1:6cb811b:    if (y==0) {n+=32; y = (int)(x>>>32); }   // the only 64 bit shift necessary
1:6cb811b:    if ((y & 0x0000FFFF) == 0) { n+=16; y>>>=16; }
1:6cb811b:    if ((y & 0x000000FF) == 0) { n+=8; y>>>=8; }
1:6cb811b:    return (ntzTable[ y & 0xff ]) + n;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns 0 based index of first set bit
1:6cb811b:    * <br/> This is an alternate implementation of ntz()
1:6cb811b:    */
1:68d2526:   public static int ntz3(long x)
1:68d2526:   {
1:6cb811b:    // another implementation taken from Hackers Delight, extended to 64 bits
1:6cb811b:    // and converted to Java.
1:6cb811b:    // Many 32 bit ntz algorithms are at http://www.hackersdelight.org/HDcode/ntz.cc
1:6cb811b:    int n = 1;
1:6cb811b: 
1:6cb811b:    // do the first step as a long, all others as ints.
1:6cb811b:    int y = (int)x;
1:6cb811b:    if (y==0) {n+=32; y = (int)(x>>>32); }
1:6cb811b:    if ((y & 0x0000FFFF) == 0) { n+=16; y>>>=16; }
1:6cb811b:    if ((y & 0x000000FF) == 0) { n+=8; y>>>=8; }
1:6cb811b:    if ((y & 0x0000000F) == 0) { n+=4; y>>>=4; }
1:6cb811b:    if ((y & 0x00000003) == 0) { n+=2; y>>>=2; }
1:6cb811b:    return n - (y & 1);
1:6cb811b:   }
1:6cb811b: 
1:6cb811b: 
1:6cb811b:   /** returns true if v is a power of two or zero*/
1:68d2526:   public static boolean isPowerOfTwo(int v)
1:68d2526:   {
1:6cb811b:     return ((v & (v-1)) == 0);
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns true if v is a power of two or zero*/
1:68d2526:   public static boolean isPowerOfTwo(long v)
1:68d2526:   {
1:6cb811b:     return ((v & (v-1)) == 0);
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns the next highest power of two, or the current value if it's already a power of two or zero*/
1:68d2526:   public static int nextHighestPowerOfTwo(int v)
1:68d2526:   {
1:6cb811b:     v--;
1:6cb811b:     v |= v >> 1;
1:6cb811b:     v |= v >> 2;
1:6cb811b:     v |= v >> 4;
1:6cb811b:     v |= v >> 8;
1:6cb811b:     v |= v >> 16;
1:6cb811b:     v++;
1:6cb811b:     return v;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b:   /** returns the next highest power of two, or the current value if it's already a power of two or zero*/
1:68d2526:    public static long nextHighestPowerOfTwo(long v)
1:68d2526:    {
1:6cb811b:     v--;
1:6cb811b:     v |= v >> 1;
1:6cb811b:     v |= v >> 2;
1:6cb811b:     v |= v >> 4;
1:6cb811b:     v |= v >> 8;
1:6cb811b:     v |= v >> 16;
1:6cb811b:     v |= v >> 32;
1:6cb811b:     v++;
1:6cb811b:     return v;
1:6cb811b:   }
1:6cb811b: 
1:6cb811b: }
============================================================================
author:Alex Petrov
-------------------------------------------------------------------------------
commit:7d857b4
/////////////////////////////////////////////////////////////////////////
1: public final class BitUtil
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
0: final class BitUtil
1: {
1:   public static int pop(long x)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public static long pop_array(long A[], int wordOffset, int numWords)
1:   {
/////////////////////////////////////////////////////////////////////////
1:     for (i = wordOffset; i <= n - 8; i+=8)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-4)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-2)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<n)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public static long pop_intersect(long A[], long B[], int wordOffset, int numWords)
1:   {
1:     for (i = wordOffset; i <= n - 8; i+=8)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-4)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-2)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<n)
1:     {
/////////////////////////////////////////////////////////////////////////
1:    public static long pop_union(long A[], long B[], int wordOffset, int numWords)
1:    {
1:      for (i = wordOffset; i <= n - 8; i+=8)
1:      {
/////////////////////////////////////////////////////////////////////////
1:      if (i<=n-4)
1:      {
/////////////////////////////////////////////////////////////////////////
1:      if (i<=n-2)
1:      {
/////////////////////////////////////////////////////////////////////////
1:      if (i<n)
1:      {
/////////////////////////////////////////////////////////////////////////
1:   public static long pop_andnot(long A[], long B[], int wordOffset, int numWords)
1:   {
1:     for (i = wordOffset; i <= n - 8; i+=8)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-4)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-2)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<n)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public static long pop_xor(long A[], long B[], int wordOffset, int numWords)
1:   {
1:     for (i = wordOffset; i <= n - 8; i+=8)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-4)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<=n-2)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     if (i<n)
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public static int ntz(long val)
1:   {
/////////////////////////////////////////////////////////////////////////
1:     if (lower!=0)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     else
1:     {
/////////////////////////////////////////////////////////////////////////
1:   public static int ntz(int val)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public static int ntz2(long x)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public static int ntz3(long x)
1:   {
/////////////////////////////////////////////////////////////////////////
1:   public static boolean isPowerOfTwo(int v)
1:   {
1:   public static boolean isPowerOfTwo(long v)
1:   {
1:   public static int nextHighestPowerOfTwo(int v)
1:   {
/////////////////////////////////////////////////////////////////////////
1:    public static long nextHighestPowerOfTwo(long v)
1:    {
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1:   /** keyspaceName of number of trailing zeros in a byte */
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:6cb811b
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.utils.obs;
1: 
1: /**  A variety of high efficiency bit twiddling routines.
1:  * @lucene.internal
1:  */
0: final class BitUtil {
1: 
1:   /** Returns the number of bits set in the long */
0:   public static int pop(long x) {
1:   /* Hacker's Delight 32 bit pop function:
1:    * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc
1:    *
1:   int pop(unsigned x) {
1:      x = x - ((x >> 1) & 0x55555555);
1:      x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
1:      x = (x + (x >> 4)) & 0x0F0F0F0F;
1:      x = x + (x >> 8);
1:      x = x + (x >> 16);
1:      return x & 0x0000003F;
1:     }
1:   ***/
1: 
1:     // 64 bit java version of the C function from above
1:     x = x - ((x >>> 1) & 0x5555555555555555L);
1:     x = (x & 0x3333333333333333L) + ((x >>>2 ) & 0x3333333333333333L);
1:     x = (x + (x >>> 4)) & 0x0F0F0F0F0F0F0F0FL;
1:     x = x + (x >>> 8);
1:     x = x + (x >>> 16);
1:     x = x + (x >>> 32);
1:     return ((int)x) & 0x7F;
1:   }
1: 
1:   /*** Returns the number of set bits in an array of longs. */
0:   public static long pop_array(long A[], int wordOffset, int numWords) {
1:     /*
1:     * Robert Harley and David Seal's bit counting algorithm, as documented
1:     * in the revisions of Hacker's Delight
1:     * http://www.hackersdelight.org/revisions.pdf
1:     * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc
1:     *
1:     * This function was adapted to Java, and extended to use 64 bit words.
1:     * if only we had access to wider registers like SSE from java...
1:     *
1:     * This function can be transformed to compute the popcount of other functions
1:     * on bitsets via something like this:
1:     * sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'
1:     *
1:     */
1:     int n = wordOffset+numWords;
1:     long tot=0, tot8=0;
1:     long ones=0, twos=0, fours=0;
1: 
1:     int i;
0:     for (i = wordOffset; i <= n - 8; i+=8) {
1:       /***  C macro from Hacker's Delight
1:        #define CSA(h,l, a,b,c) \
1:        {unsigned u = a ^ b; unsigned v = c; \
1:        h = (a & b) | (u & v); l = u ^ v;}
1:        ***/
1: 
1:       long twosA,twosB,foursA,foursB,eights;
1: 
1:       // CSA(twosA, ones, ones, A[i], A[i+1])
1:       {
1:         long b=A[i], c=A[i+1];
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, A[i+2], A[i+3])
1:       {
1:         long b=A[i+2], c=A[i+3];
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursA, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       //CSA(twosA, ones, ones, A[i+4], A[i+5])
1:       {
1:         long b=A[i+4], c=A[i+5];
1:         long u=ones^b;
1:         twosA=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, A[i+6], A[i+7])
1:       {
1:         long b=A[i+6], c=A[i+7];
1:         long u=ones^b;
1:         twosB=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursB, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursB=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1: 
1:       //CSA(eights, fours, fours, foursA, foursB)
1:       {
1:         long u=fours^foursA;
1:         eights=(fours&foursA)|(u&foursB);
1:         fours=u^foursB;
1:       }
1:       tot8 += pop(eights);
1:     }
1: 
1:     // handle trailing words in a binary-search manner...
1:     // derived from the loop above by setting specific elements to 0.
1:     // the original method in Hackers Delight used a simple for loop:
1:     //   for (i = i; i < n; i++)      // Add in the last elements
1:     //  tot = tot + pop(A[i]);
1: 
0:     if (i<=n-4) {
1:       long twosA, twosB, foursA, eights;
1:       {
1:         long b=A[i], c=A[i+1];
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       {
1:         long b=A[i+2], c=A[i+3];
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=4;
1:     }
1: 
0:     if (i<=n-2) {
1:       long b=A[i], c=A[i+1];
1:       long u=ones ^ b;
1:       long twosA=(ones & b)|( u & c);
1:       ones=u^c;
1: 
1:       long foursA=twos&twosA;
1:       twos=twos^twosA;
1: 
1:       long eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=2;
1:     }
1: 
0:     if (i<n) {
1:       tot += pop(A[i]);
1:     }
1: 
1:     tot += (pop(fours)<<2)
1:             + (pop(twos)<<1)
1:             + pop(ones)
1:             + (tot8<<3);
1: 
1:     return tot;
1:   }
1: 
1:   /** Returns the popcount or cardinality of the two sets after an intersection.
1:    * Neither array is modified.
1:    */
0:   public static long pop_intersect(long A[], long B[], int wordOffset, int numWords) {
1:     // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'
1:     int n = wordOffset+numWords;
1:     long tot=0, tot8=0;
1:     long ones=0, twos=0, fours=0;
1: 
1:     int i;
0:     for (i = wordOffset; i <= n - 8; i+=8) {
1:       long twosA,twosB,foursA,foursB,eights;
1: 
1:       // CSA(twosA, ones, ones, (A[i] & B[i]), (A[i+1] & B[i+1]))
1:       {
1:         long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+2] & B[i+2]), (A[i+3] & B[i+3]))
1:       {
1:         long b=(A[i+2] & B[i+2]), c=(A[i+3] & B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursA, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       //CSA(twosA, ones, ones, (A[i+4] & B[i+4]), (A[i+5] & B[i+5]))
1:       {
1:         long b=(A[i+4] & B[i+4]), c=(A[i+5] & B[i+5]);
1:         long u=ones^b;
1:         twosA=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+6] & B[i+6]), (A[i+7] & B[i+7]))
1:       {
1:         long b=(A[i+6] & B[i+6]), c=(A[i+7] & B[i+7]);
1:         long u=ones^b;
1:         twosB=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursB, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursB=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1: 
1:       //CSA(eights, fours, fours, foursA, foursB)
1:       {
1:         long u=fours^foursA;
1:         eights=(fours&foursA)|(u&foursB);
1:         fours=u^foursB;
1:       }
1:       tot8 += pop(eights);
1:     }
1: 
1: 
0:     if (i<=n-4) {
1:       long twosA, twosB, foursA, eights;
1:       {
1:         long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       {
1:         long b=(A[i+2] & B[i+2]), c=(A[i+3] & B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=4;
1:     }
1: 
0:     if (i<=n-2) {
1:       long b=(A[i] & B[i]), c=(A[i+1] & B[i+1]);
1:       long u=ones ^ b;
1:       long twosA=(ones & b)|( u & c);
1:       ones=u^c;
1: 
1:       long foursA=twos&twosA;
1:       twos=twos^twosA;
1: 
1:       long eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=2;
1:     }
1: 
0:     if (i<n) {
1:       tot += pop((A[i] & B[i]));
1:     }
1: 
1:     tot += (pop(fours)<<2)
1:             + (pop(twos)<<1)
1:             + pop(ones)
1:             + (tot8<<3);
1: 
1:     return tot;
1:   }
1: 
1:   /** Returns the popcount or cardinality of the union of two sets.
1:     * Neither array is modified.
1:     */
0:    public static long pop_union(long A[], long B[], int wordOffset, int numWords) {
1:      // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \| B[\1]\)/g'
1:      int n = wordOffset+numWords;
1:      long tot=0, tot8=0;
1:      long ones=0, twos=0, fours=0;
1: 
1:      int i;
0:      for (i = wordOffset; i <= n - 8; i+=8) {
1:        /***  C macro from Hacker's Delight
1:         #define CSA(h,l, a,b,c) \
1:         {unsigned u = a ^ b; unsigned v = c; \
1:         h = (a & b) | (u & v); l = u ^ v;}
1:         ***/
1: 
1:        long twosA,twosB,foursA,foursB,eights;
1: 
1:        // CSA(twosA, ones, ones, (A[i] | B[i]), (A[i+1] | B[i+1]))
1:        {
1:          long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:          long u=ones ^ b;
1:          twosA=(ones & b)|( u & c);
1:          ones=u^c;
1:        }
1:        // CSA(twosB, ones, ones, (A[i+2] | B[i+2]), (A[i+3] | B[i+3]))
1:        {
1:          long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
1:          long u=ones^b;
1:          twosB =(ones&b)|(u&c);
1:          ones=u^c;
1:        }
1:        //CSA(foursA, twos, twos, twosA, twosB)
1:        {
1:          long u=twos^twosA;
1:          foursA=(twos&twosA)|(u&twosB);
1:          twos=u^twosB;
1:        }
1:        //CSA(twosA, ones, ones, (A[i+4] | B[i+4]), (A[i+5] | B[i+5]))
1:        {
1:          long b=(A[i+4] | B[i+4]), c=(A[i+5] | B[i+5]);
1:          long u=ones^b;
1:          twosA=(ones&b)|(u&c);
1:          ones=u^c;
1:        }
1:        // CSA(twosB, ones, ones, (A[i+6] | B[i+6]), (A[i+7] | B[i+7]))
1:        {
1:          long b=(A[i+6] | B[i+6]), c=(A[i+7] | B[i+7]);
1:          long u=ones^b;
1:          twosB=(ones&b)|(u&c);
1:          ones=u^c;
1:        }
1:        //CSA(foursB, twos, twos, twosA, twosB)
1:        {
1:          long u=twos^twosA;
1:          foursB=(twos&twosA)|(u&twosB);
1:          twos=u^twosB;
1:        }
1: 
1:        //CSA(eights, fours, fours, foursA, foursB)
1:        {
1:          long u=fours^foursA;
1:          eights=(fours&foursA)|(u&foursB);
1:          fours=u^foursB;
1:        }
1:        tot8 += pop(eights);
1:      }
1: 
1: 
0:      if (i<=n-4) {
1:        long twosA, twosB, foursA, eights;
1:        {
1:          long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:          long u=ones ^ b;
1:          twosA=(ones & b)|( u & c);
1:          ones=u^c;
1:        }
1:        {
1:          long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
1:          long u=ones^b;
1:          twosB =(ones&b)|(u&c);
1:          ones=u^c;
1:        }
1:        {
1:          long u=twos^twosA;
1:          foursA=(twos&twosA)|(u&twosB);
1:          twos=u^twosB;
1:        }
1:        eights=fours&foursA;
1:        fours=fours^foursA;
1: 
1:        tot8 += pop(eights);
1:        i+=4;
1:      }
1: 
0:      if (i<=n-2) {
1:        long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
1:        long u=ones ^ b;
1:        long twosA=(ones & b)|( u & c);
1:        ones=u^c;
1: 
1:        long foursA=twos&twosA;
1:        twos=twos^twosA;
1: 
1:        long eights=fours&foursA;
1:        fours=fours^foursA;
1: 
1:        tot8 += pop(eights);
1:        i+=2;
1:      }
1: 
0:      if (i<n) {
1:        tot += pop((A[i] | B[i]));
1:      }
1: 
1:      tot += (pop(fours)<<2)
1:              + (pop(twos)<<1)
1:              + pop(ones)
1:              + (tot8<<3);
1: 
1:      return tot;
1:    }
1: 
1:   /** Returns the popcount or cardinality of A & ~B
1:    * Neither array is modified.
1:    */
0:   public static long pop_andnot(long A[], long B[], int wordOffset, int numWords) {
1:     // generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& ~B[\1]\)/g'
1:     int n = wordOffset+numWords;
1:     long tot=0, tot8=0;
1:     long ones=0, twos=0, fours=0;
1: 
1:     int i;
0:     for (i = wordOffset; i <= n - 8; i+=8) {
1:       /***  C macro from Hacker's Delight
1:        #define CSA(h,l, a,b,c) \
1:        {unsigned u = a ^ b; unsigned v = c; \
1:        h = (a & b) | (u & v); l = u ^ v;}
1:        ***/
1: 
1:       long twosA,twosB,foursA,foursB,eights;
1: 
1:       // CSA(twosA, ones, ones, (A[i] & ~B[i]), (A[i+1] & ~B[i+1]))
1:       {
1:         long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+2] & ~B[i+2]), (A[i+3] & ~B[i+3]))
1:       {
1:         long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursA, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       //CSA(twosA, ones, ones, (A[i+4] & ~B[i+4]), (A[i+5] & ~B[i+5]))
1:       {
1:         long b=(A[i+4] & ~B[i+4]), c=(A[i+5] & ~B[i+5]);
1:         long u=ones^b;
1:         twosA=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+6] & ~B[i+6]), (A[i+7] & ~B[i+7]))
1:       {
1:         long b=(A[i+6] & ~B[i+6]), c=(A[i+7] & ~B[i+7]);
1:         long u=ones^b;
1:         twosB=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursB, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursB=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1: 
1:       //CSA(eights, fours, fours, foursA, foursB)
1:       {
1:         long u=fours^foursA;
1:         eights=(fours&foursA)|(u&foursB);
1:         fours=u^foursB;
1:       }
1:       tot8 += pop(eights);
1:     }
1: 
1: 
0:     if (i<=n-4) {
1:       long twosA, twosB, foursA, eights;
1:       {
1:         long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       {
1:         long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=4;
1:     }
1: 
0:     if (i<=n-2) {
1:       long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
1:       long u=ones ^ b;
1:       long twosA=(ones & b)|( u & c);
1:       ones=u^c;
1: 
1:       long foursA=twos&twosA;
1:       twos=twos^twosA;
1: 
1:       long eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=2;
1:     }
1: 
0:     if (i<n) {
1:       tot += pop((A[i] & ~B[i]));
1:     }
1: 
1:     tot += (pop(fours)<<2)
1:             + (pop(twos)<<1)
1:             + pop(ones)
1:             + (tot8<<3);
1: 
1:     return tot;
1:   }
1: 
0:   public static long pop_xor(long A[], long B[], int wordOffset, int numWords) {
1:     int n = wordOffset+numWords;
1:     long tot=0, tot8=0;
1:     long ones=0, twos=0, fours=0;
1: 
1:     int i;
0:     for (i = wordOffset; i <= n - 8; i+=8) {
1:       /***  C macro from Hacker's Delight
1:        #define CSA(h,l, a,b,c) \
1:        {unsigned u = a ^ b; unsigned v = c; \
1:        h = (a & b) | (u & v); l = u ^ v;}
1:        ***/
1: 
1:       long twosA,twosB,foursA,foursB,eights;
1: 
1:       // CSA(twosA, ones, ones, (A[i] ^ B[i]), (A[i+1] ^ B[i+1]))
1:       {
1:         long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+2] ^ B[i+2]), (A[i+3] ^ B[i+3]))
1:       {
1:         long b=(A[i+2] ^ B[i+2]), c=(A[i+3] ^ B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursA, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       //CSA(twosA, ones, ones, (A[i+4] ^ B[i+4]), (A[i+5] ^ B[i+5]))
1:       {
1:         long b=(A[i+4] ^ B[i+4]), c=(A[i+5] ^ B[i+5]);
1:         long u=ones^b;
1:         twosA=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       // CSA(twosB, ones, ones, (A[i+6] ^ B[i+6]), (A[i+7] ^ B[i+7]))
1:       {
1:         long b=(A[i+6] ^ B[i+6]), c=(A[i+7] ^ B[i+7]);
1:         long u=ones^b;
1:         twosB=(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       //CSA(foursB, twos, twos, twosA, twosB)
1:       {
1:         long u=twos^twosA;
1:         foursB=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1: 
1:       //CSA(eights, fours, fours, foursA, foursB)
1:       {
1:         long u=fours^foursA;
1:         eights=(fours&foursA)|(u&foursB);
1:         fours=u^foursB;
1:       }
1:       tot8 += pop(eights);
1:     }
1: 
1: 
0:     if (i<=n-4) {
1:       long twosA, twosB, foursA, eights;
1:       {
1:         long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:         long u=ones ^ b;
1:         twosA=(ones & b)|( u & c);
1:         ones=u^c;
1:       }
1:       {
1:         long b=(A[i+2] ^ B[i+2]), c=(A[i+3] ^ B[i+3]);
1:         long u=ones^b;
1:         twosB =(ones&b)|(u&c);
1:         ones=u^c;
1:       }
1:       {
1:         long u=twos^twosA;
1:         foursA=(twos&twosA)|(u&twosB);
1:         twos=u^twosB;
1:       }
1:       eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=4;
1:     }
1: 
0:     if (i<=n-2) {
1:       long b=(A[i] ^ B[i]), c=(A[i+1] ^ B[i+1]);
1:       long u=ones ^ b;
1:       long twosA=(ones & b)|( u & c);
1:       ones=u^c;
1: 
1:       long foursA=twos&twosA;
1:       twos=twos^twosA;
1: 
1:       long eights=fours&foursA;
1:       fours=fours^foursA;
1: 
1:       tot8 += pop(eights);
1:       i+=2;
1:     }
1: 
0:     if (i<n) {
1:       tot += pop((A[i] ^ B[i]));
1:     }
1: 
1:     tot += (pop(fours)<<2)
1:             + (pop(twos)<<1)
1:             + pop(ones)
1:             + (tot8<<3);
1: 
1:     return tot;
1:   }
1: 
1:   /* python code to generate ntzTable
1:   def ntz(val):
1:     if val==0: return 8
1:     i=0
1:     while (val&0x01)==0:
1:       i = i+1
1:       val >>= 1
1:     return i
1:   print ','.join([ str(ntz(i)) for i in range(256) ])
1:   ***/
0:   /** table of number of trailing zeros in a byte */
1:   public static final byte[] ntzTable = {8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0};
1: 
1: 
1:   /** Returns number of trailing zeros in a 64 bit long value. */
0:   public static int ntz(long val) {
1:     // A full binary search to determine the low byte was slower than
1:     // a linear search for nextSetBit().  This is most likely because
1:     // the implementation of nextSetBit() shifts bits to the right, increasing
1:     // the probability that the first non-zero byte is in the rhs.
1:     //
1:     // This implementation does a single binary search at the top level only
1:     // so that all other bit shifting can be done on ints instead of longs to
1:     // remain friendly to 32 bit architectures.  In addition, the case of a
1:     // non-zero first byte is checked for first because it is the most common
1:     // in dense bit arrays.
1: 
1:     int lower = (int)val;
1:     int lowByte = lower & 0xff;
1:     if (lowByte != 0) return ntzTable[lowByte];
1: 
0:     if (lower!=0) {
1:       lowByte = (lower>>>8) & 0xff;
1:       if (lowByte != 0) return ntzTable[lowByte] + 8;
1:       lowByte = (lower>>>16) & 0xff;
1:       if (lowByte != 0) return ntzTable[lowByte] + 16;
1:       // no need to mask off low byte for the last byte in the 32 bit word
1:       // no need to check for zero on the last byte either.
1:       return ntzTable[lower>>>24] + 24;
0:     } else {
1:       // grab upper 32 bits
1:       int upper=(int)(val>>32);
1:       lowByte = upper & 0xff;
1:       if (lowByte != 0) return ntzTable[lowByte] + 32;
1:       lowByte = (upper>>>8) & 0xff;
1:       if (lowByte != 0) return ntzTable[lowByte] + 40;
1:       lowByte = (upper>>>16) & 0xff;
1:       if (lowByte != 0) return ntzTable[lowByte] + 48;
1:       // no need to mask off low byte for the last byte in the 32 bit word
1:       // no need to check for zero on the last byte either.
1:       return ntzTable[upper>>>24] + 56;
1:     }
1:   }
1: 
1:   /** Returns number of trailing zeros in a 32 bit int value. */
0:   public static int ntz(int val) {
1:     // This implementation does a single binary search at the top level only.
1:     // In addition, the case of a non-zero first byte is checked for first
1:     // because it is the most common in dense bit arrays.
1: 
1:     int lowByte = val & 0xff;
1:     if (lowByte != 0) return ntzTable[lowByte];
1:     lowByte = (val>>>8) & 0xff;
1:     if (lowByte != 0) return ntzTable[lowByte] + 8;
1:     lowByte = (val>>>16) & 0xff;
1:     if (lowByte != 0) return ntzTable[lowByte] + 16;
1:     // no need to mask off low byte for the last byte.
1:     // no need to check for zero on the last byte either.
1:     return ntzTable[val>>>24] + 24;
1:   }
1: 
1:   /** returns 0 based index of first set bit
1:    * (only works for x!=0)
1:    * <br/> This is an alternate implementation of ntz()
1:    */
0:   public static int ntz2(long x) {
1:    int n = 0;
1:    int y = (int)x;
1:    if (y==0) {n+=32; y = (int)(x>>>32); }   // the only 64 bit shift necessary
1:    if ((y & 0x0000FFFF) == 0) { n+=16; y>>>=16; }
1:    if ((y & 0x000000FF) == 0) { n+=8; y>>>=8; }
1:    return (ntzTable[ y & 0xff ]) + n;
1:   }
1: 
1:   /** returns 0 based index of first set bit
1:    * <br/> This is an alternate implementation of ntz()
1:    */
0:   public static int ntz3(long x) {
1:    // another implementation taken from Hackers Delight, extended to 64 bits
1:    // and converted to Java.
1:    // Many 32 bit ntz algorithms are at http://www.hackersdelight.org/HDcode/ntz.cc
1:    int n = 1;
1: 
1:    // do the first step as a long, all others as ints.
1:    int y = (int)x;
1:    if (y==0) {n+=32; y = (int)(x>>>32); }
1:    if ((y & 0x0000FFFF) == 0) { n+=16; y>>>=16; }
1:    if ((y & 0x000000FF) == 0) { n+=8; y>>>=8; }
1:    if ((y & 0x0000000F) == 0) { n+=4; y>>>=4; }
1:    if ((y & 0x00000003) == 0) { n+=2; y>>>=2; }
1:    return n - (y & 1);
1:   }
1: 
1: 
1:   /** returns true if v is a power of two or zero*/
0:   public static boolean isPowerOfTwo(int v) {
1:     return ((v & (v-1)) == 0);
1:   }
1: 
1:   /** returns true if v is a power of two or zero*/
0:   public static boolean isPowerOfTwo(long v) {
1:     return ((v & (v-1)) == 0);
1:   }
1: 
1:   /** returns the next highest power of two, or the current value if it's already a power of two or zero*/
0:   public static int nextHighestPowerOfTwo(int v) {
1:     v--;
1:     v |= v >> 1;
1:     v |= v >> 2;
1:     v |= v >> 4;
1:     v |= v >> 8;
1:     v |= v >> 16;
1:     v++;
1:     return v;
1:   }
1: 
1:   /** returns the next highest power of two, or the current value if it's already a power of two or zero*/
0:    public static long nextHighestPowerOfTwo(long v) {
1:     v--;
1:     v |= v >> 1;
1:     v |= v >> 2;
1:     v |= v >> 4;
1:     v |= v >> 8;
1:     v |= v >> 16;
1:     v |= v >> 32;
1:     v++;
1:     return v;
1:   }
1: 
1: }
============================================================================