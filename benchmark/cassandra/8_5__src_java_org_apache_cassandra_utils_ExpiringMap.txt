2:066ef58: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:31c564a:  */
1:066ef58: package org.apache.cassandra.utils;
1:31c564a: 
1:103d9fb: import java.util.Map;
1:103d9fb: import java.util.Set;
1:103d9fb: import java.util.concurrent.ConcurrentHashMap;
1:103d9fb: import java.util.concurrent.ConcurrentMap;
1:eac19fe: import java.util.concurrent.ScheduledExecutorService;
1:eac19fe: import java.util.concurrent.TimeUnit;
1:1dc4279: 
1:14d0647: import com.google.common.base.Function;
1:2effc40: import com.google.common.util.concurrent.Uninterruptibles;
1:2effc40: 
1:e3c5d5d: import org.slf4j.Logger;
1:e3c5d5d: import org.slf4j.LoggerFactory;
1:e3c5d5d: 
1:eac19fe: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
1:ef25537: 
1:96d9c33: public class ExpiringMap<K, V>
2:31c564a: {
1:e3c5d5d:     private static final Logger logger = LoggerFactory.getLogger(ExpiringMap.class);
1:4f47a44:     private volatile boolean shutdown;
1:e3c5d5d: 
1:f422b98:     public static class CacheableObject<T>
1:185eca5:     {
1:71a50b7:         public final T value;
1:f422b98:         public final long timeout;
1:71a50b7:         private final long createdAt;
1:fcba8b8: 
1:f422b98:         private CacheableObject(T value, long timeout)
1:75e832a:         {
1:f422b98:             assert value != null;
1:f422b98:             this.value = value;
1:f422b98:             this.timeout = timeout;
1:7751588:             this.createdAt = Clock.instance.nanoTime();
1:14d0647:         }
1:14d0647: 
1:1d2c122:         private boolean isReadyToDieAt(long atNano)
1:d4ec31f:         {
1:1d2c122:             return atNano - createdAt > TimeUnit.MILLISECONDS.toNanos(timeout);
1:d4ec31f:         }
1:31c564a:     }
1:d4ec31f: 
1:eac19fe:     // if we use more ExpiringMaps we may want to add multiple threads to this executor
1:eac19fe:     private static final ScheduledExecutorService service = new DebuggableScheduledThreadPoolExecutor("EXPIRING-MAP-REAPER");
1:eac19fe: 
1:4f47a44:     private final ConcurrentMap<K, CacheableObject<V>> cache = new ConcurrentHashMap<K, CacheableObject<V>>();
1:e3c5d5d:     private final long defaultExpiration;
1:2ac485b: 
1:e3c5d5d:     public ExpiringMap(long defaultExpiration)
1:67c5720:     {
1:e3c5d5d:         this(defaultExpiration, null);
1:31c564a:     }
1:31c564a: 
1:14d0647:     /**
1:14d0647:      *
1:e3c5d5d:      * @param defaultExpiration the TTL for objects in the cache in milliseconds
1:14d0647:      */
1:f422b98:     public ExpiringMap(long defaultExpiration, final Function<Pair<K,CacheableObject<V>>, ?> postExpireHook)
1:3893f24:     {
1:e3c5d5d:         this.defaultExpiration = defaultExpiration;
1:31c564a: 
1:e3c5d5d:         if (defaultExpiration <= 0)
1:3893f24:         {
1:75e832a:             throw new IllegalArgumentException("Argument specified must be a positive number");
1:75e832a:         }
1:75e832a: 
1:4f47a44:         Runnable runnable = new Runnable()
1:14d0647:         {
1:3893f24:             public void run()
1:3893f24:             {
1:7751588:                 long start = Clock.instance.nanoTime();
1:e3c5d5d:                 int n = 0;
1:3893f24:                 for (Map.Entry<K, CacheableObject<V>> entry : cache.entrySet())
1:3893f24:                 {
1:e3c5d5d:                     if (entry.getValue().isReadyToDieAt(start))
1:3893f24:                     {
1:4722fe7:                         if (cache.remove(entry.getKey()) != null)
1:4722fe7:                         {
1:4722fe7:                             n++;
1:4722fe7:                             if (postExpireHook != null)
1:4722fe7:                                 postExpireHook.apply(Pair.create(entry.getKey(), entry.getValue()));
1:4722fe7:                         }
1:3893f24:                     }
1:3893f24:                 }
1:e3c5d5d:                 logger.trace("Expired {} entries", n);
1:3893f24:             }
1:3893f24:         };
1:4f47a44:         service.scheduleWithFixedDelay(runnable, defaultExpiration / 2, defaultExpiration / 2, TimeUnit.MILLISECONDS);
1:3893f24:     }
1:31c564a: 
1:be6e6ea:     public boolean shutdownBlocking()
1:4f47a44:     {
1:4f47a44:         service.shutdown();
1:4f47a44:         try
1:4f47a44:         {
1:be6e6ea:             return service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
1:4f47a44:         }
1:4f47a44:         catch (InterruptedException e)
1:4f47a44:         {
1:4f47a44:             throw new AssertionError(e);
1:4f47a44:         }
1:4f47a44:     }
1:4f47a44: 
1:4f47a44:     public void reset()
1:4f47a44:     {
1:4f47a44:         shutdown = false;
1:4f47a44:         cache.clear();
1:4f47a44:     }
1:4f47a44: 
1:4f47a44:     public V put(K key, V value)
1:eac19fe:     {
1:e3c5d5d:         return put(key, value, this.defaultExpiration);
1:eac19fe:     }
1:3893f24: 
1:4f47a44:     public V put(K key, V value, long timeout)
1:3893f24:     {
1:4f47a44:         if (shutdown)
1:4f47a44:         {
1:4f47a44:             // StorageProxy isn't equipped to deal with "I'm nominally alive, but I can't send any messages out."
1:4f47a44:             // So we'll just sit on this thread until the rest of the server shutdown completes.
1:4f47a44:             //
1:4f47a44:             // See comments in CustomTThreadPoolServer.serve, CASSANDRA-3335, and CASSANDRA-3727.
1:4f47a44:             Uninterruptibles.sleepUninterruptibly(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
1:4f47a44:         }
1:4f47a44:         CacheableObject<V> previous = cache.put(key, new CacheableObject<V>(value, timeout));
1:4f47a44:         return (previous == null) ? null : previous.value;
1:185eca5:     }
1:31c564a: 
1:066ef58:     public V get(K key)
1:185eca5:     {
1:75e832a:         CacheableObject<V> co = cache.get(key);
1:71a50b7:         return co == null ? null : co.value;
1:67c5720:     }
1:31c564a: 
1:066ef58:     public V remove(K key)
1:185eca5:     {
1:75e832a:         CacheableObject<V> co = cache.remove(key);
1:71a50b7:         return co == null ? null : co.value;
1:185eca5:     }
1:31c564a: 
1:1d2c122:     /**
1:1d2c122:      * @return System.nanoTime() when key was put into the map.
1:1d2c122:      */
1:67c5720:     public long getAge(K key)
1:67c5720:     {
1:67c5720:         CacheableObject<V> co = cache.get(key);
1:e3c5d5d:         return co == null ? 0 : co.createdAt;
1:67c5720:     }
1:67c5720: 
1:066ef58:     public int size()
1:3893f24:     {
1:75e832a:         return cache.size();
1:185eca5:     }
1:31c564a: 
1:066ef58:     public boolean containsKey(K key)
1:3893f24:     {
1:75e832a:         return cache.containsKey(key);
1:3893f24:     }
1:31c564a: 
1:066ef58:     public boolean isEmpty()
1:31c564a:     {
1:75e832a:         return cache.isEmpty();
1:3893f24:     }
1:31c564a: 
1:066ef58:     public Set<K> keySet()
1:31c564a:     {
1:75e832a:         return cache.keySet();
1:3893f24:     }
3:31c564a: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:316e1cd
commit:be6e6ea
/////////////////////////////////////////////////////////////////////////
1:     public boolean shutdownBlocking()
1:             return service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
author:Stefan Podkowinski
-------------------------------------------------------------------------------
commit:7751588
/////////////////////////////////////////////////////////////////////////
1:             this.createdAt = Clock.instance.nanoTime();
/////////////////////////////////////////////////////////////////////////
1:                 long start = Clock.instance.nanoTime();
author:Jake Luciani
-------------------------------------------------------------------------------
commit:4722fe7
/////////////////////////////////////////////////////////////////////////
1:                         if (cache.remove(entry.getKey()) != null)
1:                         {
1:                             n++;
1:                             if (postExpireHook != null)
1:                                 postExpireHook.apply(Pair.create(entry.getKey(), entry.getValue()));
1:                         }
author:Brandon Williams
-------------------------------------------------------------------------------
commit:4f47a44
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean shutdown;
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<K, CacheableObject<V>> cache = new ConcurrentHashMap<K, CacheableObject<V>>();
/////////////////////////////////////////////////////////////////////////
1:         Runnable runnable = new Runnable()
/////////////////////////////////////////////////////////////////////////
1:         service.scheduleWithFixedDelay(runnable, defaultExpiration / 2, defaultExpiration / 2, TimeUnit.MILLISECONDS);
0:     public void shutdownBlocking()
1:     {
1:         service.shutdown();
1:         try
1:         {
0:             service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
1:         }
1:         catch (InterruptedException e)
1:         {
1:             throw new AssertionError(e);
1:         }
1:     }
1: 
1:     public void reset()
1:     {
1:         shutdown = false;
1:         cache.clear();
1:     }
1: 
1:     public V put(K key, V value)
1:     public V put(K key, V value, long timeout)
1:         if (shutdown)
1:         {
1:             // StorageProxy isn't equipped to deal with "I'm nominally alive, but I can't send any messages out."
1:             // So we'll just sit on this thread until the rest of the server shutdown completes.
1:             //
1:             // See comments in CustomTThreadPoolServer.serve, CASSANDRA-3335, and CASSANDRA-3727.
1:             Uninterruptibles.sleepUninterruptibly(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
1:         }
1:         CacheableObject<V> previous = cache.put(key, new CacheableObject<V>(value, timeout));
1:         return (previous == null) ? null : previous.value;
commit:d4ec31f
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         public String toString()
1:         {
0:             return "CacheableObject(obj=" + value.toString() + ", deltaFromTimeout=" + (System.nanoTime() - (createdAt + TimeUnit.MILLISECONDS.toNanos(timeout))) + "ns)";
1:         }
0:     private final ConcurrentMap<K, CacheableObject<V>> cache = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
0:         Runnable reaperTask = new Runnable()
/////////////////////////////////////////////////////////////////////////
0:         service.scheduleWithFixedDelay(reaperTask, defaultExpiration / 2, defaultExpiration / 2, TimeUnit.MILLISECONDS);
0:     public CacheableObject<V> put(K key, V value)
0:     public CacheableObject<V> put(K key, V value, long timeout)
0:         return cache.put(key, new CacheableObject<V>(value, timeout));
commit:67c5720
/////////////////////////////////////////////////////////////////////////
1:     public long getAge(K key)
1:     {
0:         long age = 0;
1:         CacheableObject<V> co = cache.get(key);
0:         if (co != null)
1:         {
0:             age = co.age;
1:         }
0:         return age;
1:     }
1: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:1d2c122
/////////////////////////////////////////////////////////////////////////
0:             this.createdAt = System.nanoTime();
1:         private boolean isReadyToDieAt(long atNano)
1:             return atNano - createdAt > TimeUnit.MILLISECONDS.toNanos(timeout);
/////////////////////////////////////////////////////////////////////////
0:                 long start = System.nanoTime();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return System.nanoTime() when key was put into the map.
1:      */
commit:2effc40
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.util.concurrent.Uninterruptibles;
1: 
/////////////////////////////////////////////////////////////////////////
0:             Uninterruptibles.sleepUninterruptibly(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
commit:cc2ced8
commit:789aab1
commit:103d9fb
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import java.util.Set;
0: import java.util.Timer;
0: import java.util.TimerTask;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentMap<K, CacheableObject<V>> cache = new ConcurrentHashMap<K, CacheableObject<V>>();
commit:8fbbdf0
commit:db45670
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<K, CacheableObject<V>> cache = new ConcurrentHashMap<K, CacheableObject<V>>();
commit:7af7eb3
/////////////////////////////////////////////////////////////////////////
0:                             postExpireHook.apply(Pair.create(entry.getKey(), entry.getValue()));
commit:71a50b7
/////////////////////////////////////////////////////////////////////////
1:         public final T value;
1:         private final long createdAt;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return (previous == null) ? null : previous.value;
1:         return co == null ? null : co.value;
1:         return co == null ? null : co.value;
commit:f422b98
/////////////////////////////////////////////////////////////////////////
1:     public static class CacheableObject<T>
1:         public final long timeout;
1:         private CacheableObject(T value, long timeout)
1:             assert value != null;
1:             this.value = value;
1:             this.timeout = timeout;
0:             this.createdAt = System.currentTimeMillis();
0:         public T getValue()
0:         private boolean isReadyToDieAt(long time)
0:             return ((time - createdAt) > timeout);
/////////////////////////////////////////////////////////////////////////
1:     public ExpiringMap(long defaultExpiration, final Function<Pair<K,CacheableObject<V>>, ?> postExpireHook)
/////////////////////////////////////////////////////////////////////////
0:                             postExpireHook.apply(new Pair<K, CacheableObject<V>>(entry.getKey(), entry.getValue()));
commit:eac19fe
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
0: import java.util.Set;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.TimeUnit;
1: import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
1:     // if we use more ExpiringMaps we may want to add multiple threads to this executor
1:     private static final ScheduledExecutorService service = new DebuggableScheduledThreadPoolExecutor("EXPIRING-MAP-REAPER");
1: 
/////////////////////////////////////////////////////////////////////////
0:         Runnable runnable = new Runnable()
/////////////////////////////////////////////////////////////////////////
0:         service.scheduleWithFixedDelay(runnable, defaultExpiration / 2, defaultExpiration / 2, TimeUnit.MILLISECONDS);
0:     public void shutdownBlocking()
0:         service.shutdown();
0:         try
0:             service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
0:         catch (InterruptedException e)
1:         {
0:             throw new AssertionError(e);
1:         }
commit:1e75013
/////////////////////////////////////////////////////////////////////////
0:     public void reset()
0:         shutdown = false;
commit:185eca5
/////////////////////////////////////////////////////////////////////////
0:     private volatile boolean shutdown;
/////////////////////////////////////////////////////////////////////////
0:         shutdown = true;
/////////////////////////////////////////////////////////////////////////
0:         if (shutdown)
1:         {
0:             // StorageProxy isn't equipped to deal with "I'm nominally alive, but I can't send any messages out."
0:             // So we'll just sit on this thread until the rest of the server shutdown completes.
0:             //
0:             // See comments in CustomTThreadPoolServer.serve, CASSANDRA-3335, and CASSANDRA-3727.
0:             try
1:             {
0:                 Thread.sleep(Long.MAX_VALUE);
1:             }
0:             catch (InterruptedException e)
1:             {
0:                 throw new AssertionError(e);
1:             }
1:         }
commit:e3c5d5d
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1:     private static final Logger logger = LoggerFactory.getLogger(ExpiringMap.class);
1: 
0:         private final long createdAt;
/////////////////////////////////////////////////////////////////////////
0:             createdAt = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:         boolean isReadyToDieAt(long time)
0:             return ((time - createdAt) > expiration);
1:     private final long defaultExpiration;
1:     public ExpiringMap(long defaultExpiration)
1:         this(defaultExpiration, null);
1:      * @param defaultExpiration the TTL for objects in the cache in milliseconds
0:     public ExpiringMap(long defaultExpiration, final Function<Pair<K,V>, ?> postExpireHook)
1:         this.defaultExpiration = defaultExpiration;
1:         if (defaultExpiration <= 0)
/////////////////////////////////////////////////////////////////////////
1:                 int n = 0;
1:                     if (entry.getValue().isReadyToDieAt(start))
0:                         n++;
1:                 logger.trace("Expired {} entries", n);
0:         timer.schedule(task, defaultExpiration / 2, defaultExpiration / 2);
0:             logger.trace("Waiting for {} entries before shutting down ExpiringMap", cache.size());
/////////////////////////////////////////////////////////////////////////
1:         return put(key, value, this.defaultExpiration);
/////////////////////////////////////////////////////////////////////////
1:         return co == null ? 0 : co.createdAt;
commit:3893f24
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public ExpiringMap(long expiration, final Function<Pair<K,V>, ?> postExpireHook)
/////////////////////////////////////////////////////////////////////////
0:         TimerTask task = new TimerTask()
1:         {
1:             public void run()
1:             {
0:                 long start = System.currentTimeMillis();
1:                 for (Map.Entry<K, CacheableObject<V>> entry : cache.entrySet())
1:                 {
0:                     if (entry.getValue().isReadyToDie(start))
1:                     {
0:                         cache.remove(entry.getKey());
0:                         if (postExpireHook != null)
0:                             postExpireHook.apply(new Pair<K, V>(entry.getKey(), entry.getValue().getValue()));
1:                     }
1:                 }
1:             }
1:         };
0:         timer.schedule(task, expiration / 2, expiration / 2);
0:         while (!cache.isEmpty())
1:         {
0:             try
1:             {
0:                 Thread.sleep(100);
1:             }
0:             catch (InterruptedException e)
1:             {
0:                 throw new AssertionError(e);
1:             }
1:         }
0:     public void clear()
1:     {
0:         cache.clear();
1:     }
1: 
commit:ae7dbe3
commit:5e75a7f
/////////////////////////////////////////////////////////////////////////
commit:6a0df02
/////////////////////////////////////////////////////////////////////////
commit:9bd4881
/////////////////////////////////////////////////////////////////////////
0:         return co == null ? null : co.getValue();
0:         return co == null ? null : co.getValue();
0:         return co == null ? 0 : co.age;
commit:22ce1dd
/////////////////////////////////////////////////////////////////////////
0:                     if (postExpireHook != null)
0:                         postExpireHook.apply(new Pair<K, V>(entry.getKey(), entry.getValue().getValue()));
commit:badf731
/////////////////////////////////////////////////////////////////////////
0:             assert o != null;
/////////////////////////////////////////////////////////////////////////
0:             for (Map.Entry<K, CacheableObject<V>> entry : cache.entrySet())
0:                     postExpireHook.apply(new Pair<K, V>(entry.getKey(), entry.getValue().getValue()));
0:     private final NonBlockingHashMap<K, CacheableObject<V>> cache = new NonBlockingHashMap<K, CacheableObject<V>>();
commit:f51da9a
/////////////////////////////////////////////////////////////////////////
0:     public V put(K key, V value)
0:         CacheableObject<V> previous = cache.put(key, new CacheableObject<V>(value));
0:         return (previous == null) ? null : previous.getValue();
commit:745fb44
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     private final Function<Pair<K,V>, ?> postExpireHook;
/////////////////////////////////////////////////////////////////////////
0:             for (Map.Entry<K, CacheableObject> entry : cache.entrySet())
0:                 if (entry.getValue().isReadyToDie(expiration))
0:                     cache.remove(entry.getKey());
0:                     postExpireHook.apply(new Pair(entry.getKey(), entry.getValue().getValue()));
/////////////////////////////////////////////////////////////////////////
0:     public ExpiringMap(long expiration, Function<Pair<K,V>, ?> postExpireHook)
commit:14d0647
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
1: import com.google.common.base.Function;
/////////////////////////////////////////////////////////////////////////
0:     private final Function<K, ?> postExpireHook;
/////////////////////////////////////////////////////////////////////////
0:                         postExpireHook.apply(key);
/////////////////////////////////////////////////////////////////////////
0:         this(expiration, null);
1:     }
1: 
1:     /**
1:      *
0:      * @param expiration the TTL for objects in the cache in milliseconds
1:      */
0:     public ExpiringMap(long expiration, Function<K, ?> postExpireHook)
1:     {
0:         this.postExpireHook = postExpireHook;
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
0: import java.util.Set;
0: import java.util.Timer;
0: import java.util.TimerTask;
0: import org.cliffc.high_scale_lib.NonBlockingHashMap;
1: 
commit:75e832a
/////////////////////////////////////////////////////////////////////////
0: import org.cliffc.high_scale_lib.NonBlockingHashMap;
/////////////////////////////////////////////////////////////////////////
0:     private static class CacheableObject<T>
0:         private final T value;
0:         private final long age;
0:         CacheableObject(T o)
0:             value = o;
0:             age = System.currentTimeMillis();
0:         T getValue()
0:             return value;
0:             return ((System.currentTimeMillis() - age) > expiration);
0:         private final long expiration;
0:             this.expiration = expiration;
0:             synchronized (cache)
0:                 Enumeration<K> e = cache.keys();
0:                     CacheableObject co = cache.get(key);
0:                     if (co != null && co.isReadyToDie(expiration))
0:                         cache.remove(key);
0:     private final NonBlockingHashMap<K, CacheableObject> cache = new NonBlockingHashMap<K, CacheableObject>();
0:     private final Timer timer;
0:     private static int counter = 0;
/////////////////////////////////////////////////////////////////////////
0:         if (expiration <= 0)
1:         {
1:             throw new IllegalArgumentException("Argument specified must be a positive number");
1:         }
1: 
0:         timer = new Timer("EXPIRING-MAP-TIMER-" + (++counter), true);
0:         timer.schedule(new CacheMonitor(expiration), expiration / 2, expiration / 2);
0:         timer.cancel();
0:         cache.put(key, new CacheableObject<V>(value));
1:         CacheableObject<V> co = cache.get(key);
/////////////////////////////////////////////////////////////////////////
1:         CacheableObject<V> co = cache.remove(key);
/////////////////////////////////////////////////////////////////////////
1:         return cache.size();
1:         return cache.containsKey(key);
1:         return cache.isEmpty();
1:         return cache.keySet();
commit:fcba8b8
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(ExpiringMap.class);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d9ec6a6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2ac485b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
0:             for (Entry<K, V> entry : expungedValues.entrySet())
0:                 K key = entry.getKey();
0:                 V value = entry.getValue();
1:                 
commit:96d9c33
/////////////////////////////////////////////////////////////////////////
1: public class ExpiringMap<K, V>
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOGGER = Logger.getLogger(ExpiringMap.class);
/////////////////////////////////////////////////////////////////////////
0:     public ExpiringMap(long expiration)
/////////////////////////////////////////////////////////////////////////
0:     public ExpiringMap(long expiration, ICacheExpungeHook<K, V> global)
commit:1dc4279
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cache.ICacheExpungeHook;
0: import org.apache.cassandra.cache.ICachetable;
1: 
commit:31c564a
/////////////////////////////////////////////////////////////////////////
0: public class Cachetable<K, V> implements ICachetable<K, V>
0:     private class CacheableObject
1: 
0:         @Override
0:         @Override
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
0:             return ((System.currentTimeMillis() - age_) > expiration);
1: 
1: 
1: 
0:         @Override
1:         {
0:             Map<K, V> expungedValues = new HashMap<K, V>();
0:             synchronized (cache_)
0:                 while (e.hasMoreElements())
1:                 {
0:                     CacheableObject co = cache_.get(key);
0:                     if (co != null && co.isReadyToDie(expiration_))
0:                         if (null != v)
1:                         {
1:                         }
0:                         cache_.remove(key);
1: 
0:             Set<K> keys = expungedValues.keySet();
0:             for (K key : keys)
1:             {
0:                 ICacheExpungeHook<K, V> hook = hooks_.remove(key);
/////////////////////////////////////////////////////////////////////////
1:     }
0:     private ICacheExpungeHook<K, V> globalHook_;
0:     private Hashtable<K, CacheableObject> cache_;
0:     private Map<K, ICacheExpungeHook<K, V>> hooks_;
0:     private static final Logger LOGGER = Logger.getLogger(Cachetable.class);
0:         if (expiration <= 0)
0:         {
1:         }
0:         cache_ = new Hashtable<K, CacheableObject>();
0:         hooks_ = new Hashtable<K, ICacheExpungeHook<K, V>>();
0:         timer_ = new Timer("CACHETABLE-TIMER-" + (++counter_), true);
1: 
0:     * Specify the TTL for objects in the cache
0:     * in milliseconds.
1:     */
0:         init(expiration);
1:     }
1: 
0:     * Specify the TTL for objects in the cache
0:     * in milliseconds and a global expunge hook. If
0:     * a key has a key-specific hook installed invoke that
0:     * instead.
1:     */
0:     public Cachetable(long expiration, ICacheExpungeHook<K, V> global)
0:         globalHook_ = global;
1: 
1: 
0:     {
0:         cache_.put(key, new CacheableObject(value));
0:     public void put(K key, V value, ICacheExpungeHook<K, V> hook)
/////////////////////////////////////////////////////////////////////////
0:         CacheableObject co = cache_.get(key);
0:         if (co != null)
/////////////////////////////////////////////////////////////////////////
0:         CacheableObject co = cache_.remove(key);
0:         if (co != null)
/////////////////////////////////////////////////////////////////////////
0:         return cache_.containsValue(new CacheableObject(value));
/////////////////////////////////////////////////////////////////////////
0:     }
commit:704c915
/////////////////////////////////////////////////////////////////////////
0:                 if (hook != null)
0:                     hook.callMe(key, value);
0:                 else if (globalHook_ != null)
0:                     globalHook_.callMe(key, value);
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.cassandra.utils;
0: 
0: import java.util.*;
0: 
0: import org.apache.log4j.Logger;
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class Cachetable<K,V> implements ICachetable<K,V>
0: {
0:     private class CacheableObject<V>
0:     {
0:         private V value_;
0:         private long age_;
0:         
0:         CacheableObject(V o)
0:         {
0:             value_ = o;
0:             age_ = System.currentTimeMillis();
0:         }
0: 
0:         public boolean equals(Object o)
0:         {
0:             return value_.equals(o);
0:         }
0: 
0:         public int hashCode()
0:         {
0:             return value_.hashCode();
0:         }
0: 
0:         V getValue()
0:         {
0:             return value_;
0:         }           
0:         
0:         boolean isReadyToDie(long expiration)
0:         {
0:             return ( (System.currentTimeMillis() - age_) > expiration );
0:         }
0:     }
0:     
0:     private class CacheMonitor extends TimerTask
0:     {
0:         private long expiration_;
0:         
0:         CacheMonitor(long expiration)
0:         {
0:             expiration_ = expiration;
0:         }
0:         
0:         public void run()
0:         {  
0:             Map<K,V> expungedValues = new HashMap<K,V>();            
0:             synchronized(cache_)
0:             {
0:                 Enumeration<K> e = cache_.keys();
0:                 while( e.hasMoreElements() )
0:                 {        
0:                     K key = e.nextElement();
0:                     CacheableObject<V> co = cache_.get(key);
0:                     if ( co != null && co.isReadyToDie(expiration_) )
0:                     {
0:                         V v = co.getValue();
0:                         if(null != v)
0:                             expungedValues.put(key, v);
0:                         cache_.remove(key);                                       
0:                     }
0:                 }
0:             }
0:             
0:             /* Calling the hooks on the keys that have been expunged */
0:             Set<K> keys = expungedValues.keySet();                                               
0:             for ( K key : keys )
0:             {                                
0:                 V value = expungedValues.get(key);
0:                 ICacheExpungeHook<K,V> hook = hooks_.remove(key);
0:                 try 
0:                 {
0:                     if ( hook != null )
0:                     {
0:                         hook.callMe(key, value);                    
0:                     }
0:                     else if ( globalHook_ != null )
0:                     {
0:                         globalHook_.callMe(key, value);
0:                     }
0:                 }
0:                 catch(Throwable e)
0:                 {
0:                     logger_.info(LogUtil.throwableToString(e));
0:                 }
0:             }
0:             expungedValues.clear();
0:         }
0:     }   
0: 
0:     private ICacheExpungeHook<K,V> globalHook_;
0:     private Hashtable<K, CacheableObject<V>> cache_;
0:     private Map<K, ICacheExpungeHook<K,V>> hooks_;
0:     private Timer timer_;
0:     private static int counter_ = 0;
0:     private static Logger logger_ = Logger.getLogger(Cachetable.class);
0: 
0:     private void init(long expiration)
0:     {
0:         if ( expiration <= 0 )
0:             throw new IllegalArgumentException("Argument specified must be a positive number");
0: 
0:         cache_ = new Hashtable<K, CacheableObject<V>>();
0:         hooks_ = new Hashtable<K, ICacheExpungeHook<K,V>>();
0:         timer_ = new Timer("CACHETABLE-TIMER-" + (++counter_), true);        
0:         timer_.schedule(new CacheMonitor(expiration), expiration, expiration);
0:     }
0:     
1:     /*
0:      * Specify the TTL for objects in the cache
0:      * in milliseconds.
0:      */
0:     public Cachetable(long expiration)
0:     {
0:         init(expiration);   
0:     }    
0:     
1:     /*
0:      * Specify the TTL for objects in the cache
0:      * in milliseconds and a global expunge hook. If
0:      * a key has a key-specific hook installed invoke that
0:      * instead.
0:      */
0:     public Cachetable(long expiration, ICacheExpungeHook<K,V> global)
0:     {
0:         init(expiration);
0:         globalHook_ = global;        
0:     }
0:     
0:     public void shutdown()
0:     {
0:         timer_.cancel();
0:     }
0:     
0:     public void put(K key, V value)
0:     {        
0:         cache_.put(key, new CacheableObject<V>(value));
0:     }
0: 
0:     public void put(K key, V value, ICacheExpungeHook<K,V> hook)
0:     {
0:         put(key, value);
0:         hooks_.put(key, hook);
0:     }
0: 
1:     public V get(K key)
0:     {
0:         V result = null;
0:         CacheableObject<V> co = cache_.get(key);
0:         if ( co != null )
0:         {
0:             result = co.getValue();
0:         }
0:         return result;
0:     }
0: 
1:     public V remove(K key)
0:     {
0:         CacheableObject<V> co = cache_.remove(key);
0:         V result = null;
0:         if ( co != null )
0:         {
0:             result = co.getValue();
0:         }
0:         return result;
0:     }
0: 
1:     public int size()
0:     {
0:         return cache_.size();
0:     }
0: 
1:     public boolean containsKey(K key)
0:     {
0:         return cache_.containsKey(key);
0:     }
0: 
0:     public boolean containsValue(V value)
0:     {
0:         return cache_.containsValue( new CacheableObject<V>(value) );
0:     }
0: 
1:     public boolean isEmpty()
0:     {
0:         return cache_.isEmpty();
0:     }
0: 
1:     public Set<K> keySet()
0:     {
0:         return cache_.keySet();
0:     }    
0: }
commit:71739ef
commit:238758b
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
0: /*
/////////////////////////////////////////////////////////////////////////
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:0095f0c
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOGGER = LoggerFactory.getLogger(ExpiringMap.class);
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.utils;
0: 
0: import java.util.*;
0: import java.util.concurrent.ConcurrentHashMap;
0: 
0: import org.apache.log4j.Logger;
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class Cachetable<K,V> implements ICachetable<K,V>
0: {
0:     private class CacheableObject<V>
0:     {
0:         private V value_;
0:         private long age_;
0:         
0:         CacheableObject(V o)
0:         {
0:             value_ = o;
0:             age_ = System.currentTimeMillis();
0:         }
0: 
0:         public boolean equals(Object o)
0:         {
0:             return value_.equals(o);
0:         }
0: 
0:         public int hashCode()
0:         {
0:             return value_.hashCode();
0:         }
0: 
0:         V getValue()
0:         {
0:             return value_;
0:         }           
0:         
0:         boolean isReadyToDie(long expiration)
0:         {
0:             return ( (System.currentTimeMillis() - age_) > expiration );
0:         }
0:     }
0:     
0:     private class CacheMonitor extends TimerTask
0:     {
0:         private long expiration_;
0:         
0:         CacheMonitor(long expiration)
0:         {
0:             expiration_ = expiration;
0:         }
0:         
0:         public void run()
0:         {  
0:             Map<K,V> expungedValues = new HashMap<K,V>();            
0:             synchronized(cache_)
0:             {
0:                 Enumeration<K> e = cache_.keys();
0:                 while( e.hasMoreElements() )
0:                 {        
0:                     K key = e.nextElement();
0:                     CacheableObject<V> co = cache_.get(key);
0:                     if ( co != null && co.isReadyToDie(expiration_) )
0:                     {
0:                         V v = co.getValue();
0:                         if(null != v)
0:                             expungedValues.put(key, v);
0:                         cache_.remove(key);                                       
0:                     }
0:                 }
0:             }
0:             
0:             /* Calling the hooks on the keys that have been expunged */
0:             Set<K> keys = expungedValues.keySet();                                               
0:             for ( K key : keys )
0:             {                                
0:                 V value = expungedValues.get(key);
0:                 ICacheExpungeHook<K,V> hook = hooks_.remove(key);
0:                 try 
0:                 {
0:                     if ( hook != null )
0:                     {
0:                         hook.callMe(key, value);                    
0:                     }
0:                     else if ( globalHook_ != null )
0:                     {
0:                         globalHook_.callMe(key, value);
0:                     }
0:                 }
0:                 catch(Throwable e)
0:                 {
0:                     logger_.info(LogUtil.throwableToString(e));
0:                 }
0:             }
0:             expungedValues.clear();
0:         }
0:     }   
0: 
0:     private ICacheExpungeHook<K,V> globalHook_;
0:     private Hashtable<K, CacheableObject<V>> cache_;
0:     private Map<K, ICacheExpungeHook<K,V>> hooks_;
0:     private Timer timer_;
0:     private static int counter_ = 0;
0:     private static Logger logger_ = Logger.getLogger(Cachetable.class);
0: 
0:     private void init(long expiration)
0:     {
0:         if ( expiration <= 0 )
0:             throw new IllegalArgumentException("Argument specified must be a positive number");
0: 
0:         cache_ = new Hashtable<K, CacheableObject<V>>();
0:         hooks_ = new Hashtable<K, ICacheExpungeHook<K,V>>();
0:         timer_ = new Timer("CACHETABLE-TIMER-" + (++counter_), true);        
0:         timer_.schedule(new CacheMonitor(expiration), expiration, expiration);
0:     }
0:     
0:     /*
0:      * Specify the TTL for objects in the cache
0:      * in milliseconds.
0:      */
0:     public Cachetable(long expiration)
0:     {
0:         init(expiration);   
0:     }    
0:     
0:     /*
0:      * Specify the TTL for objects in the cache
0:      * in milliseconds and a global expunge hook. If
0:      * a key has a key-specific hook installed invoke that
0:      * instead.
0:      */
0:     public Cachetable(long expiration, ICacheExpungeHook<K,V> global)
0:     {
0:         init(expiration);
0:         globalHook_ = global;        
0:     }
0:     
0:     public void shutdown()
0:     {
0:         timer_.cancel();
0:     }
0:     
0:     public void put(K key, V value)
0:     {        
0:         cache_.put(key, new CacheableObject<V>(value));
0:     }
0: 
0:     public void put(K key, V value, ICacheExpungeHook<K,V> hook)
0:     {
0:         put(key, value);
0:         hooks_.put(key, hook);
0:     }
0: 
0:     public V get(K key)
0:     {
0:         V result = null;
0:         CacheableObject<V> co = cache_.get(key);
0:         if ( co != null )
0:         {
0:             result = co.getValue();
0:         }
0:         return result;
0:     }
0: 
0:     public V remove(K key)
0:     {
0:         CacheableObject<V> co = cache_.remove(key);
0:         V result = null;
0:         if ( co != null )
0:         {
0:             result = co.getValue();
0:         }
0:         return result;
0:     }
0: 
0:     public int size()
0:     {
0:         return cache_.size();
0:     }
0: 
0:     public boolean containsKey(K key)
0:     {
0:         return cache_.containsKey(key);
0:     }
0: 
0:     public boolean containsValue(V value)
0:     {
0:         return cache_.containsValue( new CacheableObject<V>(value) );
0:     }
0: 
0:     public boolean isEmpty()
0:     {
0:         return cache_.isEmpty();
0:     }
0: 
0:     public Set<K> keySet()
0:     {
0:         return cache_.keySet();
0:     }    
0: }
============================================================================