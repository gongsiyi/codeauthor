1:d43b9ce: /*
1:d43b9ce: * Licensed to the Apache Software Foundation (ASF) under one
1:d43b9ce: * or more contributor license agreements.  See the NOTICE file
1:d43b9ce: * distributed with this work for additional information
1:d43b9ce: * regarding copyright ownership.  The ASF licenses this file
1:d43b9ce: * to you under the Apache License, Version 2.0 (the
1:d43b9ce: * "License"); you may not use this file except in compliance
1:d43b9ce: * with the License.  You may obtain a copy of the License at
1:d43b9ce: *
1:d43b9ce: *    http://www.apache.org/licenses/LICENSE-2.0
1:d43b9ce: *
1:d43b9ce: * Unless required by applicable law or agreed to in writing,
1:d43b9ce: * software distributed under the License is distributed on an
1:d43b9ce: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:d43b9ce: * KIND, either express or implied.  See the License for the
1:d43b9ce: * specific language governing permissions and limitations
1:d43b9ce: * under the License.
1:d43b9ce: */
1:d43b9ce: package org.apache.cassandra.net;
1:d43b9ce: 
1:d43b9ce: import java.net.InetAddress;
1:d43b9ce: import java.util.Map;
1:d43b9ce: import java.util.Set;
1:d43b9ce: import java.util.concurrent.TimeUnit;
1:d43b9ce: 
1:d43b9ce: import com.google.common.collect.ImmutableMap;
1:d43b9ce: import com.google.common.collect.Sets;
1:d43b9ce: import com.google.common.util.concurrent.RateLimiter;
1:d43b9ce: 
1:d43b9ce: import org.junit.Assert;
1:d43b9ce: import org.junit.Test;
1:d43b9ce: 
1:d43b9ce: import org.apache.cassandra.utils.TestTimeSource;
1:d43b9ce: import org.apache.cassandra.utils.TimeSource;
1:d43b9ce: 
1:d43b9ce: import static org.apache.cassandra.net.RateBasedBackPressure.FACTOR;
1:d43b9ce: import static org.apache.cassandra.net.RateBasedBackPressure.FLOW;
1:d43b9ce: import static org.apache.cassandra.net.RateBasedBackPressure.HIGH_RATIO;
1:d43b9ce: import static org.junit.Assert.assertEquals;
1:d43b9ce: import static org.junit.Assert.assertFalse;
1:d43b9ce: import static org.junit.Assert.assertTrue;
1:d43b9ce: import static org.junit.Assert.fail;
1:d43b9ce: 
1:d43b9ce: public class RateBasedBackPressureTest
1:d43b9ce: {
1:d43b9ce:     @Test(expected = IllegalArgumentException.class)
1:d43b9ce:     public void testAcceptsNoLessThanThreeArguments() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "1"), new TestTimeSource(), 10);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test(expected = IllegalArgumentException.class)
1:d43b9ce:     public void testHighRatioMustBeBiggerThanZero() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0", FACTOR, "2", FLOW, "FAST"), new TestTimeSource(), 10);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test(expected = IllegalArgumentException.class)
1:d43b9ce:     public void testHighRatioMustBeSmallerEqualThanOne() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "2", FACTOR, "2", FLOW, "FAST"), new TestTimeSource(), 10);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test(expected = IllegalArgumentException.class)
1:d43b9ce:     public void testFactorMustBeBiggerEqualThanOne() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "0", FLOW, "FAST"), new TestTimeSource(), 10);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test(expected = IllegalArgumentException.class)
1:d43b9ce:     public void testWindowSizeMustBeBiggerEqualThanTen() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "5", FLOW, "FAST"), new TestTimeSource(), 1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testFlowMustBeEitherFASTorSLOW() throws Exception
1:d43b9ce:     {
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "FAST"), new TestTimeSource(), 10);
1:d43b9ce:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "SLOW"), new TestTimeSource(), 10);
1:d43b9ce:         try
1:d43b9ce:         {
1:d43b9ce:             new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "WRONG"), new TestTimeSource(), 10);
1:d43b9ce:             fail("Expected to fail with wrong flow type.");
1:d43b9ce:         }
1:d43b9ce:         catch (Exception ex)
1:d43b9ce:         {
1:d43b9ce:         }
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureStateUpdates()
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce: 
1:d43b9ce:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce:         state.onMessageSent(null);
1:d43b9ce:         assertEquals(0, state.incomingRate.size());
1:d43b9ce:         assertEquals(0, state.outgoingRate.size());
1:d43b9ce: 
1:d43b9ce:         state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce:         state.onResponseReceived();
1:d43b9ce:         assertEquals(1, state.incomingRate.size());
1:d43b9ce:         assertEquals(1, state.outgoingRate.size());
1:d43b9ce: 
1:d43b9ce:         state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce:         state.onResponseTimeout();
1:d43b9ce:         assertEquals(0, state.incomingRate.size());
1:d43b9ce:         assertEquals(1, state.outgoingRate.size());
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureIsNotUpdatedBeyondInfinity() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce: 
1:d43b9ce:         // Get initial rate:
1:d43b9ce:         double initialRate = state.rateLimiter.getRate();
1:d43b9ce:         assertEquals(Double.POSITIVE_INFINITY, initialRate, 0.0);
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate equally:
1:d43b9ce:         state.incomingRate.update(1);
1:d43b9ce:         state.outgoingRate.update(1);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the rate doesn't change because already at infinity:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         assertEquals(initialRate, state.rateLimiter.getRate(), 0.0);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureIsUpdatedOncePerWindowSize() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce: 
1:d43b9ce:         // Get initial time:
1:d43b9ce:         long current = state.getLastIntervalAcquire();
1:d43b9ce:         assertEquals(0, current);
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate:
1:d43b9ce:         state.incomingRate.update(1);
1:d43b9ce:         state.outgoingRate.update(1);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead by window size:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the timestamp changed:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         current = state.getLastIntervalAcquire();
1:d43b9ce:         assertEquals(timeSource.currentTimeMillis(), current);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead by less than interval:
1:d43b9ce:         long previous = current;
1:d43b9ce:         timeSource.sleep(windowSize / 2, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the last timestamp didn't change because below the window size:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         current = state.getLastIntervalAcquire();
1:d43b9ce:         assertEquals(previous, current);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureWhenBelowHighRatio() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate so that the ratio is 0.5:
1:d43b9ce:         state.incomingRate.update(50);
1:d43b9ce:         state.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the rate is decreased by factor:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         assertEquals(7.4, state.rateLimiter.getRate(), 0.1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureRateLimiterIsIncreasedAfterGoingAgainAboveHighRatio() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate so that the ratio is 0.5:
1:d43b9ce:         state.incomingRate.update(50);
1:d43b9ce:         state.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the rate decreased:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         assertEquals(7.4, state.rateLimiter.getRate(), 0.1);
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate back above high rate:
1:d43b9ce:         state.incomingRate.update(50);
1:d43b9ce:         state.outgoingRate.update(50);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify rate limiter is increased by factor:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         assertEquals(8.25, state.rateLimiter.getRate(), 0.1);
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rate to keep it below the limiter rate:
1:d43b9ce:         state.incomingRate.update(1);
1:d43b9ce:         state.outgoingRate.update(1);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify rate limiter is not increased as already higher than the actual rate:
1:d43b9ce:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:d43b9ce:         assertEquals(8.25, state.rateLimiter.getRate(), 0.1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureFastFlow() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:d43b9ce:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:d43b9ce:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rates:
1:d43b9ce:         state1.incomingRate.update(50);
1:d43b9ce:         state1.outgoingRate.update(100);
1:d43b9ce:         state2.incomingRate.update(80); // fast
1:d43b9ce:         state2.outgoingRate.update(100);
1:d43b9ce:         state3.incomingRate.update(20);
1:d43b9ce:         state3.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the fast replica rate limiting has been applied:
1:d43b9ce:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:d43b9ce:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:d43b9ce:         assertTrue(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(12.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureSlowFlow() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:d43b9ce:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:d43b9ce:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rates:
1:d43b9ce:         state1.incomingRate.update(50);
1:d43b9ce:         state1.outgoingRate.update(100);
1:d43b9ce:         state2.incomingRate.update(100);
1:d43b9ce:         state2.outgoingRate.update(100);
1:d43b9ce:         state3.incomingRate.update(20); // slow
1:d43b9ce:         state3.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the slow replica rate limiting has been applied:
1:d43b9ce:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:d43b9ce:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:d43b9ce:         assertTrue(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressureWithDifferentGroups() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 6000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:d43b9ce:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:d43b9ce:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1:d43b9ce:         RateBasedBackPressureState state4 = strategy.newState(InetAddress.getByName("127.0.0.4"));
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rates:
1:d43b9ce:         state1.incomingRate.update(50); // this
1:d43b9ce:         state1.outgoingRate.update(100);
1:d43b9ce:         state2.incomingRate.update(100);
1:d43b9ce:         state2.outgoingRate.update(100);
1:d43b9ce:         state3.incomingRate.update(20); // this
1:d43b9ce:         state3.outgoingRate.update(100);
1:d43b9ce:         state4.incomingRate.update(80);
1:d43b9ce:         state4.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the first group:
1:d43b9ce:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2);
1:d43b9ce:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:d43b9ce:         assertTrue(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(7.4, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:d43b9ce: 
1:d43b9ce:         // Verify the second group:
1:d43b9ce:         replicaGroup = Sets.newHashSet(state3, state4);
1:d43b9ce:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:d43b9ce:         assertTrue(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     @Test
1:d43b9ce:     public void testBackPressurePastTimeout() throws Exception
1:d43b9ce:     {
1:d43b9ce:         long windowSize = 10000;
1:d43b9ce:         TestTimeSource timeSource = new TestTimeSource();
1:d43b9ce:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:d43b9ce:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:d43b9ce:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:d43b9ce:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1:d43b9ce: 
1:d43b9ce:         // Update incoming and outgoing rates:
1:d43b9ce:         state1.incomingRate.update(5); // slow
1:d43b9ce:         state1.outgoingRate.update(100);
1:d43b9ce:         state2.incomingRate.update(100);
1:d43b9ce:         state2.outgoingRate.update(100);
1:d43b9ce:         state3.incomingRate.update(100);
1:d43b9ce:         state3.outgoingRate.update(100);
1:d43b9ce: 
1:d43b9ce:         // Move time ahead:
1:d43b9ce:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1:d43b9ce: 
1:d43b9ce:         // Verify the slow replica rate limiting has been applied:
1:d43b9ce:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:d43b9ce:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1:d43b9ce:         assertTrue(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(0.5, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:d43b9ce: 
1:d43b9ce:         // Make one more apply call to saturate the rate limit timeout (0.5 requests per second means 2 requests span
1:d43b9ce:         // 4 seconds, but we can only make one as we have to subtract the incoming response time):
1:d43b9ce:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1:d43b9ce: 
1:d43b9ce:         // Now verify another call to apply doesn't acquire the rate limit because of the max timeout of 4 seconds minus
1:d43b9ce:         // 2 seconds of response time, so the time source itself sleeps two second:
1:d43b9ce:         long start = timeSource.currentTimeMillis();
1:d43b9ce:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1:d43b9ce:         assertFalse(strategy.checkAcquired());
1:d43b9ce:         assertTrue(strategy.checkApplied());
1:d43b9ce:         assertEquals(TimeUnit.NANOSECONDS.convert(2, TimeUnit.SECONDS),
1:d43b9ce:                      strategy.timeout);
1:d43b9ce:         assertEquals(strategy.timeout,
1:d43b9ce:                      TimeUnit.NANOSECONDS.convert(timeSource.currentTimeMillis() - start, TimeUnit.MILLISECONDS));
1:d43b9ce:     }
1:d43b9ce: 
1:d43b9ce:     public static class TestableBackPressure extends RateBasedBackPressure
1:d43b9ce:     {
1:d43b9ce:         public volatile boolean acquired = false;
1:d43b9ce:         public volatile boolean applied = false;
1:d43b9ce:         public volatile long timeout;
1:d43b9ce: 
1:d43b9ce:         public TestableBackPressure(Map<String, Object> args, TimeSource timeSource, long windowSize)
1:d43b9ce:         {
1:d43b9ce:             super(args, timeSource, windowSize);
1:d43b9ce:         }
1:d43b9ce: 
1:d43b9ce:         @Override
1:d43b9ce:         public boolean doRateLimit(RateLimiter rateLimiter, long timeoutInNanos)
1:d43b9ce:         {
1:d43b9ce:             acquired = super.doRateLimit(rateLimiter, timeoutInNanos);
1:d43b9ce:             applied = true;
1:d43b9ce:             timeout = timeoutInNanos;
1:d43b9ce:             return acquired;
1:d43b9ce:         }
1:d43b9ce: 
1:d43b9ce:         public boolean checkAcquired()
1:d43b9ce:         {
1:d43b9ce:             boolean checked = acquired;
1:d43b9ce:             acquired = false;
1:d43b9ce:             return checked;
1:d43b9ce:         }
1:d43b9ce: 
1:d43b9ce:         public boolean checkApplied()
1:d43b9ce:         {
1:d43b9ce:             boolean checked = applied;
1:d43b9ce:             applied = false;
1:d43b9ce:             return checked;
1:d43b9ce:         }
1:d43b9ce:     }
1:d43b9ce: }
============================================================================
author:Sergio Bossa
-------------------------------------------------------------------------------
commit:d43b9ce
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.net;
1: 
1: import java.net.InetAddress;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.TimeUnit;
1: 
1: import com.google.common.collect.ImmutableMap;
1: import com.google.common.collect.Sets;
1: import com.google.common.util.concurrent.RateLimiter;
1: 
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.utils.TestTimeSource;
1: import org.apache.cassandra.utils.TimeSource;
1: 
1: import static org.apache.cassandra.net.RateBasedBackPressure.FACTOR;
1: import static org.apache.cassandra.net.RateBasedBackPressure.FLOW;
1: import static org.apache.cassandra.net.RateBasedBackPressure.HIGH_RATIO;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class RateBasedBackPressureTest
1: {
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testAcceptsNoLessThanThreeArguments() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "1"), new TestTimeSource(), 10);
1:     }
1: 
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testHighRatioMustBeBiggerThanZero() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0", FACTOR, "2", FLOW, "FAST"), new TestTimeSource(), 10);
1:     }
1: 
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testHighRatioMustBeSmallerEqualThanOne() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "2", FACTOR, "2", FLOW, "FAST"), new TestTimeSource(), 10);
1:     }
1: 
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testFactorMustBeBiggerEqualThanOne() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "0", FLOW, "FAST"), new TestTimeSource(), 10);
1:     }
1: 
1:     @Test(expected = IllegalArgumentException.class)
1:     public void testWindowSizeMustBeBiggerEqualThanTen() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "5", FLOW, "FAST"), new TestTimeSource(), 1);
1:     }
1: 
1:     @Test
1:     public void testFlowMustBeEitherFASTorSLOW() throws Exception
1:     {
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "FAST"), new TestTimeSource(), 10);
1:         new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "SLOW"), new TestTimeSource(), 10);
1:         try
1:         {
1:             new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "1", FLOW, "WRONG"), new TestTimeSource(), 10);
1:             fail("Expected to fail with wrong flow type.");
1:         }
1:         catch (Exception ex)
1:         {
1:         }
1:     }
1: 
1:     @Test
1:     public void testBackPressureStateUpdates()
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1: 
1:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1:         state.onMessageSent(null);
1:         assertEquals(0, state.incomingRate.size());
1:         assertEquals(0, state.outgoingRate.size());
1: 
1:         state = strategy.newState(InetAddress.getLoopbackAddress());
1:         state.onResponseReceived();
1:         assertEquals(1, state.incomingRate.size());
1:         assertEquals(1, state.outgoingRate.size());
1: 
1:         state = strategy.newState(InetAddress.getLoopbackAddress());
1:         state.onResponseTimeout();
1:         assertEquals(0, state.incomingRate.size());
1:         assertEquals(1, state.outgoingRate.size());
1:     }
1: 
1:     @Test
1:     public void testBackPressureIsNotUpdatedBeyondInfinity() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1: 
1:         // Get initial rate:
1:         double initialRate = state.rateLimiter.getRate();
1:         assertEquals(Double.POSITIVE_INFINITY, initialRate, 0.0);
1: 
1:         // Update incoming and outgoing rate equally:
1:         state.incomingRate.update(1);
1:         state.outgoingRate.update(1);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the rate doesn't change because already at infinity:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         assertEquals(initialRate, state.rateLimiter.getRate(), 0.0);
1:     }
1: 
1:     @Test
1:     public void testBackPressureIsUpdatedOncePerWindowSize() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1: 
1:         // Get initial time:
1:         long current = state.getLastIntervalAcquire();
1:         assertEquals(0, current);
1: 
1:         // Update incoming and outgoing rate:
1:         state.incomingRate.update(1);
1:         state.outgoingRate.update(1);
1: 
1:         // Move time ahead by window size:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the timestamp changed:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         current = state.getLastIntervalAcquire();
1:         assertEquals(timeSource.currentTimeMillis(), current);
1: 
1:         // Move time ahead by less than interval:
1:         long previous = current;
1:         timeSource.sleep(windowSize / 2, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the last timestamp didn't change because below the window size:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         current = state.getLastIntervalAcquire();
1:         assertEquals(previous, current);
1:     }
1: 
1:     @Test
1:     public void testBackPressureWhenBelowHighRatio() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1: 
1:         // Update incoming and outgoing rate so that the ratio is 0.5:
1:         state.incomingRate.update(50);
1:         state.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the rate is decreased by factor:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         assertEquals(7.4, state.rateLimiter.getRate(), 0.1);
1:     }
1: 
1:     @Test
1:     public void testBackPressureRateLimiterIsIncreasedAfterGoingAgainAboveHighRatio() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:         RateBasedBackPressureState state = strategy.newState(InetAddress.getLoopbackAddress());
1: 
1:         // Update incoming and outgoing rate so that the ratio is 0.5:
1:         state.incomingRate.update(50);
1:         state.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the rate decreased:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         assertEquals(7.4, state.rateLimiter.getRate(), 0.1);
1: 
1:         // Update incoming and outgoing rate back above high rate:
1:         state.incomingRate.update(50);
1:         state.outgoingRate.update(50);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify rate limiter is increased by factor:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         assertEquals(8.25, state.rateLimiter.getRate(), 0.1);
1: 
1:         // Update incoming and outgoing rate to keep it below the limiter rate:
1:         state.incomingRate.update(1);
1:         state.outgoingRate.update(1);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify rate limiter is not increased as already higher than the actual rate:
1:         strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
1:         assertEquals(8.25, state.rateLimiter.getRate(), 0.1);
1:     }
1: 
1:     @Test
1:     public void testBackPressureFastFlow() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "FAST"), timeSource, windowSize);
1:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1: 
1:         // Update incoming and outgoing rates:
1:         state1.incomingRate.update(50);
1:         state1.outgoingRate.update(100);
1:         state2.incomingRate.update(80); // fast
1:         state2.outgoingRate.update(100);
1:         state3.incomingRate.update(20);
1:         state3.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the fast replica rate limiting has been applied:
1:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:         assertTrue(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(12.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:     }
1: 
1:     @Test
1:     public void testBackPressureSlowFlow() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1: 
1:         // Update incoming and outgoing rates:
1:         state1.incomingRate.update(50);
1:         state1.outgoingRate.update(100);
1:         state2.incomingRate.update(100);
1:         state2.outgoingRate.update(100);
1:         state3.incomingRate.update(20); // slow
1:         state3.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the slow replica rate limiting has been applied:
1:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:         assertTrue(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:     }
1: 
1:     @Test
1:     public void testBackPressureWithDifferentGroups() throws Exception
1:     {
1:         long windowSize = 6000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1:         RateBasedBackPressureState state4 = strategy.newState(InetAddress.getByName("127.0.0.4"));
1: 
1:         // Update incoming and outgoing rates:
1:         state1.incomingRate.update(50); // this
1:         state1.outgoingRate.update(100);
1:         state2.incomingRate.update(100);
1:         state2.outgoingRate.update(100);
1:         state3.incomingRate.update(20); // this
1:         state3.outgoingRate.update(100);
1:         state4.incomingRate.update(80);
1:         state4.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the first group:
1:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2);
1:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:         assertTrue(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(7.4, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1: 
1:         // Verify the second group:
1:         replicaGroup = Sets.newHashSet(state3, state4);
1:         strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
1:         assertTrue(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1:     }
1: 
1:     @Test
1:     public void testBackPressurePastTimeout() throws Exception
1:     {
1:         long windowSize = 10000;
1:         TestTimeSource timeSource = new TestTimeSource();
1:         TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, "0.9", FACTOR, "10", FLOW, "SLOW"), timeSource, windowSize);
1:         RateBasedBackPressureState state1 = strategy.newState(InetAddress.getByName("127.0.0.1"));
1:         RateBasedBackPressureState state2 = strategy.newState(InetAddress.getByName("127.0.0.2"));
1:         RateBasedBackPressureState state3 = strategy.newState(InetAddress.getByName("127.0.0.3"));
1: 
1:         // Update incoming and outgoing rates:
1:         state1.incomingRate.update(5); // slow
1:         state1.outgoingRate.update(100);
1:         state2.incomingRate.update(100);
1:         state2.outgoingRate.update(100);
1:         state3.incomingRate.update(100);
1:         state3.outgoingRate.update(100);
1: 
1:         // Move time ahead:
1:         timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);
1: 
1:         // Verify the slow replica rate limiting has been applied:
1:         Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
1:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1:         assertTrue(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(0.5, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
1: 
1:         // Make one more apply call to saturate the rate limit timeout (0.5 requests per second means 2 requests span
1:         // 4 seconds, but we can only make one as we have to subtract the incoming response time):
1:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1: 
1:         // Now verify another call to apply doesn't acquire the rate limit because of the max timeout of 4 seconds minus
1:         // 2 seconds of response time, so the time source itself sleeps two second:
1:         long start = timeSource.currentTimeMillis();
1:         strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
1:         assertFalse(strategy.checkAcquired());
1:         assertTrue(strategy.checkApplied());
1:         assertEquals(TimeUnit.NANOSECONDS.convert(2, TimeUnit.SECONDS),
1:                      strategy.timeout);
1:         assertEquals(strategy.timeout,
1:                      TimeUnit.NANOSECONDS.convert(timeSource.currentTimeMillis() - start, TimeUnit.MILLISECONDS));
1:     }
1: 
1:     public static class TestableBackPressure extends RateBasedBackPressure
1:     {
1:         public volatile boolean acquired = false;
1:         public volatile boolean applied = false;
1:         public volatile long timeout;
1: 
1:         public TestableBackPressure(Map<String, Object> args, TimeSource timeSource, long windowSize)
1:         {
1:             super(args, timeSource, windowSize);
1:         }
1: 
1:         @Override
1:         public boolean doRateLimit(RateLimiter rateLimiter, long timeoutInNanos)
1:         {
1:             acquired = super.doRateLimit(rateLimiter, timeoutInNanos);
1:             applied = true;
1:             timeout = timeoutInNanos;
1:             return acquired;
1:         }
1: 
1:         public boolean checkAcquired()
1:         {
1:             boolean checked = acquired;
1:             acquired = false;
1:             return checked;
1:         }
1: 
1:         public boolean checkApplied()
1:         {
1:             boolean checked = applied;
1:             applied = false;
1:             return checked;
1:         }
1:     }
1: }
============================================================================