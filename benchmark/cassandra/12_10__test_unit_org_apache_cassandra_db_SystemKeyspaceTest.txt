1:1adcd1c: /*
1:1adcd1c:  * Licensed to the Apache Software Foundation (ASF) under one
1:1adcd1c:  * or more contributor license agreements.  See the NOTICE file
1:1adcd1c:  * distributed with this work for additional information
1:1adcd1c:  * regarding copyright ownership.  The ASF licenses this file
1:1adcd1c:  * to you under the Apache License, Version 2.0 (the
1:1adcd1c:  * "License"); you may not use this file except in compliance
1:1adcd1c:  * with the License.  You may obtain a copy of the License at
3:1adcd1c:  *
1:690fbf3:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1adcd1c:  *
1:690fbf3:  * Unless required by applicable law or agreed to in writing, software
1:690fbf3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:690fbf3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:690fbf3:  * See the License for the specific language governing permissions and
1:690fbf3:  * limitations under the License.
1:1adcd1c:  */
1:690fbf3: package org.apache.cassandra.db;
1:1adcd1c: 
1:b09e60f: import java.io.File;
1:194bad2: import java.io.IOException;
1:05d4222: import java.net.InetAddress;
1:05d4222: import java.net.UnknownHostException;
1:b09e60f: import java.nio.file.Path;
1:b09e60f: import java.nio.file.Paths;
1:690fbf3: import java.util.*;
1:05d4222: 
1:b09e60f: import org.apache.commons.io.FileUtils;
1:b7ae07e: import org.junit.BeforeClass;
1:05d4222: import org.junit.Test;
1:05d4222: 
1:194bad2: import org.apache.cassandra.config.DatabaseDescriptor;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:194bad2: import org.apache.cassandra.cql3.QueryProcessor;
1:194bad2: import org.apache.cassandra.cql3.UntypedResultSet;
1:07893d7: import org.apache.cassandra.dht.ByteOrderedPartitioner.BytesToken;
1:66b96ee: import org.apache.cassandra.dht.Token;
1:b09e60f: import org.apache.cassandra.io.sstable.Descriptor;
1:05d4222: import org.apache.cassandra.utils.ByteBufferUtil;
1:dcddfaf: import org.apache.cassandra.utils.FBUtilities;
1:2385dc2: import org.apache.cassandra.utils.CassandraVersion;
1:194bad2: 
1:194bad2: import static org.junit.Assert.assertEquals;
1:194bad2: import static org.junit.Assert.assertTrue;
1:05d4222: 
1:0e96e58: public class SystemKeyspaceTest
1:05d4222: {
1:b09e60f:     public static final String MIGRATION_SSTABLES_ROOT = "migration-sstable-root";
1:b09e60f: 
1:b7ae07e:     @BeforeClass
1:b7ae07e:     public static void prepSnapshotTracker()
1:b7ae07e:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511: 
1:54836ec:         if (FBUtilities.isWindows)
1:b7ae07e:             WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:b7ae07e:     }
1:b7ae07e: 
1:b09e60f:     @Test
1:66b96ee:     public void testLocalTokens()
1:b09e60f:     {
1:66b96ee:         // Remove all existing tokens
1:0e96e58:         Collection<Token> current = SystemKeyspace.loadTokens().asMap().get(FBUtilities.getLocalAddress());
1:dcddfaf:         if (current != null && !current.isEmpty())
1:0e96e58:             SystemKeyspace.updateTokens(current);
1:194bad2: 
1:66b96ee:         List<Token> tokens = new ArrayList<Token>()
1:66b96ee:         {{
1:66b96ee:             for (int i = 0; i < 9; i++)
1:66b96ee:                 add(new BytesToken(ByteBufferUtil.bytes(String.format("token%d", i))));
1:66b96ee:         }};
1:05d4222: 
1:0e96e58:         SystemKeyspace.updateTokens(tokens);
1:66b96ee:         int count = 0;
1:05d4222: 
1:0e96e58:         for (Token tok : SystemKeyspace.getSavedTokens())
1:66b96ee:             assert tokens.get(count++).equals(tok);
1:05d4222:     }
1:05d4222: 
1:194bad2:     @Test
1:05d4222:     public void testNonLocalToken() throws UnknownHostException
1:194bad2:     {
1:05d4222:         BytesToken token = new BytesToken(ByteBufferUtil.bytes("token3"));
1:05d4222:         InetAddress address = InetAddress.getByName("127.0.0.2");
1:0e96e58:         SystemKeyspace.updateTokens(address, Collections.<Token>singletonList(token));
1:0e96e58:         assert SystemKeyspace.loadTokens().get(address).contains(token);
1:0e96e58:         SystemKeyspace.removeEndpoint(address);
1:0e96e58:         assert !SystemKeyspace.loadTokens().containsValue(token);
1:05d4222:     }
1:eb886e9: 
1:05d4222:     @Test
1:712ffeb:     public void testLocalHostID()
1:05d4222:     {
1:0e96e58:         UUID firstId = SystemKeyspace.getLocalHostId();
1:0e96e58:         UUID secondId = SystemKeyspace.getLocalHostId();
1:712ffeb:         assert firstId.equals(secondId) : String.format("%s != %s%n", firstId.toString(), secondId.toString());
1:05d4222:     }
1:194bad2: 
1:b7ae07e:     private void assertDeletedOrDeferred(int expectedCount)
1:b7ae07e:     {
1:54836ec:         if (FBUtilities.isWindows)
1:b7ae07e:             assertEquals(expectedCount, getDeferredDeletionCount());
1:b7ae07e:         else
1:b7ae07e:             assertTrue(getSystemSnapshotFiles().isEmpty());
1:b7ae07e:     }
1:b7ae07e: 
1:b7ae07e:     private int getDeferredDeletionCount()
1:b7ae07e:     {
1:b7ae07e:         try
1:b7ae07e:         {
1:b7ae07e:             Class c = Class.forName("java.io.DeleteOnExitHook");
1:b7ae07e:             LinkedHashSet<String> files = (LinkedHashSet<String>)FBUtilities.getProtectedField(c, "files").get(c);
1:b7ae07e:             return files.size();
1:b7ae07e:         }
1:b7ae07e:         catch (Exception e)
1:b7ae07e:         {
1:b7ae07e:             throw new RuntimeException(e);
1:b7ae07e:         }
1:b7ae07e:     }
1:b7ae07e: 
1:05d4222:     @Test
1:194bad2:     public void snapshotSystemKeyspaceIfUpgrading() throws IOException
1:05d4222:     {
1:194bad2:         // First, check that in the absence of any previous installed version, we don't create snapshots
1:9797511:         for (ColumnFamilyStore cfs : Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStores())
1:194bad2:             cfs.clearUnsafe();
1:9797511:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
1:eb886e9: 
1:b7ae07e:         int baseline = getDeferredDeletionCount();
1:b7ae07e: 
1:194bad2:         SystemKeyspace.snapshotOnVersionChange();
1:b7ae07e:         assertDeletedOrDeferred(baseline);
1:194bad2: 
1:194bad2:         // now setup system.local as if we're upgrading from a previous version
1:f9b6d3d:         setupReleaseVersion(getOlderVersionString());
1:9797511:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
1:b7ae07e:         assertDeletedOrDeferred(baseline);
1:194bad2: 
1:194bad2:         // Compare versions again & verify that snapshots were created for all tables in the system ks
1:194bad2:         SystemKeyspace.snapshotOnVersionChange();
1:a89597d:         assertEquals(SystemKeyspace.metadata().tables.size(), getSystemSnapshotFiles().size());
1:194bad2: 
1:194bad2:         // clear out the snapshots & set the previous recorded version equal to the latest, we shouldn't
1:194bad2:         // see any new snapshots created this time.
1:9797511:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
1:f9b6d3d:         setupReleaseVersion(FBUtilities.getReleaseVersionString());
1:b7ae07e: 
1:194bad2:         SystemKeyspace.snapshotOnVersionChange();
1:194bad2: 
1:b7ae07e:         // snapshotOnVersionChange for upgrade case will open a SSTR when the CFS is flushed. On Windows, we won't be
1:b7ae07e:         // able to delete hard-links to that file while segments are memory-mapped, so they'll be marked for deferred deletion.
1:b7ae07e:         // 10 files expected.
1:b7ae07e:         assertDeletedOrDeferred(baseline + 10);
1:b7ae07e: 
1:9797511:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
1:194bad2:     }
1:194bad2: 
1:eb886e9:     @Test
1:d0da9e7:     public void testMigrateEmptyDataDirs() throws IOException
1:d0da9e7:     {
1:d0da9e7:         File dataDir = Paths.get(DatabaseDescriptor.getAllDataFileLocations()[0]).toFile();
1:d0da9e7:         if (new File(dataDir, "Emptykeyspace1").exists())
1:d0da9e7:             FileUtils.deleteDirectory(new File(dataDir, "Emptykeyspace1"));
1:d0da9e7:         assertTrue(new File(dataDir, "Emptykeyspace1").mkdirs());
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7:         SystemKeyspace.migrateDataDirs();
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7: 
1:d0da9e7:         assertTrue(new File(dataDir, "Emptykeyspace1/table1").mkdirs());
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7:         SystemKeyspace.migrateDataDirs();
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7: 
1:d0da9e7:         assertTrue(new File(dataDir, "Emptykeyspace1/wrong_file").createNewFile());
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7:         SystemKeyspace.migrateDataDirs();
1:d0da9e7:         assertEquals(0, numLegacyFiles());
1:d0da9e7: 
1:d0da9e7:     }
1:d0da9e7: 
1:d0da9e7:     @Test
1:76ca697:     public void testMigrateDataDirs_2_1() throws IOException
1:194bad2:     {
1:a1d9a02:         testMigrateDataDirs("2.1", 5); // see test data for num legacy files
1:76ca697:     }
1:76ca697: 
1:76ca697:     @Test
1:76ca697:     public void testMigrateDataDirs_2_2() throws IOException
1:76ca697:     {
1:a1d9a02:         testMigrateDataDirs("2.2", 7); // see test data for num legacy files
1:76ca697:     }
1:76ca697: 
1:a1d9a02:     private void testMigrateDataDirs(String version, int numLegacyFiles) throws IOException
1:76ca697:     {
1:76ca697:         Path migrationSSTableRoot = Paths.get(System.getProperty(MIGRATION_SSTABLES_ROOT), version);
1:b09e60f:         Path dataDir = Paths.get(DatabaseDescriptor.getAllDataFileLocations()[0]);
1:b09e60f: 
1:b09e60f:         FileUtils.copyDirectory(migrationSSTableRoot.toFile(), dataDir.toFile());
1:b09e60f: 
1:a1d9a02:         assertEquals(numLegacyFiles, numLegacyFiles());
1:b09e60f: 
1:b09e60f:         SystemKeyspace.migrateDataDirs();
1:b09e60f: 
1:b09e60f:         assertEquals(0, numLegacyFiles());
1:b09e60f:     }
1:b09e60f: 
1:b09e60f:     private static int numLegacyFiles()
1:b09e60f:     {
1:b09e60f:         int ret = 0;
1:b09e60f:         Iterable<String> dirs = Arrays.asList(DatabaseDescriptor.getAllDataFileLocations());
1:b09e60f:         for (String dataDir : dirs)
1:b09e60f:         {
1:b09e60f:             File dir = new File(dataDir);
1:d0da9e7:             for (File ksdir : dir.listFiles((d, n) -> new File(d, n).isDirectory()))
1:b09e60f:             {
1:d0da9e7:                 for (File cfdir : ksdir.listFiles((d, n) -> new File(d, n).isDirectory()))
1:b09e60f:                 {
1:76ca697:                     if (Descriptor.isLegacyFile(cfdir))
1:b09e60f:                     {
1:b09e60f:                         ret++;
1:b09e60f:                     }
1:b09e60f:                     else
1:b09e60f:                     {
1:76ca697:                         File[] legacyFiles = cfdir.listFiles((d, n) -> Descriptor.isLegacyFile(new File(d, n)));
1:b09e60f:                         ret += legacyFiles.length;
1:b09e60f:                     }
1:b09e60f:                 }
1:b09e60f:             }
1:b09e60f:         }
1:b09e60f:         return ret;
1:b09e60f:     }
1:b09e60f: 
1:f9b6d3d:     private String getOlderVersionString()
1:eb886e9:     {
1:f9b6d3d:         String version = FBUtilities.getReleaseVersionString();
1:2385dc2:         CassandraVersion semver = new CassandraVersion(version.contains("-") ? version.substring(0, version.indexOf('-'))
1:f9b6d3d:                                                                            : version);
1:f9b6d3d:         return (String.format("%s.%s.%s", semver.major - 1, semver.minor, semver.patch));
1:194bad2:     }
1:194bad2: 
1:194bad2:     private Set<String> getSystemSnapshotFiles()
1:194bad2:     {
1:194bad2:         Set<String> snapshottedTableNames = new HashSet<>();
1:9797511:         for (ColumnFamilyStore cfs : Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStores())
1:194bad2:         {
1:194bad2:             if (!cfs.getSnapshotDetails().isEmpty())
1:194bad2:                 snapshottedTableNames.add(cfs.getColumnFamilyName());
1:194bad2:         }
1:194bad2:         return snapshottedTableNames;
1:194bad2:     }
1:194bad2: 
1:f9b6d3d:     private void setupReleaseVersion(String version)
1:194bad2:     {
1:194bad2:         // besides the release_version, we also need to insert the cluster_name or the check
1:194bad2:         // in SystemKeyspace.checkHealth were we verify it matches DatabaseDescriptor will fail
1:194bad2:         QueryProcessor.executeInternal(String.format("INSERT INTO system.local(key, release_version, cluster_name) " +
1:194bad2:                                                      "VALUES ('local', '%s', '%s')",
1:194bad2:                                                      version,
1:194bad2:                                                      DatabaseDescriptor.getClusterName()));
1:194bad2:         String r = readLocalVersion();
1:f9b6d3d:         assertEquals(String.format("Expected %s, got %s", version, r), version, r);
1:194bad2:     }
1:194bad2: 
1:194bad2:     private String readLocalVersion()
1:194bad2:     {
1:194bad2:         UntypedResultSet rs = QueryProcessor.executeInternal("SELECT release_version FROM system.local WHERE key='local'");
1:194bad2:         return rs.isEmpty() || !rs.one().has("release_version") ? null : rs.one().getString("release_version");
1:194bad2:     }
1:eb886e9: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:ce84226
commit:a1d9a02
/////////////////////////////////////////////////////////////////////////
1:         testMigrateDataDirs("2.1", 5); // see test data for num legacy files
1:         testMigrateDataDirs("2.2", 7); // see test data for num legacy files
1:     private void testMigrateDataDirs(String version, int numLegacyFiles) throws IOException
1:         assertEquals(numLegacyFiles, numLegacyFiles());
commit:d0da9e7
/////////////////////////////////////////////////////////////////////////
1:     public void testMigrateEmptyDataDirs() throws IOException
1:     {
1:         File dataDir = Paths.get(DatabaseDescriptor.getAllDataFileLocations()[0]).toFile();
1:         if (new File(dataDir, "Emptykeyspace1").exists())
1:             FileUtils.deleteDirectory(new File(dataDir, "Emptykeyspace1"));
1:         assertTrue(new File(dataDir, "Emptykeyspace1").mkdirs());
1:         assertEquals(0, numLegacyFiles());
1:         SystemKeyspace.migrateDataDirs();
1:         assertEquals(0, numLegacyFiles());
1: 
1:         assertTrue(new File(dataDir, "Emptykeyspace1/table1").mkdirs());
1:         assertEquals(0, numLegacyFiles());
1:         SystemKeyspace.migrateDataDirs();
1:         assertEquals(0, numLegacyFiles());
1: 
1:         assertTrue(new File(dataDir, "Emptykeyspace1/wrong_file").createNewFile());
1:         assertEquals(0, numLegacyFiles());
1:         SystemKeyspace.migrateDataDirs();
1:         assertEquals(0, numLegacyFiles());
1: 
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:             for (File ksdir : dir.listFiles((d, n) -> new File(d, n).isDirectory()))
1:                 for (File cfdir : ksdir.listFiles((d, n) -> new File(d, n).isDirectory()))
commit:76ca697
/////////////////////////////////////////////////////////////////////////
1:     public void testMigrateDataDirs_2_1() throws IOException
0:         testMigrateDataDirs("2.1");
1:     }
1: 
1:     @Test
1:     public void testMigrateDataDirs_2_2() throws IOException
1:     {
0:         testMigrateDataDirs("2.2");
1:     }
1: 
0:     private void testMigrateDataDirs(String version) throws IOException
1:     {
1:         Path migrationSSTableRoot = Paths.get(System.getProperty(MIGRATION_SSTABLES_ROOT), version);
/////////////////////////////////////////////////////////////////////////
1:                     if (Descriptor.isLegacyFile(cfdir))
1:                         File[] legacyFiles = cfdir.listFiles((d, n) -> Descriptor.isLegacyFile(new File(d, n)));
commit:b09e60f
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.nio.file.Path;
1: import java.nio.file.Paths;
1: import org.apache.commons.io.FileUtils;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.sstable.Descriptor;
/////////////////////////////////////////////////////////////////////////
1:     public static final String MIGRATION_SSTABLES_ROOT = "migration-sstable-root";
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testMigrateDataDirs() throws IOException
1:     {
0:         Path migrationSSTableRoot = Paths.get(System.getProperty(MIGRATION_SSTABLES_ROOT), "2.2");
1:         Path dataDir = Paths.get(DatabaseDescriptor.getAllDataFileLocations()[0]);
1: 
1:         FileUtils.copyDirectory(migrationSSTableRoot.toFile(), dataDir.toFile());
1: 
0:         assertEquals(5, numLegacyFiles()); // see test data
1: 
1:         SystemKeyspace.migrateDataDirs();
1: 
1:         assertEquals(0, numLegacyFiles());
1:     }
1: 
1:     private static int numLegacyFiles()
1:     {
1:         int ret = 0;
1:         Iterable<String> dirs = Arrays.asList(DatabaseDescriptor.getAllDataFileLocations());
1:         for (String dataDir : dirs)
1:         {
1:             File dir = new File(dataDir);
0:             for (File ksdir : dir.listFiles((d, n) -> d.isDirectory()))
1:             {
0:                 for (File cfdir : ksdir.listFiles((d, n) -> d.isDirectory()))
1:                 {
0:                     if (Descriptor.isLegacyFile(cfdir.getName()))
1:                     {
1:                         ret++;
1:                     }
1:                     else
1:                     {
0:                         File[] legacyFiles = cfdir.listFiles((d, n) -> Descriptor.isLegacyFile(n));
1:                         ret += legacyFiles.length;
1:                     }
1:                 }
1:             }
1:         }
1:         return ret;
1:     }
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (ColumnFamilyStore cfs : Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStores())
1:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clearSnapshot(null, SchemaConstants.SYSTEM_KEYSPACE_NAME);
/////////////////////////////////////////////////////////////////////////
1:         for (ColumnFamilyStore cfs : Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStores())
commit:54836ec
/////////////////////////////////////////////////////////////////////////
1:         if (FBUtilities.isWindows)
/////////////////////////////////////////////////////////////////////////
1:         if (FBUtilities.isWindows)
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:036ddaf
commit:b7ae07e
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void prepSnapshotTracker()
1:     {
0:         if (FBUtilities.isWindows())
1:             WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void assertDeletedOrDeferred(int expectedCount)
1:     {
0:         if (FBUtilities.isWindows())
1:             assertEquals(expectedCount, getDeferredDeletionCount());
1:         else
1:             assertTrue(getSystemSnapshotFiles().isEmpty());
1:     }
1: 
1:     private int getDeferredDeletionCount()
1:     {
1:         try
1:         {
1:             Class c = Class.forName("java.io.DeleteOnExitHook");
1:             LinkedHashSet<String> files = (LinkedHashSet<String>)FBUtilities.getProtectedField(c, "files").get(c);
1:             return files.size();
1:         }
1:         catch (Exception e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         int baseline = getDeferredDeletionCount();
1: 
1:         assertDeletedOrDeferred(baseline);
1:         assertDeletedOrDeferred(baseline);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // snapshotOnVersionChange for upgrade case will open a SSTR when the CFS is flushed. On Windows, we won't be
1:         // able to delete hard-links to that file while segments are memory-mapped, so they'll be marked for deferred deletion.
1:         // 10 files expected.
1:         assertDeletedOrDeferred(baseline + 10);
1: 
0:         Keyspace.clearSnapshot(null, SystemKeyspace.NAME);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(SystemKeyspace.metadata().tables.size(), getSystemSnapshotFiles().size());
commit:6e1033b
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(SystemKeyspace.definition().tables.size(), getSystemSnapshotFiles().size());
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1: public class SystemKeyspaceTest
1:         Collection<Token> current = SystemKeyspace.loadTokens().asMap().get(FBUtilities.getLocalAddress());
1:             SystemKeyspace.updateTokens(current);
/////////////////////////////////////////////////////////////////////////
1:         SystemKeyspace.updateTokens(tokens);
1:         for (Token tok : SystemKeyspace.getSavedTokens())
/////////////////////////////////////////////////////////////////////////
1:         SystemKeyspace.updateTokens(address, Collections.<Token>singletonList(token));
1:         assert SystemKeyspace.loadTokens().get(address).contains(token);
1:         SystemKeyspace.removeEndpoint(address);
1:         assert !SystemKeyspace.loadTokens().containsValue(token);
1:         UUID firstId = SystemKeyspace.getLocalHostId();
1:         UUID secondId = SystemKeyspace.getLocalHostId();
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:2385dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.CassandraVersion;
/////////////////////////////////////////////////////////////////////////
1:         CassandraVersion semver = new CassandraVersion(version.contains("-") ? version.substring(0, version.indexOf('-'))
commit:690fbf3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.db;
1: import java.util.*;
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:f9b6d3d
/////////////////////////////////////////////////////////////////////////
1:         setupReleaseVersion(getOlderVersionString());
/////////////////////////////////////////////////////////////////////////
1:         setupReleaseVersion(FBUtilities.getReleaseVersionString());
1:     private String getOlderVersionString()
1:         String version = FBUtilities.getReleaseVersionString();
0:         SemanticVersion semver = new SemanticVersion(version.contains("-") ? version.substring(0, version.indexOf('-'))
1:                                                                            : version);
1:         return (String.format("%s.%s.%s", semver.major - 1, semver.minor, semver.patch));
/////////////////////////////////////////////////////////////////////////
1:     private void setupReleaseVersion(String version)
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(String.format("Expected %s, got %s", version, r), version, r);
commit:194bad2
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.UntypedResultSet;
0: import org.apache.cassandra.utils.SemanticVersion;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void snapshotSystemKeyspaceIfUpgrading() throws IOException
1:     {
1:         // First, check that in the absence of any previous installed version, we don't create snapshots
0:         for (ColumnFamilyStore cfs : Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStores())
1:             cfs.clearUnsafe();
0:         Keyspace.clearSnapshot(null, SystemKeyspace.NAME);
1: 
1:         SystemKeyspace.snapshotOnVersionChange();
0:         assertTrue(getSystemSnapshotFiles().isEmpty());
1: 
1:         // now setup system.local as if we're upgrading from a previous version
0:         SemanticVersion next = getCurrentReleaseVersion();
0:         setupReleaseVersion(new SemanticVersion(String.format("%s.%s.%s", next.major - 1, next.minor, next.patch)));
0:         Keyspace.clearSnapshot(null, SystemKeyspace.NAME);
0:         assertTrue(getSystemSnapshotFiles().isEmpty());
1: 
1:         // Compare versions again & verify that snapshots were created for all tables in the system ks
1:         SystemKeyspace.snapshotOnVersionChange();
0:         assertEquals(SystemKeyspace.definition().cfMetaData().size(), getSystemSnapshotFiles().size());
1: 
1:         // clear out the snapshots & set the previous recorded version equal to the latest, we shouldn't
1:         // see any new snapshots created this time.
0:         Keyspace.clearSnapshot(null, SystemKeyspace.NAME);
0:         setupReleaseVersion(getCurrentReleaseVersion());
1: 
1:         SystemKeyspace.snapshotOnVersionChange();
0:         assertTrue(getSystemSnapshotFiles().isEmpty());
1:     }
1: 
0:     private SemanticVersion getCurrentReleaseVersion()
1:     {
0:         return new SemanticVersion(FBUtilities.getReleaseVersionString());
1:     }
1: 
1:     private Set<String> getSystemSnapshotFiles()
1:     {
1:         Set<String> snapshottedTableNames = new HashSet<>();
0:         for (ColumnFamilyStore cfs : Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStores())
1:         {
1:             if (!cfs.getSnapshotDetails().isEmpty())
1:                 snapshottedTableNames.add(cfs.getColumnFamilyName());
1:         }
1:         return snapshottedTableNames;
1:     }
1: 
0:     private void setupReleaseVersion(SemanticVersion version)
1:     {
1:         // besides the release_version, we also need to insert the cluster_name or the check
1:         // in SystemKeyspace.checkHealth were we verify it matches DatabaseDescriptor will fail
1:         QueryProcessor.executeInternal(String.format("INSERT INTO system.local(key, release_version, cluster_name) " +
1:                                                      "VALUES ('local', '%s', '%s')",
1:                                                      version,
1:                                                      DatabaseDescriptor.getClusterName()));
1:         String r = readLocalVersion();
0:         assertEquals(String.format("Expected %s, got %s", version, r), version.toString(), r);
1:     }
1: 
1:     private String readLocalVersion()
1:     {
1:         UntypedResultSet rs = QueryProcessor.executeInternal("SELECT release_version FROM system.local WHERE key='local'");
1:         return rs.isEmpty() || !rs.one().has("release_version") ? null : rs.one().getString("release_version");
1:     }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.ByteOrderedPartitioner.BytesToken;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:aa90c88
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
commit:1adcd1c
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  * 
1:  */
1: 
commit:05d4222
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
1: 
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: 
0: import com.google.common.base.Charsets;
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.dht.BytesToken;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: public class SystemTableTest
1: {
1:     @Test
0:     public void testLocalToken()
1:     {
0:         SystemTable.updateToken(new BytesToken(ByteBufferUtil.bytes("token")));
0:         assert new String(((BytesToken) SystemTable.getSavedToken()).token, Charsets.UTF_8).equals("token");
1: 
0:         SystemTable.updateToken(new BytesToken(ByteBufferUtil.bytes("token2")));
0:         assert new String(((BytesToken) SystemTable.getSavedToken()).token, Charsets.UTF_8).equals("token2");
1:     }
1: 
1:     @Test
1:     public void testNonLocalToken() throws UnknownHostException
1:     {
1:         BytesToken token = new BytesToken(ByteBufferUtil.bytes("token3"));
1:         InetAddress address = InetAddress.getByName("127.0.0.2");
0:         SystemTable.updateToken(address, token);
0:         assert SystemTable.loadTokens().get(token).equals(address);
0:         SystemTable.removeToken(token);
0:         assert !SystemTable.loadTokens().containsKey(token);
1:     }
1: }
commit:1a29b2c
/////////////////////////////////////////////////////////////////////////
commit:e959b2c
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.updateToken(StorageService.getPartitioner().getToken("503545744:0"));
commit:eb886e9
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Assert;
1: 
0:     public void testOnlyOnceCreationOfStorageMetadata() throws IOException
0:         SystemTable.StorageMetadata storageMetadata1 = SystemTable.initMetadata();
0:         SystemTable.StorageMetadata storageMetadata2 = SystemTable.initMetadata();
0:         Assert.assertTrue("smd should not change after calling initMetadata twice", storageMetadata1 == storageMetadata2);
1:     }
1: 
1:     @Test
0:     public void testTokenGetsUpdated() throws IOException
1:     {
0:         SystemTable.StorageMetadata storageMetadata1 = SystemTable.initMetadata();
0:         SystemTable.StorageMetadata storageMetadata2 = SystemTable.initMetadata();
0:         Assert.assertTrue("smd should still be a singleton after updateToken", storageMetadata1 == storageMetadata2);
commit:81dd8ee
/////////////////////////////////////////////////////////////////////////
0:     public void testMain() throws IOException
0:     {
0:         SystemTable.initMetadata();
0:         SystemTable.updateToken(StorageService.getPartitioner().getInitialToken("503545744:0"));
commit:88edbed
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
commit:97fc5cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
0: 
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.service.StorageService;
0: 
0: public class SystemTableTest extends CleanupHelper
0: {
commit:bfb2e95
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken(StorageService.getPartitioner().getInitialToken("503545744:0"));
commit:ec7f04b
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken(StorageService.getPartitioner().getTokenForKey("503545744:0"));
commit:907d92e
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken( StorageService.token("503545744:0") );
commit:afd3c27
commit:7e648c8
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: 
0: import org.apache.cassandra.ServerTest;
0: import org.apache.cassandra.service.StorageService;
0: import org.testng.annotations.Test;
0: 
0: import java.io.IOException;
0: 
0: public class SystemTableTest extends ServerTest {
0:     @Test
0:     public void testMain() throws IOException {
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken( StorageService.hash("503545744:0") );
0:     }
0: }
commit:7a6f421
/////////////////////////////////////////////////////////////////////////
commit:dd61d51
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken( StorageService.token("503545744:0") );
commit:a996c82
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: 
0: import org.apache.cassandra.ServerTest;
0: import org.apache.cassandra.service.StorageService;
0: import org.testng.annotations.Test;
0: 
0: import java.io.IOException;
0: 
0: public class SystemTableTest extends ServerTest {
0:     @Test
0:     public void testMain() throws IOException {
0:         SystemTable.openSystemTable(SystemTable.cfName_).updateToken( StorageService.hash("503545744:0") );
0:     }
0: }
author:Brandon Williams
-------------------------------------------------------------------------------
commit:e6b6eaa
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.removeEndpoint(address);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:dcddfaf
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:         Collection<Token> current = SystemTable.loadTokens().asMap().get(FBUtilities.getLocalAddress());
1:         if (current != null && !current.isEmpty())
0:             SystemTable.updateTokens(current);
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
author:Eric Evans
-------------------------------------------------------------------------------
commit:66b96ee
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.List;
1: import org.apache.cassandra.dht.Token;
1:     public void testLocalTokens()
1:         // Remove all existing tokens
0:         SystemTable.updateTokens(Collections.<Token> emptySet());
1:         List<Token> tokens = new ArrayList<Token>()
1:         {{
1:             for (int i = 0; i < 9; i++)
1:                 add(new BytesToken(ByteBufferUtil.bytes(String.format("token%d", i))));
1:         }};
0: 
0:         SystemTable.updateTokens(tokens);
1:         int count = 0;
0: 
0:         for (Token tok : SystemTable.getSavedTokens())
1:             assert tokens.get(count++).equals(tok);
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.updateTokens(address, Collections.<Token>singletonList(token));
0:         assert SystemTable.loadTokens().get(address).contains(token);
0:         SystemTable.removeTokens(Collections.<Token>singletonList(token));
0:         assert !SystemTable.loadTokens().containsValue(token);
commit:712ffeb
/////////////////////////////////////////////////////////////////////////
0: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
1:     public void testLocalHostID()
0:     {
0:         UUID firstId = SystemTable.getLocalHostId();
0:         UUID secondId = SystemTable.getLocalHostId();
1:         assert firstId.equals(secondId) : String.format("%s != %s%n", firstId.toString(), secondId.toString());
0:     }
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
0:         SystemTable.updateToken(StorageService.getPartitioner().getToken("503545744:0".getBytes()));
============================================================================