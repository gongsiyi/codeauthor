1:60bf7a5: /*
1:60bf7a5:  * Licensed to the Apache Software Foundation (ASF) under one
1:60bf7a5:  * or more contributor license agreements.  See the NOTICE file
1:60bf7a5:  * distributed with this work for additional information
1:60bf7a5:  * regarding copyright ownership.  The ASF licenses this file
1:60bf7a5:  * to you under the Apache License, Version 2.0 (the
1:60bf7a5:  * "License"); you may not use this file except in compliance
1:60bf7a5:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:60bf7a5:  */
1:57b18e6: package org.apache.cassandra.io.sstable;
1:4937ac7: 
1:0ad499e: import java.nio.charset.CharacterCodingException;
1:4937ac7: import java.util.ArrayList;
1:4937ac7: import java.util.List;
1:4937ac7: import java.util.concurrent.ExecutionException;
1:d2a3827: 
1:d2a3827: import org.junit.BeforeClass;
1:4937ac7: import org.junit.Test;
1:4937ac7: 
1:4937ac7: import org.apache.cassandra.SchemaLoader;
1:4937ac7: import org.apache.cassandra.Util;
1:d2a3827: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.db.ColumnFamilyStore;
1:a991b64: import org.apache.cassandra.db.DecoratedKey;
1:0e96e58: import org.apache.cassandra.db.Keyspace;
1:a991b64: import org.apache.cassandra.db.RowUpdateBuilder;
1:a991b64: import org.apache.cassandra.db.marshal.AsciiType;
1:a991b64: import org.apache.cassandra.db.marshal.IntegerType;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:4937ac7: import org.apache.cassandra.utils.ByteBufferUtil;
1:4937ac7: 
1:a991b64: import static org.apache.cassandra.Util.getBytes;
1:4937ac7: import static org.junit.Assert.assertEquals;
1:4937ac7: import static org.junit.Assert.assertTrue;
1:57b18e6: 
1:d2a3827: public class SSTableMetadataTest
1:4937ac7: {
1:d2a3827:     public static final String KEYSPACE1 = "SSTableMetadataTest";
1:d2a3827:     public static final String CF_STANDARD = "Standard1";
1:d2a3827:     public static final String CF_STANDARD2 = "Standard2";
1:d2a3827:     public static final String CF_STANDARD3 = "Standard3";
1:d2a3827:     public static final String CF_STANDARDCOMPOSITE2 = "StandardComposite2";
1:d2a3827:     public static final String CF_COUNTER1 = "Counter1";
1:4937ac7: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws Exception
1:d2a3827:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD3),
1:a991b64:                                     CFMetaData.Builder.create(KEYSPACE1, CF_STANDARDCOMPOSITE2)
1:a991b64:                                                       .addPartitionKey("key", AsciiType.instance)
1:a991b64:                                                       .addClusteringColumn("name", AsciiType.instance)
1:a991b64:                                                       .addClusteringColumn("int", IntegerType.instance)
1:a991b64:                                                       .addRegularColumn("val", AsciiType.instance).build(),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF_COUNTER1));
1:d2a3827:     }
1:57b18e6: 
1:57b18e6:     @Test
1:9639f95:     public void testTrackMaxDeletionTime()
1:4937ac7:     {
1:d2a3827:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:0e96e58:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard1");
1:4937ac7:         long timestamp = System.currentTimeMillis();
1:4937ac7:         for(int i = 0; i < 10; i++)
1:4937ac7:         {
1:4937ac7:             DecoratedKey key = Util.dk(Integer.toString(i));
1:4937ac7:             for (int j = 0; j < 10; j++)
1:a991b64:                 new RowUpdateBuilder(store.metadata, timestamp, 10 + j, Integer.toString(i))
1:a991b64:                     .clustering(Integer.toString(j))
1:a991b64:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                     .build()
1:a991b64:                     .applyUnsafe();
1:57b18e6: 
1:4937ac7:         }
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(store.metadata, timestamp, 10000, "longttl")
1:a991b64:             .clustering("col")
1:a991b64:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:             .build()
1:a991b64:             .applyUnsafe();
1:a991b64: 
1:a991b64: 
1:4937ac7:         store.forceBlockingFlush();
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:4937ac7:         int ttltimestamp = (int)(System.currentTimeMillis()/1000);
1:4937ac7:         int firstDelTime = 0;
1:ad8cad7:         for(SSTableReader sstable : store.getLiveSSTables())
1:4937ac7:         {
1:4937ac7:             firstDelTime = sstable.getSSTableMetadata().maxLocalDeletionTime;
1:4937ac7:             assertEquals(ttltimestamp + 10000, firstDelTime, 10);
1:a991b64: 
1:4937ac7:         }
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(store.metadata, timestamp, 20000, "longttl2")
1:a991b64:         .clustering("col")
1:a991b64:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:         .build()
1:a991b64:         .applyUnsafe();
1:a991b64: 
1:a991b64: 
1:4937ac7:         ttltimestamp = (int) (System.currentTimeMillis()/1000);
1:4937ac7:         store.forceBlockingFlush();
1:ad8cad7:         assertEquals(2, store.getLiveSSTables().size());
1:ad8cad7:         List<SSTableReader> sstables = new ArrayList<>(store.getLiveSSTables());
1:4937ac7:         if(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime < sstables.get(1).getSSTableMetadata().maxLocalDeletionTime)
1:4937ac7:         {
1:4937ac7:             assertEquals(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime, firstDelTime);
1:4937ac7:             assertEquals(sstables.get(1).getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:4937ac7:         }
1:4937ac7:         else
1:4937ac7:         {
1:4937ac7:             assertEquals(sstables.get(1).getSSTableMetadata().maxLocalDeletionTime, firstDelTime);
1:4937ac7:             assertEquals(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:4937ac7:         }
1:4937ac7: 
1:ad8cad7:         Util.compact(store, store.getLiveSSTables());
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         for(SSTableReader sstable : store.getLiveSSTables())
1:4937ac7:         {
1:4937ac7:             assertEquals(sstable.getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:4937ac7:         }
1:4937ac7:     }
1:4937ac7: 
1:4937ac7:     /**
1:4937ac7:      * 1. create a row with columns with ttls, 5x100 and 1x1000
1:4937ac7:      * 2. flush, verify (maxLocalDeletionTime = time+1000)
1:4937ac7:      * 3. delete column with ttl=1000
1:4937ac7:      * 4. flush, verify the new sstable (maxLocalDeletionTime = ~now)
1:4937ac7:      * 5. compact
1:4937ac7:      * 6. verify resulting sstable has maxLocalDeletionTime = time + 100.
1:4937ac7:      *
1:4937ac7:      * @throws ExecutionException
1:4937ac7:      * @throws InterruptedException
1:4937ac7:      */
1:4937ac7:     @Test
1:4937ac7:     public void testWithDeletes() throws ExecutionException, InterruptedException
1:4937ac7:     {
1:d2a3827:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:0e96e58:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard2");
1:4937ac7:         long timestamp = System.currentTimeMillis();
1:4937ac7:         DecoratedKey key = Util.dk("deletetest");
1:4937ac7:         for (int i = 0; i<5; i++)
1:a991b64:             new RowUpdateBuilder(store.metadata, timestamp, 100, "deletetest")
1:a991b64:                 .clustering("deletecolumn" + i)
1:a991b64:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                 .build()
1:a991b64:                 .applyUnsafe();
1:a991b64: 
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(store.metadata, timestamp, 1000, "deletetest")
1:a991b64:         .clustering("todelete")
1:a991b64:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:         .build()
1:a991b64:         .applyUnsafe();
1:a991b64: 
1:4937ac7:         store.forceBlockingFlush();
1:ad8cad7:         assertEquals(1,store.getLiveSSTables().size());
1:4937ac7:         int ttltimestamp = (int) (System.currentTimeMillis()/1000);
1:4937ac7:         int firstMaxDelTime = 0;
1:ad8cad7:         for(SSTableReader sstable : store.getLiveSSTables())
1:4937ac7:         {
1:4937ac7:             firstMaxDelTime = sstable.getSSTableMetadata().maxLocalDeletionTime;
1:4937ac7:             assertEquals(ttltimestamp + 1000, firstMaxDelTime, 10);
1:4937ac7:         }
1:a991b64: 
1:a991b64:         RowUpdateBuilder.deleteRow(store.metadata, timestamp + 1, "deletetest", "todelete").applyUnsafe();
1:a991b64: 
1:4937ac7:         store.forceBlockingFlush();
1:ad8cad7:         assertEquals(2,store.getLiveSSTables().size());
1:4937ac7:         boolean foundDelete = false;
1:ad8cad7:         for(SSTableReader sstable : store.getLiveSSTables())
1:4937ac7:         {
1:4937ac7:             if(sstable.getSSTableMetadata().maxLocalDeletionTime != firstMaxDelTime)
1:4937ac7:             {
1:4937ac7:                 assertEquals(sstable.getSSTableMetadata().maxLocalDeletionTime, ttltimestamp, 10);
1:4937ac7:                 foundDelete = true;
1:4937ac7:             }
1:4937ac7:         }
1:4937ac7:         assertTrue(foundDelete);
1:ad8cad7:         Util.compact(store, store.getLiveSSTables());
1:ad8cad7:         assertEquals(1,store.getLiveSSTables().size());
1:ad8cad7:         for(SSTableReader sstable : store.getLiveSSTables())
1:4937ac7:         {
1:4937ac7:             assertEquals(ttltimestamp + 100, sstable.getSSTableMetadata().maxLocalDeletionTime, 10);
1:4937ac7:         }
1:4937ac7:     }
1:4937ac7: 
1:4937ac7:     @Test
1:0ad499e:     public void trackMaxMinColNames() throws CharacterCodingException, ExecutionException, InterruptedException
1:0ad499e:     {
1:d2a3827:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:0e96e58:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard3");
1:0ad499e:         for (int j = 0; j < 8; j++)
1:0ad499e:         {
1:a991b64:             String key = "row" + j;
1:0ad499e:             for (int i = 100; i<150; i++)
1:0ad499e:             {
1:a991b64:                 new RowUpdateBuilder(store.metadata, System.currentTimeMillis(), key)
1:a991b64:                     .clustering(j + "col" + i)
1:a991b64:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                     .build()
1:a991b64:                     .applyUnsafe();
1:4937ac7:             }
2:0ad499e:         }
1:0ad499e:         store.forceBlockingFlush();
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         for (SSTableReader sstable : store.getLiveSSTables())
1:0ad499e:         {
1:a991b64:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)), "0col100");
1:a991b64:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)), "7col149");
1:0ad499e:         }
1:a991b64:         String key = "row2";
1:a991b64: 
1:0ad499e:         for (int i = 101; i<299; i++)
1:0ad499e:         {
1:a991b64:             new RowUpdateBuilder(store.metadata, System.currentTimeMillis(), key)
1:a991b64:             .clustering(9 + "col" + i)
1:a991b64:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:             .build()
1:a991b64:             .applyUnsafe();
1:0ad499e:         }
1:d2a3827: 
1:0ad499e:         store.forceBlockingFlush();
1:0ad499e:         store.forceMajorCompaction();
1:ad8cad7:         assertEquals(1, store.getLiveSSTables().size());
1:ad8cad7:         for (SSTableReader sstable : store.getLiveSSTables())
1:0ad499e:         {
1:a991b64:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)), "0col100");
1:a991b64:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)), "9col298");
1:0ad499e:         }
1:0ad499e:     }
1:d2a3827: 
2:0ad499e:     @Test
1:0ad499e:     public void testMaxMinComposites() throws CharacterCodingException, ExecutionException, InterruptedException
1:0ad499e:     {
1:0ad499e:         /*
1:0ad499e:         creates two sstables, columns like this:
1:0ad499e:         ---------------------
1:0ad499e:         k   |a0:9|a1:8|..|a9:0
1:0ad499e:         ---------------------
1:0ad499e:         and
1:0ad499e:         ---------------------
1:0ad499e:         k2  |b0:9|b1:8|..|b9:0
1:0ad499e:         ---------------------
1:0ad499e:         meaning max columns are b9 and 9, min is a0 and 0
1:0ad499e:          */
1:d2a3827:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:60bf7a5: 
1:0e96e58:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("StandardComposite2");
4:0ad499e: 
1:0ad499e:         for (int i = 0; i < 10; i++)
1:0ad499e:         {
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 0, "k")
1:a991b64:                 .clustering("a" + (9 - i), getBytes(i))
1:a991b64:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:                 .build()
1:a991b64:                 .applyUnsafe();
1:a991b64: 
1:0ad499e:         }
1:0ad499e:         cfs.forceBlockingFlush();
1:0ad499e: 
1:0ad499e:         for (int i = 0; i < 10; i++)
1:0ad499e:         {
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 0, "k2")
1:a991b64:             .clustering("b" + (9 - i), getBytes(i))
1:a991b64:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:a991b64:             .build()
1:a991b64:             .applyUnsafe();
1:0ad499e:         }
1:0ad499e:         cfs.forceBlockingFlush();
1:0ad499e:         cfs.forceMajorCompaction();
1:ad8cad7:         assertEquals(cfs.getLiveSSTables().size(), 1);
1:ad8cad7:         for (SSTableReader sstable : cfs.getLiveSSTables())
1:0ad499e:         {
1:a991b64:             assertEquals("b9", ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)));
1:a991b64:             assertEquals(9, ByteBufferUtil.toInt(sstable.getSSTableMetadata().maxClusteringValues.get(1)));
1:a991b64:             assertEquals("a0", ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)));
1:a991b64:             assertEquals(0, ByteBufferUtil.toInt(sstable.getSSTableMetadata().minClusteringValues.get(1)));
1:0ad499e:         }
1:0ad499e:     }
1:0ad499e: 
1:a991b64:     /*@Test
1:57b18e6:     public void testLegacyCounterShardTracking()
1:57b18e6:     {
1:d2a3827:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore("Counter1");
1:57b18e6: 
1:57b18e6:         // A cell with all shards
1:57b18e6:         CounterContext.ContextState state = CounterContext.ContextState.allocate(1, 1, 1);
1:57b18e6:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:57b18e6:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:57b18e6:         state.writeRemote(CounterId.fromInt(3), 1L, 1L);
1:a991b64: 
1:57b18e6:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
1:8541cca:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
1:b453f08:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
1:57b18e6:         cfs.forceBlockingFlush();
1:ad8cad7:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:57b18e6:         cfs.truncateBlocking();
1:57b18e6: 
1:57b18e6:         // A cell with global and remote shards
1:57b18e6:         state = CounterContext.ContextState.allocate(0, 1, 1);
1:57b18e6:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:57b18e6:         state.writeRemote(CounterId.fromInt(3), 1L, 1L);
1:57b18e6:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
1:8541cca:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
1:b453f08:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
1:57b18e6:         cfs.forceBlockingFlush();
1:ad8cad7:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:57b18e6:         cfs.truncateBlocking();
1:57b18e6: 
1:57b18e6:         // A cell with global and local shards
1:57b18e6:         state = CounterContext.ContextState.allocate(1, 1, 0);
1:57b18e6:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:57b18e6:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:57b18e6:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
1:8541cca:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
1:b453f08:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
1:57b18e6:         cfs.forceBlockingFlush();
1:ad8cad7:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:57b18e6:         cfs.truncateBlocking();
1:57b18e6: 
1:57b18e6:         // A cell with global only
1:57b18e6:         state = CounterContext.ContextState.allocate(1, 0, 0);
1:57b18e6:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:57b18e6:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
1:8541cca:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
1:b453f08:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
1:57b18e6:         cfs.forceBlockingFlush();
1:ad8cad7:         assertFalse(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:57b18e6:         cfs.truncateBlocking();
1:a991b64:     } */
1:57b18e6: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         for(SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, store.getLiveSSTables().size());
1:         List<SSTableReader> sstables = new ArrayList<>(store.getLiveSSTables());
/////////////////////////////////////////////////////////////////////////
1:         Util.compact(store, store.getLiveSSTables());
1:         assertEquals(1, store.getLiveSSTables().size());
1:         for(SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1,store.getLiveSSTables().size());
1:         for(SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2,store.getLiveSSTables().size());
1:         for(SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         Util.compact(store, store.getLiveSSTables());
1:         assertEquals(1,store.getLiveSSTables().size());
1:         for(SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         for (SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, store.getLiveSSTables().size());
1:         for (SSTableReader sstable : store.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(cfs.getLiveSSTables().size(), 1);
1:         for (SSTableReader sstable : cfs.getLiveSSTables())
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
/////////////////////////////////////////////////////////////////////////
1:         assertFalse(cfs.getLiveSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:57b18e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.io.sstable;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.context.CounterContext;
0: import org.apache.cassandra.utils.CounterId;
0: import static org.junit.Assert.assertFalse;
0: import static org.apache.cassandra.Util.cellname;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("Standard1", cellname(Integer.toString(j)),
0:         rm.add("Standard1", cellname("col"),
/////////////////////////////////////////////////////////////////////////
0:         rm.add("Standard1", cellname("col"),
/////////////////////////////////////////////////////////////////////////
0:         List<SSTableReader> sstables = new ArrayList<>(store.getSSTables());
/////////////////////////////////////////////////////////////////////////
0:             rm.add("Standard2", cellname("deletecolumn" + i),
0:         rm.add("Standard2", cellname("todelete"),
/////////////////////////////////////////////////////////////////////////
0:         rm.delete("Standard2", cellname("todelete"), timestamp + 1);
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("Standard3", cellname(j + "col" + i), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             rm.add("Standard3", cellname(9 + "col" + i), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testLegacyCounterShardTracking()
1:     {
0:         ColumnFamilyStore cfs = Keyspace.open("Keyspace1").getColumnFamilyStore("Counter1");
1: 
1:         // A cell with all shards
1:         CounterContext.ContextState state = CounterContext.ContextState.allocate(1, 1, 1);
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:         state.writeRemote(CounterId.fromInt(3), 1L, 1L);
1:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells.addColumn(new CounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").key, cells).apply();
1:         cfs.forceBlockingFlush();
0:         assertTrue(cfs.getSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:         cfs.truncateBlocking();
1: 
1:         // A cell with global and remote shards
1:         state = CounterContext.ContextState.allocate(0, 1, 1);
1:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:         state.writeRemote(CounterId.fromInt(3), 1L, 1L);
1:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells.addColumn(new CounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").key, cells).apply();
1:         cfs.forceBlockingFlush();
0:         assertTrue(cfs.getSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:         cfs.truncateBlocking();
1: 
1:         // A cell with global and local shards
1:         state = CounterContext.ContextState.allocate(1, 1, 0);
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         state.writeLocal(CounterId.fromInt(2), 1L, 1L);
1:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells.addColumn(new CounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").key, cells).apply();
1:         cfs.forceBlockingFlush();
0:         assertTrue(cfs.getSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:         cfs.truncateBlocking();
1: 
1:         // A cell with global only
1:         state = CounterContext.ContextState.allocate(1, 0, 0);
1:         state.writeGlobal(CounterId.fromInt(1), 1L, 1L);
1:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells.addColumn(new CounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").key, cells).apply();
1:         cfs.forceBlockingFlush();
0:         assertFalse(cfs.getSSTables().iterator().next().getSSTableMetadata().hasLegacyCounterShards);
1:         cfs.truncateBlocking();
1:     }
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", Util.dk("longttl").key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", Util.dk("longttl2").key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard2");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
1:         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard3");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("StandardComposite2");
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.ClusteringComparator;
1: import org.apache.cassandra.db.ColumnFamilyStore;
1: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.Keyspace;
0: import org.apache.cassandra.db.Mutation;
1: import org.apache.cassandra.db.RowUpdateBuilder;
0: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.AsciiType;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
1: import org.apache.cassandra.db.marshal.IntegerType;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
1: import static org.apache.cassandra.Util.getBytes;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     CFMetaData.Builder.create(KEYSPACE1, CF_STANDARDCOMPOSITE2)
1:                                                       .addPartitionKey("key", AsciiType.instance)
1:                                                       .addClusteringColumn("name", AsciiType.instance)
1:                                                       .addClusteringColumn("int", IntegerType.instance)
1:                                                       .addRegularColumn("val", AsciiType.instance).build(),
1:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF_COUNTER1));
/////////////////////////////////////////////////////////////////////////
1:                 new RowUpdateBuilder(store.metadata, timestamp, 10 + j, Integer.toString(i))
1:                     .clustering(Integer.toString(j))
1:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                     .build()
1:                     .applyUnsafe();
1: 
1: 
1:         new RowUpdateBuilder(store.metadata, timestamp, 10000, "longttl")
1:             .clustering("col")
1:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:             .build()
1:             .applyUnsafe();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         new RowUpdateBuilder(store.metadata, timestamp, 20000, "longttl2")
1:         .clustering("col")
1:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:         .build()
1:         .applyUnsafe();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             new RowUpdateBuilder(store.metadata, timestamp, 100, "deletetest")
1:                 .clustering("deletecolumn" + i)
1:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                 .build()
1:                 .applyUnsafe();
1: 
1: 
1:         new RowUpdateBuilder(store.metadata, timestamp, 1000, "deletetest")
1:         .clustering("todelete")
1:         .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:         .build()
1:         .applyUnsafe();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         RowUpdateBuilder.deleteRow(store.metadata, timestamp + 1, "deletetest", "todelete").applyUnsafe();
1: 
/////////////////////////////////////////////////////////////////////////
1:             String key = "row" + j;
1:                 new RowUpdateBuilder(store.metadata, System.currentTimeMillis(), key)
1:                     .clustering(j + "col" + i)
1:                     .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                     .build()
1:                     .applyUnsafe();
1:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)), "0col100");
1:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)), "7col149");
1:         String key = "row2";
1: 
1:             new RowUpdateBuilder(store.metadata, System.currentTimeMillis(), key)
1:             .clustering(9 + "col" + i)
1:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:             .build()
1:             .applyUnsafe();
1:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)), "0col100");
1:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)), "9col298");
/////////////////////////////////////////////////////////////////////////
1:             new RowUpdateBuilder(cfs.metadata, 0, "k")
1:                 .clustering("a" + (9 - i), getBytes(i))
1:                 .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:                 .build()
1:                 .applyUnsafe();
1: 
1:             new RowUpdateBuilder(cfs.metadata, 0, "k2")
1:             .clustering("b" + (9 - i), getBytes(i))
1:             .add("val", ByteBufferUtil.EMPTY_BYTE_BUFFER)
1:             .build()
1:             .applyUnsafe();
1:             assertEquals("b9", ByteBufferUtil.string(sstable.getSSTableMetadata().maxClusteringValues.get(0)));
1:             assertEquals(9, ByteBufferUtil.toInt(sstable.getSSTableMetadata().maxClusteringValues.get(1)));
1:             assertEquals("a0", ByteBufferUtil.string(sstable.getSSTableMetadata().minClusteringValues.get(0)));
1:             assertEquals(0, ByteBufferUtil.toInt(sstable.getSSTableMetadata().minClusteringValues.get(1)));
1:     /*@Test
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     } */
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.composites.*;
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("Standard1", Util.cellname(Integer.toString(j)),
0:         rm.add("Standard1", Util.cellname("col"),
/////////////////////////////////////////////////////////////////////////
0:         rm.add("Standard1", Util.cellname("col"),
/////////////////////////////////////////////////////////////////////////
0:             rm.add("Standard2", Util.cellname("deletecolumn"+i),
0:         rm.add("Standard2", Util.cellname("todelete"),
/////////////////////////////////////////////////////////////////////////
0:         rm.delete("Standard2", Util.cellname("todelete"), timestamp + 1);
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("Standard3", Util.cellname(j+"col"+i), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             rm.add("Standard3", Util.cellname(9+"col"+i), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         CellNameType type = cfs.getComparator();
0:             CellName colName = type.makeCellName(ByteBufferUtil.bytes("a"+(9-i)), ByteBufferUtil.bytes(i));
/////////////////////////////////////////////////////////////////////////
0:             CellName colName = type.makeCellName(ByteBufferUtil.bytes("b"+(9-i)), ByteBufferUtil.bytes(i));
commit:4937ac7
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.io.sstable;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.concurrent.ExecutionException;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.RowMutation;
0: import org.apache.cassandra.db.Table;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
0: public class SSTableMetadataTest extends SchemaLoader
1: {
1:     @Test
0:     public void testTrackMaxDeletionTime() throws ExecutionException, InterruptedException
1:     {
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
1:         long timestamp = System.currentTimeMillis();
1:         for(int i = 0; i < 10; i++)
1:         {
1:             DecoratedKey key = Util.dk(Integer.toString(i));
0:             RowMutation rm = new RowMutation("Keyspace1", key.key);
1:             for (int j = 0; j < 10; j++)
0:                 rm.add("Standard1", ByteBufferUtil.bytes(Integer.toString(j)),
0:                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                        timestamp,
0:                        10 + j);
0:             rm.apply();
1:         }
0:         RowMutation rm = new RowMutation("Keyspace1", Util.dk("longttl").key);
0:         rm.add("Standard1", ByteBufferUtil.bytes("col"),
0:                ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                timestamp,
0:                10000);
0:         rm.apply();
1:         store.forceBlockingFlush();
0:         assertEquals(1, store.getSSTables().size());
1:         int ttltimestamp = (int)(System.currentTimeMillis()/1000);
1:         int firstDelTime = 0;
0:         for(SSTableReader sstable : store.getSSTables())
1:         {
1:             firstDelTime = sstable.getSSTableMetadata().maxLocalDeletionTime;
1:             assertEquals(ttltimestamp + 10000, firstDelTime, 10);
1: 
1:         }
0:         rm = new RowMutation("Keyspace1", Util.dk("longttl2").key);
0:         rm.add("Standard1", ByteBufferUtil.bytes("col"),
0:                ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                timestamp,
0:                20000);
0:         rm.apply();
1:         ttltimestamp = (int) (System.currentTimeMillis()/1000);
1:         store.forceBlockingFlush();
0:         assertEquals(2, store.getSSTables().size());
0:         List<SSTableReader> sstables = new ArrayList<SSTableReader>(store.getSSTables());
1:         if(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime < sstables.get(1).getSSTableMetadata().maxLocalDeletionTime)
1:         {
1:             assertEquals(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime, firstDelTime);
1:             assertEquals(sstables.get(1).getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:         }
1:         else
1:         {
1:             assertEquals(sstables.get(1).getSSTableMetadata().maxLocalDeletionTime, firstDelTime);
1:             assertEquals(sstables.get(0).getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:         }
1: 
0:         Util.compact(store, store.getSSTables());
0:         assertEquals(1, store.getSSTables().size());
0:         for(SSTableReader sstable : store.getSSTables())
1:         {
1:             assertEquals(sstable.getSSTableMetadata().maxLocalDeletionTime, ttltimestamp + 20000, 10);
1:         }
1:     }
1: 
1:     /**
1:      * 1. create a row with columns with ttls, 5x100 and 1x1000
1:      * 2. flush, verify (maxLocalDeletionTime = time+1000)
1:      * 3. delete column with ttl=1000
1:      * 4. flush, verify the new sstable (maxLocalDeletionTime = ~now)
1:      * 5. compact
1:      * 6. verify resulting sstable has maxLocalDeletionTime = time + 100.
1:      *
1:      * @throws ExecutionException
1:      * @throws InterruptedException
1:      */
1:     @Test
1:     public void testWithDeletes() throws ExecutionException, InterruptedException
1:     {
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore store = table.getColumnFamilyStore("Standard2");
1:         long timestamp = System.currentTimeMillis();
1:         DecoratedKey key = Util.dk("deletetest");
0:         RowMutation rm = new RowMutation("Keyspace1", key.key);
1:         for (int i = 0; i<5; i++)
0:             rm.add("Standard2", ByteBufferUtil.bytes("deletecolumn"+i),
0:                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                        timestamp,
0:                        100);
0:         rm.add("Standard2", ByteBufferUtil.bytes("todelete"),
0:                    ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                    timestamp,
0:                    1000);
0:         rm.apply();
1:         store.forceBlockingFlush();
0:         assertEquals(1,store.getSSTables().size());
1:         int ttltimestamp = (int) (System.currentTimeMillis()/1000);
1:         int firstMaxDelTime = 0;
0:         for(SSTableReader sstable : store.getSSTables())
1:         {
1:             firstMaxDelTime = sstable.getSSTableMetadata().maxLocalDeletionTime;
1:             assertEquals(ttltimestamp + 1000, firstMaxDelTime, 10);
1:         }
0:         rm = new RowMutation("Keyspace1", key.key);
0:         rm.delete("Standard2", ByteBufferUtil.bytes("todelete"), timestamp + 1);
0:         rm.apply();
1:         store.forceBlockingFlush();
0:         assertEquals(2,store.getSSTables().size());
1:         boolean foundDelete = false;
0:         for(SSTableReader sstable : store.getSSTables())
1:         {
1:             if(sstable.getSSTableMetadata().maxLocalDeletionTime != firstMaxDelTime)
1:             {
1:                 assertEquals(sstable.getSSTableMetadata().maxLocalDeletionTime, ttltimestamp, 10);
1:                 foundDelete = true;
1:             }
1:         }
1:         assertTrue(foundDelete);
0:         Util.compact(store, store.getSSTables());
0:         assertEquals(1,store.getSSTables().size());
0:         for(SSTableReader sstable : store.getSSTables())
1:         {
1:             assertEquals(ttltimestamp + 100, sstable.getSSTableMetadata().maxLocalDeletionTime, 10);
1:         }
1:     }
1: }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:7df3a5c
/////////////////////////////////////////////////////////////////////////
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5de72e5
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARDCOMPOSITE2, compositeMaxMin),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_COUNTER1).defaultValidator(CounterColumnType.instance));
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
/////////////////////////////////////////////////////////////////////////
1:         new Mutation(Util.dk("k").getKey(), cells).applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
1: 
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.marshal.*;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
1: public class SSTableMetadataTest
1:     public static final String KEYSPACE1 = "SSTableMetadataTest";
1:     public static final String CF_STANDARD = "Standard1";
1:     public static final String CF_STANDARD2 = "Standard2";
1:     public static final String CF_STANDARD3 = "Standard3";
1:     public static final String CF_STANDARDCOMPOSITE2 = "StandardComposite2";
1:     public static final String CF_COUNTER1 = "Counter1";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws Exception
1:     {
0:         AbstractType<?> compositeMaxMin = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance, IntegerType.instance}));
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD3),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_STANDARDCOMPOSITE2, compositeMaxMin),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_COUNTER1, BytesType.instance).defaultValidator(CounterColumnType.instance));
1:     }
1: 
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:             Mutation rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE1, Util.dk("longttl").getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE1, Util.dk("longttl2").getKey());
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         Mutation rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:             Mutation rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE1, key.getKey());
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation(KEYSPACE1, key);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation(KEYSPACE1, key);
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore("Counter1");
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", Util.dk("longttl").getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", Util.dk("longttl2").getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
1:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").getKey(), cells).apply();
/////////////////////////////////////////////////////////////////////////
1:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").getKey(), cells).apply();
/////////////////////////////////////////////////////////////////////////
1:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").getKey(), cells).apply();
/////////////////////////////////////////////////////////////////////////
1:         cells.addColumn(new BufferCounterCell(cellname("col"), state.context, 1L, Long.MIN_VALUE));
0:         new Mutation(Util.dk("k").getKey(), cells).apply();
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
1:     public void testTrackMaxDeletionTime()
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:60bf7a5
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
1:  */
1: 
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
1: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.IntegerType;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void trackMaxMinColNames() throws CharacterCodingException, ExecutionException, InterruptedException
1:     {
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore store = table.getColumnFamilyStore("Standard3");
0:         store.getCompactionStrategy();
1:         for (int j = 0; j < 8; j++)
1:         {
0:             DecoratedKey key = Util.dk("row"+j);
0:             RowMutation rm = new RowMutation("Keyspace1", key.key);
1:             for (int i = 100; i<150; i++)
1:             {
0:                 rm.add("Standard3", ByteBufferUtil.bytes(j+"col"+i),
0:                    ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                    System.currentTimeMillis());
1:             }
0:             rm.apply();
1:         }
1:         store.forceBlockingFlush();
0:         assertEquals(1, store.getSSTables().size());
0:         for (SSTableReader sstable : store.getSSTables())
1:         {
0:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minColumnNames.get(0)), "0col100");
0:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxColumnNames.get(0)), "7col149");
1:         }
0:         DecoratedKey key = Util.dk("row2");
0:         RowMutation rm = new RowMutation("Keyspace1", key.key);
1:         for (int i = 101; i<299; i++)
1:         {
0:             rm.add("Standard3", ByteBufferUtil.bytes(9+"col"+i),
0:                ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                System.currentTimeMillis());
1:         }
0:         rm.apply();
1: 
1:         store.forceBlockingFlush();
1:         store.forceMajorCompaction();
0:         assertEquals(1, store.getSSTables().size());
0:         for (SSTableReader sstable : store.getSSTables())
1:         {
0:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().minColumnNames.get(0)), "0col100");
0:             assertEquals(ByteBufferUtil.string(sstable.getSSTableMetadata().maxColumnNames.get(0)), "9col298");
1:         }
1:     }
1:     @Test
1:     public void testMaxMinComposites() throws CharacterCodingException, ExecutionException, InterruptedException
1:     {
1:         /*
1:         creates two sstables, columns like this:
1:         ---------------------
1:         k   |a0:9|a1:8|..|a9:0
1:         ---------------------
1:         and
1:         ---------------------
1:         k2  |b0:9|b1:8|..|b9:0
1:         ---------------------
1:         meaning max columns are b9 and 9, min is a0 and 0
1:          */
0:         Table table = Table.open("Keyspace1");
1: 
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore("StandardComposite2");
1: 
0:         CompositeType ct = CompositeType.getInstance(BytesType.instance, IntegerType.instance);
1: 
0:         ByteBuffer key = ByteBufferUtil.bytes("k");
1:         for (int i = 0; i < 10; i++)
1:         {
0:             RowMutation rm = new RowMutation("Keyspace1", key);
0:             ByteBuffer colName = ct.builder().add(ByteBufferUtil.bytes("a"+(9-i))).add(ByteBufferUtil.bytes(i)).build();
0:             rm.add("StandardComposite2", colName, ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
0:             rm.apply();
1:         }
1:         cfs.forceBlockingFlush();
1: 
0:         key = ByteBufferUtil.bytes("k2");
1:         for (int i = 0; i < 10; i++)
1:         {
0:             RowMutation rm = new RowMutation("Keyspace1", key);
0:             ByteBuffer colName = ct.builder().add(ByteBufferUtil.bytes("b"+(9-i))).add(ByteBufferUtil.bytes(i)).build();
0:             rm.add("StandardComposite2", colName, ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
0:             rm.apply();
1:         }
1:         cfs.forceBlockingFlush();
1:         cfs.forceMajorCompaction();
0:         assertEquals(cfs.getSSTables().size(), 1);
0:         for (SSTableReader sstable : cfs.getSSTables())
1:         {
0:             assertEquals("b9", ByteBufferUtil.string(sstable.getSSTableMetadata().maxColumnNames.get(0)));
0:             assertEquals(9, ByteBufferUtil.toInt(sstable.getSSTableMetadata().maxColumnNames.get(1)));
0:             assertEquals("a0", ByteBufferUtil.string(sstable.getSSTableMetadata().minColumnNames.get(0)));
0:             assertEquals(0, ByteBufferUtil.toInt(sstable.getSSTableMetadata().minColumnNames.get(1)));
1:         }
1:     }
============================================================================