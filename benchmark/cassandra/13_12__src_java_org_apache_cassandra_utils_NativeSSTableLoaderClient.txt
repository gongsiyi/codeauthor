1:f698cc2: /*
1:f698cc2:  * Licensed to the Apache Software Foundation (ASF) under one
1:f698cc2:  * or more contributor license agreements.  See the NOTICE file
1:f698cc2:  * distributed with this work for additional information
1:f698cc2:  * regarding copyright ownership.  The ASF licenses this file
1:f698cc2:  * to you under the Apache License, Version 2.0 (the
1:f698cc2:  * "License"); you may not use this file except in compliance
1:f698cc2:  * with the License.  You may obtain a copy of the License at
1:f698cc2:  *
1:f698cc2:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f698cc2:  *
1:f698cc2:  * Unless required by applicable law or agreed to in writing, software
1:f698cc2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f698cc2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f698cc2:  * See the License for the specific language governing permissions and
1:f698cc2:  * limitations under the License.
1:f698cc2:  */
1:f698cc2: package org.apache.cassandra.utils;
16:f698cc2: 
1:f698cc2: import java.net.InetAddress;
1:f698cc2: import java.util.*;
1:f698cc2: 
1:f698cc2: import com.datastax.driver.core.*;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:4db577a: import org.apache.cassandra.config.ColumnDefinition.ClusteringOrder;
1:f698cc2: import org.apache.cassandra.config.CFMetaData;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:a991b64: import org.apache.cassandra.cql3.ColumnIdentifier;
1:a991b64: import org.apache.cassandra.db.marshal.*;
1:f698cc2: import org.apache.cassandra.dht.*;
1:f698cc2: import org.apache.cassandra.dht.Token;
1:0a08525: import org.apache.cassandra.dht.Token.TokenFactory;
1:f698cc2: import org.apache.cassandra.io.sstable.SSTableLoader;
1:454f32d: import org.apache.cassandra.schema.CQLTypeParser;
1:7d6c876: import org.apache.cassandra.schema.SchemaKeyspace;
1:454f32d: import org.apache.cassandra.schema.Types;
1:f698cc2: 
1:f698cc2: public class NativeSSTableLoaderClient extends SSTableLoader.Client
1:f698cc2: {
1:f698cc2:     protected final Map<String, CFMetaData> tables;
1:f698cc2:     private final Collection<InetAddress> hosts;
1:f698cc2:     private final int port;
1:fa18880:     private final AuthProvider authProvider;
1:f698cc2:     private final SSLOptions sslOptions;
1:fa18880: 
1:a991b64: 
1:f698cc2:     public NativeSSTableLoaderClient(Collection<InetAddress> hosts, int port, String username, String password, SSLOptions sslOptions)
1:f698cc2:     {
1:fa18880:         this(hosts, port, new PlainTextAuthProvider(username, password), sslOptions);
1:fa18880:     }
1:fa18880: 
1:fa18880:     public NativeSSTableLoaderClient(Collection<InetAddress> hosts, int port, AuthProvider authProvider, SSLOptions sslOptions)
1:fa18880:     {
1:f698cc2:         super();
1:f698cc2:         this.tables = new HashMap<>();
1:f698cc2:         this.hosts = hosts;
1:f698cc2:         this.port = port;
1:fa18880:         this.authProvider = authProvider;
1:f698cc2:         this.sslOptions = sslOptions;
1:f698cc2:     }
1:a991b64: 
1:f698cc2:     public void init(String keyspace)
1:f698cc2:     {
1:f698cc2:         Cluster.Builder builder = Cluster.builder().addContactPoints(hosts).withPort(port);
1:f698cc2:         if (sslOptions != null)
1:f698cc2:             builder.withSSL(sslOptions);
1:fa18880:         if (authProvider != null)
1:fa18880:             builder = builder.withAuthProvider(authProvider);
1:a991b64: 
1:7aafe05:         try (Cluster cluster = builder.build(); Session session = cluster.connect())
1:f698cc2:         {
1:7aafe05: 
1:f698cc2:             Metadata metadata = cluster.getMetadata();
1:a22ce89: 
1:f698cc2:             Set<TokenRange> tokenRanges = metadata.getTokenRanges();
1:a991b64: 
1:6aa7d6c:             IPartitioner partitioner = FBUtilities.newPartitioner(metadata.getPartitioner());
1:6aa7d6c:             TokenFactory tokenFactory = partitioner.getTokenFactory();
1:a991b64: 
1:f698cc2:             for (TokenRange tokenRange : tokenRanges)
1:f698cc2:             {
1:ed96322:                 Set<Host> endpoints = metadata.getReplicas(Metadata.quote(keyspace), tokenRange);
1:f698cc2:                 Range<Token> range = new Range<>(tokenFactory.fromString(tokenRange.getStart().getValue().toString()),
1:f698cc2:                                                  tokenFactory.fromString(tokenRange.getEnd().getValue().toString()));
1:f698cc2:                 for (Host endpoint : endpoints)
1:f698cc2:                     addRangeForEndpoint(range, endpoint.getAddress());
1:f698cc2:             }
1:a991b64: 
1:454f32d:             Types types = fetchTypes(keyspace, session);
1:454f32d: 
1:454f32d:             tables.putAll(fetchTables(keyspace, session, partitioner, types));
1:a3a8dbc:             // We only need the CFMetaData for the views, so we only load that.
1:454f32d:             tables.putAll(fetchViews(keyspace, session, partitioner, types));
1:f698cc2:         }
1:f698cc2:     }
1:a991b64: 
1:f698cc2:     public CFMetaData getTableMetadata(String tableName)
1:f698cc2:     {
1:f698cc2:         return tables.get(tableName);
1:f698cc2:     }
1:a991b64: 
1:f698cc2:     @Override
1:f698cc2:     public void setTableMetadata(CFMetaData cfm)
1:f698cc2:     {
1:f698cc2:         tables.put(cfm.cfName, cfm);
1:f698cc2:     }
1:a991b64: 
1:454f32d:     private static Types fetchTypes(String keyspace, Session session)
1:454f32d:     {
1:9797511:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TYPES);
1:454f32d: 
1:454f32d:         Types.RawBuilder types = Types.rawBuilder(keyspace);
1:454f32d:         for (Row row : session.execute(query, keyspace))
1:454f32d:         {
1:454f32d:             String name = row.getString("type_name");
1:454f32d:             List<String> fieldNames = row.getList("field_names", String.class);
1:454f32d:             List<String> fieldTypes = row.getList("field_types", String.class);
1:454f32d:             types.add(name, fieldNames, fieldTypes);
1:454f32d:         }
1:454f32d:         return types.build();
1:454f32d:     }
1:454f32d: 
1:dc85238:     /*
1:dc85238:      * The following is a slightly simplified but otherwise duplicated version of
1:dc85238:      * SchemaKeyspace.createTableFromTableRowAndColumnRows().
1:dc85238:      * It might be safer to have a simple wrapper of the driver ResultSet/Row implementing
1:dc85238:      * UntypedResultSet/UntypedResultSet.Row and reuse the original method.
1:6aa7d6c:      *
1:6aa7d6c:      * Note: It is not safe for this class to use static methods from SchemaKeyspace (static final fields are ok)
1:6aa7d6c:      * as that triggers initialization of the class, which fails in client mode.
1:dc85238:      */
1:454f32d:     private static Map<String, CFMetaData> fetchTables(String keyspace, Session session, IPartitioner partitioner, Types types)
1:f698cc2:     {
1:f698cc2:         Map<String, CFMetaData> tables = new HashMap<>();
1:9797511:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES);
1:a3a8dbc: 
1:dc85238:         for (Row row : session.execute(query, keyspace))
1:f698cc2:         {
1:7d6c876:             String name = row.getString("table_name");
1:454f32d:             tables.put(name, createTableMetadata(keyspace, session, partitioner, false, row, name, types));
1:f698cc2:         }
1:a3a8dbc: 
1:f698cc2:         return tables;
1:f698cc2:     }
1:dc85238: 
1:a3a8dbc:     /*
1:a3a8dbc:      * In the case where we are creating View CFMetaDatas, we
1:a3a8dbc:      */
1:454f32d:     private static Map<String, CFMetaData> fetchViews(String keyspace, Session session, IPartitioner partitioner, Types types)
1:a3a8dbc:     {
1:a3a8dbc:         Map<String, CFMetaData> tables = new HashMap<>();
1:9797511:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.VIEWS);
1:a3a8dbc: 
1:a3a8dbc:         for (Row row : session.execute(query, keyspace))
1:a3a8dbc:         {
1:a3a8dbc:             String name = row.getString("view_name");
1:454f32d:             tables.put(name, createTableMetadata(keyspace, session, partitioner, true, row, name, types));
1:a3a8dbc:         }
1:a3a8dbc: 
1:a3a8dbc:         return tables;
1:a3a8dbc:     }
1:a3a8dbc: 
1:454f32d:     private static CFMetaData createTableMetadata(String keyspace,
1:454f32d:                                                   Session session,
1:454f32d:                                                   IPartitioner partitioner,
1:454f32d:                                                   boolean isView,
1:454f32d:                                                   Row row,
1:454f32d:                                                   String name,
1:454f32d:                                                   Types types)
1:a3a8dbc:     {
1:dc85238:         UUID id = row.getUUID("id");
1:19bccb4:         Set<CFMetaData.Flag> flags = isView ? Collections.emptySet() : CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
1:a3a8dbc: 
1:dc85238:         boolean isSuper = flags.contains(CFMetaData.Flag.SUPER);
1:dc85238:         boolean isCounter = flags.contains(CFMetaData.Flag.COUNTER);
1:dc85238:         boolean isDense = flags.contains(CFMetaData.Flag.DENSE);
1:19bccb4:         boolean isCompound = isView || flags.contains(CFMetaData.Flag.COMPOUND);
1:dc85238: 
1:dc85238:         String columnsQuery = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?",
1:9797511:                                             SchemaConstants.SCHEMA_KEYSPACE_NAME,
1:dc85238:                                             SchemaKeyspace.COLUMNS);
1:a3a8dbc: 
1:a3a8dbc:         List<ColumnDefinition> defs = new ArrayList<>();
1:dc85238:         for (Row colRow : session.execute(columnsQuery, keyspace, name))
1:454f32d:             defs.add(createDefinitionFromRow(colRow, keyspace, name, types));
1:a3a8dbc: 
1:a3a8dbc:         return CFMetaData.create(keyspace,
1:0a08525:                                  name,
1:0a08525:                                  id,
1:0a08525:                                  isDense,
1:0a08525:                                  isCompound,
1:0a08525:                                  isSuper,
1:0a08525:                                  isCounter,
1:a3a8dbc:                                  isView,
1:0a08525:                                  defs,
1:a3a8dbc:                                  partitioner);
1:a3a8dbc:     }
1:454f32d: 
1:454f32d:     private static ColumnDefinition createDefinitionFromRow(Row row, String keyspace, String table, Types types)
1:a991b64:     {
1:454f32d:         ClusteringOrder order = ClusteringOrder.valueOf(row.getString("clustering_order").toUpperCase());
1:454f32d:         AbstractType<?> type = CQLTypeParser.parse(keyspace, row.getString("type"), types);
1:454f32d:         if (order == ClusteringOrder.DESC)
1:454f32d:             type = ReversedType.getInstance(type);
1:454f32d: 
1:4bc3aa9:         ColumnIdentifier name = ColumnIdentifier.getInterned(type,
1:4bc3aa9:                                                              row.getBytes("column_name_bytes"),
1:4bc3aa9:                                                              row.getString("column_name"));
1:4bc3aa9: 
1:0790e48:         int position = row.getInt("position");
1:0790e48:         ColumnDefinition.Kind kind = ColumnDefinition.Kind.valueOf(row.getString("kind").toUpperCase());
1:0790e48:         return new ColumnDefinition(keyspace, table, name, type, position, kind);
1:a991b64:     }
1:f698cc2: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:1050544
commit:4bc3aa9
/////////////////////////////////////////////////////////////////////////
1:         ColumnIdentifier name = ColumnIdentifier.getInterned(type,
1:                                                              row.getBytes("column_name_bytes"),
1:                                                              row.getString("column_name"));
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TYPES);
/////////////////////////////////////////////////////////////////////////
1:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES);
/////////////////////////////////////////////////////////////////////////
1:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.VIEWS);
/////////////////////////////////////////////////////////////////////////
1:                                             SchemaConstants.SCHEMA_KEYSPACE_NAME,
author:Sergey Kirillov
-------------------------------------------------------------------------------
commit:19bccb4
/////////////////////////////////////////////////////////////////////////
1:         Set<CFMetaData.Flag> flags = isView ? Collections.emptySet() : CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
1:         boolean isCompound = isView || flags.contains(CFMetaData.Flag.COMPOUND);
author:Mike Adamson
-------------------------------------------------------------------------------
commit:fa18880
/////////////////////////////////////////////////////////////////////////
1:     private final AuthProvider authProvider;
1: 
1:         this(hosts, port, new PlainTextAuthProvider(username, password), sslOptions);
1:     }
1: 
1:     public NativeSSTableLoaderClient(Collection<InetAddress> hosts, int port, AuthProvider authProvider, SSLOptions sslOptions)
1:     {
1:         this.authProvider = authProvider;
/////////////////////////////////////////////////////////////////////////
1:         if (authProvider != null)
1:             builder = builder.withAuthProvider(authProvider);
author:Alex Liu
-------------------------------------------------------------------------------
commit:ed96322
/////////////////////////////////////////////////////////////////////////
1:                 Set<Host> endpoints = metadata.getReplicas(Metadata.quote(keyspace), tokenRange);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:4db577a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ColumnDefinition.ClusteringOrder;
commit:454f32d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.CQLTypeParser;
1: import org.apache.cassandra.schema.Types;
/////////////////////////////////////////////////////////////////////////
1:             Types types = fetchTypes(keyspace, session);
1: 
1:             tables.putAll(fetchTables(keyspace, session, partitioner, types));
1:             tables.putAll(fetchViews(keyspace, session, partitioner, types));
/////////////////////////////////////////////////////////////////////////
1:     private static Types fetchTypes(String keyspace, Session session)
1:     {
0:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaKeyspace.NAME, SchemaKeyspace.TYPES);
1: 
1:         Types.RawBuilder types = Types.rawBuilder(keyspace);
1:         for (Row row : session.execute(query, keyspace))
1:         {
1:             String name = row.getString("type_name");
1:             List<String> fieldNames = row.getList("field_names", String.class);
1:             List<String> fieldTypes = row.getList("field_types", String.class);
1:             types.add(name, fieldNames, fieldTypes);
1:         }
1:         return types.build();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static Map<String, CFMetaData> fetchTables(String keyspace, Session session, IPartitioner partitioner, Types types)
/////////////////////////////////////////////////////////////////////////
1:             tables.put(name, createTableMetadata(keyspace, session, partitioner, false, row, name, types));
/////////////////////////////////////////////////////////////////////////
1:     private static Map<String, CFMetaData> fetchViews(String keyspace, Session session, IPartitioner partitioner, Types types)
/////////////////////////////////////////////////////////////////////////
1:             tables.put(name, createTableMetadata(keyspace, session, partitioner, true, row, name, types));
1:     private static CFMetaData createTableMetadata(String keyspace,
1:                                                   Session session,
1:                                                   IPartitioner partitioner,
1:                                                   boolean isView,
1:                                                   Row row,
1:                                                   String name,
1:                                                   Types types)
0:         Set<CFMetaData.Flag> flags = CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
/////////////////////////////////////////////////////////////////////////
1:             defs.add(createDefinitionFromRow(colRow, keyspace, name, types));
/////////////////////////////////////////////////////////////////////////
1:     private static ColumnDefinition createDefinitionFromRow(Row row, String keyspace, String table, Types types)
1: 
1:         ClusteringOrder order = ClusteringOrder.valueOf(row.getString("clustering_order").toUpperCase());
1:         AbstractType<?> type = CQLTypeParser.parse(keyspace, row.getString("type"), types);
1:         if (order == ClusteringOrder.DESC)
1:             type = ReversedType.getInstance(type);
1: 
commit:0790e48
/////////////////////////////////////////////////////////////////////////
0:         AbstractType<?> type = TypeParser.parse(row.getString("type"));
1:         int position = row.getInt("position");
1:         ColumnDefinition.Kind kind = ColumnDefinition.Kind.valueOf(row.getString("kind").toUpperCase());
1:         return new ColumnDefinition(keyspace, table, name, type, position, kind);
commit:b31845c
/////////////////////////////////////////////////////////////////////////
0:             boolean isMaterializedView = flags.contains(CFMetaData.Flag.VIEW);
commit:0a08525
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.dht.Token.TokenFactory;
/////////////////////////////////////////////////////////////////////////
0:             TokenFactory tokenFactory = FBUtilities.newPartitioner(metadata.getPartitioner()).getTokenFactory();
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace,
1:                                                name,
1:                                                id,
1:                                                isDense,
1:                                                isCompound,
1:                                                isSuper,
1:                                                isCounter,
0:                                                isMaterializedView,
1:                                                defs,
0:                                                DatabaseDescriptor.getPartitioner()));
commit:dc85238
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * The following is a slightly simplified but otherwise duplicated version of
1:      * SchemaKeyspace.createTableFromTableRowAndColumnRows().
1:      * It might be safer to have a simple wrapper of the driver ResultSet/Row implementing
1:      * UntypedResultSet/UntypedResultSet.Row and reuse the original method.
1:      */
0:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaKeyspace.NAME, SchemaKeyspace.TABLES);
1:         for (Row row : session.execute(query, keyspace))
1:             UUID id = row.getUUID("id");
0:             Set<CFMetaData.Flag> flags = row.isNull("flags")
0:                                        ? Collections.emptySet()
0:                                        : SchemaKeyspace.flagsFromStrings(row.getSet("flags", String.class));
1:             boolean isSuper = flags.contains(CFMetaData.Flag.SUPER);
1:             boolean isCounter = flags.contains(CFMetaData.Flag.COUNTER);
1:             boolean isDense = flags.contains(CFMetaData.Flag.DENSE);
0:             boolean isCompound = flags.contains(CFMetaData.Flag.COMPOUND);
1: 
1:             String columnsQuery = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?",
1:                                                 SchemaKeyspace.COLUMNS);
1:             for (Row colRow : session.execute(columnsQuery, keyspace, name))
0:                 defs.add(createDefinitionFromRow(colRow, keyspace, name));
/////////////////////////////////////////////////////////////////////////
0:     private static ColumnDefinition createDefinitionFromRow(Row row, String keyspace, String table)
0:         ColumnIdentifier name = ColumnIdentifier.getInterned(row.getBytes("column_name_bytes"), row.getString("column_name"));
1: 
0:         ColumnDefinition.Kind kind = ColumnDefinition.Kind.valueOf(row.getString("type").toUpperCase());
commit:7d6c876
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.SchemaKeyspace;
/////////////////////////////////////////////////////////////////////////
0:         String query = String.format("SELECT table_name, cf_id, type, comparator, subcomparator, is_dense, default_validator FROM %s.%s WHERE keyspace_name = '%s'",
0:                                      SchemaKeyspace.NAME,
0:                                      SchemaKeyspace.TABLES,
/////////////////////////////////////////////////////////////////////////
1:             String name = row.getString("table_name");
/////////////////////////////////////////////////////////////////////////
0:             String columnsQuery = String.format("SELECT column_name, component_index, type, validator FROM %s.%s WHERE keyspace_name='%s' AND table_name='%s'",
0:                                                 SchemaKeyspace.NAME,
0:                                                 SchemaKeyspace.COLUMNS,
/////////////////////////////////////////////////////////////////////////
0:         ColumnDefinition.Kind kind = SchemaKeyspace.deserializeKind(row.getString("type"));
commit:907fe62
/////////////////////////////////////////////////////////////////////////
0:         String query = String.format("SELECT columnfamily_name, cf_id, type, comparator, subcomparator, is_dense FROM %s.%s WHERE keyspace_name = '%s'",
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:a3a8dbc
/////////////////////////////////////////////////////////////////////////
1:             // We only need the CFMetaData for the views, so we only load that.
0:             tables.putAll(fetchViewMetadata(keyspace, session, partitioner));
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, createTableMetadata(keyspace, session, partitioner, false, row, name));
1:     /*
1:      * In the case where we are creating View CFMetaDatas, we
1:      */
0:     private static Map<String, CFMetaData> fetchViewMetadata(String keyspace, Session session, IPartitioner partitioner)
1:     {
1:         Map<String, CFMetaData> tables = new HashMap<>();
0:         String query = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ?", SchemaKeyspace.NAME, SchemaKeyspace.VIEWS);
1: 
1:         for (Row row : session.execute(query, keyspace))
1:         {
1:             String name = row.getString("view_name");
0:             tables.put(name, createTableMetadata(keyspace, session, partitioner, true, row, name));
1:         }
1: 
1:         return tables;
1:     }
1: 
0:     private static CFMetaData createTableMetadata(String keyspace, Session session, IPartitioner partitioner, boolean isView, Row row, String name)
1:     {
0:         UUID id = row.getUUID("id");
0:         Set<CFMetaData.Flag> flags = row.isNull("flags")
0:                                      ? Collections.emptySet()
0:                                      : CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
1: 
0:         boolean isSuper = flags.contains(CFMetaData.Flag.SUPER);
0:         boolean isCounter = flags.contains(CFMetaData.Flag.COUNTER);
0:         boolean isDense = flags.contains(CFMetaData.Flag.DENSE);
0:         boolean isCompound = flags.contains(CFMetaData.Flag.COMPOUND);
1: 
0:         String columnsQuery = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?",
0:                                             SchemaKeyspace.NAME,
0:                                             SchemaKeyspace.COLUMNS);
1: 
1:         List<ColumnDefinition> defs = new ArrayList<>();
0:         for (Row colRow : session.execute(columnsQuery, keyspace, name))
0:             defs.add(createDefinitionFromRow(colRow, keyspace, name));
1: 
1:         return CFMetaData.create(keyspace,
0:                                  name,
0:                                  id,
0:                                  isDense,
0:                                  isCompound,
0:                                  isSuper,
0:                                  isCounter,
1:                                  isView,
0:                                  defs,
1:                                  partitioner);
1:     }
1: 
commit:3bdcaa3
/////////////////////////////////////////////////////////////////////////
0:             boolean isMaterializedView = flags.contains(CFMetaData.Flag.MATERIALIZEDVIEW);
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace, name, id, isDense, isCompound, isSuper, isCounter, isMaterializedView, defs));
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:06c130e
/////////////////////////////////////////////////////////////////////////
0:         return new ColumnDefinition(keyspace, table, name, validator, componentIndex, kind);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:6aa7d6c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             IPartitioner partitioner = FBUtilities.newPartitioner(metadata.getPartitioner());
1:             TokenFactory tokenFactory = partitioner.getTokenFactory();
/////////////////////////////////////////////////////////////////////////
0:             tables.putAll(fetchTablesMetadata(keyspace, session, partitioner));
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * Note: It is not safe for this class to use static methods from SchemaKeyspace (static final fields are ok)
1:      * as that triggers initialization of the class, which fails in client mode.
0:     private static Map<String, CFMetaData> fetchTablesMetadata(String keyspace, Session session, IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
0:                                        : CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
/////////////////////////////////////////////////////////////////////////
0:                                                partitioner));
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.Token.TokenFactory;
/////////////////////////////////////////////////////////////////////////
0:             TokenFactory tokenFactory = FBUtilities.newPartitioner(metadata.getPartitioner()).getTokenFactory();
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace,
0:                                                name,
0:                                                id,
0:                                                isDense,
0:                                                isCompound,
0:                                                isSuper,
0:                                                isCounter,
0:                                                isMaterializedView,
0:                                                defs,
0:                                                DatabaseDescriptor.getPartitioner()));
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             setPartitioner(metadata.getPartitioner());
1: 
0:             Token.TokenFactory tokenFactory = getPartitioner().getTokenFactory();
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace, name, id, isDense, isCompound, isSuper, isCounter, isMaterializedView, defs));
commit:24d185d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace, name, id, isDense, isCompound, isSuper, isCounter, defs));
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:3c43775
/////////////////////////////////////////////////////////////////////////
0:             boolean isMaterializedView = flags.contains(CFMetaData.Flag.MATERIALIZEDVIEW);
/////////////////////////////////////////////////////////////////////////
0:             tables.put(name, CFMetaData.create(keyspace, name, id, isDense, isCompound, isSuper, isCounter, isMaterializedView, defs));
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
1:         try (Cluster cluster = builder.build(); Session session = cluster.connect())
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
0: import org.apache.cassandra.db.CompactTables;
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
0:         String query = String.format("SELECT columnfamily_name, cf_id, type, comparator, subcomparator, is_dense, default_validator FROM %s.%s WHERE keyspace_name = '%s'",
1: 
0:         // The following is a slightly simplified but otherwise duplicated version of LegacySchemaTables.createTableFromTableRowAndColumnRows. It might
0:         // be safer to have a simple wrapper of the driver ResultSet/Row implementing UntypedResultSet/UntypedResultSet.Row and reuse the original method.
0:             boolean isSuper = row.getString("type").toLowerCase().equals("super");
0:             boolean isCompound = rawComparator instanceof CompositeType;
0:             AbstractType<?> defaultValidator = TypeParser.parse(row.getString("default_validator"));
0:             boolean isCounter =  defaultValidator instanceof CounterColumnType;
0:             boolean isCQLTable = !isSuper && !isDense && isCompound;
1: 
0:             String columnsQuery = String.format("SELECT column_name, component_index, type, validator FROM %s.%s WHERE keyspace_name='%s' AND columnfamily_name='%s'",
0:                                                 SystemKeyspace.NAME,
0:                                                 LegacySchemaTables.COLUMNS,
0:                                                 keyspace,
0:                                                 name);
1: 
0:             List<ColumnDefinition> defs = new ArrayList<>();
0:             for (Row colRow : session.execute(columnsQuery))
0:                 defs.add(createDefinitionFromRow(colRow, keyspace, name, rawComparator, subComparator, isSuper, isCQLTable));
1: 
0:             tables.put(name, CFMetaData.create(keyspace, name, id, isDense, isCompound, isSuper, isCounter, defs));
1: 
0:     // A slightly simplified version of LegacySchemaTables.
0:     private static ColumnDefinition createDefinitionFromRow(Row row,
0:                                                             String keyspace,
0:                                                             String table,
0:                                                             AbstractType<?> rawComparator,
0:                                                             AbstractType<?> rawSubComparator,
0:                                                             boolean isSuper,
0:                                                             boolean isCQLTable)
1:     {
0:         ColumnDefinition.Kind kind = LegacySchemaTables.deserializeKind(row.getString("type"));
1: 
0:         Integer componentIndex = null;
0:         if (!row.isNull("component_index"))
0:             componentIndex = row.getInt("component_index");
1: 
0:         // Note: we save the column name as string, but we should not assume that it is an UTF8 name, we
0:         // we need to use the comparator fromString method
0:         AbstractType<?> comparator = isCQLTable
0:                                    ? UTF8Type.instance
0:                                    : CompactTables.columnDefinitionComparator(kind, isSuper, rawComparator, rawSubComparator);
0:         ColumnIdentifier name = ColumnIdentifier.getInterned(comparator.fromString(row.getString("column_name")), comparator);
1: 
0:         AbstractType<?> validator = TypeParser.parse(row.getString("validator"));
1: 
0:         return new ColumnDefinition(keyspace, table, name, validator, null, null, null, componentIndex, kind);
1:     }
author:Philip Thompson
-------------------------------------------------------------------------------
commit:f698cc2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.utils;
1: 
1: import java.net.InetAddress;
1: import java.util.*;
1: 
1: import com.datastax.driver.core.*;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.ColumnFamilyType;
0: import org.apache.cassandra.db.SystemKeyspace;
0: import org.apache.cassandra.db.composites.CellNameType;
0: import org.apache.cassandra.db.composites.CellNames;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.TypeParser;
1: import org.apache.cassandra.dht.*;
1: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.io.sstable.SSTableLoader;
0: import org.apache.cassandra.schema.LegacySchemaTables;
1: 
1: public class NativeSSTableLoaderClient extends SSTableLoader.Client
1: {
1:     protected final Map<String, CFMetaData> tables;
1:     private final Collection<InetAddress> hosts;
1:     private final int port;
0:     private final String username;
0:     private final String password;
1:     private final SSLOptions sslOptions;
1: 
1:     public NativeSSTableLoaderClient(Collection<InetAddress> hosts, int port, String username, String password, SSLOptions sslOptions)
1:     {
1:         super();
1:         this.tables = new HashMap<>();
1:         this.hosts = hosts;
1:         this.port = port;
0:         this.username = username;
0:         this.password = password;
1:         this.sslOptions = sslOptions;
1:     }
1: 
1:     public void init(String keyspace)
1:     {
1:         Cluster.Builder builder = Cluster.builder().addContactPoints(hosts).withPort(port);
1:         if (sslOptions != null)
1:             builder.withSSL(sslOptions);
0:         if (username != null && password != null)
0:             builder = builder.withCredentials(username, password);
1: 
0:         try (Cluster cluster = builder.build())
1:         {
0:             Session session = cluster.connect();
1:             Metadata metadata = cluster.getMetadata();
1: 
0:             setPartitioner(metadata.getPartitioner());
1: 
1:             Set<TokenRange> tokenRanges = metadata.getTokenRanges();
1: 
0:             Token.TokenFactory tokenFactory = getPartitioner().getTokenFactory();
1: 
1:             for (TokenRange tokenRange : tokenRanges)
1:             {
0:                 Set<Host> endpoints = metadata.getReplicas(keyspace, tokenRange);
1:                 Range<Token> range = new Range<>(tokenFactory.fromString(tokenRange.getStart().getValue().toString()),
1:                                                  tokenFactory.fromString(tokenRange.getEnd().getValue().toString()));
1:                 for (Host endpoint : endpoints)
1:                     addRangeForEndpoint(range, endpoint.getAddress());
1:             }
1: 
0:             tables.putAll(fetchTablesMetadata(keyspace, session));
1:         }
1:     }
1: 
1:     public CFMetaData getTableMetadata(String tableName)
1:     {
1:         return tables.get(tableName);
1:     }
1: 
1:     @Override
1:     public void setTableMetadata(CFMetaData cfm)
1:     {
1:         tables.put(cfm.cfName, cfm);
1:     }
1: 
0:     private static Map<String, CFMetaData> fetchTablesMetadata(String keyspace, Session session)
1:     {
1:         Map<String, CFMetaData> tables = new HashMap<>();
1: 
0:         String query = String.format("SELECT columnfamily_name, cf_id, type, comparator, subcomparator FROM %s.%s WHERE keyspace_name = '%s'",
0:                                      SystemKeyspace.NAME,
0:                                      LegacySchemaTables.COLUMNFAMILIES,
0:                                      keyspace);
1: 
0:         for (Row row : session.execute(query))
1:         {
0:             String name = row.getString("columnfamily_name");
0:             UUID id = row.getUUID("cf_id");
0:             ColumnFamilyType type = ColumnFamilyType.valueOf(row.getString("type"));
0:             AbstractType rawComparator = TypeParser.parse(row.getString("comparator"));
0:             AbstractType subComparator = row.isNull("subcomparator")
0:                                        ? null
0:                                        : TypeParser.parse(row.getString("subcomparator"));
0:             boolean isDense = row.getBool("is_dense");
0:             CellNameType comparator = CellNames.fromAbstractType(CFMetaData.makeRawAbstractType(rawComparator, subComparator),
0:                                                                  isDense);
1: 
0:             tables.put(name, new CFMetaData(keyspace, name, type, comparator, id));
1:         }
1: 
1:         return tables;
1:     }
1: }
============================================================================