1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
3:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:a991b64: package org.apache.cassandra.db;
13:a991b64: 
1:a991b64: import java.io.IOException;
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.util.*;
1:a991b64: 
1:a991b64: import com.google.common.collect.Iterators;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:a991b64: import org.apache.cassandra.db.marshal.AbstractType;
1:2457599: import org.apache.cassandra.io.util.DataInputPlus;
1:a991b64: import org.apache.cassandra.io.util.DataOutputPlus;
1:a991b64: 
1:a991b64: /**
1:a991b64:  * Represents the selection of multiple range of rows within a partition.
1:a991b64:  * <p>
1:a991b64:  * A {@code Slices} is basically a list of {@code Slice}, though those are guaranteed to be non-overlapping
1:a991b64:  * and always in clustering order.
1:a991b64:  */
1:a991b64: public abstract class Slices implements Iterable<Slice>
11:a991b64: {
1:a991b64:     public static final Serializer serializer = new Serializer();
1:a991b64: 
1:a991b64:     /** Slices selecting all the rows of a partition. */
1:a991b64:     public static final Slices ALL = new SelectAllSlices();
1:a991b64:     /** Slices selecting no rows in a partition. */
1:a991b64:     public static final Slices NONE = new SelectNoSlices();
1:a991b64: 
1:a991b64:     protected Slices()
1:a991b64:     {
10:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Creates a {@code Slices} object that contains a single slice.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator for the table {@code slice} is a slice of.
1:a991b64:      * @param slice the single slice that the return object should contains.
1:a991b64:      *
1:a991b64:      * @return the newly created {@code Slices} object.
1:a991b64:      */
1:a991b64:     public static Slices with(ClusteringComparator comparator, Slice slice)
1:a991b64:     {
1:2cc26eb:         if (slice.start() == ClusteringBound.BOTTOM && slice.end() == ClusteringBound.TOP)
1:a991b64:             return Slices.ALL;
1:a991b64: 
1:a991b64:         assert comparator.compare(slice.start(), slice.end()) <= 0;
1:a991b64:         return new ArrayBackedSlices(comparator, new Slice[]{ slice });
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether the slices has a lower bound, that is whether it's first slice start is {@code Slice.BOTTOM}.
1:a991b64:      *
1:a991b64:      * @return whether the slices has a lower bound.
1:a991b64:      */
1:a991b64:     public abstract boolean hasLowerBound();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether the slices has an upper bound, that is whether it's last slice end is {@code Slice.TOP}.
1:a991b64:      *
1:a991b64:      * @return whether the slices has an upper bound.
1:a991b64:      */
1:a991b64:     public abstract boolean hasUpperBound();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The number of slice this object contains.
1:a991b64:      *
1:a991b64:      * @return the number of slice this object contains.
1:a991b64:      */
1:a991b64:     public abstract int size();
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the ith slice of this {@code Slices} object.
1:a991b64:      *
1:a991b64:      * @return the ith slice of this object.
1:a991b64:      */
1:a991b64:     public abstract Slice get(int i);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns slices for continuing the paging of those slices given the last returned clustering prefix.
1:a991b64:      *
1:a991b64:      * @param comparator the comparator for the table this is a filter for.
1:a991b64:      * @param lastReturned the last clustering that was returned for the query we are paging for. The
1:a991b64:      * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
1:a991b64:      * (where coming after means "greater than" if {@code !reversed} and "lesser than" otherwise).
1:a991b64:      * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
1:a991b64:      * @param reversed whether the query we're paging for is reversed or not.
1:a991b64:      *
1:a991b64:      * @return new slices that select results coming after {@code lastReturned}.
1:a991b64:      */
1:a991b64:     public abstract Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * An object that allows to test whether rows are selected by this {@code Slices} objects assuming those rows
1:a991b64:      * are tested in clustering order.
1:a991b64:      *
1:a991b64:      * @param reversed if true, the rows passed to the returned object will be assumed to be in reversed clustering
1:a991b64:      * order, otherwise they should be in clustering order.
1:a991b64:      *
1:a991b64:      * @return an object that tests for selection of rows by this {@code Slices} object.
1:a991b64:      */
1:a991b64:     public abstract InOrderTester inOrderTester(boolean reversed);
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether a given clustering (row) is selected by this {@code Slices} object.
1:a991b64:      *
1:a991b64:      * @param clustering the clustering to test for selection.
1:a991b64:      *
1:a991b64:      * @return whether a given clustering (row) is selected by this {@code Slices} object.
1:a991b64:      */
1:a991b64:     public abstract boolean selects(Clustering clustering);
1:a991b64: 
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Given the per-clustering column minimum and maximum value a sstable contains, whether or not this slices potentially
1:a991b64:      * intersects that sstable or not.
1:a991b64:      *
1:a991b64:      * @param minClusteringValues the smallest values for each clustering column that a sstable contains.
1:a991b64:      * @param maxClusteringValues the biggest values for each clustering column that a sstable contains.
1:a991b64:      *
1:a991b64:      * @return whether the slices might intersects with the sstable having {@code minClusteringValues} and
1:a991b64:      * {@code maxClusteringValues}.
1:a991b64:      */
1:a991b64:     public abstract boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues);
1:a991b64: 
1:a991b64:     public abstract String toCQLString(CFMetaData metadata);
1:a991b64: 
1:a991b64:     /**
1:2e3727e:      * Checks if this <code>Slices</code> is empty.
1:2e3727e:      * @return <code>true</code> if this <code>Slices</code> is empty, <code>false</code> otherwise.
1:a991b64:      */
1:2e3727e:     public final boolean isEmpty()
1:a991b64:     {
1:2e3727e:         return size() == 0;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * In simple object that allows to test the inclusion of rows in those slices assuming those rows
1:a991b64:      * are passed (to {@link #includes}) in clustering order (or reverse clustering ordered, depending
1:a991b64:      * of the argument passed to {@link #inOrderTester}).
1:a991b64:      */
1:a991b64:     public interface InOrderTester
1:a991b64:     {
1:a991b64:         public boolean includes(Clustering value);
1:a991b64:         public boolean isDone();
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Builder to create {@code Slices} objects.
1:a991b64:      */
1:a991b64:     public static class Builder
1:a991b64:     {
1:a991b64:         private final ClusteringComparator comparator;
1:a991b64: 
1:a991b64:         private final List<Slice> slices;
1:a991b64: 
1:a991b64:         private boolean needsNormalizing;
1:a991b64: 
1:a991b64:         public Builder(ClusteringComparator comparator)
1:a991b64:         {
1:a991b64:             this.comparator = comparator;
1:a991b64:             this.slices = new ArrayList<>();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Builder(ClusteringComparator comparator, int initialSize)
1:a991b64:         {
1:a991b64:             this.comparator = comparator;
1:a991b64:             this.slices = new ArrayList<>(initialSize);
1:a991b64:         }
1:a991b64: 
1:2cc26eb:         public Builder add(ClusteringBound start, ClusteringBound end)
1:a991b64:         {
1:a991b64:             return add(Slice.make(start, end));
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Builder add(Slice slice)
1:a991b64:         {
1:a991b64:             assert comparator.compare(slice.start(), slice.end()) <= 0;
1:a991b64:             if (slices.size() > 0 && comparator.compare(slices.get(slices.size()-1).end(), slice.start()) > 0)
1:a991b64:                 needsNormalizing = true;
1:a991b64:             slices.add(slice);
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:86ba227:         public Builder addAll(Slices slices)
1:86ba227:         {
1:86ba227:             for (Slice slice : slices)
1:86ba227:                 add(slice);
1:86ba227:             return this;
1:86ba227:         }
1:86ba227: 
1:a991b64:         public int size()
1:a991b64:         {
1:a991b64:             return slices.size();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slices build()
1:a991b64:         {
1:a991b64:             if (slices.isEmpty())
1:a991b64:                 return NONE;
1:a991b64: 
1:a991b64:             if (slices.size() == 1 && slices.get(0) == Slice.ALL)
1:a991b64:                 return ALL;
1:a991b64: 
1:a991b64:             List<Slice> normalized = needsNormalizing
1:a991b64:                                    ? normalize(slices)
1:a991b64:                                    : slices;
1:a991b64: 
1:a991b64:             return new ArrayBackedSlices(comparator, normalized.toArray(new Slice[normalized.size()]));
1:a991b64:         }
1:a991b64: 
1:a991b64:         /**
1:a991b64:          * Given an array of slices (potentially overlapping and in any order) and return an equivalent array
1:a991b64:          * of non-overlapping slices in clustering order.
1:a991b64:          *
1:a991b64:          * @param slices an array of slices. This may be modified by this method.
1:a991b64:          * @return the smallest possible array of non-overlapping slices in clustering order. If the original
1:a991b64:          * slices are already non-overlapping and in comparator order, this may or may not return the provided slices
1:a991b64:          * directly.
1:a991b64:          */
1:a991b64:         private List<Slice> normalize(List<Slice> slices)
1:a991b64:         {
1:a991b64:             if (slices.size() <= 1)
1:a991b64:                 return slices;
1:a991b64: 
1:a991b64:             Collections.sort(slices, new Comparator<Slice>()
1:a991b64:             {
3:a991b64:                 @Override
1:a991b64:                 public int compare(Slice s1, Slice s2)
1:a991b64:                 {
1:a991b64:                     int c = comparator.compare(s1.start(), s2.start());
1:a991b64:                     if (c != 0)
1:a991b64:                         return c;
1:a991b64: 
1:a991b64:                     return comparator.compare(s1.end(), s2.end());
1:a991b64:                 }
1:a991b64:             });
1:a991b64: 
1:a991b64:             List<Slice> slicesCopy = new ArrayList<>(slices.size());
1:a991b64: 
1:a991b64:             Slice last = slices.get(0);
1:a991b64: 
1:a991b64:             for (int i = 1; i < slices.size(); i++)
1:a991b64:             {
1:a991b64:                 Slice s2 = slices.get(i);
1:a991b64: 
1:a991b64:                 boolean includesStart = last.includes(comparator, s2.start());
1:a991b64:                 boolean includesFinish = last.includes(comparator, s2.end());
1:a991b64: 
1:a991b64:                 if (includesStart && includesFinish)
1:a991b64:                     continue;
1:a991b64: 
1:a991b64:                 if (!includesStart && !includesFinish)
1:a991b64:                 {
1:a991b64:                     slicesCopy.add(last);
1:a991b64:                     last = s2;
1:a991b64:                     continue;
1:a991b64:                 }
1:a991b64: 
1:a991b64:                 if (includesStart)
1:a991b64:                 {
1:a991b64:                     last = Slice.make(last.start(), s2.end());
1:a991b64:                     continue;
1:a991b64:                 }
1:a991b64: 
1:a991b64:                 assert !includesFinish;
1:a991b64:             }
1:a991b64: 
1:a991b64:             slicesCopy.add(last);
1:a991b64:             return slicesCopy;
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static class Serializer
1:a991b64:     {
1:a991b64:         public void serialize(Slices slices, DataOutputPlus out, int version) throws IOException
1:a991b64:         {
1:a991b64:             int size = slices.size();
1:649a106:             out.writeUnsignedVInt(size);
1:a991b64: 
1:a991b64:             if (size == 0)
4:a991b64:                 return;
1:a991b64: 
1:a991b64:             List<AbstractType<?>> types = slices == ALL
1:a991b64:                                         ? Collections.<AbstractType<?>>emptyList()
1:a991b64:                                         : ((ArrayBackedSlices)slices).comparator.subtypes();
1:a991b64: 
1:a991b64:             for (Slice slice : slices)
1:a991b64:                 Slice.serializer.serialize(slice, out, version, types);
1:a991b64:         }
1:a991b64: 
1:03f72ac:         public long serializedSize(Slices slices, int version)
1:a991b64:         {
1:649a106:             long size = TypeSizes.sizeofUnsignedVInt(slices.size());
1:a991b64: 
1:a991b64:             if (slices.size() == 0)
1:a991b64:                 return size;
1:a991b64: 
1:a991b64:             List<AbstractType<?>> types = slices instanceof SelectAllSlices
1:a991b64:                                         ? Collections.<AbstractType<?>>emptyList()
1:a991b64:                                         : ((ArrayBackedSlices)slices).comparator.subtypes();
1:a991b64: 
1:a991b64:             for (Slice slice : slices)
1:03f72ac:                 size += Slice.serializer.serializedSize(slice, version, types);
1:a991b64: 
1:a991b64:             return size;
1:a991b64:         }
1:a991b64: 
1:2457599:         public Slices deserialize(DataInputPlus in, int version, CFMetaData metadata) throws IOException
1:a991b64:         {
1:649a106:             int size = (int)in.readUnsignedVInt();
1:a991b64: 
1:a991b64:             if (size == 0)
1:a991b64:                 return NONE;
1:a991b64: 
1:a991b64:             Slice[] slices = new Slice[size];
1:a991b64:             for (int i = 0; i < size; i++)
1:a991b64:                 slices[i] = Slice.serializer.deserialize(in, version, metadata.comparator.subtypes());
1:a991b64: 
1:2cc26eb:             if (size == 1 && slices[0].start() == ClusteringBound.BOTTOM && slices[0].end() == ClusteringBound.TOP)
1:a991b64:                 return ALL;
1:a991b64: 
1:a991b64:             return new ArrayBackedSlices(metadata.comparator, slices);
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Simple {@code Slices} implementation that stores its slices in an array.
1:a991b64:      */
1:a991b64:     private static class ArrayBackedSlices extends Slices
1:a991b64:     {
1:a991b64:         private final ClusteringComparator comparator;
1:a991b64: 
1:a991b64:         private final Slice[] slices;
1:a991b64: 
1:a991b64:         private ArrayBackedSlices(ClusteringComparator comparator, Slice[] slices)
1:a991b64:         {
1:a991b64:             this.comparator = comparator;
1:a991b64:             this.slices = slices;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public int size()
1:a991b64:         {
1:a991b64:             return slices.length;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasLowerBound()
1:a991b64:         {
1:a991b64:             return slices[0].start().size() != 0;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasUpperBound()
1:a991b64:         {
1:a991b64:             return slices[slices.length - 1].end().size() != 0;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slice get(int i)
1:a991b64:         {
1:a991b64:             return slices[i];
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean selects(Clustering clustering)
1:a991b64:         {
1:a991b64:             for (int i = 0; i < slices.length; i++)
1:a991b64:             {
1:a991b64:                 Slice slice = slices[i];
1:a991b64:                 if (comparator.compare(clustering, slice.start()) < 0)
1:a991b64:                     return false;
1:a991b64: 
1:a991b64:                 if (comparator.compare(clustering, slice.end()) <= 0)
1:a991b64:                     return true;
1:a991b64:             }
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public InOrderTester inOrderTester(boolean reversed)
1:a991b64:         {
1:a991b64:             return reversed ? new InReverseOrderTester() : new InForwardOrderTester();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:a991b64:         {
1:a991b64:             return reversed ? forReversePaging(comparator, lastReturned, inclusive) : forForwardPaging(comparator, lastReturned, inclusive);
1:a991b64:         }
1:a991b64: 
1:a991b64:         private Slices forForwardPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
1:a991b64:         {
1:a991b64:             for (int i = 0; i < slices.length; i++)
1:a991b64:             {
1:a991b64:                 Slice slice = slices[i];
1:a991b64:                 Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, false);
1:a991b64:                 if (newSlice == null)
1:a991b64:                     continue;
1:a991b64: 
1:a991b64:                 if (slice == newSlice && i == 0)
1:a991b64:                     return this;
1:a991b64: 
1:a991b64:                 ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, i, slices.length));
1:a991b64:                 newSlices.slices[0] = newSlice;
1:a991b64:                 return newSlices;
1:a991b64:             }
1:a991b64:             return Slices.NONE;
1:a991b64:         }
1:a991b64: 
1:a991b64:         private Slices forReversePaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
1:a991b64:         {
1:a991b64:             for (int i = slices.length - 1; i >= 0; i--)
1:a991b64:             {
1:a991b64:                 Slice slice = slices[i];
1:a991b64:                 Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, true);
1:a991b64:                 if (newSlice == null)
1:a991b64:                     continue;
1:a991b64: 
1:a991b64:                 if (slice == newSlice && i == slices.length - 1)
1:a991b64:                     return this;
1:a991b64: 
1:a991b64:                 ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, 0, i + 1));
1:a991b64:                 newSlices.slices[i] = newSlice;
1:a991b64:                 return newSlices;
1:a991b64:             }
1:a991b64:             return Slices.NONE;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:a991b64:         {
1:a991b64:             for (Slice slice : this)
1:a991b64:             {
1:a991b64:                 if (slice.intersects(comparator, minClusteringValues, maxClusteringValues))
1:a991b64:                     return true;
1:a991b64:             }
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Iterator<Slice> iterator()
1:a991b64:         {
1:a991b64:             return Iterators.forArray(slices);
1:a991b64:         }
1:a991b64: 
1:a991b64:         private class InForwardOrderTester implements InOrderTester
1:a991b64:         {
1:a991b64:             private int idx;
1:a991b64:             private boolean inSlice;
1:a991b64: 
1:a991b64:             public boolean includes(Clustering value)
1:a991b64:             {
1:a991b64:                 while (idx < slices.length)
1:a991b64:                 {
1:a991b64:                     if (!inSlice)
1:a991b64:                     {
1:a991b64:                         int cmp = comparator.compare(value, slices[idx].start());
1:a991b64:                         // value < start
1:a991b64:                         if (cmp < 0)
1:a991b64:                             return false;
1:a991b64: 
1:a991b64:                         inSlice = true;
1:a991b64: 
1:a991b64:                         if (cmp == 0)
1:a991b64:                             return true;
1:a991b64:                     }
1:a991b64: 
1:a991b64:                     // Here, start < value and inSlice
1:a991b64:                     if (comparator.compare(value, slices[idx].end()) <= 0)
1:a991b64:                         return true;
1:a991b64: 
1:a991b64:                     ++idx;
1:a991b64:                     inSlice = false;
1:a991b64:                 }
1:a991b64:                 return false;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean isDone()
1:a991b64:             {
1:a991b64:                 return idx >= slices.length;
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:a991b64:         private class InReverseOrderTester implements InOrderTester
1:a991b64:         {
1:a991b64:             private int idx;
1:a991b64:             private boolean inSlice;
1:a991b64: 
1:a991b64:             public InReverseOrderTester()
1:a991b64:             {
1:a991b64:                 this.idx = slices.length - 1;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean includes(Clustering value)
1:a991b64:             {
1:a991b64:                 while (idx >= 0)
1:a991b64:                 {
1:a991b64:                     if (!inSlice)
1:a991b64:                     {
1:a991b64:                         int cmp = comparator.compare(slices[idx].end(), value);
1:a991b64:                         // value > end
1:a991b64:                         if (cmp > 0)
1:a991b64:                             return false;
1:a991b64: 
1:a991b64:                         inSlice = true;
1:a991b64: 
1:a991b64:                         if (cmp == 0)
1:a991b64:                             return true;
1:a991b64:                     }
1:a991b64: 
1:a991b64:                     // Here, value <= end and inSlice
1:a991b64:                     if (comparator.compare(slices[idx].start(), value) <= 0)
1:a991b64:                         return true;
1:a991b64: 
1:a991b64:                     --idx;
1:a991b64:                     inSlice = false;
1:a991b64:                 }
1:a991b64:                 return false;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean isDone()
1:a991b64:             {
1:a991b64:                 return idx < 0;
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public String toString()
1:a991b64:         {
1:a991b64:             StringBuilder sb = new StringBuilder();
1:a991b64:             sb.append("{");
1:a991b64:             for (int i = 0; i < slices.length; i++)
1:a991b64:             {
1:a991b64:                 if (i > 0)
1:a991b64:                     sb.append(", ");
1:a991b64:                 sb.append(slices[i].toString(comparator));
1:a991b64:             }
1:a991b64:             return sb.append("}").toString();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public String toCQLString(CFMetaData metadata)
1:a991b64:         {
1:a991b64:             StringBuilder sb = new StringBuilder();
1:a991b64: 
1:a991b64:             // In CQL, condition are expressed by column, so first group things that way,
1:a991b64:             // i.e. for each column, we create a list of what each slice contains on that column
1:a991b64:             int clusteringSize = metadata.clusteringColumns().size();
1:a991b64:             List<List<ComponentOfSlice>> columnComponents = new ArrayList<>(clusteringSize);
1:a991b64:             for (int i = 0; i < clusteringSize; i++)
1:a991b64:             {
1:a991b64:                 List<ComponentOfSlice> perSlice = new ArrayList<>();
1:a991b64:                 columnComponents.add(perSlice);
1:a991b64: 
1:a991b64:                 for (int j = 0; j < slices.length; j++)
1:a991b64:                 {
1:a991b64:                     ComponentOfSlice c = ComponentOfSlice.fromSlice(i, slices[j]);
1:a991b64:                     if (c != null)
1:a991b64:                         perSlice.add(c);
1:a991b64:                 }
1:a991b64:             }
1:a991b64: 
1:a991b64:             boolean needAnd = false;
1:a991b64:             for (int i = 0; i < clusteringSize; i++)
1:a991b64:             {
1:a991b64:                 ColumnDefinition column = metadata.clusteringColumns().get(i);
1:a991b64:                 List<ComponentOfSlice> componentInfo = columnComponents.get(i);
1:a991b64:                 if (componentInfo.isEmpty())
1:a991b64:                     break;
1:a991b64: 
1:a991b64:                 // For a given column, there is only 3 cases that CQL currently generates:
1:a991b64:                 //   1) every slice are EQ with the same value, it's a simple '=' relation.
1:a991b64:                 //   2) every slice are EQ but with different values, it's a IN relation.
1:a991b64:                 //   3) every slice aren't EQ but have the same values, we have inequality relations.
1:a991b64:                 // Note that this doesn't cover everything that ReadCommand can express, but
1:a991b64:                 // as it's all that CQL support for now, we'll ignore other cases (which would then
1:a991b64:                 // display a bogus query but that's not the end of the world).
1:a991b64:                 // TODO: we should improve this at some point.
1:a991b64:                 ComponentOfSlice first = componentInfo.get(0);
1:a991b64:                 if (first.isEQ())
1:a991b64:                 {
1:a991b64:                     if (needAnd)
1:a991b64:                         sb.append(" AND ");
1:a991b64:                     needAnd = true;
1:a991b64: 
1:a991b64:                     sb.append(column.name);
1:a991b64: 
1:a991b64:                     Set<ByteBuffer> values = new LinkedHashSet<>();
1:a991b64:                     for (int j = 0; j < componentInfo.size(); j++)
1:a991b64:                         values.add(componentInfo.get(j).startValue);
1:a991b64: 
1:a991b64:                     if (values.size() == 1)
1:a991b64:                     {
1:a991b64:                         sb.append(" = ").append(column.type.getString(first.startValue));
1:a991b64:                     }
1:a991b64:                     else
1:a991b64:                     {
1:a991b64:                         sb.append(" IN (");
1:a991b64:                         int j = 0;
1:a991b64:                         for (ByteBuffer value : values)
1:a991b64:                             sb.append(j++ == 0 ? "" : ", ").append(column.type.getString(value));
1:a991b64:                         sb.append(")");
1:a991b64:                     }
1:a991b64:                 }
1:a991b64:                 else
1:a991b64:                 {
1:a991b64:                     // As said above, we assume (without checking) that this means all ComponentOfSlice for this column
1:a991b64:                     // are the same, so we only bother about the first.
1:a991b64:                     if (first.startValue != null)
1:a991b64:                     {
1:a991b64:                         if (needAnd)
1:a991b64:                             sb.append(" AND ");
1:a991b64:                         needAnd = true;
1:a991b64:                         sb.append(column.name).append(first.startInclusive ? " >= " : " > ").append(column.type.getString(first.startValue));
1:a991b64:                     }
1:a991b64:                     if (first.endValue != null)
1:a991b64:                     {
1:a991b64:                         if (needAnd)
1:a991b64:                             sb.append(" AND ");
1:a991b64:                         needAnd = true;
1:a991b64:                         sb.append(column.name).append(first.endInclusive ? " <= " : " < ").append(column.type.getString(first.endValue));
1:a991b64:                     }
1:a991b64:                 }
1:a991b64:             }
1:a991b64:             return sb.toString();
1:a991b64:         }
1:a991b64: 
1:a991b64:         // An somewhat adhoc utility class only used by toCQLString
1:a991b64:         private static class ComponentOfSlice
1:a991b64:         {
1:a991b64:             public final boolean startInclusive;
1:a991b64:             public final ByteBuffer startValue;
1:a991b64:             public final boolean endInclusive;
1:a991b64:             public final ByteBuffer endValue;
1:a991b64: 
1:a991b64:             private ComponentOfSlice(boolean startInclusive, ByteBuffer startValue, boolean endInclusive, ByteBuffer endValue)
1:a991b64:             {
1:a991b64:                 this.startInclusive = startInclusive;
1:a991b64:                 this.startValue = startValue;
1:a991b64:                 this.endInclusive = endInclusive;
1:a991b64:                 this.endValue = endValue;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public static ComponentOfSlice fromSlice(int component, Slice slice)
1:a991b64:             {
1:2cc26eb:                 ClusteringBound start = slice.start();
1:2cc26eb:                 ClusteringBound end = slice.end();
1:a991b64: 
1:a991b64:                 if (component >= start.size() && component >= end.size())
1:a991b64:                     return null;
1:a991b64: 
1:a991b64:                 boolean startInclusive = true, endInclusive = true;
1:a991b64:                 ByteBuffer startValue = null, endValue = null;
1:a991b64:                 if (component < start.size())
1:a991b64:                 {
1:a991b64:                     startInclusive = start.isInclusive();
1:a991b64:                     startValue = start.get(component);
1:a991b64:                 }
1:a991b64:                 if (component < end.size())
1:a991b64:                 {
1:a991b64:                     endInclusive = end.isInclusive();
1:a991b64:                     endValue = end.get(component);
1:a991b64:                 }
1:a991b64:                 return new ComponentOfSlice(startInclusive, startValue, endInclusive, endValue);
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean isEQ()
1:a991b64:             {
1:79a16e5:                 return Objects.equals(startValue, endValue);
1:a991b64:             }
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Specialized implementation of {@code Slices} that selects all rows.
1:a991b64:      * <p>
1:a991b64:      * This is equivalent to having the single {@code Slice.ALL} slice, but is somewhat more effecient.
1:a991b64:      */
1:a991b64:     private static class SelectAllSlices extends Slices
1:a991b64:     {
1:a991b64:         private static final InOrderTester trivialTester = new InOrderTester()
1:a991b64:         {
1:a991b64:             public boolean includes(Clustering value)
1:a991b64:             {
1:a991b64:                 return true;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean isDone()
1:a991b64:             {
1:a991b64:                 return false;
1:a991b64:             }
2:a991b64:         };
1:a991b64: 
1:a991b64:         public int size()
1:a991b64:         {
1:a991b64:             return 1;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slice get(int i)
1:a991b64:         {
1:a991b64:             return Slice.ALL;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasLowerBound()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasUpperBound()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean selects(Clustering clustering)
1:a991b64:         {
1:a991b64:             return true;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:a991b64:         {
1:a991b64:             return new ArrayBackedSlices(comparator, new Slice[]{ Slice.ALL.forPaging(comparator, lastReturned, inclusive, reversed) });
1:a991b64:         }
1:a991b64: 
1:a991b64:         public InOrderTester inOrderTester(boolean reversed)
1:a991b64:         {
1:a991b64:             return trivialTester;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:a991b64:         {
1:a991b64:             return true;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Iterator<Slice> iterator()
1:a991b64:         {
1:a991b64:             return Iterators.singletonIterator(Slice.ALL);
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public String toString()
1:a991b64:         {
1:a991b64:             return "ALL";
1:a991b64:         }
1:a991b64: 
1:a991b64:         public String toCQLString(CFMetaData metadata)
1:a991b64:         {
1:a991b64:             return "";
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Specialized implementation of {@code Slices} that selects no rows.
1:a991b64:      */
1:a991b64:     private static class SelectNoSlices extends Slices
1:a991b64:     {
1:a991b64:         private static final InOrderTester trivialTester = new InOrderTester()
1:a991b64:         {
1:a991b64:             public boolean includes(Clustering value)
1:a991b64:             {
1:a991b64:                 return false;
1:a991b64:             }
1:a991b64: 
1:a991b64:             public boolean isDone()
1:a991b64:             {
1:a991b64:                 return true;
1:a991b64:             }
1:a991b64:         };
1:a991b64: 
1:a991b64:         public int size()
1:a991b64:         {
1:a991b64:             return 0;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slice get(int i)
1:a991b64:         {
1:a991b64:             throw new UnsupportedOperationException();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasLowerBound()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasUpperBound()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:a991b64:         {
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean selects(Clustering clustering)
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public InOrderTester inOrderTester(boolean reversed)
1:a991b64:         {
1:a991b64:             return trivialTester;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Iterator<Slice> iterator()
1:a991b64:         {
1:f4233eb:             return Collections.emptyIterator();
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public String toString()
1:a991b64:         {
1:a991b64:             return "NONE";
1:a991b64:         }
1:a991b64: 
1:a991b64:         public String toCQLString(CFMetaData metadata)
1:a991b64:         {
1:a991b64:             return "";
1:a991b64:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:79a16e5
/////////////////////////////////////////////////////////////////////////
1:                 return Objects.equals(startValue, endValue);
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
0:                 return Objects.equals(startValue, endValue);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:89a645a
commit:a87fd71
commit:86ba227
/////////////////////////////////////////////////////////////////////////
1:         public Builder addAll(Slices slices)
1:         {
1:             for (Slice slice : slices)
1:                 add(slice);
1:             return this;
1:         }
1: 
commit:a59be26
/////////////////////////////////////////////////////////////////////////
0:             out.writeVInt(size);
/////////////////////////////////////////////////////////////////////////
0:             long size = TypeSizes.sizeofVInt(slices.size());
/////////////////////////////////////////////////////////////////////////
0:             int size = (int)in.readVInt();
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public Slices deserialize(DataInputPlus in, int version, CFMetaData metadata) throws IOException
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
0: import java.io.DataInput;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import com.google.common.collect.Iterators;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.io.util.DataOutputPlus;
1: 
1: /**
1:  * Represents the selection of multiple range of rows within a partition.
1:  * <p>
1:  * A {@code Slices} is basically a list of {@code Slice}, though those are guaranteed to be non-overlapping
1:  * and always in clustering order.
1:  */
1: public abstract class Slices implements Iterable<Slice>
1: {
1:     public static final Serializer serializer = new Serializer();
1: 
1:     /** Slices selecting all the rows of a partition. */
1:     public static final Slices ALL = new SelectAllSlices();
1:     /** Slices selecting no rows in a partition. */
1:     public static final Slices NONE = new SelectNoSlices();
1: 
1:     protected Slices()
1:     {
1:     }
1: 
1:     /**
1:      * Creates a {@code Slices} object that contains a single slice.
1:      *
1:      * @param comparator the comparator for the table {@code slice} is a slice of.
1:      * @param slice the single slice that the return object should contains.
1:      *
1:      * @return the newly created {@code Slices} object.
1:      */
1:     public static Slices with(ClusteringComparator comparator, Slice slice)
1:     {
0:         if (slice.start() == Slice.Bound.BOTTOM && slice.end() == Slice.Bound.TOP)
1:             return Slices.ALL;
1: 
1:         assert comparator.compare(slice.start(), slice.end()) <= 0;
1:         return new ArrayBackedSlices(comparator, new Slice[]{ slice });
1:     }
1: 
1:     /**
1:      * Whether the slices has a lower bound, that is whether it's first slice start is {@code Slice.BOTTOM}.
1:      *
1:      * @return whether the slices has a lower bound.
1:      */
1:     public abstract boolean hasLowerBound();
1: 
1:     /**
1:      * Whether the slices has an upper bound, that is whether it's last slice end is {@code Slice.TOP}.
1:      *
1:      * @return whether the slices has an upper bound.
1:      */
1:     public abstract boolean hasUpperBound();
1: 
1:     /**
1:      * The number of slice this object contains.
1:      *
1:      * @return the number of slice this object contains.
1:      */
1:     public abstract int size();
1: 
1:     /**
1:      * Returns the ith slice of this {@code Slices} object.
1:      *
1:      * @return the ith slice of this object.
1:      */
1:     public abstract Slice get(int i);
1: 
1:     /**
1:      * Returns slices for continuing the paging of those slices given the last returned clustering prefix.
1:      *
1:      * @param comparator the comparator for the table this is a filter for.
1:      * @param lastReturned the last clustering that was returned for the query we are paging for. The
1:      * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
1:      * (where coming after means "greater than" if {@code !reversed} and "lesser than" otherwise).
1:      * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
1:      * @param reversed whether the query we're paging for is reversed or not.
1:      *
1:      * @return new slices that select results coming after {@code lastReturned}.
1:      */
1:     public abstract Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed);
1: 
1:     /**
1:      * An object that allows to test whether rows are selected by this {@code Slices} objects assuming those rows
1:      * are tested in clustering order.
1:      *
1:      * @param reversed if true, the rows passed to the returned object will be assumed to be in reversed clustering
1:      * order, otherwise they should be in clustering order.
1:      *
1:      * @return an object that tests for selection of rows by this {@code Slices} object.
1:      */
1:     public abstract InOrderTester inOrderTester(boolean reversed);
1: 
1:     /**
1:      * Whether a given clustering (row) is selected by this {@code Slices} object.
1:      *
1:      * @param clustering the clustering to test for selection.
1:      *
1:      * @return whether a given clustering (row) is selected by this {@code Slices} object.
1:      */
1:     public abstract boolean selects(Clustering clustering);
1: 
1: 
1:     /**
1:      * Given the per-clustering column minimum and maximum value a sstable contains, whether or not this slices potentially
1:      * intersects that sstable or not.
1:      *
1:      * @param minClusteringValues the smallest values for each clustering column that a sstable contains.
1:      * @param maxClusteringValues the biggest values for each clustering column that a sstable contains.
1:      *
1:      * @return whether the slices might intersects with the sstable having {@code minClusteringValues} and
1:      * {@code maxClusteringValues}.
1:      */
1:     public abstract boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues);
1: 
1:     /**
0:      * Given a sliceable row iterator, returns a row iterator that only return rows selected by the slice of
0:      * this {@code Slices} object.
1:      *
0:      * @param iter the sliceable iterator to filter.
1:      *
0:      * @return an iterator that only returns the rows (or rather Unfiltered) of {@code iter} that are selected by those slices.
1:      */
0:     public abstract UnfilteredRowIterator makeSliceIterator(SliceableUnfilteredRowIterator iter);
1: 
1:     public abstract String toCQLString(CFMetaData metadata);
1: 
1:     /**
1:      * In simple object that allows to test the inclusion of rows in those slices assuming those rows
1:      * are passed (to {@link #includes}) in clustering order (or reverse clustering ordered, depending
1:      * of the argument passed to {@link #inOrderTester}).
1:      */
1:     public interface InOrderTester
1:     {
1:         public boolean includes(Clustering value);
1:         public boolean isDone();
1:     }
1: 
1:     /**
1:      * Builder to create {@code Slices} objects.
1:      */
1:     public static class Builder
1:     {
1:         private final ClusteringComparator comparator;
1: 
1:         private final List<Slice> slices;
1: 
1:         private boolean needsNormalizing;
1: 
1:         public Builder(ClusteringComparator comparator)
1:         {
1:             this.comparator = comparator;
1:             this.slices = new ArrayList<>();
1:         }
1: 
1:         public Builder(ClusteringComparator comparator, int initialSize)
1:         {
1:             this.comparator = comparator;
1:             this.slices = new ArrayList<>(initialSize);
1:         }
1: 
0:         public Builder add(Slice.Bound start, Slice.Bound end)
1:         {
1:             return add(Slice.make(start, end));
1:         }
1: 
1:         public Builder add(Slice slice)
1:         {
1:             assert comparator.compare(slice.start(), slice.end()) <= 0;
1:             if (slices.size() > 0 && comparator.compare(slices.get(slices.size()-1).end(), slice.start()) > 0)
1:                 needsNormalizing = true;
1:             slices.add(slice);
1:             return this;
1:         }
1: 
1:         public int size()
1:         {
1:             return slices.size();
1:         }
1: 
1:         public Slices build()
1:         {
1:             if (slices.isEmpty())
1:                 return NONE;
1: 
1:             if (slices.size() == 1 && slices.get(0) == Slice.ALL)
1:                 return ALL;
1: 
1:             List<Slice> normalized = needsNormalizing
1:                                    ? normalize(slices)
1:                                    : slices;
1: 
1:             return new ArrayBackedSlices(comparator, normalized.toArray(new Slice[normalized.size()]));
1:         }
1: 
1:         /**
1:          * Given an array of slices (potentially overlapping and in any order) and return an equivalent array
1:          * of non-overlapping slices in clustering order.
1:          *
1:          * @param slices an array of slices. This may be modified by this method.
1:          * @return the smallest possible array of non-overlapping slices in clustering order. If the original
1:          * slices are already non-overlapping and in comparator order, this may or may not return the provided slices
1:          * directly.
1:          */
1:         private List<Slice> normalize(List<Slice> slices)
1:         {
1:             if (slices.size() <= 1)
1:                 return slices;
1: 
1:             Collections.sort(slices, new Comparator<Slice>()
1:             {
1:                 @Override
1:                 public int compare(Slice s1, Slice s2)
1:                 {
1:                     int c = comparator.compare(s1.start(), s2.start());
1:                     if (c != 0)
1:                         return c;
1: 
1:                     return comparator.compare(s1.end(), s2.end());
1:                 }
1:             });
1: 
1:             List<Slice> slicesCopy = new ArrayList<>(slices.size());
1: 
1:             Slice last = slices.get(0);
1: 
1:             for (int i = 1; i < slices.size(); i++)
1:             {
1:                 Slice s2 = slices.get(i);
1: 
1:                 boolean includesStart = last.includes(comparator, s2.start());
1:                 boolean includesFinish = last.includes(comparator, s2.end());
1: 
1:                 if (includesStart && includesFinish)
1:                     continue;
1: 
1:                 if (!includesStart && !includesFinish)
1:                 {
1:                     slicesCopy.add(last);
1:                     last = s2;
1:                     continue;
1:                 }
1: 
1:                 if (includesStart)
1:                 {
1:                     last = Slice.make(last.start(), s2.end());
1:                     continue;
1:                 }
1: 
1:                 assert !includesFinish;
1:             }
1: 
1:             slicesCopy.add(last);
1:             return slicesCopy;
1:         }
1:     }
1: 
1:     public static class Serializer
1:     {
1:         public void serialize(Slices slices, DataOutputPlus out, int version) throws IOException
1:         {
1:             int size = slices.size();
0:             out.writeInt(size);
1: 
1:             if (size == 0)
1:                 return;
1: 
1:             List<AbstractType<?>> types = slices == ALL
1:                                         ? Collections.<AbstractType<?>>emptyList()
1:                                         : ((ArrayBackedSlices)slices).comparator.subtypes();
1: 
1:             for (Slice slice : slices)
1:                 Slice.serializer.serialize(slice, out, version, types);
1:         }
1: 
0:         public long serializedSize(Slices slices, int version, TypeSizes sizes)
1:         {
0:             long size = sizes.sizeof(slices.size());
1: 
1:             if (slices.size() == 0)
1:                 return size;
1: 
1:             List<AbstractType<?>> types = slices instanceof SelectAllSlices
1:                                         ? Collections.<AbstractType<?>>emptyList()
1:                                         : ((ArrayBackedSlices)slices).comparator.subtypes();
1: 
1:             for (Slice slice : slices)
0:                 size += Slice.serializer.serializedSize(slice, version, types, sizes);
1: 
1:             return size;
1:         }
1: 
0:         public Slices deserialize(DataInput in, int version, CFMetaData metadata) throws IOException
1:         {
0:             int size = in.readInt();
1: 
1:             if (size == 0)
1:                 return NONE;
1: 
1:             Slice[] slices = new Slice[size];
1:             for (int i = 0; i < size; i++)
1:                 slices[i] = Slice.serializer.deserialize(in, version, metadata.comparator.subtypes());
1: 
0:             if (size == 1 && slices[0].start() == Slice.Bound.BOTTOM && slices[0].end() == Slice.Bound.TOP)
1:                 return ALL;
1: 
1:             return new ArrayBackedSlices(metadata.comparator, slices);
1:         }
1:     }
1: 
1:     /**
1:      * Simple {@code Slices} implementation that stores its slices in an array.
1:      */
1:     private static class ArrayBackedSlices extends Slices
1:     {
1:         private final ClusteringComparator comparator;
1: 
1:         private final Slice[] slices;
1: 
1:         private ArrayBackedSlices(ClusteringComparator comparator, Slice[] slices)
1:         {
1:             this.comparator = comparator;
1:             this.slices = slices;
1:         }
1: 
1:         public int size()
1:         {
1:             return slices.length;
1:         }
1: 
1:         public boolean hasLowerBound()
1:         {
1:             return slices[0].start().size() != 0;
1:         }
1: 
1:         public boolean hasUpperBound()
1:         {
1:             return slices[slices.length - 1].end().size() != 0;
1:         }
1: 
1:         public Slice get(int i)
1:         {
1:             return slices[i];
1:         }
1: 
1:         public boolean selects(Clustering clustering)
1:         {
1:             for (int i = 0; i < slices.length; i++)
1:             {
1:                 Slice slice = slices[i];
1:                 if (comparator.compare(clustering, slice.start()) < 0)
1:                     return false;
1: 
1:                 if (comparator.compare(clustering, slice.end()) <= 0)
1:                     return true;
1:             }
1:             return false;
1:         }
1: 
1:         public InOrderTester inOrderTester(boolean reversed)
1:         {
1:             return reversed ? new InReverseOrderTester() : new InForwardOrderTester();
1:         }
1: 
1:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:         {
1:             return reversed ? forReversePaging(comparator, lastReturned, inclusive) : forForwardPaging(comparator, lastReturned, inclusive);
1:         }
1: 
1:         private Slices forForwardPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
1:         {
1:             for (int i = 0; i < slices.length; i++)
1:             {
1:                 Slice slice = slices[i];
1:                 Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, false);
1:                 if (newSlice == null)
1:                     continue;
1: 
1:                 if (slice == newSlice && i == 0)
1:                     return this;
1: 
1:                 ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, i, slices.length));
1:                 newSlices.slices[0] = newSlice;
1:                 return newSlices;
1:             }
1:             return Slices.NONE;
1:         }
1: 
1:         private Slices forReversePaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
1:         {
1:             for (int i = slices.length - 1; i >= 0; i--)
1:             {
1:                 Slice slice = slices[i];
1:                 Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, true);
1:                 if (newSlice == null)
1:                     continue;
1: 
1:                 if (slice == newSlice && i == slices.length - 1)
1:                     return this;
1: 
1:                 ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, 0, i + 1));
1:                 newSlices.slices[i] = newSlice;
1:                 return newSlices;
1:             }
1:             return Slices.NONE;
1:         }
1: 
1:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:         {
1:             for (Slice slice : this)
1:             {
1:                 if (slice.intersects(comparator, minClusteringValues, maxClusteringValues))
1:                     return true;
1:             }
1:             return false;
1:         }
1: 
0:         public UnfilteredRowIterator makeSliceIterator(final SliceableUnfilteredRowIterator iter)
1:         {
0:             return new WrappingUnfilteredRowIterator(iter)
1:             {
0:                 private int nextSlice = iter.isReverseOrder() ? slices.length - 1 : 0;
0:                 private Iterator<Unfiltered> currentSliceIterator = Collections.emptyIterator();
1: 
0:                 private Unfiltered next;
1: 
1:                 @Override
0:                 public boolean hasNext()
1:                 {
0:                     prepareNext();
0:                     return next != null;
1:                 }
1: 
1:                 @Override
0:                 public Unfiltered next()
1:                 {
0:                     prepareNext();
0:                     Unfiltered toReturn = next;
0:                     next = null;
0:                     return toReturn;
1:                 }
1: 
0:                 private boolean hasMoreSlice()
1:                 {
0:                     return isReverseOrder()
0:                          ? nextSlice >= 0
0:                          : nextSlice < slices.length;
1:                 }
1: 
0:                 private Slice popNextSlice()
1:                 {
0:                     return slices[isReverseOrder() ? nextSlice-- : nextSlice++];
1:                 }
1: 
0:                 private void prepareNext()
1:                 {
0:                     if (next != null)
1:                         return;
1: 
0:                     while (true)
1:                     {
0:                         if (currentSliceIterator.hasNext())
1:                         {
0:                             next = currentSliceIterator.next();
1:                             return;
1:                         }
1: 
0:                         if (!hasMoreSlice())
1:                             return;
1: 
0:                         currentSliceIterator = iter.slice(popNextSlice());
1:                     }
1:                 }
1:             };
1:         }
1: 
1:         public Iterator<Slice> iterator()
1:         {
1:             return Iterators.forArray(slices);
1:         }
1: 
1:         private class InForwardOrderTester implements InOrderTester
1:         {
1:             private int idx;
1:             private boolean inSlice;
1: 
1:             public boolean includes(Clustering value)
1:             {
1:                 while (idx < slices.length)
1:                 {
1:                     if (!inSlice)
1:                     {
1:                         int cmp = comparator.compare(value, slices[idx].start());
1:                         // value < start
1:                         if (cmp < 0)
1:                             return false;
1: 
1:                         inSlice = true;
1: 
1:                         if (cmp == 0)
1:                             return true;
1:                     }
1: 
1:                     // Here, start < value and inSlice
1:                     if (comparator.compare(value, slices[idx].end()) <= 0)
1:                         return true;
1: 
1:                     ++idx;
1:                     inSlice = false;
1:                 }
1:                 return false;
1:             }
1: 
1:             public boolean isDone()
1:             {
1:                 return idx >= slices.length;
1:             }
1:         }
1: 
1:         private class InReverseOrderTester implements InOrderTester
1:         {
1:             private int idx;
1:             private boolean inSlice;
1: 
1:             public InReverseOrderTester()
1:             {
1:                 this.idx = slices.length - 1;
1:             }
1: 
1:             public boolean includes(Clustering value)
1:             {
1:                 while (idx >= 0)
1:                 {
1:                     if (!inSlice)
1:                     {
1:                         int cmp = comparator.compare(slices[idx].end(), value);
1:                         // value > end
1:                         if (cmp > 0)
1:                             return false;
1: 
1:                         inSlice = true;
1: 
1:                         if (cmp == 0)
1:                             return true;
1:                     }
1: 
1:                     // Here, value <= end and inSlice
1:                     if (comparator.compare(slices[idx].start(), value) <= 0)
1:                         return true;
1: 
1:                     --idx;
1:                     inSlice = false;
1:                 }
1:                 return false;
1:             }
1: 
1:             public boolean isDone()
1:             {
1:                 return idx < 0;
1:             }
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("{");
1:             for (int i = 0; i < slices.length; i++)
1:             {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append(slices[i].toString(comparator));
1:             }
1:             return sb.append("}").toString();
1:         }
1: 
1:         public String toCQLString(CFMetaData metadata)
1:         {
1:             StringBuilder sb = new StringBuilder();
1: 
1:             // In CQL, condition are expressed by column, so first group things that way,
1:             // i.e. for each column, we create a list of what each slice contains on that column
1:             int clusteringSize = metadata.clusteringColumns().size();
1:             List<List<ComponentOfSlice>> columnComponents = new ArrayList<>(clusteringSize);
1:             for (int i = 0; i < clusteringSize; i++)
1:             {
1:                 List<ComponentOfSlice> perSlice = new ArrayList<>();
1:                 columnComponents.add(perSlice);
1: 
1:                 for (int j = 0; j < slices.length; j++)
1:                 {
1:                     ComponentOfSlice c = ComponentOfSlice.fromSlice(i, slices[j]);
1:                     if (c != null)
1:                         perSlice.add(c);
1:                 }
1:             }
1: 
1:             boolean needAnd = false;
1:             for (int i = 0; i < clusteringSize; i++)
1:             {
1:                 ColumnDefinition column = metadata.clusteringColumns().get(i);
1:                 List<ComponentOfSlice> componentInfo = columnComponents.get(i);
1:                 if (componentInfo.isEmpty())
1:                     break;
1: 
1:                 // For a given column, there is only 3 cases that CQL currently generates:
1:                 //   1) every slice are EQ with the same value, it's a simple '=' relation.
1:                 //   2) every slice are EQ but with different values, it's a IN relation.
1:                 //   3) every slice aren't EQ but have the same values, we have inequality relations.
1:                 // Note that this doesn't cover everything that ReadCommand can express, but
1:                 // as it's all that CQL support for now, we'll ignore other cases (which would then
1:                 // display a bogus query but that's not the end of the world).
1:                 // TODO: we should improve this at some point.
1:                 ComponentOfSlice first = componentInfo.get(0);
1:                 if (first.isEQ())
1:                 {
1:                     if (needAnd)
1:                         sb.append(" AND ");
1:                     needAnd = true;
1: 
1:                     sb.append(column.name);
1: 
1:                     Set<ByteBuffer> values = new LinkedHashSet<>();
1:                     for (int j = 0; j < componentInfo.size(); j++)
1:                         values.add(componentInfo.get(j).startValue);
1: 
1:                     if (values.size() == 1)
1:                     {
1:                         sb.append(" = ").append(column.type.getString(first.startValue));
1:                     }
1:                     else
1:                     {
1:                         sb.append(" IN (");
1:                         int j = 0;
1:                         for (ByteBuffer value : values)
1:                             sb.append(j++ == 0 ? "" : ", ").append(column.type.getString(value));
1:                         sb.append(")");
1:                     }
1:                 }
1:                 else
1:                 {
1:                     // As said above, we assume (without checking) that this means all ComponentOfSlice for this column
1:                     // are the same, so we only bother about the first.
1:                     if (first.startValue != null)
1:                     {
1:                         if (needAnd)
1:                             sb.append(" AND ");
1:                         needAnd = true;
1:                         sb.append(column.name).append(first.startInclusive ? " >= " : " > ").append(column.type.getString(first.startValue));
1:                     }
1:                     if (first.endValue != null)
1:                     {
1:                         if (needAnd)
1:                             sb.append(" AND ");
1:                         needAnd = true;
1:                         sb.append(column.name).append(first.endInclusive ? " <= " : " < ").append(column.type.getString(first.endValue));
1:                     }
1:                 }
1:             }
1:             return sb.toString();
1:         }
1: 
1:         // An somewhat adhoc utility class only used by toCQLString
1:         private static class ComponentOfSlice
1:         {
1:             public final boolean startInclusive;
1:             public final ByteBuffer startValue;
1:             public final boolean endInclusive;
1:             public final ByteBuffer endValue;
1: 
1:             private ComponentOfSlice(boolean startInclusive, ByteBuffer startValue, boolean endInclusive, ByteBuffer endValue)
1:             {
1:                 this.startInclusive = startInclusive;
1:                 this.startValue = startValue;
1:                 this.endInclusive = endInclusive;
1:                 this.endValue = endValue;
1:             }
1: 
1:             public static ComponentOfSlice fromSlice(int component, Slice slice)
1:             {
0:                 Slice.Bound start = slice.start();
0:                 Slice.Bound end = slice.end();
1: 
1:                 if (component >= start.size() && component >= end.size())
1:                     return null;
1: 
1:                 boolean startInclusive = true, endInclusive = true;
1:                 ByteBuffer startValue = null, endValue = null;
1:                 if (component < start.size())
1:                 {
1:                     startInclusive = start.isInclusive();
1:                     startValue = start.get(component);
1:                 }
1:                 if (component < end.size())
1:                 {
1:                     endInclusive = end.isInclusive();
1:                     endValue = end.get(component);
1:                 }
1:                 return new ComponentOfSlice(startInclusive, startValue, endInclusive, endValue);
1:             }
1: 
1:             public boolean isEQ()
1:             {
0:                 return startValue.equals(endValue);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Specialized implementation of {@code Slices} that selects all rows.
1:      * <p>
1:      * This is equivalent to having the single {@code Slice.ALL} slice, but is somewhat more effecient.
1:      */
1:     private static class SelectAllSlices extends Slices
1:     {
1:         private static final InOrderTester trivialTester = new InOrderTester()
1:         {
1:             public boolean includes(Clustering value)
1:             {
1:                 return true;
1:             }
1: 
1:             public boolean isDone()
1:             {
1:                 return false;
1:             }
1:         };
1: 
1:         public int size()
1:         {
1:             return 1;
1:         }
1: 
1:         public Slice get(int i)
1:         {
1:             return Slice.ALL;
1:         }
1: 
1:         public boolean hasLowerBound()
1:         {
1:             return false;
1:         }
1: 
1:         public boolean hasUpperBound()
1:         {
1:             return false;
1:         }
1: 
1:         public boolean selects(Clustering clustering)
1:         {
1:             return true;
1:         }
1: 
1:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:         {
1:             return new ArrayBackedSlices(comparator, new Slice[]{ Slice.ALL.forPaging(comparator, lastReturned, inclusive, reversed) });
1:         }
1: 
1:         public InOrderTester inOrderTester(boolean reversed)
1:         {
1:             return trivialTester;
1:         }
1: 
1:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:         {
1:             return true;
1:         }
1: 
0:         public UnfilteredRowIterator makeSliceIterator(SliceableUnfilteredRowIterator iter)
1:         {
0:             return iter;
1:         }
1: 
1:         public Iterator<Slice> iterator()
1:         {
1:             return Iterators.singletonIterator(Slice.ALL);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return "ALL";
1:         }
1: 
1:         public String toCQLString(CFMetaData metadata)
1:         {
1:             return "";
1:         }
1:     }
1: 
1:     /**
1:      * Specialized implementation of {@code Slices} that selects no rows.
1:      */
1:     private static class SelectNoSlices extends Slices
1:     {
1:         private static final InOrderTester trivialTester = new InOrderTester()
1:         {
1:             public boolean includes(Clustering value)
1:             {
1:                 return false;
1:             }
1: 
1:             public boolean isDone()
1:             {
1:                 return true;
1:             }
1:         };
1: 
1:         public int size()
1:         {
1:             return 0;
1:         }
1: 
1:         public Slice get(int i)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public boolean hasLowerBound()
1:         {
1:             return false;
1:         }
1: 
1:         public boolean hasUpperBound()
1:         {
1:             return false;
1:         }
1: 
1:         public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
1:         {
1:             return this;
1:         }
1: 
1:         public boolean selects(Clustering clustering)
1:         {
1:             return false;
1:         }
1: 
1:         public InOrderTester inOrderTester(boolean reversed)
1:         {
1:             return trivialTester;
1:         }
1: 
1:         public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer> maxClusteringValues)
1:         {
1:             return false;
1:         }
1: 
0:         public UnfilteredRowIterator makeSliceIterator(SliceableUnfilteredRowIterator iter)
1:         {
0:             return UnfilteredRowIterators.emptyIterator(iter.metadata(), iter.partitionKey(), iter.isReverseOrder());
1:         }
1: 
1:         public Iterator<Slice> iterator()
1:         {
0:             return Iterators.emptyIterator();
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return "NONE";
1:         }
1: 
1:         public String toCQLString(CFMetaData metadata)
1:         {
1:             return "";
1:         }
1:     }
1: }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:f4233eb
/////////////////////////////////////////////////////////////////////////
1:             return Collections.emptyIterator();
commit:59a2861
/////////////////////////////////////////////////////////////////////////
0:             out.writeInt(size);
/////////////////////////////////////////////////////////////////////////
0:             long size = TypeSizes.sizeof(slices.size());
/////////////////////////////////////////////////////////////////////////
0:             int size = in.readInt();
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:         if (slice.start() == ClusteringBound.BOTTOM && slice.end() == ClusteringBound.TOP)
/////////////////////////////////////////////////////////////////////////
1:         public Builder add(ClusteringBound start, ClusteringBound end)
/////////////////////////////////////////////////////////////////////////
1:             if (size == 1 && slices[0].start() == ClusteringBound.BOTTOM && slices[0].end() == ClusteringBound.TOP)
/////////////////////////////////////////////////////////////////////////
1:                 ClusteringBound start = slice.start();
1:                 ClusteringBound end = slice.end();
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:4fb559b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:649a106
/////////////////////////////////////////////////////////////////////////
1:             out.writeUnsignedVInt(size);
/////////////////////////////////////////////////////////////////////////
1:             long size = TypeSizes.sizeofUnsignedVInt(slices.size());
/////////////////////////////////////////////////////////////////////////
1:             int size = (int)in.readUnsignedVInt();
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
1:      * Checks if this <code>Slices</code> is empty.
1:      * @return <code>true</code> if this <code>Slices</code> is empty, <code>false</code> otherwise.
0:      */
1:     public final boolean isEmpty()
0:     {
1:         return size() == 0;
0:     }
0: 
0:     /**
author:Blake Eggleston
-------------------------------------------------------------------------------
commit:9658ee9
/////////////////////////////////////////////////////////////////////////
0:             return UnfilteredRowIterators.noRowsIterator(iter.metadata(), iter.partitionKey(), iter.staticRow(),
0:                                                          iter.partitionLevelDeletion(), iter.isReverseOrder());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:2fea59d
/////////////////////////////////////////////////////////////////////////
0:             out.writeVInt(size);
/////////////////////////////////////////////////////////////////////////
0:             long size = TypeSizes.sizeofVInt(slices.size());
/////////////////////////////////////////////////////////////////////////
0:             int size = (int)in.readVInt();
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1:         public long serializedSize(Slices slices, int version)
0:             long size = TypeSizes.sizeof(slices.size());
/////////////////////////////////////////////////////////////////////////
1:                 size += Slice.serializer.serializedSize(slice, version, types);
============================================================================