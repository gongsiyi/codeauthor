1:31e3f61: /*
1:38e3e85:  * Licensed to the Apache Software Foundation (ASF) under one
1:38e3e85:  * or more contributor license agreements.  See the NOTICE file
1:38e3e85:  * distributed with this work for additional information
1:38e3e85:  * regarding copyright ownership.  The ASF licenses this file
1:38e3e85:  * to you under the Apache License, Version 2.0 (the
1:38e3e85:  * "License"); you may not use this file except in compliance
1:38e3e85:  * with the License.  You may obtain a copy of the License at
1:38e3e85:  *
1:38e3e85:  *    http://www.apache.org/licenses/LICENSE-2.0
1:38e3e85:  *
1:38e3e85:  * Unless required by applicable law or agreed to in writing,
1:38e3e85:  * software distributed under the License is distributed on an
1:38e3e85:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:38e3e85:  * KIND, either express or implied.  See the License for the
1:38e3e85:  * specific language governing permissions and limitations
1:38e3e85:  * under the License.
1:38e3e85:  */
1:7d6c876: package org.apache.cassandra.schema;
7:38e3e85: 
1:507ed14: import java.io.IOException;
1:507ed14: import java.nio.ByteBuffer;
1:38e3e85: import java.util.ArrayList;
1:507ed14: import java.util.Collections;
1:362cc05: import java.util.HashSet;
1:507ed14: import java.util.List;
1:340df43: import java.util.Set;
1:507ed14: 
1:507ed14: import com.google.common.collect.ImmutableMap;
1:507ed14: 
1:507ed14: import org.junit.BeforeClass;
1:507ed14: import org.junit.Test;
1:38e3e85: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:7d6c876: import org.apache.cassandra.config.CFMetaData;
1:340df43: import org.apache.cassandra.config.ColumnDefinition;
1:7d6c876: import org.apache.cassandra.config.Schema;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:340df43: import org.apache.cassandra.cql3.QueryProcessor;
1:340df43: import org.apache.cassandra.cql3.UntypedResultSet;
1:507ed14: import org.apache.cassandra.db.ColumnFamilyStore;
1:507ed14: import org.apache.cassandra.db.Keyspace;
1:507ed14: import org.apache.cassandra.db.Mutation;
1:38e3e85: import org.apache.cassandra.db.marshal.AsciiType;
1:38e3e85: import org.apache.cassandra.db.marshal.UTF8Type;
1:507ed14: import org.apache.cassandra.db.partitions.PartitionUpdate;
1:507ed14: import org.apache.cassandra.db.rows.UnfilteredRowIterators;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:38e3e85: import org.apache.cassandra.thrift.CfDef;
1:38e3e85: import org.apache.cassandra.thrift.ColumnDef;
1:38e3e85: import org.apache.cassandra.thrift.IndexType;
1:a94b173: import org.apache.cassandra.thrift.ThriftConversion;
1:38e3e85: import org.apache.cassandra.utils.ByteBufferUtil;
1:3e9d345: import org.apache.cassandra.utils.FBUtilities;
1:3e9d345: 
1:38e3e85: import static org.junit.Assert.assertEquals;
1:507ed14: import static org.junit.Assert.assertTrue;
1:ccb0028: 
1:7d6c876: public class SchemaKeyspaceTest
1:d2a3827: {
1:d2a3827:     private static final String KEYSPACE1 = "CFMetaDataTest1";
1:d2a3827:     private static final String CF_STANDARD1 = "Standard1";
1:ccb0028: 
1:7d6c876:     private static final List<ColumnDef> columnDefs = new ArrayList<>();
1:38e3e85: 
1:38e3e85:     static
1:8a1b93d:     {
1:38e3e85:         columnDefs.add(new ColumnDef(ByteBufferUtil.bytes("col1"), AsciiType.class.getCanonicalName())
1:38e3e85:                                     .setIndex_name("col1Index")
1:38e3e85:                                     .setIndex_type(IndexType.KEYS));
1:d2a3827: 
1:38e3e85:         columnDefs.add(new ColumnDef(ByteBufferUtil.bytes("col2"), UTF8Type.class.getCanonicalName())
1:38e3e85:                                     .setIndex_name("col2Index")
1:38e3e85:                                     .setIndex_type(IndexType.KEYS));
1:8a1b93d:     }
1:67435b5: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:67435b5:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:d2a3827:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));
1:67435b5:     }
1:67435b5: 
1:507ed14:     @Test
1:6f5d8a5:     public void testThriftConversion() throws Exception
1:67435b5:     {
1:38e3e85:         CfDef cfDef = new CfDef().setDefault_validation_class(AsciiType.class.getCanonicalName())
1:38e3e85:                                  .setComment("Test comment")
1:38e3e85:                                  .setColumn_metadata(columnDefs)
1:d2a3827:                                  .setKeyspace(KEYSPACE1)
1:d2a3827:                                  .setName(CF_STANDARD1);
1:8a1b93d: 
1:38e3e85:         // convert Thrift to CFMetaData
1:a94b173:         CFMetaData cfMetaData = ThriftConversion.fromThrift(cfDef);
1:38e3e85: 
1:37b0793:         CfDef thriftCfDef = new CfDef();
1:d2a3827:         thriftCfDef.keyspace = KEYSPACE1;
1:d2a3827:         thriftCfDef.name = CF_STANDARD1;
1:37b0793:         thriftCfDef.default_validation_class = cfDef.default_validation_class;
1:37b0793:         thriftCfDef.comment = cfDef.comment;
1:a94b173:         thriftCfDef.column_metadata = new ArrayList<>();
1:38e3e85:         for (ColumnDef columnDef : columnDefs)
4:38e3e85:         {
1:37b0793:             ColumnDef c = new ColumnDef();
1:38e3e85:             c.name = ByteBufferUtil.clone(columnDef.name);
1:37b0793:             c.validation_class = columnDef.getValidation_class();
1:37b0793:             c.index_name = columnDef.getIndex_name();
1:37b0793:             c.index_type = IndexType.KEYS;
1:37b0793:             thriftCfDef.column_metadata.add(c);
1:67435b5:         }
1:38e3e85: 
1:a94b173:         CfDef converted = ThriftConversion.toThrift(cfMetaData);
1:38e3e85: 
1:37b0793:         assertEquals(thriftCfDef.keyspace, converted.keyspace);
1:37b0793:         assertEquals(thriftCfDef.name, converted.name);
1:37b0793:         assertEquals(thriftCfDef.default_validation_class, converted.default_validation_class);
1:37b0793:         assertEquals(thriftCfDef.comment, converted.comment);
1:362cc05:         assertEquals(new HashSet<>(thriftCfDef.column_metadata), new HashSet<>(converted.column_metadata));
1:d2a3827:     }
1:86637d4: 
1:86637d4:     @Test
1:86637d4:     public void testConversionsInverses() throws Exception
1:86637d4:     {
1:0e96e58:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:86637d4:         {
1:0e96e58:             for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
1:86637d4:             {
1:86637d4:                 CFMetaData cfm = cfs.metadata;
1:362cc05:                 if (!cfm.isThriftCompatible())
1:362cc05:                     continue;
1:362cc05: 
1:86637d4:                 checkInverses(cfm);
1:86637d4: 
1:86637d4:                 // Testing with compression to catch #3558
1:69bfca0:                 CFMetaData withCompression = cfm.copy();
1:b31845c:                 withCompression.compression(CompressionParams.snappy(32768));
1:86637d4:                 checkInverses(withCompression);
1:86637d4:             }
1:86637d4:         }
1:86637d4:     }
1:86637d4: 
1:38e3e85:     @Test
1:507ed14:     public void testExtensions() throws IOException
1:507ed14:     {
1:507ed14:         String keyspace = "SandBox";
1:507ed14: 
1:507ed14:         createTable(keyspace, "CREATE TABLE test (a text primary key, b int, c int)");
1:507ed14: 
1:507ed14:         CFMetaData metadata = Schema.instance.getCFMetaData(keyspace, "test");
1:507ed14:         assertTrue("extensions should be empty", metadata.params.extensions.isEmpty());
1:507ed14: 
1:507ed14:         ImmutableMap<String, ByteBuffer> extensions = ImmutableMap.of("From ... with Love",
1:507ed14:                                                                       ByteBuffer.wrap(new byte[]{0, 0, 7}));
1:507ed14: 
1:507ed14:         CFMetaData copy = metadata.copy().extensions(extensions);
1:507ed14: 
1:507ed14:         updateTable(keyspace, metadata, copy);
1:507ed14: 
1:507ed14:         metadata = Schema.instance.getCFMetaData(keyspace, "test");
1:507ed14:         assertEquals(extensions, metadata.params.extensions);
1:507ed14:     }
1:507ed14: 
1:340df43:     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable)
1:507ed14:     {
1:507ed14:         KeyspaceMetadata ksm = Schema.instance.getKeyspaceInstance(keyspace).getMetadata();
1:2683806:         Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros()).build();
1:5c2912d:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
1:507ed14:     }
1:507ed14: 
1:340df43:     private static void createTable(String keyspace, String cql)
1:507ed14:     {
1:507ed14:         CFMetaData table = CFMetaData.compile(cql, keyspace);
1:507ed14: 
1:507ed14:         KeyspaceMetadata ksm = KeyspaceMetadata.create(keyspace, KeyspaceParams.simple(1), Tables.of(table));
1:2683806:         Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros()).build();
1:5c2912d:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
1:507ed14:     }
1:507ed14: 
1:7d6c876:     private static void checkInverses(CFMetaData cfm) throws Exception
1:86637d4:     {
1:a89597d:         KeyspaceMetadata keyspace = Schema.instance.getKSMetaData(cfm.ksName);
1:38e3e85: 
1:86637d4:         // Test thrift conversion
1:362cc05:         CFMetaData before = cfm;
1:a94b173:         CFMetaData after = ThriftConversion.fromThriftForUpdate(ThriftConversion.toThrift(before), before);
1:6609029:         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
1:86637d4: 
1:86637d4:         // Test schema conversion
1:2683806:         Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
1:9797511:         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES));
1:9797511:         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.COLUMNS));
1:340df43: 
1:9797511:         UntypedResultSet.Row tableRow = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES),
1:340df43:                                                                  UnfilteredRowIterators.filter(serializedCf.unfilteredIterator(), FBUtilities.nowInSeconds()))
1:340df43:                                                       .one();
1:340df43:         TableParams params = SchemaKeyspace.createTableParamsFromRow(tableRow);
1:340df43: 
1:9797511:         UntypedResultSet columnsRows = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.COLUMNS),
1:340df43:                                                                 UnfilteredRowIterators.filter(serializedCD.unfilteredIterator(), FBUtilities.nowInSeconds()));
1:340df43:         Set<ColumnDefinition> columns = new HashSet<>();
1:340df43:         for (UntypedResultSet.Row row : columnsRows)
1:340df43:             columns.add(SchemaKeyspace.createColumnFromRow(row, Types.none()));
1:340df43: 
1:340df43:         assertEquals(cfm.params, params);
1:340df43:         assertEquals(new HashSet<>(cfm.allColumns()), columns);
1:86637d4:     }
4:38e3e85: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES));
1:         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.COLUMNS));
1:         UntypedResultSet.Row tableRow = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.TABLES),
1:         UntypedResultSet columnsRows = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.COLUMNS),
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:2683806
/////////////////////////////////////////////////////////////////////////
1:         Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros()).build();
/////////////////////////////////////////////////////////////////////////
1:         Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros()).build();
/////////////////////////////////////////////////////////////////////////
1:         Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:3079ae6
commit:340df43
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.UntypedResultSet;
/////////////////////////////////////////////////////////////////////////
1:     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable)
1:     private static void createTable(String keyspace, String cql)
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
0:         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
1: 
0:         UntypedResultSet.Row tableRow = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaKeyspace.NAME, SchemaKeyspace.TABLES),
1:                                                                  UnfilteredRowIterators.filter(serializedCf.unfilteredIterator(), FBUtilities.nowInSeconds()))
1:                                                       .one();
1:         TableParams params = SchemaKeyspace.createTableParamsFromRow(tableRow);
1: 
0:         UntypedResultSet columnsRows = QueryProcessor.resultify(String.format("SELECT * FROM %s.%s", SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS),
1:                                                                 UnfilteredRowIterators.filter(serializedCD.unfilteredIterator(), FBUtilities.nowInSeconds()));
1:         Set<ColumnDefinition> columns = new HashSet<>();
1:         for (UntypedResultSet.Row row : columnsRows)
1:             columns.add(SchemaKeyspace.createColumnFromRow(row, Types.none()));
1: 
1:         assertEquals(cfm.params, params);
1:         assertEquals(new HashSet<>(cfm.allColumns()), columns);
commit:b31845c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 withCompression.compression(CompressionParams.snappy(32768));
commit:7d6c876
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.schema;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.SchemaKeyspace;
/////////////////////////////////////////////////////////////////////////
1: public class SchemaKeyspaceTest
1:     private static final List<ColumnDef> columnDefs = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:                 withCompression.compressionParameters(new CompressionParameters(SnappyCompressor.instance, 32768, new HashMap<>()));
1:     private static void checkInverses(CFMetaData cfm) throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
0:         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SystemKeyspace.NAME, SchemaKeyspace.TABLES));
0:         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SystemKeyspace.NAME, SchemaKeyspace.COLUMNS));
0:         CFMetaData newCfm = SchemaKeyspace.createTableFromTablePartitionAndColumnsPartition(UnfilteredRowIterators.filter(serializedCf.unfilteredIterator(), FBUtilities.nowInSeconds()),
0:                                                                                             UnfilteredRowIterators.filter(serializedCD.unfilteredIterator(), FBUtilities.nowInSeconds()));
commit:a89597d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata keyspace = Schema.instance.getKSMetaData(cfm.ksName);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:3e9d345
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.LegacySchemaTables;
1: import org.apache.cassandra.utils.FBUtilities;
1: 
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData keyspace = Schema.instance.getKSMetaData(cfm.ksName);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = LegacySchemaTables.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
0:         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(SystemKeyspace.NAME, LegacySchemaTables.COLUMNFAMILIES));
0:         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(SystemKeyspace.NAME, LegacySchemaTables.COLUMNS));
0:         CFMetaData newCfm = LegacySchemaTables.createTableFromTablePartitionAndColumnsPartition(new Row(k, serializedCf), new Row(k, serializedCD));
commit:611d1ba
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(SystemKeyspace.NAME, SystemKeyspace.SCHEMA_COLUMNFAMILIES_TABLE));
0:         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(SystemKeyspace.NAME, SystemKeyspace.SCHEMA_COLUMNS_TABLE));
commit:a94b173
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.thrift.ThriftConversion;
/////////////////////////////////////////////////////////////////////////
1:         CFMetaData cfMetaData = ThriftConversion.fromThrift(cfDef);
1:         thriftCfDef.column_metadata = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         CfDef converted = ThriftConversion.toThrift(cfMetaData);
/////////////////////////////////////////////////////////////////////////
1:         CFMetaData after = ThriftConversion.fromThriftForUpdate(ThriftConversion.toThrift(before), before);
commit:69bfca0
/////////////////////////////////////////////////////////////////////////
1:                 CFMetaData withCompression = cfm.copy();
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = cfm.toSchema(System.currentTimeMillis());
commit:a965977
/////////////////////////////////////////////////////////////////////////
0:         CFMetaData newCfm = CFMetaData.addColumnDefinitionsFromSchema(CFMetaData.fromSchemaNoColumnsNoTriggers(result), new Row(k, serializedCD));
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.*;
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(Keyspace.SYSTEM_KS, SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF));
0:         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(Keyspace.SYSTEM_KS, SystemKeyspace.SCHEMA_COLUMNS_CF));
commit:6f5d8a5
/////////////////////////////////////////////////////////////////////////
1:     public void testThriftConversion() throws Exception
/////////////////////////////////////////////////////////////////////////
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5c2912d
/////////////////////////////////////////////////////////////////////////
1:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
/////////////////////////////////////////////////////////////////////////
1:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
author:blerer
-------------------------------------------------------------------------------
commit:507ed14
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.Collections;
1: import java.util.List;
1: 
1: import com.google.common.collect.ImmutableMap;
1: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: import org.apache.cassandra.db.ColumnFamilyStore;
1: import org.apache.cassandra.db.Keyspace;
1: import org.apache.cassandra.db.Mutation;
0: import org.apache.cassandra.db.SystemKeyspace;
1: import org.apache.cassandra.db.partitions.PartitionUpdate;
1: import org.apache.cassandra.db.rows.UnfilteredRowIterators;
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testExtensions() throws IOException
1:     {
1:         String keyspace = "SandBox";
1: 
1:         createTable(keyspace, "CREATE TABLE test (a text primary key, b int, c int)");
1: 
1:         CFMetaData metadata = Schema.instance.getCFMetaData(keyspace, "test");
1:         assertTrue("extensions should be empty", metadata.params.extensions.isEmpty());
1: 
1:         ImmutableMap<String, ByteBuffer> extensions = ImmutableMap.of("From ... with Love",
1:                                                                       ByteBuffer.wrap(new byte[]{0, 0, 7}));
1: 
1:         CFMetaData copy = metadata.copy().extensions(extensions);
1: 
1:         updateTable(keyspace, metadata, copy);
1: 
1:         metadata = Schema.instance.getCFMetaData(keyspace, "test");
1:         assertEquals(extensions, metadata.params.extensions);
1:     }
1: 
0:     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable) throws IOException
1:     {
1:         KeyspaceMetadata ksm = Schema.instance.getKeyspaceInstance(keyspace).getMetadata();
0:         Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros(), false);
0:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation), true);
1:     }
1: 
0:     private static void createTable(String keyspace, String cql) throws IOException
1:     {
1:         CFMetaData table = CFMetaData.compile(cql, keyspace);
1: 
1:         KeyspaceMetadata ksm = KeyspaceMetadata.create(keyspace, KeyspaceParams.simple(1), Tables.of(table));
0:         Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros());
0:         SchemaKeyspace.mergeSchema(Collections.singleton(mutation), true);
1:     }
1: 
commit:056115f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 withCompression.compressionParameters(CompressionParameters.snappy(32768));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.rows.UnfilteredRowIterators;
0: import org.apache.cassandra.db.partitions.PartitionUpdate;
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SystemKeyspace.NAME, LegacySchemaTables.COLUMNFAMILIES));
0:         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SystemKeyspace.NAME, LegacySchemaTables.COLUMNS));
0:         CFMetaData newCfm = LegacySchemaTables.createTableFromTablePartitionAndColumnsPartition(UnfilteredRowIterators.filter(serializedCf.unfilteredIterator(), FBUtilities.nowInSeconds()),
0:                                                                                                 UnfilteredRowIterators.filter(serializedCD.unfilteredIterator(), FBUtilities.nowInSeconds()));
commit:2269adb
commit:b433722
commit:362cc05
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new HashSet<>(thriftCfDef.column_metadata), new HashSet<>(converted.column_metadata));
/////////////////////////////////////////////////////////////////////////
1:                 if (!cfm.isThriftCompatible())
1:                     continue;
1: 
/////////////////////////////////////////////////////////////////////////
1:         CFMetaData before = cfm;
0:         CFMetaData after = CFMetaData.fromThrift(before.toThrift());
/////////////////////////////////////////////////////////////////////////
0:         CFMetaData newCfm = CFMetaData.fromSchemaNoTriggers(result, ColumnDefinition.resultify(new Row(k, serializedCD)));
commit:67435b5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:     private static CFMetaData withoutThriftIncompatible(CFMetaData cfm)
1:     {
0:         CFMetaData result = cfm.clone();
1: 
0:         // This is a nasty hack to work around the fact that in thrift we exposes:
0:         //   - neither definition with a non-nulll componentIndex
0:         //   - nor non REGULAR definitions.
0:         Iterator<ColumnDefinition> iter = result.allColumns().iterator();
0:         while (iter.hasNext())
1:         {
0:             ColumnDefinition def = iter.next();
0:             // Remove what we know is not thrift compatible
0:             if (!def.isThriftCompatible())
0:                 iter.remove();
1:         }
0:         return result;
1:     }
1: 
0:         CFMetaData before = withoutThriftIncompatible(cfm);
0:         CFMetaData after = withoutThriftIncompatible(CFMetaData.fromThrift(before.toThrift()));
0:         assert before.equals(after) : String.format("\n%s\n!=\n%s", before, after);
commit:a950b92
/////////////////////////////////////////////////////////////////////////
0:         for (ColumnDefinition def: cfm.allColumns())
0:             // Remove what we know is not thrift compatible
0:             if (!def.isThriftCompatible())
0:                 cfm.removeColumnDefinition(def);
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class CFMetaDataTest extends SchemaLoader
commit:86637d4
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.config.Schema;
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.RowMutation;
0: import org.apache.cassandra.db.SystemTable;
0: import org.apache.cassandra.db.Table;
0: import org.apache.cassandra.io.compress.*;
/////////////////////////////////////////////////////////////////////////
0: public class CFMetaDataTest extends CleanupHelper
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testConversionsInverses() throws Exception
1:     {
0:         for (String table : Schema.instance.getNonSystemTables())
1:         {
0:             for (ColumnFamilyStore cfs : Table.open(table).getColumnFamilyStores())
1:             {
1:                 CFMetaData cfm = cfs.metadata;
1:                 checkInverses(cfm);
1: 
1:                 // Testing with compression to catch #3558
0:                 CFMetaData withCompression = CFMetaData.rename(cfm, cfm.cfName); // basically a clone
0:                 withCompression.compressionParameters(new CompressionParameters(SnappyCompressor.instance, 32768, new HashMap<String, String>()));
1:                 checkInverses(withCompression);
1:             }
1:         }
1:     }
1: 
0:     private void checkInverses(CFMetaData cfm) throws Exception
1:     {
1:         // Test thrift conversion
0:         assert cfm.equals(CFMetaData.fromThrift(cfm.toThrift())) : String.format("\n%s\n!=\n%s", cfm, CFMetaData.fromThrift(cfm.toThrift()));
1: 
1:         // Test schema conversion
0:         RowMutation rm = cfm.toSchema(System.currentTimeMillis());
0:         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_TABLE, SystemTable.SCHEMA_COLUMNFAMILIES_CF));
0:         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_TABLE, SystemTable.SCHEMA_COLUMNS_CF));
0:         CfDef cfDef = CFMetaData.addColumnDefinitionSchema(CFMetaData.fromSchema(serializedCf), serializedCD);
0:         assert cfm.equals(CFMetaData.fromThrift(cfDef)) : String.format("\n%s\n!=\n%s", cfm, CFMetaData.fromThrift(cfDef));
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:11dfc02
/////////////////////////////////////////////////////////////////////////
0: public class LegacySchemaTablesTest
commit:8a1b93d
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:         // This is a nasty hack to work around the fact that non-null componentIndex 
0:         // are only used by CQL (so far) so we don't expose them through thrift
0:         // There is a CFM with componentIndex defined in Keyspace2 which is used by 
0:         // ColumnFamilyStoreTest to verify index repair (CASSANDRA-2897)
0:         for (Map.Entry<ByteBuffer, ColumnDefinition> cMeta: cfm.column_metadata.entrySet())
1:         {
0:             // Non-null componentIndex are only used by CQL (so far) so we don't expose
0:             // them through thrift
0:             if (cMeta.getValue().componentIndex != null)
0:                 cfm.column_metadata.remove(cMeta.getKey());
1:         }
1: 
commit:5c94432
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_KS, SystemTable.SCHEMA_COLUMNFAMILIES_CF));
0:         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_KS, SystemTable.SCHEMA_COLUMNS_CF));
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.QueryProcessor;
0: import org.apache.cassandra.cql3.UntypedResultSet;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.Row;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
0: import java.nio.ByteBuffer;
1: 
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey k = StorageService.getPartitioner().decorateKey(ByteBufferUtil.bytes(cfm.ksName));
1: 
/////////////////////////////////////////////////////////////////////////
0:         UntypedResultSet.Row result = QueryProcessor.resultify("SELECT * FROM system.schema_columnfamilies", new Row(k, serializedCf)).one();
0:         CFMetaData newCfm = CFMetaData.addColumnDefinitionSchema(CFMetaData.fromSchemaNoColumns(result), new Row(k, serializedCD));
0:         assert cfm.equals(newCfm) : String.format("\n%s\n!=\n%s", cfm, newCfm);
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: import org.junit.BeforeClass;
0: public class CFMetaDataTest
1:     private static final String KEYSPACE1 = "CFMetaDataTest1";
1:     private static final String CF_STANDARD1 = "Standard1";
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));
1:     }
1: 
1:                                  .setKeyspace(KEYSPACE1)
1:                                  .setName(CF_STANDARD1);
1:         thriftCfDef.keyspace = KEYSPACE1;
1:         thriftCfDef.name = CF_STANDARD1;
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:ea565aa
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData withCompression = cfm.clone();
author:Dave Brosius
-------------------------------------------------------------------------------
commit:6609029
/////////////////////////////////////////////////////////////////////////
1:         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
/////////////////////////////////////////////////////////////////////////
0:         assert cfm.equals(newCfm) : String.format("%n%s%n!=%n%s", cfm, newCfm);
commit:bc6b5f4
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:37b0793
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         CfDef thriftCfDef = new CfDef();
0:         thriftCfDef.keyspace = KEYSPACE;
0:         thriftCfDef.name = COLUMN_FAMILY;
1:         thriftCfDef.default_validation_class = cfDef.default_validation_class;
1:         thriftCfDef.comment = cfDef.comment;
0:         thriftCfDef.column_metadata = new ArrayList<ColumnDef>();
1:             ColumnDef c = new ColumnDef();
1:             c.validation_class = columnDef.getValidation_class();
1:             c.index_name = columnDef.getIndex_name();
1:             c.index_type = IndexType.KEYS;
1:             thriftCfDef.column_metadata.add(c);
0:         CfDef converted = cfMetaData.toThrift();
1:         assertEquals(thriftCfDef.keyspace, converted.keyspace);
1:         assertEquals(thriftCfDef.name, converted.name);
1:         assertEquals(thriftCfDef.default_validation_class, converted.default_validation_class);
1:         assertEquals(thriftCfDef.comment, converted.comment);
0:         assertEquals(thriftCfDef.column_metadata, converted.column_metadata);
commit:38e3e85
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.cassandra.config;
1: 
1: import java.util.ArrayList;
0: import java.util.List;
1: 
0: import org.apache.avro.util.Utf8;
1: import org.apache.cassandra.db.marshal.AsciiType;
1: import org.apache.cassandra.db.marshal.UTF8Type;
1: import org.apache.cassandra.thrift.CfDef;
1: import org.apache.cassandra.thrift.ColumnDef;
1: import org.apache.cassandra.thrift.IndexType;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: import org.junit.Test;
1: 
1: import static org.junit.Assert.assertEquals;
1: 
0: public class CFMetaDataTest
1: {
0:     private static String KEYSPACE = "Keyspace1";
0:     private static String COLUMN_FAMILY = "Standard1";
1: 
0:     private static List<ColumnDef> columnDefs = new ArrayList<ColumnDef>();
1: 
1:     static
1:     {
1:         columnDefs.add(new ColumnDef(ByteBufferUtil.bytes("col1"), AsciiType.class.getCanonicalName())
1:                                     .setIndex_name("col1Index")
1:                                     .setIndex_type(IndexType.KEYS));
1: 
1:         columnDefs.add(new ColumnDef(ByteBufferUtil.bytes("col2"), UTF8Type.class.getCanonicalName())
1:                                     .setIndex_name("col2Index")
1:                                     .setIndex_type(IndexType.KEYS));
1:     }
1: 
1:     @Test
0:     public void testThriftToAvroConversion() throws Exception
1:     {
1:         CfDef cfDef = new CfDef().setDefault_validation_class(AsciiType.class.getCanonicalName())
1:                                  .setComment("Test comment")
1:                                  .setColumn_metadata(columnDefs)
0:                                  .setKeyspace(KEYSPACE)
0:                                  .setName(COLUMN_FAMILY);
1: 
1:         // convert Thrift to CFMetaData
0:         CFMetaData cfMetaData = CFMetaData.fromThrift(cfDef);
1: 
0:         // make a correct Avro object
0:         org.apache.cassandra.db.migration.avro.CfDef avroCfDef = new org.apache.cassandra.db.migration.avro.CfDef();
0:         avroCfDef.keyspace = new Utf8(KEYSPACE);
0:         avroCfDef.name = new Utf8(COLUMN_FAMILY);
0:         avroCfDef.default_validation_class = new Utf8(cfDef.default_validation_class);
0:         avroCfDef.comment = new Utf8(cfDef.comment);
0:         avroCfDef.column_metadata = new ArrayList<org.apache.cassandra.db.migration.avro.ColumnDef>();
1:         for (ColumnDef columnDef : columnDefs)
1:         {
0:             org.apache.cassandra.db.migration.avro.ColumnDef c = new org.apache.cassandra.db.migration.avro.ColumnDef();
1:             c.name = ByteBufferUtil.clone(columnDef.name);
0:             c.validation_class = new Utf8(columnDef.getValidation_class());
0:             c.index_name = new Utf8(columnDef.getIndex_name());
0:             c.index_type = org.apache.cassandra.db.migration.avro.IndexType.KEYS;
0:             avroCfDef.column_metadata.add(c);
1:         }
1: 
0:         org.apache.cassandra.db.migration.avro.CfDef converted = cfMetaData.toAvro();
1: 
0:         assertEquals(avroCfDef.keyspace, converted.keyspace);
0:         assertEquals(avroCfDef.name, converted.name);
0:         assertEquals(avroCfDef.default_validation_class, converted.default_validation_class);
0:         assertEquals(avroCfDef.comment, converted.comment);
0:         assertEquals(avroCfDef.column_metadata, converted.column_metadata);
1:     }
1: }
============================================================================