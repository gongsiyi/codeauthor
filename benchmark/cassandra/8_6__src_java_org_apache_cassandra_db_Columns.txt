1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
3:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
2:a991b64:  */
1:a991b64: package org.apache.cassandra.db;
14:a991b64: 
1:a991b64: import java.io.IOException;
1:a991b64: import java.util.*;
1:dc9ed46: import java.util.function.Consumer;
1:2457599: import java.util.function.Predicate;
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.security.MessageDigest;
1:a991b64: 
1:ace28c9: import com.google.common.collect.ImmutableList;
1:a991b64: import com.google.common.collect.Iterators;
1:a991b64: 
1:fe388d4: import net.nicoulaj.compilecommand.annotations.DontInline;
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:ace28c9: import org.apache.cassandra.cql3.ColumnIdentifier;
1:ace28c9: import org.apache.cassandra.db.marshal.SetType;
1:a991b64: import org.apache.cassandra.db.marshal.UTF8Type;
1:2fea59d: import org.apache.cassandra.io.util.DataInputPlus;
1:a991b64: import org.apache.cassandra.io.util.DataOutputPlus;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:ace28c9: import org.apache.cassandra.utils.SearchIterator;
1:ace28c9: import org.apache.cassandra.utils.btree.BTree;
1:ace28c9: import org.apache.cassandra.utils.btree.BTreeSearchIterator;
1:1c62850: import org.apache.cassandra.utils.btree.BTreeRemoval;
1:e51f83b: import org.apache.cassandra.utils.btree.UpdateFunction;
1:a991b64: 
2:a991b64: /**
1:a991b64:  * An immutable and sorted list of (non-PK) columns for a given table.
1:a991b64:  * <p>
1:a991b64:  * Note that in practice, it will either store only static columns, or only regular ones. When
1:a991b64:  * we need both type of columns, we use a {@link PartitionColumns} object.
1:a991b64:  */
1:0d74c3e: public class Columns extends AbstractCollection<ColumnDefinition> implements Collection<ColumnDefinition>
23:a991b64: {
1:a991b64:     public static final Serializer serializer = new Serializer();
1:ace28c9:     public static final Columns NONE = new Columns(BTree.empty(), 0);
1:0790e48:     public static final ColumnDefinition FIRST_COMPLEX =
1:0790e48:         new ColumnDefinition("",
1:0790e48:                              "",
1:0790e48:                              ColumnIdentifier.getInterned(ByteBufferUtil.EMPTY_BYTE_BUFFER, UTF8Type.instance),
1:0790e48:                              SetType.getInstance(UTF8Type.instance, true),
1:0790e48:                              ColumnDefinition.NO_POSITION,
1:0790e48:                              ColumnDefinition.Kind.REGULAR);
1:a991b64: 
1:ace28c9:     private final Object[] columns;
1:ace28c9:     private final int complexIdx; // Index of the first complex column
1:a991b64: 
1:ace28c9:     private Columns(Object[] columns, int complexIdx)
1:a991b64:     {
1:ace28c9:         assert complexIdx <= BTree.size(columns);
1:a991b64:         this.columns = columns;
1:a991b64:         this.complexIdx = complexIdx;
21:a991b64:     }
1:a991b64: 
1:ace28c9:     private Columns(Object[] columns)
1:fe388d4:     {
1:a991b64:         this(columns, findFirstComplexIdx(columns));
1:fe388d4:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Creates a {@code Columns} holding only the one column provided.
1:a991b64:      *
1:a991b64:      * @param c the column for which to create a {@code Columns} object.
1:a991b64:      *
1:a991b64:      * @return the newly created {@code Columns} containing only {@code c}.
1:a991b64:      */
1:a991b64:     public static Columns of(ColumnDefinition c)
1:2457599:     {
1:ace28c9:         return new Columns(BTree.singleton(c), c.isComplex() ? 0 : 1);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns a new {@code Columns} object holing the same columns than the provided set.
1:a991b64:      *
1:ace28c9:      * @param s the set from which to create the new {@code Columns}.
1:a991b64:      * @return the newly created {@code Columns} containing the columns from {@code s}.
1:a991b64:      */
1:aa57626:     public static Columns from(Collection<ColumnDefinition> s)
1:a991b64:     {
1:ace28c9:         Object[] tree = BTree.<ColumnDefinition>builder(Comparator.naturalOrder()).addAll(s).build();
1:ace28c9:         return new Columns(tree, findFirstComplexIdx(tree));
1:a991b64:     }
1:a991b64: 
1:ace28c9:     private static int findFirstComplexIdx(Object[] tree)
1:a991b64:     {
1:ace28c9:         // have fast path for common no-complex case
1:ace28c9:         int size = BTree.size(tree);
1:ace28c9:         if (!BTree.isEmpty(tree) && BTree.<ColumnDefinition>findByIndex(tree, size - 1).isSimple())
1:ace28c9:             return size;
1:ace28c9:         return BTree.ceilIndex(tree, Comparator.naturalOrder(), FIRST_COMPLEX);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether this columns is empty.
1:a991b64:      *
1:a991b64:      * @return whether this columns is empty.
1:a991b64:      */
1:a991b64:     public boolean isEmpty()
1:a991b64:     {
1:ace28c9:         return BTree.isEmpty(columns);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The number of simple columns in this object.
1:a991b64:      *
1:a991b64:      * @return the number of simple columns in this object.
1:a991b64:      */
1:a991b64:     public int simpleColumnCount()
1:a991b64:     {
1:a991b64:         return complexIdx;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The number of complex columns (non-frozen collections, udts, ...) in this object.
1:a991b64:      *
1:a991b64:      * @return the number of complex columns in this object.
1:a991b64:      */
1:a991b64:     public int complexColumnCount()
1:a991b64:     {
1:ace28c9:         return BTree.size(columns) - complexIdx;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The total number of columns in this object.
1:a991b64:      *
1:a991b64:      * @return the total number of columns in this object.
1:a991b64:      */
1:0d74c3e:     public int size()
1:a991b64:     {
1:ace28c9:         return BTree.size(columns);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether this objects contains simple columns.
1:a991b64:      *
1:a991b64:      * @return whether this objects contains simple columns.
1:a991b64:      */
1:a991b64:     public boolean hasSimple()
1:a991b64:     {
1:a991b64:         return complexIdx > 0;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether this objects contains complex columns.
1:a991b64:      *
1:a991b64:      * @return whether this objects contains complex columns.
1:a991b64:      */
1:a991b64:     public boolean hasComplex()
1:a991b64:     {
1:ace28c9:         return complexIdx < BTree.size(columns);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the ith simple column of this object.
1:a991b64:      *
1:a991b64:      * @param i the index for the simple column to fectch. This must
1:a991b64:      * satisfy {@code 0 <= i < simpleColumnCount()}.
1:a991b64:      *
1:a991b64:      * @return the {@code i}th simple column in this object.
1:a991b64:      */
1:a991b64:     public ColumnDefinition getSimple(int i)
1:a991b64:     {
1:ace28c9:         return BTree.findByIndex(columns, i);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the ith complex column of this object.
1:a991b64:      *
1:a991b64:      * @param i the index for the complex column to fectch. This must
1:a991b64:      * satisfy {@code 0 <= i < complexColumnCount()}.
1:a991b64:      *
1:a991b64:      * @return the {@code i}th complex column in this object.
1:a991b64:      */
1:a991b64:     public ColumnDefinition getComplex(int i)
1:a991b64:     {
1:ace28c9:         return BTree.findByIndex(columns, complexIdx + i);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The index of the provided simple column in this object (if it contains
1:a991b64:      * the provided column).
1:a991b64:      *
1:a991b64:      * @param c the simple column for which to return the index of.
1:a991b64:      *
1:a991b64:      * @return the index for simple column {@code c} if it is contains in this
1:ace28c9:      * object
1:a991b64:      */
1:ace28c9:     public int simpleIdx(ColumnDefinition c)
1:a991b64:     {
1:ace28c9:         return BTree.findIndex(columns, Comparator.naturalOrder(), c);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * The index of the provided complex column in this object (if it contains
1:a991b64:      * the provided column).
1:a991b64:      *
1:a991b64:      * @param c the complex column for which to return the index of.
1:a991b64:      *
1:a991b64:      * @return the index for complex column {@code c} if it is contains in this
1:ace28c9:      * object
1:a991b64:      */
1:ace28c9:     public int complexIdx(ColumnDefinition c)
1:a991b64:     {
1:ace28c9:         return BTree.findIndex(columns, Comparator.naturalOrder(), c) - complexIdx;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether the provided column is contained by this object.
1:a991b64:      *
1:a991b64:      * @param c the column to check presence of.
1:a991b64:      *
1:a991b64:      * @return whether {@code c} is contained by this object.
1:a991b64:      */
1:a991b64:     public boolean contains(ColumnDefinition c)
1:a991b64:     {
1:ace28c9:         return BTree.findIndex(columns, Comparator.naturalOrder(), c) >= 0;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the result of merging this {@code Columns} object with the
1:a991b64:      * provided one.
1:a991b64:      *
1:a991b64:      * @param other the other {@code Columns} to merge this object with.
1:a991b64:      *
1:a991b64:      * @return the result of merging/taking the union of {@code this} and
1:a991b64:      * {@code other}. The returned object may be one of the operand and that
1:a991b64:      * operand is a subset of the other operand.
1:a991b64:      */
1:a991b64:     public Columns mergeTo(Columns other)
1:a991b64:     {
1:a991b64:         if (this == other || other == NONE)
1:a991b64:             return this;
1:a991b64:         if (this == NONE)
1:a991b64:             return other;
1:a991b64: 
1:e51f83b:         Object[] tree = BTree.<ColumnDefinition>merge(this.columns, other.columns, Comparator.naturalOrder(),
1:e51f83b:                                                       UpdateFunction.noOp());
1:ace28c9:         if (tree == this.columns)
1:ace28c9:             return this;
1:ace28c9:         if (tree == other.columns)
1:ace28c9:             return other;
1:a991b64: 
1:ace28c9:         return new Columns(tree, findFirstComplexIdx(tree));
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:2457599:      * Whether this object is a superset of the provided other {@code Columns object}.
1:a991b64:      *
1:2457599:      * @param other the other object to test for inclusion in this object.
1:a991b64:      *
1:a991b64:      * @return whether all the columns of {@code other} are contained by this object.
1:a991b64:      */
1:0d74c3e:     public boolean containsAll(Collection<?> other)
1:a991b64:     {
1:0d74c3e:         if (other == this)
1:0d74c3e:             return true;
1:0d74c3e:         if (other.size() > this.size())
1:2457599:             return false;
1:a991b64: 
1:ace28c9:         BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
1:0d74c3e:         for (Object def : other)
1:0d74c3e:             if (iter.next((ColumnDefinition) def) == null)
4:a991b64:                 return false;
1:2457599:         return true;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Iterator over the simple columns of this object.
1:a991b64:      *
1:a991b64:      * @return an iterator over the simple columns of this object.
1:a991b64:      */
1:a991b64:     public Iterator<ColumnDefinition> simpleColumns()
1:a991b64:     {
1:ace28c9:         return BTree.iterator(columns, 0, complexIdx - 1, BTree.Dir.ASC);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Iterator over the complex columns of this object.
1:a991b64:      *
1:a991b64:      * @return an iterator over the complex columns of this object.
1:a991b64:      */
1:a991b64:     public Iterator<ColumnDefinition> complexColumns()
1:a991b64:     {
1:ace28c9:         return BTree.iterator(columns, complexIdx, BTree.size(columns) - 1, BTree.Dir.ASC);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Iterator over all the columns of this object.
1:a991b64:      *
1:a991b64:      * @return an iterator over all the columns of this object.
1:a991b64:      */
1:fe388d4:     public BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iterator()
1:a991b64:     {
1:fe388d4:         return BTree.<ColumnDefinition, ColumnDefinition>slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * An iterator that returns the columns of this object in "select" order (that
1:a991b64:      * is in global alphabetical order, where the "normal" iterator returns simple
1:a991b64:      * columns first and the complex second).
1:a991b64:      *
1:a991b64:      * @return an iterator returning columns in alphabetical order.
1:a991b64:      */
1:a991b64:     public Iterator<ColumnDefinition> selectOrderIterator()
1:a991b64:     {
1:a991b64:         // In wildcard selection, we want to return all columns in alphabetical order,
1:a991b64:         // irregarding of whether they are complex or not
1:fe388d4:         return Iterators.<ColumnDefinition>
1:fe388d4:                          mergeSorted(ImmutableList.of(simpleColumns(), complexColumns()),
1:fe388d4:                                      (s, c) ->
1:fe388d4:                                      {
1:fe388d4:                                          assert !s.kind.isPrimaryKeyKind();
1:fe388d4:                                          return s.name.bytes.compareTo(c.name.bytes);
1:fe388d4:                                      });
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the equivalent of those columns but with the provided column removed.
1:a991b64:      *
1:a991b64:      * @param column the column to remove.
1:a991b64:      *
1:a991b64:      * @return newly allocated columns containing all the columns of {@code this} expect
1:a991b64:      * for {@code column}.
1:a991b64:      */
1:a991b64:     public Columns without(ColumnDefinition column)
1:a991b64:     {
1:ace28c9:         if (!contains(column))
1:a991b64:             return this;
1:a991b64: 
1:1c62850:         Object[] newColumns = BTreeRemoval.<ColumnDefinition>remove(columns, Comparator.naturalOrder(), column);
1:a991b64:         return new Columns(newColumns);
1:a991b64:     }
1:a991b64: 
1:2457599:     /**
1:2457599:      * Returns a predicate to test whether columns are included in this {@code Columns} object,
1:2457599:      * assuming that tes tested columns are passed to the predicate in sorted order.
1:2457599:      *
1:2457599:      * @return a predicate to test the inclusion of sorted columns in this object.
1:2457599:      */
1:2457599:     public Predicate<ColumnDefinition> inOrderInclusionTester()
1:2457599:     {
1:ace28c9:         SearchIterator<ColumnDefinition, ColumnDefinition> iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
1:ace28c9:         return column -> iter.next(column) != null;
1:2457599:     }
1:2457599: 
1:a991b64:     public void digest(MessageDigest digest)
1:2457599:     {
1:a991b64:         for (ColumnDefinition c : this)
1:a991b64:             digest.update(c.name.bytes.duplicate());
1:2457599:     }
1:2457599: 
1:dc9ed46:     /**
1:dc9ed46:      * Apply a function to each column definition in forwards or reversed order.
1:dc9ed46:      * @param function
1:dc9ed46:      * @param reversed
1:dc9ed46:      */
1:dc9ed46:     public void apply(Consumer<ColumnDefinition> function, boolean reversed)
1:dc9ed46:     {
1:dc9ed46:         BTree.apply(columns, function, reversed);
1:dc9ed46:     }
1:dc9ed46: 
1:a991b64:     @Override
1:a991b64:     public boolean equals(Object other)
1:2457599:     {
1:ace28c9:         if (other == this)
1:ace28c9:             return true;
1:a991b64:         if (!(other instanceof Columns))
1:2457599:             return false;
1:a991b64: 
1:a991b64:         Columns that = (Columns)other;
1:ace28c9:         return this.complexIdx == that.complexIdx && BTree.equals(this.columns, that.columns);
1:2457599:     }
1:a991b64: 
1:a991b64:     @Override
1:a991b64:     public int hashCode()
1:a991b64:     {
1:ace28c9:         return Objects.hash(complexIdx, BTree.hashCode(columns));
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Override
1:a991b64:     public String toString()
1:a991b64:     {
1:0d74c3e:         StringBuilder sb = new StringBuilder("[");
1:a991b64:         boolean first = true;
1:a991b64:         for (ColumnDefinition def : this)
1:a991b64:         {
1:a991b64:             if (first) first = false; else sb.append(" ");
1:a991b64:             sb.append(def.name);
1:a991b64:         }
1:0d74c3e:         return sb.append("]").toString();
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static class Serializer
1:a991b64:     {
1:a991b64:         public void serialize(Columns columns, DataOutputPlus out) throws IOException
1:a991b64:         {
1:649a106:             out.writeUnsignedVInt(columns.size());
1:a991b64:             for (ColumnDefinition column : columns)
1:2fea59d:                 ByteBufferUtil.writeWithVIntLength(column.name.bytes, out);
1:a991b64:         }
1:a991b64: 
1:03f72ac:         public long serializedSize(Columns columns)
1:a991b64:         {
1:649a106:             long size = TypeSizes.sizeofUnsignedVInt(columns.size());
1:a991b64:             for (ColumnDefinition column : columns)
1:2fea59d:                 size += ByteBufferUtil.serializedSizeWithVIntLength(column.name.bytes);
1:a991b64:             return size;
1:a991b64:         }
1:a991b64: 
1:2fea59d:         public Columns deserialize(DataInputPlus in, CFMetaData metadata) throws IOException
1:a991b64:         {
1:649a106:             int length = (int)in.readUnsignedVInt();
1:ace28c9:             BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:ace28c9:             builder.auto(false);
1:a991b64:             for (int i = 0; i < length; i++)
1:a991b64:             {
1:2fea59d:                 ByteBuffer name = ByteBufferUtil.readWithVIntLength(in);
1:a991b64:                 ColumnDefinition column = metadata.getColumnDefinition(name);
1:a991b64:                 if (column == null)
1:a991b64:                 {
1:a991b64:                     // If we don't find the definition, it could be we have data for a dropped column, and we shouldn't
1:a991b64:                     // fail deserialization because of that. So we grab a "fake" ColumnDefinition that ensure proper
1:a991b64:                     // deserialization. The column will be ignore later on anyway.
1:a991b64:                     column = metadata.getDroppedColumnDefinition(name);
1:a991b64:                     if (column == null)
1:a991b64:                         throw new RuntimeException("Unknown column " + UTF8Type.instance.getString(name) + " during deserialization");
1:a991b64:                 }
1:ace28c9:                 builder.add(column);
1:a991b64:             }
1:ace28c9:             return new Columns(builder.build());
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         /**
1:fe388d4:          * If both ends have a pre-shared superset of the columns we are serializing, we can send them much
1:fe388d4:          * more efficiently. Both ends must provide the identically same set of columns.
1:fe388d4:          */
1:0d74c3e:         public void serializeSubset(Collection<ColumnDefinition> columns, Columns superset, DataOutputPlus out) throws IOException
1:fe388d4:         {
1:fe388d4:             /**
1:fe388d4:              * We weight this towards small sets, and sets where the majority of items are present, since
1:fe388d4:              * we expect this to mostly be used for serializing result sets.
1:fe388d4:              *
1:fe388d4:              * For supersets with fewer than 64 columns, we encode a bitmap of *missing* columns,
1:fe388d4:              * which equates to a zero (single byte) when all columns are present, and otherwise
1:fe388d4:              * a positive integer that can typically be vint encoded efficiently.
1:fe388d4:              *
1:fe388d4:              * If we have 64 or more columns, we cannot neatly perform a bitmap encoding, so we just switch
1:fe388d4:              * to a vint encoded set of deltas, either adding or subtracting (whichever is most efficient).
1:fe388d4:              * We indicate this switch by sending our bitmap with every bit set, i.e. -1L
1:fe388d4:              */
1:0d74c3e:             int columnCount = columns.size();
1:0d74c3e:             int supersetCount = superset.size();
1:fe388d4:             if (columnCount == supersetCount)
1:fe388d4:             {
1:fe388d4:                 out.writeUnsignedVInt(0);
1:fe388d4:             }
1:fe388d4:             else if (supersetCount < 64)
1:fe388d4:             {
1:fe388d4:                 out.writeUnsignedVInt(encodeBitmap(columns, superset, supersetCount));
1:fe388d4:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 serializeLargeSubset(columns, columnCount, superset, supersetCount, out);
1:fe388d4:             }
1:fe388d4:         }
1:fe388d4: 
1:0d74c3e:         public long serializedSubsetSize(Collection<ColumnDefinition> columns, Columns superset)
1:fe388d4:         {
1:0d74c3e:             int columnCount = columns.size();
1:0d74c3e:             int supersetCount = superset.size();
1:fe388d4:             if (columnCount == supersetCount)
1:fe388d4:             {
1:fe388d4:                 return TypeSizes.sizeofUnsignedVInt(0);
1:fe388d4:             }
1:fe388d4:             else if (supersetCount < 64)
1:fe388d4:             {
1:fe388d4:                 return TypeSizes.sizeofUnsignedVInt(encodeBitmap(columns, superset, supersetCount));
1:fe388d4:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 return serializeLargeSubsetSize(columns, columnCount, superset, supersetCount);
1:fe388d4:             }
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         public Columns deserializeSubset(Columns superset, DataInputPlus in) throws IOException
1:fe388d4:         {
1:fe388d4:             long encoded = in.readUnsignedVInt();
1:f60322a:             if (encoded == 0L)
1:fe388d4:             {
1:fe388d4:                 return superset;
1:fe388d4:             }
1:0d74c3e:             else if (superset.size() >= 64)
1:f60322a:             {
1:f60322a:                 return deserializeLargeSubset(in, superset, (int) encoded);
1:f60322a:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:fe388d4:                 int firstComplexIdx = 0;
1:fe388d4:                 for (ColumnDefinition column : superset)
1:fe388d4:                 {
1:fe388d4:                     if ((encoded & 1) == 0)
1:fe388d4:                     {
1:fe388d4:                         builder.add(column);
1:fe388d4:                         if (column.isSimple())
1:fe388d4:                             ++firstComplexIdx;
1:fe388d4:                     }
1:fe388d4:                     encoded >>>= 1;
1:fe388d4:                 }
1:fe388d4:                 return new Columns(builder.build(), firstComplexIdx);
1:fe388d4:             }
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         // encodes a 1 bit for every *missing* column, on the assumption presence is more common,
1:fe388d4:         // and because this is consistent with encoding 0 to represent all present
1:0d74c3e:         private static long encodeBitmap(Collection<ColumnDefinition> columns, Columns superset, int supersetCount)
1:fe388d4:         {
1:fe388d4:             long bitmap = 0L;
1:fe388d4:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:fe388d4:             // the index we would encounter next if all columns are present
1:fe388d4:             int expectIndex = 0;
1:fe388d4:             for (ColumnDefinition column : columns)
1:fe388d4:             {
1:fe388d4:                 if (iter.next(column) == null)
1:0d74c3e:                     throw new IllegalStateException(columns + " is not a subset of " + superset);
1:fe388d4: 
1:fe388d4:                 int currentIndex = iter.indexOfCurrent();
1:fe388d4:                 int count = currentIndex - expectIndex;
1:fe388d4:                 // (1L << count) - 1 gives us count bits set at the bottom of the register
1:fe388d4:                 // so << expectIndex moves these bits to start at expectIndex, which is where our missing portion
1:fe388d4:                 // begins (assuming count > 0; if not, we're adding 0 bits, so it's a no-op)
1:fe388d4:                 bitmap |= ((1L << count) - 1) << expectIndex;
1:fe388d4:                 expectIndex = currentIndex + 1;
1:fe388d4:             }
1:fe388d4:             int count = supersetCount - expectIndex;
1:fe388d4:             bitmap |= ((1L << count) - 1) << expectIndex;
1:fe388d4:             return bitmap;
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         @DontInline
1:0d74c3e:         private void serializeLargeSubset(Collection<ColumnDefinition> columns, int columnCount, Columns superset, int supersetCount, DataOutputPlus out) throws IOException
1:fe388d4:         {
1:fe388d4:             // write flag indicating we're in lengthy mode
1:fe388d4:             out.writeUnsignedVInt(supersetCount - columnCount);
1:fe388d4:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:fe388d4:             if (columnCount < supersetCount / 2)
1:fe388d4:             {
1:fe388d4:                 // write present columns
1:fe388d4:                 for (ColumnDefinition column : columns)
1:fe388d4:                 {
1:fe388d4:                     if (iter.next(column) == null)
2:fe388d4:                         throw new IllegalStateException();
1:fe388d4:                     out.writeUnsignedVInt(iter.indexOfCurrent());
1:fe388d4:                 }
1:fe388d4:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 // write missing columns
1:fe388d4:                 int prev = -1;
1:fe388d4:                 for (ColumnDefinition column : columns)
1:fe388d4:                 {
1:fe388d4:                     if (iter.next(column) == null)
1:fe388d4:                         throw new IllegalStateException();
1:fe388d4:                     int cur = iter.indexOfCurrent();
1:fe388d4:                     while (++prev != cur)
1:fe388d4:                         out.writeUnsignedVInt(prev);
1:fe388d4:                 }
1:fe388d4:                 while (++prev != supersetCount)
1:fe388d4:                     out.writeUnsignedVInt(prev);
1:fe388d4:             }
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         @DontInline
1:f60322a:         private Columns deserializeLargeSubset(DataInputPlus in, Columns superset, int delta) throws IOException
1:fe388d4:         {
1:0d74c3e:             int supersetCount = superset.size();
1:fe388d4:             int columnCount = supersetCount - delta;
1:fe388d4: 
1:fe388d4:             BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:fe388d4:             if (columnCount < supersetCount / 2)
1:fe388d4:             {
1:fe388d4:                 for (int i = 0 ; i < columnCount ; i++)
1:fe388d4:                 {
1:fe388d4:                     int idx = (int) in.readUnsignedVInt();
1:fe388d4:                     builder.add(BTree.findByIndex(superset.columns, idx));
1:fe388d4:                 }
1:fe388d4:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 Iterator<ColumnDefinition> iter = superset.iterator();
1:fe388d4:                 int idx = 0;
1:fe388d4:                 int skipped = 0;
1:fe388d4:                 while (true)
1:fe388d4:                 {
1:fe388d4:                     int nextMissingIndex = skipped < delta ? (int)in.readUnsignedVInt() : supersetCount;
1:fe388d4:                     while (idx < nextMissingIndex)
1:fe388d4:                     {
1:fe388d4:                         ColumnDefinition def = iter.next();
1:fe388d4:                         builder.add(def);
1:fe388d4:                         idx++;
1:fe388d4:                     }
1:fe388d4:                     if (idx == supersetCount)
1:fe388d4:                         break;
1:fe388d4:                     iter.next();
1:fe388d4:                     idx++;
1:fe388d4:                     skipped++;
1:fe388d4:                 }
1:fe388d4:             }
1:fe388d4:             return new Columns(builder.build());
1:fe388d4:         }
1:fe388d4: 
1:fe388d4:         @DontInline
1:0d74c3e:         private int serializeLargeSubsetSize(Collection<ColumnDefinition> columns, int columnCount, Columns superset, int supersetCount)
1:fe388d4:         {
1:fe388d4:             // write flag indicating we're in lengthy mode
1:f60322a:             int size = TypeSizes.sizeofUnsignedVInt(supersetCount - columnCount);
1:fe388d4:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:fe388d4:             if (columnCount < supersetCount / 2)
1:fe388d4:             {
1:fe388d4:                 // write present columns
1:fe388d4:                 for (ColumnDefinition column : columns)
1:fe388d4:                 {
1:fe388d4:                     if (iter.next(column) == null)
1:fe388d4:                         throw new IllegalStateException();
1:fe388d4:                     size += TypeSizes.sizeofUnsignedVInt(iter.indexOfCurrent());
1:fe388d4:                 }
1:fe388d4:             }
1:fe388d4:             else
1:fe388d4:             {
1:fe388d4:                 // write missing columns
1:fe388d4:                 int prev = -1;
1:fe388d4:                 for (ColumnDefinition column : columns)
1:fe388d4:                 {
1:fe388d4:                     if (iter.next(column) == null)
1:fe388d4:                         throw new IllegalStateException();
1:fe388d4:                     int cur = iter.indexOfCurrent();
1:fe388d4:                     while (++prev != cur)
1:fe388d4:                         size += TypeSizes.sizeofUnsignedVInt(prev);
1:fe388d4:                 }
1:fe388d4:                 while (++prev != supersetCount)
1:fe388d4:                     size += TypeSizes.sizeofUnsignedVInt(prev);
1:fe388d4:             }
1:fe388d4:             return size;
1:a991b64:         }
1:fe388d4: 
1:a991b64:     }
1:a991b64: }
============================================================================
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: import java.util.function.Consumer;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Apply a function to each column definition in forwards or reversed order.
1:      * @param function
1:      * @param reversed
1:      */
1:     public void apply(Consumer<ColumnDefinition> function, boolean reversed)
1:     {
1:         BTree.apply(columns, function, reversed);
1:     }
1: 
author:Piotr Jastrzebski
-------------------------------------------------------------------------------
commit:1c62850
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.btree.BTreeRemoval;
/////////////////////////////////////////////////////////////////////////
1:         Object[] newColumns = BTreeRemoval.<ColumnDefinition>remove(columns, Comparator.naturalOrder(), column);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:649a106
/////////////////////////////////////////////////////////////////////////
1:             out.writeUnsignedVInt(columns.size());
1:             long size = TypeSizes.sizeofUnsignedVInt(columns.size());
/////////////////////////////////////////////////////////////////////////
1:             int length = (int)in.readUnsignedVInt();
commit:aa57626
/////////////////////////////////////////////////////////////////////////
1:     public static Columns from(Collection<ColumnDefinition> s)
commit:0d74c3e
/////////////////////////////////////////////////////////////////////////
1: public class Columns extends AbstractCollection<ColumnDefinition> implements Collection<ColumnDefinition>
/////////////////////////////////////////////////////////////////////////
1:     public int size()
/////////////////////////////////////////////////////////////////////////
1:     public boolean containsAll(Collection<?> other)
1:         if (other == this)
1:             return true;
1:         if (other.size() > this.size())
1:         for (Object def : other)
1:             if (iter.next((ColumnDefinition) def) == null)
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder sb = new StringBuilder("[");
1:         return sb.append("]").toString();
0:             out.writeVInt(columns.size());
0:             long size = TypeSizes.sizeofVInt(columns.size());
/////////////////////////////////////////////////////////////////////////
1:         public void serializeSubset(Collection<ColumnDefinition> columns, Columns superset, DataOutputPlus out) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             int columnCount = columns.size();
1:             int supersetCount = superset.size();
/////////////////////////////////////////////////////////////////////////
1:         public long serializedSubsetSize(Collection<ColumnDefinition> columns, Columns superset)
1:             int columnCount = columns.size();
1:             int supersetCount = superset.size();
/////////////////////////////////////////////////////////////////////////
1:             else if (superset.size() >= 64)
/////////////////////////////////////////////////////////////////////////
1:         private static long encodeBitmap(Collection<ColumnDefinition> columns, Columns superset, int supersetCount)
/////////////////////////////////////////////////////////////////////////
1:                     throw new IllegalStateException(columns + " is not a subset of " + superset);
/////////////////////////////////////////////////////////////////////////
1:         private void serializeLargeSubset(Collection<ColumnDefinition> columns, int columnCount, Columns superset, int supersetCount, DataOutputPlus out) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             int supersetCount = superset.size();
/////////////////////////////////////////////////////////////////////////
1:         private int serializeLargeSubsetSize(Collection<ColumnDefinition> columns, int columnCount, Columns superset, int supersetCount)
commit:f60322a
/////////////////////////////////////////////////////////////////////////
1:             if (encoded == 0L)
0:             else if (superset.columnCount() >= 64)
1:             {
1:                 return deserializeLargeSubset(in, superset, (int) encoded);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private Columns deserializeLargeSubset(DataInputPlus in, Columns superset, int delta) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             int size = TypeSizes.sizeofUnsignedVInt(supersetCount - columnCount);
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.btree.UpdateFunction;
/////////////////////////////////////////////////////////////////////////
1:         Object[] tree = BTree.<ColumnDefinition>merge(this.columns, other.columns, Comparator.naturalOrder(),
1:                                                       UpdateFunction.noOp());
commit:fe388d4
/////////////////////////////////////////////////////////////////////////
1: import net.nicoulaj.compilecommand.annotations.DontInline;
/////////////////////////////////////////////////////////////////////////
1:     public BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iterator()
1:         return BTree.<ColumnDefinition, ColumnDefinition>slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
/////////////////////////////////////////////////////////////////////////
1:         return Iterators.<ColumnDefinition>
1:                          mergeSorted(ImmutableList.of(simpleColumns(), complexColumns()),
1:                                      (s, c) ->
1:                                      {
1:                                          assert !s.kind.isPrimaryKeyKind();
1:                                          return s.name.bytes.compareTo(c.name.bytes);
1:                                      });
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * If both ends have a pre-shared superset of the columns we are serializing, we can send them much
1:          * more efficiently. Both ends must provide the identically same set of columns.
1:          */
0:         public void serializeSubset(Columns columns, Columns superset, DataOutputPlus out) throws IOException
1:         {
1:             /**
1:              * We weight this towards small sets, and sets where the majority of items are present, since
1:              * we expect this to mostly be used for serializing result sets.
1:              *
1:              * For supersets with fewer than 64 columns, we encode a bitmap of *missing* columns,
1:              * which equates to a zero (single byte) when all columns are present, and otherwise
1:              * a positive integer that can typically be vint encoded efficiently.
1:              *
1:              * If we have 64 or more columns, we cannot neatly perform a bitmap encoding, so we just switch
1:              * to a vint encoded set of deltas, either adding or subtracting (whichever is most efficient).
1:              * We indicate this switch by sending our bitmap with every bit set, i.e. -1L
1:              */
0:             int columnCount = columns.columnCount();
0:             int supersetCount = superset.columnCount();
1:             if (columnCount == supersetCount)
1:             {
1:                 out.writeUnsignedVInt(0);
1:             }
1:             else if (supersetCount < 64)
1:             {
1:                 out.writeUnsignedVInt(encodeBitmap(columns, superset, supersetCount));
1:             }
1:             else
1:             {
1:                 serializeLargeSubset(columns, columnCount, superset, supersetCount, out);
1:             }
1:         }
1: 
0:         public long serializedSubsetSize(Columns columns, Columns superset)
1:         {
0:             int columnCount = columns.columnCount();
0:             int supersetCount = superset.columnCount();
1:             if (columnCount == supersetCount)
1:             {
1:                 return TypeSizes.sizeofUnsignedVInt(0);
1:             }
1:             else if (supersetCount < 64)
1:             {
1:                 return TypeSizes.sizeofUnsignedVInt(encodeBitmap(columns, superset, supersetCount));
1:             }
1:             else
1:             {
1:                 return serializeLargeSubsetSize(columns, columnCount, superset, supersetCount);
1:             }
1:         }
1: 
1:         public Columns deserializeSubset(Columns superset, DataInputPlus in) throws IOException
1:         {
1:             long encoded = in.readUnsignedVInt();
0:             if (encoded == -1L)
1:             {
0:                 return deserializeLargeSubset(in, superset);
1:             }
0:             else if (encoded == 0L)
1:             {
1:                 return superset;
1:             }
1:             else
1:             {
1:                 BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:                 int firstComplexIdx = 0;
1:                 for (ColumnDefinition column : superset)
1:                 {
1:                     if ((encoded & 1) == 0)
1:                     {
1:                         builder.add(column);
1:                         if (column.isSimple())
1:                             ++firstComplexIdx;
1:                     }
1:                     encoded >>>= 1;
1:                 }
1:                 return new Columns(builder.build(), firstComplexIdx);
1:             }
1:         }
1: 
1:         // encodes a 1 bit for every *missing* column, on the assumption presence is more common,
1:         // and because this is consistent with encoding 0 to represent all present
0:         private static long encodeBitmap(Columns columns, Columns superset, int supersetCount)
1:         {
1:             long bitmap = 0L;
1:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:             // the index we would encounter next if all columns are present
1:             int expectIndex = 0;
1:             for (ColumnDefinition column : columns)
1:             {
1:                 if (iter.next(column) == null)
1:                     throw new IllegalStateException();
1: 
1:                 int currentIndex = iter.indexOfCurrent();
1:                 int count = currentIndex - expectIndex;
1:                 // (1L << count) - 1 gives us count bits set at the bottom of the register
1:                 // so << expectIndex moves these bits to start at expectIndex, which is where our missing portion
1:                 // begins (assuming count > 0; if not, we're adding 0 bits, so it's a no-op)
1:                 bitmap |= ((1L << count) - 1) << expectIndex;
1:                 expectIndex = currentIndex + 1;
1:             }
1:             int count = supersetCount - expectIndex;
1:             bitmap |= ((1L << count) - 1) << expectIndex;
1:             return bitmap;
1:         }
1: 
1:         @DontInline
0:         private void serializeLargeSubset(Columns columns, int columnCount, Columns superset, int supersetCount, DataOutputPlus out) throws IOException
1:         {
1:             // write flag indicating we're in lengthy mode
0:             out.writeUnsignedVInt(-1L);
1:             out.writeUnsignedVInt(supersetCount - columnCount);
1:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:             if (columnCount < supersetCount / 2)
1:             {
1:                 // write present columns
1:                 for (ColumnDefinition column : columns)
1:                 {
1:                     if (iter.next(column) == null)
1:                         throw new IllegalStateException();
1:                     out.writeUnsignedVInt(iter.indexOfCurrent());
1:                 }
1:             }
1:             else
1:             {
1:                 // write missing columns
1:                 int prev = -1;
1:                 for (ColumnDefinition column : columns)
1:                 {
1:                     if (iter.next(column) == null)
1:                         throw new IllegalStateException();
1:                     int cur = iter.indexOfCurrent();
1:                     while (++prev != cur)
1:                         out.writeUnsignedVInt(prev);
1:                 }
1:                 while (++prev != supersetCount)
1:                     out.writeUnsignedVInt(prev);
1:             }
1:         }
1: 
1:         @DontInline
0:         private Columns deserializeLargeSubset(DataInputPlus in, Columns superset) throws IOException
1:         {
0:             int supersetCount = superset.columnCount();
0:             int delta = (int) in.readUnsignedVInt();
1:             int columnCount = supersetCount - delta;
1: 
1:             BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:             if (columnCount < supersetCount / 2)
1:             {
1:                 for (int i = 0 ; i < columnCount ; i++)
1:                 {
1:                     int idx = (int) in.readUnsignedVInt();
1:                     builder.add(BTree.findByIndex(superset.columns, idx));
1:                 }
1:             }
1:             else
1:             {
1:                 Iterator<ColumnDefinition> iter = superset.iterator();
1:                 int idx = 0;
1:                 int skipped = 0;
1:                 while (true)
1:                 {
1:                     int nextMissingIndex = skipped < delta ? (int)in.readUnsignedVInt() : supersetCount;
1:                     while (idx < nextMissingIndex)
1:                     {
1:                         ColumnDefinition def = iter.next();
1:                         builder.add(def);
1:                         idx++;
1:                     }
1:                     if (idx == supersetCount)
1:                         break;
1:                     iter.next();
1:                     idx++;
1:                     skipped++;
1:                 }
1:             }
1:             return new Columns(builder.build());
1:         }
1: 
1:         @DontInline
0:         private int serializeLargeSubsetSize(Columns columns, int columnCount, Columns superset, int supersetCount)
1:         {
1:             // write flag indicating we're in lengthy mode
0:             int size = TypeSizes.sizeofUnsignedVInt(-1L) + TypeSizes.sizeofUnsignedVInt(supersetCount - columnCount);
1:             BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = superset.iterator();
1:             if (columnCount < supersetCount / 2)
1:             {
1:                 // write present columns
1:                 for (ColumnDefinition column : columns)
1:                 {
1:                     if (iter.next(column) == null)
1:                         throw new IllegalStateException();
1:                     size += TypeSizes.sizeofUnsignedVInt(iter.indexOfCurrent());
1:                 }
1:             }
1:             else
1:             {
1:                 // write missing columns
1:                 int prev = -1;
1:                 for (ColumnDefinition column : columns)
1:                 {
1:                     if (iter.next(column) == null)
1:                         throw new IllegalStateException();
1:                     int cur = iter.indexOfCurrent();
1:                     while (++prev != cur)
1:                         size += TypeSizes.sizeofUnsignedVInt(prev);
1:                 }
1:                 while (++prev != supersetCount)
1:                     size += TypeSizes.sizeofUnsignedVInt(prev);
1:             }
1:             return size;
1:         }
1: 
commit:ace28c9
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.ImmutableList;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.marshal.SetType;
1: import org.apache.cassandra.utils.SearchIterator;
1: import org.apache.cassandra.utils.btree.BTree;
1: import org.apache.cassandra.utils.btree.BTreeSearchIterator;
/////////////////////////////////////////////////////////////////////////
1:     public static final Columns NONE = new Columns(BTree.empty(), 0);
0:     public static final ColumnDefinition FIRST_COMPLEX = new ColumnDefinition("", "", ColumnIdentifier.getInterned(ByteBufferUtil.EMPTY_BYTE_BUFFER, UTF8Type.instance),
0:                                                                               SetType.getInstance(UTF8Type.instance, true), null, ColumnDefinition.Kind.REGULAR);
1:     private final Object[] columns;
1:     private final int complexIdx; // Index of the first complex column
1:     private Columns(Object[] columns, int complexIdx)
1:         assert complexIdx <= BTree.size(columns);
1:     private Columns(Object[] columns)
/////////////////////////////////////////////////////////////////////////
1:         return new Columns(BTree.singleton(c), c.isComplex() ? 0 : 1);
1:      * @param s the set from which to create the new {@code Columns}.
1:         Object[] tree = BTree.<ColumnDefinition>builder(Comparator.naturalOrder()).addAll(s).build();
1:         return new Columns(tree, findFirstComplexIdx(tree));
1:     private static int findFirstComplexIdx(Object[] tree)
1:         // have fast path for common no-complex case
1:         int size = BTree.size(tree);
1:         if (!BTree.isEmpty(tree) && BTree.<ColumnDefinition>findByIndex(tree, size - 1).isSimple())
1:             return size;
1:         return BTree.ceilIndex(tree, Comparator.naturalOrder(), FIRST_COMPLEX);
/////////////////////////////////////////////////////////////////////////
1:         return BTree.isEmpty(columns);
/////////////////////////////////////////////////////////////////////////
1:         return BTree.size(columns) - complexIdx;
/////////////////////////////////////////////////////////////////////////
1:         return BTree.size(columns);
/////////////////////////////////////////////////////////////////////////
1:         return complexIdx < BTree.size(columns);
/////////////////////////////////////////////////////////////////////////
1:         return BTree.findByIndex(columns, i);
/////////////////////////////////////////////////////////////////////////
1:         return BTree.findByIndex(columns, complexIdx + i);
/////////////////////////////////////////////////////////////////////////
1:      * object
1:     public int simpleIdx(ColumnDefinition c)
1:         return BTree.findIndex(columns, Comparator.naturalOrder(), c);
/////////////////////////////////////////////////////////////////////////
1:      * object
1:     public int complexIdx(ColumnDefinition c)
1:         return BTree.findIndex(columns, Comparator.naturalOrder(), c) - complexIdx;
/////////////////////////////////////////////////////////////////////////
1:         return BTree.findIndex(columns, Comparator.naturalOrder(), c) >= 0;
/////////////////////////////////////////////////////////////////////////
0:         Object[] tree = BTree.<ColumnDefinition>merge(this.columns, other.columns, Comparator.naturalOrder());
1:         if (tree == this.columns)
1:             return this;
1:         if (tree == other.columns)
1:             return other;
1:         return new Columns(tree, findFirstComplexIdx(tree));
/////////////////////////////////////////////////////////////////////////
1:         BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
0:         for (ColumnDefinition def : BTree.<ColumnDefinition>iterable(other.columns))
0:             if (iter.next(def) == null)
/////////////////////////////////////////////////////////////////////////
1:         return BTree.iterator(columns, 0, complexIdx - 1, BTree.Dir.ASC);
/////////////////////////////////////////////////////////////////////////
1:         return BTree.iterator(columns, complexIdx, BTree.size(columns) - 1, BTree.Dir.ASC);
/////////////////////////////////////////////////////////////////////////
0:         return BTree.iterator(columns);
/////////////////////////////////////////////////////////////////////////
0:         return Iterators.<ColumnDefinition>mergeSorted(ImmutableList.of(simpleColumns(), complexColumns()),
0:                                      (s, c) -> s.name.compareTo(c.name));
/////////////////////////////////////////////////////////////////////////
1:         if (!contains(column))
0:         Object[] newColumns = BTree.<ColumnDefinition>transformAndFilter(columns, (c) -> c.equals(column) ? null : c);
/////////////////////////////////////////////////////////////////////////
1:         SearchIterator<ColumnDefinition, ColumnDefinition> iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);
1:         return column -> iter.next(column) != null;
/////////////////////////////////////////////////////////////////////////
1:         if (other == this)
1:             return true;
1:         return this.complexIdx == that.complexIdx && BTree.equals(this.columns, that.columns);
1:         return Objects.hash(complexIdx, BTree.hashCode(columns));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             BTree.Builder<ColumnDefinition> builder = BTree.builder(Comparator.naturalOrder());
1:             builder.auto(false);
/////////////////////////////////////////////////////////////////////////
1:                 builder.add(column);
1:             return new Columns(builder.build());
commit:8c8103c
/////////////////////////////////////////////////////////////////////////
0:                 return columns[regular].name.compareTo(columns[complex].name) < 0
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0790e48
/////////////////////////////////////////////////////////////////////////
1:     public static final ColumnDefinition FIRST_COMPLEX =
1:         new ColumnDefinition("",
1:                              "",
1:                              ColumnIdentifier.getInterned(ByteBufferUtil.EMPTY_BYTE_BUFFER, UTF8Type.instance),
1:                              SetType.getInstance(UTF8Type.instance, true),
1:                              ColumnDefinition.NO_POSITION,
1:                              ColumnDefinition.Kind.REGULAR);
commit:2fea59d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:             out.writeVInt(columns.columnCount());
1:                 ByteBufferUtil.writeWithVIntLength(column.name.bytes, out);
0:             long size = TypeSizes.sizeofVInt(columns.columnCount());
1:                 size += ByteBufferUtil.serializedSizeWithVIntLength(column.name.bytes);
1:         public Columns deserialize(DataInputPlus in, CFMetaData metadata) throws IOException
0:             int length = (int)in.readVInt();
1:                 ByteBuffer name = ByteBufferUtil.readWithVIntLength(in);
author:blerer
-------------------------------------------------------------------------------
commit:ffe53de
/////////////////////////////////////////////////////////////////////////
0:         if (other.columnCount() > columnCount())
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:59a2861
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             out.writeShort(columns.columnCount());
0:                 ByteBufferUtil.writeWithShortLength(column.name.bytes, out);
0:             long size = TypeSizes.sizeof((short)columns.columnCount());
0:                 size += TypeSizes.sizeofWithShortLength(column.name.bytes);
0:         public Columns deserialize(DataInput in, CFMetaData metadata) throws IOException
0:             int length = in.readUnsignedShort();
0:                 ByteBuffer name = ByteBufferUtil.readWithShortLength(in);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a59be26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:             out.writeVInt(columns.columnCount());
0:                 ByteBufferUtil.writeWithVIntLength(column.name.bytes, out);
0:             long size = TypeSizes.sizeofVInt(columns.columnCount());
0:                 size += ByteBufferUtil.serializedSizeWithVIntLength(column.name.bytes);
0:         public Columns deserialize(DataInputPlus in, CFMetaData metadata) throws IOException
0:             int length = (int)in.readVInt();
0:                 ByteBuffer name = ByteBufferUtil.readWithVIntLength(in);
commit:2457599
/////////////////////////////////////////////////////////////////////////
1: import java.util.function.Predicate;
/////////////////////////////////////////////////////////////////////////
1:      * Whether this object is a superset of the provided other {@code Columns object}.
1:      * @param other the other object to test for inclusion in this object.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a predicate to test whether columns are included in this {@code Columns} object,
1:      * assuming that tes tested columns are passed to the predicate in sorted order.
1:      *
1:      * @return a predicate to test the inclusion of sorted columns in this object.
1:      */
1:     public Predicate<ColumnDefinition> inOrderInclusionTester()
1:     {
0:         return new Predicate<ColumnDefinition>()
1:         {
0:             private int i = 0;
1: 
0:             public boolean test(ColumnDefinition column)
1:             {
0:                 while (i < columns.length)
1:                 {
0:                     int cmp = column.compareTo(columns[i]);
0:                     if (cmp < 0)
1:                         return false;
0:                     i++;
0:                     if (cmp == 0)
1:                         return true;
1:                 }
1:                 return false;
1:             }
0:         };
1:     }
1: 
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
0: import java.io.DataInput;
1: import java.io.IOException;
1: import java.util.*;
1: import java.nio.ByteBuffer;
1: import java.security.MessageDigest;
1: 
0: import com.google.common.collect.AbstractIterator;
1: import com.google.common.collect.Iterators;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.marshal.UTF8Type;
0: import org.apache.cassandra.db.marshal.MapType;
1: import org.apache.cassandra.io.util.DataOutputPlus;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: /**
1:  * An immutable and sorted list of (non-PK) columns for a given table.
1:  * <p>
1:  * Note that in practice, it will either store only static columns, or only regular ones. When
1:  * we need both type of columns, we use a {@link PartitionColumns} object.
1:  */
0: public class Columns implements Iterable<ColumnDefinition>
1: {
1:     public static final Serializer serializer = new Serializer();
0:     public static final Columns NONE = new Columns(new ColumnDefinition[0], 0);
1: 
0:     public final ColumnDefinition[] columns;
0:     public final int complexIdx; // Index of the first complex column
1: 
0:     private Columns(ColumnDefinition[] columns, int complexIdx)
1:     {
0:         assert complexIdx <= columns.length;
1:         this.columns = columns;
1:         this.complexIdx = complexIdx;
1:     }
1: 
0:     private Columns(ColumnDefinition[] columns)
1:     {
1:         this(columns, findFirstComplexIdx(columns));
1:     }
1: 
1:     /**
1:      * Creates a {@code Columns} holding only the one column provided.
1:      *
1:      * @param c the column for which to create a {@code Columns} object.
1:      *
1:      * @return the newly created {@code Columns} containing only {@code c}.
1:      */
1:     public static Columns of(ColumnDefinition c)
1:     {
0:         ColumnDefinition[] columns = new ColumnDefinition[]{ c };
0:         return new Columns(columns, c.isComplex() ? 0 : 1);
1:     }
1: 
1:     /**
1:      * Returns a new {@code Columns} object holing the same columns than the provided set.
1:      *
0:      * @param param s the set from which to create the new {@code Columns}.
1:      *
1:      * @return the newly created {@code Columns} containing the columns from {@code s}.
1:      */
0:     public static Columns from(Set<ColumnDefinition> s)
1:     {
0:         ColumnDefinition[] columns = s.toArray(new ColumnDefinition[s.size()]);
0:         Arrays.sort(columns);
0:         return new Columns(columns, findFirstComplexIdx(columns));
1:     }
1: 
0:     private static int findFirstComplexIdx(ColumnDefinition[] columns)
1:     {
0:         for (int i = 0; i < columns.length; i++)
0:             if (columns[i].isComplex())
0:                 return i;
0:         return columns.length;
1:     }
1: 
1:     /**
1:      * Whether this columns is empty.
1:      *
1:      * @return whether this columns is empty.
1:      */
1:     public boolean isEmpty()
1:     {
0:         return columns.length == 0;
1:     }
1: 
1:     /**
1:      * The number of simple columns in this object.
1:      *
1:      * @return the number of simple columns in this object.
1:      */
1:     public int simpleColumnCount()
1:     {
1:         return complexIdx;
1:     }
1: 
1:     /**
1:      * The number of complex columns (non-frozen collections, udts, ...) in this object.
1:      *
1:      * @return the number of complex columns in this object.
1:      */
1:     public int complexColumnCount()
1:     {
0:         return columns.length - complexIdx;
1:     }
1: 
1:     /**
1:      * The total number of columns in this object.
1:      *
1:      * @return the total number of columns in this object.
1:      */
0:     public int columnCount()
1:     {
0:         return columns.length;
1:     }
1: 
1:     /**
1:      * Whether this objects contains simple columns.
1:      *
1:      * @return whether this objects contains simple columns.
1:      */
1:     public boolean hasSimple()
1:     {
1:         return complexIdx > 0;
1:     }
1: 
1:     /**
1:      * Whether this objects contains complex columns.
1:      *
1:      * @return whether this objects contains complex columns.
1:      */
1:     public boolean hasComplex()
1:     {
0:         return complexIdx < columns.length;
1:     }
1: 
1:     /**
1:      * Returns the ith simple column of this object.
1:      *
1:      * @param i the index for the simple column to fectch. This must
1:      * satisfy {@code 0 <= i < simpleColumnCount()}.
1:      *
1:      * @return the {@code i}th simple column in this object.
1:      */
1:     public ColumnDefinition getSimple(int i)
1:     {
0:         return columns[i];
1:     }
1: 
1:     /**
1:      * Returns the ith complex column of this object.
1:      *
1:      * @param i the index for the complex column to fectch. This must
1:      * satisfy {@code 0 <= i < complexColumnCount()}.
1:      *
1:      * @return the {@code i}th complex column in this object.
1:      */
1:     public ColumnDefinition getComplex(int i)
1:     {
0:         return columns[complexIdx + i];
1:     }
1: 
1:     /**
1:      * The index of the provided simple column in this object (if it contains
1:      * the provided column).
1:      *
1:      * @param c the simple column for which to return the index of.
0:      * @param from the index to start the search from.
1:      *
1:      * @return the index for simple column {@code c} if it is contains in this
0:      * object (starting from index {@code from}), {@code -1} otherwise.
1:      */
0:     public int simpleIdx(ColumnDefinition c, int from)
1:     {
0:         assert !c.isComplex();
0:         for (int i = from; i < complexIdx; i++)
0:             // We know we only use "interned" ColumnIdentifier so == is ok.
0:             if (columns[i].name == c.name)
0:                 return i;
0:         return -1;
1:     }
1: 
1:     /**
1:      * The index of the provided complex column in this object (if it contains
1:      * the provided column).
1:      *
1:      * @param c the complex column for which to return the index of.
0:      * @param from the index to start the search from.
1:      *
1:      * @return the index for complex column {@code c} if it is contains in this
0:      * object (starting from index {@code from}), {@code -1} otherwise.
1:      */
0:     public int complexIdx(ColumnDefinition c, int from)
1:     {
0:         assert c.isComplex();
0:         for (int i = complexIdx + from; i < columns.length; i++)
0:             // We know we only use "interned" ColumnIdentifier so == is ok.
0:             if (columns[i].name == c.name)
0:                 return i - complexIdx;
0:         return -1;
1:     }
1: 
1:     /**
1:      * Whether the provided column is contained by this object.
1:      *
1:      * @param c the column to check presence of.
1:      *
1:      * @return whether {@code c} is contained by this object.
1:      */
1:     public boolean contains(ColumnDefinition c)
1:     {
0:         return c.isComplex() ? complexIdx(c, 0) >= 0 : simpleIdx(c, 0) >= 0;
1:     }
1: 
1:     /**
0:      * Whether or not there is some counter columns within those columns.
1:      *
0:      * @return whether or not there is some counter columns within those columns.
1:      */
0:     public boolean hasCounters()
1:     {
0:         for (int i = 0; i < complexIdx; i++)
1:         {
0:             if (columns[i].type.isCounter())
0:                 return true;
1:         }
1: 
0:         for (int i = complexIdx; i < columns.length; i++)
1:         {
0:             // We only support counter in maps because that's all we need for now (and we need it for the sake of thrift super columns of counter)
0:             if (columns[i].type instanceof MapType && (((MapType)columns[i].type).valueComparator().isCounter()))
0:                 return true;
1:         }
1: 
1:         return false;
1:     }
1: 
1:     /**
1:      * Returns the result of merging this {@code Columns} object with the
1:      * provided one.
1:      *
1:      * @param other the other {@code Columns} to merge this object with.
1:      *
1:      * @return the result of merging/taking the union of {@code this} and
1:      * {@code other}. The returned object may be one of the operand and that
1:      * operand is a subset of the other operand.
1:      */
1:     public Columns mergeTo(Columns other)
1:     {
1:         if (this == other || other == NONE)
1:             return this;
1:         if (this == NONE)
1:             return other;
1: 
0:         int i = 0, j = 0;
0:         int size = 0;
0:         while (i < columns.length && j < other.columns.length)
1:         {
0:             ++size;
0:             int cmp = columns[i].compareTo(other.columns[j]);
0:             if (cmp == 0)
1:             {
0:                 ++i;
0:                 ++j;
1:             }
0:             else if (cmp < 0)
1:             {
0:                 ++i;
1:             }
0:             else
1:             {
0:                 ++j;
1:             }
1:         }
1: 
0:         // If every element was always counted on both array, we have the same
0:         // arrays for the first min elements
0:         if (i == size && j == size)
1:         {
0:             // We've exited because of either c1 or c2 (or both). The array that
0:             // made us stop is thus a subset of the 2nd one, return that array.
0:             return i == columns.length ? other : this;
1:         }
1: 
0:         size += i == columns.length ? other.columns.length - j : columns.length - i;
0:         ColumnDefinition[] result = new ColumnDefinition[size];
0:         i = 0;
0:         j = 0;
0:         for (int k = 0; k < size; k++)
1:         {
0:             int cmp = i >= columns.length ? 1
0:                     : (j >= other.columns.length ? -1 : columns[i].compareTo(other.columns[j]));
0:             if (cmp == 0)
1:             {
0:                 result[k] = columns[i];
0:                 ++i;
0:                 ++j;
1:             }
0:             else if (cmp < 0)
1:             {
0:                 result[k] = columns[i++];
1:             }
0:             else
1:             {
0:                 result[k] = other.columns[j++];
1:             }
1:         }
0:         return new Columns(result, findFirstComplexIdx(result));
1:     }
1: 
1:     /**
0:      * Whether this object is a subset of the provided other {@code Columns object}.
1:      *
0:      * @param other the othere object to test for inclusion in this object.
1:      *
1:      * @return whether all the columns of {@code other} are contained by this object.
1:      */
0:     public boolean contains(Columns other)
1:     {
0:         if (other.columns.length > columns.length)
1:             return false;
1: 
0:         int j = 0;
0:         int cmp = 0;
0:         for (ColumnDefinition def : other.columns)
1:         {
0:             while (j < columns.length && (cmp = columns[j].compareTo(def)) < 0)
0:                 j++;
1: 
0:             if (j >= columns.length || cmp > 0)
1:                 return false;
1: 
0:             // cmp == 0, we've found the definition. Ce can bump j once more since
0:             // we know we won't need to compare that element again
0:             j++;
1:         }
0:         return true;
1:     }
1: 
1:     /**
1:      * Iterator over the simple columns of this object.
1:      *
1:      * @return an iterator over the simple columns of this object.
1:      */
1:     public Iterator<ColumnDefinition> simpleColumns()
1:     {
0:         return new ColumnIterator(0, complexIdx);
1:     }
1: 
1:     /**
1:      * Iterator over the complex columns of this object.
1:      *
1:      * @return an iterator over the complex columns of this object.
1:      */
1:     public Iterator<ColumnDefinition> complexColumns()
1:     {
0:         return new ColumnIterator(complexIdx, columns.length);
1:     }
1: 
1:     /**
1:      * Iterator over all the columns of this object.
1:      *
1:      * @return an iterator over all the columns of this object.
1:      */
0:     public Iterator<ColumnDefinition> iterator()
1:     {
0:         return Iterators.forArray(columns);
1:     }
1: 
1:     /**
1:      * An iterator that returns the columns of this object in "select" order (that
1:      * is in global alphabetical order, where the "normal" iterator returns simple
1:      * columns first and the complex second).
1:      *
1:      * @return an iterator returning columns in alphabetical order.
1:      */
1:     public Iterator<ColumnDefinition> selectOrderIterator()
1:     {
1:         // In wildcard selection, we want to return all columns in alphabetical order,
1:         // irregarding of whether they are complex or not
0:         return new AbstractIterator<ColumnDefinition>()
1:         {
0:             private int regular;
0:             private int complex = complexIdx;
1: 
0:             protected ColumnDefinition computeNext()
1:             {
0:                 if (complex >= columns.length)
0:                     return regular >= complexIdx ? endOfData() : columns[regular++];
0:                 if (regular >= complexIdx)
0:                     return columns[complex++];
1: 
0:                 return ByteBufferUtil.compareUnsigned(columns[regular].name.bytes, columns[complex].name.bytes) < 0
0:                      ? columns[regular++]
0:                      : columns[complex++];
1:             }
0:         };
1:     }
1: 
1:     /**
1:      * Returns the equivalent of those columns but with the provided column removed.
1:      *
1:      * @param column the column to remove.
1:      *
1:      * @return newly allocated columns containing all the columns of {@code this} expect
1:      * for {@code column}.
1:      */
1:     public Columns without(ColumnDefinition column)
1:     {
0:         int idx = column.isComplex() ? complexIdx(column, 0) : simpleIdx(column, 0);
0:         if (idx < 0)
1:             return this;
1: 
0:         int realIdx = column.isComplex() ? complexIdx + idx : idx;
1: 
0:         ColumnDefinition[] newColumns = new ColumnDefinition[columns.length - 1];
0:         System.arraycopy(columns, 0, newColumns, 0, realIdx);
0:         System.arraycopy(columns, realIdx + 1, newColumns, realIdx, newColumns.length - realIdx);
1:         return new Columns(newColumns);
1:     }
1: 
1:     public void digest(MessageDigest digest)
1:     {
1:         for (ColumnDefinition c : this)
1:             digest.update(c.name.bytes.duplicate());
1:     }
1: 
1:     @Override
1:     public boolean equals(Object other)
1:     {
1:         if (!(other instanceof Columns))
1:             return false;
1: 
1:         Columns that = (Columns)other;
0:         return this.complexIdx == that.complexIdx && Arrays.equals(this.columns, that.columns);
1:     }
1: 
1:     @Override
1:     public int hashCode()
1:     {
0:         return Objects.hash(complexIdx, Arrays.hashCode(columns));
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
0:         StringBuilder sb = new StringBuilder();
1:         boolean first = true;
1:         for (ColumnDefinition def : this)
1:         {
1:             if (first) first = false; else sb.append(" ");
1:             sb.append(def.name);
1:         }
0:         return sb.toString();
1:     }
1: 
0:     private class ColumnIterator extends AbstractIterator<ColumnDefinition>
1:     {
0:         private final int to;
0:         private int idx;
1: 
0:         private ColumnIterator(int from, int to)
1:         {
0:             this.idx = from;
0:             this.to = to;
1:         }
1: 
0:         protected ColumnDefinition computeNext()
1:         {
0:             if (idx >= to)
0:                 return endOfData();
0:             return columns[idx++];
1:         }
1:     }
1: 
1:     public static class Serializer
1:     {
1:         public void serialize(Columns columns, DataOutputPlus out) throws IOException
1:         {
0:             out.writeShort(columns.columnCount());
1:             for (ColumnDefinition column : columns)
0:                 ByteBufferUtil.writeWithShortLength(column.name.bytes, out);
1:         }
1: 
0:         public long serializedSize(Columns columns, TypeSizes sizes)
1:         {
0:             long size = sizes.sizeof((short)columns.columnCount());
1:             for (ColumnDefinition column : columns)
0:                 size += sizes.sizeofWithShortLength(column.name.bytes);
1:             return size;
1:         }
1: 
0:         public Columns deserialize(DataInput in, CFMetaData metadata) throws IOException
1:         {
0:             int length = in.readUnsignedShort();
0:             ColumnDefinition[] columns = new ColumnDefinition[length];
1:             for (int i = 0; i < length; i++)
1:             {
0:                 ByteBuffer name = ByteBufferUtil.readWithShortLength(in);
1:                 ColumnDefinition column = metadata.getColumnDefinition(name);
1:                 if (column == null)
1:                 {
1:                     // If we don't find the definition, it could be we have data for a dropped column, and we shouldn't
1:                     // fail deserialization because of that. So we grab a "fake" ColumnDefinition that ensure proper
1:                     // deserialization. The column will be ignore later on anyway.
1:                     column = metadata.getDroppedColumnDefinition(name);
1:                     if (column == null)
1:                         throw new RuntimeException("Unknown column " + UTF8Type.instance.getString(name) + " during deserialization");
1:                 }
0:                 columns[i] = column;
1:             }
0:             return new Columns(columns);
1:         }
1:     }
1: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1:         public long serializedSize(Columns columns)
0:             long size = TypeSizes.sizeof((short)columns.columnCount());
0:                 size += TypeSizes.sizeofWithShortLength(column.name.bytes);
============================================================================