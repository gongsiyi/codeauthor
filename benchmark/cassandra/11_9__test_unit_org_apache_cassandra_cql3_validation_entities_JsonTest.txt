1:c7b02d1: /*
1:c7b02d1:  * Licensed to the Apache Software Foundation (ASF) under one
1:c7b02d1:  * or more contributor license agreements.  See the NOTICE file
1:c7b02d1:  * distributed with this work for additional information
1:c7b02d1:  * regarding copyright ownership.  The ASF licenses this file
1:c7b02d1:  * to you under the Apache License, Version 2.0 (the
1:c7b02d1:  * "License"); you may not use this file except in compliance
1:c7b02d1:  * with the License.  You may obtain a copy of the License at
1:c7b02d1:  *
1:c7b02d1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:c7b02d1:  *
1:c7b02d1:  * Unless required by applicable law or agreed to in writing, software
1:c7b02d1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c7b02d1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c7b02d1:  * See the License for the specific language governing permissions and
1:c7b02d1:  * limitations under the License.
1:c7b02d1:  */
1:01115f7: package org.apache.cassandra.cql3.validation.entities;
1:c7b02d1: 
1:01115f7: import org.apache.cassandra.config.DatabaseDescriptor;
1:01115f7: import org.apache.cassandra.cql3.Json;
1:01115f7: import org.apache.cassandra.cql3.CQLTester;
1:bfd57d1: import org.apache.cassandra.cql3.Duration;
1:01115f7: import org.apache.cassandra.dht.ByteOrderedPartitioner;
1:c7b02d1: import org.apache.cassandra.serializers.SimpleDateSerializer;
1:c7b02d1: import org.apache.cassandra.serializers.TimeSerializer;
1:c7b02d1: import org.apache.cassandra.utils.ByteBufferUtil;
1:c7b02d1: 
1:6b1bd17: import org.junit.Assert;
1:01115f7: import org.junit.BeforeClass;
1:c7b02d1: import org.junit.Test;
1:c7b02d1: 
1:c7b02d1: import java.math.BigDecimal;
1:c7b02d1: import java.math.BigInteger;
1:c7b02d1: import java.net.InetAddress;
1:c7b02d1: import java.text.SimpleDateFormat;
1:6b1bd17: import java.util.*;
1:6b1bd17: import java.util.concurrent.ExecutorService;
1:6b1bd17: import java.util.concurrent.Executors;
1:6b1bd17: import java.util.concurrent.Future;
1:6b1bd17: import java.util.concurrent.TimeUnit;
1:c7b02d1: 
1:c7b02d1: import static org.junit.Assert.fail;
1:c7b02d1: 
1:c7b02d1: public class JsonTest extends CQLTester
1:c7b02d1: {
1:01115f7:     @BeforeClass
1:01115f7:     public static void setUp()
1:01115f7:     {
1:0a08525:         DatabaseDescriptor.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
1:01115f7:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:c7b02d1:     public void testFromJsonFct() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         String typeName = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
1:c7b02d1:         createTable("CREATE TABLE %s (" +
1:c7b02d1:                 "k int PRIMARY KEY, " +
1:c7b02d1:                 "asciival ascii, " +
1:c7b02d1:                 "bigintval bigint, " +
1:c7b02d1:                 "blobval blob, " +
1:c7b02d1:                 "booleanval boolean, " +
1:c7b02d1:                 "dateval date, " +
1:c7b02d1:                 "decimalval decimal, " +
1:c7b02d1:                 "doubleval double, " +
1:c7b02d1:                 "floatval float, " +
1:c7b02d1:                 "inetval inet, " +
1:c7b02d1:                 "intval int, " +
1:dc8a017:                 "smallintval smallint, " +
1:c7b02d1:                 "textval text, " +
1:c7b02d1:                 "timeval time, " +
1:c7b02d1:                 "timestampval timestamp, " +
1:c7b02d1:                 "timeuuidval timeuuid, " +
1:dc8a017:                 "tinyintval tinyint, " +
1:c7b02d1:                 "uuidval uuid," +
1:c7b02d1:                 "varcharval varchar, " +
1:c7b02d1:                 "varintval varint, " +
1:c7b02d1:                 "listval list<int>, " +
1:c7b02d1:                 "frozenlistval frozen<list<int>>, " +
1:c7b02d1:                 "setval set<uuid>, " +
1:c7b02d1:                 "frozensetval frozen<set<uuid>>, " +
1:c7b02d1:                 "mapval map<ascii, int>," +
1:c7b02d1:                 "frozenmapval frozen<map<ascii, int>>," +
1:c7b02d1:                 "tupleval frozen<tuple<int, ascii, uuid>>," +
1:bfd57d1:                 "udtval frozen<" + typeName + ">," +
1:bfd57d1:                 "durationval duration)");
1:c7b02d1: 
1:c7b02d1:         // fromJson() can only be used when the receiver type is known
1:c7b02d1:         assertInvalidMessage("fromJson() cannot be used in the selection clause", "SELECT fromJson(asciival) FROM %s", 0, 0);
1:c7b02d1: 
1:1937bed:         String func1 = createFunction(KEYSPACE, "int", "CREATE FUNCTION %s (a int) CALLED ON NULL INPUT RETURNS text LANGUAGE java AS $$ return a.toString(); $$");
1:1937bed:         createFunctionOverload(func1, "int", "CREATE FUNCTION %s (a text) CALLED ON NULL INPUT RETURNS text LANGUAGE java AS $$ return new String(a); $$");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Ambiguous call to function",
1:c7b02d1:                 "INSERT INTO %s (k, textval) VALUES (?, " + func1 + "(fromJson(?)))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // fails JSON parsing
1:c7b02d1:         assertInvalidMessage("Could not decode JSON string '\u038E\u0394\u03B4\u03E0'",
1:c7b02d1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\u038E\u0394\u03B4\u03E0");
1:c7b02d1: 
1:c7b02d1:         // handle nulls
1:c7b02d1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, null);
1:c7b02d1: 
1:c7b02d1:         // ================ ascii ================
1:c7b02d1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"ascii text\"");
1:c7b02d1:         assertRows(execute("SELECT k, asciival FROM %s WHERE k = ?", 0), row(0, "ascii text"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"ascii \\\" text\"");
1:c7b02d1:         assertRows(execute("SELECT k, asciival FROM %s WHERE k = ?", 0), row(0, "ascii \" text"));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Invalid ASCII character in string literal",
1:c7b02d1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"\\u1fff\\u2013\\u33B4\\u2014\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected an ascii string, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // test that we can use fromJson() in other valid places in queries
1:c7b02d1:         assertRows(execute("SELECT asciival FROM %s WHERE k = fromJson(?)", "0"), row("ascii \" text"));
1:c7b02d1:         execute("UPDATE %s SET asciival = fromJson(?) WHERE k = fromJson(?)", "\"ascii \\\" text\"", "0");
1:c7b02d1:         execute("DELETE FROM %s WHERE k = fromJson(?)", "0");
1:c7b02d1: 
1:c7b02d1:         // ================ bigint ================
1:c7b02d1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "123123123123");
1:c7b02d1:         assertRows(execute("SELECT k, bigintval FROM %s WHERE k = ?", 0), row(0, 123123123123L));
1:c7b02d1: 
1:c7b02d1:         // strings are also accepted
1:c7b02d1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "\"123123123123\"");
1:c7b02d1:         assertRows(execute("SELECT k, bigintval FROM %s WHERE k = ?", 0), row(0, 123123123123L));
1:c7b02d1: 
1:c7b02d1:         // overflow (Long.MAX_VALUE + 1)
1:c7b02d1:         assertInvalidMessage("Expected a bigint value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "9223372036854775808");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a bigint value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "123.456");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make long from",
1:c7b02d1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "\"abc\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a bigint value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1:c7b02d1: 
1:c7b02d1:         // ================ blob ================
1:c7b02d1:         execute("INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"0x00000001\"");
1:c7b02d1:         assertRows(execute("SELECT k, blobval FROM %s WHERE k = ?", 0), row(0, ByteBufferUtil.bytes(1)));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value 'xyzz' is not a valid blob representation",
1:c7b02d1:             "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("String representation of blob is missing 0x prefix: 123",
1:c7b02d1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"123\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value '0x123' is not a valid blob representation",
1:c7b02d1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"0x123\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value '123' is not a valid blob representation",
1:c7b02d1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // ================ boolean ================
1:c7b02d1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, true));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "false");
1:c7b02d1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, false));
1:c7b02d1: 
1:c7b02d1:         // strings are also accepted
1:c7b02d1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "\"false\"");
1:c7b02d1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, false));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make boolean from",
1:c7b02d1:                 "INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "\"abc\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a boolean value, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // ================ date ================
1:c7b02d1:         execute("INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "\"1987-03-23\"");
1:c7b02d1:         assertRows(execute("SELECT k, dateval FROM %s WHERE k = ?", 0), row(0, SimpleDateSerializer.dateStringToDays("1987-03-23")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a string representation of a date",
1:c7b02d1:                 "INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to coerce 'xyz' to a formatted date",
1:c7b02d1:                 "INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1:c7b02d1: 
1:c7b02d1:         // ================ decimal ================
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:c7b02d1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123.123123")));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "123123");
1:c7b02d1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123")));
1:c7b02d1: 
1:c7b02d1:         // accept strings for numbers that cannot be represented as doubles
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"123123.123123\"");
1:c7b02d1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123.123123")));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"-1.23E-12\"");
1:c7b02d1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("-1.23E-12")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value 'xyzz' is not a valid representation of a decimal value",
1:c7b02d1:                 "INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value 'true' is not a valid representation of a decimal value",
1:c7b02d1:                 "INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1: 
1:c7b02d1:         // ================ double ================
1:c7b02d1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:c7b02d1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.123123d));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "123123");
1:c7b02d1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.0d));
1:c7b02d1: 
1:c7b02d1:         // strings are also accepted
1:c7b02d1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "\"123123\"");
1:c7b02d1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.0d));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make double from",
1:c7b02d1:                 "INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a double value, but got",
1:c7b02d1:                 "INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1: 
1:c7b02d1:         // ================ float ================
1:c7b02d1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:c7b02d1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.123123f));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "123123");
1:c7b02d1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.0f));
1:c7b02d1: 
1:c7b02d1:         // strings are also accepted
1:c7b02d1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "\"123123.0\"");
1:c7b02d1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.0f));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make float from",
1:c7b02d1:                 "INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a float value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1: 
1:c7b02d1:         // ================ inet ================
1:c7b02d1:         execute("INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"127.0.0.1\"");
1:c7b02d1:         assertRows(execute("SELECT k, inetval FROM %s WHERE k = ?", 0), row(0, InetAddress.getByName("127.0.0.1")));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"::1\"");
1:c7b02d1:         assertRows(execute("SELECT k, inetval FROM %s WHERE k = ?", 0), row(0, InetAddress.getByName("::1")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make inet address from 'xyzz'",
1:c7b02d1:                 "INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a string representation of an inet value, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // ================ int ================
1:c7b02d1:         execute("INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "123123");
1:c7b02d1:         assertRows(execute("SELECT k, intval FROM %s WHERE k = ?", 0), row(0, 123123));
1:c7b02d1: 
1:c7b02d1:         // strings are also accepted
1:c7b02d1:         execute("INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "\"123123\"");
1:c7b02d1:         assertRows(execute("SELECT k, intval FROM %s WHERE k = ?", 0), row(0, 123123));
1:c7b02d1: 
1:c7b02d1:         // int overflow (2 ^ 32, or Integer.MAX_INT + 1)
1:c7b02d1:         assertInvalidMessage("Expected an int value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "2147483648");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected an int value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "123.456");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make int from",
1:c7b02d1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected an int value, but got a",
1:c7b02d1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1: 
1:dc8a017:         // ================ smallint ================
1:dc8a017:         execute("INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "32767");
1:dc8a017:         assertRows(execute("SELECT k, smallintval FROM %s WHERE k = ?", 0), row(0, (short) 32767));
1:dc8a017: 
1:dc8a017:         // strings are also accepted
1:dc8a017:         execute("INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "\"32767\"");
1:dc8a017:         assertRows(execute("SELECT k, smallintval FROM %s WHERE k = ?", 0), row(0, (short) 32767));
1:dc8a017: 
1:dc8a017:         // smallint overflow (Short.MAX_VALUE + 1)
1:dc8a017:         assertInvalidMessage("Unable to make short from",
1:dc8a017:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "32768");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Unable to make short from",
1:dc8a017:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "123.456");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Unable to make short from",
1:dc8a017:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Expected a short value, but got a Boolean",
1:dc8a017:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "true");
1:dc8a017: 
1:dc8a017:         // ================ tinyint ================
1:dc8a017:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "127");
1:dc8a017:         assertRows(execute("SELECT k, tinyintval FROM %s WHERE k = ?", 0), row(0, (byte) 127));
1:dc8a017: 
1:dc8a017:         // strings are also accepted
1:dc8a017:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "\"127\"");
1:dc8a017:         assertRows(execute("SELECT k, tinyintval FROM %s WHERE k = ?", 0), row(0, (byte) 127));
1:dc8a017: 
1:dc8a017:         // tinyint overflow (Byte.MAX_VALUE + 1)
1:dc8a017:         assertInvalidMessage("Unable to make byte from",
1:dc8a017:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "128");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Unable to make byte from",
1:dc8a017:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "123.456");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Unable to make byte from",
1:dc8a017:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:dc8a017: 
1:dc8a017:         assertInvalidMessage("Expected a byte value, but got a Boolean",
1:dc8a017:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "true");
1:dc8a017: 
1:c7b02d1:         // ================ text (varchar) ================
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"\"");
1:c7b02d1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, ""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"abcd\"");
1:c7b02d1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "abcd"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"some \\\" text\"");
1:c7b02d1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "some \" text"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"\\u2013\"");
1:c7b02d1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "\u2013"));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a UTF-8 string, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // ================ time ================
1:c7b02d1:         execute("INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "\"07:35:07.000111222\"");
1:c7b02d1:         assertRows(execute("SELECT k, timeval FROM %s WHERE k = ?", 0), row(0, TimeSerializer.timeStringToLong("07:35:07.000111222")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a string representation of a time value",
1:c7b02d1:                 "INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "123456");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to coerce 'xyz' to a formatted time",
1:c7b02d1:                 "INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1:c7b02d1: 
1:c7b02d1:         // ================ timestamp ================
1:c7b02d1:         execute("INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "123123123123");
1:c7b02d1:         assertRows(execute("SELECT k, timestampval FROM %s WHERE k = ?", 0), row(0, new Date(123123123123L)));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "\"2014-01-01\"");
1:c7b02d1:         assertRows(execute("SELECT k, timestampval FROM %s WHERE k = ?", 0), row(0, new SimpleDateFormat("y-M-d").parse("2014-01-01")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a long or a datestring representation of a timestamp value, but got a Double",
1:c7b02d1:                 "INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "123.456");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to coerce 'abcd' to a formatted date",
1:c7b02d1:                 "INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "\"abcd\"");
1:c7b02d1: 
1:c7b02d1:         // ================ timeuuid ================
1:c7b02d1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\"");
1:c7b02d1:         assertRows(execute("SELECT k, timeuuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"6BDDC89A-5644-11E4-97FC-56847AFE9799\"");
1:c7b02d1:         assertRows(execute("SELECT k, timeuuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("TimeUUID supports only version 1 UUIDs",
1:c7b02d1:                 "INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"00000000-0000-0000-0000-000000000000\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a string representation of a timeuuid, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:          // ================ uuidval ================
1:c7b02d1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\"");
1:c7b02d1:         assertRows(execute("SELECT k, uuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"6BDDC89A-5644-11E4-97FC-56847AFE9799\"");
1:c7b02d1:         assertRows(execute("SELECT k, uuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make UUID from",
1:c7b02d1:                 "INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"00000000-0000-0000-zzzz-000000000000\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a string representation of a uuid, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         // ================ varint ================
1:c7b02d1:         execute("INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "123123123123");
1:c7b02d1:         assertRows(execute("SELECT k, varintval FROM %s WHERE k = ?", 0), row(0, new BigInteger("123123123123")));
1:c7b02d1: 
1:c7b02d1:         // accept strings for numbers that cannot be represented as longs
1:c7b02d1:         execute("INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"1234567890123456789012345678901234567890\"");
1:c7b02d1:         assertRows(execute("SELECT k, varintval FROM %s WHERE k = ?", 0), row(0, new BigInteger("1234567890123456789012345678901234567890")));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value '123123.123' is not a valid representation of a varint value",
1:c7b02d1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "123123.123");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value 'xyzz' is not a valid representation of a varint value",
1:c7b02d1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value '' is not a valid representation of a varint value",
1:c7b02d1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"\"");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Value 'true' is not a valid representation of a varint value",
1:c7b02d1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "true");
1:c7b02d1: 
1:c7b02d1:         // ================ lists ================
1:c7b02d1:         execute("INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[1, 2, 3]");
1:c7b02d1:         assertRows(execute("SELECT k, listval FROM %s WHERE k = ?", 0), row(0, list(1, 2, 3)));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[]");
1:c7b02d1:         assertRows(execute("SELECT k, listval FROM %s WHERE k = ?", 0), row(0, null));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a list, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make int from",
1:c7b02d1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Invalid null element in list",
1:c7b02d1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[null]");
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozenlistval) VALUES (?, fromJson(?))", 0, "[1, 2, 3]");
1:c7b02d1:         assertRows(execute("SELECT k, frozenlistval FROM %s WHERE k = ?", 0), row(0, list(1, 2, 3)));
1:c7b02d1: 
1:c7b02d1:         // ================ sets ================
1:c7b02d1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // duplicates are okay, just like in CQL
1:c7b02d1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[]");
1:c7b02d1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0), row(0, null));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a list (representing a set), but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make UUID from",
1:c7b02d1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Invalid null element in set",
1:c7b02d1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[null]");
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1:         assertRows(execute("SELECT k, frozensetval FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9799\", \"6bddc89a-5644-11e4-97fc-56847afe9798\"]");
1:c7b02d1:         assertRows(execute("SELECT k, frozensetval FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // ================ maps ================
1:c7b02d1:         execute("INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": 2}");
1:c7b02d1:         assertRows(execute("SELECT k, mapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{}");
1:c7b02d1:         assertRows(execute("SELECT k, mapval FROM %s WHERE k = ?", 0), row(0, null));
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Expected a map, but got a Integer",
1:c7b02d1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "123");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Invalid ASCII character in string literal",
1:c7b02d1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"\\u1fff\\u2013\\u33B4\\u2014\": 1}");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Invalid null value in map",
1:c7b02d1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"a\": null}");
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": 2}");
1:c7b02d1:         assertRows(execute("SELECT k, frozenmapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, fromJson(?))", 0, "{\"b\": 2, \"a\": 1}");
1:c7b02d1:         assertRows(execute("SELECT k, frozenmapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1:c7b02d1: 
1:c7b02d1:         // ================ tuples ================
1:c7b02d1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))", 0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1:         assertRows(execute("SELECT k, tupleval FROM %s WHERE k = ?", 0),
1:c7b02d1:             row(0, tuple(1, "foobar", UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))", 0, "[1, null, \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1:         assertRows(execute("SELECT k, tupleval FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, tuple(1, null, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Tuple contains extra items",
1:c7b02d1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\", 1, 2, 3]");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Tuple is missing items",
1:c7b02d1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[1, \"foobar\"]");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make int from",
1:c7b02d1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:c7b02d1:                 0, "[\"not an int\", \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:c7b02d1: 
1:c7b02d1:         // ================ UDTs ================
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"foo\", \"bar\"]}");
1:c7b02d1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:c7b02d1:         );
1:c7b02d1: 
1:bfd57d1:         // ================ duration ================
1:bfd57d1:         execute("INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"53us\"");
1:bfd57d1:         assertRows(execute("SELECT k, durationval FROM %s WHERE k = ?", 0), row(0, Duration.newInstance(0, 0, 53000L)));
1:bfd57d1: 
1:bfd57d1:         execute("INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"P2W\"");
1:bfd57d1:         assertRows(execute("SELECT k, durationval FROM %s WHERE k = ?", 0), row(0, Duration.newInstance(0, 14, 0)));
1:bfd57d1: 
1:bfd57d1:         assertInvalidMessage("Unable to convert 'xyz' to a duration",
1:bfd57d1:                              "INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1:bfd57d1: 
1:c7b02d1:         // order of fields shouldn't matter
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"a\": 1, \"c\": [\"foo\", \"bar\"]}");
1:c7b02d1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // test nulls
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": null, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"foo\", \"bar\"]}");
1:c7b02d1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, null, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // test missing fields
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\"}");
1:c7b02d1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), null)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unknown field", "INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"xxx\": 1}");
1:c7b02d1:         assertInvalidMessage("Unable to make int from",
1:c7b02d1:                 "INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": \"foobar\"}");
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:c7b02d1:     public void testToJsonFct() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         String typeName = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
1:c7b02d1:         createTable("CREATE TABLE %s (" +
1:c7b02d1:                 "k int PRIMARY KEY, " +
1:c7b02d1:                 "asciival ascii, " +
1:c7b02d1:                 "bigintval bigint, " +
1:c7b02d1:                 "blobval blob, " +
1:c7b02d1:                 "booleanval boolean, " +
1:c7b02d1:                 "dateval date, " +
1:c7b02d1:                 "decimalval decimal, " +
1:c7b02d1:                 "doubleval double, " +
1:c7b02d1:                 "floatval float, " +
1:c7b02d1:                 "inetval inet, " +
1:c7b02d1:                 "intval int, " +
1:dc8a017:                 "smallintval smallint, " +
1:c7b02d1:                 "textval text, " +
1:c7b02d1:                 "timeval time, " +
1:c7b02d1:                 "timestampval timestamp, " +
1:c7b02d1:                 "timeuuidval timeuuid, " +
1:dc8a017:                 "tinyintval tinyint, " +
1:c7b02d1:                 "uuidval uuid," +
1:c7b02d1:                 "varcharval varchar, " +
1:c7b02d1:                 "varintval varint, " +
1:c7b02d1:                 "listval list<int>, " +
1:c7b02d1:                 "frozenlistval frozen<list<int>>, " +
1:c7b02d1:                 "setval set<uuid>, " +
1:c7b02d1:                 "frozensetval frozen<set<uuid>>, " +
1:c7b02d1:                 "mapval map<ascii, int>, " +
1:c7b02d1:                 "frozenmapval frozen<map<ascii, int>>, " +
1:c7b02d1:                 "tupleval frozen<tuple<int, ascii, uuid>>," +
1:bfd57d1:                 "udtval frozen<" + typeName + ">," +
1:bfd57d1:                 "durationval duration)");
1:c7b02d1: 
1:c7b02d1:         // toJson() can only be used in selections
1:c7b02d1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:c7b02d1:                 "INSERT INTO %s (k, asciival) VALUES (?, toJson(?))", 0, 0);
1:c7b02d1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:c7b02d1:                 "UPDATE %s SET asciival = toJson(?) WHERE k = ?", 0, 0);
1:c7b02d1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:c7b02d1:                 "DELETE FROM %s WHERE k = fromJson(toJson(?))", 0);
1:c7b02d1: 
1:c7b02d1:         // ================ ascii ================
1:c7b02d1:         execute("INSERT INTO %s (k, asciival) VALUES (?, ?)", 0, "ascii text");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(asciival) FROM %s WHERE k = ?", 0), row(0, "\"ascii text\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, asciival) VALUES (?, ?)", 0, "");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(asciival) FROM %s WHERE k = ?", 0), row(0, "\"\""));
1:c7b02d1: 
1:c7b02d1:         // ================ bigint ================
1:c7b02d1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, 123123123123L);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "123123123123"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, 0L);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, -123123123123L);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "-123123123123"));
1:c7b02d1: 
1:c7b02d1:         // ================ blob ================
1:c7b02d1:         execute("INSERT INTO %s (k, blobval) VALUES (?, ?)", 0, ByteBufferUtil.bytes(1));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(blobval) FROM %s WHERE k = ?", 0), row(0, "\"0x00000001\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, blobval) VALUES (?, ?)", 0, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(blobval) FROM %s WHERE k = ?", 0), row(0, "\"0x\""));
1:c7b02d1: 
1:c7b02d1:         // ================ boolean ================
1:c7b02d1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, ?)", 0, true);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(booleanval) FROM %s WHERE k = ?", 0), row(0, "true"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, ?)", 0, false);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(booleanval) FROM %s WHERE k = ?", 0), row(0, "false"));
1:c7b02d1: 
1:c7b02d1:         // ================ date ================
1:c7b02d1:         execute("INSERT INTO %s (k, dateval) VALUES (?, ?)", 0, SimpleDateSerializer.dateStringToDays("1987-03-23"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(dateval) FROM %s WHERE k = ?", 0), row(0, "\"1987-03-23\""));
1:c7b02d1: 
1:c7b02d1:         // ================ decimal ================
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, ?)", 0, new BigDecimal("123123.123123"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(decimalval) FROM %s WHERE k = ?", 0), row(0, "123123.123123"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, ?)", 0, new BigDecimal("-1.23E-12"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(decimalval) FROM %s WHERE k = ?", 0), row(0, "-1.23E-12"));
1:c7b02d1: 
1:c7b02d1:         // ================ double ================
1:c7b02d1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, ?)", 0, 123123.123123d);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(doubleval) FROM %s WHERE k = ?", 0), row(0, "123123.123123"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, ?)", 0, 123123d);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(doubleval) FROM %s WHERE k = ?", 0), row(0, "123123.0"));
1:c7b02d1: 
1:c7b02d1:         // ================ float ================
1:c7b02d1:         execute("INSERT INTO %s (k, floatval) VALUES (?, ?)", 0, 123.123f);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(floatval) FROM %s WHERE k = ?", 0), row(0, "123.123"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, floatval) VALUES (?, ?)", 0, 123123f);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(floatval) FROM %s WHERE k = ?", 0), row(0, "123123.0"));
1:c7b02d1: 
1:c7b02d1:         // ================ inet ================
1:c7b02d1:         execute("INSERT INTO %s (k, inetval) VALUES (?, ?)", 0, InetAddress.getByName("127.0.0.1"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(inetval) FROM %s WHERE k = ?", 0), row(0, "\"127.0.0.1\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, inetval) VALUES (?, ?)", 0, InetAddress.getByName("::1"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(inetval) FROM %s WHERE k = ?", 0), row(0, "\"0:0:0:0:0:0:0:1\""));
1:c7b02d1: 
1:c7b02d1:         // ================ int ================
1:c7b02d1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, 123123);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "123123"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, 0);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "0"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, -123123);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "-123123"));
1:c7b02d1: 
1:dc8a017:         // ================ smallint ================
1:dc8a017:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) 32767);
1:dc8a017:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "32767"));
1:dc8a017: 
1:dc8a017:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) 0);
1:dc8a017:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1:dc8a017: 
1:dc8a017:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) -32768);
1:dc8a017:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "-32768"));
1:dc8a017: 
1:dc8a017:         // ================ tinyint ================
1:dc8a017:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) 127);
1:dc8a017:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "127"));
1:dc8a017: 
1:dc8a017:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) 0);
1:dc8a017:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1:dc8a017: 
1:dc8a017:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) -128);
1:dc8a017:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "-128"));
1:dc8a017: 
1:c7b02d1:         // ================ text (varchar) ================
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "abcd");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"abcd\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "\u8422");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\u8422\""));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "\u0000");
1:c7b02d1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\\u0000\""));
1:c7b02d1: 
1:c7b02d1:         // ================ timestamp ================
1:c7b02d1:         execute("INSERT INTO %s (k, timeval) VALUES (?, ?)", 0, 123L);
1:c7b02d1:         assertRows(execute("SELECT k, toJson(timeval) FROM %s WHERE k = ?", 0), row(0, "\"00:00:00.000000123\""));
1:c7b02d1: 
1:c7b02d1:         // ================ timestamp ================
1:88f22b9:         SimpleDateFormat sdf = new SimpleDateFormat("y-M-d");
1:88f22b9:         sdf.setTimeZone(TimeZone.getTimeZone("UDT"));
1:88f22b9:         execute("INSERT INTO %s (k, timestampval) VALUES (?, ?)", 0, sdf.parse("2014-01-01"));
1:88f22b9:         assertRows(execute("SELECT k, toJson(timestampval) FROM %s WHERE k = ?", 0), row(0, "\"2014-01-01 00:00:00.000Z\""));
1:c7b02d1: 
1:c7b02d1:         // ================ timeuuid ================
1:c7b02d1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, ?)", 0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(timeuuidval) FROM %s WHERE k = ?", 0), row(0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\""));
1:c7b02d1: 
1:c7b02d1:          // ================ uuidval ================
1:c7b02d1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, ?)", 0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(uuidval) FROM %s WHERE k = ?", 0), row(0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\""));
1:c7b02d1: 
1:c7b02d1:         // ================ varint ================
1:c7b02d1:         execute("INSERT INTO %s (k, varintval) VALUES (?, ?)", 0, new BigInteger("123123123123123123123"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(varintval) FROM %s WHERE k = ?", 0), row(0, "123123123123123123123"));
1:c7b02d1: 
1:c7b02d1:         // ================ lists ================
1:c7b02d1:         execute("INSERT INTO %s (k, listval) VALUES (?, ?)", 0, list(1, 2, 3));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(listval) FROM %s WHERE k = ?", 0), row(0, "[1, 2, 3]"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, listval) VALUES (?, ?)", 0, list());
1:c7b02d1:         assertRows(execute("SELECT k, toJson(listval) FROM %s WHERE k = ?", 0), row(0, "null"));
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozenlistval) VALUES (?, ?)", 0, list(1, 2, 3));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(frozenlistval) FROM %s WHERE k = ?", 0), row(0, "[1, 2, 3]"));
1:c7b02d1: 
1:c7b02d1:         // ================ sets ================
1:c7b02d1:         execute("INSERT INTO %s (k, setval) VALUES (?, ?)",
1:c7b02d1:                 0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(setval) FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, setval) VALUES (?, ?)", 0, set());
1:c7b02d1:         assertRows(execute("SELECT k, toJson(setval) FROM %s WHERE k = ?", 0), row(0, "null"));
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, ?)",
1:c7b02d1:                 0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(frozensetval) FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // ================ maps ================
1:c7b02d1:         execute("INSERT INTO %s (k, mapval) VALUES (?, ?)", 0, map("a", 1, "b", 2));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(mapval) FROM %s WHERE k = ?", 0), row(0, "{\"a\": 1, \"b\": 2}"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, mapval) VALUES (?, ?)", 0, map());
1:c7b02d1:         assertRows(execute("SELECT k, toJson(mapval) FROM %s WHERE k = ?", 0), row(0, "null"));
1:c7b02d1: 
1:c7b02d1:         // frozen
1:c7b02d1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, ?)", 0, map("a", 1, "b", 2));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(frozenmapval) FROM %s WHERE k = ?", 0), row(0, "{\"a\": 1, \"b\": 2}"));
1:c7b02d1: 
1:c7b02d1:         // ================ tuples ================
1:c7b02d1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, ?)", 0, tuple(1, "foobar", UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(tupleval) FROM %s WHERE k = ?", 0),
1:c7b02d1:             row(0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, ?)", 0, tuple(1, "foobar", null));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(tupleval) FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, "[1, \"foobar\", null]")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // ================ UDTs ================
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, {a: ?, b: ?, c: ?})", 0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("foo", "bar"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(udtval) FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"bar\", \"foo\"]}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s (k, udtval) VALUES (?, {a: ?, b: ?})", 0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:c7b02d1:         assertRows(execute("SELECT k, toJson(udtval) FROM %s WHERE k = ?", 0),
1:c7b02d1:                 row(0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": null}")
1:c7b02d1:         );
1:bfd57d1: 
1:bfd57d1:         // ================ duration ================
1:bfd57d1:         execute("INSERT INTO %s (k, durationval) VALUES (?, 12µs)", 0);
1:bfd57d1:         assertRows(execute("SELECT k, toJson(durationval) FROM %s WHERE k = ?", 0), row(0, "12us"));
1:bfd57d1: 
1:bfd57d1:         execute("INSERT INTO %s (k, durationval) VALUES (?, P1Y1M2DT10H5M)", 0);
1:bfd57d1:         assertRows(execute("SELECT k, toJson(durationval) FROM %s WHERE k = ?", 0), row(0, "1y1mo2d10h5m"));
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:c7b02d1:     public void testSelectJsonSyntax() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         // tests SELECT JSON statements
1:c7b02d1:         createTable("CREATE TABLE %s (k int primary key, v int)");
1:c7b02d1:         execute("INSERT INTO %s (k, v) VALUES (0, 0)");
1:c7b02d1:         execute("INSERT INTO %s (k, v) VALUES (1, 1)");
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON * FROM %s"),
1:c7b02d1:                 row("{\"k\": 0, \"v\": 0}"),
1:c7b02d1:                 row("{\"k\": 1, \"v\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON k, v FROM %s"),
1:c7b02d1:                 row("{\"k\": 0, \"v\": 0}"),
1:c7b02d1:                 row("{\"k\": 1, \"v\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON v, k FROM %s"),
1:c7b02d1:                 row("{\"v\": 0, \"k\": 0}"),
1:c7b02d1:                 row("{\"v\": 1, \"k\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON v as foo, k as bar FROM %s"),
1:c7b02d1:                 row("{\"foo\": 0, \"bar\": 0}"),
1:c7b02d1:                 row("{\"foo\": 1, \"bar\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON ttl(v), k FROM %s"),
1:c7b02d1:                 row("{\"ttl(v)\": null, \"k\": 0}"),
1:c7b02d1:                 row("{\"ttl(v)\": null, \"k\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON ttl(v) as foo, k FROM %s"),
1:c7b02d1:                 row("{\"foo\": null, \"k\": 0}"),
1:c7b02d1:                 row("{\"foo\": null, \"k\": 1}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON count(*) FROM %s"),
1:c7b02d1:                 row("{\"count\": 2}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON count(*) as foo FROM %s"),
1:c7b02d1:                 row("{\"foo\": 2}")
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         assertRows(execute("SELECT JSON toJson(blobAsInt(intAsBlob(v))) FROM %s LIMIT 1"),
1:c7b02d1:                 row("{\"system.tojson(system.blobasint(system.intasblob(v)))\": \"0\"}")
1:c7b02d1:         );
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:c7b02d1:     public void testInsertJsonSyntax() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         createTable("CREATE TABLE %s (k int primary key, v int)");
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": 0}");
1:c7b02d1:         assertRows(execute("SELECT * FROM %s"),
1:c7b02d1:                 row(0, 0)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         // without specifying column names
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": 0}");
1:c7b02d1:         assertRows(execute("SELECT * FROM %s"),
1:c7b02d1:                 row(0, 0)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": null}");
1:c7b02d1:         assertRows(execute("SELECT * FROM %s"),
1:c7b02d1:                 row(0, null)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"v\": 1, \"k\": 0}");
1:c7b02d1:         assertRows(execute("SELECT * FROM %s"),
1:c7b02d1:                 row(0, 1)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0}");
1:c7b02d1:         assertRows(execute("SELECT * FROM %s"),
1:c7b02d1:                 row(0, null)
1:c7b02d1:         );
1:c7b02d1: 
1:c7b02d1:         if (USE_PREPARED_VALUES)
1:c7b02d1:             assertInvalidMessage("Got null for INSERT JSON values", "INSERT INTO %s JSON ?", new Object[]{null});
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Got null for INSERT JSON values", "INSERT INTO %s JSON ?", "null");
1:c7b02d1:         assertInvalidMessage("Could not decode JSON string as a map", "INSERT INTO %s JSON ?", "\"notamap\"");
1:c7b02d1:         assertInvalidMessage("Could not decode JSON string as a map", "INSERT INTO %s JSON ?", "12.34");
1:c7b02d1:         assertInvalidMessage("JSON values map contains unrecognized column",
1:c7b02d1:                 "INSERT INTO %s JSON ?",
1:c7b02d1:                 "{\"k\": 0, \"v\": 0, \"zzz\": 0}");
1:c7b02d1: 
1:c7b02d1:         assertInvalidMessage("Unable to make int from",
1:c7b02d1:                 "INSERT INTO %s JSON ?",
1:c7b02d1:                 "{\"k\": 0, \"v\": \"notanint\"}");
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:1291135:     public void testInsertJsonSyntaxDefaultUnset() throws Throwable
1:1291135:     {
1:1291135:         createTable("CREATE TABLE %s (k int primary key, v1 int, v2 int)");
1:1291135:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v1\": 0, \"v2\": 0}");
1:1291135: 
1:1291135:         // leave v1 unset
1:1291135:         execute("INSERT INTO %s JSON ? DEFAULT UNSET", "{\"k\": 0, \"v2\": 2}");
1:1291135:         assertRows(execute("SELECT * FROM %s"),
1:1291135:                 row(0, 0, 2)
1:1291135:         );
1:1291135: 
1:1291135:         // explicit specification DEFAULT NULL
1:1291135:         execute("INSERT INTO %s JSON ? DEFAULT NULL", "{\"k\": 0, \"v2\": 2}");
1:1291135:         assertRows(execute("SELECT * FROM %s"),
1:1291135:                 row(0, null, 2)
1:1291135:         );
1:1291135: 
1:1291135:         // implicitly setting v2 to null
1:1291135:         execute("INSERT INTO %s JSON ? DEFAULT NULL", "{\"k\": 0}");
1:1291135:         assertRows(execute("SELECT * FROM %s"),
1:1291135:                 row(0, null, null)
1:1291135:         );
1:1291135: 
1:1291135:         // mix setting null explicitly with default unset:
1:1291135:         // set values for all fields
1:1291135:         execute("INSERT INTO %s JSON ?", "{\"k\": 1, \"v1\": 1, \"v2\": 1}");
1:1291135:         // explicitly set v1 to null while leaving v2 unset which retains its value
1:1291135:         execute("INSERT INTO %s JSON ? DEFAULT UNSET", "{\"k\": 1, \"v1\": null}");
1:1291135:         assertRows(execute("SELECT * FROM %s WHERE k=1"),
1:1291135:                 row(1, null, 1)
1:1291135:         );
1:1291135: 
1:1291135:         // test string literal instead of bind marker
1:1291135:         execute("INSERT INTO %s JSON '{\"k\": 2, \"v1\": 2, \"v2\": 2}'");
1:1291135:         // explicitly set v1 to null while leaving v2 unset which retains its value
1:1291135:         execute("INSERT INTO %s JSON '{\"k\": 2, \"v1\": null}' DEFAULT UNSET");
1:1291135:         assertRows(execute("SELECT * FROM %s WHERE k=2"),
1:1291135:                 row(2, null, 2)
1:1291135:         );
1:1291135:         execute("INSERT INTO %s JSON '{\"k\": 2}' DEFAULT NULL");
1:1291135:         assertRows(execute("SELECT * FROM %s WHERE k=2"),
1:1291135:                 row(2, null, null)
1:1291135:         );
1:1291135:     }
1:1291135: 
1:1291135:     @Test
1:c7b02d1:     public void testCaseSensitivity() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         createTable("CREATE TABLE %s (k int primary key, \"Foo\" int)");
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"\\\"Foo\\\"\": 0}");
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"K\": 0, \"\\\"Foo\\\"\": 0}");
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"\\\"k\\\"\": 0, \"\\\"Foo\\\"\": 0}");
1:c7b02d1: 
1:c7b02d1:         // results should preserve and quote case-sensitive identifiers
1:c7b02d1:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"\\\"Foo\\\"\": 0}"));
1:c7b02d1:         assertRows(execute("SELECT JSON k, \"Foo\" as foo FROM %s"), row("{\"k\": 0, \"foo\": 0}"));
1:c7b02d1:         assertRows(execute("SELECT JSON k, \"Foo\" as \"Bar\" FROM %s"), row("{\"k\": 0, \"\\\"Bar\\\"\": 0}"));
1:c7b02d1: 
1:c7b02d1:         assertInvalid("INSERT INTO %s JSON ?", "{\"k\": 0, \"foo\": 0}");
1:c7b02d1:         assertInvalid("INSERT INTO %s JSON ?", "{\"k\": 0, \"\\\"foo\\\"\": 0}");
1:c7b02d1: 
1:c7b02d1:         // user-defined types also need to handle case-sensitivity
1:c7b02d1:         String typeName = createType("CREATE TYPE %s (a int, \"Foo\" int)");
1:c7b02d1:         createTable("CREATE TABLE %s (k int primary key, v frozen<" + typeName + ">)");
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}");
1:c7b02d1:         assertRows(execute("SELECT JSON k, v FROM %s"), row("{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}"));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": {\"A\": 0, \"\\\"Foo\\\"\": 0}}");
1:c7b02d1:         assertRows(execute("SELECT JSON k, v FROM %s"), row("{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}"));
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:c7b02d1:     public void testInsertJsonSyntaxWithCollections() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         createTable("CREATE TABLE %s (" +
1:c7b02d1:                 "k int PRIMARY KEY, " +
1:c7b02d1:                 "m map<text, boolean>, " +
1:c7b02d1:                 "mf frozen<map<text, boolean>>, " +
1:c7b02d1:                 "s set<int>, " +
1:c7b02d1:                 "sf frozen<set<int>>, " +
1:c7b02d1:                 "l list<int>, " +
1:c7b02d1:                 "lf frozen<list<int>>)");
1:c7b02d1: 
1:c7b02d1:         // map
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"m\": {\"a\": true, \"b\": false}}");
1:c7b02d1:         assertRows(execute("SELECT k, m FROM %s"), row(0, map("a", true, "b", false)));
1:c7b02d1: 
1:c7b02d1:         // frozen map
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"mf\": {\"a\": true, \"b\": false}}");
1:c7b02d1:         assertRows(execute("SELECT k, mf FROM %s"), row(0, map("a", true, "b", false)));
1:c7b02d1: 
1:c7b02d1:         // set
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"s\": [3, 1, 2]}");
1:c7b02d1:         assertRows(execute("SELECT k, s FROM %s"), row(0, set(1, 2, 3)));
1:c7b02d1: 
1:c7b02d1:         // frozen set
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"sf\": [3, 1, 2]}");
1:c7b02d1:         assertRows(execute("SELECT k, sf FROM %s"), row(0, set(1, 2, 3)));
1:c7b02d1: 
1:c7b02d1:         // list
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"l\": [1, 2, 3]}");
1:c7b02d1:         assertRows(execute("SELECT k, l FROM %s"), row(0, list(1, 2, 3)));
1:c7b02d1: 
1:c7b02d1:         // frozen list
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"lf\": [1, 2, 3]}");
1:c7b02d1:         assertRows(execute("SELECT k, lf FROM %s"), row(0, list(1, 2, 3)));
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Test
1:b7be198:     public void testInsertJsonSyntaxWithNonNativeMapKeys() throws Throwable
1:b7be198:     {
1:b7be198:         // JSON doesn't allow non-string keys, so we accept string representations of any type as map keys and
1:b7be198:         // return maps with string keys when necessary.
1:b7be198: 
1:b7be198:         String typeName = createType("CREATE TYPE %s (a int)");
1:b7be198:         createTable("CREATE TABLE %s (" +
1:b7be198:                 "k int PRIMARY KEY, " +
1:b7be198:                 "intmap map<int, boolean>, " +
1:b7be198:                 "bigintmap map<bigint, boolean>, " +
1:b7be198:                 "varintmap map<varint, boolean>, " +
1:dc8a017:                 "smallintmap map<smallint, boolean>, " +
1:dc8a017:                 "tinyintmap map<tinyint, boolean>, " +
1:b7be198:                 "booleanmap map<boolean, boolean>, " +
1:b7be198:                 "floatmap map<float, boolean>, " +
1:b7be198:                 "doublemap map<double, boolean>, " +
1:b7be198:                 "decimalmap map<decimal, boolean>, " +
1:b7be198:                 "tuplemap map<frozen<tuple<int, text>>, boolean>, " +
1:b7be198:                 "udtmap map<frozen<" + typeName + ">, boolean>, " +
1:b7be198:                 "setmap map<frozen<set<int>>, boolean>, " +
1:b7be198:                 "listmap map<frozen<list<int>>, boolean>, " +
1:b7be198:                 "textsetmap map<frozen<set<text>>, boolean>, " +
1:b7be198:                 "nestedsetmap map<frozen<map<set<text>, text>>, boolean>, " +
1:b7be198:                 "frozensetmap frozen<map<set<int>, boolean>>)");
1:b7be198: 
1:b7be198:         // int keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"intmap\": {\"0\": true, \"1\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, intmap FROM %s"), row("{\"k\": 0, \"intmap\": {\"0\": true, \"1\": false}}"));
1:b7be198: 
1:b7be198:         // bigint keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"bigintmap\": {\"0\": true, \"1\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, bigintmap FROM %s"), row("{\"k\": 0, \"bigintmap\": {\"0\": true, \"1\": false}}"));
1:b7be198: 
1:b7be198:         // varint keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"varintmap\": {\"0\": true, \"1\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, varintmap FROM %s"), row("{\"k\": 0, \"varintmap\": {\"0\": true, \"1\": false}}"));
1:b7be198: 
1:dc8a017:         // smallint keys
1:dc8a017:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"smallintmap\": {\"0\": true, \"1\": false}}");
1:dc8a017:         assertRows(execute("SELECT JSON k, smallintmap FROM %s"), row("{\"k\": 0, \"smallintmap\": {\"0\": true, \"1\": false}}"));
1:dc8a017: 
1:dc8a017:         // tinyint keys
1:dc8a017:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"tinyintmap\": {\"0\": true, \"1\": false}}");
1:dc8a017:         assertRows(execute("SELECT JSON k, tinyintmap FROM %s"), row("{\"k\": 0, \"tinyintmap\": {\"0\": true, \"1\": false}}"));
1:dc8a017: 
1:b7be198:         // boolean keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"booleanmap\": {\"true\": true, \"false\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, booleanmap FROM %s"), row("{\"k\": 0, \"booleanmap\": {\"false\": false, \"true\": true}}"));
1:b7be198: 
1:b7be198:         // float keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"floatmap\": {\"1.23\": true, \"4.56\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, floatmap FROM %s"), row("{\"k\": 0, \"floatmap\": {\"1.23\": true, \"4.56\": false}}"));
1:b7be198: 
1:b7be198:         // double keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"doublemap\": {\"1.23\": true, \"4.56\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, doublemap FROM %s"), row("{\"k\": 0, \"doublemap\": {\"1.23\": true, \"4.56\": false}}"));
1:b7be198: 
1:b7be198:         // decimal keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"decimalmap\": {\"1.23\": true, \"4.56\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, decimalmap FROM %s"), row("{\"k\": 0, \"decimalmap\": {\"1.23\": true, \"4.56\": false}}"));
1:b7be198: 
1:b7be198:         // tuple<int, text> keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"tuplemap\": {\"[0, \\\"a\\\"]\": true, \"[1, \\\"b\\\"]\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, tuplemap FROM %s"), row("{\"k\": 0, \"tuplemap\": {\"[0, \\\"a\\\"]\": true, \"[1, \\\"b\\\"]\": false}}"));
1:b7be198: 
1:b7be198:         // UDT keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"udtmap\": {\"{\\\"a\\\": 0}\": true, \"{\\\"a\\\": 1}\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, udtmap FROM %s"), row("{\"k\": 0, \"udtmap\": {\"{\\\"a\\\": 0}\": true, \"{\\\"a\\\": 1}\": false}}"));
1:b7be198: 
1:b7be198:         // set<int> keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"setmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, setmap FROM %s"), row("{\"k\": 0, \"setmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1:b7be198: 
1:b7be198:         // list<int> keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"listmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, listmap FROM %s"), row("{\"k\": 0, \"listmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1:b7be198: 
1:b7be198:         // set<text> keys
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"textsetmap\": {\"[\\\"0\\\", \\\"1\\\"]\": true, \"[\\\"3\\\", \\\"4\\\"]\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, textsetmap FROM %s"), row("{\"k\": 0, \"textsetmap\": {\"[\\\"0\\\", \\\"1\\\"]\": true, \"[\\\"3\\\", \\\"4\\\"]\": false}}"));
1:b7be198: 
1:b7be198:         // map<set<text>, text> keys
1:b7be198:         String innerKey1 = "[\"0\", \"1\"]";
1:6b1bd17:         String fullKey1 = String.format("{\"%s\": \"%s\"}", Json.quoteAsJsonString(innerKey1), "a");
1:6b1bd17:         String stringKey1 = Json.quoteAsJsonString(fullKey1);
1:b7be198:         String innerKey2 = "[\"3\", \"4\"]";
1:6b1bd17:         String fullKey2 = String.format("{\"%s\": \"%s\"}", Json.quoteAsJsonString(innerKey2), "b");
1:6b1bd17:         String stringKey2 = Json.quoteAsJsonString(fullKey2);
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"nestedsetmap\": {\"" + stringKey1 + "\": true, \"" + stringKey2 + "\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, nestedsetmap FROM %s"), row("{\"k\": 0, \"nestedsetmap\": {\"" + stringKey1 + "\": true, \"" + stringKey2 + "\": false}}"));
1:b7be198: 
1:b7be198:         // set<int> keys in a frozen map
1:b7be198:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"frozensetmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:b7be198:         assertRows(execute("SELECT JSON k, frozensetmap FROM %s"), row("{\"k\": 0, \"frozensetmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1:b7be198:     }
1:b7be198: 
1:b7be198:     @Test
1:c7b02d1:     public void testInsertJsonSyntaxWithTuplesAndUDTs() throws Throwable
1:c7b02d1:     {
1:c7b02d1:         String typeName = createType("CREATE TYPE %s (a int, b frozen<set<int>>, c tuple<int, int>)");
1:c7b02d1:         createTable("CREATE TABLE %s (" +
1:c7b02d1:                 "k int PRIMARY KEY, " +
1:c7b02d1:                 "a frozen<" + typeName + ">, " +
1:c7b02d1:                 "b tuple<int, boolean>)");
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": [1, 2, 3], \"c\": [0, 1]}, \"b\": [0, true]}");
1:c7b02d1:         assertRows(execute("SELECT k, a.a, a.b, a.c, b FROM %s"), row(0, 0, set(1, 2, 3), tuple(0, 1), tuple(0, true)));
1:c7b02d1: 
1:c7b02d1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": [1, 2, 3], \"c\": null}, \"b\": null}");
1:c7b02d1:         assertRows(execute("SELECT k, a.a, a.b, a.c, b FROM %s"), row(0, 0, set(1, 2, 3), null, null));
1:c7b02d1:     }
1:6b1bd17: 
1:c116207:     // done for CASSANDRA-11146
1:c116207:     @Test
1:c116207:     public void testAlterUDT() throws Throwable
1:c116207:     {
1:c116207:         String typeName = createType("CREATE TYPE %s (a int)");
1:c116207:         createTable("CREATE TABLE %s (" +
1:c116207:                 "k int PRIMARY KEY, " +
1:c116207:                 "a frozen<" + typeName + ">)");
1:c116207: 
1:c116207:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0}}");
1:c116207:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0}}"));
1:c116207: 
1:c116207:         schemaChange("ALTER TYPE " + KEYSPACE + "." + typeName + " ADD b boolean");
1:c116207:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0, \"b\": null}}"));
1:c116207: 
1:c116207:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": true}}");
1:c116207:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0, \"b\": true}}"));
1:c116207:     }
1:c116207: 
1:6b1bd17:     // done for CASSANDRA-11048
1:6b1bd17:     @Test
1:fc972b9:     public void testJsonThreadSafety() throws Throwable
1:6b1bd17:     {
1:6b1bd17:         int numThreads = 10;
1:a5dac12:         final int numRows = 5000;
1:6b1bd17: 
1:6b1bd17:         createTable("CREATE TABLE %s (" +
1:6b1bd17:                 "k text PRIMARY KEY, " +
1:6b1bd17:                 "v text)");
1:6b1bd17: 
1:6b1bd17:         for (int i = 0; i < numRows; i++)
1:6b1bd17:             execute("INSERT INTO %s (k, v) VALUES (?, ?)", "" + i, "" + i);
1:6b1bd17: 
1:6b1bd17:         long seed = System.nanoTime();
1:6b1bd17:         System.out.println("Seed " + seed);
1:6b1bd17:         final Random rand = new Random(seed);
1:6b1bd17: 
1:6b1bd17:         final Runnable worker = new Runnable()
1:6b1bd17:         {
1:6b1bd17:             @Override
1:6b1bd17:             public void run()
1:6b1bd17:             {
1:6b1bd17:                 try
1:6b1bd17:                 {
1:6b1bd17:                     for (int i = 0; i < numRows; i++)
1:6b1bd17:                     {
1:6b1bd17:                         String key = "" + rand.nextInt(numRows);
1:6b1bd17:                         assertRows(execute("SELECT JSON * FROM %s WHERE k = ?", key),
1:6b1bd17:                                 row(String.format("{\"k\": \"%s\", \"v\": \"%s\"}", key, key)));
1:6b1bd17:                     }
1:6b1bd17:                 }
1:6b1bd17:                 catch (Throwable exc)
1:6b1bd17:                 {
1:6b1bd17:                     exc.printStackTrace();
1:6b1bd17:                     fail(exc.getMessage());
1:6b1bd17:                 }
1:6b1bd17:             }
1:6b1bd17:         };
1:6b1bd17: 
1:6b1bd17:         ExecutorService executor = Executors.newFixedThreadPool(numThreads);
1:6b1bd17:         List<Future> futures = new ArrayList<>();
1:6b1bd17:         for (int i = 0; i < numThreads; i++)
1:6b1bd17:             futures.add(executor.submit(worker));
1:6b1bd17: 
1:6b1bd17:         for (Future future : futures)
1:a5dac12:             future.get(30, TimeUnit.SECONDS);
1:6b1bd17: 
1:6b1bd17:         executor.shutdown();
1:a5dac12:         Assert.assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS));
1:6b1bd17:     }
1:c7b02d1: }
============================================================================
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:bfd57d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Duration;
/////////////////////////////////////////////////////////////////////////
1:                 "udtval frozen<" + typeName + ">," +
1:                 "durationval duration)");
/////////////////////////////////////////////////////////////////////////
1:         // ================ duration ================
1:         execute("INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"53us\"");
1:         assertRows(execute("SELECT k, durationval FROM %s WHERE k = ?", 0), row(0, Duration.newInstance(0, 0, 53000L)));
1: 
1:         execute("INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"P2W\"");
1:         assertRows(execute("SELECT k, durationval FROM %s WHERE k = ?", 0), row(0, Duration.newInstance(0, 14, 0)));
1: 
1:         assertInvalidMessage("Unable to convert 'xyz' to a duration",
1:                              "INSERT INTO %s (k, durationval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1: 
/////////////////////////////////////////////////////////////////////////
1:                 "udtval frozen<" + typeName + ">," +
1:                 "durationval duration)");
/////////////////////////////////////////////////////////////////////////
1: 
1:         // ================ duration ================
1:         execute("INSERT INTO %s (k, durationval) VALUES (?, 12µs)", 0);
1:         assertRows(execute("SELECT k, toJson(durationval) FROM %s WHERE k = ?", 0), row(0, "12us"));
1: 
1:         execute("INSERT INTO %s (k, durationval) VALUES (?, P1Y1M2DT10H5M)", 0);
1:         assertRows(execute("SELECT k, toJson(durationval) FROM %s WHERE k = ?", 0), row(0, "1y1mo2d10h5m"));
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:df192c9
commit:2d73f3b
commit:91a48d2
commit:a5dac12
/////////////////////////////////////////////////////////////////////////
1:         final int numRows = 5000;
/////////////////////////////////////////////////////////////////////////
1:             future.get(30, TimeUnit.SECONDS);
1:         Assert.assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS));
commit:c64d3a5
commit:c116207
/////////////////////////////////////////////////////////////////////////
1:     // done for CASSANDRA-11146
1:     @Test
1:     public void testAlterUDT() throws Throwable
1:     {
1:         String typeName = createType("CREATE TYPE %s (a int)");
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "a frozen<" + typeName + ">)");
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0}}");
1:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0}}"));
1: 
1:         schemaChange("ALTER TYPE " + KEYSPACE + "." + typeName + " ADD b boolean");
1:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0, \"b\": null}}"));
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": true}}");
1:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"a\": {\"a\": 0, \"b\": true}}"));
1:     }
1: 
commit:9b5af91
commit:6b1bd17
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Assert;
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:         String fullKey1 = String.format("{\"%s\": \"%s\"}", Json.quoteAsJsonString(innerKey1), "a");
1:         String stringKey1 = Json.quoteAsJsonString(fullKey1);
1:         String fullKey2 = String.format("{\"%s\": \"%s\"}", Json.quoteAsJsonString(innerKey2), "b");
1:         String stringKey2 = Json.quoteAsJsonString(fullKey2);
/////////////////////////////////////////////////////////////////////////
1: 
1:     // done for CASSANDRA-11048
1:     @Test
0:     public void testJsonTreadSafety() throws Throwable
1:     {
1:         int numThreads = 10;
0:         final int numRows = 10000;
1: 
1:         createTable("CREATE TABLE %s (" +
1:                 "k text PRIMARY KEY, " +
1:                 "v text)");
1: 
1:         for (int i = 0; i < numRows; i++)
1:             execute("INSERT INTO %s (k, v) VALUES (?, ?)", "" + i, "" + i);
1: 
1:         long seed = System.nanoTime();
1:         System.out.println("Seed " + seed);
1:         final Random rand = new Random(seed);
1: 
1:         final Runnable worker = new Runnable()
1:         {
1:             @Override
1:             public void run()
1:             {
1:                 try
1:                 {
1:                     for (int i = 0; i < numRows; i++)
1:                     {
1:                         String key = "" + rand.nextInt(numRows);
1:                         assertRows(execute("SELECT JSON * FROM %s WHERE k = ?", key),
1:                                 row(String.format("{\"k\": \"%s\", \"v\": \"%s\"}", key, key)));
1:                     }
1:                 }
1:                 catch (Throwable exc)
1:                 {
1:                     exc.printStackTrace();
1:                     fail(exc.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         ExecutorService executor = Executors.newFixedThreadPool(numThreads);
1:         List<Future> futures = new ArrayList<>();
1:         for (int i = 0; i < numThreads; i++)
1:             futures.add(executor.submit(worker));
1: 
1:         for (Future future : futures)
0:             future.get(10, TimeUnit.SECONDS);
1: 
1:         executor.shutdown();
0:         Assert.assertTrue(executor.awaitTermination(10, TimeUnit.SECONDS));
1:     }
commit:b7be198
/////////////////////////////////////////////////////////////////////////
1:     public void testInsertJsonSyntaxWithNonNativeMapKeys() throws Throwable
1:     {
1:         // JSON doesn't allow non-string keys, so we accept string representations of any type as map keys and
1:         // return maps with string keys when necessary.
1: 
1:         String typeName = createType("CREATE TYPE %s (a int)");
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "intmap map<int, boolean>, " +
1:                 "bigintmap map<bigint, boolean>, " +
1:                 "varintmap map<varint, boolean>, " +
1:                 "booleanmap map<boolean, boolean>, " +
1:                 "floatmap map<float, boolean>, " +
1:                 "doublemap map<double, boolean>, " +
1:                 "decimalmap map<decimal, boolean>, " +
1:                 "tuplemap map<frozen<tuple<int, text>>, boolean>, " +
1:                 "udtmap map<frozen<" + typeName + ">, boolean>, " +
1:                 "setmap map<frozen<set<int>>, boolean>, " +
1:                 "listmap map<frozen<list<int>>, boolean>, " +
1:                 "textsetmap map<frozen<set<text>>, boolean>, " +
1:                 "nestedsetmap map<frozen<map<set<text>, text>>, boolean>, " +
1:                 "frozensetmap frozen<map<set<int>, boolean>>)");
1: 
1:         // int keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"intmap\": {\"0\": true, \"1\": false}}");
1:         assertRows(execute("SELECT JSON k, intmap FROM %s"), row("{\"k\": 0, \"intmap\": {\"0\": true, \"1\": false}}"));
1: 
1:         // bigint keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"bigintmap\": {\"0\": true, \"1\": false}}");
1:         assertRows(execute("SELECT JSON k, bigintmap FROM %s"), row("{\"k\": 0, \"bigintmap\": {\"0\": true, \"1\": false}}"));
1: 
1:         // varint keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"varintmap\": {\"0\": true, \"1\": false}}");
1:         assertRows(execute("SELECT JSON k, varintmap FROM %s"), row("{\"k\": 0, \"varintmap\": {\"0\": true, \"1\": false}}"));
1: 
1:         // boolean keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"booleanmap\": {\"true\": true, \"false\": false}}");
1:         assertRows(execute("SELECT JSON k, booleanmap FROM %s"), row("{\"k\": 0, \"booleanmap\": {\"false\": false, \"true\": true}}"));
1: 
1:         // float keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"floatmap\": {\"1.23\": true, \"4.56\": false}}");
1:         assertRows(execute("SELECT JSON k, floatmap FROM %s"), row("{\"k\": 0, \"floatmap\": {\"1.23\": true, \"4.56\": false}}"));
1: 
1:         // double keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"doublemap\": {\"1.23\": true, \"4.56\": false}}");
1:         assertRows(execute("SELECT JSON k, doublemap FROM %s"), row("{\"k\": 0, \"doublemap\": {\"1.23\": true, \"4.56\": false}}"));
1: 
1:         // decimal keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"decimalmap\": {\"1.23\": true, \"4.56\": false}}");
1:         assertRows(execute("SELECT JSON k, decimalmap FROM %s"), row("{\"k\": 0, \"decimalmap\": {\"1.23\": true, \"4.56\": false}}"));
1: 
1:         // tuple<int, text> keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"tuplemap\": {\"[0, \\\"a\\\"]\": true, \"[1, \\\"b\\\"]\": false}}");
1:         assertRows(execute("SELECT JSON k, tuplemap FROM %s"), row("{\"k\": 0, \"tuplemap\": {\"[0, \\\"a\\\"]\": true, \"[1, \\\"b\\\"]\": false}}"));
1: 
1:         // UDT keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"udtmap\": {\"{\\\"a\\\": 0}\": true, \"{\\\"a\\\": 1}\": false}}");
1:         assertRows(execute("SELECT JSON k, udtmap FROM %s"), row("{\"k\": 0, \"udtmap\": {\"{\\\"a\\\": 0}\": true, \"{\\\"a\\\": 1}\": false}}"));
1: 
1:         // set<int> keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"setmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:         assertRows(execute("SELECT JSON k, setmap FROM %s"), row("{\"k\": 0, \"setmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1: 
1:         // list<int> keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"listmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:         assertRows(execute("SELECT JSON k, listmap FROM %s"), row("{\"k\": 0, \"listmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1: 
1:         // set<text> keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"textsetmap\": {\"[\\\"0\\\", \\\"1\\\"]\": true, \"[\\\"3\\\", \\\"4\\\"]\": false}}");
1:         assertRows(execute("SELECT JSON k, textsetmap FROM %s"), row("{\"k\": 0, \"textsetmap\": {\"[\\\"0\\\", \\\"1\\\"]\": true, \"[\\\"3\\\", \\\"4\\\"]\": false}}"));
1: 
1:         // map<set<text>, text> keys
1:         String innerKey1 = "[\"0\", \"1\"]";
0:         String fullKey1 = String.format("{\"%s\": \"%s\"}", new String(Json.JSON_STRING_ENCODER.quoteAsString(innerKey1)), "a");
0:         String stringKey1 = new String(Json.JSON_STRING_ENCODER.quoteAsString(fullKey1));
1:         String innerKey2 = "[\"3\", \"4\"]";
0:         String fullKey2 = String.format("{\"%s\": \"%s\"}", new String(Json.JSON_STRING_ENCODER.quoteAsString(innerKey2)), "b");
0:         String stringKey2 = new String(Json.JSON_STRING_ENCODER.quoteAsString(fullKey2));
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"nestedsetmap\": {\"" + stringKey1 + "\": true, \"" + stringKey2 + "\": false}}");
1:         assertRows(execute("SELECT JSON k, nestedsetmap FROM %s"), row("{\"k\": 0, \"nestedsetmap\": {\"" + stringKey1 + "\": true, \"" + stringKey2 + "\": false}}"));
1: 
1:         // set<int> keys in a frozen map
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"frozensetmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}");
1:         assertRows(execute("SELECT JSON k, frozensetmap FROM %s"), row("{\"k\": 0, \"frozensetmap\": {\"[0, 1, 2]\": true, \"[3, 4, 5]\": false}}"));
1:     }
1: 
1:     @Test
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.cassandra.cql3;
1: 
1: import org.apache.cassandra.serializers.SimpleDateSerializer;
1: import org.apache.cassandra.serializers.TimeSerializer;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.junit.Test;
1: 
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
1: import java.net.InetAddress;
1: import java.text.SimpleDateFormat;
0: import java.util.Date;
0: import java.util.UUID;
1: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class JsonTest extends CQLTester
1: {
1: 
1:     @Test
1:     public void testFromJsonFct() throws Throwable
1:     {
1:         String typeName = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "asciival ascii, " +
1:                 "bigintval bigint, " +
1:                 "blobval blob, " +
1:                 "booleanval boolean, " +
1:                 "dateval date, " +
1:                 "decimalval decimal, " +
1:                 "doubleval double, " +
1:                 "floatval float, " +
1:                 "inetval inet, " +
1:                 "intval int, " +
1:                 "textval text, " +
1:                 "timeval time, " +
1:                 "timestampval timestamp, " +
1:                 "timeuuidval timeuuid, " +
1:                 "uuidval uuid," +
1:                 "varcharval varchar, " +
1:                 "varintval varint, " +
1:                 "listval list<int>, " +
1:                 "frozenlistval frozen<list<int>>, " +
1:                 "setval set<uuid>, " +
1:                 "frozensetval frozen<set<uuid>>, " +
1:                 "mapval map<ascii, int>," +
1:                 "frozenmapval frozen<map<ascii, int>>," +
1:                 "tupleval frozen<tuple<int, ascii, uuid>>," +
0:                 "udtval frozen<" + typeName + ">)");
1: 
1: 
1:         // fromJson() can only be used when the receiver type is known
1:         assertInvalidMessage("fromJson() cannot be used in the selection clause", "SELECT fromJson(asciival) FROM %s", 0, 0);
1: 
0:         String func1 = createFunction(KEYSPACE, "int", "CREATE FUNCTION %s (a int) RETURNS text LANGUAGE java AS $$ return a.toString(); $$");
0:         createFunctionOverload(func1, "int", "CREATE FUNCTION %s (a text) RETURNS text LANGUAGE java AS $$ return new String(a); $$");
1: 
1:         assertInvalidMessage("Ambiguous call to function",
1:                 "INSERT INTO %s (k, textval) VALUES (?, " + func1 + "(fromJson(?)))", 0, "123");
1: 
1:         // fails JSON parsing
1:         assertInvalidMessage("Could not decode JSON string '\u038E\u0394\u03B4\u03E0'",
1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\u038E\u0394\u03B4\u03E0");
1: 
1:         // handle nulls
1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, null);
1: 
1:         // ================ ascii ================
1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"ascii text\"");
1:         assertRows(execute("SELECT k, asciival FROM %s WHERE k = ?", 0), row(0, "ascii text"));
1: 
1:         execute("INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"ascii \\\" text\"");
1:         assertRows(execute("SELECT k, asciival FROM %s WHERE k = ?", 0), row(0, "ascii \" text"));
1: 
1:         assertInvalidMessage("Invalid ASCII character in string literal",
1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "\"\\u1fff\\u2013\\u33B4\\u2014\"");
1: 
1:         assertInvalidMessage("Expected an ascii string, but got a Integer",
1:                 "INSERT INTO %s (k, asciival) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // test that we can use fromJson() in other valid places in queries
1:         assertRows(execute("SELECT asciival FROM %s WHERE k = fromJson(?)", "0"), row("ascii \" text"));
1:         execute("UPDATE %s SET asciival = fromJson(?) WHERE k = fromJson(?)", "\"ascii \\\" text\"", "0");
1:         execute("DELETE FROM %s WHERE k = fromJson(?)", "0");
1: 
1:         // ================ bigint ================
1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "123123123123");
1:         assertRows(execute("SELECT k, bigintval FROM %s WHERE k = ?", 0), row(0, 123123123123L));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "\"123123123123\"");
1:         assertRows(execute("SELECT k, bigintval FROM %s WHERE k = ?", 0), row(0, 123123123123L));
1: 
1:         // overflow (Long.MAX_VALUE + 1)
1:         assertInvalidMessage("Expected a bigint value, but got a",
1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "9223372036854775808");
1: 
1:         assertInvalidMessage("Expected a bigint value, but got a",
1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "123.456");
1: 
1:         assertInvalidMessage("Unable to make long from",
1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "\"abc\"");
1: 
1:         assertInvalidMessage("Expected a bigint value, but got a",
1:                 "INSERT INTO %s (k, bigintval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1: 
1:         // ================ blob ================
1:         execute("INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"0x00000001\"");
1:         assertRows(execute("SELECT k, blobval FROM %s WHERE k = ?", 0), row(0, ByteBufferUtil.bytes(1)));
1: 
1:         assertInvalidMessage("Value 'xyzz' is not a valid blob representation",
1:             "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("String representation of blob is missing 0x prefix: 123",
1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"123\"");
1: 
1:         assertInvalidMessage("Value '0x123' is not a valid blob representation",
1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "\"0x123\"");
1: 
1:         assertInvalidMessage("Value '123' is not a valid blob representation",
1:                 "INSERT INTO %s (k, blobval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // ================ boolean ================
1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "true");
1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, true));
1: 
1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "false");
1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, false));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "\"false\"");
1:         assertRows(execute("SELECT k, booleanval FROM %s WHERE k = ?", 0), row(0, false));
1: 
1:         assertInvalidMessage("Unable to make boolean from",
1:                 "INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "\"abc\"");
1: 
1:         assertInvalidMessage("Expected a boolean value, but got a Integer",
1:                 "INSERT INTO %s (k, booleanval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // ================ date ================
1:         execute("INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "\"1987-03-23\"");
1:         assertRows(execute("SELECT k, dateval FROM %s WHERE k = ?", 0), row(0, SimpleDateSerializer.dateStringToDays("1987-03-23")));
1: 
1:         assertInvalidMessage("Expected a string representation of a date",
1:                 "INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         assertInvalidMessage("Unable to coerce 'xyz' to a formatted date",
1:                 "INSERT INTO %s (k, dateval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1: 
1:         // ================ decimal ================
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123.123123")));
1: 
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "123123");
1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123")));
1: 
1:         // accept strings for numbers that cannot be represented as doubles
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"123123.123123\"");
1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("123123.123123")));
1: 
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"-1.23E-12\"");
1:         assertRows(execute("SELECT k, decimalval FROM %s WHERE k = ?", 0), row(0, new BigDecimal("-1.23E-12")));
1: 
1:         assertInvalidMessage("Value 'xyzz' is not a valid representation of a decimal value",
1:                 "INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Value 'true' is not a valid representation of a decimal value",
1:                 "INSERT INTO %s (k, decimalval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ double ================
1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.123123d));
1: 
1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "123123");
1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.0d));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "\"123123\"");
1:         assertRows(execute("SELECT k, doubleval FROM %s WHERE k = ?", 0), row(0, 123123.0d));
1: 
1:         assertInvalidMessage("Unable to make double from",
1:                 "INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected a double value, but got",
1:                 "INSERT INTO %s (k, doubleval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ float ================
1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "123123.123123");
1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.123123f));
1: 
1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "123123");
1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.0f));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "\"123123.0\"");
1:         assertRows(execute("SELECT k, floatval FROM %s WHERE k = ?", 0), row(0, 123123.0f));
1: 
1:         assertInvalidMessage("Unable to make float from",
1:                 "INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected a float value, but got a",
1:                 "INSERT INTO %s (k, floatval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ inet ================
1:         execute("INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"127.0.0.1\"");
1:         assertRows(execute("SELECT k, inetval FROM %s WHERE k = ?", 0), row(0, InetAddress.getByName("127.0.0.1")));
1: 
1:         execute("INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"::1\"");
1:         assertRows(execute("SELECT k, inetval FROM %s WHERE k = ?", 0), row(0, InetAddress.getByName("::1")));
1: 
1:         assertInvalidMessage("Unable to make inet address from 'xyzz'",
1:                 "INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected a string representation of an inet value, but got a Integer",
1:                 "INSERT INTO %s (k, inetval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // ================ int ================
1:         execute("INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "123123");
1:         assertRows(execute("SELECT k, intval FROM %s WHERE k = ?", 0), row(0, 123123));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "\"123123\"");
1:         assertRows(execute("SELECT k, intval FROM %s WHERE k = ?", 0), row(0, 123123));
1: 
1:         // int overflow (2 ^ 32, or Integer.MAX_INT + 1)
1:         assertInvalidMessage("Expected an int value, but got a",
1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "2147483648");
1: 
1:         assertInvalidMessage("Expected an int value, but got a",
1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "123.456");
1: 
1:         assertInvalidMessage("Unable to make int from",
1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected an int value, but got a",
1:                 "INSERT INTO %s (k, intval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ text (varchar) ================
1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"\"");
1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, ""));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"abcd\"");
1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "abcd"));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"some \\\" text\"");
1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "some \" text"));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "\"\\u2013\"");
1:         assertRows(execute("SELECT k, textval FROM %s WHERE k = ?", 0), row(0, "\u2013"));
1: 
1:         assertInvalidMessage("Expected a UTF-8 string, but got a Integer",
1:                 "INSERT INTO %s (k, textval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // ================ time ================
1:         execute("INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "\"07:35:07.000111222\"");
1:         assertRows(execute("SELECT k, timeval FROM %s WHERE k = ?", 0), row(0, TimeSerializer.timeStringToLong("07:35:07.000111222")));
1: 
1:         assertInvalidMessage("Expected a string representation of a time value",
1:                 "INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "123456");
1: 
1:         assertInvalidMessage("Unable to coerce 'xyz' to a formatted time",
1:                 "INSERT INTO %s (k, timeval) VALUES (?, fromJson(?))", 0, "\"xyz\"");
1: 
1:         // ================ timestamp ================
1:         execute("INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "123123123123");
1:         assertRows(execute("SELECT k, timestampval FROM %s WHERE k = ?", 0), row(0, new Date(123123123123L)));
1: 
1:         execute("INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "\"2014-01-01\"");
1:         assertRows(execute("SELECT k, timestampval FROM %s WHERE k = ?", 0), row(0, new SimpleDateFormat("y-M-d").parse("2014-01-01")));
1: 
1:         assertInvalidMessage("Expected a long or a datestring representation of a timestamp value, but got a Double",
1:                 "INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "123.456");
1: 
1:         assertInvalidMessage("Unable to coerce 'abcd' to a formatted date",
1:                 "INSERT INTO %s (k, timestampval) VALUES (?, fromJson(?))", 0, "\"abcd\"");
1: 
1:         // ================ timeuuid ================
1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\"");
1:         assertRows(execute("SELECT k, timeuuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1: 
1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"6BDDC89A-5644-11E4-97FC-56847AFE9799\"");
1:         assertRows(execute("SELECT k, timeuuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1: 
1:         assertInvalidMessage("TimeUUID supports only version 1 UUIDs",
1:                 "INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "\"00000000-0000-0000-0000-000000000000\"");
1: 
1:         assertInvalidMessage("Expected a string representation of a timeuuid, but got a Integer",
1:                 "INSERT INTO %s (k, timeuuidval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:          // ================ uuidval ================
1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\"");
1:         assertRows(execute("SELECT k, uuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1: 
1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"6BDDC89A-5644-11E4-97FC-56847AFE9799\"");
1:         assertRows(execute("SELECT k, uuidval FROM %s WHERE k = ?", 0), row(0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1: 
1:         assertInvalidMessage("Unable to make UUID from",
1:                 "INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "\"00000000-0000-0000-zzzz-000000000000\"");
1: 
1:         assertInvalidMessage("Expected a string representation of a uuid, but got a Integer",
1:                 "INSERT INTO %s (k, uuidval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         // ================ varint ================
1:         execute("INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "123123123123");
1:         assertRows(execute("SELECT k, varintval FROM %s WHERE k = ?", 0), row(0, new BigInteger("123123123123")));
1: 
1:         // accept strings for numbers that cannot be represented as longs
1:         execute("INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"1234567890123456789012345678901234567890\"");
1:         assertRows(execute("SELECT k, varintval FROM %s WHERE k = ?", 0), row(0, new BigInteger("1234567890123456789012345678901234567890")));
1: 
1:         assertInvalidMessage("Value '123123.123' is not a valid representation of a varint value",
1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "123123.123");
1: 
1:         assertInvalidMessage("Value 'xyzz' is not a valid representation of a varint value",
1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Value '' is not a valid representation of a varint value",
1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "\"\"");
1: 
1:         assertInvalidMessage("Value 'true' is not a valid representation of a varint value",
1:                 "INSERT INTO %s (k, varintval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ lists ================
1:         execute("INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[1, 2, 3]");
1:         assertRows(execute("SELECT k, listval FROM %s WHERE k = ?", 0), row(0, list(1, 2, 3)));
1: 
1:         execute("INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[]");
1:         assertRows(execute("SELECT k, listval FROM %s WHERE k = ?", 0), row(0, null));
1: 
1:         assertInvalidMessage("Expected a list, but got a Integer",
1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         assertInvalidMessage("Unable to make int from",
1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1: 
1:         assertInvalidMessage("Invalid null element in list",
1:                 "INSERT INTO %s (k, listval) VALUES (?, fromJson(?))", 0, "[null]");
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozenlistval) VALUES (?, fromJson(?))", 0, "[1, 2, 3]");
1:         assertRows(execute("SELECT k, frozenlistval FROM %s WHERE k = ?", 0), row(0, list(1, 2, 3)));
1: 
1:         // ================ sets ================
1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))",
1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0),
1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:         );
1: 
1:         // duplicates are okay, just like in CQL
1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))",
1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0),
1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:         );
1: 
1:         execute("INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[]");
1:         assertRows(execute("SELECT k, setval FROM %s WHERE k = ?", 0), row(0, null));
1: 
1:         assertInvalidMessage("Expected a list (representing a set), but got a Integer",
1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         assertInvalidMessage("Unable to make UUID from",
1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[\"abc\"]");
1: 
1:         assertInvalidMessage("Invalid null element in set",
1:                 "INSERT INTO %s (k, setval) VALUES (?, fromJson(?))", 0, "[null]");
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, fromJson(?))",
1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:         assertRows(execute("SELECT k, frozensetval FROM %s WHERE k = ?", 0),
1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:         );
1: 
1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, fromJson(?))",
1:                 0, "[\"6bddc89a-5644-11e4-97fc-56847afe9799\", \"6bddc89a-5644-11e4-97fc-56847afe9798\"]");
1:         assertRows(execute("SELECT k, frozensetval FROM %s WHERE k = ?", 0),
1:                 row(0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))))
1:         );
1: 
1:         // ================ maps ================
1:         execute("INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": 2}");
1:         assertRows(execute("SELECT k, mapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1: 
1:         execute("INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{}");
1:         assertRows(execute("SELECT k, mapval FROM %s WHERE k = ?", 0), row(0, null));
1: 
1:         assertInvalidMessage("Expected a map, but got a Integer",
1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "123");
1: 
1:         assertInvalidMessage("Invalid ASCII character in string literal",
1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"\\u1fff\\u2013\\u33B4\\u2014\": 1}");
1: 
1:         assertInvalidMessage("Invalid null value in map",
1:                 "INSERT INTO %s (k, mapval) VALUES (?, fromJson(?))", 0, "{\"a\": null}");
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": 2}");
1:         assertRows(execute("SELECT k, frozenmapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1: 
1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, fromJson(?))", 0, "{\"b\": 2, \"a\": 1}");
1:         assertRows(execute("SELECT k, frozenmapval FROM %s WHERE k = ?", 0), row(0, map("a", 1, "b", 2)));
1: 
1:         // ================ tuples ================
1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))", 0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:         assertRows(execute("SELECT k, tupleval FROM %s WHERE k = ?", 0),
1:             row(0, tuple(1, "foobar", UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")))
1:         );
1: 
1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))", 0, "[1, null, \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1:         assertRows(execute("SELECT k, tupleval FROM %s WHERE k = ?", 0),
1:                 row(0, tuple(1, null, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")))
1:         );
1: 
1:         assertInvalidMessage("Tuple contains extra items",
1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:                 0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\", 1, 2, 3]");
1: 
1:         assertInvalidMessage("Tuple is missing items",
1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:                 0, "[1, \"foobar\"]");
1: 
1:         assertInvalidMessage("Unable to make int from",
1:                 "INSERT INTO %s (k, tupleval) VALUES (?, fromJson(?))",
1:                 0, "[\"not an int\", \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]");
1: 
1:         // ================ UDTs ================
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"foo\", \"bar\"]}");
1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:         );
1: 
1:         // order of fields shouldn't matter
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"a\": 1, \"c\": [\"foo\", \"bar\"]}");
1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:         );
1: 
1:         // test nulls
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": null, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"foo\", \"bar\"]}");
1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:                 row(0, null, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("bar", "foo"))
1:         );
1: 
1:         // test missing fields
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\"}");
1:         assertRows(execute("SELECT k, udtval.a, udtval.b, udtval.c FROM %s WHERE k = ?", 0),
1:                 row(0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), null)
1:         );
1: 
1:         assertInvalidMessage("Unknown field", "INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"xxx\": 1}");
1:         assertInvalidMessage("Unable to make int from",
1:                 "INSERT INTO %s (k, udtval) VALUES (?, fromJson(?))", 0, "{\"a\": \"foobar\"}");
1:     }
1: 
1:     @Test
1:     public void testToJsonFct() throws Throwable
1:     {
1:         String typeName = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "asciival ascii, " +
1:                 "bigintval bigint, " +
1:                 "blobval blob, " +
1:                 "booleanval boolean, " +
1:                 "dateval date, " +
1:                 "decimalval decimal, " +
1:                 "doubleval double, " +
1:                 "floatval float, " +
1:                 "inetval inet, " +
1:                 "intval int, " +
1:                 "textval text, " +
1:                 "timeval time, " +
1:                 "timestampval timestamp, " +
1:                 "timeuuidval timeuuid, " +
1:                 "uuidval uuid," +
1:                 "varcharval varchar, " +
1:                 "varintval varint, " +
1:                 "listval list<int>, " +
1:                 "frozenlistval frozen<list<int>>, " +
1:                 "setval set<uuid>, " +
1:                 "frozensetval frozen<set<uuid>>, " +
1:                 "mapval map<ascii, int>, " +
1:                 "frozenmapval frozen<map<ascii, int>>, " +
1:                 "tupleval frozen<tuple<int, ascii, uuid>>," +
0:                 "udtval frozen<" + typeName + ">)");
1: 
1:         // toJson() can only be used in selections
1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:                 "INSERT INTO %s (k, asciival) VALUES (?, toJson(?))", 0, 0);
1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:                 "UPDATE %s SET asciival = toJson(?) WHERE k = ?", 0, 0);
1:         assertInvalidMessage("toJson() may only be used within the selection clause",
1:                 "DELETE FROM %s WHERE k = fromJson(toJson(?))", 0);
1: 
1:         // ================ ascii ================
1:         execute("INSERT INTO %s (k, asciival) VALUES (?, ?)", 0, "ascii text");
1:         assertRows(execute("SELECT k, toJson(asciival) FROM %s WHERE k = ?", 0), row(0, "\"ascii text\""));
1: 
1:         execute("INSERT INTO %s (k, asciival) VALUES (?, ?)", 0, "");
1:         assertRows(execute("SELECT k, toJson(asciival) FROM %s WHERE k = ?", 0), row(0, "\"\""));
1: 
1:         // ================ bigint ================
1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, 123123123123L);
1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "123123123123"));
1: 
1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, 0L);
1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1: 
1:         execute("INSERT INTO %s (k, bigintval) VALUES (?, ?)", 0, -123123123123L);
1:         assertRows(execute("SELECT k, toJson(bigintval) FROM %s WHERE k = ?", 0), row(0, "-123123123123"));
1: 
1:         // ================ blob ================
1:         execute("INSERT INTO %s (k, blobval) VALUES (?, ?)", 0, ByteBufferUtil.bytes(1));
1:         assertRows(execute("SELECT k, toJson(blobval) FROM %s WHERE k = ?", 0), row(0, "\"0x00000001\""));
1: 
1:         execute("INSERT INTO %s (k, blobval) VALUES (?, ?)", 0, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         assertRows(execute("SELECT k, toJson(blobval) FROM %s WHERE k = ?", 0), row(0, "\"0x\""));
1: 
1:         // ================ boolean ================
1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, ?)", 0, true);
1:         assertRows(execute("SELECT k, toJson(booleanval) FROM %s WHERE k = ?", 0), row(0, "true"));
1: 
1:         execute("INSERT INTO %s (k, booleanval) VALUES (?, ?)", 0, false);
1:         assertRows(execute("SELECT k, toJson(booleanval) FROM %s WHERE k = ?", 0), row(0, "false"));
1: 
1:         // ================ date ================
1:         execute("INSERT INTO %s (k, dateval) VALUES (?, ?)", 0, SimpleDateSerializer.dateStringToDays("1987-03-23"));
1:         assertRows(execute("SELECT k, toJson(dateval) FROM %s WHERE k = ?", 0), row(0, "\"1987-03-23\""));
1: 
1:         // ================ decimal ================
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, ?)", 0, new BigDecimal("123123.123123"));
1:         assertRows(execute("SELECT k, toJson(decimalval) FROM %s WHERE k = ?", 0), row(0, "123123.123123"));
1: 
1:         execute("INSERT INTO %s (k, decimalval) VALUES (?, ?)", 0, new BigDecimal("-1.23E-12"));
1:         assertRows(execute("SELECT k, toJson(decimalval) FROM %s WHERE k = ?", 0), row(0, "-1.23E-12"));
1: 
1:         // ================ double ================
1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, ?)", 0, 123123.123123d);
1:         assertRows(execute("SELECT k, toJson(doubleval) FROM %s WHERE k = ?", 0), row(0, "123123.123123"));
1: 
1:         execute("INSERT INTO %s (k, doubleval) VALUES (?, ?)", 0, 123123d);
1:         assertRows(execute("SELECT k, toJson(doubleval) FROM %s WHERE k = ?", 0), row(0, "123123.0"));
1: 
1:         // ================ float ================
1:         execute("INSERT INTO %s (k, floatval) VALUES (?, ?)", 0, 123.123f);
1:         assertRows(execute("SELECT k, toJson(floatval) FROM %s WHERE k = ?", 0), row(0, "123.123"));
1: 
1:         execute("INSERT INTO %s (k, floatval) VALUES (?, ?)", 0, 123123f);
1:         assertRows(execute("SELECT k, toJson(floatval) FROM %s WHERE k = ?", 0), row(0, "123123.0"));
1: 
1:         // ================ inet ================
1:         execute("INSERT INTO %s (k, inetval) VALUES (?, ?)", 0, InetAddress.getByName("127.0.0.1"));
1:         assertRows(execute("SELECT k, toJson(inetval) FROM %s WHERE k = ?", 0), row(0, "\"127.0.0.1\""));
1: 
1:         execute("INSERT INTO %s (k, inetval) VALUES (?, ?)", 0, InetAddress.getByName("::1"));
1:         assertRows(execute("SELECT k, toJson(inetval) FROM %s WHERE k = ?", 0), row(0, "\"0:0:0:0:0:0:0:1\""));
1: 
1:         // ================ int ================
1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, 123123);
1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "123123"));
1: 
1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, 0);
1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "0"));
1: 
1:         execute("INSERT INTO %s (k, intval) VALUES (?, ?)", 0, -123123);
1:         assertRows(execute("SELECT k, toJson(intval) FROM %s WHERE k = ?", 0), row(0, "-123123"));
1: 
1:         // ================ text (varchar) ================
1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "");
1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\""));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "abcd");
1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"abcd\""));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "\u8422");
1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\u8422\""));
1: 
1:         execute("INSERT INTO %s (k, textval) VALUES (?, ?)", 0, "\u0000");
1:         assertRows(execute("SELECT k, toJson(textval) FROM %s WHERE k = ?", 0), row(0, "\"\\u0000\""));
1: 
1:         // ================ timestamp ================
1:         execute("INSERT INTO %s (k, timeval) VALUES (?, ?)", 0, 123L);
1:         assertRows(execute("SELECT k, toJson(timeval) FROM %s WHERE k = ?", 0), row(0, "\"00:00:00.000000123\""));
1: 
1:         // ================ timestamp ================
0:         execute("INSERT INTO %s (k, timestampval) VALUES (?, ?)", 0, new SimpleDateFormat("y-M-d").parse("2014-01-01"));
0:         assertRows(execute("SELECT k, toJson(timestampval) FROM %s WHERE k = ?", 0), row(0, "\"2014-01-01 00:00:00.000\""));
1: 
1:         // ================ timeuuid ================
1:         execute("INSERT INTO %s (k, timeuuidval) VALUES (?, ?)", 0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:         assertRows(execute("SELECT k, toJson(timeuuidval) FROM %s WHERE k = ?", 0), row(0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\""));
1: 
1:          // ================ uuidval ================
1:         execute("INSERT INTO %s (k, uuidval) VALUES (?, ?)", 0, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:         assertRows(execute("SELECT k, toJson(uuidval) FROM %s WHERE k = ?", 0), row(0, "\"6bddc89a-5644-11e4-97fc-56847afe9799\""));
1: 
1:         // ================ varint ================
1:         execute("INSERT INTO %s (k, varintval) VALUES (?, ?)", 0, new BigInteger("123123123123123123123"));
1:         assertRows(execute("SELECT k, toJson(varintval) FROM %s WHERE k = ?", 0), row(0, "123123123123123123123"));
1: 
1:         // ================ lists ================
1:         execute("INSERT INTO %s (k, listval) VALUES (?, ?)", 0, list(1, 2, 3));
1:         assertRows(execute("SELECT k, toJson(listval) FROM %s WHERE k = ?", 0), row(0, "[1, 2, 3]"));
1: 
1:         execute("INSERT INTO %s (k, listval) VALUES (?, ?)", 0, list());
1:         assertRows(execute("SELECT k, toJson(listval) FROM %s WHERE k = ?", 0), row(0, "null"));
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozenlistval) VALUES (?, ?)", 0, list(1, 2, 3));
1:         assertRows(execute("SELECT k, toJson(frozenlistval) FROM %s WHERE k = ?", 0), row(0, "[1, 2, 3]"));
1: 
1:         // ================ sets ================
1:         execute("INSERT INTO %s (k, setval) VALUES (?, ?)",
1:                 0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))));
1:         assertRows(execute("SELECT k, toJson(setval) FROM %s WHERE k = ?", 0),
1:                 row(0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:         );
1: 
1:         execute("INSERT INTO %s (k, setval) VALUES (?, ?)", 0, set());
1:         assertRows(execute("SELECT k, toJson(setval) FROM %s WHERE k = ?", 0), row(0, "null"));
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozensetval) VALUES (?, ?)",
1:                 0, set(UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9798"), (UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"))));
1:         assertRows(execute("SELECT k, toJson(frozensetval) FROM %s WHERE k = ?", 0),
1:                 row(0, "[\"6bddc89a-5644-11e4-97fc-56847afe9798\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:         );
1: 
1:         // ================ maps ================
1:         execute("INSERT INTO %s (k, mapval) VALUES (?, ?)", 0, map("a", 1, "b", 2));
1:         assertRows(execute("SELECT k, toJson(mapval) FROM %s WHERE k = ?", 0), row(0, "{\"a\": 1, \"b\": 2}"));
1: 
1:         execute("INSERT INTO %s (k, mapval) VALUES (?, ?)", 0, map());
1:         assertRows(execute("SELECT k, toJson(mapval) FROM %s WHERE k = ?", 0), row(0, "null"));
1: 
1:         // frozen
1:         execute("INSERT INTO %s (k, frozenmapval) VALUES (?, ?)", 0, map("a", 1, "b", 2));
1:         assertRows(execute("SELECT k, toJson(frozenmapval) FROM %s WHERE k = ?", 0), row(0, "{\"a\": 1, \"b\": 2}"));
1: 
1:         // ================ tuples ================
1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, ?)", 0, tuple(1, "foobar", UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799")));
1:         assertRows(execute("SELECT k, toJson(tupleval) FROM %s WHERE k = ?", 0),
1:             row(0, "[1, \"foobar\", \"6bddc89a-5644-11e4-97fc-56847afe9799\"]")
1:         );
1: 
1:         execute("INSERT INTO %s (k, tupleval) VALUES (?, ?)", 0, tuple(1, "foobar", null));
1:         assertRows(execute("SELECT k, toJson(tupleval) FROM %s WHERE k = ?", 0),
1:                 row(0, "[1, \"foobar\", null]")
1:         );
1: 
1:         // ================ UDTs ================
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, {a: ?, b: ?, c: ?})", 0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"), set("foo", "bar"));
1:         assertRows(execute("SELECT k, toJson(udtval) FROM %s WHERE k = ?", 0),
1:                 row(0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": [\"bar\", \"foo\"]}")
1:         );
1: 
1:         execute("INSERT INTO %s (k, udtval) VALUES (?, {a: ?, b: ?})", 0, 1, UUID.fromString("6bddc89a-5644-11e4-97fc-56847afe9799"));
1:         assertRows(execute("SELECT k, toJson(udtval) FROM %s WHERE k = ?", 0),
1:                 row(0, "{\"a\": 1, \"b\": \"6bddc89a-5644-11e4-97fc-56847afe9799\", \"c\": null}")
1:         );
1:     }
1: 
1:     @Test
1:     public void testSelectJsonSyntax() throws Throwable
1:     {
1:         // tests SELECT JSON statements
1:         createTable("CREATE TABLE %s (k int primary key, v int)");
1:         execute("INSERT INTO %s (k, v) VALUES (0, 0)");
1:         execute("INSERT INTO %s (k, v) VALUES (1, 1)");
1: 
1:         assertRows(execute("SELECT JSON * FROM %s"),
1:                 row("{\"k\": 0, \"v\": 0}"),
1:                 row("{\"k\": 1, \"v\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON k, v FROM %s"),
1:                 row("{\"k\": 0, \"v\": 0}"),
1:                 row("{\"k\": 1, \"v\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON v, k FROM %s"),
1:                 row("{\"v\": 0, \"k\": 0}"),
1:                 row("{\"v\": 1, \"k\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON v as foo, k as bar FROM %s"),
1:                 row("{\"foo\": 0, \"bar\": 0}"),
1:                 row("{\"foo\": 1, \"bar\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON ttl(v), k FROM %s"),
1:                 row("{\"ttl(v)\": null, \"k\": 0}"),
1:                 row("{\"ttl(v)\": null, \"k\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON ttl(v) as foo, k FROM %s"),
1:                 row("{\"foo\": null, \"k\": 0}"),
1:                 row("{\"foo\": null, \"k\": 1}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON count(*) FROM %s"),
1:                 row("{\"count\": 2}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON count(*) as foo FROM %s"),
1:                 row("{\"foo\": 2}")
1:         );
1: 
1:         assertRows(execute("SELECT JSON toJson(blobAsInt(intAsBlob(v))) FROM %s LIMIT 1"),
1:                 row("{\"system.tojson(system.blobasint(system.intasblob(v)))\": \"0\"}")
1:         );
1:     }
1: 
1:     @Test
1:     public void testInsertJsonSyntax() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int primary key, v int)");
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": 0}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, 0)
1:         );
1: 
1:         // without specifying column names
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": 0}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, 0)
1:         );
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": null}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, null)
1:         );
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"v\": 1, \"k\": 0}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, 1)
1:         );
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, null)
1:         );
1: 
1:         if (USE_PREPARED_VALUES)
1:             assertInvalidMessage("Got null for INSERT JSON values", "INSERT INTO %s JSON ?", new Object[]{null});
1: 
1:         assertInvalidMessage("Got null for INSERT JSON values", "INSERT INTO %s JSON ?", "null");
1:         assertInvalidMessage("Could not decode JSON string as a map", "INSERT INTO %s JSON ?", "\"notamap\"");
1:         assertInvalidMessage("Could not decode JSON string as a map", "INSERT INTO %s JSON ?", "12.34");
1:         assertInvalidMessage("JSON values map contains unrecognized column",
1:                 "INSERT INTO %s JSON ?",
1:                 "{\"k\": 0, \"v\": 0, \"zzz\": 0}");
1: 
1:         assertInvalidMessage("Unable to make int from",
1:                 "INSERT INTO %s JSON ?",
1:                 "{\"k\": 0, \"v\": \"notanint\"}");
1:     }
1: 
1:     @Test
1:     public void testCaseSensitivity() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int primary key, \"Foo\" int)");
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"\\\"Foo\\\"\": 0}");
1:         execute("INSERT INTO %s JSON ?", "{\"K\": 0, \"\\\"Foo\\\"\": 0}");
1:         execute("INSERT INTO %s JSON ?", "{\"\\\"k\\\"\": 0, \"\\\"Foo\\\"\": 0}");
1: 
1:         // results should preserve and quote case-sensitive identifiers
1:         assertRows(execute("SELECT JSON * FROM %s"), row("{\"k\": 0, \"\\\"Foo\\\"\": 0}"));
1:         assertRows(execute("SELECT JSON k, \"Foo\" as foo FROM %s"), row("{\"k\": 0, \"foo\": 0}"));
1:         assertRows(execute("SELECT JSON k, \"Foo\" as \"Bar\" FROM %s"), row("{\"k\": 0, \"\\\"Bar\\\"\": 0}"));
1: 
1:         assertInvalid("INSERT INTO %s JSON ?", "{\"k\": 0, \"foo\": 0}");
1:         assertInvalid("INSERT INTO %s JSON ?", "{\"k\": 0, \"\\\"foo\\\"\": 0}");
1: 
1:         // user-defined types also need to handle case-sensitivity
1:         String typeName = createType("CREATE TYPE %s (a int, \"Foo\" int)");
1:         createTable("CREATE TABLE %s (k int primary key, v frozen<" + typeName + ">)");
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}");
1:         assertRows(execute("SELECT JSON k, v FROM %s"), row("{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}"));
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v\": {\"A\": 0, \"\\\"Foo\\\"\": 0}}");
1:         assertRows(execute("SELECT JSON k, v FROM %s"), row("{\"k\": 0, \"v\": {\"a\": 0, \"\\\"Foo\\\"\": 0}}"));
1:     }
1: 
1:     @Test
1:     public void testInsertJsonSyntaxWithCollections() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "m map<text, boolean>, " +
1:                 "mf frozen<map<text, boolean>>, " +
1:                 "s set<int>, " +
1:                 "sf frozen<set<int>>, " +
1:                 "l list<int>, " +
1:                 "lf frozen<list<int>>)");
1: 
1:         // map
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"m\": {\"a\": true, \"b\": false}}");
1:         assertRows(execute("SELECT k, m FROM %s"), row(0, map("a", true, "b", false)));
1: 
1:         // frozen map
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"mf\": {\"a\": true, \"b\": false}}");
1:         assertRows(execute("SELECT k, mf FROM %s"), row(0, map("a", true, "b", false)));
1: 
1:         // set
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"s\": [3, 1, 2]}");
1:         assertRows(execute("SELECT k, s FROM %s"), row(0, set(1, 2, 3)));
1: 
1:         // frozen set
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"sf\": [3, 1, 2]}");
1:         assertRows(execute("SELECT k, sf FROM %s"), row(0, set(1, 2, 3)));
1: 
1:         // list
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"l\": [1, 2, 3]}");
1:         assertRows(execute("SELECT k, l FROM %s"), row(0, list(1, 2, 3)));
1: 
1:         // frozen list
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"lf\": [1, 2, 3]}");
1:         assertRows(execute("SELECT k, lf FROM %s"), row(0, list(1, 2, 3)));
1:     }
1: 
1:     @Test
1:     public void testInsertJsonSyntaxWithTuplesAndUDTs() throws Throwable
1:     {
1:         String typeName = createType("CREATE TYPE %s (a int, b frozen<set<int>>, c tuple<int, int>)");
1:         createTable("CREATE TABLE %s (" +
1:                 "k int PRIMARY KEY, " +
1:                 "a frozen<" + typeName + ">, " +
1:                 "b tuple<int, boolean>)");
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": [1, 2, 3], \"c\": [0, 1]}, \"b\": [0, true]}");
1:         assertRows(execute("SELECT k, a.a, a.b, a.c, b FROM %s"), row(0, 0, set(1, 2, 3), tuple(0, 1), tuple(0, true)));
1: 
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"a\": {\"a\": 0, \"b\": [1, 2, 3], \"c\": null}, \"b\": null}");
1:         assertRows(execute("SELECT k, a.a, a.b, a.c, b FROM %s"), row(0, 0, set(1, 2, 3), null, null));
1:     }
1: }
author:Pawe? Rychlik
-------------------------------------------------------------------------------
commit:dc8a017
/////////////////////////////////////////////////////////////////////////
1:                 "smallintval smallint, " +
1:                 "tinyintval tinyint, " +
/////////////////////////////////////////////////////////////////////////
1:         // ================ smallint ================
1:         execute("INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "32767");
1:         assertRows(execute("SELECT k, smallintval FROM %s WHERE k = ?", 0), row(0, (short) 32767));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "\"32767\"");
1:         assertRows(execute("SELECT k, smallintval FROM %s WHERE k = ?", 0), row(0, (short) 32767));
1: 
1:         // smallint overflow (Short.MAX_VALUE + 1)
1:         assertInvalidMessage("Unable to make short from",
1:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "32768");
1: 
1:         assertInvalidMessage("Unable to make short from",
1:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "123.456");
1: 
1:         assertInvalidMessage("Unable to make short from",
1:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected a short value, but got a Boolean",
1:                 "INSERT INTO %s (k, smallintval) VALUES (?, fromJson(?))", 0, "true");
1: 
1:         // ================ tinyint ================
1:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "127");
1:         assertRows(execute("SELECT k, tinyintval FROM %s WHERE k = ?", 0), row(0, (byte) 127));
1: 
1:         // strings are also accepted
1:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "\"127\"");
1:         assertRows(execute("SELECT k, tinyintval FROM %s WHERE k = ?", 0), row(0, (byte) 127));
1: 
1:         // tinyint overflow (Byte.MAX_VALUE + 1)
1:         assertInvalidMessage("Unable to make byte from",
1:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "128");
1: 
1:         assertInvalidMessage("Unable to make byte from",
1:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "123.456");
1: 
1:         assertInvalidMessage("Unable to make byte from",
1:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "\"xyzz\"");
1: 
1:         assertInvalidMessage("Expected a byte value, but got a Boolean",
1:                 "INSERT INTO %s (k, tinyintval) VALUES (?, fromJson(?))", 0, "true");
1: 
/////////////////////////////////////////////////////////////////////////
1:                 "smallintval smallint, " +
1:                 "tinyintval tinyint, " +
/////////////////////////////////////////////////////////////////////////
1:         // ================ smallint ================
1:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) 32767);
1:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "32767"));
1: 
1:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) 0);
1:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1: 
1:         execute("INSERT INTO %s (k, smallintval) VALUES (?, ?)", 0, (short) -32768);
1:         assertRows(execute("SELECT k, toJson(smallintval) FROM %s WHERE k = ?", 0), row(0, "-32768"));
1: 
1:         // ================ tinyint ================
1:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) 127);
1:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "127"));
1: 
1:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) 0);
1:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "0"));
1: 
1:         execute("INSERT INTO %s (k, tinyintval) VALUES (?, ?)", 0, (byte) -128);
1:         assertRows(execute("SELECT k, toJson(tinyintval) FROM %s WHERE k = ?", 0), row(0, "-128"));
1: 
/////////////////////////////////////////////////////////////////////////
1:                 "smallintmap map<smallint, boolean>, " +
1:                 "tinyintmap map<tinyint, boolean>, " +
/////////////////////////////////////////////////////////////////////////
1:         // smallint keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"smallintmap\": {\"0\": true, \"1\": false}}");
1:         assertRows(execute("SELECT JSON k, smallintmap FROM %s"), row("{\"k\": 0, \"smallintmap\": {\"0\": true, \"1\": false}}"));
1: 
1:         // tinyint keys
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"tinyintmap\": {\"0\": true, \"1\": false}}");
1:         assertRows(execute("SELECT JSON k, tinyintmap FROM %s"), row("{\"k\": 0, \"tinyintmap\": {\"0\": true, \"1\": false}}"));
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:1291135
/////////////////////////////////////////////////////////////////////////
1:     public void testInsertJsonSyntaxDefaultUnset() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int primary key, v1 int, v2 int)");
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 0, \"v1\": 0, \"v2\": 0}");
1: 
1:         // leave v1 unset
1:         execute("INSERT INTO %s JSON ? DEFAULT UNSET", "{\"k\": 0, \"v2\": 2}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, 0, 2)
1:         );
1: 
1:         // explicit specification DEFAULT NULL
1:         execute("INSERT INTO %s JSON ? DEFAULT NULL", "{\"k\": 0, \"v2\": 2}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, null, 2)
1:         );
1: 
1:         // implicitly setting v2 to null
1:         execute("INSERT INTO %s JSON ? DEFAULT NULL", "{\"k\": 0}");
1:         assertRows(execute("SELECT * FROM %s"),
1:                 row(0, null, null)
1:         );
1: 
1:         // mix setting null explicitly with default unset:
1:         // set values for all fields
1:         execute("INSERT INTO %s JSON ?", "{\"k\": 1, \"v1\": 1, \"v2\": 1}");
1:         // explicitly set v1 to null while leaving v2 unset which retains its value
1:         execute("INSERT INTO %s JSON ? DEFAULT UNSET", "{\"k\": 1, \"v1\": null}");
1:         assertRows(execute("SELECT * FROM %s WHERE k=1"),
1:                 row(1, null, 1)
1:         );
1: 
1:         // test string literal instead of bind marker
1:         execute("INSERT INTO %s JSON '{\"k\": 2, \"v1\": 2, \"v2\": 2}'");
1:         // explicitly set v1 to null while leaving v2 unset which retains its value
1:         execute("INSERT INTO %s JSON '{\"k\": 2, \"v1\": null}' DEFAULT UNSET");
1:         assertRows(execute("SELECT * FROM %s WHERE k=2"),
1:                 row(2, null, 2)
1:         );
1:         execute("INSERT INTO %s JSON '{\"k\": 2}' DEFAULT NULL");
1:         assertRows(execute("SELECT * FROM %s WHERE k=2"),
1:                 row(2, null, null)
1:         );
1:     }
1: 
1:     @Test
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:b360653
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.cql3.validation.entities;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.cql3.Json;
1: import org.apache.cassandra.cql3.CQLTester;
1: import org.apache.cassandra.dht.ByteOrderedPartitioner;
0: 
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setUp()
1:     {
0:         DatabaseDescriptor.setPartitioner(ByteOrderedPartitioner.instance);
1:     }
author:Alex Petrov
-------------------------------------------------------------------------------
commit:88f22b9
/////////////////////////////////////////////////////////////////////////
1:         SimpleDateFormat sdf = new SimpleDateFormat("y-M-d");
1:         sdf.setTimeZone(TimeZone.getTimeZone("UDT"));
1:         execute("INSERT INTO %s (k, timestampval) VALUES (?, ?)", 0, sdf.parse("2014-01-01"));
1:         assertRows(execute("SELECT k, toJson(timestampval) FROM %s WHERE k = ?", 0), row(0, "\"2014-01-01 00:00:00.000Z\""));
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:1de5342
commit:fc972b9
/////////////////////////////////////////////////////////////////////////
1:     public void testJsonThreadSafety() throws Throwable
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitioner(ByteOrderedPartitioner.instance);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:1937bed
/////////////////////////////////////////////////////////////////////////
1:         String func1 = createFunction(KEYSPACE, "int", "CREATE FUNCTION %s (a int) CALLED ON NULL INPUT RETURNS text LANGUAGE java AS $$ return a.toString(); $$");
1:         createFunctionOverload(func1, "int", "CREATE FUNCTION %s (a text) CALLED ON NULL INPUT RETURNS text LANGUAGE java AS $$ return new String(a); $$");
============================================================================