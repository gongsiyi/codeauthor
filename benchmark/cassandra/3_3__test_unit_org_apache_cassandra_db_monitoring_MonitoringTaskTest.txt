1:557bbbc: /*
1:557bbbc:  * Licensed to the Apache Software Foundation (ASF) under one
1:557bbbc:  * or more contributor license agreements.  See the NOTICE file
1:557bbbc:  * distributed with this work for additional information
1:557bbbc:  * regarding copyright ownership.  The ASF licenses this file
1:557bbbc:  * to you under the Apache License, Version 2.0 (the
1:557bbbc:  * "License"); you may not use this file except in compliance
1:557bbbc:  * with the License.  You may obtain a copy of the License at
1:557bbbc:  *
1:557bbbc:  *     http://www.apache.org/licenses/LICENSE-2.0
1:557bbbc:  *
1:557bbbc:  * Unless required by applicable law or agreed to in writing, software
1:557bbbc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:557bbbc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:557bbbc:  * See the License for the specific language governing permissions and
1:557bbbc:  * limitations under the License.
1:557bbbc:  */
1:557bbbc: 
1:557bbbc: package org.apache.cassandra.db.monitoring;
1:557bbbc: 
1:557bbbc: import java.util.ArrayList;
1:557bbbc: import java.util.Arrays;
1:557bbbc: import java.util.Collections;
1:557bbbc: import java.util.List;
1:557bbbc: import java.util.UUID;
1:557bbbc: import java.util.concurrent.CountDownLatch;
1:557bbbc: import java.util.concurrent.ExecutorService;
1:557bbbc: import java.util.concurrent.Executors;
1:557bbbc: import java.util.concurrent.TimeUnit;
1:557bbbc: 
1:6966fcd: import org.junit.After;
1:557bbbc: import org.junit.BeforeClass;
1:557bbbc: import org.junit.Test;
1:557bbbc: 
1:557bbbc: import static org.junit.Assert.assertEquals;
1:557bbbc: import static org.junit.Assert.assertFalse;
1:557bbbc: import static org.junit.Assert.assertTrue;
1:557bbbc: import static org.junit.Assert.fail;
1:557bbbc: 
1:557bbbc: public class MonitoringTaskTest
1:557bbbc: {
1:557bbbc:     private static final long timeout = 100;
1:6966fcd:     private static final long slowTimeout = 10;
1:6966fcd: 
1:557bbbc:     private static final long MAX_SPIN_TIME_NANOS = TimeUnit.SECONDS.toNanos(5);
1:557bbbc: 
1:6966fcd:     private static final int REPORT_INTERVAL_MS = 600000; // long enough so that it won't check unless told to do so
1:6966fcd:     private static final int MAX_TIMEDOUT_OPERATIONS = -1; // unlimited
1:557bbbc: 
1:557bbbc:     @BeforeClass
1:557bbbc:     public static void setup()
1:557bbbc:     {
1:557bbbc:         MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:557bbbc:     }
1:557bbbc: 
1:6966fcd:     @After
1:6966fcd:     public void cleanUp()
1:6966fcd:     {
1:6966fcd:         // these clear the queues of the monitorint task
1:6966fcd:         MonitoringTask.instance.getSlowOperations();
1:6966fcd:         MonitoringTask.instance.getFailedOperations();
1:6966fcd:     }
1:6966fcd: 
1:557bbbc:     private static final class TestMonitor extends MonitorableImpl
1:557bbbc:     {
1:557bbbc:         private final String name;
1:557bbbc: 
1:9d9a1a1:         TestMonitor(String name, long timestamp, boolean isCrossNode, long timeout, long slow)
1:557bbbc:         {
1:557bbbc:             this.name = name;
1:9d9a1a1:             setMonitoringTime(timestamp, isCrossNode, timeout, slow);
1:557bbbc:         }
1:557bbbc: 
1:557bbbc:         public String name()
1:557bbbc:         {
1:557bbbc:             return name;
1:557bbbc:         }
1:557bbbc: 
1:557bbbc:         @Override
1:557bbbc:         public String toString()
1:557bbbc:         {
1:557bbbc:             return name();
1:557bbbc:         }
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     private static void waitForOperationsToComplete(Monitorable... operations) throws InterruptedException
1:557bbbc:     {
1:557bbbc:         waitForOperationsToComplete(Arrays.asList(operations));
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     private static void waitForOperationsToComplete(List<Monitorable> operations) throws InterruptedException
1:557bbbc:     {
1:557bbbc:         long timeout = operations.stream().map(Monitorable::timeout).reduce(0L, Long::max);
1:557bbbc:         Thread.sleep(timeout * 2 + ApproximateTime.precision());
1:557bbbc: 
1:557bbbc:         long start = System.nanoTime();
1:557bbbc:         while(System.nanoTime() - start <= MAX_SPIN_TIME_NANOS)
1:557bbbc:         {
1:557bbbc:             long numInProgress = operations.stream().filter(Monitorable::isInProgress).count();
1:557bbbc:             if (numInProgress == 0)
1:557bbbc:                 return;
1:6966fcd:         }
1:6966fcd:     }
1:557bbbc: 
1:6966fcd:     private static void waitForOperationsToBeReportedAsSlow(Monitorable... operations) throws InterruptedException
1:6966fcd:     {
1:6966fcd:         waitForOperationsToBeReportedAsSlow(Arrays.asList(operations));
1:6966fcd:     }
1:6966fcd: 
1:6966fcd:     private static void waitForOperationsToBeReportedAsSlow(List<Monitorable> operations) throws InterruptedException
1:6966fcd:     {
1:6966fcd:         long timeout = operations.stream().map(Monitorable::slowTimeout).reduce(0L, Long::max);
1:6966fcd:         Thread.sleep(timeout * 2 + ApproximateTime.precision());
1:6966fcd: 
1:6966fcd:         long start = System.nanoTime();
1:6966fcd:         while(System.nanoTime() - start <= MAX_SPIN_TIME_NANOS)
1:6966fcd:         {
1:6966fcd:             long numSlow = operations.stream().filter(Monitorable::isSlow).count();
1:6966fcd:             if (numSlow == operations.size())
1:6966fcd:                 return;
1:557bbbc:         }
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testAbort() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test abort", System.currentTimeMillis(), false, timeout, slowTimeout);
3:557bbbc:         waitForOperationsToComplete(operation);
1:557bbbc: 
2:557bbbc:         assertTrue(operation.isAborted());
2:557bbbc:         assertFalse(operation.isCompleted());
1:557bbbc:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testAbortIdemPotent() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test abort", System.currentTimeMillis(), false, timeout, slowTimeout);
1:557bbbc:         waitForOperationsToComplete(operation);
1:557bbbc: 
1:557bbbc:         assertTrue(operation.abort());
1:557bbbc: 
1:557bbbc:         assertTrue(operation.isAborted());
1:557bbbc:         assertFalse(operation.isCompleted());
1:557bbbc:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testAbortCrossNode() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test for cross node", System.currentTimeMillis(), true, timeout, slowTimeout);
1:557bbbc:         waitForOperationsToComplete(operation);
1:557bbbc: 
1:557bbbc:         assertTrue(operation.isAborted());
1:557bbbc:         assertFalse(operation.isCompleted());
1:557bbbc:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testComplete() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test complete", System.currentTimeMillis(), false, timeout, slowTimeout);
1:557bbbc:         operation.complete();
1:557bbbc:         waitForOperationsToComplete(operation);
1:557bbbc: 
1:557bbbc:         assertFalse(operation.isAborted());
1:557bbbc:         assertTrue(operation.isCompleted());
1:557bbbc:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testCompleteIdemPotent() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test complete", System.currentTimeMillis(), false, timeout, slowTimeout);
1:557bbbc:         operation.complete();
1:557bbbc:         waitForOperationsToComplete(operation);
1:557bbbc: 
1:557bbbc:         assertTrue(operation.complete());
1:557bbbc: 
1:557bbbc:         assertFalse(operation.isAborted());
1:557bbbc:         assertTrue(operation.isCompleted());
1:557bbbc:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:6966fcd:     public void testReportSlow() throws InterruptedException
1:6966fcd:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test report slow", System.currentTimeMillis(), false, timeout, slowTimeout);
1:6966fcd:         waitForOperationsToBeReportedAsSlow(operation);
1:6966fcd: 
1:6966fcd:         assertTrue(operation.isSlow());
1:6966fcd:         operation.complete();
1:6966fcd:         assertFalse(operation.isAborted());
1:6966fcd:         assertTrue(operation.isCompleted());
1:6966fcd:         assertEquals(1, MonitoringTask.instance.getSlowOperations().size());
1:6966fcd:     }
1:6966fcd: 
1:6966fcd:     @Test
1:6966fcd:     public void testNoReportSlowIfZeroSlowTimeout() throws InterruptedException
1:6966fcd:     {
1:6966fcd:         // when the slow timeout is set to zero then operation won't be reported as slow
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test report slow disabled", System.currentTimeMillis(), false, timeout, 0);
1:6966fcd:         waitForOperationsToBeReportedAsSlow(operation);
1:6966fcd: 
1:6966fcd:         assertTrue(operation.isSlow());
1:6966fcd:         operation.complete();
1:6966fcd:         assertFalse(operation.isAborted());
1:6966fcd:         assertTrue(operation.isCompleted());
1:6966fcd:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1:6966fcd:     }
1:6966fcd: 
1:6966fcd:     @Test
1:557bbbc:     public void testReport() throws InterruptedException
1:557bbbc:     {
1:9d9a1a1:         Monitorable operation = new TestMonitor("Test report", System.currentTimeMillis(), false, timeout, slowTimeout);
1:557bbbc:         waitForOperationsToComplete(operation);
1:6966fcd: 
1:6966fcd:         assertTrue(operation.isSlow());
1:557bbbc:         assertTrue(operation.isAborted());
1:557bbbc:         assertFalse(operation.isCompleted());
1:557bbbc: 
1:6966fcd:         // aborted operations are not logged as slow
1:6966fcd:         assertFalse(MonitoringTask.instance.logSlowOperations(ApproximateTime.currentTimeMillis()));
1:6966fcd:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1:6966fcd: 
1:6966fcd:         assertTrue(MonitoringTask.instance.logFailedOperations(ApproximateTime.currentTimeMillis()));
1:557bbbc:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testRealScheduling() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         MonitoringTask.instance = MonitoringTask.make(10, -1);
1:557bbbc:         try
1:557bbbc:         {
1:9d9a1a1:             Monitorable operation1 = new TestMonitor("Test report 1", System.currentTimeMillis(), false, timeout, slowTimeout);
1:6966fcd:             waitForOperationsToComplete(operation1);
1:557bbbc: 
1:6966fcd:             assertTrue(operation1.isAborted());
1:6966fcd:             assertFalse(operation1.isCompleted());
1:6966fcd: 
1:9d9a1a1:             Monitorable operation2 = new TestMonitor("Test report 2", System.currentTimeMillis(), false, timeout, slowTimeout);
1:6966fcd:             waitForOperationsToBeReportedAsSlow(operation2);
1:6966fcd: 
1:6966fcd:             operation2.complete();
1:6966fcd:             assertFalse(operation2.isAborted());
1:6966fcd:             assertTrue(operation2.isCompleted());
1:557bbbc: 
1:557bbbc:             Thread.sleep(ApproximateTime.precision() + 500);
1:557bbbc:             assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:6966fcd:             assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1:557bbbc:         }
1:557bbbc:         finally
1:557bbbc:         {
1:557bbbc:             MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:557bbbc:         }
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testMultipleThreads() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         final int opCount = 50;
1:557bbbc:         final ExecutorService executorService = Executors.newFixedThreadPool(20);
1:557bbbc:         final List<Monitorable> operations = Collections.synchronizedList(new ArrayList<>(opCount));
1:557bbbc: 
1:557bbbc:         for (int i = 0; i < opCount; i++)
1:557bbbc:         {
1:557bbbc:             executorService.submit(() ->
1:9d9a1a1:                 operations.add(new TestMonitor(UUID.randomUUID().toString(), System.currentTimeMillis(), false, timeout, slowTimeout))
1:557bbbc:             );
1:557bbbc:         }
1:557bbbc: 
1:557bbbc:         executorService.shutdown();
1:557bbbc:         assertTrue(executorService.awaitTermination(30, TimeUnit.SECONDS));
1:557bbbc:         assertEquals(opCount, operations.size());
1:557bbbc: 
1:557bbbc:         waitForOperationsToComplete(operations);
1:557bbbc:         assertEquals(opCount, MonitoringTask.instance.getFailedOperations().size());
1:6966fcd:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testZeroMaxTimedoutOperations() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         doTestMaxTimedoutOperations(0, 1, 0);
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:557bbbc:     public void testMaxTimedoutOperationsExceeded() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         doTestMaxTimedoutOperations(5, 10, 6);
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     private static void doTestMaxTimedoutOperations(int maxTimedoutOperations,
1:557bbbc:                                                     int numThreads,
1:557bbbc:                                                     int numExpectedOperations) throws InterruptedException
1:557bbbc:     {
1:557bbbc:         MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, maxTimedoutOperations);
1:557bbbc:         try
1:557bbbc:         {
1:6966fcd:             ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
1:6966fcd:             final CountDownLatch finished = new CountDownLatch(numThreads);
1:557bbbc: 
1:6966fcd:             for (int i = 0; i < numThreads; i++)
1:557bbbc:             {
1:557bbbc:                 final String operationName = "Operation " + Integer.toString(i+1);
1:557bbbc:                 final int numTimes = i + 1;
1:557bbbc:                 executorService.submit(() -> {
1:557bbbc:                     try
1:557bbbc:                     {
1:557bbbc:                         for (int j = 0; j < numTimes; j++)
1:557bbbc:                         {
1:6966fcd:                             Monitorable operation1 = new TestMonitor(operationName,
1:9d9a1a1:                                                                      System.currentTimeMillis(),
1:9d9a1a1:                                                                      false,
1:9d9a1a1:                                                                      timeout,
1:9d9a1a1:                                                                      slowTimeout);
1:6966fcd:                             waitForOperationsToComplete(operation1);
1:6966fcd: 
1:6966fcd:                             Monitorable operation2 = new TestMonitor(operationName,
1:9d9a1a1:                                                                      System.currentTimeMillis(),
1:9d9a1a1:                                                                      false,
1:9d9a1a1:                                                                      timeout,
1:9d9a1a1:                                                                      slowTimeout);
1:6966fcd:                             waitForOperationsToBeReportedAsSlow(operation2);
1:6966fcd:                             operation2.complete();
1:557bbbc:                         }
1:557bbbc:                     }
1:557bbbc:                     catch (InterruptedException e)
1:557bbbc:                     {
1:557bbbc:                         e.printStackTrace();
1:557bbbc:                         fail("Unexpected exception");
1:557bbbc:                     }
1:557bbbc:                     finally
1:557bbbc:                     {
1:557bbbc:                         finished.countDown();
1:557bbbc:                     }
1:557bbbc:                 });
1:557bbbc:             }
1:557bbbc: 
1:557bbbc:             finished.await();
1:557bbbc:             assertEquals(0, executorService.shutdownNow().size());
1:557bbbc: 
1:557bbbc:             List<String> failedOperations = MonitoringTask.instance.getFailedOperations();
1:557bbbc:             assertEquals(numExpectedOperations, failedOperations.size());
1:557bbbc:             if (numExpectedOperations > 0)
1:557bbbc:                 assertTrue(failedOperations.get(numExpectedOperations - 1).startsWith("..."));
1:557bbbc:         }
1:557bbbc:         finally
1:557bbbc:         {
1:557bbbc:             MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:557bbbc:         }
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:6966fcd:     public void testMultipleThreadsSameNameFailed() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         final int threadCount = 50;
1:557bbbc:         final List<Monitorable> operations = new ArrayList<>(threadCount);
2:557bbbc:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
2:557bbbc:         final CountDownLatch finished = new CountDownLatch(threadCount);
1:557bbbc: 
2:557bbbc:         for (int i = 0; i < threadCount; i++)
1:557bbbc:         {
1:557bbbc:             executorService.submit(() -> {
1:557bbbc:                 try
1:557bbbc:                 {
1:6966fcd:                     Monitorable operation = new TestMonitor("Test testMultipleThreadsSameName failed",
1:9d9a1a1:                                                             System.currentTimeMillis(),
1:9d9a1a1:                                                             false,
1:9d9a1a1:                                                             timeout,
1:9d9a1a1:                                                             slowTimeout);
1:557bbbc:                     operations.add(operation);
1:557bbbc:                 }
1:557bbbc:                 finally
1:557bbbc:                 {
1:557bbbc:                     finished.countDown();
1:557bbbc:                 }
1:557bbbc:             });
1:557bbbc:         }
1:557bbbc: 
1:557bbbc:         finished.await();
1:557bbbc:         assertEquals(0, executorService.shutdownNow().size());
1:557bbbc: 
1:557bbbc:         waitForOperationsToComplete(operations);
1:557bbbc:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: 
1:557bbbc:     @Test
1:6966fcd:     public void testMultipleThreadsSameNameSlow() throws InterruptedException
1:6966fcd:     {
1:6966fcd:         final int threadCount = 50;
1:6966fcd:         final List<Monitorable> operations = new ArrayList<>(threadCount);
1:6966fcd:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:6966fcd:         final CountDownLatch finished = new CountDownLatch(threadCount);
1:6966fcd: 
1:6966fcd:         for (int i = 0; i < threadCount; i++)
1:6966fcd:         {
1:6966fcd:             executorService.submit(() -> {
1:6966fcd:                 try
1:6966fcd:                 {
1:6966fcd:                     Monitorable operation = new TestMonitor("Test testMultipleThreadsSameName slow",
1:9d9a1a1:                                                             System.currentTimeMillis(),
1:9d9a1a1:                                                             false,
1:9d9a1a1:                                                             timeout,
1:9d9a1a1:                                                             slowTimeout);
1:6966fcd:                     operations.add(operation);
1:6966fcd:                 }
1:6966fcd:                 finally
1:6966fcd:                 {
1:6966fcd:                     finished.countDown();
1:6966fcd:                 }
1:6966fcd:             });
1:6966fcd:         }
1:6966fcd: 
1:6966fcd:         finished.await();
1:6966fcd:         assertEquals(0, executorService.shutdownNow().size());
1:6966fcd: 
1:6966fcd:         waitForOperationsToBeReportedAsSlow(operations);
1:6966fcd:         operations.forEach(o -> o.complete());
1:6966fcd: 
1:6966fcd:         assertEquals(1, MonitoringTask.instance.getSlowOperations().size());
1:6966fcd:     }
1:6966fcd: 
1:6966fcd:     @Test
1:557bbbc:     public void testMultipleThreadsNoFailedOps() throws InterruptedException
1:557bbbc:     {
1:557bbbc:         final int threadCount = 50;
1:557bbbc:         final List<Monitorable> operations = new ArrayList<>(threadCount);
1:557bbbc:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:557bbbc:         final CountDownLatch finished = new CountDownLatch(threadCount);
1:557bbbc: 
1:557bbbc:         for (int i = 0; i < threadCount; i++)
1:557bbbc:         {
1:557bbbc:             executorService.submit(() -> {
1:557bbbc:                 try
1:557bbbc:                 {
1:557bbbc:                     Monitorable operation = new TestMonitor("Test thread " + Thread.currentThread().getName(),
1:9d9a1a1:                                                             System.currentTimeMillis(),
1:9d9a1a1:                                                             false,
1:9d9a1a1:                                                             timeout,
1:9d9a1a1:                                                             slowTimeout);
1:557bbbc:                     operations.add(operation);
1:557bbbc:                     operation.complete();
1:557bbbc:                 }
1:557bbbc:                 finally
1:557bbbc:                 {
1:557bbbc:                     finished.countDown();
1:557bbbc:                 }
1:557bbbc:             });
1:557bbbc:         }
1:557bbbc: 
1:557bbbc:         finished.await();
1:557bbbc:         assertEquals(0, executorService.shutdownNow().size());
1:557bbbc: 
1:557bbbc:         waitForOperationsToComplete(operations);
1:557bbbc:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:557bbbc:     }
1:557bbbc: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9d9a1a1
/////////////////////////////////////////////////////////////////////////
1:         TestMonitor(String name, long timestamp, boolean isCrossNode, long timeout, long slow)
1:             setMonitoringTime(timestamp, isCrossNode, timeout, slow);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test abort", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test abort", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test for cross node", System.currentTimeMillis(), true, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test complete", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test complete", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test report slow", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test report slow disabled", System.currentTimeMillis(), false, timeout, 0);
/////////////////////////////////////////////////////////////////////////
1:         Monitorable operation = new TestMonitor("Test report", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:             Monitorable operation1 = new TestMonitor("Test report 1", System.currentTimeMillis(), false, timeout, slowTimeout);
1:             Monitorable operation2 = new TestMonitor("Test report 2", System.currentTimeMillis(), false, timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:                 operations.add(new TestMonitor(UUID.randomUUID().toString(), System.currentTimeMillis(), false, timeout, slowTimeout))
/////////////////////////////////////////////////////////////////////////
1:                                                                      System.currentTimeMillis(),
1:                                                                      false,
1:                                                                      timeout,
1:                                                                      slowTimeout);
1:                                                                      System.currentTimeMillis(),
1:                                                                      false,
1:                                                                      timeout,
1:                                                                      slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:                                                             System.currentTimeMillis(),
1:                                                             false,
1:                                                             timeout,
1:                                                             slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:                                                             System.currentTimeMillis(),
1:                                                             false,
1:                                                             timeout,
1:                                                             slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:                                                             System.currentTimeMillis(),
1:                                                             false,
1:                                                             timeout,
1:                                                             slowTimeout);
author:Shogo Hoshii
-------------------------------------------------------------------------------
commit:6966fcd
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
/////////////////////////////////////////////////////////////////////////
1:     private static final long slowTimeout = 10;
1: 
1:     private static final int REPORT_INTERVAL_MS = 600000; // long enough so that it won't check unless told to do so
1:     private static final int MAX_TIMEDOUT_OPERATIONS = -1; // unlimited
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void cleanUp()
1:     {
1:         // these clear the queues of the monitorint task
1:         MonitoringTask.instance.getSlowOperations();
1:         MonitoringTask.instance.getFailedOperations();
1:     }
1: 
0:         TestMonitor(String name, ConstructionTime constructionTime, long timeout, long slow)
0:             setMonitoringTime(constructionTime, timeout, slow);
/////////////////////////////////////////////////////////////////////////
1:         }
1:     }
1:     private static void waitForOperationsToBeReportedAsSlow(Monitorable... operations) throws InterruptedException
1:     {
1:         waitForOperationsToBeReportedAsSlow(Arrays.asList(operations));
1:     }
1: 
1:     private static void waitForOperationsToBeReportedAsSlow(List<Monitorable> operations) throws InterruptedException
1:     {
1:         long timeout = operations.stream().map(Monitorable::slowTimeout).reduce(0L, Long::max);
1:         Thread.sleep(timeout * 2 + ApproximateTime.precision());
1: 
1:         long start = System.nanoTime();
1:         while(System.nanoTime() - start <= MAX_SPIN_TIME_NANOS)
1:         {
1:             long numSlow = operations.stream().filter(Monitorable::isSlow).count();
1:             if (numSlow == operations.size())
1:                 return;
0:         Monitorable operation = new TestMonitor("Test abort", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
0:         Monitorable operation = new TestMonitor("Test abort", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
0:         Monitorable operation = new TestMonitor("Test for cross node", new ConstructionTime(System.currentTimeMillis(), true), timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
0:         Monitorable operation = new TestMonitor("Test complete", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
0:         Monitorable operation = new TestMonitor("Test complete", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:     public void testReportSlow() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test report slow", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
1:         waitForOperationsToBeReportedAsSlow(operation);
1: 
1:         assertTrue(operation.isSlow());
1:         operation.complete();
1:         assertFalse(operation.isAborted());
1:         assertTrue(operation.isCompleted());
1:         assertEquals(1, MonitoringTask.instance.getSlowOperations().size());
1:     }
1: 
1:     @Test
1:     public void testNoReportSlowIfZeroSlowTimeout() throws InterruptedException
1:     {
1:         // when the slow timeout is set to zero then operation won't be reported as slow
0:         Monitorable operation = new TestMonitor("Test report slow disabled", new ConstructionTime(System.currentTimeMillis()), timeout, 0);
1:         waitForOperationsToBeReportedAsSlow(operation);
1: 
1:         assertTrue(operation.isSlow());
1:         operation.complete();
1:         assertFalse(operation.isAborted());
1:         assertTrue(operation.isCompleted());
1:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1:     }
1: 
1:     @Test
0:         Monitorable operation = new TestMonitor("Test report", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
1:         assertTrue(operation.isSlow());
1: 
1:         // aborted operations are not logged as slow
1:         assertFalse(MonitoringTask.instance.logSlowOperations(ApproximateTime.currentTimeMillis()));
1:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
1: 
1:         assertTrue(MonitoringTask.instance.logFailedOperations(ApproximateTime.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:             Monitorable operation1 = new TestMonitor("Test report 1", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
1:             waitForOperationsToComplete(operation1);
1:             assertTrue(operation1.isAborted());
1:             assertFalse(operation1.isCompleted());
1: 
0:             Monitorable operation2 = new TestMonitor("Test report 2", new ConstructionTime(System.currentTimeMillis()), timeout, slowTimeout);
1:             waitForOperationsToBeReportedAsSlow(operation2);
1: 
1:             operation2.complete();
1:             assertFalse(operation2.isAborted());
1:             assertTrue(operation2.isCompleted());
1:             assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
/////////////////////////////////////////////////////////////////////////
0:                 operations.add(new TestMonitor(UUID.randomUUID().toString(), new ConstructionTime(), timeout, slowTimeout))
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, MonitoringTask.instance.getSlowOperations().size());
/////////////////////////////////////////////////////////////////////////
1:             ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
1:             final CountDownLatch finished = new CountDownLatch(numThreads);
1:             for (int i = 0; i < numThreads; i++)
/////////////////////////////////////////////////////////////////////////
1:                             Monitorable operation1 = new TestMonitor(operationName,
0:                                                                     timeout, slowTimeout);
1:                             waitForOperationsToComplete(operation1);
1: 
1:                             Monitorable operation2 = new TestMonitor(operationName,
0:                                                                      new ConstructionTime(System.currentTimeMillis()),
0:                                                                      timeout, slowTimeout);
1:                             waitForOperationsToBeReportedAsSlow(operation2);
1:                             operation2.complete();
/////////////////////////////////////////////////////////////////////////
1:     public void testMultipleThreadsSameNameFailed() throws InterruptedException
/////////////////////////////////////////////////////////////////////////
1:                     Monitorable operation = new TestMonitor("Test testMultipleThreadsSameName failed",
0:                                                             timeout, slowTimeout);
/////////////////////////////////////////////////////////////////////////
1:     public void testMultipleThreadsSameNameSlow() throws InterruptedException
1:     {
1:         final int threadCount = 50;
1:         final List<Monitorable> operations = new ArrayList<>(threadCount);
1:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:         final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:         for (int i = 0; i < threadCount; i++)
1:         {
1:             executorService.submit(() -> {
1:                 try
1:                 {
1:                     Monitorable operation = new TestMonitor("Test testMultipleThreadsSameName slow",
0:                                                             new ConstructionTime(System.currentTimeMillis()),
0:                                                             timeout, slowTimeout);
1:                     operations.add(operation);
1:                 }
1:                 finally
1:                 {
1:                     finished.countDown();
1:                 }
1:             });
1:         }
1: 
1:         finished.await();
1:         assertEquals(0, executorService.shutdownNow().size());
1: 
1:         waitForOperationsToBeReportedAsSlow(operations);
1:         operations.forEach(o -> o.complete());
1: 
1:         assertEquals(1, MonitoringTask.instance.getSlowOperations().size());
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
0:                                                             timeout, slowTimeout);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.db.monitoring;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.List;
1: import java.util.UUID;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class MonitoringTaskTest
1: {
1:     private static final long timeout = 100;
1:     private static final long MAX_SPIN_TIME_NANOS = TimeUnit.SECONDS.toNanos(5);
1: 
0:     public static final int REPORT_INTERVAL_MS = 600000; // long enough so that it won't check unless told to do so
0:     public static final int MAX_TIMEDOUT_OPERATIONS = -1; // unlimited
1: 
1:     @BeforeClass
1:     public static void setup()
1:     {
1:         MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:     }
1: 
1:     private static final class TestMonitor extends MonitorableImpl
1:     {
1:         private final String name;
1: 
0:         TestMonitor(String name, ConstructionTime constructionTime, long timeout)
1:         {
1:             this.name = name;
0:             setMonitoringTime(constructionTime, timeout);
1:         }
1: 
1:         public String name()
1:         {
1:             return name;
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return name();
1:         }
1:     }
1: 
1:     private static void waitForOperationsToComplete(Monitorable... operations) throws InterruptedException
1:     {
1:         waitForOperationsToComplete(Arrays.asList(operations));
1:     }
1: 
1:     private static void waitForOperationsToComplete(List<Monitorable> operations) throws InterruptedException
1:     {
1:         long timeout = operations.stream().map(Monitorable::timeout).reduce(0L, Long::max);
1:         Thread.sleep(timeout * 2 + ApproximateTime.precision());
1: 
1:         long start = System.nanoTime();
1:         while(System.nanoTime() - start <= MAX_SPIN_TIME_NANOS)
1:         {
1:             long numInProgress = operations.stream().filter(Monitorable::isInProgress).count();
1:             if (numInProgress == 0)
1:                 return;
1: 
0:             Thread.yield();
1:         }
1:     }
1: 
1:     @Test
1:     public void testAbort() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test abort", new ConstructionTime(System.currentTimeMillis()), timeout);
1:         waitForOperationsToComplete(operation);
1: 
1:         assertTrue(operation.isAborted());
1:         assertFalse(operation.isCompleted());
1:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testAbortIdemPotent() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test abort", new ConstructionTime(System.currentTimeMillis()), timeout);
1:         waitForOperationsToComplete(operation);
1: 
1:         assertTrue(operation.abort());
1: 
1:         assertTrue(operation.isAborted());
1:         assertFalse(operation.isCompleted());
1:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testAbortCrossNode() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test for cross node", new ConstructionTime(System.currentTimeMillis(), true), timeout);
1:         waitForOperationsToComplete(operation);
1: 
1:         assertTrue(operation.isAborted());
1:         assertFalse(operation.isCompleted());
1:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testComplete() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test complete", new ConstructionTime(System.currentTimeMillis()), timeout);
1:         operation.complete();
1:         waitForOperationsToComplete(operation);
1: 
1:         assertFalse(operation.isAborted());
1:         assertTrue(operation.isCompleted());
1:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testCompleteIdemPotent() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test complete", new ConstructionTime(System.currentTimeMillis()), timeout);
1:         operation.complete();
1:         waitForOperationsToComplete(operation);
1: 
1:         assertTrue(operation.complete());
1: 
1:         assertFalse(operation.isAborted());
1:         assertTrue(operation.isCompleted());
1:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testReport() throws InterruptedException
1:     {
0:         Monitorable operation = new TestMonitor("Test report", new ConstructionTime(System.currentTimeMillis()), timeout);
1:         waitForOperationsToComplete(operation);
1: 
1:         assertTrue(operation.isAborted());
1:         assertFalse(operation.isCompleted());
0:         MonitoringTask.instance.logFailedOperations(ApproximateTime.currentTimeMillis());
1:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testRealScheduling() throws InterruptedException
1:     {
1:         MonitoringTask.instance = MonitoringTask.make(10, -1);
1:         try
1:         {
0:             Monitorable operation = new TestMonitor("Test report", new ConstructionTime(System.currentTimeMillis()), timeout);
1:             waitForOperationsToComplete(operation);
1: 
1:             assertTrue(operation.isAborted());
1:             assertFalse(operation.isCompleted());
1: 
1:             Thread.sleep(ApproximateTime.precision() + 500);
1:             assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:         }
1:         finally
1:         {
1:             MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:         }
1:     }
1: 
1:     @Test
1:     public void testMultipleThreads() throws InterruptedException
1:     {
1:         final int opCount = 50;
1:         final ExecutorService executorService = Executors.newFixedThreadPool(20);
1:         final List<Monitorable> operations = Collections.synchronizedList(new ArrayList<>(opCount));
1: 
1:         for (int i = 0; i < opCount; i++)
1:         {
1:             executorService.submit(() ->
0:                 operations.add(new TestMonitor(UUID.randomUUID().toString(), new ConstructionTime(), timeout))
1:             );
1:         }
1: 
1:         executorService.shutdown();
1:         assertTrue(executorService.awaitTermination(30, TimeUnit.SECONDS));
1:         assertEquals(opCount, operations.size());
1: 
1:         waitForOperationsToComplete(operations);
1:         assertEquals(opCount, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testZeroMaxTimedoutOperations() throws InterruptedException
1:     {
1:         doTestMaxTimedoutOperations(0, 1, 0);
1:     }
1: 
1:     @Test
1:     public void testMaxTimedoutOperationsExceeded() throws InterruptedException
1:     {
1:         doTestMaxTimedoutOperations(5, 10, 6);
1:     }
1: 
1:     private static void doTestMaxTimedoutOperations(int maxTimedoutOperations,
1:                                                     int numThreads,
1:                                                     int numExpectedOperations) throws InterruptedException
1:     {
1:         MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, maxTimedoutOperations);
1:         try
1:         {
0:             final int threadCount = numThreads;
1:             ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:             final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:             for (int i = 0; i < threadCount; i++)
1:             {
1:                 final String operationName = "Operation " + Integer.toString(i+1);
1:                 final int numTimes = i + 1;
1:                 executorService.submit(() -> {
1:                     try
1:                     {
1:                         for (int j = 0; j < numTimes; j++)
1:                         {
0:                             Monitorable operation = new TestMonitor(operationName,
0:                                                                     new ConstructionTime(System.currentTimeMillis()),
0:                                                                     timeout);
1:                             waitForOperationsToComplete(operation);
1:                         }
1:                     }
1:                     catch (InterruptedException e)
1:                     {
1:                         e.printStackTrace();
1:                         fail("Unexpected exception");
1:                     }
1:                     finally
1:                     {
1:                         finished.countDown();
1:                     }
1:                 });
1:             }
1: 
1:             finished.await();
1:             assertEquals(0, executorService.shutdownNow().size());
1: 
1:             List<String> failedOperations = MonitoringTask.instance.getFailedOperations();
1:             assertEquals(numExpectedOperations, failedOperations.size());
1:             if (numExpectedOperations > 0)
1:                 assertTrue(failedOperations.get(numExpectedOperations - 1).startsWith("..."));
1:         }
1:         finally
1:         {
1:             MonitoringTask.instance = MonitoringTask.make(REPORT_INTERVAL_MS, MAX_TIMEDOUT_OPERATIONS);
1:         }
1:     }
1: 
1:     @Test
0:     public void testMultipleThreadsSameName() throws InterruptedException
1:     {
1:         final int threadCount = 50;
1:         final List<Monitorable> operations = new ArrayList<>(threadCount);
1:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:         final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:         for (int i = 0; i < threadCount; i++)
1:         {
1:             executorService.submit(() -> {
1:                 try
1:                 {
0:                     Monitorable operation = new TestMonitor("Test testMultipleThreadsSameName",
0:                                                             new ConstructionTime(System.currentTimeMillis()),
0:                                                             timeout);
1:                     operations.add(operation);
1:                 }
1:                 finally
1:                 {
1:                     finished.countDown();
1:                 }
1:             });
1:         }
1: 
1:         finished.await();
1:         assertEquals(0, executorService.shutdownNow().size());
1: 
1:         waitForOperationsToComplete(operations);
0:         //MonitoringTask.instance.checkFailedOperations(ApproximateTime.currentTimeMillis());
1:         assertEquals(1, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: 
1:     @Test
1:     public void testMultipleThreadsNoFailedOps() throws InterruptedException
1:     {
1:         final int threadCount = 50;
1:         final List<Monitorable> operations = new ArrayList<>(threadCount);
1:         ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
1:         final CountDownLatch finished = new CountDownLatch(threadCount);
1: 
1:         for (int i = 0; i < threadCount; i++)
1:         {
1:             executorService.submit(() -> {
1:                 try
1:                 {
1:                     Monitorable operation = new TestMonitor("Test thread " + Thread.currentThread().getName(),
0:                                                             new ConstructionTime(System.currentTimeMillis()),
0:                                                             timeout);
1:                     operations.add(operation);
1:                     operation.complete();
1:                 }
1:                 finally
1:                 {
1:                     finished.countDown();
1:                 }
1:             });
1:         }
1: 
1:         finished.await();
1:         assertEquals(0, executorService.shutdownNow().size());
1: 
1:         waitForOperationsToComplete(operations);
1:         assertEquals(0, MonitoringTask.instance.getFailedOperations().size());
1:     }
1: }
============================================================================