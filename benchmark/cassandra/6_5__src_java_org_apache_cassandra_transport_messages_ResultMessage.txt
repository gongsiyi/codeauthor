1:6d3a3ee: /*
1:6d3a3ee:  * Licensed to the Apache Software Foundation (ASF) under one
1:6d3a3ee:  * or more contributor license agreements.  See the NOTICE file
1:6d3a3ee:  * distributed with this work for additional information
1:6d3a3ee:  * regarding copyright ownership.  The ASF licenses this file
1:6d3a3ee:  * to you under the Apache License, Version 2.0 (the
1:6d3a3ee:  * "License"); you may not use this file except in compliance
1:6d3a3ee:  * with the License.  You may obtain a copy of the License at
1:6d3a3ee:  *
1:6d3a3ee:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6d3a3ee:  *
1:6d3a3ee:  * Unless required by applicable law or agreed to in writing, software
1:6d3a3ee:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6d3a3ee:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6d3a3ee:  * See the License for the specific language governing permissions and
1:6d3a3ee:  * limitations under the License.
1:6d3a3ee:  */
1:6d3a3ee: package org.apache.cassandra.transport.messages;
18:6d3a3ee: 
1:6d3a3ee: import java.util.*;
1:6d3a3ee: 
1:cbf304e: import io.netty.buffer.ByteBuf;
1:6d3a3ee: 
1:6d3a3ee: import org.apache.cassandra.cql3.ColumnSpecification;
1:dad2f11: import org.apache.cassandra.cql3.CQLStatement;
1:6d3a3ee: import org.apache.cassandra.cql3.ResultSet;
1:dad2f11: import org.apache.cassandra.cql3.statements.SelectStatement;
1:dad2f11: import org.apache.cassandra.cql3.statements.ParsedStatement;
1:6d3a3ee: import org.apache.cassandra.transport.*;
1:6d3a3ee: import org.apache.cassandra.thrift.CqlPreparedResult;
1:6d3a3ee: import org.apache.cassandra.thrift.CqlResult;
1:6d3a3ee: import org.apache.cassandra.thrift.CqlResultType;
1:ccca5f1: import org.apache.cassandra.utils.MD5Digest;
1:6d3a3ee: 
1:6d3a3ee: public abstract class ResultMessage extends Message.Response
13:6d3a3ee: {
1:6d3a3ee:     public static final Message.Codec<ResultMessage> codec = new Message.Codec<ResultMessage>()
1:6d3a3ee:     {
1:e0adc16:         public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:6d3a3ee:         {
1:6d3a3ee:             Kind kind = Kind.fromId(body.readInt());
1:bf2ee04:             return kind.subcodec.decode(body, version);
13:6d3a3ee:         }
1:11f7d72: 
1:e0adc16:         public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:11f7d72:         {
1:f8be23a:             dest.writeInt(msg.kind.id);
1:f8be23a:             msg.kind.subcodec.encode(msg, dest, version);
1:f8be23a:         }
1:11f7d72: 
1:e0adc16:         public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:f8be23a:         {
1:f8be23a:             return 4 + msg.kind.subcodec.encodedSize(msg, version);
1:11f7d72:         }
1:6d3a3ee:     };
1:11f7d72: 
1:864e036:     public enum Kind
1:11f7d72:     {
1:6d3a3ee:         VOID         (1, Void.subcodec),
1:6d3a3ee:         ROWS         (2, Rows.subcodec),
1:6d3a3ee:         SET_KEYSPACE (3, SetKeyspace.subcodec),
1:11f7d72:         PREPARED     (4, Prepared.subcodec),
1:11f7d72:         SCHEMA_CHANGE(5, SchemaChange.subcodec);
1:6d3a3ee: 
1:6d3a3ee:         public final int id;
1:6d3a3ee:         public final Message.Codec<ResultMessage> subcodec;
1:6d3a3ee: 
1:6d3a3ee:         private static final Kind[] ids;
1:6d3a3ee:         static
1:6d3a3ee:         {
1:6d3a3ee:             int maxId = -1;
1:6d3a3ee:             for (Kind k : Kind.values())
1:6d3a3ee:                 maxId = Math.max(maxId, k.id);
1:6d3a3ee:             ids = new Kind[maxId + 1];
1:6d3a3ee:             for (Kind k : Kind.values())
1:6d3a3ee:             {
1:6d3a3ee:                 if (ids[k.id] != null)
1:6d3a3ee:                     throw new IllegalStateException("Duplicate kind id");
1:6d3a3ee:                 ids[k.id] = k;
1:6d3a3ee:             }
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         private Kind(int id, Message.Codec<ResultMessage> subcodec)
1:6d3a3ee:         {
1:6d3a3ee:             this.id = id;
1:6d3a3ee:             this.subcodec = subcodec;
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         public static Kind fromId(int id)
1:6d3a3ee:         {
1:6d3a3ee:             Kind k = ids[id];
1:6d3a3ee:             if (k == null)
1:6d3a3ee:                 throw new ProtocolException(String.format("Unknown kind id %d in RESULT message", id));
1:6d3a3ee:             return k;
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:864e036:     public final Kind kind;
1:6d3a3ee: 
1:6d3a3ee:     protected ResultMessage(Kind kind)
1:6d3a3ee:     {
1:6d3a3ee:         super(Message.Type.RESULT);
1:6d3a3ee:         this.kind = kind;
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public abstract CqlResult toThriftResult();
1:6d3a3ee: 
1:6d3a3ee:     public static class Void extends ResultMessage
1:6d3a3ee:     {
1:3b0aa84:         // Even though we have no specific information here, don't make a
1:3b0aa84:         // singleton since as each message it has in fact a streamid and connection.
1:3b0aa84:         public Void()
1:6d3a3ee:         {
1:6d3a3ee:             super(Kind.VOID);
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:6d3a3ee:         {
1:e0adc16:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:6d3a3ee:             {
1:3b0aa84:                 return new Void();
1:6d3a3ee:             }
1:6d3a3ee: 
1:e0adc16:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:6d3a3ee:             {
1:6d3a3ee:                 assert msg instanceof Void;
1:f8be23a:             }
1:f8be23a: 
1:e0adc16:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:f8be23a:             {
1:f8be23a:                 return 0;
1:6d3a3ee:             }
1:6d3a3ee:         };
1:6d3a3ee: 
1:6d3a3ee:         public CqlResult toThriftResult()
1:6d3a3ee:         {
1:6d3a3ee:             return new CqlResult(CqlResultType.VOID);
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         @Override
1:6d3a3ee:         public String toString()
1:6d3a3ee:         {
1:6d3a3ee:             return "EMPTY RESULT";
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public static class SetKeyspace extends ResultMessage
1:6d3a3ee:     {
1:11f7d72:         public final String keyspace;
1:11f7d72: 
1:6d3a3ee:         public SetKeyspace(String keyspace)
1:11f7d72:         {
1:6d3a3ee:             super(Kind.SET_KEYSPACE);
1:11f7d72:             this.keyspace = keyspace;
1:11f7d72:         }
1:11f7d72: 
1:6d3a3ee:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:11f7d72:         {
1:e0adc16:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:6d3a3ee:             {
1:11f7d72:                 String keyspace = CBUtil.readString(body);
1:6d3a3ee:                 return new SetKeyspace(keyspace);
1:f8be23a:             }
1:f8be23a: 
1:e0adc16:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:f8be23a:             {
1:6d3a3ee:                 assert msg instanceof SetKeyspace;
1:f8be23a:                 CBUtil.writeString(((SetKeyspace)msg).keyspace, dest);
1:f8be23a:             }
1:f8be23a: 
1:e0adc16:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:f8be23a:             {
1:f8be23a:                 assert msg instanceof SetKeyspace;
1:f8be23a:                 return CBUtil.sizeOfString(((SetKeyspace)msg).keyspace);
1:11f7d72:             }
1:6d3a3ee:         };
1:11f7d72: 
1:6d3a3ee:         public CqlResult toThriftResult()
1:6d3a3ee:         {
1:6d3a3ee:             return new CqlResult(CqlResultType.VOID);
1:11f7d72:         }
1:11f7d72: 
1:6d3a3ee:         @Override
1:6d3a3ee:         public String toString()
1:6d3a3ee:         {
1:6d3a3ee:             return "RESULT set keyspace " + keyspace;
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public static class Rows extends ResultMessage
1:6d3a3ee:     {
1:6d3a3ee:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:6d3a3ee:         {
1:e0adc16:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:6d3a3ee:             {
1:bf2ee04:                 return new Rows(ResultSet.codec.decode(body, version));
1:6d3a3ee:             }
1:6d3a3ee: 
1:e0adc16:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:6d3a3ee:             {
1:6d3a3ee:                 assert msg instanceof Rows;
1:6d3a3ee:                 Rows rowMsg = (Rows)msg;
1:f8be23a:                 ResultSet.codec.encode(rowMsg.result, dest, version);
1:f8be23a:             }
1:f8be23a: 
1:e0adc16:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:f8be23a:             {
1:f8be23a:                 assert msg instanceof Rows;
1:f8be23a:                 Rows rowMsg = (Rows)msg;
1:f8be23a:                 return ResultSet.codec.encodedSize(rowMsg.result, version);
1:6d3a3ee:             }
1:6d3a3ee:         };
1:6d3a3ee: 
1:6d3a3ee:         public final ResultSet result;
1:6d3a3ee: 
1:6d3a3ee:         public Rows(ResultSet result)
1:6d3a3ee:         {
1:6d3a3ee:             super(Kind.ROWS);
1:6d3a3ee:             this.result = result;
1:028f539:         }
1:028f539: 
1:6d3a3ee:         public CqlResult toThriftResult()
1:028f539:         {
1:6d3a3ee:             return result.toThriftResult();
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         @Override
1:6d3a3ee:         public String toString()
1:6d3a3ee:         {
1:6d3a3ee:             return "ROWS " + result;
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     public static class Prepared extends ResultMessage
1:6d3a3ee:     {
1:6d3a3ee:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:6d3a3ee:         {
1:e0adc16:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:6d3a3ee:             {
1:ccca5f1:                 MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
1:dca37a6:                 ResultSet.PreparedMetadata metadata = ResultSet.PreparedMetadata.codec.decode(body, version);
1:6158c64: 
1:dca37a6:                 ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.EMPTY;
1:e0adc16:                 if (version.isGreaterThan(ProtocolVersion.V1))
1:dca37a6:                     resultMetadata = ResultSet.ResultMetadata.codec.decode(body, version);
1:dad2f11: 
1:dad2f11:                 return new Prepared(id, -1, metadata, resultMetadata);
1:6d3a3ee:             }
1:6d3a3ee: 
1:e0adc16:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:6d3a3ee:             {
1:6d3a3ee:                 assert msg instanceof Prepared;
1:6d3a3ee:                 Prepared prepared = (Prepared)msg;
1:ccca5f1:                 assert prepared.statementId != null;
1:dad2f11: 
1:f8be23a:                 CBUtil.writeBytes(prepared.statementId.bytes, dest);
1:dca37a6:                 ResultSet.PreparedMetadata.codec.encode(prepared.metadata, dest, version);
1:e0adc16:                 if (version.isGreaterThan(ProtocolVersion.V1))
1:dca37a6:                     ResultSet.ResultMetadata.codec.encode(prepared.resultMetadata, dest, version);
1:f8be23a:             }
1:f8be23a: 
1:e0adc16:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:f8be23a:             {
1:f8be23a:                 assert msg instanceof Prepared;
1:f8be23a:                 Prepared prepared = (Prepared)msg;
1:f8be23a:                 assert prepared.statementId != null;
1:dad2f11: 
1:f8be23a:                 int size = 0;
1:f8be23a:                 size += CBUtil.sizeOfBytes(prepared.statementId.bytes);
1:dca37a6:                 size += ResultSet.PreparedMetadata.codec.encodedSize(prepared.metadata, version);
1:e0adc16:                 if (version.isGreaterThan(ProtocolVersion.V1))
1:dca37a6:                     size += ResultSet.ResultMetadata.codec.encodedSize(prepared.resultMetadata, version);
1:f8be23a:                 return size;
1:6d3a3ee:             }
1:6d3a3ee:         };
1:6d3a3ee: 
1:ccca5f1:         public final MD5Digest statementId;
1:028f539: 
1:028f539:         /** Describes the variables to be bound in the prepared statement */
1:dca37a6:         public final ResultSet.PreparedMetadata metadata;
1:028f539: 
1:028f539:         /** Describes the results of executing this prepared statement */
1:dca37a6:         public final ResultSet.ResultMetadata resultMetadata;
1:6d3a3ee: 
1:ccca5f1:         // statement id for CQL-over-thrift compatibility. The binary protocol ignore that.
1:ccca5f1:         private final int thriftStatementId;
1:ccca5f1: 
1:dad2f11:         public Prepared(MD5Digest statementId, ParsedStatement.Prepared prepared)
1:6d3a3ee:         {
1:dca37a6:             this(statementId, -1, new ResultSet.PreparedMetadata(prepared.boundNames, prepared.partitionKeyBindIndexes), extractResultMetadata(prepared.statement));
1:6d3a3ee:         }
1:6d3a3ee: 
1:ccca5f1:         public static Prepared forThrift(int statementId, List<ColumnSpecification> names)
1:ccca5f1:         {
1:dca37a6:             return new Prepared(null, statementId, new ResultSet.PreparedMetadata(names, null), ResultSet.ResultMetadata.EMPTY);
1:ccca5f1:         }
1:ccca5f1: 
1:dca37a6:         private Prepared(MD5Digest statementId, int thriftStatementId, ResultSet.PreparedMetadata metadata, ResultSet.ResultMetadata resultMetadata)
1:6d3a3ee:         {
1:6d3a3ee:             super(Kind.PREPARED);
1:6d3a3ee:             this.statementId = statementId;
1:ccca5f1:             this.thriftStatementId = thriftStatementId;
1:6d3a3ee:             this.metadata = metadata;
1:dad2f11:             this.resultMetadata = resultMetadata;
1:dad2f11:         }
1:dad2f11: 
1:dca37a6:         private static ResultSet.ResultMetadata extractResultMetadata(CQLStatement statement)
1:dad2f11:         {
1:dad2f11:             if (!(statement instanceof SelectStatement))
1:dca37a6:                 return ResultSet.ResultMetadata.EMPTY;
1:dad2f11: 
1:dad2f11:             return ((SelectStatement)statement).getResultMetadata();
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         public CqlResult toThriftResult()
1:6d3a3ee:         {
1:6d3a3ee:             throw new UnsupportedOperationException();
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         public CqlPreparedResult toThriftPreparedResult()
1:6d3a3ee:         {
1:6d3a3ee:             List<String> namesString = new ArrayList<String>(metadata.names.size());
1:6d3a3ee:             List<String> typesString = new ArrayList<String>(metadata.names.size());
1:6d3a3ee:             for (ColumnSpecification name : metadata.names)
1:6d3a3ee:             {
1:6d3a3ee:                 namesString.add(name.toString());
1:b7e1082:                 typesString.add(name.type.toString());
1:6d3a3ee:             }
1:ccca5f1:             return new CqlPreparedResult(thriftStatementId, metadata.names.size()).setVariable_types(typesString).setVariable_names(namesString);
1:6d3a3ee:         }
1:6d3a3ee: 
1:6d3a3ee:         @Override
1:6d3a3ee:         public String toString()
1:6d3a3ee:         {
1:57769f6:             return "RESULT PREPARED " + statementId + " " + metadata + " (resultMetadata=" + resultMetadata + ")";
1:6d3a3ee:         }
1:6d3a3ee:     }
1:6d3a3ee: 
1:11f7d72:     public static class SchemaChange extends ResultMessage
1:11f7d72:     {
1:2fe6de6:         public final Event.SchemaChange change;
1:11f7d72: 
1:2fe6de6:         public SchemaChange(Event.SchemaChange change)
1:11f7d72:         {
1:11f7d72:             super(Kind.SCHEMA_CHANGE);
1:11f7d72:             this.change = change;
1:11f7d72:         }
1:11f7d72: 
1:11f7d72:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:11f7d72:         {
1:e0adc16:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:11f7d72:             {
1:2fe6de6:                 return new SchemaChange(Event.SchemaChange.deserializeEvent(body, version));
1:11f7d72:             }
1:11f7d72: 
1:e0adc16:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:11f7d72:             {
1:11f7d72:                 assert msg instanceof SchemaChange;
1:11f7d72:                 SchemaChange scm = (SchemaChange)msg;
1:2fe6de6:                 scm.change.serializeEvent(dest, version);
1:11f7d72:             }
1:f8be23a: 
1:e0adc16:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
1:11f7d72:             {
1:f8be23a:                 assert msg instanceof SchemaChange;
1:f8be23a:                 SchemaChange scm = (SchemaChange)msg;
1:2fe6de6:                 return scm.change.eventSerializedSize(version);
1:11f7d72:             }
1:11f7d72:         };
1:11f7d72: 
1:11f7d72:         public CqlResult toThriftResult()
1:11f7d72:         {
1:11f7d72:             return new CqlResult(CqlResultType.VOID);
1:11f7d72:         }
1:11f7d72: 
1:11f7d72:         @Override
1:11f7d72:         public String toString()
1:6d3a3ee:         {
1:2fe6de6:             return "RESULT schema change " + change;
1:11f7d72:         }
1:6d3a3ee:     }
1:6d3a3ee: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1:         public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:         public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:         public int encodedSize(ResultMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:                 if (version.isGreaterThan(ProtocolVersion.V1))
1:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:                 if (version.isGreaterThan(ProtocolVersion.V1))
1:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:                 if (version.isGreaterThan(ProtocolVersion.V1))
/////////////////////////////////////////////////////////////////////////
1:             public ResultMessage decode(ByteBuf body, ProtocolVersion version)
1:             public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
1:             public int encodedSize(ResultMessage msg, ProtocolVersion version)
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:dca37a6
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet.PreparedMetadata metadata = ResultSet.PreparedMetadata.codec.decode(body, version);
1:                 ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.EMPTY;
1:                     resultMetadata = ResultSet.ResultMetadata.codec.decode(body, version);
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet.PreparedMetadata.codec.encode(prepared.metadata, dest, version);
1:                     ResultSet.ResultMetadata.codec.encode(prepared.resultMetadata, dest, version);
/////////////////////////////////////////////////////////////////////////
1:                 size += ResultSet.PreparedMetadata.codec.encodedSize(prepared.metadata, version);
1:                     size += ResultSet.ResultMetadata.codec.encodedSize(prepared.resultMetadata, version);
/////////////////////////////////////////////////////////////////////////
1:         public final ResultSet.PreparedMetadata metadata;
1:         public final ResultSet.ResultMetadata resultMetadata;
1:             this(statementId, -1, new ResultSet.PreparedMetadata(prepared.boundNames, prepared.partitionKeyBindIndexes), extractResultMetadata(prepared.statement));
1:             return new Prepared(null, statementId, new ResultSet.PreparedMetadata(names, null), ResultSet.ResultMetadata.EMPTY);
1:         private Prepared(MD5Digest statementId, int thriftStatementId, ResultSet.PreparedMetadata metadata, ResultSet.ResultMetadata resultMetadata)
/////////////////////////////////////////////////////////////////////////
1:         private static ResultSet.ResultMetadata extractResultMetadata(CQLStatement statement)
1:                 return ResultSet.ResultMetadata.EMPTY;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:02fb218
/////////////////////////////////////////////////////////////////////////
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:0249363
/////////////////////////////////////////////////////////////////////////
commit:2fe6de6
/////////////////////////////////////////////////////////////////////////
1:         public final Event.SchemaChange change;
1:         public SchemaChange(Event.SchemaChange change)
1:                 return new SchemaChange(Event.SchemaChange.deserializeEvent(body, version));
1:                 scm.change.serializeEvent(dest, version);
1:                 return scm.change.eventSerializedSize(version);
/////////////////////////////////////////////////////////////////////////
1:             return "RESULT schema change " + change;
commit:028f539
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.pager.PagingState;
/////////////////////////////////////////////////////////////////////////
0:         public Rows withPagingState(PagingState state)
1:         {
0:             return new Rows(result.withPagingState(state));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         /** Describes the variables to be bound in the prepared statement */
1: 
1:         /** Describes the results of executing this prepared statement */
commit:36f2178
/////////////////////////////////////////////////////////////////////////
0:                     size += ResultSet.Metadata.codec.encodedSize(prepared.resultMetadata, version);
commit:f8be23a
/////////////////////////////////////////////////////////////////////////
0:         public void encode(ResultMessage msg, ChannelBuffer dest, int version)
1:             dest.writeInt(msg.kind.id);
1:             msg.kind.subcodec.encode(msg, dest, version);
1:         }
0:         public int encodedSize(ResultMessage msg, int version)
1:         {
1:             return 4 + msg.kind.subcodec.encodedSize(msg, version);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ChannelBuffer dest, int version)
1:             }
1: 
0:             public int encodedSize(ResultMessage msg, int version)
1:             {
1:                 return 0;
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ChannelBuffer dest, int version)
1:                 CBUtil.writeString(((SetKeyspace)msg).keyspace, dest);
1:             }
1: 
0:             public int encodedSize(ResultMessage msg, int version)
1:             {
1:                 assert msg instanceof SetKeyspace;
1:                 return CBUtil.sizeOfString(((SetKeyspace)msg).keyspace);
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ChannelBuffer dest, int version)
1:                 ResultSet.codec.encode(rowMsg.result, dest, version);
1:             }
1: 
0:             public int encodedSize(ResultMessage msg, int version)
1:             {
1:                 assert msg instanceof Rows;
1:                 Rows rowMsg = (Rows)msg;
1:                 return ResultSet.codec.encodedSize(rowMsg.result, version);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ChannelBuffer dest, int version)
1:                 CBUtil.writeBytes(prepared.statementId.bytes, dest);
0:                 ResultSet.Metadata.codec.encode(prepared.metadata, dest, version);
0:                 if (version > 1)
0:                     ResultSet.Metadata.codec.encode(prepared.resultMetadata, dest, version);
1:             }
0:             public int encodedSize(ResultMessage msg, int version)
1:             {
1:                 assert msg instanceof Prepared;
1:                 Prepared prepared = (Prepared)msg;
1:                 assert prepared.statementId != null;
1: 
1:                 int size = 0;
1:                 size += CBUtil.sizeOfBytes(prepared.statementId.bytes);
0:                 size += ResultSet.Metadata.codec.encodedSize(prepared.metadata, version);
0:                 if (version > 1)
0:                     ResultSet.Metadata.codec.encodedSize(prepared.resultMetadata, version);
1:                 return size;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 Change change = CBUtil.readEnumValue(Change.class, body);
0:             public void encode(ResultMessage msg, ChannelBuffer dest, int version)
0:                 CBUtil.writeEnumValue(scm.change, dest);
0:                 CBUtil.writeString(scm.keyspace, dest);
0:                 CBUtil.writeString(scm.columnFamily, dest);
1:             }
1: 
0:             public int encodedSize(ResultMessage msg, int version)
1:             {
1:                 assert msg instanceof SchemaChange;
1:                 SchemaChange scm = (SchemaChange)msg;
1: 
0:                 int size = 0;
0:                 size += CBUtil.sizeOfEnumValue(scm.change);
0:                 size += CBUtil.sizeOfString(scm.keyspace);
0:                 size += CBUtil.sizeOfString(scm.columnFamily);
0:                 return size;
commit:5a18e37
/////////////////////////////////////////////////////////////////////////
0:             ChannelBuffer body = msg.encodeBody(version);
/////////////////////////////////////////////////////////////////////////
0:     public ChannelBuffer encode(int version)
0:         return codec.encode(this, version);
0:     protected abstract ChannelBuffer encodeBody(int version);
/////////////////////////////////////////////////////////////////////////
0:         protected ChannelBuffer encodeBody(int version)
0:             return subcodec.encode(this, version);
/////////////////////////////////////////////////////////////////////////
0:         protected ChannelBuffer encodeBody(int version)
0:             return subcodec.encode(this, version);
/////////////////////////////////////////////////////////////////////////
0:         protected ChannelBuffer encodeBody(int version)
0:             return subcodec.encode(this, version);
/////////////////////////////////////////////////////////////////////////
0:         protected ChannelBuffer encodeBody(int version)
0:             return subcodec.encode(this, version);
/////////////////////////////////////////////////////////////////////////
0:         protected ChannelBuffer encodeBody(int version)
0:             return subcodec.encode(this, version);
commit:57769f6
/////////////////////////////////////////////////////////////////////////
1:             return "RESULT PREPARED " + statementId + " " + metadata + " (resultMetadata=" + resultMetadata + ")";
commit:6158c64
/////////////////////////////////////////////////////////////////////////
1: 
0:                 ResultSet.Metadata resultMetadata = ResultSet.Metadata.EMPTY;
0:                 if (version > 1)
0:                     resultMetadata = ResultSet.Metadata.codec.decode(body, version);
/////////////////////////////////////////////////////////////////////////
0:                                                     version > 1 ? ResultSet.Metadata.codec.encode(prepared.resultMetadata, version) : ChannelBuffers.EMPTY_BUFFER);
/////////////////////////////////////////////////////////////////////////
0:             return new Prepared(null, statementId, new ResultSet.Metadata(names), ResultSet.Metadata.EMPTY);
/////////////////////////////////////////////////////////////////////////
0:                 return ResultSet.Metadata.EMPTY;
commit:dad2f11
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.CQLStatement;
1: import org.apache.cassandra.cql3.statements.SelectStatement;
1: import org.apache.cassandra.cql3.statements.ParsedStatement;
/////////////////////////////////////////////////////////////////////////
0:                 ResultSet.Metadata metadata = ResultSet.Metadata.codec.decode(body, version);
0:                 ResultSet.Metadata resultMetadata = ResultSet.Metadata.codec.decode(body, version);
1: 
1:                 return new Prepared(id, -1, metadata, resultMetadata);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                 return ChannelBuffers.wrappedBuffer(CBUtil.bytesToCB(prepared.statementId.bytes),
0:                                                     ResultSet.Metadata.codec.encode(prepared.metadata, version),
0:                                                     ResultSet.Metadata.codec.encode(prepared.resultMetadata, version));
0:         public final ResultSet.Metadata resultMetadata;
1:         public Prepared(MD5Digest statementId, ParsedStatement.Prepared prepared)
0:             this(statementId, -1, new ResultSet.Metadata(prepared.boundNames), extractResultMetadata(prepared.statement));
0:             return new Prepared(null, statementId, new ResultSet.Metadata(names), ResultSet.Metadata.empty);
0:         private Prepared(MD5Digest statementId, int thriftStatementId, ResultSet.Metadata metadata, ResultSet.Metadata resultMetadata)
1:             this.resultMetadata = resultMetadata;
1:         }
1: 
0:         private static ResultSet.Metadata extractResultMetadata(CQLStatement statement)
1:         {
1:             if (!(statement instanceof SelectStatement))
0:                 return ResultSet.Metadata.empty;
1: 
1:             return ((SelectStatement)statement).getResultMetadata();
commit:e48ff29
/////////////////////////////////////////////////////////////////////////
0:         public ChannelBuffer encode(ResultMessage msg, int version)
/////////////////////////////////////////////////////////////////////////
0:         return codec.encode(this, getVersion());
/////////////////////////////////////////////////////////////////////////
0:             public ChannelBuffer encode(ResultMessage msg, int version)
/////////////////////////////////////////////////////////////////////////
0:             return subcodec.encode(this, getVersion());
/////////////////////////////////////////////////////////////////////////
0:             public ChannelBuffer encode(ResultMessage msg, int version)
/////////////////////////////////////////////////////////////////////////
0:             return subcodec.encode(this, getVersion());
/////////////////////////////////////////////////////////////////////////
0:             public ChannelBuffer encode(ResultMessage msg, int version)
0:                 return ResultSet.codec.encode(rowMsg.result, version);
/////////////////////////////////////////////////////////////////////////
0:             return subcodec.encode(this, getVersion());
/////////////////////////////////////////////////////////////////////////
0:             public ChannelBuffer encode(ResultMessage msg, int version)
0:                 return ChannelBuffers.wrappedBuffer(CBUtil.bytesToCB(prepared.statementId.bytes), ResultSet.Metadata.codec.encode(prepared.metadata, version));
/////////////////////////////////////////////////////////////////////////
0:             return subcodec.encode(this, getVersion());
/////////////////////////////////////////////////////////////////////////
0:             public ChannelBuffer encode(ResultMessage msg, int version)
/////////////////////////////////////////////////////////////////////////
0:             return subcodec.encode(this, getVersion());
commit:b7e1082
/////////////////////////////////////////////////////////////////////////
1:                 typesString.add(name.type.toString());
commit:3b0aa84
/////////////////////////////////////////////////////////////////////////
1:         // Even though we have no specific information here, don't make a
1:         // singleton since as each message it has in fact a streamid and connection.
1:         public Void()
/////////////////////////////////////////////////////////////////////////
1:                 return new Void();
/////////////////////////////////////////////////////////////////////////
commit:11f7d72
/////////////////////////////////////////////////////////////////////////
1:         PREPARED     (4, Prepared.subcodec),
1:         SCHEMA_CHANGE(5, SchemaChange.subcodec);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static class SchemaChange extends ResultMessage
1:     {
0:         public enum Change { CREATED, UPDATED, DROPPED }
1: 
0:         public final Change change;
1:         public final String keyspace;
0:         public final String columnFamily;
1: 
0:         public SchemaChange(Change change, String keyspace)
1:         {
0:             this(change, keyspace, "");
1:         }
1: 
0:         public SchemaChange(Change change, String keyspace, String columnFamily)
1:         {
1:             super(Kind.SCHEMA_CHANGE);
1:             this.change = change;
1:             this.keyspace = keyspace;
0:             this.columnFamily = columnFamily;
1:         }
1: 
1:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:         {
0:             public ResultMessage decode(ChannelBuffer body)
1:             {
0:                 String cStr = CBUtil.readString(body);
0:                 Change change = null;
0:                 try
1:                 {
0:                     change = Enum.valueOf(Change.class, cStr.toUpperCase());
1:                 }
0:                 catch (IllegalStateException e)
1:                 {
0:                     throw new ProtocolException("Unknown Schema change action: " + cStr);
1:                 }
1: 
1:                 String keyspace = CBUtil.readString(body);
0:                 String columnFamily = CBUtil.readString(body);
0:                 return new SchemaChange(change, keyspace, columnFamily);
1: 
1:             }
1: 
0:             public ChannelBuffer encode(ResultMessage msg)
1:             {
1:                 assert msg instanceof SchemaChange;
1:                 SchemaChange scm = (SchemaChange)msg;
1: 
0:                 ChannelBuffer a = CBUtil.stringToCB(scm.change.toString());
0:                 ChannelBuffer k = CBUtil.stringToCB(scm.keyspace);
0:                 ChannelBuffer c = CBUtil.stringToCB(scm.columnFamily);
0:                 return ChannelBuffers.wrappedBuffer(a, k, c);
1:             }
1:         };
1: 
0:         protected ChannelBuffer encodeBody()
1:         {
0:             return subcodec.encode(this);
1:         }
1: 
1:         public CqlResult toThriftResult()
1:         {
1:             return new CqlResult(CqlResultType.VOID);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
0:             return "RESULT schema change " + change + " on " + keyspace + (columnFamily.isEmpty() ? "" : "." + columnFamily);
1:         }
1:     }
commit:16f3d33
/////////////////////////////////////////////////////////////////////////
0:         public final String keyspace;
commit:ccca5f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.MD5Digest;
/////////////////////////////////////////////////////////////////////////
1:                 MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
0:                 return new Prepared(id, -1, ResultSet.Metadata.codec.decode(body));
1:                 assert prepared.statementId != null;
0:                 return ChannelBuffers.wrappedBuffer(CBUtil.bytesToCB(prepared.statementId.bytes), ResultSet.Metadata.codec.encode(prepared.metadata));
1:         public final MD5Digest statementId;
1:         // statement id for CQL-over-thrift compatibility. The binary protocol ignore that.
1:         private final int thriftStatementId;
1: 
0:         public Prepared(MD5Digest statementId, List<ColumnSpecification> names)
0:             this(statementId, -1, new ResultSet.Metadata(names));
1:         public static Prepared forThrift(int statementId, List<ColumnSpecification> names)
1:         {
0:             return new Prepared(null, statementId, new ResultSet.Metadata(names));
1:         }
1: 
0:         private Prepared(MD5Digest statementId, int thriftStatementId, ResultSet.Metadata metadata)
1:             this.thriftStatementId = thriftStatementId;
/////////////////////////////////////////////////////////////////////////
1:             return new CqlPreparedResult(thriftStatementId, metadata.names.size()).setVariable_types(typesString).setVariable_names(namesString);
commit:864e036
/////////////////////////////////////////////////////////////////////////
1:     public enum Kind
/////////////////////////////////////////////////////////////////////////
1:     public final Kind kind;
commit:6d3a3ee
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.transport.messages;
1: 
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
1: import java.util.*;
0: import java.util.concurrent.TimeoutException;
1: 
0: import org.jboss.netty.buffer.ChannelBuffer;
0: import org.jboss.netty.buffer.ChannelBuffers;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.cql3.ColumnSpecification;
0: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.ResultSet;
1: import org.apache.cassandra.transport.*;
0: import org.apache.cassandra.db.marshal.TypeParser;
1: import org.apache.cassandra.thrift.CqlPreparedResult;
1: import org.apache.cassandra.thrift.CqlResult;
1: import org.apache.cassandra.thrift.CqlResultType;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: public abstract class ResultMessage extends Message.Response
1: {
1:     public static final Message.Codec<ResultMessage> codec = new Message.Codec<ResultMessage>()
1:     {
0:         public ResultMessage decode(ChannelBuffer body)
1:         {
1:             Kind kind = Kind.fromId(body.readInt());
0:             return kind.subcodec.decode(body);
1:         }
1: 
0:         public ChannelBuffer encode(ResultMessage msg)
1:         {
0:             ChannelBuffer kcb = ChannelBuffers.buffer(4);
0:             kcb.writeInt(msg.kind.id);
1: 
0:             ChannelBuffer body = msg.encodeBody();
0:             return ChannelBuffers.wrappedBuffer(kcb, body);
1:         }
1:     };
1: 
0:     private enum Kind
1:     {
1:         VOID         (1, Void.subcodec),
1:         ROWS         (2, Rows.subcodec),
1:         SET_KEYSPACE (3, SetKeyspace.subcodec),
0:         PREPARED     (4, Prepared.subcodec);
1: 
1:         public final int id;
1:         public final Message.Codec<ResultMessage> subcodec;
1: 
1:         private static final Kind[] ids;
1:         static
1:         {
1:             int maxId = -1;
1:             for (Kind k : Kind.values())
1:                 maxId = Math.max(maxId, k.id);
1:             ids = new Kind[maxId + 1];
1:             for (Kind k : Kind.values())
1:             {
1:                 if (ids[k.id] != null)
1:                     throw new IllegalStateException("Duplicate kind id");
1:                 ids[k.id] = k;
1:             }
1:         }
1: 
1:         private Kind(int id, Message.Codec<ResultMessage> subcodec)
1:         {
1:             this.id = id;
1:             this.subcodec = subcodec;
1:         }
1: 
1:         public static Kind fromId(int id)
1:         {
1:             Kind k = ids[id];
1:             if (k == null)
1:                 throw new ProtocolException(String.format("Unknown kind id %d in RESULT message", id));
1:             return k;
1:         }
1:     }
1: 
0:     private final Kind kind;
1: 
1:     protected ResultMessage(Kind kind)
1:     {
1:         super(Message.Type.RESULT);
1:         this.kind = kind;
1:     }
1: 
0:     public ChannelBuffer encode()
1:     {
0:         return codec.encode(this);
1:     }
1: 
0:     protected abstract ChannelBuffer encodeBody();
1: 
1:     public abstract CqlResult toThriftResult();
1: 
1:     public static class Void extends ResultMessage
1:     {
0:         // use VOID_MESSAGE
0:         private Void()
1:         {
1:             super(Kind.VOID);
1:         }
1: 
1:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:         {
0:             public ResultMessage decode(ChannelBuffer body)
1:             {
0:                 return Void.instance();
1:             }
1: 
0:             public ChannelBuffer encode(ResultMessage msg)
1:             {
1:                 assert msg instanceof Void;
0:                 return ChannelBuffers.EMPTY_BUFFER;
1:             }
1:         };
1: 
0:         protected ChannelBuffer encodeBody()
1:         {
0:             return subcodec.encode(this);
1:         }
1: 
1:         public CqlResult toThriftResult()
1:         {
1:             return new CqlResult(CqlResultType.VOID);
1:         }
1: 
0:         public static Void instance()
1:         {
0:             return Holder.instance;
1:         }
1: 
0:         // Battling java initialization
0:         private static class Holder
1:         {
0:             static final Void instance = new Void();
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return "EMPTY RESULT";
1:         }
1:     }
1: 
1:     public static class SetKeyspace extends ResultMessage
1:     {
0:         private final String keyspace;
1: 
1:         public SetKeyspace(String keyspace)
1:         {
1:             super(Kind.SET_KEYSPACE);
0:             this.keyspace = keyspace;
1:         }
1: 
1:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:         {
0:             public ResultMessage decode(ChannelBuffer body)
1:             {
0:                 String keyspace = CBUtil.readString(body);
1:                 return new SetKeyspace(keyspace);
1:             }
1: 
0:             public ChannelBuffer encode(ResultMessage msg)
1:             {
1:                 assert msg instanceof SetKeyspace;
0:                 return CBUtil.stringToCB(((SetKeyspace)msg).keyspace);
1:             }
1:         };
1: 
0:         protected ChannelBuffer encodeBody()
1:         {
0:             return subcodec.encode(this);
1:         }
1: 
1:         public CqlResult toThriftResult()
1:         {
1:             return new CqlResult(CqlResultType.VOID);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return "RESULT set keyspace " + keyspace;
1:         }
1:     }
1: 
1:     public static class Rows extends ResultMessage
1:     {
1:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:         {
0:             public ResultMessage decode(ChannelBuffer body)
1:             {
0:                 return new Rows(ResultSet.codec.decode(body));
1:             }
1: 
0:             public ChannelBuffer encode(ResultMessage msg)
1:             {
1:                 assert msg instanceof Rows;
1:                 Rows rowMsg = (Rows)msg;
0:                 return ResultSet.codec.encode(rowMsg.result);
1:             }
1:         };
1: 
1:         public final ResultSet result;
1: 
1:         public Rows(ResultSet result)
1:         {
1:             super(Kind.ROWS);
1:             this.result = result;
1:         }
1: 
0:         protected ChannelBuffer encodeBody()
1:         {
0:             return subcodec.encode(this);
1:         }
1: 
1:         public CqlResult toThriftResult()
1:         {
1:             return result.toThriftResult();
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return "ROWS " + result;
1:         }
1: 
1:     }
1: 
1:     public static class Prepared extends ResultMessage
1:     {
1:         public static final Message.Codec<ResultMessage> subcodec = new Message.Codec<ResultMessage>()
1:         {
0:             public ResultMessage decode(ChannelBuffer body)
1:             {
0:                 int id = body.readInt();
0:                 return new Prepared(id, ResultSet.Metadata.codec.decode(body));
1:             }
1: 
0:             public ChannelBuffer encode(ResultMessage msg)
1:             {
1:                 assert msg instanceof Prepared;
1:                 Prepared prepared = (Prepared)msg;
0:                 return ChannelBuffers.wrappedBuffer(CBUtil.intToCB(prepared.statementId), ResultSet.Metadata.codec.encode(prepared.metadata));
1:             }
1:         };
1: 
0:         public final int statementId;
0:         public final ResultSet.Metadata metadata;
1: 
0:         public Prepared(int statementId, List<ColumnSpecification> names)
1:         {
0:             this(statementId, new ResultSet.Metadata(names));
1:         }
1: 
0:         private Prepared(int statementId, ResultSet.Metadata metadata)
1:         {
1:             super(Kind.PREPARED);
1:             this.statementId = statementId;
1:             this.metadata = metadata;
1:         }
1: 
0:         protected ChannelBuffer encodeBody()
1:         {
0:             return subcodec.encode(this);
1:         }
1: 
1:         public CqlResult toThriftResult()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public CqlPreparedResult toThriftPreparedResult()
1:         {
1:             List<String> namesString = new ArrayList<String>(metadata.names.size());
1:             List<String> typesString = new ArrayList<String>(metadata.names.size());
1:             for (ColumnSpecification name : metadata.names)
1:             {
1:                 namesString.add(name.toString());
0:                 typesString.add(TypeParser.getShortName(name.type));
1:             }
0:             return new CqlPreparedResult(statementId, metadata.names.size()).setVariable_types(typesString).setVariable_names(namesString);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
0:             return "RESULT PREPARED " + statementId + " " + metadata;
1:         }
1:     }
1: }
author:belliottsmith
-------------------------------------------------------------------------------
commit:cbf304e
/////////////////////////////////////////////////////////////////////////
1: import io.netty.buffer.ByteBuf;
/////////////////////////////////////////////////////////////////////////
0:         public ResultMessage decode(ByteBuf body, int version)
0:         public void encode(ResultMessage msg, ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ByteBuf body, int version)
0:             public void encode(ResultMessage msg, ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ByteBuf body, int version)
0:             public void encode(ResultMessage msg, ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ByteBuf body, int version)
0:             public void encode(ResultMessage msg, ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ByteBuf body, int version)
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ByteBuf body, int version)
/////////////////////////////////////////////////////////////////////////
0:             public void encode(ResultMessage msg, ByteBuf dest, int version)
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:bf2ee04
/////////////////////////////////////////////////////////////////////////
0:         public ResultMessage decode(ChannelBuffer body, int version)
1:             return kind.subcodec.decode(body, version);
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ChannelBuffer body, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ChannelBuffer body, int version)
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ChannelBuffer body, int version)
1:                 return new Rows(ResultSet.codec.decode(body, version));
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ChannelBuffer body, int version)
0:                 return new Prepared(id, -1, ResultSet.Metadata.codec.decode(body, version));
/////////////////////////////////////////////////////////////////////////
0:             public ResultMessage decode(ChannelBuffer body, int version)
============================================================================