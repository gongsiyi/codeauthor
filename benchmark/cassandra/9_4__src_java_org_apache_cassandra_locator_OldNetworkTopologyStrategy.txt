2:066ef58: /*
1:07cf56f:  * Licensed to the Apache Software Foundation (ASF) under one
1:07cf56f:  * or more contributor license agreements.  See the NOTICE file
1:07cf56f:  * distributed with this work for additional information
1:07cf56f:  * regarding copyright ownership.  The ASF licenses this file
1:07cf56f:  * to you under the Apache License, Version 2.0 (the
1:07cf56f:  * "License"); you may not use this file except in compliance
1:07cf56f:  * with the License.  You may obtain a copy of the License at
1:07cf56f:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cf56f:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:07cf56f:  */
1:066ef58: package org.apache.cassandra.locator;
1:34e241a: 
1:34e241a: import java.net.InetAddress;
1:e98eb1c: import java.util.ArrayList;
1:c315745: import java.util.Collections;
1:c315745: import java.util.Collection;
1:e98eb1c: import java.util.Iterator;
1:e98eb1c: import java.util.List;
1:e98eb1c: import java.util.Map;
1:720c49a: 
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:066ef58: import org.apache.cassandra.dht.Token;
1:3678daa: 
1:48ed049: /**
1:cb1ef76:  * This Replication Strategy returns the nodes responsible for a given
1:cb1ef76:  * key but respects rack awareness. It places one replica in a
1:cb1ef76:  * different data center from the first (if there is any such data center),
1:48ed049:  * the third replica in a different rack in the first datacenter, and
1:48ed049:  * any remaining replicas on the first unused nodes on the ring.
2:066ef58:  */
1:916c810: public class OldNetworkTopologyStrategy extends AbstractReplicationStrategy
15:066ef58: {
1:0e96e58:     public OldNetworkTopologyStrategy(String keyspaceName, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions)
1:066ef58:     {
1:0e96e58:         super(keyspaceName, tokenMetadata, snitch, configOptions);
15:066ef58:     }
1:0f2caaa: 
1:ce9179e:     public List<InetAddress> calculateNaturalEndpoints(Token token, TokenMetadata metadata)
1:847f3b0:     {
1:df8a933:         int replicas = getReplicationFactor();
1:ce9179e:         List<InetAddress> endpoints = new ArrayList<InetAddress>(replicas);
1:d8755b3:         ArrayList<Token> tokens = metadata.sortedTokens();
1:6877a05: 
1:720c49a:         if (tokens.isEmpty())
1:924c7e5:             return endpoints;
1:8c7bc2f: 
1:389bac7:         Iterator<Token> iter = TokenMetadata.ringIterator(tokens, token, false);
1:6877a05:         Token primaryToken = iter.next();
1:18b2a16:         endpoints.add(metadata.getEndpoint(primaryToken));
1:0eea213: 
1:6877a05:         boolean bDataCenter = false;
1:6877a05:         boolean bOtherRack = false;
1:6877a05:         while (endpoints.size() < replicas && iter.hasNext())
1:8c7bc2f:         {
1:5a45534:             // First try to find one in a different data center
1:5a45534:             Token t = iter.next();
1:5a45534:             if (!snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
1:8c7bc2f:             {
1:5a45534:                 // If we have already found something in a diff datacenter no need to find another
1:5a45534:                 if (!bDataCenter)
1:5a45534:                 {
1:5a45534:                     endpoints.add(metadata.getEndpoint(t));
1:5a45534:                     bDataCenter = true;
1:8c7bc2f:                 }
1:5a45534:                 continue;
1:5a45534:             }
1:5a45534:             // Now  try to find one on a different rack
1:5a45534:             if (!snitch.getRack(metadata.getEndpoint(primaryToken)).equals(snitch.getRack(metadata.getEndpoint(t))) &&
1:5a45534:                 snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
1:5a45534:             {
1:5a45534:                 // If we have already found something in a diff rack no need to find another
1:5a45534:                 if (!bOtherRack)
1:5a45534:                 {
1:5a45534:                     endpoints.add(metadata.getEndpoint(t));
1:5a45534:                     bOtherRack = true;
1:5a45534:                 }
1:5a45534:             }
1:0789a58: 
1:a2e2c03:         }
1:720c49a: 
1:066ef58:         // If we found N number of nodes we are good. This loop wil just exit. Otherwise just
1:066ef58:         // loop through the list and add until we have N nodes.
1:0789a58:         if (endpoints.size() < replicas)
1:847f3b0:         {
1:389bac7:             iter = TokenMetadata.ringIterator(tokens, token, false);
1:6877a05:             while (endpoints.size() < replicas && iter.hasNext())
1:066ef58:             {
1:6877a05:                 Token t = iter.next();
1:18b2a16:                 if (!endpoints.contains(metadata.getEndpoint(t)))
2:18b2a16:                     endpoints.add(metadata.getEndpoint(t));
1:847f3b0:             }
1:847f3b0:         }
1:6877a05: 
1:720c49a:         return endpoints;
1:066ef58:     }
3:847f3b0: 
1:8c7bc2f:     public int getReplicationFactor()
1:8c7bc2f:     {
1:8c7bc2f:         return Integer.parseInt(this.configOptions.get("replication_factor"));
1:8c7bc2f:     }
1:8c7bc2f: 
1:8c7bc2f:     public void validateOptions() throws ConfigurationException
1:8c7bc2f:     {
1:921f499:         if (configOptions == null || configOptions.get("replication_factor") == null)
1:8c7bc2f:         {
1:921f499:             throw new ConfigurationException("SimpleStrategy requires a replication_factor strategy option.");
1:8c7bc2f:         }
1:921f499:         validateReplicationFactor(configOptions.get("replication_factor"));
1:8c7bc2f:     }
1:c315745: 
1:c315745:     public Collection<String> recognizedOptions()
1:c315745:     {
1:c315745:         return Collections.<String>singleton("replication_factor");
1:c315745:     }
1:8c7bc2f: }
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1:     public OldNetworkTopologyStrategy(String keyspaceName, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions)
1:         super(keyspaceName, tokenMetadata, snitch, configOptions);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:56f35db
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:c315745
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Collection<String> recognizedOptions()
1:     {
1:         return Collections.<String>singleton("replication_factor");
1:     }
commit:5267112
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Table;
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:b803c37
commit:921f499
/////////////////////////////////////////////////////////////////////////
1:         if (configOptions == null || configOptions.get("replication_factor") == null)
1:             throw new ConfigurationException("SimpleStrategy requires a replication_factor strategy option.");
1:         validateReplicationFactor(configOptions.get("replication_factor"));
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getReplicationFactor()
1:     {
1:         return Integer.parseInt(this.configOptions.get("replication_factor"));
1:     }
1: 
1:     public void validateOptions() throws ConfigurationException
1:     {
0:         if (this.configOptions == null)
1:         {
0:             throw new ConfigurationException("OldNetworkTopologyStrategy requires a replication_factor strategy option.");
1:         }
0:         if (this.configOptions.get("replication_factor") == null)
1:         {
0:             throw new ConfigurationException("OldNetworkTopologyStrategy requires a replication_factor strategy option.");
1:         }
0:         int rf = Integer.parseInt(this.configOptions.get("replication_factor"));
0:         if (rf < 0)
1:         {
0:             throw new ConfigurationException("Replication factor for OldNetworkTopologyStrategy must be non-negative, "+rf+" given.");
1:         }
1:     }
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
commit:389bac7
/////////////////////////////////////////////////////////////////////////
1:         Iterator<Token> iter = TokenMetadata.ringIterator(tokens, token, false);
/////////////////////////////////////////////////////////////////////////
1:             iter = TokenMetadata.ringIterator(tokens, token, false);
commit:ce9179e
/////////////////////////////////////////////////////////////////////////
1:     public List<InetAddress> calculateNaturalEndpoints(Token token, TokenMetadata metadata)
1:         List<InetAddress> endpoints = new ArrayList<InetAddress>(replicas);
commit:3866585
/////////////////////////////////////////////////////////////////////////
commit:916c810
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class OldNetworkTopologyStrategy extends AbstractReplicationStrategy
0:     public OldNetworkTopologyStrategy(String table, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions)
/////////////////////////////////////////////////////////////////////////
0:             AbstractNetworkTopologySnitch snitch = (AbstractNetworkTopologySnitch) this.snitch;
commit:b297bab
/////////////////////////////////////////////////////////////////////////
commit:0789a58
/////////////////////////////////////////////////////////////////////////
0:         int replicas = getReplicationFactor(table);
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (endpoints.size() < replicas)
0:                 throw new IllegalStateException(String.format("replication factor (%s) exceeds number of endpoints (%s)", replicas, endpoints.size()));
commit:d8755b3
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Token> tokens = metadata.sortedTokens();
commit:48ed049
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * the third replica in a different rack in the first datacenter, and
1:  * any remaining replicas on the first unused nodes on the ring.
commit:34e241a
/////////////////////////////////////////////////////////////////////////
1: 
1: import java.net.InetAddress;
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     public Set<InetAddress> calculateNaturalEndpoints(Token token, TokenMetadata metadata, String table)
0:         Set<InetAddress> endpoints = new HashSet<InetAddress>(replicas);
/////////////////////////////////////////////////////////////////////////
0:             AbstractRackAwareSnitch snitch = (AbstractRackAwareSnitch) this.snitch;
commit:5a45534
/////////////////////////////////////////////////////////////////////////
0:             AbstractRackAwareSnitch snitch = (AbstractRackAwareSnitch)snitch_;
1:             // First try to find one in a different data center
1:             Token t = iter.next();
1:             if (!snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
1:                 // If we have already found something in a diff datacenter no need to find another
1:                 if (!bDataCenter)
1:                 {
1:                     endpoints.add(metadata.getEndpoint(t));
1:                     bDataCenter = true;
1:                 }
1:                 continue;
1:             }
1:             // Now  try to find one on a different rack
1:             if (!snitch.getRack(metadata.getEndpoint(primaryToken)).equals(snitch.getRack(metadata.getEndpoint(t))) &&
1:                 snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
1:             {
1:                 // If we have already found something in a diff rack no need to find another
1:                 if (!bOtherRack)
1:                 {
1:                     endpoints.add(metadata.getEndpoint(t));
1:                     bOtherRack = true;
1:                 }
commit:cb1ef76
/////////////////////////////////////////////////////////////////////////
1:  * This Replication Strategy returns the nodes responsible for a given
1:  * key but respects rack awareness. It places one replica in a
1:  * different data center from the first (if there is any such data center),
0:  * and remaining replicas in different racks in the same datacenter as
0:  * the first.
commit:0f2caaa
/////////////////////////////////////////////////////////////////////////
0:                 AbstractRackAwareSnitch snitch = (AbstractRackAwareSnitch)snitch_;
1: 
0:                 if (!snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
/////////////////////////////////////////////////////////////////////////
0:                 if (!snitch.getRack(metadata.getEndpoint(primaryToken)).equals(snitch.getRack(metadata.getEndpoint(t))) &&
0:                     snitch.getDatacenter(metadata.getEndpoint(primaryToken)).equals(snitch.getDatacenter(metadata.getEndpoint(t))))
commit:1a904da
/////////////////////////////////////////////////////////////////////////
0:         if (!(snitch instanceof AbstractRackAwareSnitch))
0:             throw new IllegalArgumentException(("RackAwareStrategy requires AbstractRackAwareSnitch."));
/////////////////////////////////////////////////////////////////////////
0:                 if (!((AbstractRackAwareSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
/////////////////////////////////////////////////////////////////////////
0:                 if (!((AbstractRackAwareSnitch)snitch_).isOnSameRack(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)) &&
0:                     ((AbstractRackAwareSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
commit:7a4a709
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalArgumentException(("RackAwareStrategy requires EndpointSnitch."));
commit:2e1b1a5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, IEndpointSnitch snitch)
0:         if (!(snitch instanceof EndpointSnitch))
/////////////////////////////////////////////////////////////////////////
0:                 if (!((EndpointSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
/////////////////////////////////////////////////////////////////////////
0:                 if (!((EndpointSnitch)snitch_).isOnSameRack(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)) &&
0:                     ((EndpointSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
1:         endpoints.add(metadata.getEndpoint(primaryToken));
/////////////////////////////////////////////////////////////////////////
0:                 if (!((EndPointSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
1:                         endpoints.add(metadata.getEndpoint(t));
0:                 if (!((EndPointSnitch)snitch_).isOnSameRack(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)) &&
0:                     ((EndPointSnitch)snitch_).isInSameDataCenter(metadata.getEndpoint(primaryToken), metadata.getEndpoint(t)))
1:                         endpoints.add(metadata.getEndpoint(t));
/////////////////////////////////////////////////////////////////////////
1:                 if (!endpoints.contains(metadata.getEndpoint(t)))
0:                     endpoints.add(metadata.getEndpoint(t));
commit:6877a05
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:         int replicas = DatabaseDescriptor.getReplicationFactor(table);
0:         ArrayList<InetAddress> endpoints = new ArrayList<InetAddress>(replicas);
0:         List<Token> tokens = metadata.sortedTokens();
0:         Iterator<Token> iter = TokenMetadata.ringIterator(tokens, token);
1:         Token primaryToken = iter.next();
1:         boolean bDataCenter = false;
1:         boolean bOtherRack = false;
1:         while (endpoints.size() < replicas && iter.hasNext())
1:                 Token t = iter.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (endpoints.size() < replicas)
0:             iter = TokenMetadata.ringIterator(tokens, token);
1:             while (endpoints.size() < replicas && iter.hasNext())
0:                 Token t = iter.next();
0:                 if (!endpoints.contains(metadata.getEndPoint(t)))
0:                     endpoints.add(metadata.getEndPoint(t));
1: 
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
0:         EndPointSnitch endPointSnitch = (EndPointSnitch) StorageService.instance.getEndPointSnitch();
/////////////////////////////////////////////////////////////////////////
1: }
commit:efae42b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         EndPointSnitch endPointSnitch = (EndPointSnitch) StorageService.instance().getEndPointSnitch();
commit:0eea213
/////////////////////////////////////////////////////////////////////////
0:     private final EndPointSnitch endPointSnitch;
1: 
0:         endPointSnitch = (EndPointSnitch) StorageService.instance().getEndPointSnitch();
/////////////////////////////////////////////////////////////////////////
commit:720c49a
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (tokens.isEmpty())
1:             return endpoints;
1: 
commit:704c915
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 throw new RuntimeException(e);
commit:93c5afa
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, IPartitioner partitioner, int replicas)
0:         super(tokenMetadata, partitioner, replicas);
commit:3678daa
/////////////////////////////////////////////////////////////////////////
0:     public ArrayList<InetAddress> getNaturalEndpoints(Token token, TokenMetadata metadata)
0:         List tokens = metadata.sortedTokens();
/////////////////////////////////////////////////////////////////////////
0:         Token primaryToken = (Token) tokens.get(index);
0:         endpoints.add(metadata.getEndPoint(primaryToken));
/////////////////////////////////////////////////////////////////////////
1: 
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i + 1) % totalNodes)
0:                 Token t = (Token) tokens.get(i);
0:                 if (!endPointSnitch.isInSameDataCenter(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)))
0:                     if (!bDataCenter)
0:                         endpoints.add(metadata.getEndPoint(t));
0:                 if (!endPointSnitch.isOnSameRack(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)) &&
0:                     endPointSnitch.isInSameDataCenter(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)))
0:                     if (!bOtherRack)
0:                         endpoints.add(metadata.getEndPoint(t));
/////////////////////////////////////////////////////////////////////////
0:                     logger_.debug(LogUtil.throwableToString(e));
/////////////////////////////////////////////////////////////////////////
0:             Token t = (Token) tokens.get(i);
0:             if (!endpoints.contains(metadata.getEndPoint(t)))
0:                 endpoints.add(metadata.getEndPoint(t));
commit:924c7e5
/////////////////////////////////////////////////////////////////////////
0:     public ArrayList<InetAddress> getNaturalEndpoints(Token token, Map<Token, InetAddress> tokenToEndPointMap)
0:         ArrayList<InetAddress> endpoints = new ArrayList<InetAddress>();
/////////////////////////////////////////////////////////////////////////
0:         endpoints.add(tokenToEndPointMap.get(tokens.get(index)));
0:         if (replicas_ == 1)
1:             return endpoints;
/////////////////////////////////////////////////////////////////////////
0:                         endpoints.add(tokenToEndPointMap.get(tokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:                         endpoints.add(tokenToEndPointMap.get(tokens.get(i)));
/////////////////////////////////////////////////////////////////////////
0:             if( ! endpoints.contains(tokenToEndPointMap.get(tokens.get(i))))
0:                 endpoints.add(tokenToEndPointMap.get(tokens.get(i)));
0:         return endpoints;
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:     public InetAddress[] getReadStorageEndPoints(Token token, Map<Token, InetAddress> tokenToEndPointMap)
0:         List<InetAddress> list = new ArrayList<InetAddress>();
/////////////////////////////////////////////////////////////////////////
0:             return list.toArray(new InetAddress[list.size()]);
/////////////////////////////////////////////////////////////////////////
0:         return list.toArray(new InetAddress[list.size()]);
commit:d5eaa4e
/////////////////////////////////////////////////////////////////////////
0:         return retrofitPorts(list).toArray(new EndPoint[list.size()]);
commit:7dbbca6
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
/////////////////////////////////////////////////////////////////////////
commit:eb83251
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class RackAwareStrategy extends AbstractReplicationStrategy
0:     public EndPoint[] getReadStorageEndPoints(Token token)
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
0:     public EndPoint[] getWriteStorageEndPoints(Token token)
commit:847f3b0
/////////////////////////////////////////////////////////////////////////
1: 
0:     public EndPoint[] getStorageEndPointsForWrite(Token token)
1:     {
0:         throw new UnsupportedOperationException("Rack-aware bootstrapping not supported");
1:     }
1: 
1:     
0:     public Map<EndPoint, EndPoint> getHintedStorageEndPointsForWrite(Token token)
1:     {
0:         throw new UnsupportedOperationException("Rack-aware bootstrapping not supported");
1:     }
commit:e959b2c
/////////////////////////////////////////////////////////////////////////
0:             results.put(key, getStorageEndPoints(partitioner_.getToken(key)));
commit:8a9c25a
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(Token token)
/////////////////////////////////////////////////////////////////////////
0:     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
0:             results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
0:     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
commit:70ce402
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(Token token,  int offset)
/////////////////////////////////////////////////////////////////////////
0:     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys, int offset)
0:             results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key), offset));
0:     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap, int offset)
commit:066ef58
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
1: package org.apache.cassandra.locator;
0: 
0: import java.net.UnknownHostException;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: 
1: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.LogUtil;
0: 
1: /*
0:  * This class returns the nodes responsible for a given
0:  * key but does respects rack awareness. It makes a best
0:  * effort to get a node from a different data center and
0:  * a node in a different rack in the same datacenter as
0:  * the primary.
1:  */
0: public class RackAwareStrategy extends AbstractStrategy
1: {
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, IPartitioner partitioner, int replicas, int storagePort)
1:     {
0:         super(tokenMetadata, partitioner, replicas, storagePort);
1:     }
0: 
0:     public EndPoint[] getStorageEndPoints(Token token)
1:     {
0:         int startIndex;
0:         List<EndPoint> list = new ArrayList<EndPoint>();
0:         boolean bDataCenter = false;
0:         boolean bOtherRack = false;
0:         int foundCount = 0;
0:         Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:         List tokens = new ArrayList(tokenToEndPointMap.keySet());
0:         Collections.sort(tokens);
0:         int index = Collections.binarySearch(tokens, token);
0:         if(index < 0)
1:         {
0:             index = (index + 1) * (-1);
0:             if (index >= tokens.size())
0:                 index = 0;
1:         }
0:         int totalNodes = tokens.size();
0:         // Add the node at the index by default
0:         list.add(tokenToEndPointMap.get(tokens.get(index)));
0:         foundCount++;
0:         if( replicas_ == 1 )
1:         {
0:             return list.toArray(new EndPoint[list.size()]);
1:         }
0:         startIndex = (index + 1)%totalNodes;
0:         IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();
0:         
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)
1:         {
0:             try
1:             {
0:                 // First try to find one in a different data center
0:                 if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
1:                 {
0:                     // If we have already found something in a diff datacenter no need to find another
0:                     if( !bDataCenter )
1:                     {
0:                         list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                         bDataCenter = true;
0:                         foundCount++;
1:                     }
0:                     continue;
1:                 }
0:                 // Now  try to find one on a different rack
0:                 if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&
0:                         endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
1:                 {
0:                     // If we have already found something in a diff rack no need to find another
0:                     if( !bOtherRack )
1:                     {
0:                         list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                         bOtherRack = true;
0:                         foundCount++;
1:                     }
1:                 }
1:             }
0:             catch (UnknownHostException e)
1:             {
0:                 if (logger_.isDebugEnabled())
0:                   logger_.debug(LogUtil.throwableToString(e));
1:             }
0: 
1:         }
1:         // If we found N number of nodes we are good. This loop wil just exit. Otherwise just
1:         // loop through the list and add until we have N nodes.
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)
1:         {
0:             if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))
1:             {
0:                 list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                 foundCount++;
1:             }
1:         }
0:         retrofitPorts(list);
0:         return list.toArray(new EndPoint[list.size()]);
1:     }
0:     
0:     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
1:     {
0:     	Map<String, EndPoint[]> results = new HashMap<String, EndPoint[]>();
0: 
0:         for ( String key : keys )
1:         {
0:             results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
1:         }
0: 
0:         return results;
1:     }
0: 
0:     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
1:     {
0:         throw new UnsupportedOperationException("This operation is not currently supported");
1:     }
commit:0077af4
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
/////////////////////////////////////////////////////////////////////////
0:                 if (logger_.isDebugEnabled())
0:                   logger_.debug(LogUtil.throwableToString(e));
commit:88edbed
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
commit:71739ef
commit:bfb2e95
/////////////////////////////////////////////////////////////////////////
0:             results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
commit:ec7f04b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.IPartitioner;
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, IPartitioner partitioner, int replicas, int storagePort)
0:         super(tokenMetadata, partitioner, replicas, storagePort);
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if( replicas_ == 1 )
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)
/////////////////////////////////////////////////////////////////////////
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)
/////////////////////////////////////////////////////////////////////////
0:             results.put(key, getStorageEndPoints(partitioner_.getTokenForKey(key)));
commit:907d92e
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigInteger;
0: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(Token token)
/////////////////////////////////////////////////////////////////////////
0:         Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:         List tokens = new ArrayList(tokenToEndPointMap.keySet());
/////////////////////////////////////////////////////////////////////////
0:             results.put(key, getStorageEndPoints(StorageService.token(key)));
0: 
0: 
0:     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
commit:2e9466c
/////////////////////////////////////////////////////////////////////////
0:         int startIndex;
/////////////////////////////////////////////////////////////////////////
0:             return list.toArray(new EndPoint[list.size()]);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return list.toArray(new EndPoint[list.size()]);
0: 
0:             results.put(key, getStorageEndPoints(token));
commit:dd61d51
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(Token token)
/////////////////////////////////////////////////////////////////////////
0:         Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:         List tokens = new ArrayList(tokenToEndPointMap.keySet());
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
commit:8ce795a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Brandon Williams
-------------------------------------------------------------------------------
commit:771695a
/////////////////////////////////////////////////////////////////////////
0:         Set<InetAddress> endpoints = new HashSet<InetAddress>(replicas);
commit:e0d4419
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
0:         Set<InetAddress> endpoints = new LinkedHashSet<InetAddress>(replicas);
author:Eric Evans
-------------------------------------------------------------------------------
commit:df8a933
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(String table, TokenMetadata tokenMetadata, IEndpointSnitch snitch, Map<String, String> configOptions)
0:         super(table, tokenMetadata, snitch, configOptions);
0:     public Set<InetAddress> calculateNaturalEndpoints(Token token, TokenMetadata metadata)
1:         int replicas = getReplicationFactor();
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, IEndPointSnitch snitch)
0:         super(tokenMetadata, snitch);
0:         if (!(snitch instanceof EndPointSnitch))
0:             throw new IllegalArgumentException(("RackAwareStrategy requires EndPointSnitch."));
0:     public ArrayList<InetAddress> getNaturalEndpoints(Token token, TokenMetadata metadata, String table)
/////////////////////////////////////////////////////////////////////////
0:         final int replicas = DatabaseDescriptor.getReplicationFactor(table);
0:         if (replicas == 1)
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas; ++count, i = (i + 1) % totalNodes)
0:                 if (!((EndPointSnitch)snitch_).isInSameDataCenter(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)))
/////////////////////////////////////////////////////////////////////////
0:                 if (!((EndPointSnitch)snitch_).isOnSameRack(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)) &&
0:                     ((EndPointSnitch)snitch_).isInSameDataCenter(metadata.getEndPoint(primaryToken), metadata.getEndPoint(t)))
/////////////////////////////////////////////////////////////////////////
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas; ++count, i = (i+1)%totalNodes)
commit:dcaf84e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public RackAwareStrategy(TokenMetadata tokenMetadata, int replicas)
0:         super(tokenMetadata, replicas);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:bd884e4
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigInteger;
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:     public EndPoint[] getStorageEndPoints(BigInteger token)
/////////////////////////////////////////////////////////////////////////
0:         Map<BigInteger, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:         List<BigInteger> tokens = new ArrayList<BigInteger>(tokenToEndPointMap.keySet());
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
0:     {
0:     	Map<String, EndPoint[]> results = new HashMap<String, EndPoint[]>();
0:     	List<EndPoint> list = new ArrayList<EndPoint>();
0:     	int startIndex = 0 ;
0:     	int foundCount = 0;
0:     	boolean bDataCenter = false;
0:         boolean bOtherRack = false;
0:     	
0:     	Map<BigInteger, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:     	int N = DatabaseDescriptor.getReplicationFactor();
0:         List<BigInteger> tokens = new ArrayList<BigInteger>(tokenToEndPointMap.keySet());
0:         Collections.sort(tokens);
0:         
0:         for ( String key : keys )
0:         {
0:         	BigInteger token = StorageService.hash(key);
0:         	int index = Collections.binarySearch(tokens, token);
0:             if(index < 0)
0:             {
0:                 index = (index + 1) * (-1);
0:                 if (index >= tokens.size())
0:                     index = 0;
0:             }
0:             int totalNodes = tokens.size();
0:             // Add the node at the index by default
0:             list.add(tokenToEndPointMap.get(tokens.get(index)));
0:             foundCount++;
0:             if( N == 1 )
0:             {
0:             	results.put( key, list.toArray(new EndPoint[0]) );
0:                 return results;
0:             }
0:             startIndex = (index + 1)%totalNodes;
0:             IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();
0:             
0:             for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:             {
0:                 try
0:                 {
0:                     // First try to find one in a different data center
0:                     if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                     {
0:                         // If we have already found something in a diff datacenter no need to find another
0:                         if( !bDataCenter )
0:                         {
0:                             list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                             bDataCenter = true;
0:                             foundCount++;
0:                         }
0:                         continue;
0:                     }
0:                     // Now  try to find one on a different rack
0:                     if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&
0:                             endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                     {
0:                         // If we have already found something in a diff rack no need to find another
0:                         if( !bOtherRack )
0:                         {
0:                             list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                             bOtherRack = true;
0:                             foundCount++;
0:                         }
0:                         continue;
0:                     }
0:                 }
0:                 catch (UnknownHostException e)
0:                 {
0:                     logger_.debug(LogUtil.throwableToString(e));
0:                 }
0:             }
0:             // If we found N number of nodes we are good. This loop wil just exit. Otherwise just
0:             // loop through the list and add until we have N nodes.
0:             for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:             {
0:                 if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))
0:                 {
0:                     list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                     foundCount++;
0:                     continue;
0:                 }
0:             }
0:             retrofitPorts(list);
0:             results.put(key, list.toArray(new EndPoint[0]));
0:         }
0:         
0:         return results;
0:     }
0:     
0:     public EndPoint[] getStorageEndPoints(BigInteger token, Map<BigInteger, EndPoint> tokenToEndPointMap)
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.locator;
0: 
0: import java.math.BigInteger;
0: import java.net.UnknownHostException;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.LogUtil;
0: 
0: 
0: /*
0:  * This class returns the nodes responsible for a given
0:  * key but does respects rack awareness. It makes a best
0:  * effort to get a node from a different data center and
0:  * a node in a different rack in the same datacenter as
0:  * the primary.
0:  */
0: public class RackAwareStrategy extends AbstractStrategy
0: {
0:     public RackAwareStrategy(TokenMetadata tokenMetadata)
0:     {
0:         super(tokenMetadata);
0:     }
0:     
0:     public EndPoint[] getStorageEndPoints(BigInteger token)
0:     {
0:         int startIndex = 0 ;
0:         List<EndPoint> list = new ArrayList<EndPoint>();
0:         boolean bDataCenter = false;
0:         boolean bOtherRack = false;
0:         int foundCount = 0;
0:         int N = DatabaseDescriptor.getReplicationFactor();
0:         Map<BigInteger, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:         List<BigInteger> tokens = new ArrayList<BigInteger>(tokenToEndPointMap.keySet());
0:         Collections.sort(tokens);
0:         int index = Collections.binarySearch(tokens, token);
0:         if(index < 0)
0:         {
0:             index = (index + 1) * (-1);
0:             if (index >= tokens.size())
0:                 index = 0;
0:         }
0:         int totalNodes = tokens.size();
0:         // Add the node at the index by default
0:         list.add(tokenToEndPointMap.get(tokens.get(index)));
0:         foundCount++;
0:         if( N == 1 )
0:         {
0:             return list.toArray(new EndPoint[0]);
0:         }
0:         startIndex = (index + 1)%totalNodes;
0:         IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();
0:         
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:         {
0:             try
0:             {
0:                 // First try to find one in a different data center
0:                 if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                 {
0:                     // If we have already found something in a diff datacenter no need to find another
0:                     if( !bDataCenter )
0:                     {
0:                         list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                         bDataCenter = true;
0:                         foundCount++;
0:                     }
0:                     continue;
0:                 }
0:                 // Now  try to find one on a different rack
0:                 if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&
0:                         endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                 {
0:                     // If we have already found something in a diff rack no need to find another
0:                     if( !bOtherRack )
0:                     {
0:                         list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                         bOtherRack = true;
0:                         foundCount++;
0:                     }
0:                     continue;
0:                 }
0:             }
0:             catch (UnknownHostException e)
0:             {
0:                 logger_.debug(LogUtil.throwableToString(e));
0:             }
0: 
0:         }
0:         // If we found N number of nodes we are good. This loop wil just exit. Otherwise just
0:         // loop through the list and add until we have N nodes.
0:         for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:         {
0:             if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))
0:             {
0:                 list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                 foundCount++;
0:                 continue;
0:             }
0:         }
0:         retrofitPorts(list);
0:         return list.toArray(new EndPoint[0]);
0:     }
0:     
0:     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
0:     {
0:     	Map<String, EndPoint[]> results = new HashMap<String, EndPoint[]>();
0:     	List<EndPoint> list = new ArrayList<EndPoint>();
0:     	int startIndex = 0 ;
0:     	int foundCount = 0;
0:     	boolean bDataCenter = false;
0:         boolean bOtherRack = false;
0:     	
0:     	Map<BigInteger, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
0:     	int N = DatabaseDescriptor.getReplicationFactor();
0:         List<BigInteger> tokens = new ArrayList<BigInteger>(tokenToEndPointMap.keySet());
0:         Collections.sort(tokens);
0:         
0:         for ( String key : keys )
0:         {
0:         	BigInteger token = StorageService.hash(key);
0:         	int index = Collections.binarySearch(tokens, token);
0:             if(index < 0)
0:             {
0:                 index = (index + 1) * (-1);
0:                 if (index >= tokens.size())
0:                     index = 0;
0:             }
0:             int totalNodes = tokens.size();
0:             // Add the node at the index by default
0:             list.add(tokenToEndPointMap.get(tokens.get(index)));
0:             foundCount++;
0:             if( N == 1 )
0:             {
0:             	results.put( key, list.toArray(new EndPoint[0]) );
0:                 return results;
0:             }
0:             startIndex = (index + 1)%totalNodes;
0:             IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();
0:             
0:             for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:             {
0:                 try
0:                 {
0:                     // First try to find one in a different data center
0:                     if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                     {
0:                         // If we have already found something in a diff datacenter no need to find another
0:                         if( !bDataCenter )
0:                         {
0:                             list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                             bDataCenter = true;
0:                             foundCount++;
0:                         }
0:                         continue;
0:                     }
0:                     // Now  try to find one on a different rack
0:                     if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&
0:                             endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))
0:                     {
0:                         // If we have already found something in a diff rack no need to find another
0:                         if( !bOtherRack )
0:                         {
0:                             list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                             bOtherRack = true;
0:                             foundCount++;
0:                         }
0:                         continue;
0:                     }
0:                 }
0:                 catch (UnknownHostException e)
0:                 {
0:                     logger_.debug(LogUtil.throwableToString(e));
0:                 }
0: 
0:             }
0:             // If we found N number of nodes we are good. This loop wil just exit. Otherwise just
0:             // loop through the list and add until we have N nodes.
0:             for (int i = startIndex, count = 1; count < totalNodes && foundCount < N; ++count, i = (i+1)%totalNodes)
0:             {
0:                 if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))
0:                 {
0:                     list.add(tokenToEndPointMap.get(tokens.get(i)));
0:                     foundCount++;
0:                     continue;
0:                 }
0:             }
0:             retrofitPorts(list);
0:             results.put(key, list.toArray(new EndPoint[0]));
0:         }
0:         
0:         return results;
0:     }
0:     
0:     public EndPoint[] getStorageEndPoints(BigInteger token, Map<BigInteger, EndPoint> tokenToEndPointMap)
0:     {
0:         throw new UnsupportedOperationException("This operation is not currently supported");
0:     }
0: }
============================================================================