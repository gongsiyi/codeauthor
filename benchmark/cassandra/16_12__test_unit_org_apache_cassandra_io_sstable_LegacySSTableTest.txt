1:12eb057: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:12eb057: package org.apache.cassandra.io.sstable;
1:eaa0694: 
1:12eb057: import java.io.File;
1:0600d7d: import java.io.FileInputStream;
1:0600d7d: import java.io.FileOutputStream;
1:0600d7d: import java.io.IOException;
1:5ab1a34: import java.util.ArrayList;
1:5ab1a34: import java.util.List;
1:0600d7d: import java.util.Random;
1:0600d7d: 
1:e8651b6: import org.junit.After;
1:0600d7d: import org.junit.Assert;
1:5ab1a34: import org.junit.BeforeClass;
1:0600d7d: import org.junit.Ignore;
1:5ab1a34: import org.junit.Test;
1:0600d7d: 
1:0600d7d: import org.slf4j.Logger;
1:0600d7d: import org.slf4j.LoggerFactory;
1:0600d7d: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:8d22d9f: import org.apache.cassandra.config.DatabaseDescriptor;
1:0600d7d: import org.apache.cassandra.cql3.QueryProcessor;
1:0600d7d: import org.apache.cassandra.cql3.UntypedResultSet;
1:5ab1a34: import org.apache.cassandra.db.ColumnFamilyStore;
1:5ab1a34: import org.apache.cassandra.db.Keyspace;
1:2111a20: import org.apache.cassandra.dht.IPartitioner;
1:2111a20: import org.apache.cassandra.dht.Range;
1:2111a20: import org.apache.cassandra.dht.Token;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableFormat;
1:a991b64: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:a991b64: import org.apache.cassandra.io.sstable.format.Version;
1:0600d7d: import org.apache.cassandra.io.sstable.format.big.BigFormat;
1:4378b58: import org.apache.cassandra.service.CacheService;
1:2111a20: import org.apache.cassandra.service.StorageService;
1:2111a20: import org.apache.cassandra.streaming.StreamPlan;
1:2111a20: import org.apache.cassandra.streaming.StreamSession;
1:b62b0ae: import org.apache.cassandra.utils.ByteBufferUtil;
1:5ab1a34: import org.apache.cassandra.utils.FBUtilities;
1:a991b64: 
3:12eb057: /**
1:7f2c3a8:  * Tests backwards compatibility for SSTables
4:12eb057:  */
1:d2a3827: public class LegacySSTableTest
1:0600d7d: {
1:0600d7d:     private static final Logger logger = LoggerFactory.getLogger(LegacySSTableTest.class);
1:a991b64: 
1:12eb057:     public static final String LEGACY_SSTABLE_PROP = "legacy-sstable-root";
1:a991b64: 
1:12eb057:     public static File LEGACY_SSTABLE_ROOT;
1:a991b64: 
1:0600d7d:     /**
1:0600d7d:      * When adding a new sstable version, add that one here.
1:0600d7d:      * See {@link #testGenerateSstables()} to generate sstables.
1:0600d7d:      * Take care on commit as you need to add the sstable files using {@code git add -f}
1:0600d7d:      */
1:904cb5d:     public static final String[] legacyVersions = {"mc", "mb", "ma", "la", "ka", "jb"};
1:a991b64: 
1:0600d7d:     // 1200 chars
1:0600d7d:     static final String longString = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:0600d7d:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789";
1:a991b64: 
1:12eb057:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:e8651b6:     {
1:eaa0694:         String scp = System.getProperty(LEGACY_SSTABLE_PROP);
1:eaa0694:         Assert.assertNotNull("System property " + LEGACY_SSTABLE_ROOT + " not set", scp);
1:a991b64:         
1:eaa0694:         LEGACY_SSTABLE_ROOT = new File(scp).getAbsoluteFile();
1:eaa0694:         Assert.assertTrue("System property " + LEGACY_SSTABLE_ROOT + " does not specify a directory", LEGACY_SSTABLE_ROOT.isDirectory());
1:eaa0694: 
1:d2a3827:         SchemaLoader.prepareServer();
1:e8651b6:         StorageService.instance.initServer();
1:5ab1a34:         Keyspace.setInitialized();
2:0600d7d:         createKeyspace();
2:e8651b6:         for (String legacyVersion : legacyVersions)
1:a991b64:         {
1:0600d7d:             createTables(legacyVersion);
1:a991b64:         }
1:a991b64: 
1:e8651b6:     }
1:a991b64: 
1:e8651b6:     @After
1:e8651b6:     public void tearDown()
1:e8651b6:     {
1:e8651b6:         for (String legacyVersion : legacyVersions)
1:e8651b6:         {
1:e8651b6:             truncateTables(legacyVersion);
1:e8651b6:         }
1:e8651b6:     }
1:eaa0694: 
1:12eb057:     /**
1:12eb057:      * Get a descriptor for the legacy sstable at the given version.
1:12eb057:      */
1:e8651b6:     protected Descriptor getDescriptor(String legacyVersion, String table)
1:2111a20:     {
1:e8651b6:         return new Descriptor(legacyVersion, getTableDir(legacyVersion, table), "legacy_tables", table, 1,
1:e8651b6:                               BigFormat.instance.getVersion(legacyVersion).hasNewFileName()?
1:e8651b6:                               SSTableFormat.Type.BIG :SSTableFormat.Type.LEGACY);
1:e8651b6:     }
1:0600d7d: 
1:0600d7d:     @Test
1:e8651b6:     public void testLoadLegacyCqlTables() throws Exception
1:0600d7d:     {
1:8d22d9f:         DatabaseDescriptor.setColumnIndexCacheSize(99999);
1:8d22d9f:         CacheService.instance.invalidateKeyCache();
1:8d22d9f:         doTestLegacyCqlTables();
1:8d22d9f:     }
1:8d22d9f: 
1:8d22d9f:     @Test
1:8d22d9f:     public void testLoadLegacyCqlTablesShallow() throws Exception
1:8d22d9f:     {
1:8d22d9f:         DatabaseDescriptor.setColumnIndexCacheSize(0);
1:8d22d9f:         CacheService.instance.invalidateKeyCache();
1:8d22d9f:         doTestLegacyCqlTables();
1:8d22d9f:     }
1:8d22d9f: 
1:8d22d9f:     private void doTestLegacyCqlTables() throws Exception
1:8d22d9f:     {
1:0600d7d:         for (String legacyVersion : legacyVersions)
1:0600d7d:         {
1:e8651b6:             logger.info("Loading legacy version: {}", legacyVersion);
1:8d22d9f:             truncateLegacyTables(legacyVersion);
1:e8651b6:             loadLegacyTables(legacyVersion);
1:e8651b6:             CacheService.instance.invalidateKeyCache();
1:e8651b6:             long startCount = CacheService.instance.keyCache.size();
1:e8651b6:             verifyReads(legacyVersion);
1:e8651b6:             verifyCache(legacyVersion, startCount);
1:8d22d9f:             compactLegacyTables(legacyVersion);
1:0600d7d:         }
1:b6b1053:     }
1:0600d7d: 
1:e8651b6:     @Test
1:e8651b6:     public void testStreamLegacyCqlTables() throws Exception
1:e8651b6:     {
1:e8651b6:         for (String legacyVersion : legacyVersions)
1:b6b1053:         {
1:e8651b6:             streamLegacyTables(legacyVersion);
1:e8651b6:             verifyReads(legacyVersion);
1:e8651b6:         }
1:e8651b6:     }
1:0600d7d: 
1:e8651b6:     private void streamLegacyTables(String legacyVersion) throws Exception
1:e8651b6:     {
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
1:e8651b6:         {
1:e8651b6:             logger.info("Streaming legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             streamLegacyTable("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             streamLegacyTable("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             streamLegacyTable("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             streamLegacyTable("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:         }
1:e8651b6:     }
1:0600d7d: 
1:e8651b6:     private void streamLegacyTable(String tablePattern, String legacyVersion, String compactNameSuffix) throws Exception
1:e8651b6:     {
1:e8651b6:         String table = String.format(tablePattern, legacyVersion, compactNameSuffix);
1:e8651b6:         SSTableReader sstable = SSTableReader.open(getDescriptor(legacyVersion, table));
1:69f77cb:         IPartitioner p = sstable.getPartitioner();
1:2111a20:         List<Range<Token>> ranges = new ArrayList<>();
1:2111a20:         ranges.add(new Range<>(p.getMinimumToken(), p.getToken(ByteBufferUtil.bytes("100"))));
1:2111a20:         ranges.add(new Range<>(p.getToken(ByteBufferUtil.bytes("100")), p.getMinimumToken()));
1:2111a20:         ArrayList<StreamSession.SSTableStreamingSections> details = new ArrayList<>();
1:9f7ab09:         details.add(new StreamSession.SSTableStreamingSections(sstable.ref(),
1:2111a20:                                                                sstable.getPositionsForRanges(ranges),
1:a7b7214:                                                                sstable.estimatedKeysForRanges(ranges), sstable.getSSTableMetadata().repairedAt));
1:2111a20:         new StreamPlan("LegacyStreamingTest").transferFiles(FBUtilities.getBroadcastAddress(), details)
1:2111a20:                                              .execute().get();
1:b6b1053:     }
1:0600d7d: 
1:8d22d9f:     private static void truncateLegacyTables(String legacyVersion) throws Exception
1:8d22d9f:     {
1:8d22d9f:         for (int compact = 0; compact <= 1; compact++)
1:8d22d9f:         {
1:8d22d9f:             logger.info("Truncating legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:8d22d9f:         }
1:8d22d9f:     }
1:8d22d9f: 
1:8d22d9f:     private static void compactLegacyTables(String legacyVersion) throws Exception
1:8d22d9f:     {
1:8d22d9f:         for (int compact = 0; compact <= 1; compact++)
1:8d22d9f:         {
1:8d22d9f:             logger.info("Compacting legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:8d22d9f:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:8d22d9f:         }
1:8d22d9f:     }
1:8d22d9f: 
1:e8651b6:     private static void loadLegacyTables(String legacyVersion) throws Exception
1:b6b1053:     {
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
1:b6b1053:         {
1:e8651b6:             logger.info("Preparing legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             loadLegacyTable("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             loadLegacyTable("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             loadLegacyTable("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact));
1:e8651b6:             loadLegacyTable("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:b6b1053:         }
1:2111a20:     }
1:0600d7d: 
1:e8651b6:     private static void verifyCache(String legacyVersion, long startCount) throws InterruptedException, java.util.concurrent.ExecutionException
1:2111a20:     {
1:e8651b6:         //For https://issues.apache.org/jira/browse/CASSANDRA-10778
1:e8651b6:         //Validate whether the key cache successfully saves in the presence of old keys as
1:e8651b6:         //well as loads the correct number of keys
1:e8651b6:         long endCount = CacheService.instance.keyCache.size();
1:e8651b6:         Assert.assertTrue(endCount > startCount);
1:e8651b6:         CacheService.instance.keyCache.submitWrite(Integer.MAX_VALUE).get();
1:e8651b6:         CacheService.instance.invalidateKeyCache();
1:e8651b6:         Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
1:e8651b6:         CacheService.instance.keyCache.loadSaved();
1:e8651b6:         if (BigFormat.instance.getVersion(legacyVersion).storeRows())
1:e8651b6:             Assert.assertEquals(endCount, CacheService.instance.keyCache.size());
1:e8651b6:         else
1:e8651b6:             Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
1:2111a20:     }
1:0600d7d: 
1:e8651b6:     private static void verifyReads(String legacyVersion)
1:2111a20:     {
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
2:ae37410:         {
1:0600d7d:             for (int ck = 0; ck < 50; ck++)
1:0600d7d:             {
1:0600d7d:                 String ckValue = Integer.toString(ck) + longString;
1:0600d7d:                 for (int pk = 0; pk < 5; pk++)
1:0600d7d:                 {
1:0600d7d:                     logger.debug("for pk={} ck={}", pk, ck);
1:0600d7d: 
1:0600d7d:                     String pkValue = Integer.toString(pk);
1:0600d7d:                     UntypedResultSet rs;
1:0600d7d:                     if (ck == 0)
1:0600d7d:                     {
1:e8651b6:                         readSimpleTable(legacyVersion, getCompactNameSuffix(compact),  pkValue);
1:e8651b6:                         readSimpleCounterTable(legacyVersion, getCompactNameSuffix(compact), pkValue);
1:2111a20:                     }
1:e8651b6: 
1:e8651b6:                     readClusteringTable(legacyVersion, getCompactNameSuffix(compact), ck, ckValue, pkValue);
1:e8651b6:                     readClusteringCounterTable(legacyVersion, getCompactNameSuffix(compact), ckValue, pkValue);
1:e8651b6:                 }
1:e8651b6:             }
1:e8651b6:         }
2:ae37410:     }
1:e8651b6: 
1:e8651b6:     private static void readClusteringCounterTable(String legacyVersion, String compactSuffix, String ckValue, String pkValue)
1:e8651b6:     {
1:e8651b6:         logger.debug("Read legacy_{}_clust_counter{}", legacyVersion, compactSuffix);
1:e8651b6:         UntypedResultSet rs;
1:e8651b6:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust_counter%s WHERE pk=? AND ck=?", legacyVersion, compactSuffix), pkValue, ckValue);
1:0600d7d:         Assert.assertNotNull(rs);
1:0600d7d:         Assert.assertEquals(1, rs.size());
1:0600d7d:         Assert.assertEquals(1L, rs.one().getLong("val"));
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static void readClusteringTable(String legacyVersion, String compactSuffix, int ck, String ckValue, String pkValue)
1:e8651b6:     {
1:e8651b6:         logger.debug("Read legacy_{}_clust{}", legacyVersion, compactSuffix);
1:e8651b6:         UntypedResultSet rs;
1:e8651b6:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust%s WHERE pk=? AND ck=?", legacyVersion, compactSuffix), pkValue, ckValue);
1:0600d7d:         assertLegacyClustRows(1, rs);
1:0600d7d: 
1:0600d7d:         String ckValue2 = Integer.toString(ck < 10 ? 40 : ck - 1) + longString;
1:0600d7d:         String ckValue3 = Integer.toString(ck > 39 ? 10 : ck + 1) + longString;
1:e8651b6:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust%s WHERE pk=? AND ck IN (?, ?, ?)", legacyVersion, compactSuffix), pkValue, ckValue, ckValue2, ckValue3);
1:0600d7d:         assertLegacyClustRows(3, rs);
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static void readSimpleCounterTable(String legacyVersion, String compactSuffix, String pkValue)
1:e8651b6:     {
1:e8651b6:         logger.debug("Read legacy_{}_simple_counter{}", legacyVersion, compactSuffix);
1:e8651b6:         UntypedResultSet rs;
1:e8651b6:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple_counter%s WHERE pk=?", legacyVersion, compactSuffix), pkValue);
1:0600d7d:         Assert.assertNotNull(rs);
1:0600d7d:         Assert.assertEquals(1, rs.size());
1:0600d7d:         Assert.assertEquals(1L, rs.one().getLong("val"));
1:0600d7d:     }
5:e8651b6: 
1:e8651b6:     private static void readSimpleTable(String legacyVersion, String compactSuffix, String pkValue)
1:e8651b6:     {
1:e8651b6:         logger.debug("Read simple: legacy_{}_simple{}", legacyVersion, compactSuffix);
1:e8651b6:         UntypedResultSet rs;
1:e8651b6:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple%s WHERE pk=?", legacyVersion, compactSuffix), pkValue);
1:0600d7d:         Assert.assertNotNull(rs);
1:0600d7d:         Assert.assertEquals(1, rs.size());
1:0600d7d:         Assert.assertEquals("foo bar baz", rs.one().getString("val"));
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static void createKeyspace()
1:0600d7d:     {
1:0600d7d:         QueryProcessor.executeInternal("CREATE KEYSPACE legacy_tables WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}");
1:0600d7d:     }
1:0600d7d: 
1:0600d7d:     private static void createTables(String legacyVersion)
1:0600d7d:     {
1:e8651b6:         for (int i=0; i<=1; i++)
1:e8651b6:         {
1:e8651b6:             String compactSuffix = getCompactNameSuffix(i);
1:e8651b6:             String tableSuffix = i == 0? "" : " WITH COMPACT STORAGE";
1:e8651b6:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple%s (pk text PRIMARY KEY, val text)%s", legacyVersion, compactSuffix, tableSuffix));
1:e8651b6:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple_counter%s (pk text PRIMARY KEY, val counter)%s", legacyVersion, compactSuffix, tableSuffix));
1:e8651b6:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust%s (pk text, ck text, val text, PRIMARY KEY (pk, ck))%s", legacyVersion, compactSuffix, tableSuffix));
1:e8651b6:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust_counter%s (pk text, ck text, val counter, PRIMARY KEY (pk, ck))%s", legacyVersion, compactSuffix, tableSuffix));
1:0600d7d:         }
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static String getCompactNameSuffix(int i)
1:e8651b6:     {
1:e8651b6:         return i == 0? "" : "_compact";
1:e8651b6:     }
1:0600d7d: 
1:e8651b6:     private static void truncateTables(String legacyVersion)
1:e8651b6:     {
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
1:e8651b6:         {
1:e8651b6:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact)));
1:e8651b6:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact)));
1:e8651b6:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact)));
1:e8651b6:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact)));
1:e8651b6:         }
1:e8651b6:         CacheService.instance.invalidateCounterCache();
1:e8651b6:         CacheService.instance.invalidateKeyCache();
1:e8651b6:     }
1:e8651b6: 
1:0600d7d:     private static void assertLegacyClustRows(int count, UntypedResultSet rs)
1:0600d7d:     {
1:0600d7d:         Assert.assertNotNull(rs);
1:0600d7d:         Assert.assertEquals(count, rs.size());
1:0600d7d:         for (int i = 0; i < count; i++)
1:0600d7d:         {
1:0600d7d:             for (UntypedResultSet.Row r : rs)
1:0600d7d:             {
1:0600d7d:                 Assert.assertEquals(128, r.getString("val").length());
1:0600d7d:             }
1:0600d7d:         }
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static void loadLegacyTable(String tablePattern, String legacyVersion, String compactSuffix) throws IOException
1:0600d7d:     {
1:e8651b6:         String table = String.format(tablePattern, legacyVersion, compactSuffix);
1:0600d7d: 
1:0600d7d:         logger.info("Loading legacy table {}", table);
1:0600d7d: 
1:0600d7d:         ColumnFamilyStore cfs = Keyspace.open("legacy_tables").getColumnFamilyStore(table);
1:0600d7d: 
1:0600d7d:         for (File cfDir : cfs.getDirectories().getCFDirectories())
1:0600d7d:         {
1:0600d7d:             copySstablesToTestData(legacyVersion, table, cfDir);
1:0600d7d:         }
1:0600d7d: 
1:0600d7d:         cfs.loadNewSSTables();
1:0600d7d:     }
1:0600d7d: 
1:0600d7d:     /**
1:e8651b6:      * Generates sstables for 8 CQL tables (see {@link #createTables(String)}) in <i>current</i>
1:0600d7d:      * sstable format (version) into {@code test/data/legacy-sstables/VERSION}, where
1:0600d7d:      * {@code VERSION} matches {@link Version#getVersion() BigFormat.latestVersion.getVersion()}.
1:0600d7d:      * <p>
1:0600d7d:      * Run this test alone (e.g. from your IDE) when a new version is introduced or format changed
1:0600d7d:      * during development. I.e. remove the {@code @Ignore} annotation temporarily.
1:0600d7d:      * </p>
1:0600d7d:      */
1:0600d7d:     @Ignore
1:0600d7d:     @Test
1:0600d7d:     public void testGenerateSstables() throws Throwable
1:0600d7d:     {
1:0600d7d:         Random rand = new Random();
1:0600d7d:         StringBuilder sb = new StringBuilder();
1:0600d7d:         for (int i = 0; i < 128; i++)
1:0600d7d:         {
1:0600d7d:             sb.append((char)('a' + rand.nextInt(26)));
1:0600d7d:         }
1:0600d7d:         String randomString = sb.toString();
1:0600d7d: 
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
1:0600d7d:         {
1:0600d7d:             for (int pk = 0; pk < 5; pk++)
1:e8651b6:             {
1:0600d7d:                 String valPk = Integer.toString(pk);
1:e8651b6:                 QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_simple%s (pk, val) VALUES ('%s', '%s')",
1:e8651b6:                                                              BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, "foo bar baz"));
1:0600d7d: 
1:e8651b6:                 QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_simple_counter%s SET val = val + 1 WHERE pk = '%s'",
1:e8651b6:                                                              BigFormat.latestVersion, getCompactNameSuffix(compact), valPk));
1:0600d7d: 
1:0600d7d:                 for (int ck = 0; ck < 50; ck++)
1:0600d7d:                 {
1:0600d7d:                     String valCk = Integer.toString(ck);
1:0600d7d: 
1:e8651b6:                     QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_clust%s (pk, ck, val) VALUES ('%s', '%s', '%s')",
1:e8651b6:                                                                  BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, valCk + longString, randomString));
1:0600d7d: 
1:e8651b6:                     QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_clust_counter%s SET val = val + 1 WHERE pk = '%s' AND ck='%s'",
1:e8651b6:                                                                  BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, valCk + longString));
1:0600d7d: 
1:0600d7d:                 }
1:0600d7d:             }
1:e8651b6:         }
1:0600d7d: 
1:0600d7d:         StorageService.instance.forceKeyspaceFlush("legacy_tables");
1:0600d7d: 
1:0600d7d:         File ksDir = new File(LEGACY_SSTABLE_ROOT, String.format("%s/legacy_tables", BigFormat.latestVersion));
1:0600d7d:         ksDir.mkdirs();
1:e8651b6:         for (int compact = 0; compact <= 1; compact++)
1:e8651b6:         {
1:e8651b6:             copySstablesFromTestData(String.format("legacy_%s_simple%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:e8651b6:             copySstablesFromTestData(String.format("legacy_%s_simple_counter%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:e8651b6:             copySstablesFromTestData(String.format("legacy_%s_clust%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:e8651b6:             copySstablesFromTestData(String.format("legacy_%s_clust_counter%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:0600d7d:         }
1:e8651b6:     }
1:0600d7d: 
1:0600d7d:     private void copySstablesFromTestData(String table, File ksDir) throws IOException
1:0600d7d:     {
1:0600d7d:         File cfDir = new File(ksDir, table);
1:0600d7d:         cfDir.mkdir();
1:0600d7d: 
1:0600d7d:         for (File srcDir : Keyspace.open("legacy_tables").getColumnFamilyStore(table).getDirectories().getCFDirectories())
1:0600d7d:         {
1:0600d7d:             for (File file : srcDir.listFiles())
1:0600d7d:             {
1:0600d7d:                 copyFile(cfDir, file);
1:0600d7d:             }
1:0600d7d:         }
1:0600d7d:     }
1:0600d7d: 
1:0600d7d:     private static void copySstablesToTestData(String legacyVersion, String table, File cfDir) throws IOException
1:0600d7d:     {
1:eaa0694:         File tableDir = getTableDir(legacyVersion, table);
1:eaa0694:         Assert.assertTrue("The table directory " + tableDir + " was not found", tableDir.isDirectory());
1:eaa0694:         for (File file : tableDir.listFiles())
1:0600d7d:         {
1:0600d7d:             copyFile(cfDir, file);
1:0600d7d:         }
1:0600d7d:     }
1:0600d7d: 
1:e8651b6:     private static File getTableDir(String legacyVersion, String table)
1:e8651b6:     {
1:e8651b6:         return new File(LEGACY_SSTABLE_ROOT, String.format("%s/legacy_tables/%s", legacyVersion, table));
1:e8651b6:     }
1:e8651b6: 
1:0600d7d:     private static void copyFile(File cfDir, File file) throws IOException
1:0600d7d:     {
1:0600d7d:         byte[] buf = new byte[65536];
1:0600d7d:         if (file.isFile())
1:0600d7d:         {
1:0600d7d:             File target = new File(cfDir, file.getName());
1:0600d7d:             int rd;
1:eaa0694:             try (FileInputStream is = new FileInputStream(file);
1:eaa0694:                  FileOutputStream os = new FileOutputStream(target);) {
1:eaa0694:                 while ((rd = is.read(buf)) >= 0)
1:eaa0694:                     os.write(buf, 0, rd);
1:eaa0694:                 }
1:0600d7d:         }
1:0600d7d:     }
1:e8651b6: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:624ed78
commit:7b10217
commit:78a3d2b
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.DeletionTime;
0: import org.apache.cassandra.db.rows.SliceableUnfilteredRowIterator;
0: import org.apache.cassandra.db.filter.ColumnFilter;
0: import org.apache.cassandra.db.marshal.BytesType;
1: import org.apache.cassandra.io.sstable.format.SSTableFormat;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
1: import org.apache.cassandra.io.sstable.format.Version;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         CFMetaData metadata = CFMetaData.Builder.createDense(KSNAME, CFNAME, false, false)
0:                                                 .addPartitionKey("key", BytesType.instance)
0:                                                 .addClusteringColumn("column", BytesType.instance)
0:                                                 .addRegularColumn("value", BytesType.instance)
0:                                                 .build();
1: 
0:                                     metadata);
/////////////////////////////////////////////////////////////////////////
1:         {
0:             if (Version.validate(version.getName()) && SSTableFormat.Type.LEGACY.info.getVersion(version.getName()).isCompatibleForStreaming())
1:         }
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer key = bytes(keystring);
1: 
0:             SliceableUnfilteredRowIterator iter = sstable.iterator(Util.dk(key), ColumnFilter.selectionBuilder().add(cfs.metadata.getColumnDefinition(bytes("name"))).build(), false, false);
0:             assert iter.partitionLevelDeletion().equals(DeletionTime.LIVE);
0:             assert iter.next().clustering().get(0).equals(key);
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamilyStore cfs = Keyspace.open(KSNAME).getColumnFamilyStore(CFNAME);
1: 
1: 
1: 
0:                 ByteBuffer key = bytes(keystring);
1: 
0:                 SliceableUnfilteredRowIterator iter = reader.iterator(Util.dk(key), ColumnFilter.selection(cfs.metadata.partitionColumns()), false, false);
1: 
0:                 // check not deleted (CASSANDRA-6527)
0:                 assert iter.partitionLevelDeletion().equals(DeletionTime.LIVE);
0:                 assert iter.next().clustering().get(0).equals(key);
commit:8e172c8
/////////////////////////////////////////////////////////////////////////
0:             if (Descriptor.Version.validate(version.getName()) && new Descriptor.Version(version.getName()).isCompatible())
/////////////////////////////////////////////////////////////////////////
0:             if (Descriptor.Version.validate(version.getName()) && new Descriptor.Version(version.getName()).isCompatible())
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.composites.CellNameType;
/////////////////////////////////////////////////////////////////////////
0:             CellNameType type = reader.metadata.comparator;
0:                 SSTableNamesIterator iter = new SSTableNamesIterator(reader, dk, FBUtilities.singleton(Util.cellname(key), type));
0:                 assert iter.next().name().toByteBuffer().equals(key);
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0:             if (Descriptor.Version.validate(version.getName()))
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class LegacySSTableTest extends SchemaLoader
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:                 ByteBuffer key = ByteBufferUtil.bytes(keystring);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:904cb5d
/////////////////////////////////////////////////////////////////////////
1:     public static final String[] legacyVersions = {"mc", "mb", "ma", "la", "ka", "jb"};
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner p = sstable.getPartitioner();
author:Dave Brosius
-------------------------------------------------------------------------------
commit:eaa0694
/////////////////////////////////////////////////////////////////////////
1:         String scp = System.getProperty(LEGACY_SSTABLE_PROP);
1:         Assert.assertNotNull("System property " + LEGACY_SSTABLE_ROOT + " not set", scp);
1:         
1:         LEGACY_SSTABLE_ROOT = new File(scp).getAbsoluteFile();
1:         Assert.assertTrue("System property " + LEGACY_SSTABLE_ROOT + " does not specify a directory", LEGACY_SSTABLE_ROOT.isDirectory());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         File tableDir = getTableDir(legacyVersion, table);
1:         Assert.assertTrue("The table directory " + tableDir + " was not found", tableDir.isDirectory());
1:         for (File file : tableDir.listFiles())
/////////////////////////////////////////////////////////////////////////
1:             try (FileInputStream is = new FileInputStream(file);
1:                  FileOutputStream os = new FileOutputStream(target);) {
1:                 while ((rd = is.read(buf)) >= 0)
1:                     os.write(buf, 0, rd);
1:                 }
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected Descriptor getDescriptor(String ver)
author:Robert Stupp
-------------------------------------------------------------------------------
commit:4e25524
commit:8d22d9f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.setColumnIndexCacheSize(99999);
1:         CacheService.instance.invalidateKeyCache();
1:         doTestLegacyCqlTables();
1:     }
1: 
1:     @Test
1:     public void testLoadLegacyCqlTablesShallow() throws Exception
1:     {
1:         DatabaseDescriptor.setColumnIndexCacheSize(0);
1:         CacheService.instance.invalidateKeyCache();
1:         doTestLegacyCqlTables();
1:     }
1: 
1:     private void doTestLegacyCqlTables() throws Exception
1:     {
1:             truncateLegacyTables(legacyVersion);
1:             compactLegacyTables(legacyVersion);
/////////////////////////////////////////////////////////////////////////
1:     private static void truncateLegacyTables(String legacyVersion) throws Exception
1:     {
1:         for (int compact = 0; compact <= 1; compact++)
1:         {
1:             logger.info("Truncating legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact))).truncateBlocking();
1:         }
1:     }
1: 
1:     private static void compactLegacyTables(String legacyVersion) throws Exception
1:     {
1:         for (int compact = 0; compact <= 1; compact++)
1:         {
1:             logger.info("Compacting legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:             Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact))).forceMajorCompaction();
1:         }
1:     }
1: 
commit:0600d7d
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.util.Random;
1: import org.junit.Assert;
1: import org.junit.Ignore;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.UntypedResultSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.sstable.format.big.BigFormat;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(LegacySSTableTest.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When adding a new sstable version, add that one here.
1:      * See {@link #testGenerateSstables()} to generate sstables.
1:      * Take care on commit as you need to add the sstable files using {@code git add -f}
1:      */
0:     public static final String[] legacyVersions = {"ma", "la", "ka", "jb"};
1: 
1:     // 1200 chars
1:     static final String longString = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
1:                                      "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789";
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (!new File(LEGACY_SSTABLE_ROOT + File.separator + version.getName() + File.separator + KSNAME).isDirectory())
0:                 continue;
/////////////////////////////////////////////////////////////////////////
0:             if (!new File(LEGACY_SSTABLE_ROOT + File.separator + version.getName() + File.separator + KSNAME).isDirectory())
0:                 continue;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testLegacyCqlTables() throws Exception
1:     {
1:         createKeyspace();
1: 
0:         loadLegacyTables();
1:     }
1: 
0:     private static void loadLegacyTables() throws IOException
1:     {
1:         for (String legacyVersion : legacyVersions)
1:         {
0:             logger.info("Preparing legacy version {}", legacyVersion);
1: 
1:             createTables(legacyVersion);
1: 
0:             loadLegacyTable("legacy_%s_simple", legacyVersion);
0:             loadLegacyTable("legacy_%s_simple_counter", legacyVersion);
0:             loadLegacyTable("legacy_%s_clust", legacyVersion);
0:             loadLegacyTable("legacy_%s_clust_counter", legacyVersion);
1: 
1:             for (int ck = 0; ck < 50; ck++)
1:             {
1:                 String ckValue = Integer.toString(ck) + longString;
1:                 for (int pk = 0; pk < 5; pk++)
1:                 {
1:                     logger.debug("for pk={} ck={}", pk, ck);
1: 
1:                     String pkValue = Integer.toString(pk);
1:                     UntypedResultSet rs;
1:                     if (ck == 0)
1:                     {
0:                         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple WHERE pk=?", legacyVersion), pkValue);
1:                         Assert.assertNotNull(rs);
1:                         Assert.assertEquals(1, rs.size());
1:                         Assert.assertEquals("foo bar baz", rs.one().getString("val"));
0:                         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple_counter WHERE pk=?", legacyVersion), pkValue);
1:                         Assert.assertNotNull(rs);
1:                         Assert.assertEquals(1, rs.size());
1:                         Assert.assertEquals(1L, rs.one().getLong("val"));
1:                     }
1: 
0:                     rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust WHERE pk=? AND ck=?", legacyVersion), pkValue, ckValue);
1:                     assertLegacyClustRows(1, rs);
1: 
1:                     String ckValue2 = Integer.toString(ck < 10 ? 40 : ck - 1) + longString;
1:                     String ckValue3 = Integer.toString(ck > 39 ? 10 : ck + 1) + longString;
0:                     rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust WHERE pk=? AND ck IN (?, ?, ?)", legacyVersion), pkValue, ckValue, ckValue2, ckValue3);
1:                     assertLegacyClustRows(3, rs);
1: 
0:                     rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust_counter WHERE pk=? AND ck=?", legacyVersion), pkValue, ckValue);
1:                     Assert.assertNotNull(rs);
1:                     Assert.assertEquals(1, rs.size());
1:                     Assert.assertEquals(1L, rs.one().getLong("val"));
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private void createKeyspace()
1:     {
1:         QueryProcessor.executeInternal("CREATE KEYSPACE legacy_tables WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}");
1:     }
1: 
1:     private static void createTables(String legacyVersion)
1:     {
0:         QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple (pk text PRIMARY KEY, val text)", legacyVersion));
0:         QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple_counter (pk text PRIMARY KEY, val counter)", legacyVersion));
0:         QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust (pk text, ck text, val text, PRIMARY KEY (pk, ck))", legacyVersion));
0:         QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust_counter (pk text, ck text, val counter, PRIMARY KEY (pk, ck))", legacyVersion));
1:     }
1: 
1:     private static void assertLegacyClustRows(int count, UntypedResultSet rs)
1:     {
1:         Assert.assertNotNull(rs);
1:         Assert.assertEquals(count, rs.size());
1:         for (int i = 0; i < count; i++)
1:         {
1:             for (UntypedResultSet.Row r : rs)
1:             {
1:                 Assert.assertEquals(128, r.getString("val").length());
1:             }
1:         }
1:     }
1: 
0:     private static void loadLegacyTable(String tablePattern, String legacyVersion) throws IOException
1:     {
0:         String table = String.format(tablePattern, legacyVersion);
1: 
1:         logger.info("Loading legacy table {}", table);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open("legacy_tables").getColumnFamilyStore(table);
1: 
1:         for (File cfDir : cfs.getDirectories().getCFDirectories())
1:         {
1:             copySstablesToTestData(legacyVersion, table, cfDir);
1:         }
1: 
1:         cfs.loadNewSSTables();
1:     }
1: 
1:     /**
0:      * Generates sstables for 4 CQL tables (see {@link #createTables(String)}) in <i>current</i>
1:      * sstable format (version) into {@code test/data/legacy-sstables/VERSION}, where
1:      * {@code VERSION} matches {@link Version#getVersion() BigFormat.latestVersion.getVersion()}.
1:      * <p>
1:      * Run this test alone (e.g. from your IDE) when a new version is introduced or format changed
1:      * during development. I.e. remove the {@code @Ignore} annotation temporarily.
1:      * </p>
1:      */
1:     @Test
1:     @Ignore
1:     public void testGenerateSstables() throws Throwable
1:     {
1:         createKeyspace();
0:         createTables(BigFormat.latestVersion.getVersion());
1: 
1:         Random rand = new Random();
1:         StringBuilder sb = new StringBuilder();
1:         for (int i = 0; i < 128; i++)
1:         {
1:             sb.append((char)('a' + rand.nextInt(26)));
1:         }
1:         String randomString = sb.toString();
1: 
1:         for (int pk = 0; pk < 5; pk++)
1:         {
1:             String valPk = Integer.toString(pk);
0:             QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_simple (pk, val) VALUES ('%s', '%s')",
0:                                                          BigFormat.latestVersion, valPk, "foo bar baz"));
1: 
0:             QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_simple_counter SET val = val + 1 WHERE pk = '%s'",
0:                                                          BigFormat.latestVersion, valPk));
1: 
1:             for (int ck = 0; ck < 50; ck++)
1:             {
1:                 String valCk = Integer.toString(ck);
1: 
0:                 QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_clust (pk, ck, val) VALUES ('%s', '%s', '%s')",
0:                                                              BigFormat.latestVersion, valPk, valCk + longString, randomString));
1: 
0:                 QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_clust_counter SET val = val + 1 WHERE pk = '%s' AND ck='%s'",
0:                                                              BigFormat.latestVersion, valPk, valCk + longString));
1: 
1:             }
1:         }
1: 
1:         StorageService.instance.forceKeyspaceFlush("legacy_tables");
1: 
1:         File ksDir = new File(LEGACY_SSTABLE_ROOT, String.format("%s/legacy_tables", BigFormat.latestVersion));
1:         ksDir.mkdirs();
0:         copySstablesFromTestData(String.format("legacy_%s_simple", BigFormat.latestVersion), ksDir);
0:         copySstablesFromTestData(String.format("legacy_%s_simple_counter", BigFormat.latestVersion), ksDir);
0:         copySstablesFromTestData(String.format("legacy_%s_clust", BigFormat.latestVersion), ksDir);
0:         copySstablesFromTestData(String.format("legacy_%s_clust_counter", BigFormat.latestVersion), ksDir);
1:     }
1: 
1:     private void copySstablesFromTestData(String table, File ksDir) throws IOException
1:     {
1:         File cfDir = new File(ksDir, table);
1:         cfDir.mkdir();
1: 
1:         for (File srcDir : Keyspace.open("legacy_tables").getColumnFamilyStore(table).getDirectories().getCFDirectories())
1:         {
1:             for (File file : srcDir.listFiles())
1:             {
1:                 copyFile(cfDir, file);
1:             }
1:         }
1:     }
1: 
1:     private static void copySstablesToTestData(String legacyVersion, String table, File cfDir) throws IOException
1:     {
0:         for (File file : new File(LEGACY_SSTABLE_ROOT, String.format("%s/legacy_tables/%s", legacyVersion, table)).listFiles())
1:         {
1:             copyFile(cfDir, file);
1:         }
1:     }
1: 
1:     private static void copyFile(File cfDir, File file) throws IOException
1:     {
1:         byte[] buf = new byte[65536];
1:         if (file.isFile())
1:         {
1:             File target = new File(cfDir, file.getName());
1:             int rd;
0:             FileInputStream is = new FileInputStream(file);
0:             FileOutputStream os = new FileOutputStream(target);
0:             while ((rd = is.read(buf)) >= 0)
0:                 os.write(buf, 0, rd);
1:         }
1:     }
author:Paulo Motta
-------------------------------------------------------------------------------
commit:e8651b6
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
0: import org.junit.Before;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         StorageService.instance.initServer();
0:         createKeyspace();
1:         for (String legacyVersion : legacyVersions)
1:         {
0:             createTables(legacyVersion);
1:         }
1:     }
1:     @After
1:     public void tearDown()
1:     {
1:         for (String legacyVersion : legacyVersions)
1:         {
1:             truncateTables(legacyVersion);
1:         }
1:     protected Descriptor getDescriptor(String legacyVersion, String table)
1:         return new Descriptor(legacyVersion, getTableDir(legacyVersion, table), "legacy_tables", table, 1,
1:                               BigFormat.instance.getVersion(legacyVersion).hasNewFileName()?
1:                               SSTableFormat.Type.BIG :SSTableFormat.Type.LEGACY);
1:     public void testLoadLegacyCqlTables() throws Exception
1:         for (String legacyVersion : legacyVersions)
1:             logger.info("Loading legacy version: {}", legacyVersion);
1:             loadLegacyTables(legacyVersion);
1:             CacheService.instance.invalidateKeyCache();
1:             long startCount = CacheService.instance.keyCache.size();
1:             verifyReads(legacyVersion);
1:             verifyCache(legacyVersion, startCount);
1:     @Test
1:     public void testStreamLegacyCqlTables() throws Exception
1:         for (String legacyVersion : legacyVersions)
1:         {
1:             streamLegacyTables(legacyVersion);
1:             verifyReads(legacyVersion);
1:         }
1:     }
1: 
1:     private void streamLegacyTables(String legacyVersion) throws Exception
1:     {
1:         for (int compact = 0; compact <= 1; compact++)
1:         {
1:             logger.info("Streaming legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:             streamLegacyTable("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact));
1:             streamLegacyTable("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:             streamLegacyTable("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact));
1:             streamLegacyTable("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:         }
1:     }
1: 
1:     private void streamLegacyTable(String tablePattern, String legacyVersion, String compactNameSuffix) throws Exception
1:     {
1:         String table = String.format(tablePattern, legacyVersion, compactNameSuffix);
1:         SSTableReader sstable = SSTableReader.open(getDescriptor(legacyVersion, table));
/////////////////////////////////////////////////////////////////////////
1:     private static void loadLegacyTables(String legacyVersion) throws Exception
1:         for (int compact = 0; compact <= 1; compact++)
1:             logger.info("Preparing legacy version {}{}", legacyVersion, getCompactNameSuffix(compact));
1:             loadLegacyTable("legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact));
1:             loadLegacyTable("legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:             loadLegacyTable("legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact));
1:             loadLegacyTable("legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact));
1:     private static void verifyCache(String legacyVersion, long startCount) throws InterruptedException, java.util.concurrent.ExecutionException
1:         //For https://issues.apache.org/jira/browse/CASSANDRA-10778
1:         //Validate whether the key cache successfully saves in the presence of old keys as
1:         //well as loads the correct number of keys
1:         long endCount = CacheService.instance.keyCache.size();
1:         Assert.assertTrue(endCount > startCount);
1:         CacheService.instance.keyCache.submitWrite(Integer.MAX_VALUE).get();
1:         CacheService.instance.invalidateKeyCache();
1:         Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
1:         CacheService.instance.keyCache.loadSaved();
1:         if (BigFormat.instance.getVersion(legacyVersion).storeRows())
1:             Assert.assertEquals(endCount, CacheService.instance.keyCache.size());
1:         else
1:             Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
1:     private static void verifyReads(String legacyVersion)
1:         for (int compact = 0; compact <= 1; compact++)
/////////////////////////////////////////////////////////////////////////
1:                         readSimpleTable(legacyVersion, getCompactNameSuffix(compact),  pkValue);
1:                         readSimpleCounterTable(legacyVersion, getCompactNameSuffix(compact), pkValue);
1:                     readClusteringTable(legacyVersion, getCompactNameSuffix(compact), ck, ckValue, pkValue);
1:                     readClusteringCounterTable(legacyVersion, getCompactNameSuffix(compact), ckValue, pkValue);
1:     private static void readClusteringCounterTable(String legacyVersion, String compactSuffix, String ckValue, String pkValue)
1:     {
1:         logger.debug("Read legacy_{}_clust_counter{}", legacyVersion, compactSuffix);
1:         UntypedResultSet rs;
1:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust_counter%s WHERE pk=? AND ck=?", legacyVersion, compactSuffix), pkValue, ckValue);
0:         Assert.assertNotNull(rs);
0:         Assert.assertEquals(1, rs.size());
0:         Assert.assertEquals(1L, rs.one().getLong("val"));
1:     }
1: 
1:     private static void readClusteringTable(String legacyVersion, String compactSuffix, int ck, String ckValue, String pkValue)
1:     {
1:         logger.debug("Read legacy_{}_clust{}", legacyVersion, compactSuffix);
1:         UntypedResultSet rs;
1:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust%s WHERE pk=? AND ck=?", legacyVersion, compactSuffix), pkValue, ckValue);
0:         assertLegacyClustRows(1, rs);
1: 
0:         String ckValue2 = Integer.toString(ck < 10 ? 40 : ck - 1) + longString;
0:         String ckValue3 = Integer.toString(ck > 39 ? 10 : ck + 1) + longString;
1:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_clust%s WHERE pk=? AND ck IN (?, ?, ?)", legacyVersion, compactSuffix), pkValue, ckValue, ckValue2, ckValue3);
0:         assertLegacyClustRows(3, rs);
1:     }
1: 
1:     private static void readSimpleCounterTable(String legacyVersion, String compactSuffix, String pkValue)
1:     {
1:         logger.debug("Read legacy_{}_simple_counter{}", legacyVersion, compactSuffix);
1:         UntypedResultSet rs;
1:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple_counter%s WHERE pk=?", legacyVersion, compactSuffix), pkValue);
0:         Assert.assertNotNull(rs);
0:         Assert.assertEquals(1, rs.size());
0:         Assert.assertEquals(1L, rs.one().getLong("val"));
1:     }
1: 
1:     private static void readSimpleTable(String legacyVersion, String compactSuffix, String pkValue)
1:     {
1:         logger.debug("Read simple: legacy_{}_simple{}", legacyVersion, compactSuffix);
1:         UntypedResultSet rs;
1:         rs = QueryProcessor.executeInternal(String.format("SELECT val FROM legacy_tables.legacy_%s_simple%s WHERE pk=?", legacyVersion, compactSuffix), pkValue);
0:         Assert.assertNotNull(rs);
0:         Assert.assertEquals(1, rs.size());
0:         Assert.assertEquals("foo bar baz", rs.one().getString("val"));
1:     }
1: 
1:     private static void createKeyspace()
1:         for (int i=0; i<=1; i++)
1:         {
1:             String compactSuffix = getCompactNameSuffix(i);
1:             String tableSuffix = i == 0? "" : " WITH COMPACT STORAGE";
1:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple%s (pk text PRIMARY KEY, val text)%s", legacyVersion, compactSuffix, tableSuffix));
1:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_simple_counter%s (pk text PRIMARY KEY, val counter)%s", legacyVersion, compactSuffix, tableSuffix));
1:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust%s (pk text, ck text, val text, PRIMARY KEY (pk, ck))%s", legacyVersion, compactSuffix, tableSuffix));
1:             QueryProcessor.executeInternal(String.format("CREATE TABLE legacy_tables.legacy_%s_clust_counter%s (pk text, ck text, val counter, PRIMARY KEY (pk, ck))%s", legacyVersion, compactSuffix, tableSuffix));
1:         }
1:     }
1: 
1:     private static String getCompactNameSuffix(int i)
1:     {
1:         return i == 0? "" : "_compact";
1:     }
1: 
1:     private static void truncateTables(String legacyVersion)
1:     {
1:         for (int compact = 0; compact <= 1; compact++)
1:         {
1:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_simple%s", legacyVersion, getCompactNameSuffix(compact)));
1:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_simple_counter%s", legacyVersion, getCompactNameSuffix(compact)));
1:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_clust%s", legacyVersion, getCompactNameSuffix(compact)));
1:             QueryProcessor.executeInternal(String.format("TRUNCATE legacy_tables.legacy_%s_clust_counter%s", legacyVersion, getCompactNameSuffix(compact)));
1:         }
1:         CacheService.instance.invalidateCounterCache();
1:         CacheService.instance.invalidateKeyCache();
/////////////////////////////////////////////////////////////////////////
1:     private static void loadLegacyTable(String tablePattern, String legacyVersion, String compactSuffix) throws IOException
1:         String table = String.format(tablePattern, legacyVersion, compactSuffix);
/////////////////////////////////////////////////////////////////////////
1:      * Generates sstables for 8 CQL tables (see {@link #createTables(String)}) in <i>current</i>
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
1:         for (int compact = 0; compact <= 1; compact++)
0:             for (int pk = 0; pk < 5; pk++)
0:                 String valPk = Integer.toString(pk);
1:                 QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_simple%s (pk, val) VALUES ('%s', '%s')",
1:                                                              BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, "foo bar baz"));
1:                 QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_simple_counter%s SET val = val + 1 WHERE pk = '%s'",
1:                                                              BigFormat.latestVersion, getCompactNameSuffix(compact), valPk));
0:                 for (int ck = 0; ck < 50; ck++)
1:                 {
0:                     String valCk = Integer.toString(ck);
1:                     QueryProcessor.executeInternal(String.format("INSERT INTO legacy_tables.legacy_%s_clust%s (pk, ck, val) VALUES ('%s', '%s', '%s')",
1:                                                                  BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, valCk + longString, randomString));
0: 
1:                     QueryProcessor.executeInternal(String.format("UPDATE legacy_tables.legacy_%s_clust_counter%s SET val = val + 1 WHERE pk = '%s' AND ck='%s'",
1:                                                                  BigFormat.latestVersion, getCompactNameSuffix(compact), valPk, valCk + longString));
0: 
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         for (int compact = 0; compact <= 1; compact++)
1:         {
1:             copySstablesFromTestData(String.format("legacy_%s_simple%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:             copySstablesFromTestData(String.format("legacy_%s_simple_counter%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:             copySstablesFromTestData(String.format("legacy_%s_clust%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:             copySstablesFromTestData(String.format("legacy_%s_clust_counter%s", BigFormat.latestVersion, getCompactNameSuffix(compact)), ksDir);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         for (File file : getTableDir(legacyVersion, table).listFiles())
1:     private static File getTableDir(String legacyVersion, String table)
1:     {
1:         return new File(LEGACY_SSTABLE_ROOT, String.format("%s/legacy_tables/%s", legacyVersion, table));
1:     }
0: 
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:4378b58
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.service.CacheService;
/////////////////////////////////////////////////////////////////////////
0:     private static void loadLegacyTables() throws Exception
/////////////////////////////////////////////////////////////////////////
0:             CacheService.instance.invalidateKeyCache();
0:             long startCount = CacheService.instance.keyCache.size();
/////////////////////////////////////////////////////////////////////////
0: 
0:             //For https://issues.apache.org/jira/browse/CASSANDRA-10778
0:             //Validate whether the key cache successfully saves in the presence of old keys as
0:             //well as loads the correct number of keys
0:             long endCount = CacheService.instance.keyCache.size();
0:             Assert.assertTrue(endCount > startCount);
0:             CacheService.instance.keyCache.submitWrite(Integer.MAX_VALUE).get();
0:             CacheService.instance.invalidateKeyCache();
0:             Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
0:             CacheService.instance.keyCache.loadSaved();
0:             if (BigFormat.instance.getVersion(legacyVersion).storeRows())
0:                 Assert.assertEquals(endCount, CacheService.instance.keyCache.size());
0:             else
0:                 Assert.assertEquals(startCount, CacheService.instance.keyCache.size());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = sstable.getPartitioner();
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
0:                                     KeyspaceParams.simple(1),
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = StorageService.getPartitioner();
commit:5ab1a34
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.HashSet;
1: import java.util.List;
0: import java.util.Set;
0: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
0: import org.apache.cassandra.db.ColumnFamily;
1: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.DeletionInfo;
1: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.setInitialized();
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
1:  * Tests backwards compatibility for SSTables
/////////////////////////////////////////////////////////////////////////
0: 
0:             // TODO actually test some reads
commit:49ec3e8
/////////////////////////////////////////////////////////////////////////
0:         Descriptor dest = getDescriptor(Descriptor.Version.current_version);
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import org.junit.BeforeClass;
0: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
0:     public static Map<ByteBuffer, ByteBuffer> TEST_DATA;
/////////////////////////////////////////////////////////////////////////
0:         TEST_DATA = new HashMap<ByteBuffer,ByteBuffer>();
0:             TEST_DATA.put(ByteBuffer.wrap(Integer.toString(i).getBytes()), ByteBuffer.wrap(("Avinash Lakshman is a good man: " + i).getBytes()));
/////////////////////////////////////////////////////////////////////////
0:             List<ByteBuffer> keys = new ArrayList<ByteBuffer>(TEST_DATA.keySet());
0:             for (ByteBuffer key : keys)
0:                 assert key.equals( FBUtilities.readShortByteArray(file));
commit:b6b1053
/////////////////////////////////////////////////////////////////////////
0:         LEGACY_SSTABLE_ROOT = new File(scp).getAbsoluteFile();
/////////////////////////////////////////////////////////////////////////
0:         Descriptor dest = getDescriptor(Descriptor.CURRENT_VERSION);
/////////////////////////////////////////////////////////////////////////
0:     public void testVersions() throws IOException
0:         for (File version : LEGACY_SSTABLE_ROOT.listFiles())
0:             testVersion(version.getName());
1:     }
0:     public void testVersion(String version)
1:     {
0:         try
0:             SSTableReader reader = SSTableReader.open(getDescriptor(version));
0: 
0:             List<byte[]> keys = new ArrayList<byte[]>(TEST_DATA.keySet());
0:             Collections.shuffle(keys);
0:             BufferedRandomAccessFile file = new BufferedRandomAccessFile(reader.getFilename(), "r");
0:             for (byte[] key : keys)
1:             {
0:                 // confirm that the bloom filter does not reject any keys
0:                 file.seek(reader.getPosition(reader.partitioner.decorateKey(key), SSTableReader.Operator.EQ));
0:                 assert Arrays.equals(key, FBUtilities.readShortByteArray(file));
1:             }
1:         }
0:         catch (Throwable e)
1:         {
0:             System.err.println("Failed to read " + version);
0:             e.printStackTrace(System.err);
commit:aadfa6a
/////////////////////////////////////////////////////////////////////////
0:             file.seek(reader.getPosition(reader.partitioner.decorateKey(key), SSTableReader.Operator.EQ));
commit:1067d37
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected Descriptor getDescriptor(String ver) throws IOException
0:         return new Descriptor(ver, directory, KSNAME, CFNAME, 0, false);
commit:f0a3969
/////////////////////////////////////////////////////////////////////////
0:             file.seek(reader.getPosition(reader.partitioner.decorateKey(key)));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
0:         assert cfs.getLiveSSTables().size() == 1;
0:         sstable = cfs.getLiveSSTables().iterator().next();
commit:02c3489
commit:61384c5
/////////////////////////////////////////////////////////////////////////
0:         details.add(new StreamSession.SSTableStreamingSections(sstable, sstable.ref(),
/////////////////////////////////////////////////////////////////////////
0:         sstable.selfRef().release();
commit:9c4a776
commit:c75ee41
/////////////////////////////////////////////////////////////////////////
0:         details.add(new StreamSession.SSTableStreamingSections(sstable, sstable.tryRef(),
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:b09e60f
/////////////////////////////////////////////////////////////////////////
0:         return new Descriptor(ver, directory, KSNAME, CFNAME, 0, SSTableFormat.Type.LEGACY);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:9ba900d
commit:9f7ab09
/////////////////////////////////////////////////////////////////////////
1:         details.add(new StreamSession.SSTableStreamingSections(sstable.ref(),
commit:67f9eba
commit:2111a20
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.streaming.StreamPlan;
1: import org.apache.cassandra.streaming.StreamSession;
/////////////////////////////////////////////////////////////////////////
0:     public void testStreaming() throws Throwable
1:     {
0:         StorageService.instance.initServer();
0: 
0:         for (File version : LEGACY_SSTABLE_ROOT.listFiles())
0:             if (Descriptor.Version.validate(version.getName()))
0:                 testStreaming(version.getName());
1:     }
0: 
0:     private void testStreaming(String version) throws Exception
1:     {
0:         SSTableReader sstable = SSTableReader.open(getDescriptor(version));
0:         IPartitioner p = StorageService.getPartitioner();
1:         List<Range<Token>> ranges = new ArrayList<>();
1:         ranges.add(new Range<>(p.getMinimumToken(), p.getToken(ByteBufferUtil.bytes("100"))));
1:         ranges.add(new Range<>(p.getToken(ByteBufferUtil.bytes("100")), p.getMinimumToken()));
1:         ArrayList<StreamSession.SSTableStreamingSections> details = new ArrayList<>();
0:         details.add(new StreamSession.SSTableStreamingSections(sstable,
1:                                                                sstable.getPositionsForRanges(ranges),
0:                                                                sstable.estimatedKeysForRanges(ranges)));
1:         new StreamPlan("LegacyStreamingTest").transferFiles(FBUtilities.getBroadcastAddress(), details)
1:                                              .execute().get();
0:         sstable.close();
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(KSNAME).getColumnFamilyStore(CFNAME);
0:         assert cfs.getSSTables().size() == 1;
0:         sstable = cfs.getSSTables().iterator().next();
0:         for (String keystring : TEST_DATA)
1:         {
0:             ByteBuffer key = ByteBufferUtil.bytes(keystring);
0:             SSTableNamesIterator iter = new SSTableNamesIterator(sstable, Util.dk(key), FBUtilities.singleton(key));
0:             ColumnFamily cf = iter.getColumnFamily();
0: 
0:             // check not deleted (CASSANDRA-6527)
0:             assert cf.deletionInfo().equals(DeletionInfo.live());
0:             assert iter.next().name().equals(key);
1:         }
1:     }
0: 
0:     @Test
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
0: import org.apache.cassandra.io.sstable.format.SSTableFormat;
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.io.sstable.format.Version;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new Descriptor(ver, directory, KSNAME, CFNAME, 0, Descriptor.Type.FINAL, SSTableFormat.Type.LEGACY);
/////////////////////////////////////////////////////////////////////////
0:             if (Version.validate(version.getName()) && SSTableFormat.Type.LEGACY.info.getVersion(version.getName()).isCompatible())
/////////////////////////////////////////////////////////////////////////
0:             OnDiskAtomIterator iter = sstable.iterator(Util.dk(key), FBUtilities.singleton(Util.cellname(key), type));
/////////////////////////////////////////////////////////////////////////
0:             if (Version.validate(version.getName()) && SSTableFormat.Type.LEGACY.info.getVersion(version.getName()).isCompatible())
/////////////////////////////////////////////////////////////////////////
0:                 OnDiskAtomIterator iter = reader.iterator(dk, FBUtilities.singleton(Util.cellname(key), type));
commit:e2bb7d2
/////////////////////////////////////////////////////////////////////////
0:     public static final String KSNAME = "Keyspace1";
commit:2500951
commit:ae37410
/////////////////////////////////////////////////////////////////////////
0:         boolean notSkipped = false;
0: 
1:         {
1:             {
0:                 notSkipped = true;
1:             }
1:         }
0: 
0:         assert notSkipped;
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
1: public class LegacySSTableTest
0:     public static final String KSNAME = "LegacySSTableTest";
1:     public static void defineSchema() throws ConfigurationException
0:     {
1:         SchemaLoader.prepareServer();
0:         SchemaLoader.createKeyspace(KSNAME,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KSNAME, CFNAME));
0:         beforeClass();
0:     }
0: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:4e95953
/////////////////////////////////////////////////////////////////////////
0:         return new Descriptor(ver, directory, KSNAME, CFNAME, 0, Descriptor.Type.FINAL);
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:a7b7214
/////////////////////////////////////////////////////////////////////////
1:                                                                sstable.estimatedKeysForRanges(ranges), sstable.getSSTableMetadata().repairedAt));
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:718b65e
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.columniterator.SSTableNamesIterator;
/////////////////////////////////////////////////////////////////////////
0:     public static Set<String> TEST_DATA;
/////////////////////////////////////////////////////////////////////////
0:         TEST_DATA = new HashSet<String>();
0:             TEST_DATA.add(Integer.toString(i));
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader ssTable = SSTableUtils.prepare().ks(KSNAME).cf(CFNAME).dest(dest).write(TEST_DATA);
0:         assert ssTable.descriptor.generation == 0 :
0:     public void testVersions() throws Throwable
0:     public void testVersion(String version) throws Throwable
0:             for (String keystring : TEST_DATA)
0:                 ByteBuffer key = ByteBuffer.wrap(keystring.getBytes());
0:                 // confirm that the bloom filter does not reject any keys/names
0:                 DecoratedKey dk = reader.partitioner.decorateKey(key);
0:                 SSTableNamesIterator iter = new SSTableNamesIterator(reader, dk, FBUtilities.singleton(key));
0:                 assert iter.next().name().equals(key);
0:             throw e;
commit:529aa2e
/////////////////////////////////////////////////////////////////////////
0:             if (Descriptor.versionValidate(version.getName()))
0:                 testVersion(version.getName());
commit:434564d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:     public static Map<byte[], byte[]> TEST_DATA;
/////////////////////////////////////////////////////////////////////////
0:         TEST_DATA = new HashMap<byte[],byte[]>();
0:         for (int i = 100; i < 1000; ++i)
0:             TEST_DATA.put(Integer.toString(i).getBytes(), ("Avinash Lakshman is a good man: " + i).getBytes());
/////////////////////////////////////////////////////////////////////////
0:         List<byte[]> keys = new ArrayList<byte[]>(TEST_DATA.keySet());
0:         for (byte[] key : keys)
0:             assert Arrays.equals(key, FBUtilities.readShortByteArray(file));
commit:12eb057
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
0: 
1: package org.apache.cassandra.io.sstable;
0: 
1: import java.io.File;
0: import java.io.IOException;
0: import java.util.*;
0: 
0: import org.junit.BeforeClass;
0: import org.junit.Test;
0: import static org.junit.Assert.*;
0: 
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.io.util.BufferedRandomAccessFile;
0: import org.apache.cassandra.db.DecoratedKey;
0: 
0: import com.google.common.base.Predicate;
0: import com.google.common.base.Predicates;
0: 
1: /**
0:  * Tests backwards compatibility for SSTables. Requires that older SSTables match up with the existing config file,
0:  * and currently only tests specific cases for specific upgrades.
1:  */
0: public class LegacySSTableTest extends CleanupHelper
0: {
1:     public static final String LEGACY_SSTABLE_PROP = "legacy-sstable-root";
0:     public static final String KSNAME = "Keyspace1";
0:     public static final String CFNAME = "Standard1";
0: 
0:     public static SortedMap<String, byte[]> TEST_DATA;
1:     public static File LEGACY_SSTABLE_ROOT;
0: 
1:     @BeforeClass
0:     public static void beforeClass()
0:     {
0:         String scp = System.getProperty(LEGACY_SSTABLE_PROP);
0:         assert scp != null;
0:         LEGACY_SSTABLE_ROOT = new File(scp);
0:         assert LEGACY_SSTABLE_ROOT.isDirectory();
0: 
0:         TEST_DATA = new TreeMap<String,byte[]>();
0:         for ( int i = 100; i < 1000; ++i )
0:         {
0:             TEST_DATA.put(Integer.toString(i), ("Avinash Lakshman is a good man: " + i).getBytes());
0:         }
0:     }
0: 
1:     /**
1:      * Get a descriptor for the legacy sstable at the given version.
1:      */
0:     protected SSTable.Descriptor getDescriptor(String ver) throws IOException
0:     {
0:         File directory = new File(LEGACY_SSTABLE_ROOT + File.separator + ver + File.separator + KSNAME);
0:         return new SSTable.Descriptor(ver, directory, KSNAME, CFNAME, 0, false);
0:     }
0: 
1:     /**
0:      * Generates a test SSTable for use in this classes' tests. Uncomment and run against an older build
0:      * and the output will be copied to a version subdirectory in 'LEGACY_SSTABLE_ROOT'
0:      *
0:     @Test
0:     public void buildTestSSTable() throws IOException
0:     {
0:         // write the output in a version specific directory
0:         SSTable.Descriptor dest = getDescriptor(SSTable.Descriptor.CURRENT_VERSION);
0:         assert dest.directory.mkdirs() : "Could not create " + dest.directory + ". Might it already exist?";
0: 
0:         SSTableReader ssTable = SSTableUtils.writeRawSSTable(new File(dest.filenameFor(SSTable.COMPONENT_DATA)),
0:                                                              KSNAME,
0:                                                              CFNAME,
0:                                                              TEST_DATA);
0:         assert ssTable.desc.generation == 0 :
0:             "In order to create a generation 0 sstable, please run this test alone.";
0:         System.out.println(">>> Wrote " + dest);
0:     }
1:     */
0: 
1:     /**
0:      * Between version b and c, on disk bloom filters became incompatible, and needed to be regenerated.
1:      */
0:     @Test
0:     public void testVerB() throws IOException
0:     {
0:         SSTableReader reader = SSTableReader.open(getDescriptor("b"));
0: 
0:         List<String> keys = new ArrayList<String>(TEST_DATA.keySet());
0:         Collections.shuffle(keys);
0:         BufferedRandomAccessFile file = new BufferedRandomAccessFile(reader.getFilename(), "r");
0:         for (String key : keys)
0:         {
0:             // confirm that the bloom filter does not reject any keys
0:             file.seek(reader.getPosition(reader.partitioner.decorateKey(key)).position);
0:             assert key.equals(file.readUTF());
0:         }
0:     }
0: }
============================================================================