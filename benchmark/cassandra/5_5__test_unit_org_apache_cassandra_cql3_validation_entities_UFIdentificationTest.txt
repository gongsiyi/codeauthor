1:cb5897f: /*
1:cb5897f:  * Licensed to the Apache Software Foundation (ASF) under one
1:cb5897f:  * or more contributor license agreements.  See the NOTICE file
1:cb5897f:  * distributed with this work for additional information
1:cb5897f:  * regarding copyright ownership.  The ASF licenses this file
1:cb5897f:  * to you under the Apache License, Version 2.0 (the
1:cb5897f:  * "License"); you may not use this file except in compliance
1:cb5897f:  * with the License.  You may obtain a copy of the License at
1:cb5897f:  *
1:cb5897f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:cb5897f:  *
1:cb5897f:  * Unless required by applicable law or agreed to in writing, software
1:cb5897f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cb5897f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cb5897f:  * See the License for the specific language governing permissions and
1:cb5897f:  * limitations under the License.
1:cb5897f:  */
1:01115f7: package org.apache.cassandra.cql3.validation.entities;
1:cb5897f: 
1:cb5897f: import java.util.*;
1:cb5897f: 
1:cb5897f: import com.google.common.base.Joiner;
1:cb5897f: import com.google.common.collect.Iterables;
1:cb5897f: import org.junit.Before;
1:cb5897f: import org.junit.Ignore;
1:cb5897f: import org.junit.Test;
1:cb5897f: 
1:01115f7: import org.apache.cassandra.cql3.Attributes;
1:01115f7: import org.apache.cassandra.cql3.CQLStatement;
1:01115f7: import org.apache.cassandra.cql3.QueryProcessor;
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:cb5897f: import org.apache.cassandra.cql3.statements.BatchStatement;
1:cb5897f: import org.apache.cassandra.cql3.statements.ModificationStatement;
1:01115f7: import org.apache.cassandra.cql3.CQLTester;
1:cb5897f: import org.apache.cassandra.service.ClientState;
1:cb5897f: 
1:cb5897f: import static org.junit.Assert.assertTrue;
1:cb5897f: 
1:cb5897f: /**
1:cb5897f:  * Checks the collection of Function objects returned by CQLStatement.getFunction
1:cb5897f:  * matches expectations. This is intended to verify the various subcomponents of
1:cb5897f:  * the statement (Operations, Terms, Restrictions, RestrictionSet, Selection,
1:cb5897f:  * Selector, SelectorFactories etc) properly report any constituent functions.
1:cb5897f:  * Some purely terminal functions are resolved at preparation, so those are not
1:cb5897f:  * included in the reported list. They still need to be surveyed, to verify the
1:cb5897f:  * calling client has the necessary permissions. UFAuthTest includes tests which
1:cb5897f:  * verify this more thoroughly than we can here.
1:cb5897f:  */
1:cb5897f: public class UFIdentificationTest extends CQLTester
1:cb5897f: {
1:cb5897f:     private com.google.common.base.Function<Function, String> toFunctionNames = new com.google.common.base.Function<Function, String>()
1:cb5897f:     {
1:cb5897f:         public String apply(Function f)
1:cb5897f:         {
1:cb5897f:             return f.name().keyspace + "." + f.name().name;
1:cb5897f:         }
1:cb5897f:     };
1:cb5897f: 
1:cb5897f:     String tFunc;
1:cb5897f:     String iFunc;
1:cb5897f:     String lFunc;
1:cb5897f:     String sFunc;
1:cb5897f:     String mFunc;
1:cb5897f:     String uFunc;
1:cb5897f:     String udtFunc;
1:cb5897f: 
1:cb5897f:     String userType;
1:cb5897f: 
1:cb5897f:     @Before
1:cb5897f:     public void setup() throws Throwable
1:cb5897f:     {
1:cb5897f:         userType = KEYSPACE + "." + createType("CREATE TYPE %s (t text, i int)");
1:cb5897f: 
1:cb5897f:         createTable("CREATE TABLE %s (" +
1:cb5897f:                     "   key int, " +
1:cb5897f:                     "   t_sc text STATIC," +
1:cb5897f:                     "   i_cc int, " +
1:cb5897f:                     "   t_cc text, " +
1:cb5897f:                     "   i_val int," +
1:cb5897f:                     "   l_val list<int>," +
1:cb5897f:                     "   s_val set<int>," +
1:cb5897f:                     "   m_val map<int, int>," +
1:cb5897f:                     "   u_val timeuuid," +
1:cb5897f:                     "   udt_val frozen<" + userType + ">," +
1:cb5897f:                     "   PRIMARY KEY (key, i_cc, t_cc)" +
1:cb5897f:                     ")");
1:cb5897f: 
1:cb5897f:         tFunc = createEchoFunction("text");
1:cb5897f:         iFunc = createEchoFunction("int");
1:cb5897f:         lFunc = createEchoFunction("list<int>");
1:cb5897f:         sFunc = createEchoFunction("set<int>");
1:cb5897f:         mFunc = createEchoFunction("map<int, int>");
1:cb5897f:         uFunc = createEchoFunction("timeuuid");
1:1de8e39:         udtFunc = createEchoFunction(userType);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testSimpleModificationStatement() throws Throwable
1:cb5897f:     {
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, t_sc) VALUES (0, 0, 'A', %s)", functionCall(tFunc, "'foo'")), tFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (0, %s, 'A')", functionCall(iFunc, "1")), iFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, t_cc, i_cc) VALUES (0, %s, 1)", functionCall(tFunc, "'foo'")), tFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'A', %s)", functionCall(iFunc, "1")), iFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, l_val) VALUES (0, 0, 'A', %s)", functionCall(lFunc, "[1]")), lFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, s_val) VALUES (0, 0, 'A', %s)", functionCall(sFunc, "{1}")), sFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, m_val) VALUES (0, 0, 'A', %s)", functionCall(mFunc, "{1:1}")), mFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, udt_val) VALUES (0, 0, 'A', %s)", functionCall(udtFunc, "{i : 1, t : 'foo'}")), udtFunc);
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, u_val) VALUES (0, 0, 'A', %s)", functionCall(uFunc, "now()")), uFunc, "system.now");
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testNonTerminalCollectionLiterals() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         String mapValue = String.format("{%s:%s}", functionCall(iFunc, "1"), functionCall(iFunc2, "1"));
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, m_val) VALUES (0, 0, 'A', %s)", mapValue), iFunc, iFunc2);
1:cb5897f: 
1:cb5897f:         String listValue = String.format("[%s]", functionCall(iFunc, "1"));
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, l_val) VALUES (0, 0, 'A',  %s)", listValue), iFunc);
1:cb5897f: 
1:cb5897f:         String setValue = String.format("{%s}", functionCall(iFunc, "1"));
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, s_val) VALUES (0, 0, 'A', %s)", setValue), iFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testNonTerminalUDTLiterals() throws Throwable
1:cb5897f:     {
1:cb5897f:         String udtValue = String.format("{ i: %s, t : %s } ", functionCall(iFunc, "1"), functionCall(tFunc, "'foo'"));
1:2e3727e:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, udt_val) VALUES (0, 0, 'A', %s)", udtValue), iFunc, tFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testModificationStatementWithConditions() throws Throwable
1:cb5897f:     {
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF t_sc=%s", functionCall(tFunc, "'foo'")), tFunc);
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF i_val=%s", functionCall(iFunc, "1")), iFunc);
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF l_val=%s", functionCall(lFunc, "[1]")), lFunc);
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF s_val=%s", functionCall(sFunc, "{1}")), sFunc);
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF m_val=%s", functionCall(mFunc, "{1:1}")), mFunc);
1:cb5897f: 
1:cb5897f: 
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF i_val IN (%s, %S)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(iFunc2, "2")),
1:cb5897f:                         iFunc, iFunc2);
1:cb5897f: 
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF u_val=%s",
1:cb5897f:                             functionCall(uFunc, "now()")),
1:cb5897f:                         uFunc, "system.now");
1:cb5897f: 
1:cb5897f:         // conditions on collection elements
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF l_val[%s] = %s",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(iFunc2, "1")),
1:cb5897f:                         iFunc, iFunc2);
1:2e3727e:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF m_val[%s] = %s",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(iFunc2, "1")),
1:cb5897f:                         iFunc, iFunc2);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test @Ignore
1:cb5897f:     // Technically, attributes like timestamp and ttl are Terms so could potentially
1:d9836e0:     // resolve to function calls (& so you can call getFunctions on them)
1:cb5897f:     // However, this is currently disallowed by CQL syntax
1:cb5897f:     public void testModificationStatementWithAttributesFromFunction() throws Throwable
1:cb5897f:     {
1:cb5897f:         String longFunc = createEchoFunction("bigint");
1:cb5897f:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TIMESTAMP %s",
1:cb5897f:                             functionCall(longFunc, "9999")),
1:cb5897f:                         longFunc);
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TTL %s",
1:cb5897f:                             functionCall(iFunc, "8888")),
1:cb5897f:                         iFunc);
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TIMESTAMP %s AND TTL %s",
1:cb5897f:                             functionCall(longFunc, "9999"), functionCall(iFunc, "8888")),
1:cb5897f:                         longFunc, iFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testModificationStatementWithNestedFunctions() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         String iFunc3 = createEchoFunction("int");
1:cb5897f:         String iFunc4 = createEchoFunction("int");
1:cb5897f:         String iFunc5 = createEchoFunction("int");
1:cb5897f:         String iFunc6 = createEchoFunction("int");
1:cb5897f:         String nestedFunctionCall = nestedFunctionCall(iFunc6, iFunc5,
1:cb5897f:                                                        nestedFunctionCall(iFunc4, iFunc3,
1:cb5897f:                                                                           nestedFunctionCall(iFunc2, iFunc, "1")));
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("DELETE FROM %s WHERE key=%s", nestedFunctionCall),
1:cb5897f:                         iFunc, iFunc2, iFunc3, iFunc4, iFunc5, iFunc6);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testSelectStatementSimpleRestrictions() throws Throwable
1:cb5897f:     {
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s", functionCall(iFunc, "1")), iFunc);
1:a991b64:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND t_sc=%s ALLOW FILTERING", functionCall(tFunc, "'foo'")), tFunc);
1:a991b64:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=%s AND t_cc='foo' ALLOW FILTERING", functionCall(iFunc, "1")), iFunc);
1:a991b64:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=0 AND t_cc=%s ALLOW FILTERING", functionCall(tFunc, "'foo'")), tFunc);
1:cb5897f: 
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         String tFunc2 = createEchoFunction("text");
1:a991b64:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s AND t_sc=%s AND i_cc=%s AND t_cc=%s ALLOW FILTERING",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'"),
1:cb5897f:                             functionCall(iFunc2, "1"),
1:cb5897f:                             functionCall(tFunc2, "'foo'")),
1:cb5897f:                         iFunc, tFunc, iFunc2, tFunc2);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testSelectStatementRestrictionsWithNestedFunctions() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         String iFunc3 = createEchoFunction("int");
1:cb5897f:         String iFunc4 = createEchoFunction("int");
1:cb5897f:         String iFunc5 = createEchoFunction("int");
1:cb5897f:         String iFunc6 = createEchoFunction("int");
1:cb5897f:         String nestedFunctionCall = nestedFunctionCall(iFunc6, iFunc5,
1:cb5897f:                                                        nestedFunctionCall(iFunc3, iFunc4,
1:cb5897f:                                                                           nestedFunctionCall(iFunc, iFunc2, "1")));
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s", nestedFunctionCall),
1:cb5897f:                         iFunc, iFunc2, iFunc3, iFunc4, iFunc5, iFunc6);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testNonTerminalTupleInSelectRestrictions() throws Throwable
1:cb5897f:     {
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) IN ((%s, %s))",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'")),
1:cb5897f:                         iFunc, tFunc);
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) = (%s, %s)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'")),
1:cb5897f:                         iFunc, tFunc);
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) > (%s, %s)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'")),
1:cb5897f:                         iFunc, tFunc);
1:cb5897f: 
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) < (%s, %s)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'")),
1:cb5897f:                         iFunc, tFunc);
1:cb5897f: 
1:cb5897f:          assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) > (%s, %s) AND (i_cc, t_cc) < (%s, %s)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'"),
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(tFunc, "'foo'")),
1:cb5897f:                          iFunc, tFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testNestedFunctionInTokenRestriction() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) = token(%s)", functionCall(iFunc, "1")),
1:cb5897f:                         "system.token", iFunc);
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) > token(%s)", functionCall(iFunc, "1")),
1:cb5897f:                         "system.token", iFunc);
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) < token(%s)", functionCall(iFunc, "1")),
1:cb5897f:                         "system.token", iFunc);
1:cb5897f:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) > token(%s) AND token(key) < token(%s)",
1:cb5897f:                             functionCall(iFunc, "1"),
1:cb5897f:                             functionCall(iFunc2, "1")),
1:cb5897f:                         "system.token", iFunc, iFunc2);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testSelectStatementSimpleSelections() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         execute("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0)");
1:cb5897f:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", functionCall(iFunc, "i_val")), iFunc);
1:cb5897f:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", nestedFunctionCall(iFunc, iFunc2, "i_val")), iFunc, iFunc2);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testSelectStatementNestedSelections() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         execute("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0)");
1:cb5897f:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", functionCall(iFunc, "i_val")), iFunc);
1:cb5897f:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", nestedFunctionCall(iFunc, iFunc2, "i_val")), iFunc, iFunc2);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testBatchStatement() throws Throwable
1:cb5897f:     {
1:cb5897f:         String iFunc2 = createEchoFunction("int");
1:cb5897f:         List<ModificationStatement> statements = new ArrayList<>();
1:cb5897f:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (%s, 0, 'foo')",
1:cb5897f:                                                  functionCall(iFunc, "0"))));
1:cb5897f:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (1, %s, 'foo')",
1:cb5897f:                                                  functionCall(iFunc2, "1"))));
1:cb5897f:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (2, 2, %s)",
1:cb5897f:                                                  functionCall(tFunc, "'foo'"))));
1:cb5897f: 
1:cb5897f:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:cb5897f:         assertFunctions(batch, iFunc, iFunc2, tFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testBatchStatementWithConditions() throws Throwable
1:cb5897f:     {
1:cb5897f:         List<ModificationStatement> statements = new ArrayList<>();
1:cb5897f:         statements.add(modificationStatement(cql("UPDATE %s SET i_val = %s WHERE key=0 AND i_cc=0 and t_cc='foo' IF l_val = %s",
1:cb5897f:                                                  functionCall(iFunc, "0"), functionCall(lFunc, "[1]"))));
1:cb5897f:         statements.add(modificationStatement(cql("UPDATE %s SET i_val = %s WHERE key=0 AND i_cc=1 and t_cc='foo' IF s_val = %s",
1:cb5897f:                                                  functionCall(iFunc, "0"), functionCall(sFunc, "{1}"))));
1:cb5897f: 
1:cb5897f:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:cb5897f:         assertFunctions(batch, iFunc, lFunc, sFunc);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private ModificationStatement modificationStatement(String cql)
1:cb5897f:     {
1:01115f7:         return (ModificationStatement) QueryProcessor.getStatement(cql, ClientState.forInternalCalls()).statement;
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertFunctions(String cql, String... function)
1:cb5897f:     {
1:cb5897f:         CQLStatement stmt = QueryProcessor.getStatement(cql, ClientState.forInternalCalls()).statement;
1:cb5897f:         assertFunctions(stmt, function);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertFunctions(CQLStatement stmt, String... function)
1:cb5897f:     {
1:cb5897f:         Set<String> expected = com.google.common.collect.Sets.newHashSet(function);
1:cb5897f:         Set<String> actual = com.google.common.collect.Sets.newHashSet(Iterables.transform(stmt.getFunctions(),
1:cb5897f:                                                                                            toFunctionNames));
1:cb5897f:         assertTrue(com.google.common.collect.Sets.symmetricDifference(expected, actual).isEmpty());
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String cql(String template, String... params)
1:cb5897f:     {
1:cb5897f:         String tableName = KEYSPACE + "." + currentTable();
1:cb5897f:         return String.format(template, com.google.common.collect.Lists.asList(tableName, params).toArray());
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     // Alternative query builder - appends the table name to the supplied params,
1:cb5897f:     // for stmts of the form "SELECT x, %s FROM %s WHERE y=0"
1:cb5897f:     private String cql2(String template, String... params)
1:cb5897f:     {
1:cb5897f:         Object[] args = Arrays.copyOf(params, params.length + 1);
1:cb5897f:         args[params.length] = KEYSPACE + "." + currentTable();
1:cb5897f:         return String.format(template, args);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String functionCall(String fName, String... args)
1:cb5897f:     {
1:cb5897f:         return String.format("%s(%s)", fName, Joiner.on(",").join(args));
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String nestedFunctionCall(String outer, String inner, String innerArgs)
1:cb5897f:     {
1:cb5897f:         return functionCall(outer, functionCall(inner, innerArgs));
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String createEchoFunction(String type) throws Throwable
1:cb5897f:     {
1:cb5897f:         return createFunction(KEYSPACE, type,
1:cb5897f:            "CREATE FUNCTION %s(input " + type + ")" +
1:1937bed:            " CALLED ON NULL INPUT" +
1:cb5897f:            " RETURNS " + type +
1:cb5897f:            " LANGUAGE java" +
1:cb5897f:            " AS ' return input;'");
1:cb5897f:     }
1:cb5897f: }
============================================================================
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, t_sc) VALUES (0, 0, 'A', %s)", functionCall(tFunc, "'foo'")), tFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (0, %s, 'A')", functionCall(iFunc, "1")), iFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, t_cc, i_cc) VALUES (0, %s, 1)", functionCall(tFunc, "'foo'")), tFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'A', %s)", functionCall(iFunc, "1")), iFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, l_val) VALUES (0, 0, 'A', %s)", functionCall(lFunc, "[1]")), lFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, s_val) VALUES (0, 0, 'A', %s)", functionCall(sFunc, "{1}")), sFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, m_val) VALUES (0, 0, 'A', %s)", functionCall(mFunc, "{1:1}")), mFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, udt_val) VALUES (0, 0, 'A', %s)", functionCall(udtFunc, "{i : 1, t : 'foo'}")), udtFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, u_val) VALUES (0, 0, 'A', %s)", functionCall(uFunc, "now()")), uFunc, "system.now");
/////////////////////////////////////////////////////////////////////////
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, m_val) VALUES (0, 0, 'A', %s)", mapValue), iFunc, iFunc2);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, l_val) VALUES (0, 0, 'A',  %s)", listValue), iFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, s_val) VALUES (0, 0, 'A', %s)", setValue), iFunc);
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, udt_val) VALUES (0, 0, 'A', %s)", udtValue), iFunc, tFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF t_sc=%s", functionCall(tFunc, "'foo'")), tFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF i_val=%s", functionCall(iFunc, "1")), iFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF l_val=%s", functionCall(lFunc, "[1]")), lFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF s_val=%s", functionCall(sFunc, "{1}")), sFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF m_val=%s", functionCall(mFunc, "{1:1}")), mFunc);
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF i_val IN (%s, %S)",
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF u_val=%s",
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF l_val[%s] = %s",
1:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 AND i_cc = 0 AND t_cc = 'A' IF m_val[%s] = %s",
commit:1de8e39
/////////////////////////////////////////////////////////////////////////
1:         udtFunc = createEchoFunction(userType);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND t_sc=%s ALLOW FILTERING", functionCall(tFunc, "'foo'")), tFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=%s AND t_cc='foo' ALLOW FILTERING", functionCall(iFunc, "1")), iFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=0 AND t_cc=%s ALLOW FILTERING", functionCall(tFunc, "'foo'")), tFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s AND t_sc=%s AND i_cc=%s AND t_cc=%s ALLOW FILTERING",
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.cql3.validation.entities;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Attributes;
1: import org.apache.cassandra.cql3.CQLStatement;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.cql3.CQLTester;
/////////////////////////////////////////////////////////////////////////
1:         return (ModificationStatement) QueryProcessor.getStatement(cql, ClientState.forInternalCalls()).statement;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:1937bed
/////////////////////////////////////////////////////////////////////////
1:            " CALLED ON NULL INPUT" +
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:d9836e0
/////////////////////////////////////////////////////////////////////////
1:     // resolve to function calls (& so you can call getFunctions on them)
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.cassandra.cql3;
1: 
1: import java.util.*;
1: 
1: import com.google.common.base.Joiner;
1: import com.google.common.collect.Iterables;
1: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.cql3.functions.Function;
1: import org.apache.cassandra.cql3.statements.BatchStatement;
1: import org.apache.cassandra.cql3.statements.ModificationStatement;
1: import org.apache.cassandra.service.ClientState;
1: 
1: import static org.junit.Assert.assertTrue;
1: 
1: /**
1:  * Checks the collection of Function objects returned by CQLStatement.getFunction
1:  * matches expectations. This is intended to verify the various subcomponents of
1:  * the statement (Operations, Terms, Restrictions, RestrictionSet, Selection,
1:  * Selector, SelectorFactories etc) properly report any constituent functions.
1:  * Some purely terminal functions are resolved at preparation, so those are not
1:  * included in the reported list. They still need to be surveyed, to verify the
1:  * calling client has the necessary permissions. UFAuthTest includes tests which
1:  * verify this more thoroughly than we can here.
1:  */
1: public class UFIdentificationTest extends CQLTester
1: {
1:     private com.google.common.base.Function<Function, String> toFunctionNames = new com.google.common.base.Function<Function, String>()
1:     {
1:         public String apply(Function f)
1:         {
1:             return f.name().keyspace + "." + f.name().name;
1:         }
1:     };
1: 
1:     String tFunc;
1:     String iFunc;
1:     String lFunc;
1:     String sFunc;
1:     String mFunc;
1:     String uFunc;
1:     String udtFunc;
1: 
1:     String userType;
1: 
1:     @Before
1:     public void setup() throws Throwable
1:     {
1:         userType = KEYSPACE + "." + createType("CREATE TYPE %s (t text, i int)");
1: 
1:         createTable("CREATE TABLE %s (" +
1:                     "   key int, " +
1:                     "   t_sc text STATIC," +
1:                     "   i_cc int, " +
1:                     "   t_cc text, " +
1:                     "   i_val int," +
1:                     "   l_val list<int>," +
1:                     "   s_val set<int>," +
1:                     "   m_val map<int, int>," +
1:                     "   u_val timeuuid," +
1:                     "   udt_val frozen<" + userType + ">," +
1:                     "   PRIMARY KEY (key, i_cc, t_cc)" +
1:                     ")");
1: 
1:         tFunc = createEchoFunction("text");
1:         iFunc = createEchoFunction("int");
1:         lFunc = createEchoFunction("list<int>");
1:         sFunc = createEchoFunction("set<int>");
1:         mFunc = createEchoFunction("map<int, int>");
1:         uFunc = createEchoFunction("timeuuid");
0:         udtFunc = createEchoFunction("frozen<" + userType + ">");
1:     }
1: 
1:     @Test
1:     public void testSimpleModificationStatement() throws Throwable
1:     {
0:         assertFunctions(cql("INSERT INTO %s (key, t_sc) VALUES (0, %s)", functionCall(tFunc, "'foo'")), tFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, i_cc) VALUES (0, %s)", functionCall(iFunc, "1")), iFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, t_cc) VALUES (0, %s)", functionCall(tFunc, "'foo'")), tFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, i_val) VALUES (0, %s)", functionCall(iFunc, "1")), iFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, l_val) VALUES (0, %s)", functionCall(lFunc, "[1]")), lFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, s_val) VALUES (0, %s)", functionCall(sFunc, "{1}")), sFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, m_val) VALUES (0, %s)", functionCall(mFunc, "{1:1}")), mFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, udt_val) VALUES (0,%s)", functionCall(udtFunc, "{i : 1, t : 'foo'}")), udtFunc);
0:         assertFunctions(cql("INSERT INTO %s (key, u_val) VALUES (0, %s)", functionCall(uFunc, "now()")), uFunc, "system.now");
1:     }
1: 
1:     @Test
1:     public void testNonTerminalCollectionLiterals() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         String mapValue = String.format("{%s:%s}", functionCall(iFunc, "1"), functionCall(iFunc2, "1"));
0:         assertFunctions(cql("INSERT INTO %s (key, m_val) VALUES (0, %s)", mapValue), iFunc, iFunc2);
1: 
1:         String listValue = String.format("[%s]", functionCall(iFunc, "1"));
0:         assertFunctions(cql("INSERT INTO %s (key, l_val) VALUES (0, %s)", listValue), iFunc);
1: 
1:         String setValue = String.format("{%s}", functionCall(iFunc, "1"));
0:         assertFunctions(cql("INSERT INTO %s (key, s_val) VALUES (0, %s)", setValue), iFunc);
1:     }
1: 
1:     @Test
1:     public void testNonTerminalUDTLiterals() throws Throwable
1:     {
1:         String udtValue = String.format("{ i: %s, t : %s } ", functionCall(iFunc, "1"), functionCall(tFunc, "'foo'"));
0:         assertFunctions(cql("INSERT INTO %s (key, udt_val) VALUES (0, %s)", udtValue), iFunc, tFunc);
1:     }
1: 
1:     @Test
1:     public void testModificationStatementWithConditions() throws Throwable
1:     {
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF t_sc=%s", functionCall(tFunc, "'foo'")), tFunc);
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF i_val=%s", functionCall(iFunc, "1")), iFunc);
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF l_val=%s", functionCall(lFunc, "[1]")), lFunc);
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF s_val=%s", functionCall(sFunc, "{1}")), sFunc);
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF m_val=%s", functionCall(mFunc, "{1:1}")), mFunc);
1: 
1: 
1:         String iFunc2 = createEchoFunction("int");
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF i_val IN (%s, %S)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(iFunc2, "2")),
1:                         iFunc, iFunc2);
1: 
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF u_val=%s",
1:                             functionCall(uFunc, "now()")),
1:                         uFunc, "system.now");
1: 
1:         // conditions on collection elements
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF l_val[%s] = %s",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(iFunc2, "1")),
1:                         iFunc, iFunc2);
0:         assertFunctions(cql("UPDATE %s SET i_val=0 WHERE key=0 IF m_val[%s] = %s",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(iFunc2, "1")),
1:                         iFunc, iFunc2);
1:     }
1: 
1:     @Test @Ignore
1:     // Technically, attributes like timestamp and ttl are Terms so could potentially
0:     // resolve to function calls (& so you can call usesFunction & getFunctions on them)
1:     // However, this is currently disallowed by CQL syntax
1:     public void testModificationStatementWithAttributesFromFunction() throws Throwable
1:     {
1:         String longFunc = createEchoFunction("bigint");
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TIMESTAMP %s",
1:                             functionCall(longFunc, "9999")),
1:                         longFunc);
1: 
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TTL %s",
1:                             functionCall(iFunc, "8888")),
1:                         iFunc);
1: 
1:         assertFunctions(cql("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0) USING TIMESTAMP %s AND TTL %s",
1:                             functionCall(longFunc, "9999"), functionCall(iFunc, "8888")),
1:                         longFunc, iFunc);
1:     }
1: 
1:     @Test
1:     public void testModificationStatementWithNestedFunctions() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         String iFunc3 = createEchoFunction("int");
1:         String iFunc4 = createEchoFunction("int");
1:         String iFunc5 = createEchoFunction("int");
1:         String iFunc6 = createEchoFunction("int");
1:         String nestedFunctionCall = nestedFunctionCall(iFunc6, iFunc5,
1:                                                        nestedFunctionCall(iFunc4, iFunc3,
1:                                                                           nestedFunctionCall(iFunc2, iFunc, "1")));
1: 
1:         assertFunctions(cql("DELETE FROM %s WHERE key=%s", nestedFunctionCall),
1:                         iFunc, iFunc2, iFunc3, iFunc4, iFunc5, iFunc6);
1:     }
1: 
1:     @Test
1:     public void testSelectStatementSimpleRestrictions() throws Throwable
1:     {
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s", functionCall(iFunc, "1")), iFunc);
0:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND t_sc=%s", functionCall(tFunc, "'foo'")), tFunc);
0:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=%s AND t_cc='foo'", functionCall(iFunc, "1")), iFunc);
0:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND i_cc=0 AND t_cc=%s", functionCall(tFunc, "'foo'")), tFunc);
1: 
1:         String iFunc2 = createEchoFunction("int");
1:         String tFunc2 = createEchoFunction("text");
0:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s AND t_sc=%s AND i_cc=%s AND t_cc=%s",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'"),
1:                             functionCall(iFunc2, "1"),
1:                             functionCall(tFunc2, "'foo'")),
1:                         iFunc, tFunc, iFunc2, tFunc2);
1:     }
1: 
1:     @Test
1:     public void testSelectStatementRestrictionsWithNestedFunctions() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         String iFunc3 = createEchoFunction("int");
1:         String iFunc4 = createEchoFunction("int");
1:         String iFunc5 = createEchoFunction("int");
1:         String iFunc6 = createEchoFunction("int");
1:         String nestedFunctionCall = nestedFunctionCall(iFunc6, iFunc5,
1:                                                        nestedFunctionCall(iFunc3, iFunc4,
1:                                                                           nestedFunctionCall(iFunc, iFunc2, "1")));
1: 
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=%s", nestedFunctionCall),
1:                         iFunc, iFunc2, iFunc3, iFunc4, iFunc5, iFunc6);
1:     }
1: 
1:     @Test
1:     public void testNonTerminalTupleInSelectRestrictions() throws Throwable
1:     {
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) IN ((%s, %s))",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'")),
1:                         iFunc, tFunc);
1: 
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) = (%s, %s)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'")),
1:                         iFunc, tFunc);
1: 
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) > (%s, %s)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'")),
1:                         iFunc, tFunc);
1: 
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) < (%s, %s)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'")),
1:                         iFunc, tFunc);
1: 
1:          assertFunctions(cql("SELECT i_val FROM %s WHERE key=0 AND (i_cc, t_cc) > (%s, %s) AND (i_cc, t_cc) < (%s, %s)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'"),
1:                             functionCall(iFunc, "1"),
1:                             functionCall(tFunc, "'foo'")),
1:                          iFunc, tFunc);
1:     }
1: 
1:     @Test
1:     public void testNestedFunctionInTokenRestriction() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) = token(%s)", functionCall(iFunc, "1")),
1:                         "system.token", iFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) > token(%s)", functionCall(iFunc, "1")),
1:                         "system.token", iFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) < token(%s)", functionCall(iFunc, "1")),
1:                         "system.token", iFunc);
1:         assertFunctions(cql("SELECT i_val FROM %s WHERE token(key) > token(%s) AND token(key) < token(%s)",
1:                             functionCall(iFunc, "1"),
1:                             functionCall(iFunc2, "1")),
1:                         "system.token", iFunc, iFunc2);
1:     }
1: 
1:     @Test
1:     public void testSelectStatementSimpleSelections() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         execute("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0)");
1:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", functionCall(iFunc, "i_val")), iFunc);
1:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", nestedFunctionCall(iFunc, iFunc2, "i_val")), iFunc, iFunc2);
1:     }
1: 
1:     @Test
1:     public void testSelectStatementNestedSelections() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         execute("INSERT INTO %s (key, i_cc, t_cc, i_val) VALUES (0, 0, 'foo', 0)");
1:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", functionCall(iFunc, "i_val")), iFunc);
1:         assertFunctions(cql2("SELECT i_val, %s FROM %s WHERE key=0", nestedFunctionCall(iFunc, iFunc2, "i_val")), iFunc, iFunc2);
1:     }
1: 
1:     @Test
1:     public void testBatchStatement() throws Throwable
1:     {
1:         String iFunc2 = createEchoFunction("int");
1:         List<ModificationStatement> statements = new ArrayList<>();
1:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (%s, 0, 'foo')",
1:                                                  functionCall(iFunc, "0"))));
1:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (1, %s, 'foo')",
1:                                                  functionCall(iFunc2, "1"))));
1:         statements.add(modificationStatement(cql("INSERT INTO %s (key, i_cc, t_cc) VALUES (2, 2, %s)",
1:                                                  functionCall(tFunc, "'foo'"))));
1: 
1:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:         assertFunctions(batch, iFunc, iFunc2, tFunc);
1:     }
1: 
1:     @Test
1:     public void testBatchStatementWithConditions() throws Throwable
1:     {
1:         List<ModificationStatement> statements = new ArrayList<>();
1:         statements.add(modificationStatement(cql("UPDATE %s SET i_val = %s WHERE key=0 AND i_cc=0 and t_cc='foo' IF l_val = %s",
1:                                                  functionCall(iFunc, "0"), functionCall(lFunc, "[1]"))));
1:         statements.add(modificationStatement(cql("UPDATE %s SET i_val = %s WHERE key=0 AND i_cc=1 and t_cc='foo' IF s_val = %s",
1:                                                  functionCall(iFunc, "0"), functionCall(sFunc, "{1}"))));
1: 
1:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:         assertFunctions(batch, iFunc, lFunc, sFunc);
1:     }
1: 
1:     private ModificationStatement modificationStatement(String cql)
1:     {
0:         return (ModificationStatement)QueryProcessor.getStatement(cql, ClientState.forInternalCalls()).statement;
1:     }
1: 
1:     private void assertFunctions(String cql, String... function)
1:     {
1:         CQLStatement stmt = QueryProcessor.getStatement(cql, ClientState.forInternalCalls()).statement;
1:         assertFunctions(stmt, function);
1:     }
1: 
1:     private void assertFunctions(CQLStatement stmt, String... function)
1:     {
1:         Set<String> expected = com.google.common.collect.Sets.newHashSet(function);
1:         Set<String> actual = com.google.common.collect.Sets.newHashSet(Iterables.transform(stmt.getFunctions(),
1:                                                                                            toFunctionNames));
1:         assertTrue(com.google.common.collect.Sets.symmetricDifference(expected, actual).isEmpty());
1:     }
1: 
1:     private String cql(String template, String... params)
1:     {
1:         String tableName = KEYSPACE + "." + currentTable();
1:         return String.format(template, com.google.common.collect.Lists.asList(tableName, params).toArray());
1:     }
1: 
1:     // Alternative query builder - appends the table name to the supplied params,
1:     // for stmts of the form "SELECT x, %s FROM %s WHERE y=0"
1:     private String cql2(String template, String... params)
1:     {
1:         Object[] args = Arrays.copyOf(params, params.length + 1);
1:         args[params.length] = KEYSPACE + "." + currentTable();
1:         return String.format(template, args);
1:     }
1: 
1:     private String functionCall(String fName, String... args)
1:     {
1:         return String.format("%s(%s)", fName, Joiner.on(",").join(args));
1:     }
1: 
1:     private String nestedFunctionCall(String outer, String inner, String innerArgs)
1:     {
1:         return functionCall(outer, functionCall(inner, innerArgs));
1:     }
1: 
1:     private String createEchoFunction(String type) throws Throwable
1:     {
1:         return createFunction(KEYSPACE, type,
1:            "CREATE FUNCTION %s(input " + type + ")" +
1:            " RETURNS " + type +
1:            " LANGUAGE java" +
1:            " AS ' return input;'");
1:     }
1: }
============================================================================