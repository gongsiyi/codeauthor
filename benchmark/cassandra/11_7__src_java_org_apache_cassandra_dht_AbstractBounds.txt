1:69542a9: /*
1:0160ad5:  * Licensed to the Apache Software Foundation (ASF) under one
1:0160ad5:  * or more contributor license agreements.  See the NOTICE file
1:0160ad5:  * distributed with this work for additional information
1:0160ad5:  * regarding copyright ownership.  The ASF licenses this file
1:0160ad5:  * to you under the Apache License, Version 2.0 (the
1:0160ad5:  * "License"); you may not use this file except in compliance
1:0160ad5:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cdfd0:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:554223b:  */
1:07cf56f: package org.apache.cassandra.dht;
1:84eeb28: 
1:0160ad5: import java.io.DataInput;
1:0160ad5: import java.io.IOException;
1:0160ad5: import java.io.Serializable;
1:3aa7308: import java.util.Collection;
1:806facc: import java.util.List;
1:57b9a34: 
1:08e2891: import org.apache.cassandra.db.DecoratedKey;
1:a991b64: import org.apache.cassandra.db.PartitionPosition;
1:806facc: import org.apache.cassandra.db.TypeSizes;
1:08e2891: import org.apache.cassandra.db.marshal.AbstractType;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:bd7d119: import org.apache.cassandra.net.MessagingService;
1:389bac7: import org.apache.cassandra.utils.Pair;
2:389bac7: 
1:ad84e4d: public abstract class AbstractBounds<T extends RingPosition<T>> implements Serializable
1:69542a9: {
1:1f039c4:     private static final long serialVersionUID = 1L;
1:69542a9:     public static final IPartitionerDependentSerializer<AbstractBounds<Token>> tokenSerializer =
1:69542a9:             new AbstractBoundsSerializer<Token>(Token.serializer);
1:a991b64:     public static final IPartitionerDependentSerializer<AbstractBounds<PartitionPosition>> rowPositionSerializer =
1:a991b64:             new AbstractBoundsSerializer<PartitionPosition>(PartitionPosition.serializer);
1:69542a9: 
1:0160ad5:     private enum Type
1:69542a9:     {
1:0160ad5:         RANGE,
1:0160ad5:         BOUNDS
1:69542a9:     }
1:554223b: 
1:554223b:     public final T left;
1:554223b:     public final T right;
1:2782e0b: 
1:07893d7:     public AbstractBounds(T left, T right)
1:572ef50:     {
1:07893d7:         assert left.getPartitioner() == right.getPartitioner();
1:0160ad5:         this.left = left;
1:0160ad5:         this.right = right;
1:2782e0b:     }
1:2782e0b: 
2:554223b:     /**
1:35f7bc5:      * Given token T and AbstractBounds ?L,R?, returns Pair(?L,T], (T,R?),
1:35f7bc5:      * where ? means that the same type of AbstractBounds is returned as the original.
1:07cdfd0:      *
1:35f7bc5:      * Put another way, returns a Pair of everything this AbstractBounds contains
1:35f7bc5:      * up to and including the split position, and everything it contains after
1:35f7bc5:      * (not including the split position).
1:07cdfd0:      *
1:35f7bc5:      * The original AbstractBounds must either contain the position T, or T
1:35f7bc5:      * should be equals to the left bound L.
2:07cf56f:      *
1:35f7bc5:      * If the split would only yield the same AbstractBound, null is returned
1:35f7bc5:      * instead.
1:554223b:      */
1:35f7bc5:     public abstract Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position);
1:572ef50:     public abstract boolean inclusiveLeft();
1:572ef50:     public abstract boolean inclusiveRight();
1:554223b: 
1:3aa7308:     /**
1:3aa7308:      * Whether {@code left} and {@code right} forms a wrapping interval, that is if unwrapping wouldn't be a no-op.
1:3aa7308:      * <p>
1:3aa7308:      * Note that the semantic is slightly different from {@link Range#isWrapAround()} in the sense that if both
1:3aa7308:      * {@code right} are minimal (for the partitioner), this methods return false (doesn't wrap) while
1:3aa7308:      * {@link Range#isWrapAround()} returns true (does wrap). This is confusing and we should fix it by
1:3aa7308:      * refactoring/rewriting the whole AbstractBounds hierarchy with cleaner semantics, but we don't want to risk
1:3aa7308:      * breaking something by changing {@link Range#isWrapAround()} in the meantime.
1:3aa7308:      */
1:3aa7308:     public static <T extends RingPosition<T>> boolean strictlyWrapsAround(T left, T right)
1:3aa7308:     {
1:3aa7308:         return !(left.compareTo(right) <= 0 || right.isMinimum());
1:3aa7308:     }
1:3aa7308: 
1:3aa7308:     public static <T extends RingPosition<T>> boolean noneStrictlyWrapsAround(Collection<AbstractBounds<T>> bounds)
1:3aa7308:     {
1:3aa7308:         for (AbstractBounds<T> b : bounds)
1:3aa7308:         {
1:3aa7308:             if (strictlyWrapsAround(b.left, b.right))
1:3aa7308:                 return false;
1:3aa7308:         }
1:3aa7308:         return true;
1:3aa7308:     }
1:3aa7308: 
2:0160ad5:     @Override
1:0160ad5:     public int hashCode()
1:2782e0b:     {
1:e5a422c:         return 31 * left.hashCode() + right.hashCode();
1:2782e0b:     }
1:554223b: 
1:57b9a34:     /** return true if @param range intersects any of the given @param ranges */
1:57b9a34:     public boolean intersects(Iterable<Range<T>> ranges)
1:2782e0b:     {
1:57b9a34:         for (Range<T> range2 : ranges)
1:2782e0b:         {
1:57b9a34:             if (range2.intersects(this))
1:57b9a34:                 return true;
1:2782e0b:         }
1:57b9a34:         return false;
1:6505a07:     }
1:2782e0b: 
1:554223b:     public abstract boolean contains(T start);
1:2782e0b: 
1:554223b:     public abstract List<? extends AbstractBounds<T>> unwrap();
1:2782e0b: 
1:08e2891:     public String getString(AbstractType<?> keyValidator)
1:08e2891:     {
1:08e2891:         return getOpeningString() + format(left, keyValidator) + ", " + format(right, keyValidator) + getClosingString();
1:08e2891:     }
1:08e2891: 
1:08e2891:     private String format(T value, AbstractType<?> keyValidator)
1:08e2891:     {
1:08e2891:         if (value instanceof DecoratedKey)
1:08e2891:         {
1:8541cca:             return keyValidator.getString(((DecoratedKey)value).getKey());
1:08e2891:         }
1:08e2891:         else
1:08e2891:         {
1:08e2891:             return value.toString();
1:08e2891:         }
1:08e2891:     }
1:08e2891: 
1:08e2891:     protected abstract String getOpeningString();
1:08e2891:     protected abstract String getClosingString();
1:08e2891: 
1:a991b64:     public abstract boolean isStartInclusive();
1:a991b64:     public abstract boolean isEndInclusive();
1:a991b64: 
1:5267112:     public abstract AbstractBounds<T> withNewRight(T newRight);
1:5267112: 
1:69542a9:     public static class AbstractBoundsSerializer<T extends RingPosition<T>> implements IPartitionerDependentSerializer<AbstractBounds<T>>
1:2782e0b:     {
1:bd7d119:         private static final int IS_TOKEN_FLAG        = 0x01;
1:bd7d119:         private static final int START_INCLUSIVE_FLAG = 0x02;
1:bd7d119:         private static final int END_INCLUSIVE_FLAG   = 0x04;
1:bd7d119: 
1:69542a9:         IPartitionerDependentSerializer<T> serializer;
1:2782e0b: 
1:bd7d119:         // Use for pre-3.0 protocol
1:69542a9:         private static int kindInt(AbstractBounds<?> ab)
1:2782e0b:         {
1:5b9fc26:             int kind = ab instanceof Range ? Type.RANGE.ordinal() : Type.BOUNDS.ordinal();
1:5b9fc26:             if (!(ab.left instanceof Token))
1:5b9fc26:                 kind = -(kind + 1);
1:5b9fc26:             return kind;
1:2782e0b:         }
1:2782e0b: 
1:bd7d119:         // For from 3.0 onwards
1:bd7d119:         private static int kindFlags(AbstractBounds<?> ab)
1:bd7d119:         {
1:bd7d119:             int flags = 0;
1:bd7d119:             if (ab.left instanceof Token)
1:bd7d119:                 flags |= IS_TOKEN_FLAG;
1:bd7d119:             if (ab.isStartInclusive())
1:bd7d119:                 flags |= START_INCLUSIVE_FLAG;
1:bd7d119:             if (ab.isEndInclusive())
1:bd7d119:                 flags |= END_INCLUSIVE_FLAG;
1:bd7d119:             return flags;
1:bd7d119:         }
1:bd7d119: 
1:69542a9:         public AbstractBoundsSerializer(IPartitionerDependentSerializer<T> serializer)
1:6505a07:         {
1:69542a9:             this.serializer = serializer;
1:2782e0b:         }
1:2782e0b: 
1:69542a9:         public void serialize(AbstractBounds<T> range, DataOutputPlus out, int version) throws IOException
1:572ef50:         {
1:554223b:             /*
1:554223b:              * The first int tells us if it's a range or bounds (depending on the value) _and_ if it's tokens or keys (depending on the
1:554223b:              * sign). We use negative kind for keys so as to preserve the serialization of token from older version.
1:554223b:              */
1:bd7d119:             if (version < MessagingService.VERSION_30)
1:bd7d119:                 out.writeInt(kindInt(range));
1:bd7d119:             else
1:bd7d119:                 out.writeByte(kindFlags(range));
1:69542a9:             serializer.serialize(range.left, out, version);
1:69542a9:             serializer.serialize(range.right, out, version);
1:554223b:         }
1:69542a9: 
1:69542a9:         public AbstractBounds<T> deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:554223b:         {
1:bd7d119:             boolean isToken, startInclusive, endInclusive;
1:bd7d119:             if (version < MessagingService.VERSION_30)
1:bd7d119:             {
1:bd7d119:                 int kind = in.readInt();
1:bd7d119:                 isToken = kind >= 0;
1:bd7d119:                 if (!isToken)
1:bd7d119:                     kind = -(kind+1);
1:bd7d119: 
1:bd7d119:                 // Pre-3.0, everything that wasa not a Range was (wrongly) serialized as a Bound;
1:bd7d119:                 startInclusive = kind != Type.RANGE.ordinal();
1:bd7d119:                 endInclusive = true;
1:bd7d119:             }
1:bd7d119:             else
1:bd7d119:             {
1:bd7d119:                 int flags = in.readUnsignedByte();
1:bd7d119:                 isToken = (flags & IS_TOKEN_FLAG) != 0;
1:bd7d119:                 startInclusive = (flags & START_INCLUSIVE_FLAG) != 0;
1:bd7d119:                 endInclusive = (flags & END_INCLUSIVE_FLAG) != 0;
1:bd7d119:             }
1:554223b: 
1:69542a9:             T left = serializer.deserialize(in, p, version);
1:69542a9:             T right = serializer.deserialize(in, p, version);
1:69542a9:             assert isToken == left instanceof Token;
1:554223b: 
1:bd7d119:             if (startInclusive)
1:bd7d119:                 return endInclusive ? new Bounds<T>(left, right) : new IncludingExcludingBounds<T>(left, right);
1:bd7d119:             else
1:bd7d119:                 return endInclusive ? new Range<T>(left, right) : new ExcludingBounds<T>(left, right);
1:554223b:         }
1:5b9fc26: 
1:69542a9:         public long serializedSize(AbstractBounds<T> ab, int version)
1:554223b:         {
1:bd7d119:             int size = version < MessagingService.VERSION_30
1:bd7d119:                      ? TypeSizes.sizeof(kindInt(ab))
1:bd7d119:                      : 1;
1:69542a9:             size += serializer.serializedSize(ab.left, version);
1:69542a9:             size += serializer.serializedSize(ab.right, version);
1:5b9fc26:             return size;
1:554223b:         }
1:554223b:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> AbstractBounds<T> bounds(Boundary<T> min, Boundary<T> max)
1:554223b:     {
1:572ef50:         return bounds(min.boundary, min.inclusive, max.boundary, max.inclusive);
1:572ef50:     }
1:572ef50:     public static <T extends RingPosition<T>> AbstractBounds<T> bounds(T min, boolean inclusiveMin, T max, boolean inclusiveMax)
1:554223b:     {
1:572ef50:         if (inclusiveMin && inclusiveMax)
1:572ef50:             return new Bounds<T>(min, max);
1:572ef50:         else if (inclusiveMax)
1:572ef50:             return new Range<T>(min, max);
1:572ef50:         else if (inclusiveMin)
1:572ef50:             return new IncludingExcludingBounds<T>(min, max);
2:554223b:         else
1:572ef50:             return new ExcludingBounds<T>(min, max);
1:572ef50:     }
1:572ef50: 
1:572ef50:     // represents one side of a bounds (which side is not encoded)
1:572ef50:     public static class Boundary<T extends RingPosition<T>>
1:572ef50:     {
1:572ef50:         public final T boundary;
1:572ef50:         public final boolean inclusive;
1:572ef50:         public Boundary(T boundary, boolean inclusive)
1:572ef50:         {
1:572ef50:             this.boundary = boundary;
1:572ef50:             this.inclusive = inclusive;
1:572ef50:         }
1:572ef50:     }
1:572ef50: 
1:572ef50:     public Boundary<T> leftBoundary()
1:572ef50:     {
1:572ef50:         return new Boundary<>(left, inclusiveLeft());
1:572ef50:     }
1:572ef50: 
1:572ef50:     public Boundary<T> rightBoundary()
1:572ef50:     {
1:572ef50:         return new Boundary<>(right, inclusiveRight());
1:572ef50:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> boolean isEmpty(Boundary<T> left, Boundary<T> right)
1:572ef50:     {
1:572ef50:         int c = left.boundary.compareTo(right.boundary);
1:572ef50:         return c > 0 || (c == 0 && !(left.inclusive && right.inclusive));
1:572ef50:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> Boundary<T> minRight(Boundary<T> right1, T right2, boolean isInclusiveRight2)
1:572ef50:     {
1:572ef50:         return minRight(right1, new Boundary<T>(right2, isInclusiveRight2));
1:572ef50:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> Boundary<T> minRight(Boundary<T> right1, Boundary<T> right2)
1:572ef50:     {
1:572ef50:         int c = right1.boundary.compareTo(right2.boundary);
1:572ef50:         if (c != 0)
1:572ef50:             return c < 0 ? right1 : right2;
1:572ef50:         // return the exclusive version, if either
1:572ef50:         return right2.inclusive ? right1 : right2;
1:572ef50:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1, T left2, boolean isInclusiveLeft2)
1:572ef50:     {
1:572ef50:         return maxLeft(left1, new Boundary<T>(left2, isInclusiveLeft2));
1:572ef50:     }
1:572ef50: 
1:572ef50:     public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1, Boundary<T> left2)
1:572ef50:     {
1:86b04ad:         int c = left1.boundary.compareTo(left2.boundary);
1:572ef50:         if (c != 0)
1:572ef50:             return c > 0 ? left1 : left2;
1:572ef50:         // return the exclusive version, if either
1:572ef50:         return left2.inclusive ? left1 : left2;
1:572ef50:     }
1:69542a9: }
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:99e0c90
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:3aa7308
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Whether {@code left} and {@code right} forms a wrapping interval, that is if unwrapping wouldn't be a no-op.
1:      * <p>
1:      * Note that the semantic is slightly different from {@link Range#isWrapAround()} in the sense that if both
1:      * {@code right} are minimal (for the partitioner), this methods return false (doesn't wrap) while
1:      * {@link Range#isWrapAround()} returns true (does wrap). This is confusing and we should fix it by
1:      * refactoring/rewriting the whole AbstractBounds hierarchy with cleaner semantics, but we don't want to risk
1:      * breaking something by changing {@link Range#isWrapAround()} in the meantime.
1:      */
1:     public static <T extends RingPosition<T>> boolean strictlyWrapsAround(T left, T right)
1:     {
1:         return !(left.compareTo(right) <= 0 || right.isMinimum());
1:     }
1: 
1:     public static <T extends RingPosition<T>> boolean noneStrictlyWrapsAround(Collection<AbstractBounds<T>> bounds)
1:     {
1:         for (AbstractBounds<T> b : bounds)
1:         {
1:             if (strictlyWrapsAround(b.left, b.right))
1:                 return false;
1:         }
1:         return true;
1:     }
1: 
commit:bd7d119
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
1:         private static final int IS_TOKEN_FLAG        = 0x01;
1:         private static final int START_INCLUSIVE_FLAG = 0x02;
1:         private static final int END_INCLUSIVE_FLAG   = 0x04;
1: 
1:         // Use for pre-3.0 protocol
/////////////////////////////////////////////////////////////////////////
1:         // For from 3.0 onwards
1:         private static int kindFlags(AbstractBounds<?> ab)
1:         {
1:             int flags = 0;
1:             if (ab.left instanceof Token)
1:                 flags |= IS_TOKEN_FLAG;
1:             if (ab.isStartInclusive())
1:                 flags |= START_INCLUSIVE_FLAG;
1:             if (ab.isEndInclusive())
1:                 flags |= END_INCLUSIVE_FLAG;
1:             return flags;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (version < MessagingService.VERSION_30)
1:                 out.writeInt(kindInt(range));
1:             else
1:                 out.writeByte(kindFlags(range));
1:             boolean isToken, startInclusive, endInclusive;
1:             if (version < MessagingService.VERSION_30)
1:             {
1:                 int kind = in.readInt();
1:                 isToken = kind >= 0;
1:                 if (!isToken)
1:                     kind = -(kind+1);
1: 
1:                 // Pre-3.0, everything that wasa not a Range was (wrongly) serialized as a Bound;
1:                 startInclusive = kind != Type.RANGE.ordinal();
1:                 endInclusive = true;
1:             }
1:             else
1:             {
1:                 int flags = in.readUnsignedByte();
1:                 isToken = (flags & IS_TOKEN_FLAG) != 0;
1:                 startInclusive = (flags & START_INCLUSIVE_FLAG) != 0;
1:                 endInclusive = (flags & END_INCLUSIVE_FLAG) != 0;
1:             }
1:             if (startInclusive)
1:                 return endInclusive ? new Bounds<T>(left, right) : new IncludingExcludingBounds<T>(left, right);
1:             else
1:                 return endInclusive ? new Range<T>(left, right) : new ExcludingBounds<T>(left, right);
1:             int size = version < MessagingService.VERSION_30
1:                      ? TypeSizes.sizeof(kindInt(ab))
1:                      : 1;
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.PartitionPosition;
/////////////////////////////////////////////////////////////////////////
1:     public static final IPartitionerDependentSerializer<AbstractBounds<PartitionPosition>> rowPositionSerializer =
1:             new AbstractBoundsSerializer<PartitionPosition>(PartitionPosition.serializer);
/////////////////////////////////////////////////////////////////////////
1:     public abstract boolean isStartInclusive();
1:     public abstract boolean isEndInclusive();
1: 
commit:5267112
/////////////////////////////////////////////////////////////////////////
1:     public abstract AbstractBounds<T> withNewRight(T newRight);
1: 
commit:08e2891
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.DecoratedKey;
1: import org.apache.cassandra.db.marshal.AbstractType;
/////////////////////////////////////////////////////////////////////////
1:     public String getString(AbstractType<?> keyValidator)
1:     {
1:         return getOpeningString() + format(left, keyValidator) + ", " + format(right, keyValidator) + getClosingString();
1:     }
1: 
1:     private String format(T value, AbstractType<?> keyValidator)
1:     {
1:         if (value instanceof DecoratedKey)
1:         {
0:             return keyValidator.getString(((DecoratedKey)value).key);
1:         }
1:         else
1:         {
1:             return value.toString();
1:         }
1:     }
1: 
1:     protected abstract String getOpeningString();
1:     protected abstract String getClosingString();
1: 
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0:     private static final AbstractBoundsSerializer serializer = new AbstractBoundsSerializer();
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.dht;
commit:35f7bc5
/////////////////////////////////////////////////////////////////////////
1:      * Given token T and AbstractBounds ?L,R?, returns Pair(?L,T], (T,R?),
1:      * where ? means that the same type of AbstractBounds is returned as the original.
0:      *
1:      * Put another way, returns a Pair of everything this AbstractBounds contains
1:      * up to and including the split position, and everything it contains after
1:      * (not including the split position).
0:      *
1:      * The original AbstractBounds must either contain the position T, or T
1:      * should be equals to the left bound L.
0:      *
1:      * If the split would only yield the same AbstractBound, null is returned
1:      * instead.
1:     public abstract Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position);
/////////////////////////////////////////////////////////////////////////
commit:554223b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.RowPosition;
0: import org.apache.cassandra.io.IVersionedSerializer;
0: import org.apache.cassandra.net.MessagingService;
0: public abstract class AbstractBounds<T extends RingPosition> implements Serializable
/////////////////////////////////////////////////////////////////////////
1:     public final T left;
1:     public final T right;
0:     public AbstractBounds(T left, T right, IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
0:      * Given token T and AbstractBounds ?L,R], returns Pair(?L,T], ]T,R])
0:     public Pair<AbstractBounds<T>,AbstractBounds<T>> split(T pos)
0:         assert left.equals(pos) || contains(pos);
0:         AbstractBounds<T> lb = createFrom(pos);
0:         AbstractBounds<T> rb = lb != null && pos.equals(right) ? null : new Range<T>(pos, right);
0:         return new Pair<AbstractBounds<T>,AbstractBounds<T>>(lb, rb);
/////////////////////////////////////////////////////////////////////////
1:     public abstract boolean contains(T start);
0:     /** @return A clone of this AbstractBounds with a new right T, or null if an identical range would be created. */
0:     public abstract AbstractBounds<T> createFrom(T right);
1:     public abstract List<? extends AbstractBounds<T>> unwrap();
0:     public static <T extends RingPosition> List<AbstractBounds<T>> normalize(Collection<? extends AbstractBounds<T>> bounds)
0:         List<AbstractBounds<T>> output = new ArrayList<AbstractBounds<T>>();
0:         for (AbstractBounds<T> bound : bounds)
0:         Collections.sort(output, new Comparator<AbstractBounds<T>>()
0:             public int compare(AbstractBounds<T> b1, AbstractBounds<T> b2)
/////////////////////////////////////////////////////////////////////////
0:     private static <T extends RingPosition> List<AbstractBounds<T>> deoverlap(List<AbstractBounds<T>> bounds)
0:         List<AbstractBounds<T>> output = new ArrayList<AbstractBounds<T>>();
0:         Iterator<AbstractBounds<T>> iter = bounds.iterator();
0:         AbstractBounds<T> current = iter.next();
0:         T min = (T) current.partitioner.minValue(current.left.getClass());
0:                     return Collections.<AbstractBounds<T>>singletonList(current);
0:             AbstractBounds<T> next = iter.next();
/////////////////////////////////////////////////////////////////////////
0:                 T newRight = next.right.equals(min) || current.right.compareTo(next.right) < 0 ? next.right : current.right;
0:                     return Collections.<AbstractBounds<T>>singletonList(new Range<T>(min, min));
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Transform this abstract bounds to equivalent covering bounds of row positions.
0:      * If this abstract bounds was already an abstractBounds of row positions, this is a noop.
1:      */
0:     public abstract AbstractBounds<RowPosition> toRowBounds();
1: 
1:     /**
0:      * Transform this abstract bounds to a token abstract bounds.
0:      * If this abstract bounds was already an abstractBounds of token, this is a noop, otherwise this use the row position tokens.
1:      */
0:     public abstract AbstractBounds<Token> toTokenBounds();
1: 
0:     public static class AbstractBoundsSerializer implements IVersionedSerializer<AbstractBounds<?>>
0:         public void serialize(AbstractBounds<?> range, DataOutput out, int version) throws IOException
0:             // Older version don't know how to handle abstract bounds of keys
0:             // However, the serialization has been designed so that token bounds are serialized the same way that before 1.1
0:             if (version < MessagingService.VERSION_11)
0:                 range = range.toTokenBounds();
1: 
1:             /*
1:              * The first int tells us if it's a range or bounds (depending on the value) _and_ if it's tokens or keys (depending on the
1:              * sign). We use negative kind for keys so as to preserve the serialization of token from older version.
1:              */
0:             boolean isToken = range.left instanceof Token;
0:             int kind = range instanceof Range ? Type.RANGE.ordinal() : Type.BOUNDS.ordinal();
0:             if (!isToken)
0:                 kind = -(kind+1);
0:             out.writeInt(kind);
0:             if (isToken)
1:             {
0:                 Token.serializer().serialize((Token)range.left, out);
0:                 Token.serializer().serialize((Token)range.right, out);
1:             }
1:             else
1:             {
0:                 RowPosition.serializer().serialize((RowPosition)range.left, out);
0:                 RowPosition.serializer().serialize((RowPosition)range.right, out);
1:             }
0:         public AbstractBounds<?> deserialize(DataInput in, int version) throws IOException
0:             int kind = in.readInt();
0:             boolean isToken = kind >= 0;
0:             if (!isToken)
0:                 kind = -(kind+1);
1: 
0:             RingPosition left, right;
0:             if (isToken)
1:             {
0:                 left = Token.serializer().deserialize(in);
0:                 right = Token.serializer().deserialize(in);
1:             }
1:             else
1:             {
0:                 left = RowPosition.serializer().deserialize(in);
0:                 right = RowPosition.serializer().deserialize(in);
1:             }
1: 
0:             if (kind == Type.RANGE.ordinal())
0:                 return new Range(left, right);
0:             return new Bounds(left, right);
0:         public long serializedSize(AbstractBounds<?> abstractBounds, int version)
commit:2782e0b
/////////////////////////////////////////////////////////////////////////
0:      * @return A copy of the given list of with all bounds unwrapped, sorted by bound.left and with overlapping bounds merged.
0:      * This method does not allow allow to mix Range and Bound in the input list.
/////////////////////////////////////////////////////////////////////////
1: 
0:         // deoverlap
0:         return deoverlap(output);
1:     }
1: 
0:     /**
0:      * Given a list of unwrapped bounds sorted by left token, return a list a equivalent
0:      * list of bounds but with no overlapping bounds.
0:      */
0:     private static List<AbstractBounds> deoverlap(List<AbstractBounds> bounds)
1:     {
0:         if (bounds.isEmpty())
0:             return bounds;
1: 
0:         List<AbstractBounds> output = new ArrayList<AbstractBounds>();
1: 
0:         Iterator<AbstractBounds> iter = bounds.iterator();
0:         AbstractBounds current = iter.next();
0:         boolean isRange = current instanceof Range;
1: 
0:         Token min = current.partitioner.getMinimumToken();
0:         while (iter.hasNext())
1:         {
0:             if (current.right.equals(min))
1:             {
0:                 // If one of the bound is the full range, we return only that
0:                 if (current.left.equals(min))
0:                     return Collections.<AbstractBounds>singletonList(current);
1: 
0:                 output.add(current.createFrom(min));
0:                 return output;
1:             }
1: 
0:             AbstractBounds next = iter.next();
0:             assert isRange ? next instanceof Range : next instanceof Bounds;
1: 
0:             // For Ranges, if next left is equal to current right, we do not intersect per se, but replacing (A, B] and (B, C] by (A, C] is
0:             // legit, and since this actually avoid special casing and will result in more "optimal" ranges, we do this transformation
0:             if (next.left.compareTo(current.right) <= 0)
1:             {
0:                 // We do overlap
0:                 // (we've handler current.right.equals(min) already)
0:                 Token newRight = next.right.equals(min) || current.right.compareTo(next.right) < 0 ? next.right : current.right;
0:                 current = current.createFrom(newRight);
0:                 if (current == null)
0:                     // current is the full ring, can only happen for Range
0:                     return Collections.<AbstractBounds>singletonList(new Range(min, min));
1:             }
0:             else
1:             {
0:                 output.add(current);
0:                 current = next;
1:             }
1:         }
0:         output.add(current);
commit:c33acda
/////////////////////////////////////////////////////////////////////////
0:             output.addAll(bound.unwrap());
commit:6505a07
/////////////////////////////////////////////////////////////////////////
0:      * This method does not allow overlapping ranges as input.
0:         AbstractBounds previous = null;
1:         {
0:             List<AbstractBounds> unwrapped = bound.unwrap();
0:             assert previous == null || previous.right.compareTo(unwrapped.get(0).left) <= 0 :
0:                 "Overlapping ranges passed to normalize: see CASSANDRA-2461: " + previous + " and " + unwrapped;
0:             output.addAll(unwrapped);
0:             previous = unwrapped.get(unwrapped.size() - 1);
1:         }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0:             int size = TypeSizes.sizeof(kindInt(ab));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:850b5d0
commit:86b04ad
/////////////////////////////////////////////////////////////////////////
1:         int c = left1.boundary.compareTo(left2.boundary);
commit:997ab95
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:7aefd91
commit:572ef50
/////////////////////////////////////////////////////////////////////////
1:     public abstract boolean inclusiveLeft();
1:     public abstract boolean inclusiveRight();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static <T extends RingPosition<T>> AbstractBounds<T> bounds(Boundary<T> min, Boundary<T> max)
1:     {
1:         return bounds(min.boundary, min.inclusive, max.boundary, max.inclusive);
1:     }
1:     public static <T extends RingPosition<T>> AbstractBounds<T> bounds(T min, boolean inclusiveMin, T max, boolean inclusiveMax)
1:     {
1:         if (inclusiveMin && inclusiveMax)
1:             return new Bounds<T>(min, max);
1:         else if (inclusiveMax)
1:             return new Range<T>(min, max);
1:         else if (inclusiveMin)
1:             return new IncludingExcludingBounds<T>(min, max);
0:         else
1:             return new ExcludingBounds<T>(min, max);
1:     }
1: 
1:     // represents one side of a bounds (which side is not encoded)
1:     public static class Boundary<T extends RingPosition<T>>
1:     {
1:         public final T boundary;
1:         public final boolean inclusive;
1:         public Boundary(T boundary, boolean inclusive)
1:         {
1:             this.boundary = boundary;
1:             this.inclusive = inclusive;
1:         }
1:     }
1: 
1:     public Boundary<T> leftBoundary()
1:     {
1:         return new Boundary<>(left, inclusiveLeft());
1:     }
1: 
1:     public Boundary<T> rightBoundary()
1:     {
1:         return new Boundary<>(right, inclusiveRight());
1:     }
1: 
1:     public static <T extends RingPosition<T>> boolean isEmpty(Boundary<T> left, Boundary<T> right)
1:     {
1:         int c = left.boundary.compareTo(right.boundary);
1:         return c > 0 || (c == 0 && !(left.inclusive && right.inclusive));
1:     }
1: 
1:     public static <T extends RingPosition<T>> Boundary<T> minRight(Boundary<T> right1, T right2, boolean isInclusiveRight2)
1:     {
1:         return minRight(right1, new Boundary<T>(right2, isInclusiveRight2));
1:     }
1: 
1:     public static <T extends RingPosition<T>> Boundary<T> minRight(Boundary<T> right1, Boundary<T> right2)
1:     {
1:         int c = right1.boundary.compareTo(right2.boundary);
1:         if (c != 0)
1:             return c < 0 ? right1 : right2;
1:         // return the exclusive version, if either
1:         return right2.inclusive ? right1 : right2;
1:     }
1: 
1:     public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1, T left2, boolean isInclusiveLeft2)
1:     {
1:         return maxLeft(left1, new Boundary<T>(left2, isInclusiveLeft2));
1:     }
1: 
1:     public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1, Boundary<T> left2)
1:     {
0:         int c = left1.boundary.compareTo(left1.boundary);
1:         if (c != 0)
1:             return c > 0 ? left1 : left2;
1:         // return the exclusive version, if either
1:         return left2.inclusive ? left1 : left2;
1:     }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69542a9
/////////////////////////////////////////////////////////////////////////
1:     public static final IPartitionerDependentSerializer<AbstractBounds<Token>> tokenSerializer =
1:             new AbstractBoundsSerializer<Token>(Token.serializer);
0:     public static final IPartitionerDependentSerializer<AbstractBounds<RowPosition>> rowPositionSerializer =
0:             new AbstractBoundsSerializer<RowPosition>(RowPosition.serializer);
/////////////////////////////////////////////////////////////////////////
1:     public static class AbstractBoundsSerializer<T extends RingPosition<T>> implements IPartitionerDependentSerializer<AbstractBounds<T>>
1:         IPartitionerDependentSerializer<T> serializer;
1:         private static int kindInt(AbstractBounds<?> ab)
/////////////////////////////////////////////////////////////////////////
1:         public AbstractBoundsSerializer(IPartitionerDependentSerializer<T> serializer)
1:         {
1:             this.serializer = serializer;
1:         }
1: 
1:         public void serialize(AbstractBounds<T> range, DataOutputPlus out, int version) throws IOException
1:         {
1:             /*
0:              * The first int tells us if it's a range or bounds (depending on the value) _and_ if it's tokens or keys (depending on the
0:              * sign). We use negative kind for keys so as to preserve the serialization of token from older version.
0:              */
0:             out.writeInt(kindInt(range));
1:             serializer.serialize(range.left, out, version);
1:             serializer.serialize(range.right, out, version);
1:         }
1: 
1:         public AbstractBounds<T> deserialize(DataInput in, IPartitioner p, int version) throws IOException
1:             T left = serializer.deserialize(in, p, version);
1:             T right = serializer.deserialize(in, p, version);
1:             assert isToken == left instanceof Token;
0:                 return new Range<T>(left, right);
0:             return new Bounds<T>(left, right);
1:         public long serializedSize(AbstractBounds<T> ab, int version)
1:             size += serializer.serializedSize(ab.left, version);
1:             size += serializer.serializedSize(ab.right, version);
commit:806facc
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
0:     public static class AbstractBoundsSerializer implements IPartitionerDependentSerializer<AbstractBounds<?>>
/////////////////////////////////////////////////////////////////////////
0:                 Token.serializer.serialize((Token) range.left, out, version);
0:                 Token.serializer.serialize((Token) range.right, out, version);
0:                 RowPosition.serializer.serialize((RowPosition) range.left, out, version);
0:                 RowPosition.serializer.serialize((RowPosition) range.right, out, version);
/////////////////////////////////////////////////////////////////////////
0:         public AbstractBounds<?> deserialize(DataInput in, IPartitioner p, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                 left = Token.serializer.deserialize(in, p, version);
0:                 right = Token.serializer.deserialize(in, p, version);
0:                 left = RowPosition.serializer.deserialize(in, p, version);
0:                 right = RowPosition.serializer.deserialize(in, p, version);
/////////////////////////////////////////////////////////////////////////
0:                 size += Token.serializer.serializedSize((Token) ab.left, version);
0:                 size += Token.serializer.serializedSize((Token) ab.right, version);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.left, version);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.right, version);
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1:     public AbstractBounds(T left, T right)
1:         assert left.getPartitioner() == right.getPartitioner();
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractBounds<T extends RingPosition<T>> implements Serializable
/////////////////////////////////////////////////////////////////////////
0:             RingPosition<?> left, right;
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return keyValidator.getString(((DecoratedKey)value).getKey());
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(AbstractBounds<?> range, DataOutputPlus out, int version) throws IOException
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
commit:2ae5272
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
0:                 Token.serializer.serialize((Token) range.left, out);
0:                 Token.serializer.serialize((Token) range.right, out);
0:                 RowPosition.serializer.serialize((RowPosition) range.left, out);
0:                 RowPosition.serializer.serialize((RowPosition) range.right, out);
/////////////////////////////////////////////////////////////////////////
0:             int size = TypeSizes.NATIVE.sizeof(kindInt(ab));
0:                 size += Token.serializer.serializedSize((Token) ab.left, TypeSizes.NATIVE);
0:                 size += Token.serializer.serializedSize((Token) ab.right, TypeSizes.NATIVE);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.left, TypeSizes.NATIVE);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.right, TypeSizes.NATIVE);
commit:5b9fc26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DBTypeSizes;
/////////////////////////////////////////////////////////////////////////
0:             out.writeInt(kindInt(range));
0:             if (range.left instanceof Token)
/////////////////////////////////////////////////////////////////////////
0:         private int kindInt(AbstractBounds<?> ab)
0:         {
1:             int kind = ab instanceof Range ? Type.RANGE.ordinal() : Type.BOUNDS.ordinal();
1:             if (!(ab.left instanceof Token))
1:                 kind = -(kind + 1);
1:             return kind;
0:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public long serializedSize(AbstractBounds<?> ab, int version)
0:             int size = DBTypeSizes.NATIVE.sizeof(kindInt(ab));
0:             if (ab.left instanceof Token)
0:             {
0:                 size += Token.serializer().serializedSize((Token) ab.left, DBTypeSizes.NATIVE);
0:                 size += Token.serializer().serializedSize((Token) ab.right, DBTypeSizes.NATIVE);
0:             }
0:             else
0:             {
0:                 size += RowPosition.serializer().serializedSize((RowPosition) ab.left, DBTypeSizes.NATIVE);
0:                 size += RowPosition.serializer().serializedSize((RowPosition) ab.right, DBTypeSizes.NATIVE);
0:             }
1:             return size;
commit:3699a2d
commit:57b9a34
/////////////////////////////////////////////////////////////////////////
1:     /** return true if @param range intersects any of the given @param ranges */
1:     public boolean intersects(Iterable<Range<T>> ranges)
0:     {
1:         for (Range<T> range2 : ranges)
0:         {
1:             if (range2.intersects(this))
1:                 return true;
0:         }
1:         return false;
0:     }
1: 
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.ISerializer;
/////////////////////////////////////////////////////////////////////////
0:     public static AbstractBoundsSerializer serializer()
/////////////////////////////////////////////////////////////////////////
0:     public static class AbstractBoundsSerializer implements ISerializer<AbstractBounds>
/////////////////////////////////////////////////////////////////////////
1: 
0:         public long serializedSize(AbstractBounds abstractBounds)
0:         {
0:             throw new UnsupportedOperationException();
0:         }
commit:5e75a7f
/////////////////////////////////////////////////////////////////////////
commit:8fbf2e7
/////////////////////////////////////////////////////////////////////////
0:         assert left.equals(token) || contains(token);
commit:9c5a6d5
/////////////////////////////////////////////////////////////////////////
0:      * If the split would cause one of the left or right side to be empty, it will be null in the result pair.
0:         AbstractBounds lb = createFrom(token);
0:         // we contain this token, so only one of the left or right can be empty
0:         AbstractBounds rb = lb != null && token.equals(right) ? null : new Range(token, right);
0:         return new Pair<AbstractBounds,AbstractBounds>(lb, rb);
/////////////////////////////////////////////////////////////////////////
0:     /** @return A clone of this AbstractBounds with a new right Token, or null if an identical range would be created. */
commit:1f039c4
/////////////////////////////////////////////////////////////////////////
1:     private static final long serialVersionUID = 1L;
commit:389bac7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.Pair;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Given token T and AbstractBounds ?L,R], returns Pair(?L,T], ?T,R])
0:      * (where ? means that the same type of Bounds is returned -- Range or Bounds -- as the original.)
0:      * The original AbstractBounds must contain the token T.
0:      * If R==T, null is returned as the right element of the Pair.
0:      */
1: 
0:     public Pair<AbstractBounds,AbstractBounds> split(Token token)
0:     {
0:         assert contains(token);
0:         Range remainder = token.equals(right) ? null : new Range(token, right);
0:         return new Pair<AbstractBounds,AbstractBounds>(createFrom(token), remainder);
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     /** @return A clone of this AbstractBounds with a new right Token. */
0:     public abstract AbstractBounds createFrom(Token right);
commit:e5a422c
/////////////////////////////////////////////////////////////////////////
1:         return 31 * left.hashCode() + right.hashCode();
commit:aadfa6a
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * @return A copy of the given list of non-intersecting bounds with all bounds unwrapped, sorted by bound.left.
0:      */
0:     public static List<AbstractBounds> normalize(Collection<? extends AbstractBounds> bounds)
0:     {
0:         // unwrap all
0:         List<AbstractBounds> output = new ArrayList<AbstractBounds>();
0:         for (AbstractBounds bound : bounds)
0:             output.addAll(bound.unwrap());
0: 
0:         // sort by left
0:         Collections.sort(output, new Comparator<AbstractBounds>()
0:         {
0:             public int compare(AbstractBounds b1, AbstractBounds b2)
0:             {
0:                 return b1.left.compareTo(b2.left);
0:             }
0:         });
0:         return output;
0:     }
0: 
commit:0160ad5
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.dht;
0: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
0:  */
0: 
0: 
1: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.Serializable;
0: import java.util.List;
0: import java.util.Set;
0: 
0: import org.apache.cassandra.io.ICompactSerializer2;
0: 
0: public abstract class AbstractBounds implements Serializable
0: {
0:     private static AbstractBoundsSerializer serializer = new AbstractBoundsSerializer();
0: 
0:     public static ICompactSerializer2<AbstractBounds> serializer()
0:     {
0:         return serializer;
0:     }
0: 
1:     private enum Type
0:     {
1:         RANGE,
1:         BOUNDS
0:     }
0: 
0:     public final Token left;
0:     public final Token right;
0: 
0:     protected transient final IPartitioner partitioner;
0: 
0:     public AbstractBounds(Token left, Token right, IPartitioner partitioner)
0:     {
1:         this.left = left;
1:         this.right = right;
0:         this.partitioner = partitioner;
0:     }
0: 
1:     @Override
1:     public int hashCode()
0:     {
0:         return toString().hashCode();
0:     }
0: 
1:     @Override
0:     public abstract boolean equals(Object obj);
0: 
0:     public abstract boolean contains(Token start);
0: 
0:     public abstract Set<AbstractBounds> restrictTo(Range range);
0: 
0:     public abstract List<AbstractBounds> unwrap();
0: 
0:     private static class AbstractBoundsSerializer implements ICompactSerializer2<AbstractBounds>
0:     {
0:         public void serialize(AbstractBounds range, DataOutput out) throws IOException
0:         {
0:             out.writeInt(range instanceof Range ? Type.RANGE.ordinal() : Type.BOUNDS.ordinal());
0:             Token.serializer().serialize(range.left, out);
0:             Token.serializer().serialize(range.right, out);
0:         }
0: 
0:         public AbstractBounds deserialize(DataInput in) throws IOException
0:         {
0:             if (in.readInt() == Type.RANGE.ordinal())
0:                 return new Range(Token.serializer().deserialize(in), Token.serializer().deserialize(in));
0:             return new Bounds(Token.serializer().deserialize(in), Token.serializer().deserialize(in));
0:         }
0:     }
0: }
0: 
commit:9cc51b5
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
0: import java.io.Serializable;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     protected transient final IPartitioner partitioner;
0: 
0:     public AbstractBounds(Token left, Token right, IPartitioner partitioner)
0:         this.partitioner = partitioner;
0:     @Override
0:     public int hashCode()
0:     {
0:         return toString().hashCode();
0:     }
0: 
0:     @Override
0:     public abstract boolean equals(Object obj);
0: 
0:     public abstract boolean contains(Token start);
0: 
0:     public abstract Set<AbstractBounds> restrictTo(Range range);
0: 
0:     public abstract List<AbstractBounds> unwrap();
commit:dfdb54a
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractBounds implements Serializable
commit:5a1e73d
/////////////////////////////////////////////////////////////////////////
0:     private static AbstractBoundsSerializer serializer = new AbstractBoundsSerializer();
0: 
0:     public static ICompactSerializer2<AbstractBounds> serializer()
0:     {
0:         return serializer;
0:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static class AbstractBoundsSerializer implements ICompactSerializer2<AbstractBounds>
commit:2f99e71
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.dht;
0: 
0: import java.io.*;
0: import java.util.List;
0: 
0: import org.apache.cassandra.io.ICompactSerializer2;
0: 
0: public abstract class AbstractBounds
0: {
0:     private static BoundsSerializer serializer_ = new BoundsSerializer();
0: 
0:     private enum Type
0:     {
0:         RANGE,
0:         BOUNDS
0:     }
0: 
0:     public static ICompactSerializer2<AbstractBounds> serializer()
0:     {
0:         return serializer_;
0:     }
0: 
0:     public final Token left;
0:     public final Token right;
0: 
0:     public AbstractBounds(Token left, Token right)
0:     {
0:         this.left = left;
0:         this.right = right;
0:     }
0: 
0:     public abstract List<AbstractBounds> restrictTo(Range range);
0: 
0:     private static class BoundsSerializer implements ICompactSerializer2<AbstractBounds>
0:     {
0:         public void serialize(AbstractBounds range, DataOutput out) throws IOException
0:         {
0:             out.writeInt(range instanceof Range ? Type.RANGE.ordinal() : Type.BOUNDS.ordinal());
0:             Token.serializer().serialize(range.left, out);
0:             Token.serializer().serialize(range.right, out);
0:         }
0: 
0:         public AbstractBounds deserialize(DataInput in) throws IOException
0:         {
0:             if (in.readInt() == Type.RANGE.ordinal())
0:                 return new Range(Token.serializer().deserialize(in), Token.serializer().deserialize(in));
0:             return new Bounds(Token.serializer().deserialize(in), Token.serializer().deserialize(in));
0:         }
0:     }
0: }
0: 
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:587cb58
/////////////////////////////////////////////////////////////////////////
0:     public static final AbstractBoundsSerializer serializer = new AbstractBoundsSerializer();
/////////////////////////////////////////////////////////////////////////
0:                 Token.serializer.serialize((Token)range.left, out);
0:                 Token.serializer.serialize((Token)range.right, out);
0:                 RowPosition.serializer.serialize((RowPosition)range.left, out);
0:                 RowPosition.serializer.serialize((RowPosition)range.right, out);
/////////////////////////////////////////////////////////////////////////
0:                 left = Token.serializer.deserialize(in);
0:                 right = Token.serializer.deserialize(in);
0:                 left = RowPosition.serializer.deserialize(in);
0:                 right = RowPosition.serializer.deserialize(in);
/////////////////////////////////////////////////////////////////////////
0:                 size += Token.serializer.serializedSize((Token) ab.left, DBTypeSizes.NATIVE);
0:                 size += Token.serializer.serializedSize((Token) ab.right, DBTypeSizes.NATIVE);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.left, DBTypeSizes.NATIVE);
0:                 size += RowPosition.serializer.serializedSize((RowPosition) ab.right, DBTypeSizes.NATIVE);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:e970b03
/////////////////////////////////////////////////////////////////////////
0:                 "Overlapping ranges passed to normalize: see CASSANDRA-2641: " + previous + " and " + unwrapped;
============================================================================