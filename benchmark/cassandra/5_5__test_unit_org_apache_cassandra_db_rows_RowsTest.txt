1:b263af9: /*
1:b263af9:  * Licensed to the Apache Software Foundation (ASF) under one
1:b263af9:  * or more contributor license agreements.  See the NOTICE file
1:b263af9:  * distributed with this work for additional information
1:b263af9:  * regarding copyright ownership.  The ASF licenses this file
1:b263af9:  * to you under the Apache License, Version 2.0 (the
1:b263af9:  * "License"); you may not use this file except in compliance
1:b263af9:  * with the License.  You may obtain a copy of the License at
1:b263af9:  *
1:b263af9:  *     http://www.apache.org/licenses/LICENSE-2.0
1:b263af9:  *
1:b263af9:  * Unless required by applicable law or agreed to in writing, software
1:b263af9:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b263af9:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b263af9:  * See the License for the specific language governing permissions and
1:b263af9:  * limitations under the License.
1:b263af9:  */
1:b263af9: 
1:b263af9: package org.apache.cassandra.db.rows;
1:b263af9: 
1:b263af9: import java.math.BigInteger;
1:b263af9: import java.nio.ByteBuffer;
1:b263af9: import java.util.Collections;
1:b263af9: import java.util.HashMap;
1:b263af9: import java.util.LinkedList;
1:b263af9: import java.util.List;
1:b263af9: import java.util.Map;
1:b263af9: import java.util.Set;
1:b263af9: 
1:b263af9: import com.google.common.collect.ImmutableMap;
1:b263af9: import com.google.common.collect.Lists;
1:b263af9: import com.google.common.collect.Sets;
1:b263af9: import org.junit.Assert;
1:b263af9: import org.junit.Test;
1:b263af9: 
1:b263af9: import org.apache.cassandra.config.CFMetaData;
1:b263af9: import org.apache.cassandra.config.ColumnDefinition;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:b263af9: import org.apache.cassandra.cql3.ColumnIdentifier;
1:b263af9: import org.apache.cassandra.db.Clustering;
1:b263af9: import org.apache.cassandra.db.DeletionTime;
1:b263af9: import org.apache.cassandra.db.LivenessInfo;
1:d413ddf: import org.apache.cassandra.db.marshal.*;
1:b263af9: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
1:b263af9: import org.apache.cassandra.utils.ByteBufferUtil;
1:b263af9: import org.apache.cassandra.utils.FBUtilities;
1:b263af9: import org.apache.cassandra.utils.Pair;
1:b263af9: 
1:b263af9: public class RowsTest
1:b263af9: {
1:b263af9:     private static final String KEYSPACE = "rows_test";
1:b263af9:     private static final String KCVM_TABLE = "kcvm";
1:b263af9:     private static final CFMetaData kcvm;
1:b263af9:     private static final ColumnDefinition v;
1:b263af9:     private static final ColumnDefinition m;
1:b263af9:     private static final Clustering c1;
1:b263af9: 
1:b263af9:     static
1:b263af9:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:b263af9:         kcvm = CFMetaData.Builder.create(KEYSPACE, KCVM_TABLE)
1:b263af9:                                  .addPartitionKey("k", IntegerType.instance)
1:b263af9:                                  .addClusteringColumn("c", IntegerType.instance)
1:b263af9:                                  .addRegularColumn("v", IntegerType.instance)
1:b263af9:                                  .addRegularColumn("m", MapType.getInstance(IntegerType.instance, IntegerType.instance, true))
1:b263af9:                                  .build();
1:b263af9: 
1:b263af9:         v = kcvm.getColumnDefinition(new ColumnIdentifier("v", false));
1:b263af9:         m = kcvm.getColumnDefinition(new ColumnIdentifier("m", false));
1:b263af9:         c1 = kcvm.comparator.make(BigInteger.valueOf(1));
1:b263af9:     }
1:b263af9: 
1:b263af9:     private static final ByteBuffer BB1 = ByteBufferUtil.bytes(1);
1:b263af9:     private static final ByteBuffer BB2 = ByteBufferUtil.bytes(2);
1:b263af9:     private static final ByteBuffer BB3 = ByteBufferUtil.bytes(3);
1:b263af9:     private static final ByteBuffer BB4 = ByteBufferUtil.bytes(4);
1:b263af9: 
1:b263af9:     private static class MergedPair<T>
1:b263af9:     {
1:b263af9:         public final int idx;
1:b263af9:         public final T merged;
1:b263af9:         public final T original;
1:b263af9: 
1:b263af9:         private MergedPair(int idx, T merged, T original)
1:b263af9:         {
1:b263af9:             this.idx = idx;
1:b263af9:             this.merged = merged;
1:b263af9:             this.original = original;
1:b263af9:         }
1:b263af9: 
1:b263af9:         static <T> MergedPair<T> create(int i, T m, T o)
1:b263af9:         {
1:b263af9:             return new MergedPair<>(i, m, o);
1:b263af9:         }
1:b263af9: 
1:b263af9:         public boolean equals(Object o)
1:b263af9:         {
1:b263af9:             if (this == o) return true;
1:b263af9:             if (o == null || getClass() != o.getClass()) return false;
1:b263af9: 
1:b263af9:             MergedPair<?> that = (MergedPair<?>) o;
1:b263af9: 
1:b263af9:             if (idx != that.idx) return false;
1:b263af9:             if (merged != null ? !merged.equals(that.merged) : that.merged != null) return false;
1:b263af9:             return !(original != null ? !original.equals(that.original) : that.original != null);
1:b263af9:         }
1:b263af9: 
1:b263af9:         public int hashCode()
1:b263af9:         {
1:b263af9:             int result = idx;
1:b263af9:             result = 31 * result + (merged != null ? merged.hashCode() : 0);
1:b263af9:             result = 31 * result + (original != null ? original.hashCode() : 0);
1:b263af9:             return result;
1:b263af9:         }
1:b263af9: 
1:b263af9:         public String toString()
1:b263af9:         {
1:b263af9:             return "MergedPair{" +
1:b263af9:                    "idx=" + idx +
1:b263af9:                    ", merged=" + merged +
1:b263af9:                    ", original=" + original +
1:b263af9:                    '}';
1:b263af9:         }
1:b263af9:     }
1:b263af9: 
1:b263af9:     private static class DiffListener implements RowDiffListener
1:b263af9:     {
1:b263af9:         int updates = 0;
1:b263af9:         Clustering clustering = null;
1:b263af9: 
1:b263af9:         private void updateClustering(Clustering c)
1:b263af9:         {
1:b263af9:             assert clustering == null || clustering == c;
1:b263af9:             clustering = c;
1:b263af9:         }
1:b263af9: 
1:b263af9:         List<MergedPair<Cell>> cells = new LinkedList<>();
1:b263af9:         public void onCell(int i, Clustering clustering, Cell merged, Cell original)
1:b263af9:         {
1:b263af9:             updateClustering(clustering);
1:b263af9:             cells.add(MergedPair.create(i, merged, original));
1:b263af9:             updates++;
1:b263af9:         }
1:b263af9: 
1:b263af9:         List<MergedPair<LivenessInfo>> liveness = new LinkedList<>();
1:b263af9:         public void onPrimaryKeyLivenessInfo(int i, Clustering clustering, LivenessInfo merged, LivenessInfo original)
1:b263af9:         {
1:b263af9:             updateClustering(clustering);
1:b263af9:             liveness.add(MergedPair.create(i, merged, original));
1:b263af9:             updates++;
1:b263af9:         }
1:b263af9: 
1:0633637:         List<MergedPair<Row.Deletion>> deletions = new LinkedList<>();
1:0633637:         public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original)
1:b263af9:         {
1:b263af9:             updateClustering(clustering);
1:b263af9:             deletions.add(MergedPair.create(i, merged, original));
1:b263af9:             updates++;
1:b263af9:         }
1:b263af9: 
1:b263af9:         Map<ColumnDefinition, List<MergedPair<DeletionTime>>> complexDeletions = new HashMap<>();
1:b263af9:         public void onComplexDeletion(int i, Clustering clustering, ColumnDefinition column, DeletionTime merged, DeletionTime original)
1:b263af9:         {
1:b263af9:             updateClustering(clustering);
1:b263af9:             if (!complexDeletions.containsKey(column)) complexDeletions.put(column, new LinkedList<>());
1:b263af9:             complexDeletions.get(column).add(MergedPair.create(i, merged, original));
1:b263af9:             updates++;
1:b263af9:         }
1:b263af9:     }
1:b263af9: 
1:b263af9:     public static class StatsCollector implements PartitionStatisticsCollector
1:b263af9:     {
1:b263af9:         List<Cell> cells = new LinkedList<>();
1:b263af9:         public void update(Cell cell)
1:b263af9:         {
1:b263af9:             cells.add(cell);
1:b263af9:         }
1:b263af9: 
1:b263af9:         List<LivenessInfo> liveness = new LinkedList<>();
1:b263af9:         public void update(LivenessInfo info)
1:b263af9:         {
1:b263af9:             liveness.add(info);
1:b263af9:         }
1:b263af9: 
1:b263af9:         List<DeletionTime> deletions = new LinkedList<>();
1:b263af9:         public void update(DeletionTime deletion)
1:b263af9:         {
1:b263af9:             deletions.add(deletion);
1:b263af9:         }
1:b263af9: 
1:b263af9:         long columnCount = -1;
1:b263af9:         public void updateColumnSetPerRow(long columnSetInRow)
1:b263af9:         {
1:b263af9:             assert columnCount < 0;
1:b263af9:             this.columnCount = columnSetInRow;
1:b263af9:         }
1:b263af9: 
1:b263af9:         boolean hasLegacyCounterShards = false;
1:b263af9:         public void updateHasLegacyCounterShards(boolean hasLegacyCounterShards)
1:b263af9:         {
1:b263af9:             this.hasLegacyCounterShards |= hasLegacyCounterShards;
1:b263af9:         }
1:b263af9:     }
1:b263af9: 
1:b263af9:     private static long secondToTs(int now)
1:b263af9:     {
1:b263af9:         return now * 1000000;
1:b263af9:     }
1:b263af9: 
1:b263af9:     private static Row.Builder createBuilder(Clustering c, int now, ByteBuffer vVal, ByteBuffer mKey, ByteBuffer mVal)
1:b263af9:     {
1:b263af9:         long ts = secondToTs(now);
1:b263af9:         Row.Builder builder = BTreeRow.unsortedBuilder(now);
1:b263af9:         builder.newRow(c);
1:e017f94:         builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(ts, now));
1:b263af9:         if (vVal != null)
1:b263af9:         {
1:e017f94:             builder.addCell(BufferCell.live(v, ts, vVal));
1:b263af9:         }
1:b263af9:         if (mKey != null && mVal != null)
1:b263af9:         {
1:b263af9:             builder.addComplexDeletion(m, new DeletionTime(ts - 1, now));
1:e017f94:             builder.addCell(BufferCell.live(m, ts, mVal, CellPath.create(mKey)));
1:b263af9:         }
1:b263af9: 
1:b263af9:         return builder;
1:b263af9:     }
1:b263af9: 
1:b263af9:     @Test
1:b263af9:     public void copy()
1:b263af9:     {
1:b263af9:         int now = FBUtilities.nowInSeconds();
1:b263af9:         long ts = secondToTs(now);
1:b263af9:         Row.Builder originalBuilder = BTreeRow.unsortedBuilder(now);
1:b263af9:         originalBuilder.newRow(c1);
1:e017f94:         LivenessInfo liveness = LivenessInfo.create(ts, now);
1:b263af9:         originalBuilder.addPrimaryKeyLivenessInfo(liveness);
1:b263af9:         DeletionTime complexDeletion = new DeletionTime(ts-1, now);
1:b263af9:         originalBuilder.addComplexDeletion(m, complexDeletion);
1:e017f94:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(v, secondToTs(now), BB1),
1:e017f94:                                                       BufferCell.live(m, secondToTs(now), BB1, CellPath.create(BB1)),
1:e017f94:                                                       BufferCell.live(m, secondToTs(now), BB2, CellPath.create(BB2)));
1:b263af9:         expectedCells.forEach(originalBuilder::addCell);
1:86ba227:         // We need to use ts-1 so the deletion doesn't shadow what we've created
1:86ba227:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts-1, now), false);
1:b263af9:         originalBuilder.addRowDeletion(rowDeletion);
1:b263af9: 
1:b263af9:         RowBuilder builder = new RowBuilder();
1:b263af9:         Rows.copy(originalBuilder.build(), builder);
1:b263af9: 
1:b263af9:         Assert.assertEquals(c1, builder.clustering);
1:b263af9:         Assert.assertEquals(liveness, builder.livenessInfo);
1:b263af9:         Assert.assertEquals(rowDeletion, builder.deletionTime);
1:b263af9:         Assert.assertEquals(Lists.newArrayList(Pair.create(m, complexDeletion)), builder.complexDeletions);
1:b263af9:         Assert.assertEquals(Sets.newHashSet(expectedCells), Sets.newHashSet(builder.cells));
1:b263af9:     }
1:b263af9: 
1:b263af9:     @Test
1:b263af9:     public void collectStats()
1:b263af9:     {
1:b263af9:         int now = FBUtilities.nowInSeconds();
1:b263af9:         long ts = secondToTs(now);
1:b263af9:         Row.Builder builder = BTreeRow.unsortedBuilder(now);
1:b263af9:         builder.newRow(c1);
1:e017f94:         LivenessInfo liveness = LivenessInfo.create(ts, now);
1:b263af9:         builder.addPrimaryKeyLivenessInfo(liveness);
1:b263af9:         DeletionTime complexDeletion = new DeletionTime(ts-1, now);
1:b263af9:         builder.addComplexDeletion(m, complexDeletion);
1:e017f94:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(v, ts, BB1),
1:e017f94:                                                       BufferCell.live(m, ts, BB1, CellPath.create(BB1)),
1:e017f94:                                                       BufferCell.live(m, ts, BB2, CellPath.create(BB2)));
1:b263af9:         expectedCells.forEach(builder::addCell);
1:86ba227:         // We need to use ts-1 so the deletion doesn't shadow what we've created
1:86ba227:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts-1, now), false);
1:b263af9:         builder.addRowDeletion(rowDeletion);
1:b263af9: 
1:b263af9:         StatsCollector collector = new StatsCollector();
1:b263af9:         Rows.collectStats(builder.build(), collector);
1:b263af9: 
1:b263af9:         Assert.assertEquals(Lists.newArrayList(liveness), collector.liveness);
1:0633637:         Assert.assertEquals(Sets.newHashSet(rowDeletion.time(), complexDeletion), Sets.newHashSet(collector.deletions));
1:b263af9:         Assert.assertEquals(Sets.newHashSet(expectedCells), Sets.newHashSet(collector.cells));
1:b263af9:         Assert.assertEquals(2, collector.columnCount);
1:b263af9:         Assert.assertFalse(collector.hasLegacyCounterShards);
1:b263af9:     }
1:b263af9: 
1:b263af9: 
1:b263af9:     public static void addExpectedCells(Set<MergedPair<Cell>> dst, Cell merged, Cell... inputs)
1:b263af9:     {
1:b263af9:         for (int i=0; i<inputs.length; i++)
1:b263af9:         {
1:b263af9:             dst.add(MergedPair.create(i, merged, inputs[i]));
1:b263af9:         }
1:b263af9:     }
1:b263af9: 
1:b263af9:     @Test
1:b263af9:     public void diff()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         long ts1 = secondToTs(now1);
1:b263af9:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:b263af9:         r1Builder.newRow(c1);
1:e017f94:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
1:b263af9:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1:b263af9:         DeletionTime r1ComplexDeletion = new DeletionTime(ts1-1, now1);
1:b263af9:         r1Builder.addComplexDeletion(m, r1ComplexDeletion);
1:b263af9: 
1:e017f94:         Cell r1v = BufferCell.live(v, ts1, BB1);
1:e017f94:         Cell r1m1 = BufferCell.live(m, ts1, BB1, CellPath.create(BB1));
1:e017f94:         Cell r1m2 = BufferCell.live(m, ts1, BB2, CellPath.create(BB2));
1:b263af9:         List<Cell> r1ExpectedCells = Lists.newArrayList(r1v, r1m1, r1m2);
1:b263af9: 
1:b263af9:         r1ExpectedCells.forEach(r1Builder::addCell);
1:b263af9: 
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         long ts2 = secondToTs(now2);
1:b263af9:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:b263af9:         r2Builder.newRow(c1);
1:e017f94:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:b263af9:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
1:e017f94:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:e017f94:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:e017f94:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:e017f94:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
1:b263af9:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1:b263af9: 
1:b263af9:         r2ExpectedCells.forEach(r2Builder::addCell);
1:0633637:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 2, now2), false);
1:b263af9:         r2Builder.addRowDeletion(r2RowDeletion);
1:b263af9: 
1:b263af9:         Row r1 = r1Builder.build();
1:b263af9:         Row r2 = r2Builder.build();
1:b263af9:         Row merged = Rows.merge(r1, r2, now2 + 1);
1:b263af9: 
1:b263af9:         Assert.assertEquals(r1ComplexDeletion, merged.getComplexColumnData(m).complexDeletion());
1:b263af9: 
1:b263af9:         DiffListener listener = new DiffListener();
1:b263af9:         Rows.diff(listener, merged, r1, r2);
1:b263af9: 
1:b263af9:         Assert.assertEquals(c1, listener.clustering);
1:b263af9: 
1:b263af9:         // check cells
1:b263af9:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet();
1:b263af9:         addExpectedCells(expectedCells, r2v,  r1v,  r2v);     // v
1:b263af9:         addExpectedCells(expectedCells, r1m1, r1m1, null);   // m[1]
1:b263af9:         addExpectedCells(expectedCells, r2m2, r1m2, r2m2);   // m[2]
1:b263af9:         addExpectedCells(expectedCells, r2m3, null, r2m3);   // m[3]
1:b263af9:         addExpectedCells(expectedCells, r2m4, null, r2m4);   // m[4]
1:b263af9: 
1:b263af9:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:b263af9:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1:b263af9: 
1:b263af9:         // liveness
1:b263af9:         List<MergedPair<LivenessInfo>> expectedLiveness = Lists.newArrayList(MergedPair.create(0, r2Liveness, r1Liveness),
1:b263af9:                                                                              MergedPair.create(1, r2Liveness, r2Liveness));
1:b263af9:         Assert.assertEquals(expectedLiveness, listener.liveness);
1:b263af9: 
1:b263af9:         // deletions
1:0633637:         List<MergedPair<Row.Deletion>> expectedDeletions = Lists.newArrayList(MergedPair.create(0, r2RowDeletion, null),
1:b263af9:                                                                               MergedPair.create(1, r2RowDeletion, r2RowDeletion));
1:b263af9:         Assert.assertEquals(expectedDeletions, listener.deletions);
1:b263af9: 
1:b263af9:         // complex deletions
1:b263af9:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, r1ComplexDeletion, r1ComplexDeletion),
1:b263af9:                                                                                    MergedPair.create(1, r1ComplexDeletion, DeletionTime.LIVE));
1:b263af9:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:b263af9:     }
1:b263af9: 
1:b263af9:     /**
1:b263af9:      * merged row has no column data
1:b263af9:      */
1:b263af9:     @Test
1:b263af9:     public void diffEmptyMerged()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         long ts1 = secondToTs(now1);
1:b263af9:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:b263af9:         r1Builder.newRow(c1);
1:e017f94:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
1:b263af9:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1:b263af9: 
1:b263af9:         // mergedData == null
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         long ts2 = secondToTs(now2);
1:b263af9:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:b263af9:         r2Builder.newRow(c1);
1:e017f94:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:b263af9:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
1:b263af9:         DeletionTime r2ComplexDeletion = new DeletionTime(ts2-1, now2);
1:b263af9:         r2Builder.addComplexDeletion(m, r2ComplexDeletion);
1:e017f94:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:e017f94:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:e017f94:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:e017f94:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
1:b263af9:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1:b263af9: 
1:b263af9:         r2ExpectedCells.forEach(r2Builder::addCell);
1:0633637:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 1, now2), false);
1:b263af9:         r2Builder.addRowDeletion(r2RowDeletion);
1:b263af9: 
1:b263af9:         Row r1 = r1Builder.build();
1:b263af9:         Row r2 = r2Builder.build();
1:b263af9: 
1:b263af9:         DiffListener listener = new DiffListener();
1:b263af9:         Rows.diff(listener, r1, r2);
1:b263af9: 
1:b263af9:         Assert.assertEquals(c1, listener.clustering);
1:b263af9: 
1:b263af9:         // check cells
1:b263af9:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet(MergedPair.create(0, null, r2v),   // v
1:b263af9:                                                               MergedPair.create(0, null, r2m2),  // m[2]
1:b263af9:                                                               MergedPair.create(0, null, r2m3),  // m[3]
1:b263af9:                                                               MergedPair.create(0, null, r2m4)); // m[4]
1:b263af9: 
1:b263af9:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:b263af9:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1:b263af9: 
1:b263af9:         // complex deletions
1:b263af9:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, null, r2ComplexDeletion));
1:b263af9:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:b263af9:     }
1:b263af9: 
1:b263af9:     /**
1:b263af9:      * input row has no column data
1:b263af9:      */
1:b263af9:     @Test
1:b263af9:     public void diffEmptyInput()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         long ts1 = secondToTs(now1);
1:b263af9:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:b263af9:         r1Builder.newRow(c1);
1:e017f94:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
1:b263af9:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1:b263af9: 
1:b263af9:         // mergedData == null
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         long ts2 = secondToTs(now2);
1:b263af9:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:b263af9:         r2Builder.newRow(c1);
1:e017f94:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:b263af9:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
1:b263af9:         DeletionTime r2ComplexDeletion = new DeletionTime(ts2-1, now2);
1:b263af9:         r2Builder.addComplexDeletion(m, r2ComplexDeletion);
1:e017f94:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:e017f94:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:e017f94:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:e017f94:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
1:b263af9:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1:b263af9: 
1:b263af9:         r2ExpectedCells.forEach(r2Builder::addCell);
1:0633637:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 1, now2), false);
1:b263af9:         r2Builder.addRowDeletion(r2RowDeletion);
1:b263af9: 
1:b263af9:         Row r1 = r1Builder.build();
1:b263af9:         Row r2 = r2Builder.build();
1:b263af9: 
1:b263af9:         DiffListener listener = new DiffListener();
1:b263af9:         Rows.diff(listener, r2, r1);
1:b263af9: 
1:b263af9:         Assert.assertEquals(c1, listener.clustering);
1:b263af9: 
1:b263af9:         // check cells
1:b263af9:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet(MergedPair.create(0, r2v, null),   // v
1:b263af9:                                                               MergedPair.create(0, r2m2, null),  // m[2]
1:b263af9:                                                               MergedPair.create(0, r2m3, null),  // m[3]
1:b263af9:                                                               MergedPair.create(0, r2m4, null)); // m[4]
1:b263af9: 
1:b263af9:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:b263af9:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1:b263af9: 
1:b263af9:         // complex deletions
1:b263af9:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, r2ComplexDeletion, null));
1:b263af9:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:b263af9:     }
1:b263af9: 
1:b263af9:     @Test
1:b263af9:     public void merge()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         Row.Builder existingBuilder = createBuilder(c1, now1, BB1, BB1, BB1);
1:b263af9: 
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         long ts2 = secondToTs(now2);
1:b263af9: 
1:e017f94:         Cell expectedVCell = BufferCell.live(v, ts2, BB2);
1:e017f94:         Cell expectedMCell = BufferCell.live(m, ts2, BB2, CellPath.create(BB1));
1:b263af9:         DeletionTime expectedComplexDeletionTime = new DeletionTime(ts2 - 1, now2);
1:b263af9: 
1:b263af9:         Row.Builder updateBuilder = createBuilder(c1, now2, null, null, null);
1:b263af9:         updateBuilder.addCell(expectedVCell);
1:b263af9:         updateBuilder.addComplexDeletion(m, expectedComplexDeletionTime);
1:b263af9:         updateBuilder.addCell(expectedMCell);
1:b263af9: 
1:b263af9:         RowBuilder builder = new RowBuilder();
1:b263af9:         long td = Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now2 + 1);
1:b263af9: 
1:b263af9:         Assert.assertEquals(c1, builder.clustering);
1:e017f94:         Assert.assertEquals(LivenessInfo.create(ts2, now2), builder.livenessInfo);
1:b263af9:         Assert.assertEquals(Lists.newArrayList(Pair.create(m, new DeletionTime(ts2-1, now2))), builder.complexDeletions);
1:b263af9: 
1:b263af9:         Assert.assertEquals(2, builder.cells.size());
1:b263af9:         Assert.assertEquals(Lists.newArrayList(expectedVCell, expectedMCell), Lists.newArrayList(builder.cells));
1:b263af9:         Assert.assertEquals(ts2 - secondToTs(now1), td);
1:b263af9:     }
1:b263af9: 
1:b263af9:     @Test
1:b263af9:     public void mergeComplexDeletionSupersededByRowDeletion()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         Row.Builder existingBuilder = createBuilder(c1, now1, null, null, null);
1:b263af9: 
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         Row.Builder updateBuilder = createBuilder(c1, now2, null, BB1, BB1);
1:b263af9:         int now3 = now2 + 1;
1:0633637:         Row.Deletion expectedDeletion = new Row.Deletion(new DeletionTime(secondToTs(now3), now3), false);
1:b263af9:         updateBuilder.addRowDeletion(expectedDeletion);
1:b263af9: 
1:b263af9:         RowBuilder builder = new RowBuilder();
1:b263af9:         Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now3 + 1);
1:b263af9: 
1:b263af9:         Assert.assertEquals(expectedDeletion, builder.deletionTime);
1:b263af9:         Assert.assertEquals(Collections.emptyList(), builder.complexDeletions);
1:b263af9:         Assert.assertEquals(Collections.emptyList(), builder.cells);
1:b263af9:     }
1:d413ddf: 
1:b263af9:     /**
1:b263af9:      * If a row's deletion time deletes a row's liveness info, the new row should have it's
1:b263af9:      * liveness info set to empty
1:b263af9:      */
1:b263af9:     @Test
1:b263af9:     public void mergeRowDeletionSupercedesLiveness()
1:b263af9:     {
1:b263af9:         int now1 = FBUtilities.nowInSeconds();
1:b263af9:         Row.Builder existingBuilder = createBuilder(c1, now1, null, null, null);
1:b263af9: 
1:b263af9:         int now2 = now1 + 1;
1:b263af9:         Row.Builder updateBuilder = createBuilder(c1, now2, BB1, BB1, BB1);
1:b263af9:         int now3 = now2 + 1;
1:0633637:         Row.Deletion expectedDeletion = new Row.Deletion(new DeletionTime(secondToTs(now3), now3), false);
1:b263af9:         updateBuilder.addRowDeletion(expectedDeletion);
1:b263af9: 
1:b263af9:         RowBuilder builder = new RowBuilder();
1:b263af9:         Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now3 + 1);
1:b263af9: 
1:b263af9:         Assert.assertEquals(expectedDeletion, builder.deletionTime);
1:b263af9:         Assert.assertEquals(LivenessInfo.EMPTY, builder.livenessInfo);
1:b263af9:         Assert.assertEquals(Collections.emptyList(), builder.complexDeletions);
1:b263af9:         Assert.assertEquals(Collections.emptyList(), builder.cells);
1:b263af9:     }
1:b263af9: 
1:d413ddf:     // Creates a dummy cell for a (regular) column for the provided name and without a cellPath.
1:d413ddf:     private static Cell liveCell(ColumnDefinition name)
1:d413ddf:     {
1:d413ddf:         return liveCell(name, -1);
1:d413ddf:     }
1:d413ddf: 
1:d413ddf:     // Creates a dummy cell for a (regular) column for the provided name.
1:d413ddf:     // If path >= 0, the cell will have a CellPath containing path as an Int32Type.
1:d413ddf:     private static Cell liveCell(ColumnDefinition name, int path)
1:d413ddf:     {
1:d413ddf:         CellPath cp = path < 0 ? null : CellPath.create(ByteBufferUtil.bytes(path));
1:d413ddf:         return new BufferCell(name, 0L, Cell.NO_TTL, Cell.NO_DELETION_TIME, ByteBuffer.allocate(1), cp);
1:d413ddf:     }
1:d413ddf: 
1:d413ddf:     // Assert that the cells generated by iterating iterable are the cell of cells (in the same order
1:d413ddf:     // and with neither more nor less cells).
1:d413ddf:     private static void assertCellOrder(Iterable<Cell> iterable, Cell... cells)
1:d413ddf:     {
1:d413ddf:         int i = 0;
1:d413ddf:         for (Cell actual : iterable)
1:d413ddf:         {
1:d413ddf:             Assert.assertFalse(String.format("Got more rows than expected (expecting %d). First unexpected cell is %s", cells.length, actual), i >= cells.length);
1:d413ddf:             Assert.assertEquals(cells[i++], actual);
1:d413ddf:         }
1:d413ddf:         Assert.assertFalse(String.format("Got less rows than expected (got %d while expecting %d).", i, cells.length), i < cells.length);
1:d413ddf:     }
1:d413ddf: 
1:d413ddf:     // Make a dummy row (empty clustering) with the provided cells, that are assumed to be in order
1:d413ddf:     private static Row makeDummyRow(Cell ... cells)
1:d413ddf:     {
1:d413ddf:         Row.Builder builder = BTreeRow.sortedBuilder();
1:d413ddf:         builder.newRow(Clustering.EMPTY);
1:d413ddf:         for (Cell cell : cells)
1:d413ddf:             builder.addCell(cell);
1:d413ddf: 
1:d413ddf:         return builder.build();
1:d413ddf:     }
1:d413ddf: 
1:d413ddf:     @Test
1:d413ddf:     public void testLegacyCellIterator()
1:d413ddf:     {
1:d413ddf:         // Creates a table with
1:d413ddf:         //   - 3 Simple columns: a, c and e
1:d413ddf:         //   - 2 Complex columns: b and d
1:d413ddf:         CFMetaData metadata = CFMetaData.Builder.create("dummy_ks", "dummy_tbl")
1:d413ddf:                                         .addPartitionKey("k", BytesType.instance)
1:d413ddf:                                         .addRegularColumn("a", BytesType.instance)
1:d413ddf:                                         .addRegularColumn("b", MapType.getInstance(Int32Type.instance, BytesType.instance, true))
1:d413ddf:                                         .addRegularColumn("c", BytesType.instance)
1:d413ddf:                                         .addRegularColumn("d", MapType.getInstance(Int32Type.instance, BytesType.instance, true))
1:d413ddf:                                         .addRegularColumn("e", BytesType.instance)
1:d413ddf:                                         .build();
1:d413ddf: 
1:d413ddf:         ColumnDefinition a = metadata.getColumnDefinition(new ColumnIdentifier("a", false));
1:d413ddf:         ColumnDefinition b = metadata.getColumnDefinition(new ColumnIdentifier("b", false));
1:d413ddf:         ColumnDefinition c = metadata.getColumnDefinition(new ColumnIdentifier("c", false));
1:d413ddf:         ColumnDefinition d = metadata.getColumnDefinition(new ColumnIdentifier("d", false));
1:d413ddf:         ColumnDefinition e = metadata.getColumnDefinition(new ColumnIdentifier("e", false));
1:d413ddf: 
1:d413ddf:         Row row;
1:d413ddf: 
1:d413ddf:         // Row with only simple columns
1:d413ddf: 
1:d413ddf:         row = makeDummyRow(liveCell(a),
1:d413ddf:                            liveCell(c),
1:d413ddf:                            liveCell(e));
1:d413ddf: 
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:d413ddf:                         liveCell(a),
1:d413ddf:                         liveCell(c),
1:d413ddf:                         liveCell(e));
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:d413ddf:                         liveCell(e),
1:d413ddf:                         liveCell(c),
1:d413ddf:                         liveCell(a));
1:d413ddf: 
1:d413ddf:         // Row with only complex columns
1:d413ddf: 
1:d413ddf:         row = makeDummyRow(liveCell(b, 1),
1:d413ddf:                            liveCell(b, 2),
1:d413ddf:                            liveCell(d, 3),
1:d413ddf:                            liveCell(d, 4));
1:d413ddf: 
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:d413ddf:                         liveCell(b, 1),
1:d413ddf:                         liveCell(b, 2),
1:d413ddf:                         liveCell(d, 3),
1:d413ddf:                         liveCell(d, 4));
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:d413ddf:                         liveCell(d, 4),
1:d413ddf:                         liveCell(d, 3),
1:d413ddf:                         liveCell(b, 2),
1:d413ddf:                         liveCell(b, 1));
1:d413ddf: 
1:d413ddf:         // Row with mixed simple and complex columns
1:d413ddf: 
1:d413ddf:         row = makeDummyRow(liveCell(a),
1:d413ddf:                            liveCell(c),
1:d413ddf:                            liveCell(e),
1:d413ddf:                            liveCell(b, 1),
1:d413ddf:                            liveCell(b, 2),
1:d413ddf:                            liveCell(d, 3),
1:d413ddf:                            liveCell(d, 4));
1:d413ddf: 
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:d413ddf:                         liveCell(a),
1:d413ddf:                         liveCell(b, 1),
1:d413ddf:                         liveCell(b, 2),
1:d413ddf:                         liveCell(c),
1:d413ddf:                         liveCell(d, 3),
1:d413ddf:                         liveCell(d, 4),
1:d413ddf:                         liveCell(e));
1:d413ddf: 
1:d413ddf:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:d413ddf:                         liveCell(e),
1:d413ddf:                         liveCell(d, 4),
1:d413ddf:                         liveCell(d, 3),
1:d413ddf:                         liveCell(c),
1:d413ddf:                         liveCell(b, 2),
1:d413ddf:                         liveCell(b, 1),
1:d413ddf:                         liveCell(a));
1:d413ddf:     }
1:b263af9: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a87fd71
commit:86ba227
/////////////////////////////////////////////////////////////////////////
1:         // We need to use ts-1 so the deletion doesn't shadow what we've created
1:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts-1, now), false);
/////////////////////////////////////////////////////////////////////////
1:         // We need to use ts-1 so the deletion doesn't shadow what we've created
1:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts-1, now), false);
commit:d413ddf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Creates a dummy cell for a (regular) column for the provided name and without a cellPath.
1:     private static Cell liveCell(ColumnDefinition name)
1:     {
1:         return liveCell(name, -1);
1:     }
1: 
1:     // Creates a dummy cell for a (regular) column for the provided name.
1:     // If path >= 0, the cell will have a CellPath containing path as an Int32Type.
1:     private static Cell liveCell(ColumnDefinition name, int path)
1:     {
1:         CellPath cp = path < 0 ? null : CellPath.create(ByteBufferUtil.bytes(path));
1:         return new BufferCell(name, 0L, Cell.NO_TTL, Cell.NO_DELETION_TIME, ByteBuffer.allocate(1), cp);
1:     }
1: 
1:     // Assert that the cells generated by iterating iterable are the cell of cells (in the same order
1:     // and with neither more nor less cells).
1:     private static void assertCellOrder(Iterable<Cell> iterable, Cell... cells)
1:     {
1:         int i = 0;
1:         for (Cell actual : iterable)
1:         {
1:             Assert.assertFalse(String.format("Got more rows than expected (expecting %d). First unexpected cell is %s", cells.length, actual), i >= cells.length);
1:             Assert.assertEquals(cells[i++], actual);
1:         }
1:         Assert.assertFalse(String.format("Got less rows than expected (got %d while expecting %d).", i, cells.length), i < cells.length);
1:     }
1: 
1:     // Make a dummy row (empty clustering) with the provided cells, that are assumed to be in order
1:     private static Row makeDummyRow(Cell ... cells)
1:     {
1:         Row.Builder builder = BTreeRow.sortedBuilder();
1:         builder.newRow(Clustering.EMPTY);
1:         for (Cell cell : cells)
1:             builder.addCell(cell);
1: 
1:         return builder.build();
1:     }
1: 
1:     @Test
1:     public void testLegacyCellIterator()
1:     {
1:         // Creates a table with
1:         //   - 3 Simple columns: a, c and e
1:         //   - 2 Complex columns: b and d
1:         CFMetaData metadata = CFMetaData.Builder.create("dummy_ks", "dummy_tbl")
1:                                         .addPartitionKey("k", BytesType.instance)
1:                                         .addRegularColumn("a", BytesType.instance)
1:                                         .addRegularColumn("b", MapType.getInstance(Int32Type.instance, BytesType.instance, true))
1:                                         .addRegularColumn("c", BytesType.instance)
1:                                         .addRegularColumn("d", MapType.getInstance(Int32Type.instance, BytesType.instance, true))
1:                                         .addRegularColumn("e", BytesType.instance)
1:                                         .build();
1: 
1:         ColumnDefinition a = metadata.getColumnDefinition(new ColumnIdentifier("a", false));
1:         ColumnDefinition b = metadata.getColumnDefinition(new ColumnIdentifier("b", false));
1:         ColumnDefinition c = metadata.getColumnDefinition(new ColumnIdentifier("c", false));
1:         ColumnDefinition d = metadata.getColumnDefinition(new ColumnIdentifier("d", false));
1:         ColumnDefinition e = metadata.getColumnDefinition(new ColumnIdentifier("e", false));
1: 
1:         Row row;
1: 
1:         // Row with only simple columns
1: 
1:         row = makeDummyRow(liveCell(a),
1:                            liveCell(c),
1:                            liveCell(e));
1: 
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:                         liveCell(a),
1:                         liveCell(c),
1:                         liveCell(e));
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:                         liveCell(e),
1:                         liveCell(c),
1:                         liveCell(a));
1: 
1:         // Row with only complex columns
1: 
1:         row = makeDummyRow(liveCell(b, 1),
1:                            liveCell(b, 2),
1:                            liveCell(d, 3),
1:                            liveCell(d, 4));
1: 
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:                         liveCell(b, 1),
1:                         liveCell(b, 2),
1:                         liveCell(d, 3),
1:                         liveCell(d, 4));
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:                         liveCell(d, 4),
1:                         liveCell(d, 3),
1:                         liveCell(b, 2),
1:                         liveCell(b, 1));
1: 
1:         // Row with mixed simple and complex columns
1: 
1:         row = makeDummyRow(liveCell(a),
1:                            liveCell(c),
1:                            liveCell(e),
1:                            liveCell(b, 1),
1:                            liveCell(b, 2),
1:                            liveCell(d, 3),
1:                            liveCell(d, 4));
1: 
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, false),
1:                         liveCell(a),
1:                         liveCell(b, 1),
1:                         liveCell(b, 2),
1:                         liveCell(c),
1:                         liveCell(d, 3),
1:                         liveCell(d, 4),
1:                         liveCell(e));
1: 
1:         assertCellOrder(row.cellsInLegacyOrder(metadata, true),
1:                         liveCell(e),
1:                         liveCell(d, 4),
1:                         liveCell(d, 3),
1:                         liveCell(c),
1:                         liveCell(b, 2),
1:                         liveCell(b, 1),
1:                         liveCell(a));
1:     }
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1:         builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(ts, now));
1:             builder.addCell(BufferCell.live(v, ts, vVal));
1:             builder.addCell(BufferCell.live(m, ts, mVal, CellPath.create(mKey)));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo liveness = LivenessInfo.create(ts, now);
1:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(v, secondToTs(now), BB1),
1:                                                       BufferCell.live(m, secondToTs(now), BB1, CellPath.create(BB1)),
1:                                                       BufferCell.live(m, secondToTs(now), BB2, CellPath.create(BB2)));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo liveness = LivenessInfo.create(ts, now);
1:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(v, ts, BB1),
1:                                                       BufferCell.live(m, ts, BB1, CellPath.create(BB1)),
1:                                                       BufferCell.live(m, ts, BB2, CellPath.create(BB2)));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
1:         Cell r1v = BufferCell.live(v, ts1, BB1);
1:         Cell r1m1 = BufferCell.live(m, ts1, BB1, CellPath.create(BB1));
1:         Cell r1m2 = BufferCell.live(m, ts1, BB2, CellPath.create(BB2));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r1Liveness = LivenessInfo.create(ts1, now1);
/////////////////////////////////////////////////////////////////////////
1:         LivenessInfo r2Liveness = LivenessInfo.create(ts2, now2);
1:         Cell r2v = BufferCell.live(v, ts2, BB2);
1:         Cell r2m2 = BufferCell.live(m, ts2, BB1, CellPath.create(BB2));
1:         Cell r2m3 = BufferCell.live(m, ts2, BB2, CellPath.create(BB3));
1:         Cell r2m4 = BufferCell.live(m, ts2, BB3, CellPath.create(BB4));
/////////////////////////////////////////////////////////////////////////
1:         Cell expectedVCell = BufferCell.live(v, ts2, BB2);
1:         Cell expectedMCell = BufferCell.live(m, ts2, BB2, CellPath.create(BB1));
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals(LivenessInfo.create(ts2, now2), builder.livenessInfo);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:0633637
/////////////////////////////////////////////////////////////////////////
1:         List<MergedPair<Row.Deletion>> deletions = new LinkedList<>();
1:         public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original)
/////////////////////////////////////////////////////////////////////////
0:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts, now), false);
/////////////////////////////////////////////////////////////////////////
0:         Row.Deletion rowDeletion = new Row.Deletion(new DeletionTime(ts, now), false);
1:         Assert.assertEquals(Sets.newHashSet(rowDeletion.time(), complexDeletion), Sets.newHashSet(collector.deletions));
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 2, now2), false);
/////////////////////////////////////////////////////////////////////////
1:         List<MergedPair<Row.Deletion>> expectedDeletions = Lists.newArrayList(MergedPair.create(0, r2RowDeletion, null),
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 1, now2), false);
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion r2RowDeletion = new Row.Deletion(new DeletionTime(ts1 - 1, now2), false);
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion expectedDeletion = new Row.Deletion(new DeletionTime(secondToTs(now3), now3), false);
/////////////////////////////////////////////////////////////////////////
1:         Row.Deletion expectedDeletion = new Row.Deletion(new DeletionTime(secondToTs(now3), now3), false);
author:Blake Eggleston
-------------------------------------------------------------------------------
commit:b263af9
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.db.rows;
1: 
1: import java.math.BigInteger;
1: import java.nio.ByteBuffer;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import com.google.common.collect.ImmutableMap;
1: import com.google.common.collect.Lists;
1: import com.google.common.collect.Sets;
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.Clustering;
1: import org.apache.cassandra.db.DeletionTime;
1: import org.apache.cassandra.db.LivenessInfo;
0: import org.apache.cassandra.db.marshal.IntegerType;
0: import org.apache.cassandra.db.marshal.MapType;
1: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.Pair;
1: 
1: public class RowsTest
1: {
1:     private static final String KEYSPACE = "rows_test";
1:     private static final String KCVM_TABLE = "kcvm";
1:     private static final CFMetaData kcvm;
1:     private static final ColumnDefinition v;
1:     private static final ColumnDefinition m;
1:     private static final Clustering c1;
1: 
1:     static
1:     {
1:         kcvm = CFMetaData.Builder.create(KEYSPACE, KCVM_TABLE)
1:                                  .addPartitionKey("k", IntegerType.instance)
1:                                  .addClusteringColumn("c", IntegerType.instance)
1:                                  .addRegularColumn("v", IntegerType.instance)
1:                                  .addRegularColumn("m", MapType.getInstance(IntegerType.instance, IntegerType.instance, true))
1:                                  .build();
1: 
1:         v = kcvm.getColumnDefinition(new ColumnIdentifier("v", false));
1:         m = kcvm.getColumnDefinition(new ColumnIdentifier("m", false));
1:         c1 = kcvm.comparator.make(BigInteger.valueOf(1));
1:     }
1: 
1:     private static final ByteBuffer BB1 = ByteBufferUtil.bytes(1);
1:     private static final ByteBuffer BB2 = ByteBufferUtil.bytes(2);
1:     private static final ByteBuffer BB3 = ByteBufferUtil.bytes(3);
1:     private static final ByteBuffer BB4 = ByteBufferUtil.bytes(4);
1: 
1:     private static class MergedPair<T>
1:     {
1:         public final int idx;
1:         public final T merged;
1:         public final T original;
1: 
1:         private MergedPair(int idx, T merged, T original)
1:         {
1:             this.idx = idx;
1:             this.merged = merged;
1:             this.original = original;
1:         }
1: 
1:         static <T> MergedPair<T> create(int i, T m, T o)
1:         {
1:             return new MergedPair<>(i, m, o);
1:         }
1: 
1:         public boolean equals(Object o)
1:         {
1:             if (this == o) return true;
1:             if (o == null || getClass() != o.getClass()) return false;
1: 
1:             MergedPair<?> that = (MergedPair<?>) o;
1: 
1:             if (idx != that.idx) return false;
1:             if (merged != null ? !merged.equals(that.merged) : that.merged != null) return false;
1:             return !(original != null ? !original.equals(that.original) : that.original != null);
1:         }
1: 
1:         public int hashCode()
1:         {
1:             int result = idx;
1:             result = 31 * result + (merged != null ? merged.hashCode() : 0);
1:             result = 31 * result + (original != null ? original.hashCode() : 0);
1:             return result;
1:         }
1: 
1:         public String toString()
1:         {
1:             return "MergedPair{" +
1:                    "idx=" + idx +
1:                    ", merged=" + merged +
1:                    ", original=" + original +
1:                    '}';
1:         }
1:     }
1: 
1:     private static class DiffListener implements RowDiffListener
1:     {
1:         int updates = 0;
1:         Clustering clustering = null;
1: 
1:         private void updateClustering(Clustering c)
1:         {
1:             assert clustering == null || clustering == c;
1:             clustering = c;
1:         }
1: 
1:         List<MergedPair<Cell>> cells = new LinkedList<>();
1:         public void onCell(int i, Clustering clustering, Cell merged, Cell original)
1:         {
1:             updateClustering(clustering);
1:             cells.add(MergedPair.create(i, merged, original));
1:             updates++;
1:         }
1: 
1:         List<MergedPair<LivenessInfo>> liveness = new LinkedList<>();
1:         public void onPrimaryKeyLivenessInfo(int i, Clustering clustering, LivenessInfo merged, LivenessInfo original)
1:         {
1:             updateClustering(clustering);
1:             liveness.add(MergedPair.create(i, merged, original));
1:             updates++;
1:         }
1: 
0:         List<MergedPair<DeletionTime>> deletions = new LinkedList<>();
0:         public void onDeletion(int i, Clustering clustering, DeletionTime merged, DeletionTime original)
1:         {
1:             updateClustering(clustering);
1:             deletions.add(MergedPair.create(i, merged, original));
1:             updates++;
1:         }
1: 
1:         Map<ColumnDefinition, List<MergedPair<DeletionTime>>> complexDeletions = new HashMap<>();
1:         public void onComplexDeletion(int i, Clustering clustering, ColumnDefinition column, DeletionTime merged, DeletionTime original)
1:         {
1:             updateClustering(clustering);
1:             if (!complexDeletions.containsKey(column)) complexDeletions.put(column, new LinkedList<>());
1:             complexDeletions.get(column).add(MergedPair.create(i, merged, original));
1:             updates++;
1:         }
1:     }
1: 
1:     public static class StatsCollector implements PartitionStatisticsCollector
1:     {
1:         List<Cell> cells = new LinkedList<>();
1:         public void update(Cell cell)
1:         {
1:             cells.add(cell);
1:         }
1: 
1:         List<LivenessInfo> liveness = new LinkedList<>();
1:         public void update(LivenessInfo info)
1:         {
1:             liveness.add(info);
1:         }
1: 
1:         List<DeletionTime> deletions = new LinkedList<>();
1:         public void update(DeletionTime deletion)
1:         {
1:             deletions.add(deletion);
1:         }
1: 
1:         long columnCount = -1;
1:         public void updateColumnSetPerRow(long columnSetInRow)
1:         {
1:             assert columnCount < 0;
1:             this.columnCount = columnSetInRow;
1:         }
1: 
1:         boolean hasLegacyCounterShards = false;
1:         public void updateHasLegacyCounterShards(boolean hasLegacyCounterShards)
1:         {
1:             this.hasLegacyCounterShards |= hasLegacyCounterShards;
1:         }
1:     }
1: 
1:     private static long secondToTs(int now)
1:     {
1:         return now * 1000000;
1:     }
1: 
1:     private static Row.Builder createBuilder(Clustering c, int now, ByteBuffer vVal, ByteBuffer mKey, ByteBuffer mVal)
1:     {
1:         long ts = secondToTs(now);
1:         Row.Builder builder = BTreeRow.unsortedBuilder(now);
1:         builder.newRow(c);
0:         builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(kcvm, ts, now));
1:         if (vVal != null)
1:         {
0:             builder.addCell(BufferCell.live(kcvm, v, ts, vVal));
1:         }
1:         if (mKey != null && mVal != null)
1:         {
1:             builder.addComplexDeletion(m, new DeletionTime(ts - 1, now));
0:             builder.addCell(BufferCell.live(kcvm, m, ts, mVal, CellPath.create(mKey)));
1:         }
1: 
1:         return builder;
1:     }
1: 
1:     @Test
1:     public void copy()
1:     {
1:         int now = FBUtilities.nowInSeconds();
1:         long ts = secondToTs(now);
1:         Row.Builder originalBuilder = BTreeRow.unsortedBuilder(now);
1:         originalBuilder.newRow(c1);
0:         LivenessInfo liveness = LivenessInfo.create(kcvm, ts, now);
1:         originalBuilder.addPrimaryKeyLivenessInfo(liveness);
1:         DeletionTime complexDeletion = new DeletionTime(ts-1, now);
1:         originalBuilder.addComplexDeletion(m, complexDeletion);
0:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(kcvm, v, secondToTs(now), BB1),
0:                                                       BufferCell.live(kcvm, m, secondToTs(now), BB1, CellPath.create(BB1)),
0:                                                       BufferCell.live(kcvm, m, secondToTs(now), BB2, CellPath.create(BB2)));
1:         expectedCells.forEach(originalBuilder::addCell);
0:         DeletionTime rowDeletion = new DeletionTime(ts, now);
1:         originalBuilder.addRowDeletion(rowDeletion);
1: 
1:         RowBuilder builder = new RowBuilder();
1:         Rows.copy(originalBuilder.build(), builder);
1: 
1:         Assert.assertEquals(c1, builder.clustering);
1:         Assert.assertEquals(liveness, builder.livenessInfo);
1:         Assert.assertEquals(rowDeletion, builder.deletionTime);
1:         Assert.assertEquals(Lists.newArrayList(Pair.create(m, complexDeletion)), builder.complexDeletions);
1:         Assert.assertEquals(Sets.newHashSet(expectedCells), Sets.newHashSet(builder.cells));
1:     }
1: 
1:     @Test
1:     public void collectStats()
1:     {
1:         int now = FBUtilities.nowInSeconds();
1:         long ts = secondToTs(now);
1:         Row.Builder builder = BTreeRow.unsortedBuilder(now);
1:         builder.newRow(c1);
0:         LivenessInfo liveness = LivenessInfo.create(kcvm, ts, now);
1:         builder.addPrimaryKeyLivenessInfo(liveness);
1:         DeletionTime complexDeletion = new DeletionTime(ts-1, now);
1:         builder.addComplexDeletion(m, complexDeletion);
0:         List<Cell> expectedCells = Lists.newArrayList(BufferCell.live(kcvm, v, ts, BB1),
0:                                                       BufferCell.live(kcvm, m, ts, BB1, CellPath.create(BB1)),
0:                                                       BufferCell.live(kcvm, m, ts, BB2, CellPath.create(BB2)));
1:         expectedCells.forEach(builder::addCell);
0:         DeletionTime rowDeletion = new DeletionTime(ts, now);
1:         builder.addRowDeletion(rowDeletion);
1: 
1:         StatsCollector collector = new StatsCollector();
1:         Rows.collectStats(builder.build(), collector);
1: 
1:         Assert.assertEquals(Lists.newArrayList(liveness), collector.liveness);
0:         Assert.assertEquals(Sets.newHashSet(rowDeletion, complexDeletion), Sets.newHashSet(collector.deletions));
1:         Assert.assertEquals(Sets.newHashSet(expectedCells), Sets.newHashSet(collector.cells));
1:         Assert.assertEquals(2, collector.columnCount);
1:         Assert.assertFalse(collector.hasLegacyCounterShards);
1:     }
1: 
1: 
1:     public static void addExpectedCells(Set<MergedPair<Cell>> dst, Cell merged, Cell... inputs)
1:     {
1:         for (int i=0; i<inputs.length; i++)
1:         {
1:             dst.add(MergedPair.create(i, merged, inputs[i]));
1:         }
1:     }
1: 
1:     @Test
1:     public void diff()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         long ts1 = secondToTs(now1);
1:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:         r1Builder.newRow(c1);
0:         LivenessInfo r1Liveness = LivenessInfo.create(kcvm, ts1, now1);
1:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1:         DeletionTime r1ComplexDeletion = new DeletionTime(ts1-1, now1);
1:         r1Builder.addComplexDeletion(m, r1ComplexDeletion);
1: 
0:         Cell r1v = BufferCell.live(kcvm, v, ts1, BB1);
0:         Cell r1m1 = BufferCell.live(kcvm, m, ts1, BB1, CellPath.create(BB1));
0:         Cell r1m2 = BufferCell.live(kcvm, m, ts1, BB2, CellPath.create(BB2));
1:         List<Cell> r1ExpectedCells = Lists.newArrayList(r1v, r1m1, r1m2);
1: 
1:         r1ExpectedCells.forEach(r1Builder::addCell);
1: 
1:         int now2 = now1 + 1;
1:         long ts2 = secondToTs(now2);
1:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:         r2Builder.newRow(c1);
0:         LivenessInfo r2Liveness = LivenessInfo.create(kcvm, ts2, now2);
1:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
0:         Cell r2v = BufferCell.live(kcvm, v, ts2, BB2);
0:         Cell r2m2 = BufferCell.live(kcvm, m, ts2, BB1, CellPath.create(BB2));
0:         Cell r2m3 = BufferCell.live(kcvm, m, ts2, BB2, CellPath.create(BB3));
0:         Cell r2m4 = BufferCell.live(kcvm, m, ts2, BB3, CellPath.create(BB4));
1:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1: 
1:         r2ExpectedCells.forEach(r2Builder::addCell);
0:         DeletionTime r2RowDeletion = new DeletionTime(ts1 - 2, now2);
1:         r2Builder.addRowDeletion(r2RowDeletion);
1: 
1:         Row r1 = r1Builder.build();
1:         Row r2 = r2Builder.build();
1:         Row merged = Rows.merge(r1, r2, now2 + 1);
1: 
1:         Assert.assertEquals(r1ComplexDeletion, merged.getComplexColumnData(m).complexDeletion());
1: 
1:         DiffListener listener = new DiffListener();
1:         Rows.diff(listener, merged, r1, r2);
1: 
1:         Assert.assertEquals(c1, listener.clustering);
1: 
1:         // check cells
1:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet();
1:         addExpectedCells(expectedCells, r2v,  r1v,  r2v);     // v
1:         addExpectedCells(expectedCells, r1m1, r1m1, null);   // m[1]
1:         addExpectedCells(expectedCells, r2m2, r1m2, r2m2);   // m[2]
1:         addExpectedCells(expectedCells, r2m3, null, r2m3);   // m[3]
1:         addExpectedCells(expectedCells, r2m4, null, r2m4);   // m[4]
1: 
1:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1: 
1:         // liveness
1:         List<MergedPair<LivenessInfo>> expectedLiveness = Lists.newArrayList(MergedPair.create(0, r2Liveness, r1Liveness),
1:                                                                              MergedPair.create(1, r2Liveness, r2Liveness));
1:         Assert.assertEquals(expectedLiveness, listener.liveness);
1: 
1:         // deletions
0:         List<MergedPair<DeletionTime>> expectedDeletions = Lists.newArrayList(MergedPair.create(0, r2RowDeletion, null),
1:                                                                               MergedPair.create(1, r2RowDeletion, r2RowDeletion));
1:         Assert.assertEquals(expectedDeletions, listener.deletions);
1: 
1:         // complex deletions
1:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, r1ComplexDeletion, r1ComplexDeletion),
1:                                                                                    MergedPair.create(1, r1ComplexDeletion, DeletionTime.LIVE));
1:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:     }
1: 
1:     /**
1:      * merged row has no column data
1:      */
1:     @Test
1:     public void diffEmptyMerged()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         long ts1 = secondToTs(now1);
1:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:         r1Builder.newRow(c1);
0:         LivenessInfo r1Liveness = LivenessInfo.create(kcvm, ts1, now1);
1:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1: 
1:         // mergedData == null
1:         int now2 = now1 + 1;
1:         long ts2 = secondToTs(now2);
1:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:         r2Builder.newRow(c1);
0:         LivenessInfo r2Liveness = LivenessInfo.create(kcvm, ts2, now2);
1:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
1:         DeletionTime r2ComplexDeletion = new DeletionTime(ts2-1, now2);
1:         r2Builder.addComplexDeletion(m, r2ComplexDeletion);
0:         Cell r2v = BufferCell.live(kcvm, v, ts2, BB2);
0:         Cell r2m2 = BufferCell.live(kcvm, m, ts2, BB1, CellPath.create(BB2));
0:         Cell r2m3 = BufferCell.live(kcvm, m, ts2, BB2, CellPath.create(BB3));
0:         Cell r2m4 = BufferCell.live(kcvm, m, ts2, BB3, CellPath.create(BB4));
1:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1: 
1:         r2ExpectedCells.forEach(r2Builder::addCell);
0:         DeletionTime r2RowDeletion = new DeletionTime(ts1 - 1, now2);
1:         r2Builder.addRowDeletion(r2RowDeletion);
1: 
1:         Row r1 = r1Builder.build();
1:         Row r2 = r2Builder.build();
1: 
1:         DiffListener listener = new DiffListener();
1:         Rows.diff(listener, r1, r2);
1: 
1:         Assert.assertEquals(c1, listener.clustering);
1: 
1:         // check cells
1:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet(MergedPair.create(0, null, r2v),   // v
1:                                                               MergedPair.create(0, null, r2m2),  // m[2]
1:                                                               MergedPair.create(0, null, r2m3),  // m[3]
1:                                                               MergedPair.create(0, null, r2m4)); // m[4]
1: 
1:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1: 
1:         // complex deletions
1:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, null, r2ComplexDeletion));
1:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:     }
1: 
1:     /**
1:      * input row has no column data
1:      */
1:     @Test
1:     public void diffEmptyInput()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         long ts1 = secondToTs(now1);
1:         Row.Builder r1Builder = BTreeRow.unsortedBuilder(now1);
1:         r1Builder.newRow(c1);
0:         LivenessInfo r1Liveness = LivenessInfo.create(kcvm, ts1, now1);
1:         r1Builder.addPrimaryKeyLivenessInfo(r1Liveness);
1: 
1:         // mergedData == null
1:         int now2 = now1 + 1;
1:         long ts2 = secondToTs(now2);
1:         Row.Builder r2Builder = BTreeRow.unsortedBuilder(now2);
1:         r2Builder.newRow(c1);
0:         LivenessInfo r2Liveness = LivenessInfo.create(kcvm, ts2, now2);
1:         r2Builder.addPrimaryKeyLivenessInfo(r2Liveness);
1:         DeletionTime r2ComplexDeletion = new DeletionTime(ts2-1, now2);
1:         r2Builder.addComplexDeletion(m, r2ComplexDeletion);
0:         Cell r2v = BufferCell.live(kcvm, v, ts2, BB2);
0:         Cell r2m2 = BufferCell.live(kcvm, m, ts2, BB1, CellPath.create(BB2));
0:         Cell r2m3 = BufferCell.live(kcvm, m, ts2, BB2, CellPath.create(BB3));
0:         Cell r2m4 = BufferCell.live(kcvm, m, ts2, BB3, CellPath.create(BB4));
1:         List<Cell> r2ExpectedCells = Lists.newArrayList(r2v, r2m2, r2m3, r2m4);
1: 
1:         r2ExpectedCells.forEach(r2Builder::addCell);
0:         DeletionTime r2RowDeletion = new DeletionTime(ts1 - 1, now2);
1:         r2Builder.addRowDeletion(r2RowDeletion);
1: 
1:         Row r1 = r1Builder.build();
1:         Row r2 = r2Builder.build();
1: 
1:         DiffListener listener = new DiffListener();
1:         Rows.diff(listener, r2, r1);
1: 
1:         Assert.assertEquals(c1, listener.clustering);
1: 
1:         // check cells
1:         Set<MergedPair<Cell>> expectedCells = Sets.newHashSet(MergedPair.create(0, r2v, null),   // v
1:                                                               MergedPair.create(0, r2m2, null),  // m[2]
1:                                                               MergedPair.create(0, r2m3, null),  // m[3]
1:                                                               MergedPair.create(0, r2m4, null)); // m[4]
1: 
1:         Assert.assertEquals(expectedCells.size(), listener.cells.size());
1:         Assert.assertEquals(expectedCells, Sets.newHashSet(listener.cells));
1: 
1:         // complex deletions
1:         List<MergedPair<DeletionTime>> expectedCmplxDeletions = Lists.newArrayList(MergedPair.create(0, r2ComplexDeletion, null));
1:         Assert.assertEquals(ImmutableMap.builder().put(m, expectedCmplxDeletions).build(), listener.complexDeletions);
1:     }
1: 
1:     @Test
1:     public void merge()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         Row.Builder existingBuilder = createBuilder(c1, now1, BB1, BB1, BB1);
1: 
1:         int now2 = now1 + 1;
1:         long ts2 = secondToTs(now2);
1: 
0:         Cell expectedVCell = BufferCell.live(kcvm, v, ts2, BB2);
0:         Cell expectedMCell = BufferCell.live(kcvm, m, ts2, BB2, CellPath.create(BB1));
1:         DeletionTime expectedComplexDeletionTime = new DeletionTime(ts2 - 1, now2);
1: 
1:         Row.Builder updateBuilder = createBuilder(c1, now2, null, null, null);
1:         updateBuilder.addCell(expectedVCell);
1:         updateBuilder.addComplexDeletion(m, expectedComplexDeletionTime);
1:         updateBuilder.addCell(expectedMCell);
1: 
1:         RowBuilder builder = new RowBuilder();
1:         long td = Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now2 + 1);
1: 
1:         Assert.assertEquals(c1, builder.clustering);
0:         Assert.assertEquals(LivenessInfo.create(kcvm, ts2, now2), builder.livenessInfo);
1:         Assert.assertEquals(Lists.newArrayList(Pair.create(m, new DeletionTime(ts2-1, now2))), builder.complexDeletions);
1: 
1:         Assert.assertEquals(2, builder.cells.size());
1:         Assert.assertEquals(Lists.newArrayList(expectedVCell, expectedMCell), Lists.newArrayList(builder.cells));
1:         Assert.assertEquals(ts2 - secondToTs(now1), td);
1:     }
1: 
1:     @Test
1:     public void mergeComplexDeletionSupersededByRowDeletion()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         Row.Builder existingBuilder = createBuilder(c1, now1, null, null, null);
1: 
1:         int now2 = now1 + 1;
1:         Row.Builder updateBuilder = createBuilder(c1, now2, null, BB1, BB1);
1:         int now3 = now2 + 1;
0:         DeletionTime expectedDeletion = new DeletionTime(secondToTs(now3), now3);
1:         updateBuilder.addRowDeletion(expectedDeletion);
1: 
1:         RowBuilder builder = new RowBuilder();
1:         Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now3 + 1);
1: 
1:         Assert.assertEquals(expectedDeletion, builder.deletionTime);
1:         Assert.assertEquals(Collections.emptyList(), builder.complexDeletions);
1:         Assert.assertEquals(Collections.emptyList(), builder.cells);
1:     }
1: 
1:     /**
1:      * If a row's deletion time deletes a row's liveness info, the new row should have it's
1:      * liveness info set to empty
1:      */
1:     @Test
1:     public void mergeRowDeletionSupercedesLiveness()
1:     {
1:         int now1 = FBUtilities.nowInSeconds();
1:         Row.Builder existingBuilder = createBuilder(c1, now1, null, null, null);
1: 
1:         int now2 = now1 + 1;
1:         Row.Builder updateBuilder = createBuilder(c1, now2, BB1, BB1, BB1);
1:         int now3 = now2 + 1;
0:         DeletionTime expectedDeletion = new DeletionTime(secondToTs(now3), now3);
1:         updateBuilder.addRowDeletion(expectedDeletion);
1: 
1:         RowBuilder builder = new RowBuilder();
1:         Rows.merge(existingBuilder.build(), updateBuilder.build(), builder, now3 + 1);
1: 
1:         Assert.assertEquals(expectedDeletion, builder.deletionTime);
1:         Assert.assertEquals(LivenessInfo.EMPTY, builder.livenessInfo);
1:         Assert.assertEquals(Collections.emptyList(), builder.complexDeletions);
1:         Assert.assertEquals(Collections.emptyList(), builder.cells);
1:     }
1: }
============================================================================