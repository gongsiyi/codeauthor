1:31e669a: /*
1:31e669a:  * Licensed to the Apache Software Foundation (ASF) under one
1:31e669a:  * or more contributor license agreements.  See the NOTICE file
1:31e669a:  * distributed with this work for additional information
1:31e669a:  * regarding copyright ownership.  The ASF licenses this file
1:31e669a:  * to you under the Apache License, Version 2.0 (the
1:31e669a:  * "License"); you may not use this file except in compliance
1:31e669a:  * with the License.  You may obtain a copy of the License at
1:31e669a:  *
1:31e669a:  *     http://www.apache.org/licenses/LICENSE-2.0
1:31e669a:  *
1:31e669a:  * Unless required by applicable law or agreed to in writing, software
1:31e669a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:31e669a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:31e669a:  * See the License for the specific language governing permissions and
1:31e669a:  * limitations under the License.
1:31e669a:  */
1:31e669a: package org.apache.cassandra.cql3;
1:31e669a: 
1:31e669a: import java.nio.ByteBuffer;
1:31e669a: 
1:31e669a: import org.slf4j.Logger;
1:31e669a: import org.slf4j.LoggerFactory;
1:362cc05: import org.apache.cassandra.config.ColumnDefinition;
1:362cc05: import org.apache.cassandra.db.*;
1:4ed0060: import org.apache.cassandra.db.marshal.*;
1:31e669a: import org.apache.cassandra.exceptions.InvalidRequestException;
1:362cc05: import org.apache.cassandra.serializers.MarshalException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:31e669a: import org.apache.cassandra.utils.ByteBufferUtil;
1:31e669a: 
1:31e669a: /**
1:31e669a:  * Static helper methods and classes for constants.
1:31e669a:  */
1:31e669a: public abstract class Constants
1:cf84ea7: {
1:31e669a:     private static final Logger logger = LoggerFactory.getLogger(Constants.class);
1:31e669a: 
1:31e669a:     public enum Type
1:cf84ea7:     {
1:ecf05b8:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, HEX, DURATION;
1:cf84ea7:     }
1:cf84ea7: 
1:1291135:     private static class UnsetLiteral extends Term.Raw
1:1291135:     {
1:1291135:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:1291135:         {
1:1291135:             return UNSET_VALUE;
1:1291135:         }
1:1291135: 
1:1291135:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:1291135:         {
1:1291135:             return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:1291135:         }
1:1291135: 
1:1291135:         public String getText()
1:1291135:         {
1:1291135:             return "";
1:1291135:         }
1:1291135: 
1:1291135:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:1291135:         {
1:1291135:             return null;
1:1291135:         }
1:1291135:     }
1:1291135: 
1:1291135:     // We don't have "unset" literal in the syntax, but it's used implicitely for JSON "DEFAULT UNSET" option
1:1291135:     public static final UnsetLiteral UNSET_LITERAL = new UnsetLiteral();
1:1291135: 
1:48f6446:     public static final Value UNSET_VALUE = new Value(ByteBufferUtil.UNSET_BYTE_BUFFER);
1:8d87e0e: 
1:5a4253b:     private static class NullLiteral extends Term.Raw
1:4ed0060:     {
1:d63d07b:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:cf84ea7:         {
1:44fa12e:             if (!testAssignment(keyspace, receiver).isAssignable())
1:cf84ea7:                 throw new InvalidRequestException("Invalid null value for counter increment/decrement");
1:31e669a: 
1:cf84ea7:             return NULL_VALUE;
1:31e669a:         }
1:31e669a: 
1:44fa12e:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:31e669a:         {
1:44fa12e:             return receiver.type instanceof CounterColumnType
1:44fa12e:                  ? AssignmentTestable.TestResult.NOT_ASSIGNABLE
1:44fa12e:                  : AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:         }
1:31e669a: 
1:5a4253b:         public String getText()
1:31e669a:         {
1:5a4253b:             return "NULL";
1:4ed0060:         }
1:4ed0060: 
1:4ed0060:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:4ed0060:         {
1:4ed0060:             return null;
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:5a4253b:     public static final NullLiteral NULL_LITERAL = new NullLiteral();
1:31e669a: 
1:c7b02d1:     public static final Term.Terminal NULL_VALUE = new Value(null)
1:31e669a:     {
1:4ed0060:         @Override
1:9872b74:         public Terminal bind(QueryOptions options)
1:cf84ea7:         {
1:cf84ea7:             // We return null because that makes life easier for collections
1:cf84ea7:             return null;
1:cf84ea7:         }
1:cf84ea7: 
1:8d87e0e:         @Override
1:8d87e0e:         public String toString()
1:8d87e0e:         {
1:8d87e0e:             return "null";
1:8d87e0e:         }
2:cf84ea7:     };
1:cf84ea7: 
1:5a4253b:     public static class Literal extends Term.Raw
1:cf84ea7:     {
1:31e669a:         private final Type type;
1:31e669a:         private final String text;
1:cf84ea7: 
1:31e669a:         private Literal(Type type, String text)
1:cf84ea7:         {
1:31e669a:             assert type != null && text != null;
1:31e669a:             this.type = type;
1:31e669a:             this.text = text;
1:cf84ea7:         }
1:cf84ea7: 
1:31e669a:         public static Literal string(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.STRING, text);
1:cf84ea7:         }
1:31e669a: 
1:31e669a:         public static Literal integer(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.INTEGER, text);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public static Literal floatingPoint(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.FLOAT, text);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public static Literal uuid(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.UUID, text);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public static Literal bool(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.BOOLEAN, text);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public static Literal hex(String text)
1:31e669a:         {
1:31e669a:             return new Literal(Type.HEX, text);
1:31e669a:         }
1:31e669a: 
1:ecf05b8:         public static Literal duration(String text)
1:ecf05b8:         {
1:ecf05b8:             return new Literal(Type.DURATION, text);
1:ecf05b8:         }
1:ecf05b8: 
1:d63d07b:         public Value prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:31e669a:         {
1:44fa12e:             if (!testAssignment(keyspace, receiver).isAssignable())
1:70fd478:                 throw new InvalidRequestException(String.format("Invalid %s constant (%s) for \"%s\" of type %s", type, text, receiver.name, receiver.type.asCQL3Type()));
1:31e669a: 
1:31e669a:             return new Value(parsedValue(receiver.type));
1:31e669a:         }
1:31e669a: 
1:31e669a:         private ByteBuffer parsedValue(AbstractType<?> validator) throws InvalidRequestException
1:31e669a:         {
1:01d4f07:             if (validator instanceof ReversedType<?>)
1:01d4f07:                 validator = ((ReversedType<?>) validator).baseType;
1:31e669a:             try
1:31e669a:             {
1:c6ed2e0:                 if (type == Type.HEX)
1:c6ed2e0:                     // Note that validator could be BytesType, but it could also be a custom type, so
1:c6ed2e0:                     // we hardcode BytesType (rather than using 'validator') in the call below.
1:c6ed2e0:                     // Further note that BytesType doesn't want it's input prefixed by '0x', hence the substring.
1:c6ed2e0:                     return BytesType.instance.fromString(text.substring(2));
1:31e669a: 
1:31e669a:                 if (validator instanceof CounterColumnType)
1:31e669a:                     return LongType.instance.fromString(text);
1:31e669a:                 return validator.fromString(text);
1:31e669a:             }
1:31e669a:             catch (MarshalException e)
1:31e669a:             {
1:31e669a:                 throw new InvalidRequestException(e.getMessage());
1:31e669a:             }
1:31e669a:         }
1:31e669a: 
1:cf84ea7:         @Override
1:44fa12e:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:31e669a:         {
1:31e669a:             CQL3Type receiverType = receiver.type.asCQL3Type();
1:677230d:             if (receiverType.isCollection() || receiverType.isUDT())
1:44fa12e:                 return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:31e669a: 
1:31e669a:             if (!(receiverType instanceof CQL3Type.Native))
1:31e669a:                 // Skip type validation for custom types. May or may not be a good idea
1:44fa12e:                 return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a: 
1:31e669a:             CQL3Type.Native nt = (CQL3Type.Native)receiverType;
1:31e669a:             switch (type)
1:31e669a:             {
1:31e669a:                 case STRING:
1:31e669a:                     switch (nt)
1:31e669a:                     {
1:31e669a:                         case ASCII:
1:31e669a:                         case TEXT:
1:31e669a:                         case INET:
1:31e669a:                         case VARCHAR:
1:107545b:                         case DATE:
1:107545b:                         case TIME:
1:31e669a:                         case TIMESTAMP:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:31e669a:                 case INTEGER:
1:31e669a:                     switch (nt)
1:31e669a:                     {
1:31e669a:                         case BIGINT:
1:31e669a:                         case COUNTER:
1:107545b:                         case DATE:
1:31e669a:                         case DECIMAL:
1:31e669a:                         case DOUBLE:
1:ecf05b8:                         case DURATION:
1:31e669a:                         case FLOAT:
1:31e669a:                         case INT:
1:35a945e:                         case SMALLINT:
1:863dbc7:                         case TIME:
1:31e669a:                         case TIMESTAMP:
1:35a945e:                         case TINYINT:
1:31e669a:                         case VARINT:
1:ecf05b8:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:ecf05b8:                     }
1:ecf05b8:                     break;
1:31e669a:                 case UUID:
1:ecf05b8:                     switch (nt)
1:ecf05b8:                     {
1:31e669a:                         case UUID:
1:31e669a:                         case TIMEUUID:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:31e669a:                 case FLOAT:
1:31e669a:                     switch (nt)
1:31e669a:                     {
1:31e669a:                         case DECIMAL:
1:31e669a:                         case DOUBLE:
1:31e669a:                         case FLOAT:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:31e669a:                 case BOOLEAN:
1:31e669a:                     switch (nt)
1:31e669a:                     {
1:31e669a:                         case BOOLEAN:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:31e669a:                 case HEX:
1:31e669a:                     switch (nt)
1:31e669a:                     {
2:31e669a:                         case BLOB:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:ecf05b8:                 case DURATION:
1:31e669a:                     switch (nt)
1:31e669a:                     {
1:ecf05b8:                         case DURATION:
1:44fa12e:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:31e669a:                     }
1:44fa12e:                     break;
1:31e669a:             }
1:44fa12e:             return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:31e669a:         }
1:5a4253b: 
1:4ed0060:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:31e669a:         {
1:4ed0060:             // Most constant are valid for more than one type (the extreme example being integer constants, which can
1:4ed0060:             // be use for any numerical type, including date, time, ...) so they don't have an exact type. And in fact,
1:4ed0060:             // for good or bad, any literal is valid for custom types, so we can never claim an exact type.
1:4ed0060:             // But really, the reason it's fine to return null here is that getExactTypeIfKnown is only used to
1:4ed0060:             // implement testAssignment() in Selectable and that method is overriden above.
1:4ed0060:             return null;
1:4ed0060:         }
1:4ed0060: 
1:31e669a:         public String getRawText()
1:31e669a:         {
1:31e669a:             return text;
1:31e669a:         }
1:31e669a: 
1:5a4253b:         public String getText()
1:31e669a:         {
1:31e669a:             return type == Type.STRING ? String.format("'%s'", text) : text;
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     /**
1:31e669a:      * A constant value, i.e. a ByteBuffer.
1:31e669a:      */
1:31e669a:     public static class Value extends Term.Terminal
1:31e669a:     {
1:31e669a:         public final ByteBuffer bytes;
1:31e669a: 
1:31e669a:         public Value(ByteBuffer bytes)
1:31e669a:         {
1:31e669a:             this.bytes = bytes;
1:31e669a:         }
1:31e669a: 
1:e0adc16:         public ByteBuffer get(ProtocolVersion protocolVersion)
1:31e669a:         {
1:31e669a:             return bytes;
1:31e669a:         }
1:31e669a: 
1:cf84ea7:         @Override
1:9872b74:         public ByteBuffer bindAndGet(QueryOptions options)
1:31e669a:         {
1:31e669a:             return bytes;
1:31e669a:         }
1:31e669a: 
2:31e669a:         @Override
1:cf84ea7:         public String toString()
1:31e669a:         {
1:4349638:             return ByteBufferUtil.bytesToHex(bytes);
1:31e669a:         }
1:5a4253b:     }
1:31e669a: 
1:31e669a:     public static class Marker extends AbstractMarker
1:31e669a:     {
1:31e669a:         protected Marker(int bindIndex, ColumnSpecification receiver)
1:31e669a:         {
1:31e669a:             super(bindIndex, receiver);
1:362cc05:             assert !receiver.type.isCollection();
1:31e669a:         }
1:31e669a: 
1:31e669a:         @Override
1:9872b74:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:31e669a:         {
1:31e669a:             try
1:31e669a:             {
1:9872b74:                 ByteBuffer value = options.getValues().get(bindIndex);
1:48f6446:                 if (value != null && value != ByteBufferUtil.UNSET_BYTE_BUFFER)
1:ef57456:                     receiver.type.validate(value);
1:31e669a:                 return value;
1:31e669a:             }
1:31e669a:             catch (MarshalException e)
1:31e669a:             {
1:31e669a:                 throw new InvalidRequestException(e.getMessage());
1:31e669a:             }
1:31e669a:         }
1:31e669a: 
1:9872b74:         public Value bind(QueryOptions options) throws InvalidRequestException
1:31e669a:         {
1:9872b74:             ByteBuffer bytes = bindAndGet(options);
1:ef57456:             if (bytes == null)
1:cf84ea7:                 return null;
1:48f6446:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:48f6446:                 return Constants.UNSET_VALUE;
1:48f6446:             return new Constants.Value(bytes);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class Setter extends Operation
1:31e669a:     {
1:362cc05:         public Setter(ColumnDefinition column, Term t)
1:31e669a:         {
1:31e669a:             super(column, t);
1:31e669a:         }
1:31e669a: 
1:2457599:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:31e669a:         {
1:9872b74:             ByteBuffer value = t.bindAndGet(params.options);
1:a991b64:             if (value == null)
1:2457599:                 params.addTombstone(column);
1:a991b64:             else if (value != ByteBufferUtil.UNSET_BYTE_BUFFER) // use reference equality and not object equality
1:2457599:                 params.addCell(column, value);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class Adder extends Operation
1:31e669a:     {
1:362cc05:         public Adder(ColumnDefinition column, Term t)
1:31e669a:         {
1:31e669a:             super(column, t);
1:31e669a:         }
1:31e669a: 
1:2457599:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:31e669a:         {
1:9872b74:             ByteBuffer bytes = t.bindAndGet(params.options);
1:ef57456:             if (bytes == null)
1:ef57456:                 throw new InvalidRequestException("Invalid null value for counter increment");
1:48f6446:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:48f6446:                 return;
1:ef57456: 
1:ef57456:             long increment = ByteBufferUtil.toLong(bytes);
1:2457599:             params.addCounter(column, increment);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class Substracter extends Operation
1:31e669a:     {
1:362cc05:         public Substracter(ColumnDefinition column, Term t)
1:31e669a:         {
1:31e669a:             super(column, t);
1:31e669a:         }
1:31e669a: 
1:2457599:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:31e669a:         {
1:9872b74:             ByteBuffer bytes = t.bindAndGet(params.options);
1:48f6446:             if (bytes == null)
1:ef57456:                 throw new InvalidRequestException("Invalid null value for counter increment");
1:48f6446:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:48f6446:                 return;
1:31e669a: 
1:ef57456:             long increment = ByteBufferUtil.toLong(bytes);
1:31e669a:             if (increment == Long.MIN_VALUE)
1:31e669a:                 throw new InvalidRequestException("The negation of " + increment + " overflows supported counter precision (signed 8 bytes integer)");
1:31e669a: 
1:2457599:             params.addCounter(column, -increment);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     // This happens to also handle collection because it doesn't felt worth
1:31e669a:     // duplicating this further
1:31e669a:     public static class Deleter extends Operation
1:31e669a:     {
1:362cc05:         public Deleter(ColumnDefinition column)
1:31e669a:         {
1:31e669a:             super(column, null);
1:31e669a:         }
1:31e669a: 
1:2457599:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:31e669a:         {
1:ee55f36:             if (column.type.isMultiCell())
1:2457599:                 params.setComplexDeletionTime(column);
1:31e669a:             else
1:2457599:                 params.addTombstone(column);
1:2457599:         }
1:31e669a:     }
1:31e669a: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer get(ProtocolVersion protocolVersion)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, HEX, DURATION;
/////////////////////////////////////////////////////////////////////////
1:         public static Literal duration(String text)
1:         {
1:             return new Literal(Type.DURATION, text);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         case DURATION:
/////////////////////////////////////////////////////////////////////////
1:                 case DURATION:
1:                     switch (nt)
1:                     {
1:                         case DURATION:
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     }
1:                     break;
commit:35a945e
/////////////////////////////////////////////////////////////////////////
1:                         case SMALLINT:
1:                         case TINYINT:
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:1291135
/////////////////////////////////////////////////////////////////////////
1:     private static class UnsetLiteral extends Term.Raw
1:     {
1:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:         {
1:             return UNSET_VALUE;
1:         }
1: 
1:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:         {
1:             return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:         }
1: 
1:         public String getText()
1:         {
1:             return "";
1:         }
1: 
1:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:         {
1:             return null;
1:         }
1:     }
1: 
1:     // We don't have "unset" literal in the syntax, but it's used implicitely for JSON "DEFAULT UNSET" option
1:     public static final UnsetLiteral UNSET_LITERAL = new UnsetLiteral();
1: 
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
0:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, HEX;
/////////////////////////////////////////////////////////////////////////
1: 
1:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:         {
1:             return null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:         {
1:             // Most constant are valid for more than one type (the extreme example being integer constants, which can
1:             // be use for any numerical type, including date, time, ...) so they don't have an exact type. And in fact,
1:             // for good or bad, any literal is valid for custom types, so we can never claim an exact type.
1:             // But really, the reason it's fine to return null here is that getExactTypeIfKnown is only used to
1:             // implement testAssignment() in Selectable and that method is overriden above.
1:             return null;
1:         }
1: 
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:                 params.addTombstone(column);
1:                 params.addCell(column, value);
/////////////////////////////////////////////////////////////////////////
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:             params.addCounter(column, increment);
/////////////////////////////////////////////////////////////////////////
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:             params.addCounter(column, -increment);
/////////////////////////////////////////////////////////////////////////
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:                 params.setComplexDeletionTime(column);
1:                 params.addTombstone(column);
1:     }
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.rows.*;
/////////////////////////////////////////////////////////////////////////
0:         public void execute(DecoratedKey partitionKey, Clustering clustering, Row.Writer writer, UpdateParameters params) throws InvalidRequestException
1:             if (value == null)
0:                 params.addTombstone(column, writer);
1:             else if (value != ByteBufferUtil.UNSET_BYTE_BUFFER) // use reference equality and not object equality
0:                 params.addCell(clustering, column, writer, value);
/////////////////////////////////////////////////////////////////////////
0:         public void execute(DecoratedKey partitionKey, Clustering clustering, Row.Writer writer, UpdateParameters params) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:             params.addCounter(column, writer, increment);
/////////////////////////////////////////////////////////////////////////
0:         public void execute(DecoratedKey partitionKey, Clustering clustering, Row.Writer writer, UpdateParameters params) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:             params.addCounter(column, writer, -increment);
/////////////////////////////////////////////////////////////////////////
0:         public void execute(DecoratedKey partitionKey, Clustering clustering, Row.Writer writer, UpdateParameters params) throws InvalidRequestException
0:                 params.setComplexDeletionTime(column, writer);
0:                 params.addTombstone(column, writer);
commit:44fa12e
/////////////////////////////////////////////////////////////////////////
1:             if (!testAssignment(keyspace, receiver).isAssignable())
1:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:             return receiver.type instanceof CounterColumnType
1:                  ? AssignmentTestable.TestResult.NOT_ASSIGNABLE
1:                  : AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
/////////////////////////////////////////////////////////////////////////
1:             if (!testAssignment(keyspace, receiver).isAssignable())
/////////////////////////////////////////////////////////////////////////
1:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:                 return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:                 return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
/////////////////////////////////////////////////////////////////////////
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
1:                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                     break;
1:             return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
commit:e28cc63
commit:8d87e0e
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public String toString()
1:             {
1:                 return "null";
1:             }
/////////////////////////////////////////////////////////////////////////
0:             return "null";
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:             public Terminal bind(QueryOptions options)
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer get(QueryOptions options)
1:         public ByteBuffer bindAndGet(QueryOptions options)
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:                 ByteBuffer value = options.getValues().get(bindIndex);
/////////////////////////////////////////////////////////////////////////
1:         public Value bind(QueryOptions options) throws InvalidRequestException
1:             ByteBuffer bytes = bindAndGet(options);
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer value = t.bindAndGet(params.options);
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer bytes = t.bindAndGet(params.options);
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer bytes = t.bindAndGet(params.options);
commit:63b1ef4
commit:b09d876
/////////////////////////////////////////////////////////////////////////
0:             prefix = maybeUpdatePrefix(cf.metadata(), prefix);
/////////////////////////////////////////////////////////////////////////
0:             prefix = maybeUpdatePrefix(cf.metadata(), prefix);
/////////////////////////////////////////////////////////////////////////
0:             prefix = maybeUpdatePrefix(cf.metadata(), prefix);
/////////////////////////////////////////////////////////////////////////
0:             ColumnNameBuilder column = maybeUpdatePrefix(cf.metadata(), prefix).add(columnName.key);
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
1:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
0:             if (!isAssignableTo(keyspace, receiver))
0:         public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
/////////////////////////////////////////////////////////////////////////
1:         public Value prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
0:             if (!isAssignableTo(keyspace, receiver))
/////////////////////////////////////////////////////////////////////////
0:         public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
commit:362cc05
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.composites.CellName;
0: import org.apache.cassandra.db.composites.Composite;
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1:             assert !receiver.type.isCollection();
/////////////////////////////////////////////////////////////////////////
1:         public Setter(ColumnDefinition column, Term t)
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException
0:             CellName cname = cf.getComparator().create(prefix, column.name);
/////////////////////////////////////////////////////////////////////////
1:         public Adder(ColumnDefinition column, Term t)
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException
0:             CellName cname = cf.getComparator().create(prefix, column.name);
1:         public Substracter(ColumnDefinition column, Term t)
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:             CellName cname = cf.getComparator().create(prefix, column.name);
/////////////////////////////////////////////////////////////////////////
1:         public Deleter(ColumnDefinition column)
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException
0:             CellName cname = cf.getComparator().create(prefix, column.name);
0:             if (column.type.isCollection())
0:                 cf.addAtom(params.makeRangeTombstone(cname.slice()));
0:                 cf.addColumn(params.makeTombstone(cname));
commit:5f5905d
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName).build();
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName).build();
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName).build();
/////////////////////////////////////////////////////////////////////////
0:             ColumnNameBuilder column = prefix.add(columnName);
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.MarshalException;
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.MarshalException;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CollectionType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
0: import org.apache.cassandra.db.marshal.LongType;
0: import org.apache.cassandra.db.marshal.ReversedType;
commit:cf84ea7
/////////////////////////////////////////////////////////////////////////
0:     public static final Term.Raw NULL_LITERAL = new Term.Raw()
1:     {
0:         private final Term.Terminal NULL_VALUE = new Value(null)
1:         {
1:             @Override
0:             public Terminal bind(List<ByteBuffer> values)
1:             {
1:                 // We return null because that makes life easier for collections
1:                 return null;
1:             }
1:         };
1: 
0:         public Term prepare(ColumnSpecification receiver) throws InvalidRequestException
1:         {
0:             if (!isAssignableTo(receiver))
1:                 throw new InvalidRequestException("Invalid null value for counter increment/decrement");
1: 
1:             return NULL_VALUE;
1:         }
1: 
0:         public boolean isAssignableTo(ColumnSpecification receiver)
1:         {
0:             return !(receiver.type instanceof CounterColumnType);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
1:             return null;
1:         }
1:     };
1: 
commit:306a565
commit:ef57456
/////////////////////////////////////////////////////////////////////////
0:                 if (value != null)
1:                     receiver.type.validate(value);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer bytes = bindAndGet(values);
0:             return bytes == null ? null : new Constants.Value(bytes);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer value = t.bindAndGet(params.variables);
0:             cf.addColumn(value == null ? params.makeTombstone(cname) : params.makeColumn(cname, value));
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer bytes = t.bindAndGet(params.variables);
1:             if (bytes == null)
1:                 throw new InvalidRequestException("Invalid null value for counter increment");
1:             long increment = ByteBufferUtil.toLong(bytes);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer bytes = t.bindAndGet(params.variables);
1:             if (bytes == null)
1:                 throw new InvalidRequestException("Invalid null value for counter increment");
1: 
1:             long increment = ByteBufferUtil.toLong(bytes);
commit:aae62a7
commit:31e669a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.Collections;
0: import java.util.List;
0: import java.util.Set;
1: 
0: import com.google.common.base.Objects;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CollectionType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
0: import org.apache.cassandra.db.marshal.LongType;
0: import org.apache.cassandra.db.marshal.MarshalException;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: /**
1:  * Static helper methods and classes for constants.
1:  */
1: public abstract class Constants
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(Constants.class);
1: 
1:     public enum Type
1:     {
0:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, HEX;
1:     }
1: 
0:     public static class Literal implements Term.Raw
1:     {
1:         private final Type type;
1:         private final String text;
1: 
0:         // For transition post-5198, see below
0:         private static volatile boolean stringAsBlobWarningLogged = false;
1: 
1:         private Literal(Type type, String text)
1:         {
1:             assert type != null && text != null;
1:             this.type = type;
1:             this.text = text;
1:         }
1: 
1:         public static Literal string(String text)
1:         {
1:             return new Literal(Type.STRING, text);
1:         }
1: 
1:         public static Literal integer(String text)
1:         {
1:             return new Literal(Type.INTEGER, text);
1:         }
1: 
1:         public static Literal floatingPoint(String text)
1:         {
1:             return new Literal(Type.FLOAT, text);
1:         }
1: 
1:         public static Literal uuid(String text)
1:         {
1:             return new Literal(Type.UUID, text);
1:         }
1: 
1:         public static Literal bool(String text)
1:         {
1:             return new Literal(Type.BOOLEAN, text);
1:         }
1: 
1:         public static Literal hex(String text)
1:         {
1:             return new Literal(Type.HEX, text);
1:         }
1: 
0:         public Value prepare(ColumnSpecification receiver) throws InvalidRequestException
1:         {
0:             if (!isAssignableTo(receiver))
0:                 throw new InvalidRequestException(String.format("Invalid %s constant (%s) for %s of type %s", type, text, receiver, receiver.type.asCQL3Type()));
1: 
1:             return new Value(parsedValue(receiver.type));
1:         }
1: 
1:         private ByteBuffer parsedValue(AbstractType<?> validator) throws InvalidRequestException
1:         {
1:             try
1:             {
0:                 // BytesType doesn't want it's input prefixed by '0x'.
0:                 if (type == Type.HEX && validator instanceof BytesType)
0:                     return validator.fromString(text.substring(2));
1:                 if (validator instanceof CounterColumnType)
1:                     return LongType.instance.fromString(text);
1:                 return validator.fromString(text);
1:             }
1:             catch (MarshalException e)
1:             {
1:                 throw new InvalidRequestException(e.getMessage());
1:             }
1:         }
1: 
1:         public String getRawText()
1:         {
1:             return text;
1:         }
1: 
0:         public boolean isAssignableTo(ColumnSpecification receiver)
1:         {
1:             CQL3Type receiverType = receiver.type.asCQL3Type();
0:             if (receiverType.isCollection())
0:                 return false;
1: 
1:             if (!(receiverType instanceof CQL3Type.Native))
1:                 // Skip type validation for custom types. May or may not be a good idea
0:                 return true;
1: 
1:             CQL3Type.Native nt = (CQL3Type.Native)receiverType;
1:             switch (type)
1:             {
1:                 case STRING:
1:                     switch (nt)
1:                     {
1:                         case ASCII:
1:                         case TEXT:
1:                         case INET:
1:                         case VARCHAR:
1:                         case TIMESTAMP:
0:                             return true;
1:                         case BLOB:
0:                             // Blobs should now be inputed as hexadecimal constants. However, to allow people to upgrade, we still allow
0:                             // blob-as-strings, even though it is deprecated (see #5198).
0:                             if (!stringAsBlobWarningLogged)
1:                             {
0:                                 stringAsBlobWarningLogged = true;
0:                                 logger.warn("Inputing CLQ3 blobs as strings (like {} = '{}') is now deprecated and will be removed in a future version. "
0:                                           + "You should convert client code to use a blob constant ({} = {}) instead (see http://cassandra.apache.org/doc/cql3/CQL.html "
0:                                           + "changelog section for more info).",
0:                                           new Object[]{receiver, text, receiver, "0x" + text});
1:                             }
0:                             return true;
1:                     }
0:                     return false;
1:                 case INTEGER:
1:                     switch (nt)
1:                     {
1:                         case BIGINT:
1:                         case COUNTER:
1:                         case DECIMAL:
1:                         case DOUBLE:
1:                         case FLOAT:
1:                         case INT:
1:                         case TIMESTAMP:
1:                         case VARINT:
0:                             return true;
1:                     }
0:                     return false;
1:                 case UUID:
1:                     switch (nt)
1:                     {
1:                         case UUID:
1:                         case TIMEUUID:
0:                             return true;
1:                     }
0:                     return false;
1:                 case FLOAT:
1:                     switch (nt)
1:                     {
1:                         case DECIMAL:
1:                         case DOUBLE:
1:                         case FLOAT:
0:                             return true;
1:                     }
0:                     return false;
1:                 case BOOLEAN:
1:                     switch (nt)
1:                     {
1:                         case BOOLEAN:
0:                             return true;
1:                     }
0:                     return false;
1:                 case HEX:
1:                     switch (nt)
1:                     {
1:                         case BLOB:
0:                             return true;
1:                     }
0:                     return false;
1:             }
0:             return false;
1:         }
1: 
1:         @Override
0:         public String toString()
1:         {
1:             return type == Type.STRING ? String.format("'%s'", text) : text;
1:         }
1:     }
1: 
1:     /**
1:      * A constant value, i.e. a ByteBuffer.
1:      */
1:     public static class Value extends Term.Terminal
1:     {
1:         public final ByteBuffer bytes;
1: 
1:         public Value(ByteBuffer bytes)
1:         {
1:             this.bytes = bytes;
1:         }
1: 
0:         public ByteBuffer get()
1:         {
1:             return bytes;
1:         }
1: 
1:         @Override
0:         public ByteBuffer bindAndGet(List<ByteBuffer> values)
1:         {
1:             return bytes;
1:         }
1:     }
1: 
1:     public static class Marker extends AbstractMarker
1:     {
1:         protected Marker(int bindIndex, ColumnSpecification receiver)
1:         {
1:             super(bindIndex, receiver);
0:             assert !(receiver.type instanceof CollectionType);
1:         }
1: 
1:         @Override
0:         public ByteBuffer bindAndGet(List<ByteBuffer> values) throws InvalidRequestException
1:         {
1:             try
1:             {
0:                 ByteBuffer value = values.get(bindIndex);
0:                 receiver.type.validate(value);
1:                 return value;
1:             }
1:             catch (MarshalException e)
1:             {
1:                 throw new InvalidRequestException(e.getMessage());
1:             }
1:         }
1: 
0:         public Value bind(List<ByteBuffer> values) throws InvalidRequestException
1:         {
0:             return new Constants.Value(bindAndGet(values));
1:         }
1:     }
1: 
1:     public static class Setter extends Operation
1:     {
0:         public Setter(ColumnIdentifier column, Term t)
1:         {
1:             super(column, t);
1:         }
1: 
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder prefix, UpdateParameters params) throws InvalidRequestException
1:         {
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName.key).build();
0:             cf.addColumn(params.makeColumn(cname, t.bindAndGet(params.variables)));
1:         }
1:     }
1: 
1:     public static class Adder extends Operation
1:     {
0:         public Adder(ColumnIdentifier column, Term t)
1:         {
1:             super(column, t);
1:         }
1: 
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder prefix, UpdateParameters params) throws InvalidRequestException
1:         {
0:             long increment = ByteBufferUtil.toLong(t.bindAndGet(params.variables));
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName.key).build();
0:             cf.addCounter(new QueryPath(cf.metadata().cfName, null, cname), increment);
1:         }
1:     }
1: 
1:     public static class Substracter extends Operation
1:     {
0:         public Substracter(ColumnIdentifier column, Term t)
1:         {
1:             super(column, t);
1:         }
1: 
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder prefix, UpdateParameters params) throws InvalidRequestException
1:         {
0:             long increment = ByteBufferUtil.toLong(t.bindAndGet(params.variables));
1:             if (increment == Long.MIN_VALUE)
1:                 throw new InvalidRequestException("The negation of " + increment + " overflows supported counter precision (signed 8 bytes integer)");
1: 
0:             ByteBuffer cname = columnName == null ? prefix.build() : prefix.add(columnName.key).build();
0:             cf.addCounter(new QueryPath(cf.metadata().cfName, null, cname), -increment);
1:         }
1:     }
1: 
1:     // This happens to also handle collection because it doesn't felt worth
1:     // duplicating this further
1:     public static class Deleter extends Operation
1:     {
0:         private final boolean isCollection;
1: 
0:         public Deleter(ColumnIdentifier column, boolean isCollection)
1:         {
1:             super(column, null);
0:             this.isCollection = isCollection;
1:         }
1: 
0:         public void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder prefix, UpdateParameters params) throws InvalidRequestException
1:         {
0:             ColumnNameBuilder column = prefix.add(columnName.key);
1: 
0:             if (isCollection)
0:                 cf.addAtom(params.makeRangeTombstone(column.build(), column.buildAsEndOfRange()));
1:             else
0:                 cf.addColumn(params.makeTombstone(column.build()));
1:         }
0:     };
1: }
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:c35e55d
author:Alex Petrov
-------------------------------------------------------------------------------
commit:863dbc7
/////////////////////////////////////////////////////////////////////////
1:                         case TIME:
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
1:             if (receiverType.isCollection() || receiverType.isUDT())
commit:5a4253b
/////////////////////////////////////////////////////////////////////////
1:     private static class NullLiteral extends Term.Raw
/////////////////////////////////////////////////////////////////////////
1:         public String getText()
1:             return "NULL";
1:     }
1: 
1:     public static final NullLiteral NULL_LITERAL = new NullLiteral();
/////////////////////////////////////////////////////////////////////////
1:     public static class Literal extends Term.Raw
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public String getRawText()
0:         {
0:             return text;
0:         }
0: 
1:         public String getText()
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static final Term.Terminal NULL_VALUE = new Value(null)
0:     {
0:         @Override
0:         public Terminal bind(QueryOptions options)
0:         {
0:             // We return null because that makes life easier for collections
0:             return null;
0:         }
0: 
0:         @Override
0:         public String toString()
0:         {
0:             return "null";
0:         }
0:     };
0: 
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer get(int protocolVersion)
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (column.type.isMultiCell())
commit:bf52190
commit:4349638
/////////////////////////////////////////////////////////////////////////
0: 
0:         @Override
0:         public String toString()
0:         {
1:             return ByteBufferUtil.bytesToHex(bytes);
0:         }
commit:70fd478
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidRequestException(String.format("Invalid %s constant (%s) for \"%s\" of type %s", type, text, receiver.name, receiver.type.asCQL3Type()));
author:Robert Stupp
-------------------------------------------------------------------------------
commit:c6ed2e0
/////////////////////////////////////////////////////////////////////////
1:                 if (type == Type.HEX)
1:                     // Note that validator could be BytesType, but it could also be a custom type, so
1:                     // we hardcode BytesType (rather than using 'validator') in the call below.
1:                     // Further note that BytesType doesn't want it's input prefixed by '0x', hence the substring.
1:                     return BytesType.instance.fromString(text.substring(2));
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:10ff8c9
/////////////////////////////////////////////////////////////////////////
0:             {
0:                 CellName cname = cf.getComparator().create(prefix, column);
0:             }
commit:1def02f
/////////////////////////////////////////////////////////////////////////
commit:bc6b5f4
commit:56f35db
/////////////////////////////////////////////////////////////////////////
author:Oded Peer
-------------------------------------------------------------------------------
commit:48f6446
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static final Value UNSET_VALUE = new Value(ByteBufferUtil.UNSET_BYTE_BUFFER);
0: 
/////////////////////////////////////////////////////////////////////////
1:                 if (value != null && value != ByteBufferUtil.UNSET_BYTE_BUFFER)
/////////////////////////////////////////////////////////////////////////
1:             if (bytes == null)
0:                 return null;
1:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:                 return Constants.UNSET_VALUE;
1:             return new Constants.Value(bytes);
/////////////////////////////////////////////////////////////////////////
0:             if (value != ByteBufferUtil.UNSET_BYTE_BUFFER) // use reference equality and not object equality
0:                 cf.addColumn(value == null ? params.makeTombstone(cname) : params.makeColumn(cname, value));
/////////////////////////////////////////////////////////////////////////
1:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:                 return;
0: 
/////////////////////////////////////////////////////////////////////////
1:             if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:                 return;
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:3d11ec5
commit:107545b
/////////////////////////////////////////////////////////////////////////
0:         STRING, INTEGER, UUID, FLOAT, DATE, TIME, BOOLEAN, HEX;
/////////////////////////////////////////////////////////////////////////
1:                         case DATE:
1:                         case TIME:
/////////////////////////////////////////////////////////////////////////
1:                         case DATE:
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:504d3c5
commit:af188ed
commit:ecf1bae
commit:62642fa
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(params.makeCounter(cname, increment));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(params.makeCounter(cname, -increment));
commit:8071765
commit:491098e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c00c24c
commit:1a45fcb
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Objects;
/////////////////////////////////////////////////////////////////////////
0: 
0:         @Override
0:         public int hashCode()
0:         {
0:             return Objects.hashCode(bytes);
0:         }
0: 
0:         @Override
0:         public boolean equals(Object o)
0:         {
0:             if (this == o)
0:                 return true;
0: 
0:             if (!(o instanceof Value))
0:                 return false;
0: 
0:             return Objects.equal(this.bytes, ((Value) o).bytes);
0:         }
commit:84d1aaa
commit:01d4f07
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
1:             if (validator instanceof ReversedType<?>)
1:                 validator = ((ReversedType<?>) validator).baseType;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:2922dbe
============================================================================