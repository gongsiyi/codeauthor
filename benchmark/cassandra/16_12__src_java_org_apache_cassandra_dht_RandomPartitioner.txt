1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
1:066ef58:  */
1:066ef58: package org.apache.cassandra.dht;
1:e7a385a: 
1:a89ef1f: import java.math.BigDecimal;
1:066ef58: import java.math.BigInteger;
1:e7a385a: import java.nio.ByteBuffer;
1:a89ef1f: import java.util.*;
1:67ae1ee: 
1:07893d7: import com.google.common.annotations.VisibleForTesting;
1:67ae1ee: 
1:18d8f26: import org.apache.cassandra.db.CachedHashDecoratedKey;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:c8b1ab4: import org.apache.cassandra.db.DecoratedKey;
1:a67f779: import org.apache.cassandra.db.marshal.AbstractType;
1:a67f779: import org.apache.cassandra.db.marshal.IntegerType;
1:0a08525: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
1:3787d6c: import org.apache.cassandra.utils.ByteBufferUtil;
1:066ef58: import org.apache.cassandra.utils.FBUtilities;
1:066ef58: import org.apache.cassandra.utils.GuidGenerator;
1:4b54b8a: import org.apache.cassandra.utils.ObjectSizes;
1:4a6b002: import org.apache.cassandra.utils.Pair;
1:ef25537: 
2:066ef58: /**
1:066ef58:  * This class generates a BigIntegerToken using MD5 hash.
1:066ef58:  */
1:066ef58: public class RandomPartitioner implements IPartitioner
1:c8b1ab4: {
1:0fd507b:     public static final BigInteger ZERO = new BigInteger("0");
1:0fd507b:     public static final BigIntegerToken MINIMUM = new BigIntegerToken("-1");
1:9a5c679:     public static final BigInteger MAXIMUM = new BigInteger("2").pow(127);
1:4b54b8a: 
1:07893d7:     private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(new BigIntegerToken(FBUtilities.hashToBigInteger(ByteBuffer.allocate(1))));
1:f4be897: 
1:07893d7:     public static final RandomPartitioner instance = new RandomPartitioner();
1:0a08525:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
1:021ab75: 
1:e2c6341:     private final Splitter splitter = new Splitter(this)
1:e2c6341:     {
1:e2c6341:         public Token tokenForValue(BigInteger value)
1:e2c6341:         {
1:e2c6341:             return new BigIntegerToken(value);
1:e2c6341:         }
1:e2c6341: 
1:e2c6341:         public BigInteger valueForToken(Token token)
1:e2c6341:         {
1:e2c6341:             return ((BigIntegerToken)token).getTokenValue();
1:e2c6341:         }
1:e2c6341:     };
1:e2c6341: 
1:7e4ef1c:     public DecoratedKey decorateKey(ByteBuffer key)
1:4b54b8a:     {
1:18d8f26:         return new CachedHashDecoratedKey(getToken(key), key);
1:67ae1ee:     }
1:67ae1ee: 
1:e7a385a:     public Token midpoint(Token ltoken, Token rtoken)
1:67ae1ee:     {
1:0fd507b:         // the symbolic MINIMUM token should act as ZERO: the empty bit array
1:0fd507b:         BigInteger left = ltoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)ltoken).token;
1:0fd507b:         BigInteger right = rtoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)rtoken).token;
1:0fd507b:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 127);
1:4a6b002:         // discard the remainder
1:4a6b002:         return new BigIntegerToken(midpair.left);
1:c8b1ab4:     }
1:c8b1ab4: 
1:e2a0d75:     public Token split(Token ltoken, Token rtoken, double ratioToLeft)
1:e2a0d75:     {
1:e2a0d75:         BigDecimal left = ltoken.equals(MINIMUM) ? BigDecimal.ZERO : new BigDecimal(((BigIntegerToken)ltoken).token),
1:e2a0d75:                    right = rtoken.equals(MINIMUM) ? BigDecimal.ZERO : new BigDecimal(((BigIntegerToken)rtoken).token),
1:e2a0d75:                    ratio = BigDecimal.valueOf(ratioToLeft);
1:e2a0d75: 
1:e2a0d75:         BigInteger newToken;
1:e2a0d75: 
1:e2a0d75:         if (left.compareTo(right) < 0)
1:e2a0d75:         {
1:e2a0d75:             newToken = right.subtract(left).multiply(ratio).add(left).toBigInteger();
1:e2a0d75:         }
1:e2a0d75:         else
1:e2a0d75:         {
1:e2a0d75:             // wrapping case
1:e2a0d75:             // L + ((R - min) + (max - L)) * ratio
1:e2a0d75:             BigDecimal max = new BigDecimal(MAXIMUM);
1:e2a0d75: 
1:e2a0d75:             newToken = max.add(right).subtract(left).multiply(ratio).add(left).toBigInteger().mod(MAXIMUM);
1:e2a0d75:         }
1:e2a0d75: 
1:e2a0d75:         assert isValidToken(newToken) : "Invalid tokens from split";
1:e2a0d75: 
1:e2a0d75:         return new BigIntegerToken(newToken);
1:e2a0d75:     }
1:e2a0d75: 
1:f8fa6d2:     public BigIntegerToken getMinimumToken()
1:c8b1ab4:     {
1:d6c2bb0:         return MINIMUM;
1:c8b1ab4:     }
1:c8b1ab4: 
1:e946c63:     public BigIntegerToken getRandomToken()
1:c8b1ab4:     {
1:a89ef1f:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes());
1:066ef58:         if ( token.signum() == -1 )
1:066ef58:             token = token.multiply(BigInteger.valueOf(-1L));
1:066ef58:         return new BigIntegerToken(token);
1:c8b1ab4:     }
1:c8b1ab4: 
1:47d3b7e:     public BigIntegerToken getRandomToken(Random random)
1:47d3b7e:     {
1:e6d22da:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, "host/127.0.0.1", 0));
1:47d3b7e:         if ( token.signum() == -1 )
1:47d3b7e:             token = token.multiply(BigInteger.valueOf(-1L));
1:47d3b7e:         return new BigIntegerToken(token);
1:47d3b7e:     }
1:47d3b7e: 
1:e2a0d75:     private boolean isValidToken(BigInteger token) {
1:e2a0d75:         return token.compareTo(ZERO) >= 0 && token.compareTo(MAXIMUM) <= 0;
1:e2a0d75:     }
1:e2a0d75: 
1:68d2526:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:68d2526:     {
1:ad84e4d:         public ByteBuffer toByteArray(Token token)
1:021ab75:         {
1:ad84e4d:             BigIntegerToken bigIntegerToken = (BigIntegerToken) token;
1:e7a385a:             return ByteBuffer.wrap(bigIntegerToken.token.toByteArray());
1:c8b1ab4:         }
1:e7a385a: 
1:ad84e4d:         public Token fromByteArray(ByteBuffer bytes)
1:021ab75:         {
1:6aa5b81:             return new BigIntegerToken(new BigInteger(ByteBufferUtil.getArray(bytes)));
1:021ab75:         }
1:c8b1ab4: 
1:ad84e4d:         public String toString(Token token)
1:021ab75:         {
1:ad84e4d:             BigIntegerToken bigIntegerToken = (BigIntegerToken) token;
1:066ef58:             return bigIntegerToken.token.toString();
1:021ab75:         }
1:021ab75: 
1:6a9a336:         public void validate(String token) throws ConfigurationException
1:6a9a336:         {
1:6a9a336:             try
1:6a9a336:             {
1:e2a0d75:                 if(!isValidToken(new BigInteger(token)))
1:e2a0d75:                     throw new ConfigurationException("Token must be >= 0 and <= 2**127");
1:6a9a336:             }
1:6a9a336:             catch (NumberFormatException e)
1:6a9a336:             {
1:6a9a336:                 throw new ConfigurationException(e.getMessage());
1:6a9a336:             }
1:6a9a336:         }
1:6a9a336: 
1:ad84e4d:         public Token fromString(String string)
1:46ea05f:         {
1:066ef58:             return new BigIntegerToken(new BigInteger(string));
1:46ea05f:         }
1:c8b1ab4:     };
1:021ab75: 
1:ad84e4d:     public Token.TokenFactory getTokenFactory()
1:46ea05f:     {
1:066ef58:         return tokenFactory;
1:46ea05f:     }
1:f8fa6d2: 
1:f8fa6d2:     public boolean preservesOrder()
1:f8fa6d2:     {
1:f8fa6d2:         return false;
1:021ab75:     }
1:f8fa6d2: 
1:07893d7:     public static class BigIntegerToken extends ComparableObjectToken<BigInteger>
1:f8fa6d2:     {
1:07893d7:         static final long serialVersionUID = -5833589141319293006L;
1:f8fa6d2: 
1:07893d7:         public BigIntegerToken(BigInteger token)
11:066ef58:         {
1:07893d7:             super(token);
1:f8fa6d2:         }
1:e1e6a6c: 
1:07893d7:         // convenience method for testing
1:07893d7:         @VisibleForTesting
1:68d2526:         public BigIntegerToken(String token)
1:68d2526:         {
1:07893d7:             this(new BigInteger(token));
1:f8fa6d2:         }
1:e1e6a6c: 
1:07893d7:         @Override
1:07893d7:         public IPartitioner getPartitioner()
1:066ef58:         {
1:07893d7:             return instance;
1:e1e6a6c:         }
13:066ef58: 
1:07893d7:         @Override
1:07893d7:         public long getHeapSize()
1:066ef58:         {
1:07893d7:             return HEAP_SIZE;
7:066ef58:         }
1:c1a9a47: 
1:c1a9a47:         public Token increaseSlightly()
1:c1a9a47:         {
1:c1a9a47:             return new BigIntegerToken(token.add(BigInteger.ONE));
1:c1a9a47:         }
1:c1a9a47: 
1:c1a9a47:         public double size(Token next)
1:c1a9a47:         {
1:c1a9a47:             BigIntegerToken n = (BigIntegerToken) next;
1:c1a9a47:             BigInteger v = n.token.subtract(token);  // Overflow acceptable and desired.
1:c1a9a47:             double d = Math.scalb(v.doubleValue(), -127); // Scale so that the full range is 1.
1:c1a9a47:             return d > 0.0 ? d : (d + 1.0); // Adjust for signed long, also making sure t.size(t) == 1.
1:c1a9a47:         }
1:066ef58:     }
1:066ef58: 
1:e7a385a:     public BigIntegerToken getToken(ByteBuffer key)
1:066ef58:     {
1:e7a385a:         if (key.remaining() == 0)
1:f8fa6d2:             return MINIMUM;
1:a89ef1f:         return new BigIntegerToken(FBUtilities.hashToBigInteger(key));
1:4b54b8a:     }
1:4b54b8a: 
1:a89ef1f:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
1:066ef58:     {
1:a89ef1f:         Map<Token, Float> ownerships = new HashMap<Token, Float>();
1:a583123:         Iterator<Token> i = sortedTokens.iterator();
1:066ef58: 
1:a89ef1f:         // 0-case
1:f82021b:         if (!i.hasNext()) { throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?"); }
1:a89ef1f:         // 1-case
1:68d2526:         if (sortedTokens.size() == 1)
1:68d2526:         {
1:a583123:             ownerships.put(i.next(), new Float(1.0));
1:066ef58:         }
1:a89ef1f:         // n-case
1:68d2526:         else
1:68d2526:         {
1:a89ef1f:             // NOTE: All divisions must take place in BigDecimals, and all modulo operators must take place in BigIntegers.
1:a89ef1f:             final BigInteger ri = MAXIMUM;                                                  //  (used for addition later)
1:a89ef1f:             final BigDecimal r  = new BigDecimal(ri);                                       // The entire range, 2**127
1:a583123:             Token start = i.next(); BigInteger ti = ((BigIntegerToken)start).token;  // The first token and its value
1:a89ef1f:             Token t; BigInteger tim1 = ti;                                                  // The last token and its value (after loop)
1:68d2526:             while (i.hasNext())
1:68d2526:             {
1:a583123:                 t = i.next(); ti = ((BigIntegerToken)t).token;                                      // The next token and its value
1:a89ef1f:                 float x = new BigDecimal(ti.subtract(tim1).add(ri).mod(ri)).divide(r).floatValue(); // %age = ((T(i) - T(i-1) + R) % R) / R
1:a89ef1f:                 ownerships.put(t, x);                                                               // save (T(i) -> %age)
1:a89ef1f:                 tim1 = ti;                                                                          // -> advance loop
1:066ef58:             }
1:a89ef1f:             // The start token's range extends backward to the last token, which is why both were saved above.
1:a89ef1f:             float x = new BigDecimal(((BigIntegerToken)start).token.subtract(ti).add(ri).mod(ri)).divide(r).floatValue();
1:a89ef1f:             ownerships.put(start, x);
1:066ef58:         }
1:a89ef1f:         return ownerships;
1:066ef58:     }
1:066ef58: 
1:e2c6341:     public Token getMaximumToken()
1:e2c6341:     {
1:e2c6341:         return new BigIntegerToken(MAXIMUM);
1:e2c6341:     }
1:e2c6341: 
1:a67f779:     public AbstractType<?> getTokenValidator()
1:066ef58:     {
1:a67f779:         return IntegerType.instance;
1:066ef58:     }
1:0a08525: 
1:0a08525:     public AbstractType<?> partitionOrdering()
1:0a08525:     {
1:0a08525:         return partitionOrdering;
1:0a08525:     }
1:e2c6341: 
1:e2c6341:     public Optional<Splitter> splitter()
1:e2c6341:     {
1:e2c6341:         return Optional.of(splitter);
1:e2c6341:     }
1:e2c6341: 
1:066ef58: }
============================================================================
author:Dikang Gu
-------------------------------------------------------------------------------
commit:e2a0d75
/////////////////////////////////////////////////////////////////////////
1:     public Token split(Token ltoken, Token rtoken, double ratioToLeft)
1:     {
1:         BigDecimal left = ltoken.equals(MINIMUM) ? BigDecimal.ZERO : new BigDecimal(((BigIntegerToken)ltoken).token),
1:                    right = rtoken.equals(MINIMUM) ? BigDecimal.ZERO : new BigDecimal(((BigIntegerToken)rtoken).token),
1:                    ratio = BigDecimal.valueOf(ratioToLeft);
1: 
1:         BigInteger newToken;
1: 
1:         if (left.compareTo(right) < 0)
1:         {
1:             newToken = right.subtract(left).multiply(ratio).add(left).toBigInteger();
1:         }
1:         else
1:         {
1:             // wrapping case
1:             // L + ((R - min) + (max - L)) * ratio
1:             BigDecimal max = new BigDecimal(MAXIMUM);
1: 
1:             newToken = max.add(right).subtract(left).multiply(ratio).add(left).toBigInteger().mod(MAXIMUM);
1:         }
1: 
1:         assert isValidToken(newToken) : "Invalid tokens from split";
1: 
1:         return new BigIntegerToken(newToken);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean isValidToken(BigInteger token) {
1:         return token.compareTo(ZERO) >= 0 && token.compareTo(MAXIMUM) <= 0;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if(!isValidToken(new BigInteger(token)))
1:                     throw new ConfigurationException("Token must be >= 0 and <= 2**127");
commit:c1a9a47
/////////////////////////////////////////////////////////////////////////
1: 
1:         public Token increaseSlightly()
1:         {
1:             return new BigIntegerToken(token.add(BigInteger.ONE));
1:         }
1: 
1:         public double size(Token next)
1:         {
1:             BigIntegerToken n = (BigIntegerToken) next;
1:             BigInteger v = n.token.subtract(token);  // Overflow acceptable and desired.
1:             double d = Math.scalb(v.doubleValue(), -127); // Scale so that the full range is 1.
1:             return d > 0.0 ? d : (d + 1.0); // Adjust for signed long, also making sure t.size(t) == 1.
1:         }
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e6d22da
/////////////////////////////////////////////////////////////////////////
1:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, "host/127.0.0.1", 0));
commit:c6ec31b
/////////////////////////////////////////////////////////////////////////
0:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, 0));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:     {
/////////////////////////////////////////////////////////////////////////
1:         public BigIntegerToken(String token)
1:         {
/////////////////////////////////////////////////////////////////////////
1:         if (sortedTokens.size() == 1)
1:         {
1:         else
1:         {
1:             while (i.hasNext())
1:             {
commit:a583123
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Iterator<Token> i = sortedTokens.iterator();
1:             ownerships.put(i.next(), new Float(1.0));
1:             Token start = i.next(); BigInteger ti = ((BigIntegerToken)start).token;  // The first token and its value
1:                 t = i.next(); ti = ((BigIntegerToken)t).token;                                      // The next token and its value
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:47d3b7e
/////////////////////////////////////////////////////////////////////////
1:     public BigIntegerToken getRandomToken(Random random)
1:     {
0:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random));
1:         if ( token.signum() == -1 )
1:             token = token.multiply(BigInteger.valueOf(-1L));
1:         return new BigIntegerToken(token);
1:     }
1: 
commit:3787d6c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         for (int i = fromdisk.position(); i < fromdisk.limit(); i++)
0:             if (fromdisk.get(i) == DELIMITER_BYTE)
/////////////////////////////////////////////////////////////////////////
0:         String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint, UTF_8);
0:         ByteBuffer key = fromdisk.duplicate();
0:         key.position(splitPoint + 1);
0:         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), key);
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:e2c6341
/////////////////////////////////////////////////////////////////////////
1:     private final Splitter splitter = new Splitter(this)
1:     {
1:         public Token tokenForValue(BigInteger value)
1:         {
1:             return new BigIntegerToken(value);
1:         }
1: 
1:         public BigInteger valueForToken(Token token)
1:         {
1:             return ((BigIntegerToken)token).getTokenValue();
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Token getMaximumToken()
1:     {
1:         return new BigIntegerToken(MAXIMUM);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Optional<Splitter> splitter()
1:     {
1:         return Optional.of(splitter);
1:     }
1: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
/////////////////////////////////////////////////////////////////////////
1:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public AbstractType<?> partitionOrdering()
1:     {
1:         return partitionOrdering;
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ObjectSizes;
/////////////////////////////////////////////////////////////////////////
0:     private static final int EMPTY_SIZE = (int) ObjectSizes.measureDeep(new BigIntegerToken(FBUtilities.hashToBigInteger(ByteBuffer.allocate(1))));
1: 
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(BigIntegerToken token)
1:     {
0:         return EMPTY_SIZE;
1:     }
1: 
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5613f8f
commit:7e4ef1c
/////////////////////////////////////////////////////////////////////////
1:     public DecoratedKey decorateKey(ByteBuffer key)
0:         return new DecoratedKey(getToken(key), key);
0:     public DecoratedKey convertFromDiskFormat(ByteBuffer fromdisk)
/////////////////////////////////////////////////////////////////////////
0:         return new DecoratedKey(new BigIntegerToken(token), key);
commit:9a5c679
/////////////////////////////////////////////////////////////////////////
1:     public static final BigInteger MAXIMUM = new BigInteger("2").pow(127);
/////////////////////////////////////////////////////////////////////////
0:                 BigInteger i = new BigInteger(token);
0:                 if (i.compareTo(ZERO) < 0)
0:                     throw new ConfigurationException("Token must be >= 0");
0:                 if (i.compareTo(MAXIMUM) > 0)
0:                     throw new ConfigurationException("Token must be <= 2**127");
/////////////////////////////////////////////////////////////////////////
0:             final BigInteger ri = MAXIMUM(127);                             //  (used for addition later)
commit:6a9a336
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
1:         public void validate(String token) throws ConfigurationException
1:         {
1:             try
1:             {
0:                 new BigInteger(token);
1:             }
1:             catch (NumberFormatException e)
1:             {
1:                 throw new ConfigurationException(e.getMessage());
1:             }
1:         }
1: 
commit:ec26ee7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position());
commit:46ea05f
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
0:         String token = null;
0:         try
1:         {
0:             token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position(), UTF_8);
1:         }
0:         catch (CharacterCodingException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
commit:6aa5b81
/////////////////////////////////////////////////////////////////////////
1:             return new BigIntegerToken(new BigInteger(ByteBufferUtil.getArray(bytes)));
commit:b814afa
/////////////////////////////////////////////////////////////////////////
0:         String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position(), UTF_8);
commit:0fd507b
/////////////////////////////////////////////////////////////////////////
1:     public static final BigInteger ZERO = new BigInteger("0");
1:     public static final BigIntegerToken MINIMUM = new BigIntegerToken("-1");
/////////////////////////////////////////////////////////////////////////
1:         // the symbolic MINIMUM token should act as ZERO: the empty bit array
1:         BigInteger left = ltoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)ltoken).token;
1:         BigInteger right = rtoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)rtoken).token;
1:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 127);
commit:ef25537
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
1: 
commit:8358669
/////////////////////////////////////////////////////////////////////////
0:         for (int i = fromdisk.position()+fromdisk.arrayOffset(); i < fromdisk.limit()+fromdisk.arrayOffset(); i++)
/////////////////////////////////////////////////////////////////////////
0:         byte[] key = Arrays.copyOfRange(fromdisk.array(), splitPoint + 1, fromdisk.limit()+fromdisk.arrayOffset());
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
1: 
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<BigIntegerToken> decorateKey(ByteBuffer key)
0:     public DecoratedKey<BigIntegerToken> convertFromDiskFormat(ByteBuffer fromdisk)
0:         for (int i = fromdisk.position()+fromdisk.arrayOffset(); i < fromdisk.limit(); i++)
0:             if (fromdisk.array()[i] == DELIMITER_BYTE)
/////////////////////////////////////////////////////////////////////////
0:         String token = new String(fromdisk.array(), fromdisk.position()+fromdisk.arrayOffset(), splitPoint, UTF_8);
0:         byte[] key = Arrays.copyOfRange(fromdisk.array(), splitPoint + 1, fromdisk.limit());
0:         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), ByteBuffer.wrap(key));
1:     public Token midpoint(Token ltoken, Token rtoken)
0:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(((BigIntegerToken)ltoken).token, ((BigIntegerToken)rtoken).token, 127);
/////////////////////////////////////////////////////////////////////////
0:         BigInteger token = FBUtilities.md5hash(GuidGenerator.guidAsBytes());
0:         public ByteBuffer toByteArray(Token<BigInteger> bigIntegerToken)
1:             return ByteBuffer.wrap(bigIntegerToken.token.toByteArray());
0:         public Token<BigInteger> fromByteArray(ByteBuffer bytes)
0:             byte[] b = new byte[bytes.remaining()];
0:             bytes.get(b);
0:             bytes.rewind();
1:             
0:             return new BigIntegerToken(new BigInteger(b));
/////////////////////////////////////////////////////////////////////////
1:     public BigIntegerToken getToken(ByteBuffer key)
1:         if (key.remaining() == 0)
commit:b6b1053
/////////////////////////////////////////////////////////////////////////
commit:f4be897
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
1: 
/////////////////////////////////////////////////////////////////////////
0:         String token = new String(fromdisk, 0, splitPoint, UTF_8);
/////////////////////////////////////////////////////////////////////////
0:         byte[] prefix = key.token.toString().getBytes(UTF_8);
commit:d6c2bb0
/////////////////////////////////////////////////////////////////////////
0:         if (key.isEmpty())
1:             return MINIMUM;
commit:b4cae03
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4a6b002
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.Pair;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(ltoken.token, rtoken.token, 127);
1:         // discard the remainder
1:         return new BigIntegerToken(midpair.left);
commit:e946c63
/////////////////////////////////////////////////////////////////////////
1:     public BigIntegerToken getRandomToken()
commit:67ae1ee
/////////////////////////////////////////////////////////////////////////
0: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
0:     private static final String DELIMITER = ":";
1:     
0:     //to avoid having to create the pattern on every String.split
0:     private Pattern diskDelimiter = Pattern.compile(DELIMITER);
1: 
0:     private static final Comparator<DecoratedKey<BigIntegerToken>> comparator =
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<BigIntegerToken> decorateKey(String key)
0:     public DecoratedKey<BigIntegerToken> convertFromDiskFormat(String key)
0:         String[] parts = diskDelimiter.split(key, 2);
0:         assert parts.length == 2;
0:         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(parts[0]), parts[1]);
0:     public String convertToDiskFormat(DecoratedKey<BigIntegerToken> key)
1:     {
0:         return key.token + DELIMITER + key.key;
1:     }
1: 
0:     public Comparator<DecoratedKey<BigIntegerToken>> getDecoratedKeyComparator()
commit:a215c38
/////////////////////////////////////////////////////////////////////////
0:             int v = o1.token.compareTo(o2.token);
0:             return o1.key.compareTo(o2.key);
commit:c8b1ab4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.DecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:     private static final Comparator<DecoratedKey<BigIntegerToken>> objComparator = 
0:         new Comparator<DecoratedKey<BigIntegerToken>>() {
0:         public int compare(DecoratedKey<BigIntegerToken> o1, DecoratedKey<BigIntegerToken> o2)
1:         {
0:             // first, compare on the bigint hash "decoration".  usually this will be enough.
0:             int v = o1.getToken().compareTo(o2.getToken());
0:             if (v != 0) {
0:                 return v;
1:             }
1: 
0:             // if the hashes are equal, compare the strings
0:             return o1.getKey().compareTo(o2.getKey());
1:         }
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<BigIntegerToken> decorateKeyObj(String key)
1:     {
0:         return new DecoratedKey<BigIntegerToken>(getToken(key), key);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
0:     public Comparator<DecoratedKey<BigIntegerToken>> getDecoratedKeyObjComparator()
1:     {
0:         return objComparator;
1:     }
commit:021ab75
/////////////////////////////////////////////////////////////////////////
0:     public static final BigInteger TWO = new BigInteger("2");
0:     public static final BigInteger MD5_MAX = TWO.pow(127);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public BigIntegerToken midpoint(BigIntegerToken ltoken, BigIntegerToken rtoken)
1:     {
0:         BigInteger left = ltoken.token;
0:         BigInteger right = rtoken.token;
1: 
0:         BigInteger midpoint;
0:         if (left.compareTo(right) < 0)
1:         {
0:             midpoint = left.add(right).divide(TWO);
1:         }
0:         else
1:         {
0:             // wrapping case
0:             BigInteger distance = MD5_MAX.add(right).subtract(left);
0:             BigInteger unchecked = distance.divide(TWO).add(left);
0:             midpoint = (unchecked.compareTo(MD5_MAX) > 0) ? unchecked.subtract(MD5_MAX) : unchecked;
1:         }
0:         return new BigIntegerToken(midpoint);
1:     }
1: 
commit:f8fa6d2
/////////////////////////////////////////////////////////////////////////
0: public class RandomPartitioner implements IPartitioner<BigIntegerToken>
0:     public static final BigIntegerToken MINIMUM = new BigIntegerToken("0");
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public BigIntegerToken getMinimumToken()
1:     {
1:         return MINIMUM;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean preservesOrder()
1:     {
1:         return false;
1:     }
1: 
0:     public BigIntegerToken getToken(String key)
commit:e959b2c
/////////////////////////////////////////////////////////////////////////
0:     public Token getToken(String key)
commit:e1e6a6c
/////////////////////////////////////////////////////////////////////////
0: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0:             // StringTokenizer is faster than String.split()
0:             StringTokenizer st1 = new StringTokenizer(o1, ":");
0:             StringTokenizer st2 = new StringTokenizer(o2, ":");
1: 
0:             // first, compare on the bigint hash "decoration".  usually this will be enough.
0:             BigInteger i1 = new BigInteger(st1.nextToken());
0:             BigInteger i2 = new BigInteger(st2.nextToken());
1: 
0:             // if the hashes are equal, compare the strings
0:             return st1.nextToken().compareTo(st2.nextToken());
/////////////////////////////////////////////////////////////////////////
1: }
commit:066ef58
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.dht;
1: 
1: import java.math.BigInteger;
0: import java.util.Comparator;
1: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.GuidGenerator;
1: 
1: /**
1:  * This class generates a BigIntegerToken using MD5 hash.
1:  */
1: public class RandomPartitioner implements IPartitioner
1: {
0:     private static final Comparator<String> comparator = new Comparator<String>()
1:     {
0:         public int compare(String o1, String o2)
1:         {
0:             String[] split1 = o1.split(":", 2);
0:             String[] split2 = o2.split(":", 2);
0:             BigInteger i1 = new BigInteger(split1[0]);
0:             BigInteger i2 = new BigInteger(split2[0]);
0:             int v = i1.compareTo(i2);
0:             if (v != 0) {
0:                 return v;
1:             }
0:             return split1[1].compareTo(split2[1]);
1:         }
0:     };
0:     private static final Comparator<String> rcomparator = new Comparator<String>()
1:     {
0:         public int compare(String o1, String o2)
1:         {
0:             return -comparator.compare(o1, o2);
1:         }
0:     };
1: 
0:     public String decorateKey(String key)
1:     {
0:         return FBUtilities.hash(key).toString() + ":" + key;
1:     }
1: 
0:     public String undecorateKey(String decoratedKey)
1:     {
0:         return decoratedKey.split(":", 2)[1];
1:     }
1: 
0:     public Comparator<String> getDecoratedKeyComparator()
1:     {
0:         return comparator;
1:     }
1: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
1:     {
0:         return rcomparator;
1:     }
1: 
0:     public BigIntegerToken getDefaultToken()
1:     {
0:         String initialToken = DatabaseDescriptor.getInitialToken();
0:         if (initialToken != null)
0:             return new BigIntegerToken(new BigInteger(initialToken));
1: 
0:         // generate random token
0:         String guid = GuidGenerator.guid();
0:         BigInteger token = FBUtilities.hash(guid);
1:         if ( token.signum() == -1 )
1:             token = token.multiply(BigInteger.valueOf(-1L));
1:         return new BigIntegerToken(token);
1:     }
1: 
0:     private final Token.TokenFactory<BigInteger> tokenFactory = new Token.TokenFactory<BigInteger>() {
0:         public byte[] toByteArray(Token<BigInteger> bigIntegerToken)
1:         {
0:             return bigIntegerToken.token.toByteArray();
1:         }
1: 
0:         public Token<BigInteger> fromByteArray(byte[] bytes)
1:         {
0:             return new BigIntegerToken(new BigInteger(bytes));
1:         }
1: 
0:         public String toString(Token<BigInteger> bigIntegerToken)
1:         {
1:             return bigIntegerToken.token.toString();
1:         }
1: 
0:         public Token<BigInteger> fromString(String string)
1:         {
1:             return new BigIntegerToken(new BigInteger(string));
1:         }
0:     };
1: 
0:     public Token.TokenFactory<BigInteger> getTokenFactory()
1:     {
1:         return tokenFactory;
1:     }
1: 
0:     public Token getInitialToken(String key)
1:     {
0:         return new BigIntegerToken(FBUtilities.hash(key));
1:     }
commit:324c3c3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0:         String initialToken = DatabaseDescriptor.getInitialToken();
0:         if (initialToken != null)
0:             return new BigIntegerToken(new BigInteger(initialToken));
0: 
0:         // generate random token
commit:ec29172
/////////////////////////////////////////////////////////////////////////
0:         public String toString(Token<BigInteger> bigIntegerToken)
0:         {
0:             return bigIntegerToken.token.toString();
0:         }
0: 
commit:71739ef
commit:bfb2e95
/////////////////////////////////////////////////////////////////////////
0:     public Token getInitialToken(String key)
commit:907d92e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.GuidGenerator;
0:  * This class generates a BigIntegerToken using MD5 hash.
/////////////////////////////////////////////////////////////////////////
0:         return FBUtilities.hash(key).toString() + ":" + key;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public BigIntegerToken getDefaultToken()
0:     {
0:         String guid = GuidGenerator.guid();
0:         BigInteger token = FBUtilities.hash(guid);
0:         if ( token.signum() == -1 )
0:             token = token.multiply(BigInteger.valueOf(-1L));
0:         return new BigIntegerToken(token);
0:     }
0: 
0:     private final Token.TokenFactory<BigInteger> tokenFactory = new Token.TokenFactory<BigInteger>() {
0:         public byte[] toByteArray(Token<BigInteger> bigIntegerToken)
0:         {
0:             return bigIntegerToken.token.toByteArray();
0:         }
0: 
0:         public Token<BigInteger> fromByteArray(byte[] bytes)
0:         {
0:             return new BigIntegerToken(new BigInteger(bytes));
0:         }
0: 
0:         public Token<BigInteger> fromString(String string)
0:         {
0:             return new BigIntegerToken(new BigInteger(string));
0:         }
0:     };
0: 
0:     public Token.TokenFactory<BigInteger> getTokenFactory()
0:     {
0:         return tokenFactory;
0:     }
0: 
0:     public Token getTokenForKey(String key)
0:     {
0:         return new BigIntegerToken(FBUtilities.hash(key));
0:     }
commit:91afe8b
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.dht;
0: import org.apache.cassandra.dht.IPartitioner;
commit:40fa7d4
/////////////////////////////////////////////////////////////////////////
0: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
0:     private static final Comparator<String> comparator = new Comparator<String>()
0:     {
0:         public int compare(String o1, String o2)
0:         {
0:             String[] split1 = o1.split(":", 2);
0:             String[] split2 = o2.split(":", 2);
0:             BigInteger i1 = new BigInteger(split1[0]);
0:             BigInteger i2 = new BigInteger(split2[0]);
0:             int v = i1.compareTo(i2);
0:             if (v != 0) {
0:                 return v;
0:             }
0:             return split1[1].compareTo(split2[1]);
0:         }
0:     };
0:     private static final Comparator<String> rcomparator = new Comparator<String>()
0:     {
0:         public int compare(String o1, String o2)
0:         {
0:             return -comparator.compare(o1, o2);
0:         }
0:     };
0: 
0:     public BigInteger hash(String key)
0: 
0:     public String decorateKey(String key)
0:     {
0:         return hash(key).toString() + ":" + key;
0:     }
0: 
0:     public String undecorateKey(String decoratedKey)
0:     {
0:         return decoratedKey.split(":", 2)[1];
0:     }
0: 
0:     public Comparator<String> getDecoratedKeyComparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return rcomparator;
0:     }
commit:dd61d51
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return i1.compareTo(i2);
0:         }
0:     };
0:     private static final Comparator<String> reverseComparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:            return -comparator.compare(o1, o2);
/////////////////////////////////////////////////////////////////////////
0:     public Comparator<String> getDecoratedKeyComparator()
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return reverseComparator;
0:     }
0: 
commit:20e081f
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.dht;
0: 
0: import java.math.BigInteger;
0: import java.util.Comparator;
0: 
0: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.GuidGenerator;
0: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.dht.BigIntegerToken;
0: import org.apache.cassandra.service.StorageService;
0: 
0: /**
0:  * This class generates a MD5 hash of the key. It uses the standard technique
0:  * used in all DHT's.
0:  * 
0:  * @author alakshman
0:  * 
0:  */
0: public class RandomPartitioner implements IPartitioner
0: {
0:     private static final Comparator<String> comparator = new Comparator<String>() {
0:         public int compare(String o1, String o2)
0:         {
0:             BigInteger i1 = new BigInteger(o1.split(":")[0]);
0:             BigInteger i2 = new BigInteger(o2.split(":")[0]);
0:             return i2.compareTo(i1);
0:         }
0:     };
0: 
0:     public BigInteger hash(String key)
0: 	{
0: 		return FBUtilities.hash(key);
0: 	}
0: 
0:     public String decorateKey(String key)
0:     {
0:         return hash(key).toString() + ":" + key;
0:     }
0: 
0:     public String undecorateKey(String decoratedKey)
0:     {
0:         return decoratedKey.split(":")[1];
0:     }
0: 
0:     public Comparator<String> getReverseDecoratedKeyComparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     public BigIntegerToken getDefaultToken()
0:     {
0:         String guid = GuidGenerator.guid();
0:         BigInteger token = FBUtilities.hash(guid);
0:         if ( token.signum() == -1 )
0:             token = token.multiply(BigInteger.valueOf(-1L));
0:         return new BigIntegerToken(token);
0:     }
0: 
0:     private final Token.TokenFactory<BigInteger> tokenFactory = new Token.TokenFactory<BigInteger>() {
0:         public byte[] toByteArray(Token<BigInteger> bigIntegerToken)
0:         {
0:             return bigIntegerToken.token.toByteArray();
0:         }
0: 
0:         public Token<BigInteger> fromByteArray(byte[] bytes)
0:         {
0:             return new BigIntegerToken(new BigInteger(bytes));
0:         }
0: 
0:         public Token<BigInteger> fromString(String string)
0:         {
0:             return new BigIntegerToken(new BigInteger(string));
0:         }
0:     };
0: 
0:     public Token.TokenFactory<BigInteger> getTokenFactory()
0:     {
0:         return tokenFactory;
0:     }
0: 
0:     public Token getTokenForKey(String key)
0:     {
0:         return new BigIntegerToken(FBUtilities.hash(key));
0:     }
0: }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
/////////////////////////////////////////////////////////////////////////
0:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public AbstractType<?> partitionOrdering()
0:     {
0:         return partitionOrdering;
0:     }
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.annotations.VisibleForTesting;
0: 
/////////////////////////////////////////////////////////////////////////
0: public class RandomPartitioner implements IPartitioner
1:     private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(new BigIntegerToken(FBUtilities.hashToBigInteger(ByteBuffer.allocate(1))));
0: 
1:     public static final RandomPartitioner instance = new RandomPartitioner();
/////////////////////////////////////////////////////////////////////////
1:     public static class BigIntegerToken extends ComparableObjectToken<BigInteger>
0:     {
1:         static final long serialVersionUID = -5833589141319293006L;
0: 
1:         public BigIntegerToken(BigInteger token)
0:         {
1:             super(token);
0:         }
0: 
1:         // convenience method for testing
1:         @VisibleForTesting
0:         public BigIntegerToken(String token) {
1:             this(new BigInteger(token));
0:         }
0: 
1:         @Override
1:         public IPartitioner getPartitioner()
0:         {
1:             return instance;
0:         }
0: 
1:         @Override
1:         public long getHeapSize()
0:         {
1:             return HEAP_SIZE;
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
0: public class RandomPartitioner extends AbstractPartitioner
/////////////////////////////////////////////////////////////////////////
0:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory() {
1:         public ByteBuffer toByteArray(Token token)
1:             BigIntegerToken bigIntegerToken = (BigIntegerToken) token;
1:         public Token fromByteArray(ByteBuffer bytes)
1:         public String toString(Token token)
1:             BigIntegerToken bigIntegerToken = (BigIntegerToken) token;
/////////////////////////////////////////////////////////////////////////
1:         public Token fromString(String string)
1:     public Token.TokenFactory getTokenFactory()
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(Token token)
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:18d8f26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.CachedHashDecoratedKey;
/////////////////////////////////////////////////////////////////////////
1:         return new CachedHashDecoratedKey(getToken(key), key);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.BufferDecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:         return new BufferDecoratedKey(getToken(key), key);
commit:a89ef1f
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
0: import java.nio.charset.CharacterCodingException;
1: import java.util.*;
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.GuidGenerator;
0: import org.apache.cassandra.utils.Pair;
0:  * This class generates a BigIntegerToken using MD5 hash.
0: public class RandomPartitioner extends AbstractPartitioner<BigIntegerToken>
0:     public static final BigInteger ZERO = new BigInteger("0");
0:     public static final BigIntegerToken MINIMUM = new BigIntegerToken("-1");
0:     public static final BigInteger MAXIMUM = new BigInteger("2").pow(127);
0: 
0:     private static final byte DELIMITER_BYTE = ":".getBytes()[0];
0: 
0:     public DecoratedKey decorateKey(ByteBuffer key)
0:         return new DecoratedKey(getToken(key), key);
0:     }
0: 
0:     public DecoratedKey convertFromDiskFormat(ByteBuffer fromdisk)
0:     {
0:         // find the delimiter position
0:         int splitPoint = -1;
0:         for (int i = fromdisk.position(); i < fromdisk.limit(); i++)
0:         {
0:             if (fromdisk.get(i) == DELIMITER_BYTE)
0:             {
0:                 splitPoint = i;
0:                 break;
0:             }
0:         }
0:         assert splitPoint != -1;
0: 
0:         // and decode the token and key
0:         String token = null;
0:         try
0:         {
0:             token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position());
0:         }
0:         catch (CharacterCodingException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:         ByteBuffer key = fromdisk.duplicate();
0:         key.position(splitPoint + 1);
0:         return new DecoratedKey(new BigIntegerToken(token), key);
0:     }
0: 
0:     public Token midpoint(Token ltoken, Token rtoken)
0:     {
0:         // the symbolic MINIMUM token should act as ZERO: the empty bit array
0:         BigInteger left = ltoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)ltoken).token;
0:         BigInteger right = rtoken.equals(MINIMUM) ? ZERO : ((BigIntegerToken)rtoken).token;
0:         Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 127);
0:         // discard the remainder
0:         return new BigIntegerToken(midpair.left);
0:     }
0: 
0:     public BigIntegerToken getMinimumToken()
0:     {
0:         return MINIMUM;
0:     }
0: 
0:     public BigIntegerToken getRandomToken()
0:     {
1:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes());
0:         if ( token.signum() == -1 )
0:             token = token.multiply(BigInteger.valueOf(-1L));
0:         return new BigIntegerToken(token);
0:     }
0: 
0:     private final Token.TokenFactory<BigInteger> tokenFactory = new Token.TokenFactory<BigInteger>() {
0:         public ByteBuffer toByteArray(Token<BigInteger> bigIntegerToken)
0:         {
0:             return ByteBuffer.wrap(bigIntegerToken.token.toByteArray());
0:         }
0: 
0:         public Token<BigInteger> fromByteArray(ByteBuffer bytes)
0:         {
0:             return new BigIntegerToken(new BigInteger(ByteBufferUtil.getArray(bytes)));
0:         }
0: 
0:         public String toString(Token<BigInteger> bigIntegerToken)
0:         {
0:             return bigIntegerToken.token.toString();
0:         }
0: 
0:         public void validate(String token) throws ConfigurationException
0:         {
0:             try
0:             {
0:                 BigInteger i = new BigInteger(token);
0:                 if (i.compareTo(ZERO) < 0)
0:                     throw new ConfigurationException("Token must be >= 0");
0:                 if (i.compareTo(MAXIMUM) > 0)
0:                     throw new ConfigurationException("Token must be <= 2**127");
0:             }
0:             catch (NumberFormatException e)
0:             {
0:                 throw new ConfigurationException(e.getMessage());
0:             }
0:         }
0: 
0:         public Token<BigInteger> fromString(String string)
0:         {
0:             return new BigIntegerToken(new BigInteger(string));
0:         }
0:     };
0: 
0:     public Token.TokenFactory<BigInteger> getTokenFactory()
0:     {
0:         return tokenFactory;
0:     }
0: 
0:     public boolean preservesOrder()
0:     {
0:         return false;
0:     }
0: 
0:     public BigIntegerToken getToken(ByteBuffer key)
0:     {
0:         if (key.remaining() == 0)
0:             return MINIMUM;
1:         return new BigIntegerToken(FBUtilities.hashToBigInteger(key));
0:     }
0: 
1:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
0:     {
1:         Map<Token, Float> ownerships = new HashMap<Token, Float>();
0:         Iterator i = sortedTokens.iterator();
0: 
1:         // 0-case
0:         if (!i.hasNext()) { throw new RuntimeException("No nodes present in the cluster. How did you call this?"); }
1:         // 1-case
0:         if (sortedTokens.size() == 1) {
0:             ownerships.put((Token)i.next(), new Float(1.0));
0:         }
1:         // n-case
0:         else {
1:             // NOTE: All divisions must take place in BigDecimals, and all modulo operators must take place in BigIntegers.
1:             final BigInteger ri = MAXIMUM;                                                  //  (used for addition later)
1:             final BigDecimal r  = new BigDecimal(ri);                                       // The entire range, 2**127
0:             Token start = (Token)i.next(); BigInteger ti = ((BigIntegerToken)start).token;  // The first token and its value
1:             Token t; BigInteger tim1 = ti;                                                  // The last token and its value (after loop)
0:             while (i.hasNext()) {
0:                 t = (Token)i.next(); ti = ((BigIntegerToken)t).token;                               // The next token and its value
1:                 float x = new BigDecimal(ti.subtract(tim1).add(ri).mod(ri)).divide(r).floatValue(); // %age = ((T(i) - T(i-1) + R) % R) / R
1:                 ownerships.put(t, x);                                                               // save (T(i) -> %age)
1:                 tim1 = ti;                                                                          // -> advance loop
0:             }
1:             // The start token's range extends backward to the last token, which is why both were saved above.
1:             float x = new BigDecimal(((BigIntegerToken)start).token.subtract(ti).add(ri).mod(ri)).divide(r).floatValue();
1:             ownerships.put(start, x);
0:         }
1:         return ownerships;
commit:f41684f
/////////////////////////////////////////////////////////////////////////
0:  * This class generates a BigIntegerToken using a MD5 hash.
0: public class RandomPartitioner extends AbstractHashedPartitioner
0:     protected BigInteger hash(ByteBuffer buffer)
0:         return FBUtilities.hashToBigInteger(buffer);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:f82021b
/////////////////////////////////////////////////////////////////////////
1:         if (!i.hasNext()) { throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?"); }
commit:25438e6
commit:37a0d32
commit:de212e5
/////////////////////////////////////////////////////////////////////////
0:         if (!i.hasNext()) { throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?"); }
commit:2ed36c6
/////////////////////////////////////////////////////////////////////////
0:                 t = (Token)i.next(); ti = ((BigIntegerToken)t).token;                               // The next token and its value
0:                 float x = new BigDecimal(ti.subtract(tim1).add(ri).mod(ri)).divide(r).floatValue(); // %age = ((T(i) - T(i-1) + R) % R) / R
0:                 ownerships.put(t, x);                                                               // save (T(i) -> %age)
0:                 tim1 = ti;                                                                          // -> advance loop
0:             // The start token's range extends backward to the last token, which is why both were saved above.
0:             float x = new BigDecimal(((BigIntegerToken)start).token.subtract(ti).add(ri).mod(ri)).divide(r).floatValue();
0:             ownerships.put(start, x);
commit:671de68
/////////////////////////////////////////////////////////////////////////
0:         BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes());
/////////////////////////////////////////////////////////////////////////
0:         return new BigIntegerToken(FBUtilities.hashToBigInteger(key));
commit:2564647
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigDecimal;
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
0:     {
0:         Map<Token, Float> ownerships = new HashMap<Token, Float>();
0:         Iterator i = sortedTokens.iterator();
0: 
0:         // 0-case
0:         if (!i.hasNext()) { throw new RuntimeException("No nodes present in the cluster. How did you call this?"); }
0:         // 1-case
0:         if (sortedTokens.size() == 1) {
0:             ownerships.put((Token)i.next(), new Float(1.0));
0:         }
0:         // n-case
0:         else {
0:             // NOTE: All divisions must take place in BigDecimals, and all modulo operators must take place in BigIntegers.
0:             final BigInteger ri = new BigInteger("2").pow(127);                             //  (used for addition later)
0:             final BigDecimal r  = new BigDecimal(ri);                                       // The entire range, 2**127
0:             Token start = (Token)i.next(); BigInteger ti = ((BigIntegerToken)start).token;  // The first token and its value
0:             Token t; BigInteger tim1 = ti;                                                  // The last token and its value (after loop)
0:             while (i.hasNext()) {
0:                 t = (Token)i.next(); ti = ((BigIntegerToken)t).token;                       // The next token and its value
0:                 float x = new BigDecimal(ti.subtract(tim1)).divide(r).floatValue();         // %age = T(i) - T(i-1) / R
0:                 ownerships.put(t, x);                                                       // save (T(i) -> %age)
0:                 tim1 = ti;                                                                  // -> advance loop
0:             }
0:             // The start token's range extends backward to the last token, which is why both were saved
0:             //  above. The simple calculation for this is: T(start) - T(end) + r % r / r.
0:             //  (In the 1-case, this produces 0% instead of 100%.)
0:             ownerships.put(start, new BigDecimal(((BigIntegerToken)start).token.subtract(ti).add(ri).mod(ri)).divide(r).floatValue());
0:         }
0:         return ownerships;
0:     }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a67f779
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.IntegerType;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public AbstractType<?> getTokenValidator()
0:     {
1:         return IntegerType.instance;
0:     }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:686139a
/////////////////////////////////////////////////////////////////////////
0:     public BigIntegerToken getMinimumToken()
commit:554223b
/////////////////////////////////////////////////////////////////////////
0: public class RandomPartitioner extends AbstractPartitioner<BigIntegerToken>
commit:8c5f958
/////////////////////////////////////////////////////////////////////////
0:             final BigInteger ri = MAXIMUM;                                                  //  (used for addition later)
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<BigIntegerToken> decorateKey(byte[] key)
/////////////////////////////////////////////////////////////////////////
0:         BigInteger token = FBUtilities.md5hash(GuidGenerator.guid().getBytes());
/////////////////////////////////////////////////////////////////////////
0:     public BigIntegerToken getToken(byte[] key)
0:         if (key.length == 0)
0:         return new BigIntegerToken(FBUtilities.md5hash(key));
commit:f3bb9ac
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import org.apache.cassandra.db.DBConstants;
/////////////////////////////////////////////////////////////////////////
0:     private static final byte DELIMITER_BYTE = ":".getBytes()[0];
0:     public DecoratedKey<BigIntegerToken> convertFromDiskFormat(byte[] fromdisk)
0:         // find the delimiter position
0:         int splitPoint = -1;
0:         for (int i = 0; i < fromdisk.length; i++)
0:         {
0:             if (fromdisk[i] == DELIMITER_BYTE)
0:             {
0:                 splitPoint = i;
0:                 break;
0:             }
0:         }
0:         assert splitPoint != -1;
0:         // and decode the token and key
0:         String token = new String(fromdisk, 0, splitPoint, FBUtilities.UTF8);
0:         byte[] key = Arrays.copyOfRange(fromdisk, splitPoint + 1, fromdisk.length);
0:         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), key);
0:     public byte[] convertToDiskFormat(DecoratedKey<BigIntegerToken> key)
0:         // encode token prefix and calculate final length (with delimiter)
0:         byte[] prefix = key.token.toString().getBytes(FBUtilities.UTF8);
0:         int length = prefix.length + 1 + key.key.length;
0:         assert length <= FBUtilities.MAX_UNSIGNED_SHORT;
0: 
0:         // copy into output bytes
0:         byte[] todisk = new byte[length];
0:         System.arraycopy(prefix, 0, todisk, 0, prefix.length);
0:         todisk[prefix.length] = DELIMITER_BYTE;
0:         System.arraycopy(key.key, 0, todisk, prefix.length + 1, key.key.length);
0:         return todisk;
commit:c1d34fb
/////////////////////////////////////////////////////////////////////////
0:         // FIXME
0:         return key.token + DELIMITER + new String(key.key, FBUtilities.UTF8);
author:Chris Goffinet
-------------------------------------------------------------------------------
commit:75db7b5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         int splitPoint = key.indexOf(DELIMITER);
0:         String first = key.substring(0, splitPoint);
0:         String second = key.substring(splitPoint+1);
0: 
0:         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(first), second);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:2b27a9f
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.service;
0: 
0: import java.math.BigInteger;
0: 
0: import org.apache.cassandra.utils.FBUtilities;
0: 
0: /**
0:  * This class generates a MD5 hash of the key. It uses the standard technique
0:  * used in all DHT's.
0:  * 
0:  * @author alakshman
0:  * 
0:  */
0: public class RandomPartitioner implements IPartitioner
0: {
0: 	public BigInteger hash(String key)
0: 	{
0: 		return FBUtilities.hash(key);
0: 	}
0: }
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.service;
0: 
0: import java.math.BigInteger;
0: 
0: import org.apache.cassandra.utils.FBUtilities;
0: 
0: /**
0:  * This class generates a MD5 hash of the key. It uses the standard technique
0:  * used in all DHT's.
0:  * 
0:  * @author alakshman
0:  * 
0:  */
0: public class RandomPartitioner implements IPartitioner
0: {
0: 	public BigInteger hash(String key)
0: 	{
0: 		return FBUtilities.hash(key);
0: 	}
0: }
============================================================================