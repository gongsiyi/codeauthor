1:01115f7: /*
1:01115f7:  * Licensed to the Apache Software Foundation (ASF) under one
1:01115f7:  * or more contributor license agreements.  See the NOTICE file
1:01115f7:  * distributed with this work for additional information
1:01115f7:  * regarding copyright ownership.  The ASF licenses this file
1:01115f7:  * to you under the Apache License, Version 2.0 (the
1:01115f7:  * "License"); you may not use this file except in compliance
1:01115f7:  * with the License.  You may obtain a copy of the License at
1:01115f7:  *
1:01115f7:  *     http://www.apache.org/licenses/LICENSE-2.0
1:01115f7:  *
1:01115f7:  * Unless required by applicable law or agreed to in writing, software
1:01115f7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:01115f7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:01115f7:  * See the License for the specific language governing permissions and
1:01115f7:  * limitations under the License.
1:01115f7:  */
1:01115f7: 
1:01115f7: package org.apache.cassandra.cql3.validation.operations;
1:01115f7: 
1:2e3727e: import java.util.Arrays;
1:2e3727e: 
1:e017f94: import org.junit.Assert;
1:01115f7: import org.junit.Test;
1:01115f7: 
1:2e3727e: import static org.apache.commons.lang3.StringUtils.isEmpty;
1:e83f9e6: 
1:e83f9e6: import org.apache.cassandra.cql3.Attributes;
1:01115f7: import org.apache.cassandra.cql3.CQLTester;
1:e017f94: import org.apache.cassandra.cql3.UntypedResultSet;
1:e017f94: import org.apache.cassandra.cql3.UntypedResultSet.Row;
1:01115f7: import org.apache.cassandra.utils.ByteBufferUtil;
1:01115f7: 
1:01115f7: public class UpdateTest extends CQLTester
1:01115f7: {
1:01115f7:     /**
1:01115f7:      * Test altering the type of a column, including the one in the primary key (#4041)
1:01115f7:      * migrated from cql_tests.py:TestCQL.update_type_test()
1:01115f7:      */
1:01115f7:     @Test
1:01115f7:     public void testUpdateColumnType() throws Throwable
1:01115f7:     {
1:01115f7:         createTable("CREATE TABLE %s (k text, c text, s set <text>, v text, PRIMARY KEY(k, c))");
1:01115f7: 
1:01115f7:         // using utf8 character so that we can see the transition to BytesType
1:01115f7:         execute("INSERT INTO %s (k, c, v, s) VALUES ('ɸ', 'ɸ', 'ɸ', {'ɸ'})");
1:01115f7: 
1:01115f7:         assertRows(execute("SELECT * FROM %s"),
1:01115f7:                    row("ɸ", "ɸ", set("ɸ"), "ɸ"));
1:01115f7: 
1:01115f7:         execute("ALTER TABLE %s ALTER v TYPE blob");
1:01115f7:         assertRows(execute("SELECT * FROM %s"),
1:01115f7:                    row("ɸ", "ɸ", set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1:01115f7: 
1:01115f7:         execute("ALTER TABLE %s ALTER k TYPE blob");
1:01115f7:         assertRows(execute("SELECT * FROM %s"),
1:01115f7:                    row(ByteBufferUtil.bytes("ɸ"), "ɸ", set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1:01115f7: 
1:01115f7:         execute("ALTER TABLE %s ALTER c TYPE blob");
1:01115f7:         assertRows(execute("SELECT * FROM %s"),
1:01115f7:                    row(ByteBufferUtil.bytes("ɸ"), ByteBufferUtil.bytes("ɸ"), set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1:01115f7: 
1:01115f7:         execute("ALTER TABLE %s ALTER s TYPE set<blob>");
1:01115f7:         assertRows(execute("SELECT * FROM %s"),
1:01115f7:                    row(ByteBufferUtil.bytes("ɸ"), ByteBufferUtil.bytes("ɸ"), set(ByteBufferUtil.bytes("ɸ")), ByteBufferUtil.bytes("ɸ")));
1:01115f7:     }
1:01115f7: 
1:01115f7:     @Test
1:01115f7:     public void testTypeCasts() throws Throwable
1:01115f7:     {
1:01115f7:         createTable("CREATE TABLE %s (k int PRIMARY KEY, t text, a ascii, d double, i int)");
1:01115f7: 
1:01115f7:         // The followings is fine
1:01115f7:         execute("UPDATE %s SET t = 'foo' WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET t = (ascii)'foo' WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET t = (text)(ascii)'foo' WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET a = 'foo' WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET a = (ascii)'foo' WHERE k = ?", 0);
1:01115f7: 
1:01115f7:         // But trying to put some explicitely type-casted text into an ascii
1:01115f7:         // column should be rejected (even though the text is actually ascci)
1:01115f7:         assertInvalid("UPDATE %s SET a = (text)'foo' WHERE k = ?", 0);
1:01115f7: 
1:01115f7:         // This is also fine because integer constants works for both integer and float types
1:01115f7:         execute("UPDATE %s SET i = 3 WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET i = (int)3 WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET d = 3 WHERE k = ?", 0);
1:01115f7:         execute("UPDATE %s SET d = (double)3 WHERE k = ?", 0);
1:01115f7: 
1:01115f7:         // But values for ints and doubles are not truly compatible (their binary representation differs)
1:01115f7:         assertInvalid("UPDATE %s SET d = (int)3 WHERE k = ?", 0);
1:01115f7:         assertInvalid("UPDATE %s SET i = (double)3 WHERE k = ?", 0);
1:01115f7:     }
2:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdate() throws Throwable
2:2e3727e:     {
1:2e3727e:         testUpdate(false);
1:2e3727e:         testUpdate(true);
1:01115f7:     }
1:2e3727e: 
1:2e3727e:     private void testUpdate(boolean forceFlush) throws Throwable
1:2e3727e:     {
1:2e3727e:         for (String compactOption : new String[] {"", " WITH COMPACT STORAGE" })
1:2e3727e:         {
1:2e3727e:             createTable("CREATE TABLE %s (partitionKey int," +
1:2e3727e:                     "clustering_1 int," +
1:2e3727e:                     "value int," +
1:2e3727e:                     " PRIMARY KEY (partitionKey, clustering_1))" + compactOption);
1:2e3727e: 
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 0, 0)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 1, 1)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 2, 2)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 3, 3)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (1, 0, 4)");
1:2e3727e: 
1:2e3727e:             flush(forceFlush);
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ?",
1:2e3727e:                                0, 1),
1:2e3727e:                        row(7));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1) = (?)", 8, 0, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ?",
1:2e3727e:                                0, 2),
1:2e3727e:                        row(8));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey IN (?, ?) AND clustering_1 = ?", 9, 0, 1, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN (?, ?) AND clustering_1 = ?",
1:2e3727e:                                0, 1, 0),
1:2e3727e:                        row(0, 0, 9),
1:2e3727e:                        row(1, 0, 9));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey IN ? AND clustering_1 = ?", 19, Arrays.asList(0, 1), 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN ? AND clustering_1 = ?",
1:2e3727e:                                Arrays.asList(0, 1), 0),
1:2e3727e:                        row(0, 0, 19),
1:2e3727e:                        row(1, 0, 19));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 IN (?, ?)", 10, 0, 1, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 IN (?, ?)",
1:2e3727e:                                0, 1, 0),
1:2e3727e:                        row(0, 0, 10),
1:2e3727e:                        row(0, 1, 10));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))", 20, 0, 0, 1);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:2e3727e:                                0, 0, 1),
1:2e3727e:                        row(0, 0, 20),
1:2e3727e:                        row(0, 1, 20));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ?", null, 0, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e: 
1:2e3727e:             if (isEmpty(compactOption))
1:2e3727e:             {
1:2e3727e:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:2e3727e:                                    0, 0, 1),
1:2e3727e:                            row(0, 0, null),
1:2e3727e:                            row(0, 1, 20));
2:2e3727e:             }
1:2e3727e:             else
1:2e3727e:             {
1:2e3727e:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:2e3727e:                                    0, 0, 1),
1:2e3727e:                            row(0, 1, 20));
1:2e3727e:             }
1:2e3727e: 
1:2e3727e:             // test invalid queries
1:2e3727e: 
1:2e3727e:             // missing primary key element
1:2e3727e:             assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE clustering_1 = ? ", 7, 1);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1:2e3727e: 
1:2e3727e:             // token function
1:2e3727e:             assertInvalidMessage("The token function cannot be used in WHERE clauses for UPDATE statements",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE token(partitionKey) = token(?) AND clustering_1 = ?",
1:2e3727e:                                  7, 0, 1);
1:2e3727e: 
1:2e3727e:             // multiple time the same value
1:2e3727e:             assertInvalidSyntax("UPDATE %s SET value = ?, value = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e: 
1:2e3727e:             // multiple time same primary key element in WHERE clause
1:2e3727e:             assertInvalidMessage("clustering_1 cannot be restricted by more than one relation if it includes an Equal",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_1 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:2e3727e:             // unknown identifiers
1:4ed0060:             assertInvalidMessage("Undefined column name value1",
1:2e3727e:                                  "UPDATE %s SET value1 = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e: 
1:4ed0060:             assertInvalidMessage("Undefined column name partitionkey1",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey1 = ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e: 
1:4ed0060:             assertInvalidMessage("Undefined column name clustering_3",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_3 = ?", 7, 0, 1);
1:2e3727e: 
1:2e3727e:             // Invalid operator in the where clause
1:2e3727e:             assertInvalidMessage("Only EQ and IN relation are supported on the partition key (unless you use the token() function)",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey > ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Cannot use CONTAINS on non-collection column partitionkey",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey CONTAINS ? AND clustering_1 = ?", 7, 0, 1);
1:2e3727e: 
1:9c3855b:             assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND value = ?", 7, 0, 1, 3);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 > ?", 7, 0, 1);
1:2e3727e:         }
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdateWithSecondaryIndices() throws Throwable
1:2e3727e:     {
1:2e3727e:         testUpdateWithSecondaryIndices(false);
1:2e3727e:         testUpdateWithSecondaryIndices(true);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private void testUpdateWithSecondaryIndices(boolean forceFlush) throws Throwable
1:2e3727e:     {
1:2e3727e:         createTable("CREATE TABLE %s (partitionKey int," +
1:2e3727e:                 "clustering_1 int," +
1:2e3727e:                 "value int," +
1:2e3727e:                 "values set<int>," +
1:2e3727e:                 " PRIMARY KEY (partitionKey, clustering_1))");
1:2e3727e: 
1:2e3727e:         createIndex("CREATE INDEX ON %s (value)");
1:2e3727e:         createIndex("CREATE INDEX ON %s (clustering_1)");
1:2e3727e:         createIndex("CREATE INDEX ON %s (values)");
1:2e3727e: 
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 0, 0, {0})");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 1, 1, {0, 1})");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 2, 2, {0, 1, 2})");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 3, 3, {0, 1, 2, 3})");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (1, 0, 4, {0, 1, 2, 3, 4})");
1:2e3727e: 
1:2e3727e:         flush(forceFlush);
1:2e3727e: 
1:2e3727e:         assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
1:2e3727e:                              "UPDATE %s SET values= {6} WHERE partitionKey = ? AND clustering_1 = ? AND value = ?", 3, 3, 3);
1:2e3727e:         assertInvalidMessage("Non PRIMARY KEY columns found in where clause: values",
1:2e3727e:                              "UPDATE %s SET value= ? WHERE partitionKey = ? AND clustering_1 = ? AND values CONTAINS ?", 6, 3, 3, 3);
1:2e3727e:         assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:2e3727e:                              "UPDATE %s SET values= {6} WHERE partitionKey = ? AND value = ?", 3, 3);
1:2e3727e:         assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:2e3727e:                              "UPDATE %s SET value= ? WHERE partitionKey = ? AND values CONTAINS ?", 6, 3, 3);
1:2e3727e:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:2e3727e:                              "UPDATE %s SET values= {6} WHERE clustering_1 = ?", 3);
1:2e3727e:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:2e3727e:                              "UPDATE %s SET values= {6} WHERE value = ?", 3);
1:2e3727e:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:2e3727e:                              "UPDATE %s SET value= ? WHERE values CONTAINS ?", 6, 3);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdateWithTwoClusteringColumns() throws Throwable
1:2e3727e:     {
1:2e3727e:         testUpdateWithTwoClusteringColumns(false);
1:2e3727e:         testUpdateWithTwoClusteringColumns(true);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private void testUpdateWithTwoClusteringColumns(boolean forceFlush) throws Throwable
1:2e3727e:     {
1:2e3727e:         for (String compactOption : new String[] { "", " WITH COMPACT STORAGE" })
1:2e3727e:         {
1:2e3727e:             createTable("CREATE TABLE %s (partitionKey int," +
1:2e3727e:                     "clustering_1 int," +
1:2e3727e:                     "clustering_2 int," +
1:2e3727e:                     "value int," +
1:2e3727e:                     " PRIMARY KEY (partitionKey, clustering_1, clustering_2))" + compactOption);
1:2e3727e: 
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 0, 0)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 1, 1)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 2, 2)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 3, 3)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 1, 1, 4)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 1, 2, 5)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (1, 0, 0, 6)");
1:2e3727e:             flush(forceFlush);
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                0, 1, 1),
1:2e3727e:                        row(7));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) = (?, ?)", 8, 0, 1, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                0, 1, 2),
1:2e3727e:                        row(8));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?", 9, 0, 1, 0, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                0, 1, 0, 0),
1:2e3727e:                        row(0, 0, 0, 9),
1:2e3727e:                        row(1, 0, 0, 9));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey IN ? AND clustering_1 = ? AND clustering_2 = ?", 9, Arrays.asList(0, 1), 0, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                Arrays.asList(0, 1), 0, 0),
1:2e3727e:                        row(0, 0, 0, 9),
1:2e3727e:                        row(1, 0, 0, 9));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 IN (?, ?)", 12, 0, 1, 1, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 IN (?, ?)",
1:2e3727e:                                0, 1, 1, 2),
1:2e3727e:                        row(0, 1, 1, 12),
1:2e3727e:                        row(0, 1, 2, 12));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 IN (?, ?) AND clustering_2 IN (?, ?)", 10, 0, 1, 0, 1, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 IN (?, ?) AND clustering_2 IN (?, ?)",
1:2e3727e:                                0, 1, 0, 1, 2),
1:2e3727e:                        row(0, 0, 1, 10),
1:2e3727e:                        row(0, 0, 2, 10),
1:2e3727e:                        row(0, 1, 1, 10),
1:2e3727e:                        row(0, 1, 2, 10));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))", 20, 0, 0, 2, 1, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:2e3727e:                                0, 0, 2, 1, 2),
1:2e3727e:                        row(0, 0, 2, 20),
1:2e3727e:                        row(0, 1, 2, 20));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", null, 0, 0, 2);
1:2e3727e:             flush(forceFlush);
1:2e3727e: 
1:2e3727e:             if (isEmpty(compactOption))
1:2e3727e:             {
1:2e3727e:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:2e3727e:                                    0, 0, 2, 1, 2),
1:2e3727e:                            row(0, 0, 2, null),
1:2e3727e:                            row(0, 1, 2, 20));
1:2e3727e:             }
1:2e3727e:             else
1:2e3727e:             {
1:2e3727e:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:2e3727e:                                    0, 0, 2, 1, 2),
1:2e3727e:                            row(0, 1, 2, 20));
1:2e3727e:             }
1:2e3727e: 
1:2e3727e:             // test invalid queries
1:2e3727e: 
1:2e3727e:             // missing primary key element
1:2e3727e:             assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE clustering_1 = ? AND clustering_2 = ?", 7, 1, 1);
1:2e3727e: 
1:2e3727e:             String errorMsg = isEmpty(compactOption) ? "Some clustering keys are missing: clustering_1"
1:2e3727e:                                                      : "PRIMARY KEY column \"clustering_2\" cannot be restricted as preceding column \"clustering_1\" is not restricted";
1:2e3727e: 
1:2e3727e:             assertInvalidMessage(errorMsg,
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_2 = ?", 7, 0, 1);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Some clustering keys are missing: clustering_1, clustering_2",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1:2e3727e: 
1:2e3727e:             // token function
1:2e3727e:             assertInvalidMessage("The token function cannot be used in WHERE clauses for UPDATE statements",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE token(partitionKey) = token(?) AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                  7, 0, 1, 1);
1:2e3727e: 
1:2e3727e:             // multiple time the same value
1:2e3727e:             assertInvalidSyntax("UPDATE %s SET value = ?, value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:2e3727e:             // multiple time same primary key element in WHERE clause
1:2e3727e:             assertInvalidMessage("clustering_1 cannot be restricted by more than one relation if it includes an Equal",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ? AND clustering_1 = ?", 7, 0, 1, 1, 1);
1:2e3727e: 
1:2e3727e:             // unknown identifiers
1:4ed0060:             assertInvalidMessage("Undefined column name value1",
1:2e3727e:                                  "UPDATE %s SET value1 = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:4ed0060:             assertInvalidMessage("Undefined column name partitionkey1",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey1 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:4ed0060:             assertInvalidMessage("Undefined column name clustering_3",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_3 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:2e3727e:             // Invalid operator in the where clause
1:2e3727e:             assertInvalidMessage("Only EQ and IN relation are supported on the partition key (unless you use the token() function)",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey > ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Cannot use CONTAINS on non-collection column partitionkey",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey CONTAINS ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:2e3727e: 
1:9c3855b:             assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ? AND value = ?", 7, 0, 1, 1, 3);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 > ?", 7, 0, 1);
1:2e3727e: 
1:2e3727e:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) > (?, ?)", 7, 0, 1, 1);
1:2e3727e:         }
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdateWithMultiplePartitionKeyComponents() throws Throwable
1:2e3727e:     {
1:2e3727e:         testUpdateWithMultiplePartitionKeyComponents(false);
1:2e3727e:         testUpdateWithMultiplePartitionKeyComponents(true);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     public void testUpdateWithMultiplePartitionKeyComponents(boolean forceFlush) throws Throwable
1:2e3727e:     {
1:2e3727e:         for (String compactOption : new String[] { "", " WITH COMPACT STORAGE" })
1:2e3727e:         {
1:2e3727e:             createTable("CREATE TABLE %s (partitionKey_1 int," +
1:2e3727e:                     "partitionKey_2 int," +
1:2e3727e:                     "clustering_1 int," +
1:2e3727e:                     "clustering_2 int," +
1:2e3727e:                     "value int," +
1:2e3727e:                     " PRIMARY KEY ((partitionKey_1, partitionKey_2), clustering_1, clustering_2))" + compactOption);
1:2e3727e: 
1:2e3727e:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 0, 0, 0, 0)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 1, 0, 1, 1)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 1, 1, 1, 2)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (1, 0, 0, 1, 3)");
1:2e3727e:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (1, 1, 0, 1, 3)");
1:2e3727e:             flush(forceFlush);
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 = ? AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 0, 0, 0);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT value FROM %s WHERE partitionKey_1 = ? AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                0, 0, 0, 0),
1:2e3727e:                        row(7));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?", 9, 0, 1, 1, 0, 1);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                                0, 1, 1, 0, 1),
1:2e3727e:                        row(0, 1, 0, 1, 9),
1:2e3727e:                        row(1, 1, 0, 1, 9));
1:2e3727e: 
1:2e3727e:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?", 10, 0, 1, 0, 1, 0, 1);
1:2e3727e:             flush(forceFlush);
1:2e3727e:             assertRows(execute("SELECT * FROM %s"),
1:2e3727e:                        row(0, 0, 0, 0, 7),
1:2e3727e:                        row(0, 0, 0, 1, 10),
1:2e3727e:                        row(0, 1, 0, 1, 10),
1:2e3727e:                        row(0, 1, 1, 1, 2),
1:2e3727e:                        row(1, 0, 0, 1, 10),
1:2e3727e:                        row(1, 1, 0, 1, 10));
1:2e3727e: 
1:2e3727e:             // missing primary key element
1:2e3727e:             assertInvalidMessage("Some partition key parts are missing: partitionkey_2",
1:2e3727e:                                  "UPDATE %s SET value = ? WHERE partitionKey_1 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 1, 1);
1:2e3727e:         }
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdateWithAStaticColumn() throws Throwable
1:2e3727e:     {
1:2e3727e:         testUpdateWithAStaticColumn(false);
1:2e3727e:         testUpdateWithAStaticColumn(true);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private void testUpdateWithAStaticColumn(boolean forceFlush) throws Throwable
1:2e3727e:     {
1:2e3727e:         createTable("CREATE TABLE %s (partitionKey int," +
1:2e3727e:                                       "clustering_1 int," +
1:2e3727e:                                       "clustering_2 int," +
1:2e3727e:                                       "value int," +
1:2e3727e:                                       "staticValue text static," +
1:2e3727e:                                       " PRIMARY KEY (partitionKey, clustering_1, clustering_2))");
1:2e3727e: 
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value, staticValue) VALUES (0, 0, 0, 0, 'A')");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 1, 1)");
1:2e3727e:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value, staticValue) VALUES (1, 0, 0, 6, 'B')");
1:2e3727e:         flush(forceFlush);
1:2e3727e: 
1:2e3727e:         execute("UPDATE %s SET staticValue = ? WHERE partitionKey = ?", "A2", 0);
1:2e3727e:         flush(forceFlush);
1:2e3727e: 
1:2e3727e:         assertRows(execute("SELECT DISTINCT staticValue FROM %s WHERE partitionKey = ?", 0),
1:2e3727e:                    row("A2"));
1:2e3727e: 
1:2e3727e:         assertInvalidMessage("Some clustering keys are missing: clustering_1, clustering_2",
1:2e3727e:                              "UPDATE %s SET staticValue = ?, value = ? WHERE partitionKey = ?", "A2", 7, 0);
1:2e3727e: 
1:2e3727e:         execute("UPDATE %s SET staticValue = ?, value = ?  WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                 "A3", 7, 0, 0, 1);
1:2e3727e:         flush(forceFlush);
1:2e3727e:         assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                            0, 0, 1),
1:2e3727e:                    row(0, 0, 1, "A3", 7));
1:2e3727e: 
1:2e3727e:         assertInvalidMessage("Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns",
1:2e3727e:                              "UPDATE %s SET staticValue = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:2e3727e:                              "A3", 0, 0, 1);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void testUpdateWithStaticList() throws Throwable
1:2e3727e:     {
1:2e3727e:         createTable("CREATE TABLE %s (k int," +
1:2e3727e:                                       "clustering int," +
1:2e3727e:                                       "value int," +
1:2e3727e:                                       "l list<text> static," +
1:2e3727e:                                       " PRIMARY KEY (k, clustering))");
1:2e3727e: 
1:2e3727e:         execute("INSERT INTO %s(k, clustering, value, l) VALUES (?, ?, ?, ?)", 0, 0, 0 ,list("v1", "v2", "v3"));
1:2e3727e: 
1:2e3727e:         assertRows(execute("SELECT l FROM %s WHERE k = 0"), row(list("v1", "v2", "v3")));
1:2e3727e: 
1:2e3727e:         execute("UPDATE %s SET l[?] = ? WHERE k = ?", 1, "v4", 0);
1:2e3727e: 
1:2e3727e:         assertRows(execute("SELECT l FROM %s WHERE k = 0"), row(list("v1", "v4", "v3")));
1:2e3727e:     }
1:e017f94: 
1:e017f94:     @Test
1:e017f94:     public void testUpdateWithDefaultTtl() throws Throwable
1:e017f94:     {
1:e017f94:         final int secondsPerMinute = 60;
1:e017f94:         createTable("CREATE TABLE %s (a int PRIMARY KEY, b int) WITH default_time_to_live = " + (10 * secondsPerMinute));
1:e017f94: 
1:e017f94:         execute("UPDATE %s SET b = 1 WHERE a = 1");
1:e017f94:         UntypedResultSet resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 1");
1:e017f94:         Assert.assertEquals(1, resultSet.size());
1:e017f94:         Row row = resultSet.one();
1:e017f94:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1:e017f94: 
1:e017f94:         execute("UPDATE %s USING TTL ? SET b = 3 WHERE a = 1", 0);
1:e017f94:         assertRows(execute("SELECT ttl(b) FROM %s WHERE a = 1"), row(new Object[]{null}));
1:e017f94: 
1:e017f94:         execute("UPDATE %s SET b = 3 WHERE a = 1");
1:e017f94:         resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 1");
1:e017f94:         Assert.assertEquals(1, resultSet.size());
1:e017f94:         row = resultSet.one();
1:e017f94:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1:e83f9e6: 
1:e017f94:         execute("UPDATE %s USING TTL ? SET b = 2 WHERE a = 2", unset());
1:e017f94:         resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 2");
1:e017f94:         Assert.assertEquals(1, resultSet.size());
1:e017f94:         row = resultSet.one();
1:e017f94:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1:e017f94: 
1:e83f9e6:         execute("UPDATE %s USING TTL ? SET b = ? WHERE a = ?", null, 3, 3);
1:e83f9e6:         assertRows(execute("SELECT ttl(b) FROM %s WHERE a = 3"), row(new Object[] { null }));
1:e83f9e6:     }
1:e83f9e6: 
1:e83f9e6:     @Test
1:e83f9e6:     public void testUpdateWithTtl() throws Throwable
1:e83f9e6:     {
1:e83f9e6:         createTable("CREATE TABLE %s (k int PRIMARY KEY, v int)");
1:e83f9e6: 
1:e83f9e6:         execute("INSERT INTO %s (k, v) VALUES (1, 1) USING TTL ?", 3600);
1:e83f9e6:         execute("INSERT INTO %s (k, v) VALUES (2, 2) USING TTL ?", 3600);
1:e83f9e6: 
1:e83f9e6:         // test with unset
1:e83f9e6:         execute("UPDATE %s USING TTL ? SET v = ? WHERE k = ?", unset(), 1, 1); // treat as 'unlimited'
1:e83f9e6:         assertRows(execute("SELECT ttl(v) FROM %s WHERE k = 1"), row(new Object[] { null }));
1:e83f9e6: 
1:e83f9e6:         // test with null
1:e83f9e6:         execute("UPDATE %s USING TTL ? SET v = ? WHERE k = ?", unset(), 2, 2);
1:e83f9e6:         assertRows(execute("SELECT k, v, TTL(v) FROM %s WHERE k = 2"), row(2, 2, null));
1:e83f9e6: 
1:e83f9e6:         // test error handling
1:e83f9e6:         assertInvalidMessage("A TTL must be greater or equal to 0, but was -5",
1:e83f9e6:                              "UPDATE %s USING TTL ? SET v = ? WHERE k = ?", -5, 1, 1);
1:e83f9e6: 
1:e83f9e6:         assertInvalidMessage("ttl is too large.",
1:e83f9e6:                              "UPDATE %s USING TTL ? SET v = ? WHERE k = ?",
1:e83f9e6:                              Attributes.MAX_TTL + 1, 1, 1);
1:e017f94:     }
1:2e3727e: }
============================================================================
author:Russell Spitzer
-------------------------------------------------------------------------------
commit:e83f9e6
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.cql3.Attributes;
/////////////////////////////////////////////////////////////////////////
1: 
1:         execute("UPDATE %s USING TTL ? SET b = ? WHERE a = ?", null, 3, 3);
1:         assertRows(execute("SELECT ttl(b) FROM %s WHERE a = 3"), row(new Object[] { null }));
1:     }
1: 
1:     @Test
1:     public void testUpdateWithTtl() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int PRIMARY KEY, v int)");
1: 
1:         execute("INSERT INTO %s (k, v) VALUES (1, 1) USING TTL ?", 3600);
1:         execute("INSERT INTO %s (k, v) VALUES (2, 2) USING TTL ?", 3600);
1: 
1:         // test with unset
1:         execute("UPDATE %s USING TTL ? SET v = ? WHERE k = ?", unset(), 1, 1); // treat as 'unlimited'
1:         assertRows(execute("SELECT ttl(v) FROM %s WHERE k = 1"), row(new Object[] { null }));
1: 
1:         // test with null
1:         execute("UPDATE %s USING TTL ? SET v = ? WHERE k = ?", unset(), 2, 2);
1:         assertRows(execute("SELECT k, v, TTL(v) FROM %s WHERE k = 2"), row(2, 2, null));
1: 
1:         // test error handling
1:         assertInvalidMessage("A TTL must be greater or equal to 0, but was -5",
1:                              "UPDATE %s USING TTL ? SET v = ? WHERE k = ?", -5, 1, 1);
1: 
1:         assertInvalidMessage("ttl is too large.",
1:                              "UPDATE %s USING TTL ? SET v = ? WHERE k = ?",
1:                              Attributes.MAX_TTL + 1, 1, 1);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1:             assertInvalidMessage("Undefined column name value1",
1:             assertInvalidMessage("Undefined column name partitionkey1",
1:             assertInvalidMessage("Undefined column name clustering_3",
/////////////////////////////////////////////////////////////////////////
1:             assertInvalidMessage("Undefined column name value1",
1:             assertInvalidMessage("Undefined column name partitionkey1",
1:             assertInvalidMessage("Undefined column name clustering_3",
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Assert;
1: import org.apache.cassandra.cql3.UntypedResultSet;
1: import org.apache.cassandra.cql3.UntypedResultSet.Row;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testUpdateWithDefaultTtl() throws Throwable
1:     {
1:         final int secondsPerMinute = 60;
1:         createTable("CREATE TABLE %s (a int PRIMARY KEY, b int) WITH default_time_to_live = " + (10 * secondsPerMinute));
1: 
1:         execute("UPDATE %s SET b = 1 WHERE a = 1");
1:         UntypedResultSet resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 1");
1:         Assert.assertEquals(1, resultSet.size());
1:         Row row = resultSet.one();
1:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1: 
1:         execute("UPDATE %s USING TTL ? SET b = 3 WHERE a = 1", 0);
1:         assertRows(execute("SELECT ttl(b) FROM %s WHERE a = 1"), row(new Object[]{null}));
1: 
1:         execute("UPDATE %s SET b = 3 WHERE a = 1");
1:         resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 1");
1:         Assert.assertEquals(1, resultSet.size());
1:         row = resultSet.one();
1:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1: 
1:         execute("UPDATE %s USING TTL ? SET b = 2 WHERE a = 2", unset());
1:         resultSet = execute("SELECT ttl(b) FROM %s WHERE a = 2");
1:         Assert.assertEquals(1, resultSet.size());
1:         row = resultSet.one();
1:         Assert.assertTrue(row.getInt("ttl(b)") >= (9 * secondsPerMinute));
1:     }
commit:8c83c8e
commit:9c3855b
/////////////////////////////////////////////////////////////////////////
1:             assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
/////////////////////////////////////////////////////////////////////////
1:             assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:b11fba7
/////////////////////////////////////////////////////////////////////////
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.cql3.validation.operations;
1: 
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.cql3.CQLTester;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: public class UpdateTest extends CQLTester
1: {
1:     /**
1:      * Test altering the type of a column, including the one in the primary key (#4041)
1:      * migrated from cql_tests.py:TestCQL.update_type_test()
1:      */
1:     @Test
1:     public void testUpdateColumnType() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k text, c text, s set <text>, v text, PRIMARY KEY(k, c))");
1: 
1:         // using utf8 character so that we can see the transition to BytesType
1:         execute("INSERT INTO %s (k, c, v, s) VALUES ('ɸ', 'ɸ', 'ɸ', {'ɸ'})");
1: 
1:         assertRows(execute("SELECT * FROM %s"),
1:                    row("ɸ", "ɸ", set("ɸ"), "ɸ"));
1: 
1:         execute("ALTER TABLE %s ALTER v TYPE blob");
1:         assertRows(execute("SELECT * FROM %s"),
1:                    row("ɸ", "ɸ", set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1: 
1:         execute("ALTER TABLE %s ALTER k TYPE blob");
1:         assertRows(execute("SELECT * FROM %s"),
1:                    row(ByteBufferUtil.bytes("ɸ"), "ɸ", set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1: 
1:         execute("ALTER TABLE %s ALTER c TYPE blob");
1:         assertRows(execute("SELECT * FROM %s"),
1:                    row(ByteBufferUtil.bytes("ɸ"), ByteBufferUtil.bytes("ɸ"), set("ɸ"), ByteBufferUtil.bytes("ɸ")));
1: 
1:         execute("ALTER TABLE %s ALTER s TYPE set<blob>");
1:         assertRows(execute("SELECT * FROM %s"),
1:                    row(ByteBufferUtil.bytes("ɸ"), ByteBufferUtil.bytes("ɸ"), set(ByteBufferUtil.bytes("ɸ")), ByteBufferUtil.bytes("ɸ")));
1:     }
1: 
1:     @Test
1:     public void testTypeCasts() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int PRIMARY KEY, t text, a ascii, d double, i int)");
1: 
1:         // The followings is fine
1:         execute("UPDATE %s SET t = 'foo' WHERE k = ?", 0);
1:         execute("UPDATE %s SET t = (ascii)'foo' WHERE k = ?", 0);
1:         execute("UPDATE %s SET t = (text)(ascii)'foo' WHERE k = ?", 0);
1:         execute("UPDATE %s SET a = 'foo' WHERE k = ?", 0);
1:         execute("UPDATE %s SET a = (ascii)'foo' WHERE k = ?", 0);
1: 
1:         // But trying to put some explicitely type-casted text into an ascii
1:         // column should be rejected (even though the text is actually ascci)
1:         assertInvalid("UPDATE %s SET a = (text)'foo' WHERE k = ?", 0);
1: 
1:         // This is also fine because integer constants works for both integer and float types
1:         execute("UPDATE %s SET i = 3 WHERE k = ?", 0);
1:         execute("UPDATE %s SET i = (int)3 WHERE k = ?", 0);
1:         execute("UPDATE %s SET d = 3 WHERE k = ?", 0);
1:         execute("UPDATE %s SET d = (double)3 WHERE k = ?", 0);
1: 
1:         // But values for ints and doubles are not truly compatible (their binary representation differs)
1:         assertInvalid("UPDATE %s SET d = (int)3 WHERE k = ?", 0);
1:         assertInvalid("UPDATE %s SET i = (double)3 WHERE k = ?", 0);
1:     }
1: }
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: 
1: import static org.apache.commons.lang3.StringUtils.isEmpty;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testUpdate() throws Throwable
1:     {
1:         testUpdate(false);
1:         testUpdate(true);
1:     }
1: 
1:     private void testUpdate(boolean forceFlush) throws Throwable
1:     {
1:         for (String compactOption : new String[] {"", " WITH COMPACT STORAGE" })
1:         {
1:             createTable("CREATE TABLE %s (partitionKey int," +
1:                     "clustering_1 int," +
1:                     "value int," +
1:                     " PRIMARY KEY (partitionKey, clustering_1))" + compactOption);
1: 
1:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 0, 0)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 1, 1)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 2, 2)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (0, 3, 3)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, value) VALUES (1, 0, 4)");
1: 
1:             flush(forceFlush);
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ?",
1:                                0, 1),
1:                        row(7));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1) = (?)", 8, 0, 2);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ?",
1:                                0, 2),
1:                        row(8));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey IN (?, ?) AND clustering_1 = ?", 9, 0, 1, 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN (?, ?) AND clustering_1 = ?",
1:                                0, 1, 0),
1:                        row(0, 0, 9),
1:                        row(1, 0, 9));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey IN ? AND clustering_1 = ?", 19, Arrays.asList(0, 1), 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN ? AND clustering_1 = ?",
1:                                Arrays.asList(0, 1), 0),
1:                        row(0, 0, 19),
1:                        row(1, 0, 19));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 IN (?, ?)", 10, 0, 1, 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 IN (?, ?)",
1:                                0, 1, 0),
1:                        row(0, 0, 10),
1:                        row(0, 1, 10));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))", 20, 0, 0, 1);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:                                0, 0, 1),
1:                        row(0, 0, 20),
1:                        row(0, 1, 20));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ?", null, 0, 0);
1:             flush(forceFlush);
1: 
1:             if (isEmpty(compactOption))
1:             {
1:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:                                    0, 0, 1),
1:                            row(0, 0, null),
1:                            row(0, 1, 20));
1:             }
1:             else
1:             {
1:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1) IN ((?), (?))",
1:                                    0, 0, 1),
1:                            row(0, 1, 20));
1:             }
1: 
1:             // test invalid queries
1: 
1:             // missing primary key element
1:             assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:                                  "UPDATE %s SET value = ? WHERE clustering_1 = ? ", 7, 1);
1: 
1:             assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1: 
1:             assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1: 
1:             // token function
1:             assertInvalidMessage("The token function cannot be used in WHERE clauses for UPDATE statements",
1:                                  "UPDATE %s SET value = ? WHERE token(partitionKey) = token(?) AND clustering_1 = ?",
1:                                  7, 0, 1);
1: 
1:             // multiple time the same value
1:             assertInvalidSyntax("UPDATE %s SET value = ?, value = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1: 
1:             // multiple time same primary key element in WHERE clause
1:             assertInvalidMessage("clustering_1 cannot be restricted by more than one relation if it includes an Equal",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_1 = ?", 7, 0, 1, 1);
1: 
1:             // unknown identifiers
0:             assertInvalidMessage("Unknown identifier value1",
1:                                  "UPDATE %s SET value1 = ? WHERE partitionKey = ? AND clustering_1 = ?", 7, 0, 1);
1: 
0:             assertInvalidMessage("Undefined name partitionkey1 in where clause ('partitionkey1 = ?')",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey1 = ? AND clustering_1 = ?", 7, 0, 1);
1: 
0:             assertInvalidMessage("Undefined name clustering_3 in where clause ('clustering_3 = ?')",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_3 = ?", 7, 0, 1);
1: 
1:             // Invalid operator in the where clause
1:             assertInvalidMessage("Only EQ and IN relation are supported on the partition key (unless you use the token() function)",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey > ? AND clustering_1 = ?", 7, 0, 1);
1: 
1:             assertInvalidMessage("Cannot use CONTAINS on non-collection column partitionkey",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey CONTAINS ? AND clustering_1 = ?", 7, 0, 1);
1: 
0:             String expectedMsg = isEmpty(compactOption) ? "Non PRIMARY KEY columns found in where clause: value"
0:                                                         : "Predicates on the non-primary-key column (value) of a COMPACT table are not yet supported";
0:             assertInvalidMessage(expectedMsg,
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND value = ?", 7, 0, 1, 3);
1: 
1:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 > ?", 7, 0, 1);
1:         }
1:     }
1: 
1:     @Test
1:     public void testUpdateWithSecondaryIndices() throws Throwable
1:     {
1:         testUpdateWithSecondaryIndices(false);
1:         testUpdateWithSecondaryIndices(true);
1:     }
1: 
1:     private void testUpdateWithSecondaryIndices(boolean forceFlush) throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (partitionKey int," +
1:                 "clustering_1 int," +
1:                 "value int," +
1:                 "values set<int>," +
1:                 " PRIMARY KEY (partitionKey, clustering_1))");
1: 
1:         createIndex("CREATE INDEX ON %s (value)");
1:         createIndex("CREATE INDEX ON %s (clustering_1)");
1:         createIndex("CREATE INDEX ON %s (values)");
1: 
1:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 0, 0, {0})");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 1, 1, {0, 1})");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 2, 2, {0, 1, 2})");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (0, 3, 3, {0, 1, 2, 3})");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, value, values) VALUES (1, 0, 4, {0, 1, 2, 3, 4})");
1: 
1:         flush(forceFlush);
1: 
1:         assertInvalidMessage("Non PRIMARY KEY columns found in where clause: value",
1:                              "UPDATE %s SET values= {6} WHERE partitionKey = ? AND clustering_1 = ? AND value = ?", 3, 3, 3);
1:         assertInvalidMessage("Non PRIMARY KEY columns found in where clause: values",
1:                              "UPDATE %s SET value= ? WHERE partitionKey = ? AND clustering_1 = ? AND values CONTAINS ?", 6, 3, 3, 3);
1:         assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:                              "UPDATE %s SET values= {6} WHERE partitionKey = ? AND value = ?", 3, 3);
1:         assertInvalidMessage("Some clustering keys are missing: clustering_1",
1:                              "UPDATE %s SET value= ? WHERE partitionKey = ? AND values CONTAINS ?", 6, 3, 3);
1:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:                              "UPDATE %s SET values= {6} WHERE clustering_1 = ?", 3);
1:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:                              "UPDATE %s SET values= {6} WHERE value = ?", 3);
1:         assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:                              "UPDATE %s SET value= ? WHERE values CONTAINS ?", 6, 3);
1:     }
1: 
1:     @Test
1:     public void testUpdateWithTwoClusteringColumns() throws Throwable
1:     {
1:         testUpdateWithTwoClusteringColumns(false);
1:         testUpdateWithTwoClusteringColumns(true);
1:     }
1: 
1:     private void testUpdateWithTwoClusteringColumns(boolean forceFlush) throws Throwable
1:     {
1:         for (String compactOption : new String[] { "", " WITH COMPACT STORAGE" })
1:         {
1:             createTable("CREATE TABLE %s (partitionKey int," +
1:                     "clustering_1 int," +
1:                     "clustering_2 int," +
1:                     "value int," +
1:                     " PRIMARY KEY (partitionKey, clustering_1, clustering_2))" + compactOption);
1: 
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 0, 0)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 1, 1)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 2, 2)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 3, 3)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 1, 1, 4)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 1, 2, 5)");
1:             execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (1, 0, 0, 6)");
1:             flush(forceFlush);
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                                0, 1, 1),
1:                        row(7));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) = (?, ?)", 8, 0, 1, 2);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT value FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                                0, 1, 2),
1:                        row(8));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?", 9, 0, 1, 0, 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?",
1:                                0, 1, 0, 0),
1:                        row(0, 0, 0, 9),
1:                        row(1, 0, 0, 9));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey IN ? AND clustering_1 = ? AND clustering_2 = ?", 9, Arrays.asList(0, 1), 0, 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey IN ? AND clustering_1 = ? AND clustering_2 = ?",
1:                                Arrays.asList(0, 1), 0, 0),
1:                        row(0, 0, 0, 9),
1:                        row(1, 0, 0, 9));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 IN (?, ?)", 12, 0, 1, 1, 2);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 IN (?, ?)",
1:                                0, 1, 1, 2),
1:                        row(0, 1, 1, 12),
1:                        row(0, 1, 2, 12));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 IN (?, ?) AND clustering_2 IN (?, ?)", 10, 0, 1, 0, 1, 2);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 IN (?, ?) AND clustering_2 IN (?, ?)",
1:                                0, 1, 0, 1, 2),
1:                        row(0, 0, 1, 10),
1:                        row(0, 0, 2, 10),
1:                        row(0, 1, 1, 10),
1:                        row(0, 1, 2, 10));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))", 20, 0, 0, 2, 1, 2);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:                                0, 0, 2, 1, 2),
1:                        row(0, 0, 2, 20),
1:                        row(0, 1, 2, 20));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", null, 0, 0, 2);
1:             flush(forceFlush);
1: 
1:             if (isEmpty(compactOption))
1:             {
1:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:                                    0, 0, 2, 1, 2),
1:                            row(0, 0, 2, null),
1:                            row(0, 1, 2, 20));
1:             }
1:             else
1:             {
1:                 assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND (clustering_1, clustering_2) IN ((?, ?), (?, ?))",
1:                                    0, 0, 2, 1, 2),
1:                            row(0, 1, 2, 20));
1:             }
1: 
1:             // test invalid queries
1: 
1:             // missing primary key element
1:             assertInvalidMessage("Some partition key parts are missing: partitionkey",
1:                                  "UPDATE %s SET value = ? WHERE clustering_1 = ? AND clustering_2 = ?", 7, 1, 1);
1: 
1:             String errorMsg = isEmpty(compactOption) ? "Some clustering keys are missing: clustering_1"
1:                                                      : "PRIMARY KEY column \"clustering_2\" cannot be restricted as preceding column \"clustering_1\" is not restricted";
1: 
1:             assertInvalidMessage(errorMsg,
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_2 = ?", 7, 0, 1);
1: 
1:             assertInvalidMessage("Some clustering keys are missing: clustering_1, clustering_2",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ?", 7, 0);
1: 
1:             // token function
1:             assertInvalidMessage("The token function cannot be used in WHERE clauses for UPDATE statements",
1:                                  "UPDATE %s SET value = ? WHERE token(partitionKey) = token(?) AND clustering_1 = ? AND clustering_2 = ?",
1:                                  7, 0, 1, 1);
1: 
1:             // multiple time the same value
1:             assertInvalidSyntax("UPDATE %s SET value = ?, value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1: 
1:             // multiple time same primary key element in WHERE clause
1:             assertInvalidMessage("clustering_1 cannot be restricted by more than one relation if it includes an Equal",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ? AND clustering_1 = ?", 7, 0, 1, 1, 1);
1: 
1:             // unknown identifiers
0:             assertInvalidMessage("Unknown identifier value1",
1:                                  "UPDATE %s SET value1 = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1: 
0:             assertInvalidMessage("Undefined name partitionkey1 in where clause ('partitionkey1 = ?')",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey1 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1: 
0:             assertInvalidMessage("Undefined name clustering_3 in where clause ('clustering_3 = ?')",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_3 = ?", 7, 0, 1, 1);
1: 
1:             // Invalid operator in the where clause
1:             assertInvalidMessage("Only EQ and IN relation are supported on the partition key (unless you use the token() function)",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey > ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1: 
1:             assertInvalidMessage("Cannot use CONTAINS on non-collection column partitionkey",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey CONTAINS ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 1, 1);
1: 
0:             String expectedMsg = isEmpty(compactOption) ? "Non PRIMARY KEY columns found in where clause: value"
0:                                                         : "Predicates on the non-primary-key column (value) of a COMPACT table are not yet supported";
0:             assertInvalidMessage(expectedMsg,
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ? AND value = ?", 7, 0, 1, 1, 3);
1: 
1:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND clustering_1 > ?", 7, 0, 1);
1: 
1:             assertInvalidMessage("Slice restrictions are not supported on the clustering columns in UPDATE statements",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey = ? AND (clustering_1, clustering_2) > (?, ?)", 7, 0, 1, 1);
1:         }
1:     }
1: 
1:     @Test
1:     public void testUpdateWithMultiplePartitionKeyComponents() throws Throwable
1:     {
1:         testUpdateWithMultiplePartitionKeyComponents(false);
1:         testUpdateWithMultiplePartitionKeyComponents(true);
1:     }
1: 
1:     public void testUpdateWithMultiplePartitionKeyComponents(boolean forceFlush) throws Throwable
1:     {
1:         for (String compactOption : new String[] { "", " WITH COMPACT STORAGE" })
1:         {
1:             createTable("CREATE TABLE %s (partitionKey_1 int," +
1:                     "partitionKey_2 int," +
1:                     "clustering_1 int," +
1:                     "clustering_2 int," +
1:                     "value int," +
1:                     " PRIMARY KEY ((partitionKey_1, partitionKey_2), clustering_1, clustering_2))" + compactOption);
1: 
1:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 0, 0, 0, 0)");
1:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 1, 0, 1, 1)");
1:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (0, 1, 1, 1, 2)");
1:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (1, 0, 0, 1, 3)");
1:             execute("INSERT INTO %s (partitionKey_1, partitionKey_2, clustering_1, clustering_2, value) VALUES (1, 1, 0, 1, 3)");
1:             flush(forceFlush);
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 = ? AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 0, 0, 0, 0);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT value FROM %s WHERE partitionKey_1 = ? AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                                0, 0, 0, 0),
1:                        row(7));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?", 9, 0, 1, 1, 0, 1);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                                0, 1, 1, 0, 1),
1:                        row(0, 1, 0, 1, 9),
1:                        row(1, 1, 0, 1, 9));
1: 
1:             execute("UPDATE %s SET value = ? WHERE partitionKey_1 IN (?, ?) AND partitionKey_2 IN (?, ?) AND clustering_1 = ? AND clustering_2 = ?", 10, 0, 1, 0, 1, 0, 1);
1:             flush(forceFlush);
1:             assertRows(execute("SELECT * FROM %s"),
1:                        row(0, 0, 0, 0, 7),
1:                        row(0, 0, 0, 1, 10),
1:                        row(0, 1, 0, 1, 10),
1:                        row(0, 1, 1, 1, 2),
1:                        row(1, 0, 0, 1, 10),
1:                        row(1, 1, 0, 1, 10));
1: 
1:             // missing primary key element
1:             assertInvalidMessage("Some partition key parts are missing: partitionkey_2",
1:                                  "UPDATE %s SET value = ? WHERE partitionKey_1 = ? AND clustering_1 = ? AND clustering_2 = ?", 7, 1, 1);
1:         }
1:     }
1: 
1:     @Test
1:     public void testUpdateWithAStaticColumn() throws Throwable
1:     {
1:         testUpdateWithAStaticColumn(false);
1:         testUpdateWithAStaticColumn(true);
1:     }
1: 
1:     private void testUpdateWithAStaticColumn(boolean forceFlush) throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (partitionKey int," +
1:                                       "clustering_1 int," +
1:                                       "clustering_2 int," +
1:                                       "value int," +
1:                                       "staticValue text static," +
1:                                       " PRIMARY KEY (partitionKey, clustering_1, clustering_2))");
1: 
1:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value, staticValue) VALUES (0, 0, 0, 0, 'A')");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value) VALUES (0, 0, 1, 1)");
1:         execute("INSERT INTO %s (partitionKey, clustering_1, clustering_2, value, staticValue) VALUES (1, 0, 0, 6, 'B')");
1:         flush(forceFlush);
1: 
1:         execute("UPDATE %s SET staticValue = ? WHERE partitionKey = ?", "A2", 0);
1:         flush(forceFlush);
1: 
1:         assertRows(execute("SELECT DISTINCT staticValue FROM %s WHERE partitionKey = ?", 0),
1:                    row("A2"));
1: 
1:         assertInvalidMessage("Some clustering keys are missing: clustering_1, clustering_2",
1:                              "UPDATE %s SET staticValue = ?, value = ? WHERE partitionKey = ?", "A2", 7, 0);
1: 
1:         execute("UPDATE %s SET staticValue = ?, value = ?  WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                 "A3", 7, 0, 0, 1);
1:         flush(forceFlush);
1:         assertRows(execute("SELECT * FROM %s WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                            0, 0, 1),
1:                    row(0, 0, 1, "A3", 7));
1: 
1:         assertInvalidMessage("Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns",
1:                              "UPDATE %s SET staticValue = ? WHERE partitionKey = ? AND clustering_1 = ? AND clustering_2 = ?",
1:                              "A3", 0, 0, 1);
1:     }
1: 
1:     @Test
1:     public void testUpdateWithStaticList() throws Throwable
1:     {
1:         createTable("CREATE TABLE %s (k int," +
1:                                       "clustering int," +
1:                                       "value int," +
1:                                       "l list<text> static," +
1:                                       " PRIMARY KEY (k, clustering))");
1: 
1:         execute("INSERT INTO %s(k, clustering, value, l) VALUES (?, ?, ?, ?)", 0, 0, 0 ,list("v1", "v2", "v3"));
1: 
1:         assertRows(execute("SELECT l FROM %s WHERE k = 0"), row(list("v1", "v2", "v3")));
1: 
1:         execute("UPDATE %s SET l[?] = ? WHERE k = ?", 1, "v4", 0);
1: 
1:         assertRows(execute("SELECT l FROM %s WHERE k = 0"), row(list("v1", "v4", "v3")));
1:     }
1: 
0:     private void flush(boolean forceFlush)
1:     {
0:         if (forceFlush)
0:             flush();
1:     }
============================================================================