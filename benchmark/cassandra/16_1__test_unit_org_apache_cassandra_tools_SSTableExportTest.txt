1:9797511: /*
1:9797511:  * Licensed to the Apache Software Foundation (ASF) under one
1:9797511:  * or more contributor license agreements.  See the NOTICE file
1:9797511:  * distributed with this work for additional information
1:9797511:  * regarding copyright ownership.  The ASF licenses this file
1:9797511:  * to you under the Apache License, Version 2.0 (the
1:9797511:  * "License"); you may not use this file except in compliance
1:9797511:  * with the License.  You may obtain a copy of the License at
1:9797511:  *
1:9797511:  *     http://www.apache.org/licenses/LICENSE-2.0
1:9797511:  *
1:9797511:  * Unless required by applicable law or agreed to in writing, software
1:9797511:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9797511:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9797511:  * See the License for the specific language governing permissions and
1:9797511:  * limitations under the License.
1:9797511:  */
1:9797511: 
1:9797511: package org.apache.cassandra.tools;
1:9797511: 
1:9797511: import org.junit.Test;
1:9797511: import org.junit.runner.RunWith;
1:9797511: 
1:9797511: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1:9797511: 
1:9797511: @RunWith(OrderedJUnit4ClassRunner.class)
1:9797511: public class SSTableExportTest extends ToolsTester
1:9797511: {
1:9797511:     @Test
1:9797511:     public void testSSTableExport_NoArgs()
1:9797511:     {
1:9797511:         runTool(1, "org.apache.cassandra.tools.SSTableExport");
1:9797511:         assertNoUnexpectedThreadsStarted(null, OPTIONAL_THREADS_WITH_SCHEMA);
1:9797511:         assertSchemaNotLoaded();
1:9797511:         assertCLSMNotLoaded();
1:9797511:         assertSystemKSNotLoaded();
1:9797511:         assertKeyspaceNotLoaded();
1:9797511:         assertServerNotLoaded();
1:9797511:     }
1:9797511: 
1:9797511:     @Test
1:9797511:     public void testSSTableExport_WithArgs() throws Exception
1:9797511:     {
1:9797511:         runTool(0, "org.apache.cassandra.tools.SSTableExport", findOneSSTable("legacy_sstables", "legacy_ma_simple"));
1:9797511:         assertNoUnexpectedThreadsStarted(null, OPTIONAL_THREADS_WITH_SCHEMA);
1:9797511:         assertSchemaNotLoaded();
1:9797511:         assertCLSMNotLoaded();
1:9797511:         assertSystemKSNotLoaded();
1:9797511:         assertServerNotLoaded();
1:9797511:     }
1:9797511: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.tools;
1: 
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: 
1: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1: 
1: @RunWith(OrderedJUnit4ClassRunner.class)
1: public class SSTableExportTest extends ToolsTester
1: {
1:     @Test
1:     public void testSSTableExport_NoArgs()
1:     {
1:         runTool(1, "org.apache.cassandra.tools.SSTableExport");
1:         assertNoUnexpectedThreadsStarted(null, OPTIONAL_THREADS_WITH_SCHEMA);
1:         assertSchemaNotLoaded();
1:         assertCLSMNotLoaded();
1:         assertSystemKSNotLoaded();
1:         assertKeyspaceNotLoaded();
1:         assertServerNotLoaded();
1:     }
1: 
1:     @Test
1:     public void testSSTableExport_WithArgs() throws Exception
1:     {
1:         runTool(0, "org.apache.cassandra.tools.SSTableExport", findOneSSTable("legacy_sstables", "legacy_ma_simple"));
1:         assertNoUnexpectedThreadsStarted(null, OPTIONAL_THREADS_WITH_SCHEMA);
1:         assertSchemaNotLoaded();
1:         assertCLSMNotLoaded();
1:         assertSystemKSNotLoaded();
1:         assertServerNotLoaded();
1:     }
1: }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
commit:8afe109
commit:b42feea
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.column;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.UUIDGen;
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Tests CASSANDRA-6892 (key aliases being used improperly for validation)
0:      */
0:     @Test
0:     public void testColumnNameEqualToDefaultKeyAlias() throws IOException, ParseException
0:     {
0:         File tempSS = tempSSTableFile("Keyspace1", "UUIDKeys");
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "UUIDKeys");
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
0: 
0:         // Add a row
0:         cfamily.addColumn(column(CFMetaData.DEFAULT_KEY_ALIAS, "not a uuid", 1L));
0:         writer.append(Util.dk(ByteBufferUtil.bytes(UUIDGen.getTimeUUID())), cfamily);
0: 
0:         SSTableReader reader = writer.closeAndOpenReader();
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("CFWithColumnNameEqualToDefaultKeyAlias", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
0: 
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals(1, json.size());
0: 
0:         JSONObject row = (JSONObject)json.get(0);
0:         JSONArray cols = (JSONArray) row.get("columns");
0:         assertEquals(1, cols.size());
0: 
0:         // check column name and value
0:         JSONArray col = (JSONArray) cols.get(0);
0:         assertEquals(CFMetaData.DEFAULT_KEY_ALIAS, ByteBufferUtil.string(hexToBytes((String) col.get(0))));
0:         assertEquals("not a uuid", ByteBufferUtil.string(hexToBytes((String) col.get(1))));
0:     }
commit:773fade
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.SortedSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:         SortedSet<ByteBuffer> names = FBUtilities.singleton(ByteBufferUtil.bytes("name"), cfamily.getComparator());
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), "Standard1", names, System.currentTimeMillis());
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), "Standard1", names, System.currentTimeMillis());
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new ExpiringCell(Util.cellname("colExp"), ByteBufferUtil.bytes("valExp"), System.currentTimeMillis(), 42, nowInSec));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new CounterCell(Util.cellname("colA"), 42, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new Cell(Util.cellname("data"), UTF8Type.instance.fromString("{\"foo\":\"bar\"}")));
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.*;
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(Util.cellname("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(Util.cellname("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(Util.cellname("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(Util.cellname("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(Util.cellname("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(new ExpiringColumn(Util.cellname("colExp"), ByteBufferUtil.bytes("valExp"), System.currentTimeMillis(), 42, nowInSec));
0:         cfamily.addColumn(Util.cellname("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
0:         cfamily.addColumn(Util.cellname("colX"), ByteBufferUtil.bytes("valX"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfs = Keyspace.open("Keyspace1").getColumnFamilyStore("Standard1");
0:         cfamily.addColumn(Util.cellname("name"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(Util.cellname("name"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = Util.namesQueryFilter(cfs, Util.dk("rowA"), "name");
0:         assertEquals(hexToBytes("76616c"), cf.getColumn(Util.cellname("name")).value());
0:         qf = Util.namesQueryFilter(cfs, Util.dk("rowExclude"), "name");
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new CounterColumn(Util.cellname("colA"), 42, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new Column(Util.cellname("data"), UTF8Type.instance.fromString("{\"foo\":\"bar\"}")));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(Util.cellname("colName"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(Util.cellname("colName1"), ByteBufferUtil.bytes("val1"), System.currentTimeMillis());
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(ByteBufferUtil.bytes("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(ByteBufferUtil.bytes("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(ByteBufferUtil.bytes("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(new ExpiringColumn(ByteBufferUtil.bytes("colExp"), ByteBufferUtil.bytes("valExp"), System.currentTimeMillis(), 42, nowInSec));
0:         cfamily.addColumn(ByteBufferUtil.bytes("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
0:         cfamily.addColumn(ByteBufferUtil.bytes("colX"), ByteBufferUtil.bytes("valX"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(ByteBufferUtil.bytes("name"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(ByteBufferUtil.bytes("name"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), "Standard1", ByteBufferUtil.bytes("name"));
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), "Standard1", ByteBufferUtil.bytes("name"));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new CounterColumn(ByteBufferUtil.bytes("colA"), 42, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new Column(ByteBufferUtil.bytes("data"), UTF8Type.instance.fromString("{\"foo\":\"bar\"}")));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(ByteBufferUtil.bytes("colName"), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(ByteBufferUtil.bytes("colName1"), ByteBufferUtil.bytes("val1"), System.currentTimeMillis());
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0:         qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
0:         return bytesToHex(ByteBufferUtil.bytes(str));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:8704006
/////////////////////////////////////////////////////////////////////////
0:         writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.finish(true);
commit:02c3489
commit:61384c5
/////////////////////////////////////////////////////////////////////////
0:         reader.selfRef().release();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5de72e5
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_COUNTER).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_VALSWITHQUOTES).defaultValidator(UTF8Type.instance),
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:9129b6e
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 JSONValue.parse("{\"markedForDeleteAt\":0,\"localDeletionTime\":0}"),
0:                 serializedDeletionInfo);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:d06fd78
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")});
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")});
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
/////////////////////////////////////////////////////////////////////////
0:                              new String[0]);
commit:c87b6a3
/////////////////////////////////////////////////////////////////////////
0:     public static void defineSchema() throws ConfigurationException
commit:3020555
/////////////////////////////////////////////////////////////////////////
0:         assertNotNull(cf);
0:         assertEquals(hexToBytes("76616c"), cf.getColumn(ByteBufferUtil.bytes("name")).value());
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotNull;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         try (FileReader file = new FileReader(temp))
0:         {
0:             char[] buf = new char[(int) temp.length()];
0:             file.read(buf);
0:             String output = new String(buf);
0:     
0:             String sep = System.getProperty("line.separator");
0:             assert output.equals(asHex("rowA") + sep + asHex("rowB") + sep) : output;
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public void testRoundTripStandardCf() throws IOException
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.io.sstable.format.SSTableWriter;
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = SSTableWriter.create(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
commit:b6ce0a6
/////////////////////////////////////////////////////////////////////////
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_VALSWITHQUOTES, BytesType.instance).defaultValidator(UTF8Type.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, "AsciiKeys").keyValidator(AsciiType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "Standard1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "Standard1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "Counter1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "ValuesWithQuotes", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "Counter1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:                 CFMetaData.sparseCFMetaData(KEYSPACE1, "UUIDKeys", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "AsciiKeys");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "AsciiKeys");
/////////////////////////////////////////////////////////////////////////
0:                              CFMetaData.sparseCFMetaData(KEYSPACE1, "AsciiKeys", BytesType.instance));
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:0de0b8c
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE, 0);
commit:a7b7214
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.ActiveRepairService;
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:5019182
commit:91d61b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.AsciiType;
0: import org.apache.cassandra.db.marshal.BytesType;
/////////////////////////////////////////////////////////////////////////
0:         final Descriptor descriptor = Descriptor.fromFilename(writer.getFilename());
0:         SSTableExport.enumeratekeys(descriptor, new PrintStream(temp.getPath()),
0:                 CFMetaData.sparseCFMetaData(descriptor.ksname, descriptor.cfname, BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")},
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "Standard1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")},
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "Standard1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0],
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "Counter1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0],
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "ValuesWithQuotes", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0],
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "Counter1", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0],
0:                 CFMetaData.sparseCFMetaData("Keyspace1", "UUIDKeys", BytesType.instance));
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testAsciiKeyValidator() throws IOException, ParseException
0:     {
0:         File tempSS = tempSSTableFile("Keyspace1", "AsciiKeys");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "AsciiKeys");
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, ActiveRepairService.UNREPAIRED_SSTABLE);
0: 
0:         // Add a row
0:         cfamily.addColumn(column("column", "value", 1L));
0:         writer.append(Util.dk("key", AsciiType.instance), cfamily);
0: 
0:         SSTableReader reader = writer.closeAndOpenReader();
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("CFWithAsciiKeys", ".json");
0:         SSTableExport.export(reader,
0:                              new PrintStream(tempJson.getPath()),
0:                              new String[0],
0:                              CFMetaData.sparseCFMetaData("Keyspace1", "AsciiKeys", BytesType.instance));
0: 
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals(1, json.size());
0: 
0:         JSONObject row = (JSONObject)json.get(0);
0:         // check row key
0:         assertEquals("key", row.get("key"));
0:     }
commit:647bfc6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         JSONArray colsA = (JSONArray)rowA.get("cells");
/////////////////////////////////////////////////////////////////////////
0:         JSONArray colsB = (JSONArray)rowB.get("cells");
/////////////////////////////////////////////////////////////////////////
0:         JSONArray cols = (JSONArray)row.get("cells");
/////////////////////////////////////////////////////////////////////////
0:         JSONArray cols = (JSONArray)row.get("cells");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         JSONArray cols = (JSONArray) row.get("cells");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         JSONArray cols = (JSONArray) row.get("cells");
commit:42a39b5
/////////////////////////////////////////////////////////////////////////
0:         qf.collateOnDiskAtom(cf, qf.getSSTableColumnIterator(reader), Integer.MIN_VALUE);
commit:57c75a7
/////////////////////////////////////////////////////////////////////////
commit:b6be683
/////////////////////////////////////////////////////////////////////////
0: import java.io.OutputStream;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import org.apache.cassandra.db.Column;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.CounterColumn;
0: import org.apache.cassandra.db.DeletionInfo;
0: import org.apache.cassandra.db.ExpiringColumn;
0: import org.apache.cassandra.db.TreeMapBackedSortedColumns;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public SSTableWriter getDummyWriter() throws IOException
0:     {
0:         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
0: 
0:         // Add rowA
0:         cfamily.addColumn(ByteBufferUtil.bytes("colA"), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         writer.append(Util.dk("rowA"), cfamily);
0:         cfamily.clear();
0:         
0:         cfamily.addColumn(ByteBufferUtil.bytes("colB"), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
0:         writer.append(Util.dk("rowB"), cfamily);
0:         cfamily.clear();
0:         
0:         
0:         return writer;
0: 
0:     }
0:     
0:     
0:     public PrintStream dummyStream = new PrintStream(new OutputStream(){
0:         public void write(int b) throws IOException { throw new IOException(); }
0:     });
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Test(expected=IOException.class)
0:     public void testBrokenPipeEnumerateKeys() throws IOException
0:     {
0:     	SSTableWriter writer = getDummyWriter();
0:     	writer.closeAndOpenReader();
0:     	SSTableExport.enumeratekeys(Descriptor.fromFilename(writer.getFilename()), dummyStream);
0:     }
0:     
0:     @Test(expected=IOException.class)
0:     public void testBrokenPipeExport1() throws IOException
0:     {
0:     	SSTableWriter writer = getDummyWriter();
0:         SSTableExport.export(writer.closeAndOpenReader(), dummyStream, new String[0]);
0:     }
0:     
0:     @Test(expected=IOException.class)
0:     public void testBrokenPipeExport2() throws IOException 
0:     {
0:     	SSTableWriter writer = getDummyWriter();
0:     	writer.closeAndOpenReader();
0:         SSTableExport.export(Descriptor.fromFilename(writer.getFilename()), dummyStream, 
0:         		new ArrayList<String>(Arrays.asList("colA")), new String[]{"colA"});
0:     }
0:     
commit:aa76394
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.*;
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Counter1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "ValuesWithQuotes");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:681e2de
commit:98dc413
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.enumeratekeys(Descriptor.fromFilename(writer.getFilename()), new PrintStream(temp.getPath()));
commit:f491265
commit:ec26ee7
/////////////////////////////////////////////////////////////////////////
0:         return bytesToHex(ByteBufferUtil.bytes(str));
commit:7364c09
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.CounterColumn;
/////////////////////////////////////////////////////////////////////////
0:         assert colB.size() == 3;
/////////////////////////////////////////////////////////////////////////
0:         assert colA.size() == 3;
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testExportCounterCf() throws IOException
0:     {
0:         File tempSS = tempSSTableFile("Keyspace1", "Counter1");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Counter1");
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
0: 
0:         // Add rowA
0:         cfamily.addColumn(null, new CounterColumn(ByteBufferUtil.bytes("colA"), 42, System.currentTimeMillis()));
0:         writer.append(Util.dk("rowA"), cfamily);
0:         cfamily.clear();
0: 
0:         SSTableReader reader = writer.closeAndOpenReader();
0: 
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("Counter1", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
0: 
0:         JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));
0: 
0:         JSONArray rowA = (JSONArray)json.get(asHex("rowA"));
0:         JSONArray colA = (JSONArray)rowA.get(0);
0:         assert hexToBytes((String)colA.get(0)).equals(ByteBufferUtil.bytes("colA"));
0:         assert ((String) colA.get(3)).equals("c");
0:         assert (Long) colA.get(4) == Long.MIN_VALUE;
0:     }
commit:6350c16
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytesToHex;
0: import static org.apache.cassandra.utils.ByteBufferUtil.hexToBytes;
/////////////////////////////////////////////////////////////////////////
0:         return bytesToHex(ByteBuffer.wrap(str.getBytes()));
/////////////////////////////////////////////////////////////////////////
0:         assert hexToBytes((String)colA.get(1)).equals(ByteBufferUtil.bytes("valA"));
/////////////////////////////////////////////////////////////////////////
0:         assert hexToBytes((String)colA.get(1)).equals(ByteBufferUtil.bytes("valA"));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(cf.getColumn(ByteBufferUtil.bytes("name")).value().equals(hexToBytes("76616c")));
commit:436f3d0
/////////////////////////////////////////////////////////////////////////
0:         int nowInSec = (int)(System.currentTimeMillis() / 1000) + 42; //live for 42 seconds
commit:a44a150
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.ExpiringColumn;
/////////////////////////////////////////////////////////////////////////
0:     public void testExportSimpleCf() throws IOException
0:     {
0:         int nowInSec = (int)(System.currentTimeMillis() / 1000);
0:         cfamily.addColumn(null, new ExpiringColumn(ByteBufferUtil.bytes("colExp"), ByteBufferUtil.bytes("valExp"), 1, 42, nowInSec));
/////////////////////////////////////////////////////////////////////////
0: 
0:         JSONArray colExp = (JSONArray)rowA.get(1);
0:         assert ((Long)colExp.get(4)) == 42;
0:         assert ((Long)colExp.get(5)) == nowInSec;
commit:8358669
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superA"), ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superB"), ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superX"), ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), 1);
/////////////////////////////////////////////////////////////////////////
0:         JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString(ByteBufferUtil.bytes("superA")));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), 1);
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("name"));
0:         assertTrue(cf.getColumn(ByteBufferUtil.bytes("name")).value().equals(ByteBuffer.wrap(hexToBytes("76616c"))));
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("name"));
commit:187761a
/////////////////////////////////////////////////////////////////////////
0:         return bytesToHex(str.getBytes());
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:         return bytesToHex(ByteBuffer.wrap(str.getBytes()));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colX".getBytes())), ByteBuffer.wrap("valX".getBytes()), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superA".getBytes()), ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superB".getBytes()), ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superX".getBytes()), ByteBuffer.wrap("colX".getBytes())), ByteBuffer.wrap("valX".getBytes()), 1);
/////////////////////////////////////////////////////////////////////////
0:         JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString(ByteBuffer.wrap("superA".getBytes())));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("name".getBytes())), ByteBuffer.wrap("val".getBytes()), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("name".getBytes())), ByteBuffer.wrap("val".getBytes()), 1);
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBuffer.wrap("name".getBytes()));
0:         assertTrue(cf.getColumn(ByteBuffer.wrap("name".getBytes())).value().equals(ByteBuffer.wrap(hexToBytes("76616c"))));
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), ByteBuffer.wrap("name".getBytes()));
commit:9d32382
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
commit:b4386e7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.Descriptor;
0: 
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
/////////////////////////////////////////////////////////////////////////
0:         SSTableImport.importJson(tempJson.getPath(), "Keyspace1", "Standard1", tempSS2.getPath());
0: 
0:         reader = SSTableReader.open(Descriptor.fromFilename(tempSS2.getPath()));
commit:fc73007
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), cfamily);
0:         writer.append(Util.dk("rowB"), cfamily);
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), cfamily);
0:         writer.append(Util.dk("rowB"), cfamily);
0:         writer.append(Util.dk("rowExclude"), cfamily);
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), cfamily);
0:         writer.append(Util.dk("rowB"), cfamily);
0:         writer.append(Util.dk("rowExclude"), cfamily);
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), cfamily);
0:         writer.append(Util.dk("rowExclude"), cfamily);
commit:cba59a8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.TimestampClock;
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), new TimestampClock(1));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), new TimestampClock(1));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), new TimestampClock(1));
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), new TimestampClock(1));
commit:8a3543a
/////////////////////////////////////////////////////////////////////////
commit:5bf3ad0
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), 1);
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
commit:ee88039
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
0:         cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
commit:bf98ec9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryFilter;
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter("rowA", new QueryPath("Standard1", null, null), "name".getBytes());
0:         ColumnFamily cf = qf.getSSTableColumnIterator(reader, Integer.MAX_VALUE).getColumnFamily();
0:         qf = QueryFilter.getNamesFilter("rowExclude", new QueryPath("Standard1", null, null), "name".getBytes());
0:         cf = qf.getSSTableColumnIterator(reader, Integer.MAX_VALUE).getColumnFamily();
commit:86eaf90
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.SSTableReader;
0: import org.apache.cassandra.io.sstable.SSTableWriter;
0: import static org.apache.cassandra.io.sstable.SSTableUtils.tempSSTableFile;
commit:8f1376b
/////////////////////////////////////////////////////////////////////////
0: 
0:         // Add rowExclude
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowExclude"), dob);
0:         dob.reset();
0:         cfamily.clear();
0: 
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{"rowExclude"});
/////////////////////////////////////////////////////////////////////////
0: 
0:         JSONArray rowExclude = (JSONArray)json.get("rowExclude");
0:         assert rowExclude == null;
/////////////////////////////////////////////////////////////////////////
0: 
0:         // Add rowExclude
0:         cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowExclude"), dob);
0:         dob.reset();
0:         cfamily.clear();
0: 
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{"rowExclude"});
/////////////////////////////////////////////////////////////////////////
0:         JSONObject rowExclude = (JSONObject)json.get("rowExclude");
0:         assert !(Boolean)colA.get(3);
0:         assert rowExclude == null;
/////////////////////////////////////////////////////////////////////////
0: 
0:         // Add rowExclude
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowExclude"), dob);
0:         dob.reset();
0:         cfamily.clear();
0: 
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{"rowExclude"});
/////////////////////////////////////////////////////////////////////////
0: 
0:         qf = new NamesQueryFilter("rowExclude", new QueryPath("Standard1", null, null), "name".getBytes());
0:         cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
0:         assert cf == null;
0: 
commit:5d4371a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         writer.closeAndOpenReader();
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.closeAndOpenReader();
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.closeAndOpenReader();
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader reader = writer.closeAndOpenReader();
/////////////////////////////////////////////////////////////////////////
0:         reader = SSTableReader.open(tempSS2.getPath(), DatabaseDescriptor.getPartitioner());
commit:128821e
/////////////////////////////////////////////////////////////////////////
0: 
0:         String sep = System.getProperty("line.separator");
0:         assert output.equals("rowA" + sep + "rowB" + sep) : output;
commit:2126f60
/////////////////////////////////////////////////////////////////////////
0:     public void testExportSimpleCf() throws IOException    {
commit:820390f
/////////////////////////////////////////////////////////////////////////
0:     public void testEnumeratekeys() throws IOException
0:     {
0:         File tempSS = createTemporarySSTable("Keyspace1", "Standard1");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
0:         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
0:         DataOutputBuffer dob = new DataOutputBuffer();
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
0:         
0:         // Add rowA
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowA"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:         
0:         // Add rowB
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowB"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:      
0:         writer.closeAndOpenReader(0);
0:         
0:         // Enumerate and verify
0:         File temp = File.createTempFile("Standard1", ".txt");
0:         SSTableExport.enumeratekeys(writer.getFilename(), new PrintStream(temp.getPath()));
0: 
0:         
0:         FileReader file = new FileReader(temp);
0:         char[] buf = new char[(int) temp.length()];
0:         file.read(buf);
0:         String output = new String(buf);
0:         
0:         assert output.equals("rowA\nrowB\n");
0:     }
0: 
0:     @Test
commit:3655e91
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputBuffer;
commit:dc6e4fe
/////////////////////////////////////////////////////////////////////////
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
0: import org.apache.cassandra.db.marshal.UUIDType;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: import org.apache.thrift.TException;
0: import org.junit.BeforeClass;
0: public class SSTableExportTest
0:     public static final String KEYSPACE1 = "SSTableExportTest";
0:     public static final String CF_STANDARD = "Standard1";
0:     public static final String CF_COUNTER = "Counter1";
0:     public static final String CF_UUID = "UUIDKeys";
0:     public static final String CF_VALSWITHQUOTES = "ValuesWithQuotes";
0: 
0:     @BeforeClass
0:     public static void defineSchema() throws ConfigurationException, IOException, TException
0:     {
0:         SchemaLoader.prepareServer();
0:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_COUNTER, BytesType.instance).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_UUID).keyValidator(UUIDType.instance),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_VALSWITHQUOTES, BytesType.instance).defaultValidator(UTF8Type.instance));
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "Standard1");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "Standard1");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore("Standard1");
0:         File tempSS = tempSSTableFile(KEYSPACE1, "Standard1");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS2 = tempSSTableFile(KEYSPACE1, "Standard1");
0:         new SSTableImport().importJson(tempJson.getPath(), KEYSPACE1, "Standard1", tempSS2.getPath());
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "Counter1");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Counter1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "ValuesWithQuotes");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "ValuesWithQuotes");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "Standard1");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile(KEYSPACE1, "UUIDKeys");
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "UUIDKeys");
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new BufferExpiringCell(Util.cellname("colExp"), ByteBufferUtil.bytes("valExp"), System.currentTimeMillis(), 42, nowInSec));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(BufferCounterCell.createLocal(Util.cellname("colA"), 42, System.currentTimeMillis(), Long.MIN_VALUE));
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new BufferCell(Util.cellname("data"), UTF8Type.instance.fromString("{\"foo\":\"bar\"}")));
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:5204575
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Counter1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "ValuesWithQuotes");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cfamily = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:714c423
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(CounterCell.createLocal(Util.cellname("colA"), 42, System.currentTimeMillis(), Long.MIN_VALUE));
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), "Standard1", ByteBufferUtil.bytes("name"), System.currentTimeMillis());
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), "Standard1", ByteBufferUtil.bytes("name"), System.currentTimeMillis());
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:d569f87
/////////////////////////////////////////////////////////////////////////
0: import static junit.framework.Assert.assertEquals;
0: import static junit.framework.Assert.assertNotNull;
0: import static org.apache.cassandra.io.sstable.SSTableUtils.tempSSTableFile;
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytesToHex;
0: import static org.apache.cassandra.utils.ByteBufferUtil.hexToBytes;
0: import static org.junit.Assert.assertTrue;
0: 
0: import org.junit.Test;
0: 
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.Column;
0: import org.apache.cassandra.db.DeletionInfo;
0: import org.apache.cassandra.db.SuperColumn;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void testExportSimpleCf() throws IOException, ParseException
/////////////////////////////////////////////////////////////////////////
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals("unexpected number of rows", 2, json.size());
0:         JSONObject rowA = (JSONObject)json.get(0);
0:         assertEquals("unexpected number of keys", 2, rowA.keySet().size());
0:         assertEquals("unexpected row key",asHex("rowA"),rowA.get("key"));
0: 
0:         JSONArray colsA = (JSONArray)rowA.get("columns");
0:         JSONArray colA = (JSONArray)colsA.get(0);
0:         JSONArray colExp = (JSONArray)colsA.get(1);
0:         JSONObject rowB = (JSONObject)json.get(1);
0:         assertEquals("unexpected number of keys", 2, rowB.keySet().size());
0:         assertEquals("unexpected row key",asHex("rowB"),rowB.get("key"));
0: 
0:         JSONArray colsB = (JSONArray)rowB.get("columns");
0:         JSONArray colB = (JSONArray)colsB.get(0);
0:     public void testExportSuperCf() throws IOException, ParseException
/////////////////////////////////////////////////////////////////////////
0:         // set deletion info on the super col
0:         ((SuperColumn) cfamily.getColumn(ByteBufferUtil.bytes("superA"))).setDeletionInfo(new DeletionInfo(0, 0));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[] { asHex("rowExclude") });
0:         JSONArray json = (JSONArray) JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals("unexpected number of rows", 2, json.size());
0:         // make sure only the two rows we expect are there
0:         JSONObject rowA = (JSONObject) json.get(0);
0:         assertEquals("unexpected number of keys", 2, rowA.keySet().size());
0:         assertEquals("unexpected row key", asHex("rowA"), rowA.get("key"));
0:         JSONObject rowB = (JSONObject) json.get(0);
0:         assertEquals("unexpected number of keys", 2, rowB.keySet().size());
0:         assertEquals("unexpected row key", asHex("rowA"), rowB.get("key"));
0: 
0:         JSONObject cols = (JSONObject) rowA.get("columns");
0: 
0:         JSONObject superA = (JSONObject) cols.get(cfamily.getComparator().getString(ByteBufferUtil.bytes("superA")));
0:         JSONArray subColumns = (JSONArray) superA.get("subColumns");
0:         JSONArray colA = (JSONArray) subColumns.get(0);
0:         assert hexToBytes((String) colA.get(1)).equals(ByteBufferUtil.bytes("valA"));
/////////////////////////////////////////////////////////////////////////
0:         new SSTableImport().importJson(tempJson.getPath(), "Keyspace1", "Standard1", tempSS2.getPath());
/////////////////////////////////////////////////////////////////////////
0:     public void testExportCounterCf() throws IOException, ParseException
/////////////////////////////////////////////////////////////////////////
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals("unexpected number of rows", 1, json.size());
0:         JSONObject row = (JSONObject)json.get(0);
0:         assertEquals("unexpected number of keys", 2, row.keySet().size());
0:         assertEquals("unexpected row key",asHex("rowA"),row.get("key"));
0:         JSONArray cols = (JSONArray)row.get("columns");
0:         JSONArray colA = (JSONArray)cols.get(0);
0:     public void testEscapingDoubleQuotes() throws IOException, ParseException
/////////////////////////////////////////////////////////////////////////
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         assertEquals("unexpected number of rows", 1, json.size());
0:         JSONObject row = (JSONObject)json.get(0);
0:         assertEquals("unexpected number of keys", 2, row.keySet().size());
0:         assertEquals("unexpected row key",asHex("rowA"),row.get("key"));
0: 
0:         JSONArray cols = (JSONArray)row.get("columns");
0:         JSONArray colA = (JSONArray)cols.get(0);
0:         assert hexToBytes((String)colA.get(0)).equals(ByteBufferUtil.bytes("data"));
0:         assert colA.get(1).equals("{\"foo\":\"bar\"}");
0:     }
0: 
0:     @Test
0:     public void testExportColumnsWithMetadata() throws IOException, ParseException
0:     {
0: 
0:         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
0: 
0:         // Add rowA
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colName")),
0:                 ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colName1")),
0:                 ByteBufferUtil.bytes("val1"), System.currentTimeMillis());
0:         cfamily.delete(new DeletionInfo(0, 0));
0:         writer.append(Util.dk("rowA"), cfamily);
0: 
0:         SSTableReader reader = writer.closeAndOpenReader();
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("CFWithDeletionInfo", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);
0: 
0:         JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));
0:         System.out.println(json.toJSONString());
0:         assertEquals("unexpected number of rows", 1, json.size());
0: 
0:         JSONObject row = (JSONObject)json.get(0);
0:         assertEquals("unexpected number of keys", 3, row.keySet().size());
0:         assertEquals("unexpected row key",asHex("rowA"),row.get("key"));
0: 
0:         // check that the row key is there and present
0:         String rowKey = (String) row.get("key");
0:         assertNotNull("expecing key to be present", rowKey);
0:         assertEquals("key did not match", ByteBufferUtil.bytes("rowA"), hexToBytes(rowKey));
0: 
0:         // check that there is metadata and that it contains deletionInfo
0:         JSONObject meta = (JSONObject) row.get("metadata");
0:         assertNotNull("expecing metadata to be present", meta);
0: 
0:         assertEquals("unexpected number of metadata entries", 1, meta.keySet().size());
0: 
0:         JSONObject serializedDeletionInfo = (JSONObject) meta.get("deletionInfo");
0:         assertNotNull("expecing deletionInfo to be present", serializedDeletionInfo);
0: 
0:         assertEquals(
0:                 "unexpected serialization format for topLevelDeletion",
0:                 "{\"markedForDeleteAt\":0,\"localDeletionTime\":0}",
0:                 serializedDeletionInfo.toJSONString());
0: 
0:         // check the colums are what we put in
0:         JSONArray cols = (JSONArray) row.get("columns");
0:         assertNotNull("expecing columns to be present", cols);
0:         assertEquals("expecting two columns", 2, cols.size());
0: 
0:         JSONArray col1 = (JSONArray) cols.get(0);
0:         assertEquals("column name did not match", ByteBufferUtil.bytes("colName"), hexToBytes((String) col1.get(0)));
0:         assertEquals("column value did not match", ByteBufferUtil.bytes("val"), hexToBytes((String) col1.get(1)));
0: 
0:         JSONArray col2 = (JSONArray) cols.get(1);
0:         assertEquals("column name did not match", ByteBufferUtil.bytes("colName1"), hexToBytes((String) col2.get(0)));
0:         assertEquals("column value did not match", ByteBufferUtil.bytes("val1"), hexToBytes((String) col2.get(1)));
0: 
author:Brandon Williams
-------------------------------------------------------------------------------
commit:33a6640
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(null, new ExpiringColumn(ByteBufferUtil.bytes("colExp"), ByteBufferUtil.bytes("valExp"), System.currentTimeMillis(), 42, nowInSec));
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superA"), ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superB"), ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superX"), ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
0:         cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), System.currentTimeMillis());
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:64f443a
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.utils.FBUtilities.bytesToHex;
/////////////////////////////////////////////////////////////////////////
0:     public String asHex(String str)
0:     {
0:         return bytesToHex(str.getBytes());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         assert output.equals(asHex("rowA") + sep + asHex("rowB") + sep) : output;
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")});
0:         JSONArray rowA = (JSONArray)json.get(asHex("rowA"));
0:         JSONArray rowB = (JSONArray)json.get(asHex("rowB"));
0:         JSONArray rowExclude = (JSONArray)json.get(asHex("rowExclude"));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")});
0:         JSONObject rowA = (JSONObject)json.get(asHex("rowA"));
0:         JSONObject rowExclude = (JSONObject)json.get(asHex("rowExclude"));
/////////////////////////////////////////////////////////////////////////
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex("rowExclude")});
commit:434564d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
0: 
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), dob);
0:         writer.append(Util.dk("rowB"), dob);
/////////////////////////////////////////////////////////////////////////
0:         // FIXME: string keys
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), dob);
0:         writer.append(Util.dk("rowB"), dob);
0:         writer.append(Util.dk("rowExclude"), dob);
/////////////////////////////////////////////////////////////////////////
0:         // FIXME: string keys
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), dob);
0:         writer.append(Util.dk("rowB"), dob);
0:         writer.append(Util.dk("rowExclude"), dob);
/////////////////////////////////////////////////////////////////////////
0:         writer.append(Util.dk("rowA"), dob);
0:         writer.append(Util.dk("rowExclude"), dob);
/////////////////////////////////////////////////////////////////////////
0:         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), "name".getBytes());
0:         qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), "name".getBytes());
commit:7a75b63
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class SSTableExportTest extends SchemaLoader
commit:81d713a
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.io.SSTableUtils.tempSSTableFile;
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile("Keyspace1", "Super4");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         File tempSS2 = tempSSTableFile("Keyspace1", "Standard1");
author:Eric Evans
-------------------------------------------------------------------------------
commit:9572076
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.NamesQueryFilter;
0: import org.apache.cassandra.io.SSTableAccessor;
0: import static org.junit.Assert.assertTrue;
0: 
0: import org.json.simple.parser.ParseException;
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Test
0:     public void testRoundTripStandardCf() throws IOException, ParseException
0:     {
0:         File tempSS = createTemporarySSTable("Keyspace1", "Standard1");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
0:         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
0:         DataOutputBuffer dob = new DataOutputBuffer();
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
0:         
0:         // Add rowA
0:         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowA"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:         
0:         SSTableReader reader = writer.closeAndOpenReader(0);
0:         
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("Standard1", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()));
0:         
0:         // Import JSON to another SSTable file
0:         File tempSS2 = createTemporarySSTable("Keyspace1", "Standard1");
0:         SSTableImport.importJson(tempJson.getPath(), "Keyspace1", "Standard1", tempSS2.getPath());        
0:         
0:         reader = SSTableAccessor.getSSTableReader(tempSS2.getPath(), DatabaseDescriptor.getPartitioner());
0:         NamesQueryFilter qf = new NamesQueryFilter("rowA", new QueryPath("Standard1", null, null), "name".getBytes());
0:         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
0:         assertTrue(cf != null);
0:         assertTrue(Arrays.equals(cf.getColumn("name".getBytes()).value(), hexToBytes("76616c")));
0:     }
0:     
commit:e65ce8d
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
0: package org.apache.cassandra.tools;
0: 
0: import java.io.File;
0: import java.io.FileReader;
0: import java.io.IOException;
0: import java.io.PrintStream;
0: import java.util.Arrays;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.io.DataOutputBuffer;
0: import org.apache.cassandra.io.SSTableReader;
0: import org.apache.cassandra.io.SSTableWriter;
0: import static org.apache.cassandra.Util.createTemporarySSTable;
0: import static org.apache.cassandra.utils.FBUtilities.hexToBytes;
0: import org.json.simple.JSONArray;
0: import org.json.simple.JSONObject;
0: import org.json.simple.JSONValue;
0: import org.junit.Test;
0: 
0: public class SSTableExportTest
0: {
0:     @Test
0:     public void testExportSimpleCf() throws IOException
0:     {
0:         File tempSS = createTemporarySSTable("Keyspace1", "Standard1");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
0:         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
0:         DataOutputBuffer dob = new DataOutputBuffer();
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
0:         
0:         // Add rowA
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowA"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:         
0:         // Add rowB
0:         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowB"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:      
0:         SSTableReader reader = writer.closeAndOpenReader(0);
0:         
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("Standard1", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()));
0:         
0:         JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));
0:         
0:         JSONArray rowA = (JSONArray)json.get("rowA");
0:         JSONArray colA = (JSONArray)rowA.get(0);
0:         assert Arrays.equals(hexToBytes((String)colA.get(1)), "valA".getBytes());
0:         
0:         JSONArray rowB = (JSONArray)json.get("rowB");
0:         JSONArray colB = (JSONArray)rowB.get(0);
0:         assert !(Boolean)colB.get(3);
0:     }
0: 
0:     @Test
0:     public void testExportSuperCf() throws IOException
0:     {
0:         File tempSS = createTemporarySSTable("Keyspace1", "Super4");
0:         ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Super4");
0:         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
0:         DataOutputBuffer dob = new DataOutputBuffer();
0:         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
0:         
0:         // Add rowA
0:         cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowA"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:         
0:         // Add rowB
0:         cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), 1, false);
0:         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
0:         writer.append(partitioner.decorateKey("rowB"), dob);
0:         dob.reset();
0:         cfamily.clear();
0:      
0:         SSTableReader reader = writer.closeAndOpenReader(0);
0:         
0:         // Export to JSON and verify
0:         File tempJson = File.createTempFile("Super4", ".json");
0:         SSTableExport.export(reader, new PrintStream(tempJson.getPath()));
0:         
0:         JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));
0:         
0:         JSONObject rowA = (JSONObject)json.get("rowA");
0:         JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString("superA".getBytes()));
0:         JSONArray subColumns = (JSONArray)superA.get("subColumns");
0:         JSONArray colA = (JSONArray)subColumns.get(0);
0:         
0:         assert Arrays.equals(hexToBytes((String)colA.get(1)), "valA".getBytes());
0:         assert !(Boolean)colA.get(3);       
0:     }
0: }
============================================================================