1:72790dc: /*
1:72790dc:  * Licensed to the Apache Software Foundation (ASF) under one
1:72790dc:  * or more contributor license agreements.  See the NOTICE file
1:72790dc:  * distributed with this work for additional information
1:72790dc:  * regarding copyright ownership.  The ASF licenses this file
1:72790dc:  * to you under the Apache License, Version 2.0 (the
1:72790dc:  * "License"); you may not use this file except in compliance
1:72790dc:  * with the License.  You may obtain a copy of the License at
1:72790dc:  *
1:72790dc:  *     http://www.apache.org/licenses/LICENSE-2.0
1:72790dc:  *
1:72790dc:  * Unless required by applicable law or agreed to in writing, software
1:72790dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72790dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72790dc:  * See the License for the specific language governing permissions and
1:72790dc:  * limitations under the License.
1:72790dc:  */
1:72790dc: package org.apache.cassandra.index.sasi.disk;
2:72790dc: 
1:72790dc: import java.io.File;
1:72790dc: import java.nio.ByteBuffer;
1:72790dc: import java.util.*;
1:72790dc: import java.util.concurrent.ThreadLocalRandom;
1:72790dc: import java.util.stream.Collectors;
1:72790dc: 
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:7d857b4: import com.carrotsearch.hppc.cursors.LongObjectCursor;
1:72790dc: import org.apache.cassandra.cql3.Operator;
1:7d857b4: import org.apache.cassandra.db.Clustering;
1:7d857b4: import org.apache.cassandra.db.ClusteringComparator;
1:72790dc: import org.apache.cassandra.db.DecoratedKey;
1:7d857b4: import org.apache.cassandra.db.marshal.BytesType;
1:72790dc: import org.apache.cassandra.index.sasi.plan.Expression;
1:72790dc: import org.apache.cassandra.index.sasi.utils.CombinedTerm;
1:72790dc: import org.apache.cassandra.index.sasi.utils.CombinedTermIterator;
1:7d857b4: import org.apache.cassandra.index.sasi.utils.KeyConverter;
1:72790dc: import org.apache.cassandra.index.sasi.utils.OnDiskIndexIterator;
1:72790dc: import org.apache.cassandra.index.sasi.utils.RangeIterator;
1:72790dc: import org.apache.cassandra.db.marshal.AbstractType;
1:72790dc: import org.apache.cassandra.db.marshal.Int32Type;
1:72790dc: import org.apache.cassandra.db.marshal.LongType;
1:72790dc: import org.apache.cassandra.db.marshal.UTF8Type;
1:7107646: import org.apache.cassandra.io.util.DataOutputBuffer;
1:72790dc: import org.apache.cassandra.utils.Pair;
1:72790dc: 
1:72790dc: import com.google.common.collect.Iterators;
1:72790dc: import com.google.common.collect.Sets;
1:72790dc: 
1:72790dc: import junit.framework.Assert;
1:9797511: 
1:9797511: import org.junit.BeforeClass;
1:72790dc: import org.junit.Test;
1:72790dc: 
1:72790dc: public class OnDiskIndexTest
2:72790dc: {
1:9797511:     @BeforeClass
1:9797511:     public static void setupDD()
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:72790dc:     @Test
1:72790dc:     public void testStringSAConstruction() throws Exception
1:72790dc:     {
1:72790dc:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:72790dc:         {{
1:72790dc:                 put(UTF8Type.instance.decompose("scat"), keyBuilder(1L));
1:72790dc:                 put(UTF8Type.instance.decompose("mat"),  keyBuilder(2L));
1:72790dc:                 put(UTF8Type.instance.decompose("fat"),  keyBuilder(3L));
1:72790dc:                 put(UTF8Type.instance.decompose("cat"),  keyBuilder(1L, 4L));
1:72790dc:                 put(UTF8Type.instance.decompose("till"), keyBuilder(2L, 6L));
1:72790dc:                 put(UTF8Type.instance.decompose("bill"), keyBuilder(5L));
1:72790dc:                 put(UTF8Type.instance.decompose("foo"),  keyBuilder(7L));
1:72790dc:                 put(UTF8Type.instance.decompose("bar"),  keyBuilder(9L, 10L));
1:72790dc:                 put(UTF8Type.instance.decompose("michael"), keyBuilder(11L, 12L, 1L));
1:2ca2fff:                 put(UTF8Type.instance.decompose("am"), keyBuilder(15L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS);
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:             addAll(builder, e.getKey(), e.getValue());
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-string", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         // first check if we can find exact matches
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:         {
1:72790dc:             if (UTF8Type.instance.getString(e.getKey()).equals("cat"))
1:72790dc:                 continue; // cat is embedded into scat, we'll test it in next section
1:72790dc: 
1:7d857b4:             Assert.assertEquals("Key was: " + UTF8Type.instance.compose(e.getKey()),
1:7d857b4:                                 convert(e.getValue()),
1:7d857b4:                                 convert(onDisk.search(expressionFor(UTF8Type.instance, e.getKey()))));
2:72790dc:         }
1:72790dc: 
1:72790dc:         // check that cat returns positions for scat & cat
1:7d857b4:         Assert.assertEquals(convert(1L, 4L), convert(onDisk.search(expressionFor("cat"))));
1:72790dc: 
1:72790dc:         // random suffix queries
1:72790dc:         Assert.assertEquals(convert(9, 10), convert(onDisk.search(expressionFor("ar"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4), convert(onDisk.search(expressionFor("at"))));
1:72790dc:         Assert.assertEquals(convert(1, 11, 12), convert(onDisk.search(expressionFor("mic"))));
1:72790dc:         Assert.assertEquals(convert(1, 11, 12), convert(onDisk.search(expressionFor("ae"))));
1:72790dc:         Assert.assertEquals(convert(2, 5, 6), convert(onDisk.search(expressionFor("ll"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 5, 6, 11, 12), convert(onDisk.search(expressionFor("l"))));
1:72790dc:         Assert.assertEquals(convert(7), convert(onDisk.search(expressionFor("oo"))));
1:72790dc:         Assert.assertEquals(convert(7), convert(onDisk.search(expressionFor("o"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4, 6), convert(onDisk.search(expressionFor("t"))));
1:2ca2fff:         Assert.assertEquals(convert(1, 2, 11, 12), convert(onDisk.search(expressionFor("m", Operator.LIKE_PREFIX))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("hello"))));
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testIntegerSAConstruction() throws Exception
1:72790dc:     {
1:72790dc:         final Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:72790dc:         {{
1:72790dc:                 put(Int32Type.instance.decompose(5),  keyBuilder(1L));
1:72790dc:                 put(Int32Type.instance.decompose(7),  keyBuilder(2L));
1:72790dc:                 put(Int32Type.instance.decompose(1),  keyBuilder(3L));
1:72790dc:                 put(Int32Type.instance.decompose(3),  keyBuilder(1L, 4L));
1:72790dc:                 put(Int32Type.instance.decompose(8),  keyBuilder(2L, 6L));
1:72790dc:                 put(Int32Type.instance.decompose(10), keyBuilder(5L));
1:72790dc:                 put(Int32Type.instance.decompose(6),  keyBuilder(7L));
1:72790dc:                 put(Int32Type.instance.decompose(4),  keyBuilder(9L, 10L));
1:72790dc:                 put(Int32Type.instance.decompose(0),  keyBuilder(11L, 12L, 1L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:             addAll(builder, e.getKey(), e.getValue());
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-int", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:         {
1:3928665:             Assert.assertEquals(convert(e.getValue()), convert(onDisk.search(expressionFor(Operator.EQ, Int32Type.instance, e.getKey()))));
1:72790dc:         }
1:72790dc: 
1:72790dc:         List<ByteBuffer> sortedNumbers = new ArrayList<ByteBuffer>()
1:72790dc:         {{
1:72790dc:             addAll(data.keySet().stream().collect(Collectors.toList()));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         Collections.sort(sortedNumbers, Int32Type.instance::compare);
1:72790dc: 
1:72790dc:         // test full iteration
1:72790dc:         int idx = 0;
1:72790dc:         for (OnDiskIndex.DataTerm term : onDisk)
1:72790dc:         {
1:72790dc:             ByteBuffer number = sortedNumbers.get(idx++);
1:72790dc:             Assert.assertEquals(number, term.getTerm());
1:72790dc:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:72790dc:         }
1:72790dc: 
1:72790dc:         // test partial iteration (descending)
1:72790dc:         idx = 3; // start from the 3rd element
1:72790dc:         Iterator<OnDiskIndex.DataTerm> partialIter = onDisk.iteratorAt(sortedNumbers.get(idx), OnDiskIndex.IteratorOrder.DESC, true);
1:72790dc:         while (partialIter.hasNext())
1:72790dc:         {
1:72790dc:             OnDiskIndex.DataTerm term = partialIter.next();
1:72790dc:             ByteBuffer number = sortedNumbers.get(idx++);
1:72790dc: 
1:72790dc:             Assert.assertEquals(number, term.getTerm());
1:72790dc:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:72790dc:         }
1:72790dc: 
1:72790dc:         idx = 3; // start from the 3rd element exclusive
1:72790dc:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx++), OnDiskIndex.IteratorOrder.DESC, false);
1:72790dc:         while (partialIter.hasNext())
1:72790dc:         {
1:72790dc:             OnDiskIndex.DataTerm term = partialIter.next();
1:72790dc:             ByteBuffer number = sortedNumbers.get(idx++);
1:72790dc: 
1:72790dc:             Assert.assertEquals(number, term.getTerm());
1:72790dc:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:72790dc:         }
1:72790dc: 
1:72790dc:         // test partial iteration (ascending)
1:72790dc:         idx = 6; // start from the 6rd element
1:72790dc:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx), OnDiskIndex.IteratorOrder.ASC, true);
1:72790dc:         while (partialIter.hasNext())
1:72790dc:         {
1:72790dc:             OnDiskIndex.DataTerm term = partialIter.next();
1:72790dc:             ByteBuffer number = sortedNumbers.get(idx--);
1:72790dc: 
1:72790dc:             Assert.assertEquals(number, term.getTerm());
1:72790dc:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:72790dc:         }
1:72790dc: 
1:72790dc:         idx = 6; // start from the 6rd element exclusive
1:72790dc:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx--), OnDiskIndex.IteratorOrder.ASC, false);
1:72790dc:         while (partialIter.hasNext())
1:72790dc:         {
1:72790dc:             OnDiskIndex.DataTerm term = partialIter.next();
1:72790dc:             ByteBuffer number = sortedNumbers.get(idx--);
1:72790dc: 
1:72790dc:             Assert.assertEquals(number, term.getTerm());
1:72790dc:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:72790dc:         }
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc: 
1:72790dc:         List<ByteBuffer> iterCheckNums = new ArrayList<ByteBuffer>()
1:72790dc:         {{
1:72790dc:             add(Int32Type.instance.decompose(3));
1:72790dc:             add(Int32Type.instance.decompose(9));
1:72790dc:             add(Int32Type.instance.decompose(14));
1:72790dc:             add(Int32Type.instance.decompose(42));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder iterTest = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         for (int i = 0; i < iterCheckNums.size(); i++)
1:7d857b4:             iterTest.add(iterCheckNums.get(i), keyAt((long) i), i, i + 5);
1:72790dc: 
1:72790dc:         File iterIndex = File.createTempFile("sa-iter", ".db");
1:72790dc:         iterIndex.deleteOnExit();
1:72790dc: 
1:72790dc:         iterTest.finish(iterIndex);
1:72790dc: 
1:7d857b4:         onDisk = new OnDiskIndex(iterIndex, Int32Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         ByteBuffer number = Int32Type.instance.decompose(1);
1:72790dc:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:72790dc:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:72790dc:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:72790dc:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1:72790dc: 
1:72790dc:         number = Int32Type.instance.decompose(44);
1:72790dc:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:72790dc:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:72790dc:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:72790dc:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1:72790dc: 
1:72790dc:         number = Int32Type.instance.decompose(20);
1:72790dc:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:72790dc:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:72790dc:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:72790dc:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1:72790dc: 
1:72790dc:         number = Int32Type.instance.decompose(5);
1:72790dc:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:72790dc:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:72790dc:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:72790dc:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1:72790dc: 
1:72790dc:         number = Int32Type.instance.decompose(10);
1:72790dc:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:72790dc:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:72790dc:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:72790dc:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testMultiSuffixMatches() throws Exception
1:72790dc:     {
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS)
1:72790dc:         {{
1:72790dc:                 addAll(this, UTF8Type.instance.decompose("Eliza"), keyBuilder(1L, 2L));
1:72790dc:                 addAll(this, UTF8Type.instance.decompose("Elizabeth"), keyBuilder(3L, 4L));
1:72790dc:                 addAll(this, UTF8Type.instance.decompose("Aliza"), keyBuilder(5L, 6L));
1:72790dc:                 addAll(this, UTF8Type.instance.decompose("Taylor"), keyBuilder(7L, 8L));
1:72790dc:                 addAll(this, UTF8Type.instance.decompose("Pavel"), keyBuilder(9L, 10L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-multi-suffix-match", ".db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6), convert(onDisk.search(expressionFor("liz"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionFor("a"))));
1:72790dc:         Assert.assertEquals(convert(5, 6), convert(onDisk.search(expressionFor("A"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4), convert(onDisk.search(expressionFor("E"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionFor("l"))));
1:72790dc:         Assert.assertEquals(convert(3, 4), convert(onDisk.search(expressionFor("bet"))));
1:72790dc:         Assert.assertEquals(convert(3, 4, 9, 10), convert(onDisk.search(expressionFor("e"))));
1:72790dc:         Assert.assertEquals(convert(7, 8), convert(onDisk.search(expressionFor("yl"))));
1:72790dc:         Assert.assertEquals(convert(7, 8), convert(onDisk.search(expressionFor("T"))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6), convert(onDisk.search(expressionFor("za"))));
1:72790dc:         Assert.assertEquals(convert(3, 4), convert(onDisk.search(expressionFor("ab"))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Pi"))));
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("ethz"))));
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("liw"))));
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Taw"))));
1:72790dc:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Av"))));
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSparseMode() throws Exception
1:72790dc:     {
2:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:72790dc: 
1:72790dc:         final long start = System.currentTimeMillis();
1:72790dc:         final int numIterations = 100000;
1:72790dc: 
1:72790dc:         for (long i = 0; i < numIterations; i++)
1:7d857b4:             builder.add(LongType.instance.decompose(start + i), keyAt(i), i, clusteringOffset(i));
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-sparse", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:72790dc: 
1:72790dc:         for (long step = start; step < (start + numIterations); step += 1000)
1:72790dc:         {
1:72790dc:             boolean lowerInclusive = random.nextBoolean();
1:72790dc:             boolean upperInclusive = random.nextBoolean();
1:72790dc: 
1:72790dc:             long limit = random.nextLong(step, start + numIterations);
1:72790dc:             RangeIterator<Long, Token> rows = onDisk.search(expressionFor(step, lowerInclusive, limit, upperInclusive));
1:72790dc: 
1:72790dc:             long lowerKey = step - start;
1:72790dc:             long upperKey = lowerKey + (limit - step);
1:72790dc: 
1:72790dc:             if (!lowerInclusive)
1:72790dc:                 lowerKey += 1;
1:72790dc: 
1:72790dc:             if (upperInclusive)
1:72790dc:                 upperKey += 1;
1:72790dc: 
1:7d857b4:             Set<RowKey> actual = convert(rows);
1:72790dc:             for (long key = lowerKey; key < upperKey; key++)
1:7d857b4:                 Assert.assertTrue("key" + key + " wasn't found", actual.contains(new RowKey(keyAt(key), ck(clusteringOffset(key)), CLUSTERING_COMPARATOR)));
1:72790dc: 
1:72790dc:             Assert.assertEquals((upperKey - lowerKey), actual.size());
1:72790dc:         }
1:72790dc: 
1:72790dc:         // let's also explicitly test whole range search
1:72790dc:         RangeIterator<Long, Token> rows = onDisk.search(expressionFor(start, true, start + numIterations, true));
1:72790dc: 
1:7d857b4:         Set<RowKey> actual = convert(rows);
1:72790dc:         Assert.assertEquals(numIterations, actual.size());
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testNotEqualsQueryForStrings() throws Exception
1:72790dc:     {
1:72790dc:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:72790dc:         {{
1:72790dc:                 put(UTF8Type.instance.decompose("Pavel"),   keyBuilder(1L, 2L));
1:72790dc:                 put(UTF8Type.instance.decompose("Jason"),   keyBuilder(3L));
1:72790dc:                 put(UTF8Type.instance.decompose("Jordan"),  keyBuilder(4L));
1:72790dc:                 put(UTF8Type.instance.decompose("Michael"), keyBuilder(5L, 6L));
1:72790dc:                 put(UTF8Type.instance.decompose("Vijay"),   keyBuilder(7L));
1:72790dc:                 put(UTF8Type.instance.decompose("Travis"),  keyBuilder(8L));
1:72790dc:                 put(UTF8Type.instance.decompose("Aleksey"), keyBuilder(9L, 10L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:             addAll(builder, e.getKey(), e.getValue());
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-except-test", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         // test whole words first
1:72790dc:         Assert.assertEquals(convert(3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel"))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(3, 4, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Michael"))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(3, 4, 7, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Michael", "Travis"))));
1:72790dc: 
1:72790dc:         // now test prefixes
1:72790dc:         Assert.assertEquals(convert(3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pav"))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(3, 4, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Mic"))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(3, 4, 7, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Micha", "Tr"))));
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testNotEqualsQueryForNumbers() throws Exception
1:72790dc:     {
1:72790dc:         final Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:72790dc:         {{
1:72790dc:                 put(Int32Type.instance.decompose(5),  keyBuilder(1L));
1:72790dc:                 put(Int32Type.instance.decompose(7),  keyBuilder(2L));
1:72790dc:                 put(Int32Type.instance.decompose(1),  keyBuilder(3L));
1:72790dc:                 put(Int32Type.instance.decompose(3),  keyBuilder(1L, 4L));
1:72790dc:                 put(Int32Type.instance.decompose(8),  keyBuilder(8L, 6L));
1:72790dc:                 put(Int32Type.instance.decompose(10), keyBuilder(5L));
1:72790dc:                 put(Int32Type.instance.decompose(6),  keyBuilder(7L));
1:72790dc:                 put(Int32Type.instance.decompose(4),  keyBuilder(9L, 10L));
1:72790dc:                 put(Int32Type.instance.decompose(0),  keyBuilder(11L, 12L, 1L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:72790dc:             addAll(builder, e.getKey(), e.getValue());
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-except-int-test", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         Assert.assertEquals(convert(1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 4, 5, 7, 9, 10, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1, 8))));
1:72790dc:         Assert.assertEquals(convert(1, 2, 4, 5, 7, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1, 8, 4))));
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testRangeQueryWithExclusions() throws Exception
1:72790dc:     {
1:72790dc:         final long lower = 0;
1:72790dc:         final long upper = 100000;
1:72790dc: 
1:7d857b4:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(LongType.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:72790dc:         for (long i = lower; i <= upper; i++)
1:7d857b4:             builder.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-except-long-ranges", "db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:72790dc: 
1:72790dc:         // single exclusion
1:72790dc: 
1:72790dc:         // let's do small range first to figure out if searchPoint works properly
1:72790dc:         validateExclusions(onDisk, lower, 50, Sets.newHashSet(42L));
1:72790dc:         // now let's do whole data set to test SPARSE searching
1:72790dc:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L));
1:72790dc: 
1:72790dc:         // pair of exclusions which would generate a split
1:72790dc: 
1:72790dc:         validateExclusions(onDisk, lower, random.nextInt(400, 800), Sets.newHashSet(42L, 154L));
1:72790dc:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L, 54631L));
1:72790dc: 
1:72790dc:         // 3 exclusions which would generate a split and change bounds
1:72790dc: 
1:72790dc:         validateExclusions(onDisk, lower, random.nextInt(400, 800), Sets.newHashSet(42L, 154L));
1:72790dc:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L, 54631L));
1:72790dc: 
1:72790dc:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L));
1:72790dc:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L, 93L));
1:72790dc:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L, 93L, 205L));
1:72790dc: 
1:72790dc:         Set<Long> exclusions = Sets.newHashSet(3L, 12L, 13L, 14L, 27L, 54L, 81L, 125L, 384L, 771L, 1054L, 2048L, 78834L);
1:72790dc: 
1:72790dc:         // test that exclusions are properly bound by lower/upper of the expression
1:72790dc:         Assert.assertEquals(392, validateExclusions(onDisk, lower, 400, exclusions, false));
1:72790dc:         Assert.assertEquals(101, validateExclusions(onDisk, lower, 100, Sets.newHashSet(-10L, -5L, -1L), false));
1:72790dc: 
1:72790dc:         validateExclusions(onDisk, lower, upper, exclusions);
1:72790dc: 
1:72790dc:         Assert.assertEquals(100000, convert(onDisk.search(new Expression("", LongType.instance)
1:72790dc:                                                     .add(Operator.NEQ, LongType.instance.decompose(100L)))).size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(49, convert(onDisk.search(new Expression("", LongType.instance)
1:72790dc:                                                     .add(Operator.LT, LongType.instance.decompose(50L))
1:72790dc:                                                     .add(Operator.NEQ, LongType.instance.decompose(10L)))).size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(99998, convert(onDisk.search(new Expression("", LongType.instance)
1:72790dc:                                                     .add(Operator.GT, LongType.instance.decompose(1L))
1:72790dc:                                                     .add(Operator.NEQ, LongType.instance.decompose(20L)))).size());
1:72790dc: 
1:72790dc:         onDisk.close();
1:72790dc:     }
1:72790dc: 
1:72790dc:     private void validateExclusions(OnDiskIndex sa, long lower, long upper, Set<Long> exclusions)
1:72790dc:     {
1:72790dc:         validateExclusions(sa, lower, upper, exclusions, true);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private int validateExclusions(OnDiskIndex sa, long lower, long upper, Set<Long> exclusions, boolean checkCount)
1:72790dc:     {
1:72790dc:         int count = 0;
1:7d857b4:         for (RowKey key : convert(sa.search(rangeWithExclusions(lower, true, upper, true, exclusions))))
1:72790dc:         {
1:7d857b4:             long keyId = LongType.instance.compose(key.decoratedKey.getKey());
1:7d857b4:             Assert.assertFalse("key" + keyId + " is present.", exclusions.contains(keyId));
1:72790dc:             count++;
1:72790dc:         }
1:72790dc: 
1:72790dc:         if (checkCount)
1:72790dc:             Assert.assertEquals(upper - (lower == 0 ? -1 : lower) - exclusions.size(), count);
1:72790dc: 
1:72790dc:         return count;
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testDescriptor() throws Exception
1:72790dc:     {
1:7d857b4:         final Map<ByteBuffer, Pair<RowKey, Long>> data = new HashMap<ByteBuffer, Pair<RowKey, Long>>()
1:72790dc:         {{
1:7d857b4:                 put(Int32Type.instance.decompose(5), Pair.create(new RowKey(keyAt(1L), ck(clusteringOffset(1L)), CLUSTERING_COMPARATOR) , 1L));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder1 = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:7d857b4:         for (Map.Entry<ByteBuffer, Pair<RowKey, Long>> e : data.entrySet())
1:72790dc:         {
1:7d857b4:             DecoratedKey key = e.getValue().left.decoratedKey;
1:72790dc:             Long position = e.getValue().right;
1:72790dc: 
1:7d857b4:             builder1.add(e.getKey(), key, position, clusteringOffset(position));
1:72790dc:         }
1:72790dc: 
1:72790dc:         File index1 = File.createTempFile("on-disk-sa-int", "db");
1:7d857b4: 
1:72790dc:         index1.deleteOnExit();
1:72790dc: 
1:72790dc:         builder1.finish(index1);
1:7d857b4:         OnDiskIndex onDisk1 = new OnDiskIndex(index1, Int32Type.instance, KeyConverter.instance);
1:7d857b4:         ByteBuffer number = Int32Type.instance.decompose(5);
1:7d857b4:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk1.search(expressionFor(Operator.EQ, Int32Type.instance, number))));
1:7d857b4:         Assert.assertEquals(onDisk1.descriptor.version, Descriptor.CURRENT_VERSION);
1:7d857b4:     }
1:7d857b4: 
1:72790dc: 
1:7d857b4:     static final String DATA_DIR = "test/data/legacy-sasi/";
1:7d857b4: 
1:7d857b4:     @Test
1:7d857b4:     public void testLegacyDescriptor() throws Exception
1:7d857b4:     {
1:7d857b4:         final Map<ByteBuffer, Pair<RowKey, Long>> data = new HashMap<ByteBuffer, Pair<RowKey, Long>>()
1:7d857b4:         {{
1:7d857b4:             put(Int32Type.instance.decompose(5), Pair.create(new RowKey(keyAt(1L), ck(KeyOffsets.NO_OFFSET), CLUSTERING_COMPARATOR) , 1L));
1:7d857b4:         }};
1:7d857b4: 
1:7d857b4:         File index2 = new File(DATA_DIR + "on-disk-sa-int2.db");
1:7d857b4:         OnDiskIndex onDisk2 = new OnDiskIndex(index2, Int32Type.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         ByteBuffer number = Int32Type.instance.decompose(5);
1:3928665:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk2.search(expressionFor(Operator.EQ, Int32Type.instance, number))));
1:72790dc: 
1:7d857b4:         Assert.assertEquals(onDisk2.descriptor.version, Descriptor.VERSION_AA);
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSuperBlocks() throws Exception
1:72790dc:     {
1:72790dc:         Map<ByteBuffer, TokenTreeBuilder> terms = new HashMap<>();
1:72790dc:         terms.put(UTF8Type.instance.decompose("1234"), keyBuilder(1L, 2L));
1:72790dc:         terms.put(UTF8Type.instance.decompose("2345"), keyBuilder(3L, 4L));
1:72790dc:         terms.put(UTF8Type.instance.decompose("3456"), keyBuilder(5L, 6L));
1:72790dc:         terms.put(UTF8Type.instance.decompose("4567"), keyBuilder(7L, 8L));
1:72790dc:         terms.put(UTF8Type.instance.decompose("5678"), keyBuilder(9L, 10L));
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:72790dc:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> entry : terms.entrySet())
1:72790dc:             addAll(builder, entry.getKey(), entry.getValue());
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-try-superblocks", ".db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
1:72790dc:         OnDiskIndex.OnDiskSuperBlock superBlock = onDisk.dataLevel.getSuperBlock(0);
1:72790dc:         Iterator<Token> iter = superBlock.iterator();
1:72790dc: 
1:72790dc:         Long lastToken = null;
1:72790dc:         while (iter.hasNext())
1:72790dc:         {
1:72790dc:             Token token = iter.next();
1:72790dc: 
1:72790dc:             if (lastToken != null)
1:72790dc:                 Assert.assertTrue(lastToken.compareTo(token.get()) < 0);
1:72790dc: 
1:72790dc:             lastToken = token.get();
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSuperBlockRetrieval() throws Exception
1:72790dc:     {
1:72790dc:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:72790dc:         for (long i = 0; i < 100000; i++)
1:7d857b4:             builder.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:72790dc: 
1:72790dc:         File index = File.createTempFile("on-disk-sa-multi-superblock-match", ".db");
1:72790dc:         index.deleteOnExit();
1:72790dc: 
1:72790dc:         builder.finish(index);
1:72790dc: 
1:7d857b4:         OnDiskIndex onDiskIndex = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         testSearchRangeWithSuperBlocks(onDiskIndex, 0, 500);
1:72790dc:         testSearchRangeWithSuperBlocks(onDiskIndex, 300, 93456);
1:72790dc:         testSearchRangeWithSuperBlocks(onDiskIndex, 210, 1700);
1:72790dc:         testSearchRangeWithSuperBlocks(onDiskIndex, 530, 3200);
1:72790dc: 
1:72790dc:         Random random = new Random(0xdeadbeef);
1:72790dc:         for (int i = 0; i < 100000; i += random.nextInt(1500)) // random steps with max of 1500 elements
1:72790dc:         {
1:72790dc:             for (int j = 0; j < 3; j++)
1:72790dc:                 testSearchRangeWithSuperBlocks(onDiskIndex, i, ThreadLocalRandom.current().nextInt(i, 100000));
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:7d857b4:     public void putAll(SortedMap<Long, KeyOffsets> offsets, TokenTreeBuilder ttb)
1:72790dc:     {
1:7d857b4:         for (Pair<Long, KeyOffsets> entry : ttb)
1:5c4d5c7:             offsets.put(entry.left, entry.right);
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testCombiningOfThePartitionedSA() throws Exception
1:72790dc:     {
1:72790dc:         OnDiskIndexBuilder builderA = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         OnDiskIndexBuilder builderB = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc: 
1:7d857b4:         TreeMap<Long, TreeMap<Long, KeyOffsets>> expected = new TreeMap<>();
1:72790dc: 
1:72790dc:         for (long i = 0; i <= 100; i++)
1:72790dc:         {
1:7d857b4:             TreeMap<Long, KeyOffsets> offsets = expected.get(i);
1:72790dc:             if (offsets == null)
1:72790dc:                 expected.put(i, (offsets = new TreeMap<>()));
1:72790dc: 
1:7d857b4:             builderA.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:5c4d5c7:             putAll(offsets, keyBuilder(i));
1:72790dc:         }
1:72790dc: 
1:72790dc:         for (long i = 50; i < 100; i++)
1:72790dc:         {
1:7d857b4:             TreeMap<Long, KeyOffsets> offsets = expected.get(i);
1:72790dc:             if (offsets == null)
1:72790dc:                 expected.put(i, (offsets = new TreeMap<>()));
1:72790dc: 
1:72790dc:             long position = 100L + i;
1:7d857b4:             builderB.add(LongType.instance.decompose(i), keyAt(position), position, clusteringOffset(position));
1:5c4d5c7:             putAll(offsets, keyBuilder(100L + i));
1:72790dc:         }
1:72790dc: 
1:72790dc:         File indexA = File.createTempFile("on-disk-sa-partition-a", ".db");
1:72790dc:         indexA.deleteOnExit();
1:72790dc: 
1:72790dc:         File indexB = File.createTempFile("on-disk-sa-partition-b", ".db");
1:72790dc:         indexB.deleteOnExit();
1:72790dc: 
1:72790dc:         builderA.finish(indexA);
1:72790dc:         builderB.finish(indexB);
1:72790dc: 
1:7d857b4:         OnDiskIndex a = new OnDiskIndex(indexA, LongType.instance, KeyConverter.instance);
1:7d857b4:         OnDiskIndex b = new OnDiskIndex(indexB, LongType.instance, KeyConverter.instance);
1:72790dc: 
1:72790dc:         RangeIterator<OnDiskIndex.DataTerm, CombinedTerm> union = OnDiskIndexIterator.union(a, b);
1:72790dc: 
1:7d857b4:         TreeMap<Long, TreeMap<Long, KeyOffsets>> actual = new TreeMap<>();
1:72790dc:         while (union.hasNext())
1:72790dc:         {
1:72790dc:             CombinedTerm term = union.next();
1:72790dc: 
1:72790dc:             Long composedTerm = LongType.instance.compose(term.getTerm());
1:72790dc: 
1:7d857b4:             TreeMap<Long, KeyOffsets> offsets = actual.get(composedTerm);
1:72790dc:             if (offsets == null)
1:72790dc:                 actual.put(composedTerm, (offsets = new TreeMap<>()));
1:72790dc: 
1:5c4d5c7:             putAll(offsets, term.getTokenTreeBuilder());
1:72790dc:         }
1:72790dc: 
1:72790dc:         Assert.assertEquals(actual, expected);
1:72790dc: 
1:72790dc:         File indexC = File.createTempFile("on-disk-sa-partition-final", ".db");
1:72790dc:         indexC.deleteOnExit();
1:72790dc: 
1:72790dc:         OnDiskIndexBuilder combined = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:72790dc:         combined.finish(Pair.create(keyAt(0).getKey(), keyAt(100).getKey()), indexC, new CombinedTermIterator(a, b));
1:72790dc: 
1:7d857b4:         OnDiskIndex c = new OnDiskIndex(indexC, LongType.instance, KeyConverter.instance);
1:72790dc:         union = OnDiskIndexIterator.union(c);
1:72790dc:         actual.clear();
1:72790dc: 
1:72790dc:         while (union.hasNext())
1:72790dc:         {
1:72790dc:             CombinedTerm term = union.next();
1:72790dc: 
1:72790dc:             Long composedTerm = LongType.instance.compose(term.getTerm());
1:72790dc: 
1:7d857b4:             TreeMap<Long, KeyOffsets> offsets = actual.get(composedTerm);
1:72790dc:             if (offsets == null)
1:72790dc:                 actual.put(composedTerm, (offsets = new TreeMap<>()));
1:72790dc: 
1:5c4d5c7:             putAll(offsets, term.getTokenTreeBuilder());
1:72790dc:         }
1:72790dc: 
1:72790dc:         Assert.assertEquals(actual, expected);
1:72790dc: 
1:72790dc:         a.close();
1:72790dc:         b.close();
1:72790dc:     }
1:72790dc: 
1:7107646:     @Test
1:7107646:     public void testPrefixSearchWithCONTAINSMode() throws Exception
1:7107646:     {
1:7107646:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:7107646:         {{
1:7107646: 
1:7107646:             put(UTF8Type.instance.decompose("lady gaga"), keyBuilder(1L));
1:7107646: 
1:7107646:             // Partial term for 'lady of bells'
1:7107646:             DataOutputBuffer ladyOfBellsBuffer = new DataOutputBuffer();
1:7107646:             ladyOfBellsBuffer.writeShort(UTF8Type.instance.decompose("lady of bells").remaining() | (1 << OnDiskIndexBuilder.IS_PARTIAL_BIT));
1:7107646:             ladyOfBellsBuffer.write(UTF8Type.instance.decompose("lady of bells"));
1:7107646:             put(ladyOfBellsBuffer.asNewBuffer(), keyBuilder(2L));
1:7107646: 
1:7107646: 
1:7107646:             put(UTF8Type.instance.decompose("lady pank"),  keyBuilder(3L));
1:7107646:         }};
1:7107646: 
1:7107646:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS);
1:7107646:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:7107646:             addAll(builder, e.getKey(), e.getValue());
1:7107646: 
1:7107646:         File index = File.createTempFile("on-disk-sa-prefix-contains-search", "db");
1:7107646:         index.deleteOnExit();
1:7107646: 
1:7107646:         builder.finish(index);
1:7107646: 
1:7d857b4:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
1:7107646: 
1:7107646:         // check that lady% return lady gaga (1) and lady pank (3) but not lady of bells(2)
1:7107646:         Assert.assertEquals(convert(1, 3), convert(onDisk.search(expressionFor("lady", Operator.LIKE_PREFIX))));
1:7107646: 
1:7107646:         onDisk.close();
1:7107646:     }
1:7107646: 
1:72790dc:     private void testSearchRangeWithSuperBlocks(OnDiskIndex onDiskIndex, long start, long end)
1:72790dc:     {
1:72790dc:         RangeIterator<Long, Token> tokens = onDiskIndex.search(expressionFor(start, true, end, false));
1:72790dc: 
1:5a4ff90:         // no results should be produced only if range is empty
1:5a4ff90:         if (tokens == null)
1:5a4ff90:         {
1:5a4ff90:             Assert.assertEquals(0, end - start);
1:5a4ff90:             return;
1:5a4ff90:         }
1:5a4ff90: 
1:72790dc:         int keyCount = 0;
1:72790dc:         Long lastToken = null;
1:72790dc:         while (tokens.hasNext())
1:72790dc:         {
1:72790dc:             Token token = tokens.next();
1:7d857b4:             Iterator<RowKey> keys = token.iterator();
1:72790dc: 
1:72790dc:             // each of the values should have exactly a single key
1:72790dc:             Assert.assertTrue(keys.hasNext());
1:72790dc:             keys.next();
1:72790dc:             Assert.assertFalse(keys.hasNext());
1:72790dc: 
1:72790dc:             // and it's last should always smaller than current
1:72790dc:             if (lastToken != null)
1:7d857b4:                 Assert.assertTrue("last should be less than current", lastToken < token.get());
1:72790dc: 
1:72790dc:             lastToken = token.get();
1:72790dc:             keyCount++;
1:72790dc:         }
1:72790dc: 
1:72790dc:         Assert.assertEquals(end - start, keyCount);
1:72790dc:     }
1:72790dc: 
1:7d857b4:     private static DecoratedKey keyAt(long partitionOffset)
1:72790dc:     {
1:7d857b4:         return KeyConverter.dk(partitionOffset);
1:72790dc:     }
1:72790dc: 
1:7d857b4:     private static Clustering ck(long rowOffset)
1:7d857b4:     {
1:7d857b4:         return KeyConverter.ck(rowOffset);
1:7d857b4:     }
1:7d857b4: 
1:7d857b4:     private TokenTreeBuilder keyBuilder(long... offsets)
1:72790dc:     {
1:5c4d5c7:         TokenTreeBuilder builder = new DynamicTokenTreeBuilder();
1:72790dc: 
1:7d857b4:         for (final long pkOffset : offsets)
1:72790dc:         {
1:7d857b4:             DecoratedKey k = keyAt(pkOffset);
1:7d857b4:             builder.add((Long) k.getToken().getTokenValue(), pkOffset, clusteringOffset(pkOffset));
1:72790dc:         }
1:72790dc: 
1:72790dc:         return builder.finish();
1:72790dc:     }
1:72790dc: 
1:7d857b4:     private static long clusteringOffset(long offset)
1:72790dc:     {
1:7d857b4:         return offset + 100;
1:7d857b4:     }
1:72790dc: 
1:7d857b4:     private TokenTreeBuilder keyBuilder(Pair<Long, Long>... offsets)
1:7d857b4:     {
1:7d857b4:         TokenTreeBuilder builder = new DynamicTokenTreeBuilder();
1:7d857b4: 
1:7d857b4:         for (final Pair<Long,Long> key : offsets)
1:7d857b4:         {
1:7d857b4:             DecoratedKey k = keyAt(key.left);
1:7d857b4:             builder.add((Long) k.getToken().getTokenValue(), key.left, key.right);
1:7d857b4:         }
1:7d857b4: 
1:7d857b4:         return builder.finish();
1:7d857b4:     }
1:7d857b4: 
1:7d857b4:     private static final ClusteringComparator CLUSTERING_COMPARATOR = new ClusteringComparator(BytesType.instance);
1:7d857b4: 
1:7d857b4:     private static Set<RowKey> convert(TokenTreeBuilder offsets)
1:7d857b4:     {
1:7d857b4:         Set<RowKey> result = new HashSet<>();
1:7d857b4: 
1:7d857b4:         Iterator<Pair<Long, KeyOffsets>> offsetIter = offsets.iterator();
1:72790dc:         while (offsetIter.hasNext())
1:72790dc:         {
1:7d857b4:             Pair<Long, KeyOffsets> pair = offsetIter.next();
1:72790dc: 
1:7d857b4:             for (LongObjectCursor<long[]> cursor : pair.right)
1:7d857b4:                 for (long l : cursor.value)
1:7d857b4:                     result.add(new RowKey(keyAt(cursor.key), ck(l), CLUSTERING_COMPARATOR));
1:72790dc:         }
1:72790dc:         return result;
1:72790dc:     }
1:72790dc: 
1:7d857b4:     private static Set<RowKey> convert(long... keyOffsets)
1:72790dc:     {
1:7d857b4:         Set<RowKey> result = new HashSet<>();
1:7d857b4:         for (final long offset : keyOffsets)
1:7d857b4:             result.add(new RowKey(keyAt(offset), ck(clusteringOffset(offset)), CLUSTERING_COMPARATOR));
1:72790dc: 
1:72790dc:         return result;
1:72790dc:     }
1:72790dc: 
1:7d857b4:     private static Set<RowKey> convert(RangeIterator<Long, Token> results)
1:72790dc:     {
1:72790dc:         if (results == null)
1:72790dc:             return Collections.emptySet();
1:72790dc: 
1:7d857b4:         Set<RowKey> keys = new TreeSet<>();
1:72790dc: 
1:72790dc:         while (results.hasNext())
1:7d857b4:             for (RowKey key: results.next())
1:72790dc:                 keys.add(key);
1:72790dc: 
1:72790dc:         return keys;
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionFor(long lower, boolean lowerInclusive, long upper, boolean upperInclusive)
1:72790dc:     {
1:72790dc:         Expression expression = new Expression("", LongType.instance);
1:72790dc:         expression.add(lowerInclusive ? Operator.GTE : Operator.GT, LongType.instance.decompose(lower));
1:72790dc:         expression.add(upperInclusive ? Operator.LTE : Operator.LT, LongType.instance.decompose(upper));
1:72790dc:         return expression;
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionFor(AbstractType<?> validator, ByteBuffer term)
1:72790dc:     {
1:3928665:         return expressionFor(Operator.LIKE_CONTAINS, validator, term);
1:3928665:     }
1:3928665: 
1:3928665:     private static Expression expressionFor(Operator op, AbstractType<?> validator, ByteBuffer term)
1:3928665:     {
1:72790dc:         Expression expression = new Expression("", validator);
1:3928665:         expression.add(op, term);
1:72790dc:         return expression;
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionForNot(AbstractType<?> validator, ByteBuffer lower, ByteBuffer upper, Iterable<ByteBuffer> terms)
1:72790dc:     {
1:72790dc:         Expression expression = new Expression("", validator);
1:72790dc:         expression.setOp(Expression.Op.RANGE);
1:72790dc:         expression.setLower(new Expression.Bound(lower, true));
1:72790dc:         expression.setUpper(new Expression.Bound(upper, true));
1:72790dc:         for (ByteBuffer term : terms)
1:72790dc:             expression.add(Operator.NEQ, term);
1:72790dc:         return expression;
1:72790dc: 
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionForNot(Integer lower, Integer upper, Integer... terms)
1:72790dc:     {
1:72790dc:         return expressionForNot(Int32Type.instance,
1:72790dc:                 Int32Type.instance.decompose(lower),
1:72790dc:                 Int32Type.instance.decompose(upper),
1:72790dc:                 Arrays.asList(terms).stream().map(Int32Type.instance::decompose).collect(Collectors.toList()));
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression rangeWithExclusions(long lower, boolean lowerInclusive, long upper, boolean upperInclusive, Set<Long> exclusions)
1:72790dc:     {
1:72790dc:         Expression expression = expressionFor(lower, lowerInclusive, upper, upperInclusive);
1:72790dc:         for (long e : exclusions)
1:72790dc:             expression.add(Operator.NEQ, LongType.instance.decompose(e));
1:72790dc: 
1:72790dc:         return expression;
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionForNot(String lower, String upper, String... terms)
1:72790dc:     {
1:72790dc:         return expressionForNot(UTF8Type.instance,
1:72790dc:                 UTF8Type.instance.decompose(lower),
1:72790dc:                 UTF8Type.instance.decompose(upper),
1:72790dc:                 Arrays.asList(terms).stream().map(UTF8Type.instance::decompose).collect(Collectors.toList()));
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Expression expressionFor(String term)
1:72790dc:     {
1:2ca2fff:         return expressionFor(term, Operator.LIKE_CONTAINS);
1:72790dc:     }
1:72790dc: 
1:2ca2fff:     private static Expression expressionFor(String term, Operator op)
1:72790dc:     {
1:2ca2fff:         return expressionFor(op, UTF8Type.instance, UTF8Type.instance.decompose(term));
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static void addAll(OnDiskIndexBuilder builder, ByteBuffer term, TokenTreeBuilder tokens)
1:72790dc:     {
1:7d857b4:         for (Pair<Long, KeyOffsets> token : tokens)
1:72790dc:         {
1:7d857b4:             for (LongObjectCursor<long[]> cursor : token.right)
1:7d857b4:                 for (long clusteringOffset : cursor.value)
1:7d857b4:                     builder.add(term, keyAt(cursor.key), cursor.key, clusteringOffset);
1:72790dc:         }
1:72790dc:     }
1:72790dc: }
============================================================================
author:Alex Petrov
-------------------------------------------------------------------------------
commit:7d857b4
/////////////////////////////////////////////////////////////////////////
1: import com.carrotsearch.hppc.cursors.LongObjectCursor;
1: import org.apache.cassandra.db.Clustering;
1: import org.apache.cassandra.db.ClusteringComparator;
1: import org.apache.cassandra.db.marshal.BytesType;
1: import org.apache.cassandra.index.sasi.utils.KeyConverter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             Assert.assertEquals("Key was: " + UTF8Type.instance.compose(e.getKey()),
1:                                 convert(e.getValue()),
1:                                 convert(onDisk.search(expressionFor(UTF8Type.instance, e.getKey()))));
1:         Assert.assertEquals(convert(1L, 4L), convert(onDisk.search(expressionFor("cat"))));
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             iterTest.add(iterCheckNums.get(i), keyAt((long) i), i, i + 5);
1:         onDisk = new OnDiskIndex(iterIndex, Int32Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             builder.add(LongType.instance.decompose(start + i), keyAt(i), i, clusteringOffset(i));
1:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             Set<RowKey> actual = convert(rows);
1:                 Assert.assertTrue("key" + key + " wasn't found", actual.contains(new RowKey(keyAt(key), ck(clusteringOffset(key)), CLUSTERING_COMPARATOR)));
/////////////////////////////////////////////////////////////////////////
1:         Set<RowKey> actual = convert(rows);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(LongType.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:             builder.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:         for (RowKey key : convert(sa.search(rangeWithExclusions(lower, true, upper, true, exclusions))))
1:             long keyId = LongType.instance.compose(key.decoratedKey.getKey());
1:             Assert.assertFalse("key" + keyId + " is present.", exclusions.contains(keyId));
/////////////////////////////////////////////////////////////////////////
1:         final Map<ByteBuffer, Pair<RowKey, Long>> data = new HashMap<ByteBuffer, Pair<RowKey, Long>>()
1:                 put(Int32Type.instance.decompose(5), Pair.create(new RowKey(keyAt(1L), ck(clusteringOffset(1L)), CLUSTERING_COMPARATOR) , 1L));
1:         for (Map.Entry<ByteBuffer, Pair<RowKey, Long>> e : data.entrySet())
1:             DecoratedKey key = e.getValue().left.decoratedKey;
1:             builder1.add(e.getKey(), key, position, clusteringOffset(position));
1: 
1:         OnDiskIndex onDisk1 = new OnDiskIndex(index1, Int32Type.instance, KeyConverter.instance);
1:         ByteBuffer number = Int32Type.instance.decompose(5);
1:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk1.search(expressionFor(Operator.EQ, Int32Type.instance, number))));
1:         Assert.assertEquals(onDisk1.descriptor.version, Descriptor.CURRENT_VERSION);
1:     }
1: 
1:     static final String DATA_DIR = "test/data/legacy-sasi/";
1: 
1:     @Test
1:     public void testLegacyDescriptor() throws Exception
1:     {
1:         final Map<ByteBuffer, Pair<RowKey, Long>> data = new HashMap<ByteBuffer, Pair<RowKey, Long>>()
1:         {{
1:             put(Int32Type.instance.decompose(5), Pair.create(new RowKey(keyAt(1L), ck(KeyOffsets.NO_OFFSET), CLUSTERING_COMPARATOR) , 1L));
1:         }};
1: 
1:         File index2 = new File(DATA_DIR + "on-disk-sa-int2.db");
1:         OnDiskIndex onDisk2 = new OnDiskIndex(index2, Int32Type.instance, KeyConverter.instance);
1:         Assert.assertEquals(onDisk2.descriptor.version, Descriptor.VERSION_AA);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             builder.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:         OnDiskIndex onDiskIndex = new OnDiskIndex(index, LongType.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:     public void putAll(SortedMap<Long, KeyOffsets> offsets, TokenTreeBuilder ttb)
1:         for (Pair<Long, KeyOffsets> entry : ttb)
/////////////////////////////////////////////////////////////////////////
1:         TreeMap<Long, TreeMap<Long, KeyOffsets>> expected = new TreeMap<>();
1:             TreeMap<Long, KeyOffsets> offsets = expected.get(i);
1:             builderA.add(LongType.instance.decompose(i), keyAt(i), i, clusteringOffset(i));
1:             TreeMap<Long, KeyOffsets> offsets = expected.get(i);
1:             builderB.add(LongType.instance.decompose(i), keyAt(position), position, clusteringOffset(position));
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex a = new OnDiskIndex(indexA, LongType.instance, KeyConverter.instance);
1:         OnDiskIndex b = new OnDiskIndex(indexB, LongType.instance, KeyConverter.instance);
1:         TreeMap<Long, TreeMap<Long, KeyOffsets>> actual = new TreeMap<>();
1:             TreeMap<Long, KeyOffsets> offsets = actual.get(composedTerm);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex c = new OnDiskIndex(indexC, LongType.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             TreeMap<Long, KeyOffsets> offsets = actual.get(composedTerm);
/////////////////////////////////////////////////////////////////////////
1:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, KeyConverter.instance);
/////////////////////////////////////////////////////////////////////////
1:             Iterator<RowKey> keys = token.iterator();
/////////////////////////////////////////////////////////////////////////
1:                 Assert.assertTrue("last should be less than current", lastToken < token.get());
/////////////////////////////////////////////////////////////////////////
1:     private static DecoratedKey keyAt(long partitionOffset)
1:         return KeyConverter.dk(partitionOffset);
1:     private static Clustering ck(long rowOffset)
1:     {
1:         return KeyConverter.ck(rowOffset);
1:     }
1: 
1:     private TokenTreeBuilder keyBuilder(long... offsets)
1:         for (final long pkOffset : offsets)
1:             DecoratedKey k = keyAt(pkOffset);
1:             builder.add((Long) k.getToken().getTokenValue(), pkOffset, clusteringOffset(pkOffset));
1:     private static long clusteringOffset(long offset)
1:         return offset + 100;
1:     }
1:     private TokenTreeBuilder keyBuilder(Pair<Long, Long>... offsets)
1:     {
1:         TokenTreeBuilder builder = new DynamicTokenTreeBuilder();
1: 
1:         for (final Pair<Long,Long> key : offsets)
1:         {
1:             DecoratedKey k = keyAt(key.left);
1:             builder.add((Long) k.getToken().getTokenValue(), key.left, key.right);
1:         }
1: 
1:         return builder.finish();
1:     }
1: 
1:     private static final ClusteringComparator CLUSTERING_COMPARATOR = new ClusteringComparator(BytesType.instance);
1: 
1:     private static Set<RowKey> convert(TokenTreeBuilder offsets)
1:     {
1:         Set<RowKey> result = new HashSet<>();
1: 
1:         Iterator<Pair<Long, KeyOffsets>> offsetIter = offsets.iterator();
1:             Pair<Long, KeyOffsets> pair = offsetIter.next();
1:             for (LongObjectCursor<long[]> cursor : pair.right)
1:                 for (long l : cursor.value)
1:                     result.add(new RowKey(keyAt(cursor.key), ck(l), CLUSTERING_COMPARATOR));
1:     private static Set<RowKey> convert(long... keyOffsets)
1:         Set<RowKey> result = new HashSet<>();
1:         for (final long offset : keyOffsets)
1:             result.add(new RowKey(keyAt(offset), ck(clusteringOffset(offset)), CLUSTERING_COMPARATOR));
1:     private static Set<RowKey> convert(RangeIterator<Long, Token> results)
1:         Set<RowKey> keys = new TreeSet<>();
1:             for (RowKey key: results.next())
/////////////////////////////////////////////////////////////////////////
1:         for (Pair<Long, KeyOffsets> token : tokens)
1:             for (LongObjectCursor<long[]> cursor : token.right)
1:                 for (long clusteringOffset : cursor.value)
1:                     builder.add(term, keyAt(cursor.key), cursor.key, clusteringOffset);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.junit.BeforeClass;
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:7107646
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputBuffer;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testPrefixSearchWithCONTAINSMode() throws Exception
1:     {
1:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:         {{
1: 
1:             put(UTF8Type.instance.decompose("lady gaga"), keyBuilder(1L));
1: 
1:             // Partial term for 'lady of bells'
1:             DataOutputBuffer ladyOfBellsBuffer = new DataOutputBuffer();
1:             ladyOfBellsBuffer.writeShort(UTF8Type.instance.decompose("lady of bells").remaining() | (1 << OnDiskIndexBuilder.IS_PARTIAL_BIT));
1:             ladyOfBellsBuffer.write(UTF8Type.instance.decompose("lady of bells"));
1:             put(ladyOfBellsBuffer.asNewBuffer(), keyBuilder(2L));
1: 
1: 
1:             put(UTF8Type.instance.decompose("lady pank"),  keyBuilder(3L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:             addAll(builder, e.getKey(), e.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-prefix-contains-search", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, new KeyConverter());
1: 
1:         // check that lady% return lady gaga (1) and lady pank (3) but not lady of bells(2)
1:         Assert.assertEquals(convert(1, 3), convert(onDisk.search(expressionFor("lady", Operator.LIKE_PREFIX))));
1: 
1:         onDisk.close();
1:     }
1: 
commit:5a4ff90
/////////////////////////////////////////////////////////////////////////
1:         // no results should be produced only if range is empty
1:         if (tokens == null)
1:         {
1:             Assert.assertEquals(0, end - start);
1:             return;
1:         }
1: 
commit:3928665
/////////////////////////////////////////////////////////////////////////
1:             Assert.assertEquals(convert(e.getValue()), convert(onDisk.search(expressionFor(Operator.EQ, Int32Type.instance, e.getKey()))));
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk1.search(expressionFor(Operator.EQ, Int32Type.instance, number))));
1:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk2.search(expressionFor(Operator.EQ, Int32Type.instance, number))));
/////////////////////////////////////////////////////////////////////////
1:         return expressionFor(Operator.LIKE_CONTAINS, validator, term);
1:     }
1: 
1:     private static Expression expressionFor(Operator op, AbstractType<?> validator, ByteBuffer term)
1:     {
1:         expression.add(op, term);
commit:72790dc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.index.sasi.disk;
1: 
1: import java.io.File;
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: import java.util.concurrent.ThreadLocalRandom;
1: import java.util.stream.Collectors;
1: 
1: import org.apache.cassandra.cql3.Operator;
0: import org.apache.cassandra.db.BufferDecoratedKey;
1: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.dht.Murmur3Partitioner;
1: import org.apache.cassandra.index.sasi.plan.Expression;
1: import org.apache.cassandra.index.sasi.utils.CombinedTerm;
1: import org.apache.cassandra.index.sasi.utils.CombinedTermIterator;
1: import org.apache.cassandra.index.sasi.utils.OnDiskIndexIterator;
1: import org.apache.cassandra.index.sasi.utils.RangeIterator;
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.Int32Type;
1: import org.apache.cassandra.db.marshal.LongType;
1: import org.apache.cassandra.db.marshal.UTF8Type;
0: import org.apache.cassandra.utils.MurmurHash;
1: import org.apache.cassandra.utils.Pair;
1: 
0: import com.carrotsearch.hppc.LongSet;
0: import com.carrotsearch.hppc.cursors.LongCursor;
1: 
0: import com.google.common.base.Function;
1: import com.google.common.collect.Iterators;
1: import com.google.common.collect.Sets;
1: 
1: import junit.framework.Assert;
1: import org.junit.Test;
1: 
1: public class OnDiskIndexTest
1: {
1:     @Test
1:     public void testStringSAConstruction() throws Exception
1:     {
1:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:         {{
1:                 put(UTF8Type.instance.decompose("scat"), keyBuilder(1L));
1:                 put(UTF8Type.instance.decompose("mat"),  keyBuilder(2L));
1:                 put(UTF8Type.instance.decompose("fat"),  keyBuilder(3L));
1:                 put(UTF8Type.instance.decompose("cat"),  keyBuilder(1L, 4L));
1:                 put(UTF8Type.instance.decompose("till"), keyBuilder(2L, 6L));
1:                 put(UTF8Type.instance.decompose("bill"), keyBuilder(5L));
1:                 put(UTF8Type.instance.decompose("foo"),  keyBuilder(7L));
1:                 put(UTF8Type.instance.decompose("bar"),  keyBuilder(9L, 10L));
1:                 put(UTF8Type.instance.decompose("michael"), keyBuilder(11L, 12L, 1L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:             addAll(builder, e.getKey(), e.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-string", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, new KeyConverter());
1: 
1:         // first check if we can find exact matches
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:         {
1:             if (UTF8Type.instance.getString(e.getKey()).equals("cat"))
1:                 continue; // cat is embedded into scat, we'll test it in next section
1: 
0:             Assert.assertEquals("Key was: " + UTF8Type.instance.compose(e.getKey()), convert(e.getValue()), convert(onDisk.search(expressionFor(UTF8Type.instance, e.getKey()))));
1:         }
1: 
1:         // check that cat returns positions for scat & cat
0:         Assert.assertEquals(convert(1, 4), convert(onDisk.search(expressionFor("cat"))));
1: 
1:         // random suffix queries
1:         Assert.assertEquals(convert(9, 10), convert(onDisk.search(expressionFor("ar"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4), convert(onDisk.search(expressionFor("at"))));
1:         Assert.assertEquals(convert(1, 11, 12), convert(onDisk.search(expressionFor("mic"))));
1:         Assert.assertEquals(convert(1, 11, 12), convert(onDisk.search(expressionFor("ae"))));
1:         Assert.assertEquals(convert(2, 5, 6), convert(onDisk.search(expressionFor("ll"))));
1:         Assert.assertEquals(convert(1, 2, 5, 6, 11, 12), convert(onDisk.search(expressionFor("l"))));
1:         Assert.assertEquals(convert(7), convert(onDisk.search(expressionFor("oo"))));
1:         Assert.assertEquals(convert(7), convert(onDisk.search(expressionFor("o"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4, 6), convert(onDisk.search(expressionFor("t"))));
1: 
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("hello"))));
1: 
1:         onDisk.close();
1:     }
1: 
1:     @Test
1:     public void testIntegerSAConstruction() throws Exception
1:     {
1:         final Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:         {{
1:                 put(Int32Type.instance.decompose(5),  keyBuilder(1L));
1:                 put(Int32Type.instance.decompose(7),  keyBuilder(2L));
1:                 put(Int32Type.instance.decompose(1),  keyBuilder(3L));
1:                 put(Int32Type.instance.decompose(3),  keyBuilder(1L, 4L));
1:                 put(Int32Type.instance.decompose(8),  keyBuilder(2L, 6L));
1:                 put(Int32Type.instance.decompose(10), keyBuilder(5L));
1:                 put(Int32Type.instance.decompose(6),  keyBuilder(7L));
1:                 put(Int32Type.instance.decompose(4),  keyBuilder(9L, 10L));
1:                 put(Int32Type.instance.decompose(0),  keyBuilder(11L, 12L, 1L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:             addAll(builder, e.getKey(), e.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-int", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, new KeyConverter());
1: 
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:         {
0:             Assert.assertEquals(convert(e.getValue()), convert(onDisk.search(expressionFor(Int32Type.instance, e.getKey()))));
1:         }
1: 
1:         List<ByteBuffer> sortedNumbers = new ArrayList<ByteBuffer>()
1:         {{
1:             addAll(data.keySet().stream().collect(Collectors.toList()));
1:         }};
1: 
1:         Collections.sort(sortedNumbers, Int32Type.instance::compare);
1: 
1:         // test full iteration
1:         int idx = 0;
1:         for (OnDiskIndex.DataTerm term : onDisk)
1:         {
1:             ByteBuffer number = sortedNumbers.get(idx++);
1:             Assert.assertEquals(number, term.getTerm());
1:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:         }
1: 
1:         // test partial iteration (descending)
1:         idx = 3; // start from the 3rd element
1:         Iterator<OnDiskIndex.DataTerm> partialIter = onDisk.iteratorAt(sortedNumbers.get(idx), OnDiskIndex.IteratorOrder.DESC, true);
1:         while (partialIter.hasNext())
1:         {
1:             OnDiskIndex.DataTerm term = partialIter.next();
1:             ByteBuffer number = sortedNumbers.get(idx++);
1: 
1:             Assert.assertEquals(number, term.getTerm());
1:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:         }
1: 
1:         idx = 3; // start from the 3rd element exclusive
1:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx++), OnDiskIndex.IteratorOrder.DESC, false);
1:         while (partialIter.hasNext())
1:         {
1:             OnDiskIndex.DataTerm term = partialIter.next();
1:             ByteBuffer number = sortedNumbers.get(idx++);
1: 
1:             Assert.assertEquals(number, term.getTerm());
1:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:         }
1: 
1:         // test partial iteration (ascending)
1:         idx = 6; // start from the 6rd element
1:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx), OnDiskIndex.IteratorOrder.ASC, true);
1:         while (partialIter.hasNext())
1:         {
1:             OnDiskIndex.DataTerm term = partialIter.next();
1:             ByteBuffer number = sortedNumbers.get(idx--);
1: 
1:             Assert.assertEquals(number, term.getTerm());
1:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:         }
1: 
1:         idx = 6; // start from the 6rd element exclusive
1:         partialIter = onDisk.iteratorAt(sortedNumbers.get(idx--), OnDiskIndex.IteratorOrder.ASC, false);
1:         while (partialIter.hasNext())
1:         {
1:             OnDiskIndex.DataTerm term = partialIter.next();
1:             ByteBuffer number = sortedNumbers.get(idx--);
1: 
1:             Assert.assertEquals(number, term.getTerm());
1:             Assert.assertEquals(convert(data.get(number)), convert(term.getTokens()));
1:         }
1: 
1:         onDisk.close();
1: 
1:         List<ByteBuffer> iterCheckNums = new ArrayList<ByteBuffer>()
1:         {{
1:             add(Int32Type.instance.decompose(3));
1:             add(Int32Type.instance.decompose(9));
1:             add(Int32Type.instance.decompose(14));
1:             add(Int32Type.instance.decompose(42));
1:         }};
1: 
1:         OnDiskIndexBuilder iterTest = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         for (int i = 0; i < iterCheckNums.size(); i++)
0:             iterTest.add(iterCheckNums.get(i), keyAt((long) i), i);
1: 
1:         File iterIndex = File.createTempFile("sa-iter", ".db");
1:         iterIndex.deleteOnExit();
1: 
1:         iterTest.finish(iterIndex);
1: 
0:         onDisk = new OnDiskIndex(iterIndex, Int32Type.instance, new KeyConverter());
1: 
1:         ByteBuffer number = Int32Type.instance.decompose(1);
1:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1: 
1:         number = Int32Type.instance.decompose(44);
1:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:         Assert.assertEquals(4, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:         Assert.assertEquals(0, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1: 
1:         number = Int32Type.instance.decompose(20);
1:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1: 
1:         number = Int32Type.instance.decompose(5);
1:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:         Assert.assertEquals(1, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:         Assert.assertEquals(3, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1: 
1:         number = Int32Type.instance.decompose(10);
1:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, false)));
1:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.ASC, true)));
1:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, false)));
1:         Assert.assertEquals(2, Iterators.size(onDisk.iteratorAt(number, OnDiskIndex.IteratorOrder.DESC, true)));
1: 
1:         onDisk.close();
1:     }
1: 
1:     @Test
1:     public void testMultiSuffixMatches() throws Exception
1:     {
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.CONTAINS)
1:         {{
1:                 addAll(this, UTF8Type.instance.decompose("Eliza"), keyBuilder(1L, 2L));
1:                 addAll(this, UTF8Type.instance.decompose("Elizabeth"), keyBuilder(3L, 4L));
1:                 addAll(this, UTF8Type.instance.decompose("Aliza"), keyBuilder(5L, 6L));
1:                 addAll(this, UTF8Type.instance.decompose("Taylor"), keyBuilder(7L, 8L));
1:                 addAll(this, UTF8Type.instance.decompose("Pavel"), keyBuilder(9L, 10L));
1:         }};
1: 
1:         File index = File.createTempFile("on-disk-sa-multi-suffix-match", ".db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, new KeyConverter());
1: 
1:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6), convert(onDisk.search(expressionFor("liz"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionFor("a"))));
1:         Assert.assertEquals(convert(5, 6), convert(onDisk.search(expressionFor("A"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4), convert(onDisk.search(expressionFor("E"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionFor("l"))));
1:         Assert.assertEquals(convert(3, 4), convert(onDisk.search(expressionFor("bet"))));
1:         Assert.assertEquals(convert(3, 4, 9, 10), convert(onDisk.search(expressionFor("e"))));
1:         Assert.assertEquals(convert(7, 8), convert(onDisk.search(expressionFor("yl"))));
1:         Assert.assertEquals(convert(7, 8), convert(onDisk.search(expressionFor("T"))));
1:         Assert.assertEquals(convert(1, 2, 3, 4, 5, 6), convert(onDisk.search(expressionFor("za"))));
1:         Assert.assertEquals(convert(3, 4), convert(onDisk.search(expressionFor("ab"))));
1: 
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Pi"))));
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("ethz"))));
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("liw"))));
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Taw"))));
1:         Assert.assertEquals(Collections.<DecoratedKey>emptySet(), convert(onDisk.search(expressionFor("Av"))));
1: 
1:         onDisk.close();
1:     }
1: 
1:     @Test
1:     public void testSparseMode() throws Exception
1:     {
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1: 
1:         final long start = System.currentTimeMillis();
1:         final int numIterations = 100000;
1: 
1:         for (long i = 0; i < numIterations; i++)
0:             builder.add(LongType.instance.decompose(start + i), keyAt(i), i);
1: 
1:         File index = File.createTempFile("on-disk-sa-sparse", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, new KeyConverter());
1: 
1:         ThreadLocalRandom random = ThreadLocalRandom.current();
1: 
1:         for (long step = start; step < (start + numIterations); step += 1000)
1:         {
1:             boolean lowerInclusive = random.nextBoolean();
1:             boolean upperInclusive = random.nextBoolean();
1: 
1:             long limit = random.nextLong(step, start + numIterations);
1:             RangeIterator<Long, Token> rows = onDisk.search(expressionFor(step, lowerInclusive, limit, upperInclusive));
1: 
1:             long lowerKey = step - start;
1:             long upperKey = lowerKey + (limit - step);
1: 
1:             if (!lowerInclusive)
1:                 lowerKey += 1;
1: 
1:             if (upperInclusive)
1:                 upperKey += 1;
1: 
0:             Set<DecoratedKey> actual = convert(rows);
1:             for (long key = lowerKey; key < upperKey; key++)
0:                 Assert.assertTrue("key" + key + " wasn't found", actual.contains(keyAt(key)));
1: 
1:             Assert.assertEquals((upperKey - lowerKey), actual.size());
1:         }
1: 
1:         // let's also explicitly test whole range search
1:         RangeIterator<Long, Token> rows = onDisk.search(expressionFor(start, true, start + numIterations, true));
1: 
0:         Set<DecoratedKey> actual = convert(rows);
1:         Assert.assertEquals(numIterations, actual.size());
1:     }
1: 
1:     @Test
1:     public void testNotEqualsQueryForStrings() throws Exception
1:     {
1:         Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:         {{
1:                 put(UTF8Type.instance.decompose("Pavel"),   keyBuilder(1L, 2L));
1:                 put(UTF8Type.instance.decompose("Jason"),   keyBuilder(3L));
1:                 put(UTF8Type.instance.decompose("Jordan"),  keyBuilder(4L));
1:                 put(UTF8Type.instance.decompose("Michael"), keyBuilder(5L, 6L));
1:                 put(UTF8Type.instance.decompose("Vijay"),   keyBuilder(7L));
1:                 put(UTF8Type.instance.decompose("Travis"),  keyBuilder(8L));
1:                 put(UTF8Type.instance.decompose("Aleksey"), keyBuilder(9L, 10L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, UTF8Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:             addAll(builder, e.getKey(), e.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-except-test", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, UTF8Type.instance, new KeyConverter());
1: 
1:         // test whole words first
1:         Assert.assertEquals(convert(3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel"))));
1: 
1:         Assert.assertEquals(convert(3, 4, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Michael"))));
1: 
1:         Assert.assertEquals(convert(3, 4, 7, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Michael", "Travis"))));
1: 
1:         // now test prefixes
1:         Assert.assertEquals(convert(3, 4, 5, 6, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pav"))));
1: 
1:         Assert.assertEquals(convert(3, 4, 7, 8, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Mic"))));
1: 
1:         Assert.assertEquals(convert(3, 4, 7, 9, 10), convert(onDisk.search(expressionForNot("Aleksey", "Vijay", "Pavel", "Micha", "Tr"))));
1: 
1:         onDisk.close();
1:     }
1: 
1:     @Test
1:     public void testNotEqualsQueryForNumbers() throws Exception
1:     {
1:         final Map<ByteBuffer, TokenTreeBuilder> data = new HashMap<ByteBuffer, TokenTreeBuilder>()
1:         {{
1:                 put(Int32Type.instance.decompose(5),  keyBuilder(1L));
1:                 put(Int32Type.instance.decompose(7),  keyBuilder(2L));
1:                 put(Int32Type.instance.decompose(1),  keyBuilder(3L));
1:                 put(Int32Type.instance.decompose(3),  keyBuilder(1L, 4L));
1:                 put(Int32Type.instance.decompose(8),  keyBuilder(8L, 6L));
1:                 put(Int32Type.instance.decompose(10), keyBuilder(5L));
1:                 put(Int32Type.instance.decompose(6),  keyBuilder(7L));
1:                 put(Int32Type.instance.decompose(4),  keyBuilder(9L, 10L));
1:                 put(Int32Type.instance.decompose(0),  keyBuilder(11L, 12L, 1L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> e : data.entrySet())
1:             addAll(builder, e.getKey(), e.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-except-int-test", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, new KeyConverter());
1: 
1:         Assert.assertEquals(convert(1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1))));
1:         Assert.assertEquals(convert(1, 2, 4, 5, 7, 9, 10, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1, 8))));
1:         Assert.assertEquals(convert(1, 2, 4, 5, 7, 11, 12), convert(onDisk.search(expressionForNot(0, 10, 1, 8, 4))));
1: 
1:         onDisk.close();
1:     }
1: 
1:     @Test
1:     public void testRangeQueryWithExclusions() throws Exception
1:     {
1:         final long lower = 0;
1:         final long upper = 100000;
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:         for (long i = lower; i <= upper; i++)
0:             builder.add(LongType.instance.decompose(i), keyAt(i), i);
1: 
1:         File index = File.createTempFile("on-disk-sa-except-long-ranges", "db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, LongType.instance, new KeyConverter());
1: 
1:         ThreadLocalRandom random = ThreadLocalRandom.current();
1: 
1:         // single exclusion
1: 
1:         // let's do small range first to figure out if searchPoint works properly
1:         validateExclusions(onDisk, lower, 50, Sets.newHashSet(42L));
1:         // now let's do whole data set to test SPARSE searching
1:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L));
1: 
1:         // pair of exclusions which would generate a split
1: 
1:         validateExclusions(onDisk, lower, random.nextInt(400, 800), Sets.newHashSet(42L, 154L));
1:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L, 54631L));
1: 
1:         // 3 exclusions which would generate a split and change bounds
1: 
1:         validateExclusions(onDisk, lower, random.nextInt(400, 800), Sets.newHashSet(42L, 154L));
1:         validateExclusions(onDisk, lower, upper, Sets.newHashSet(31337L, 54631L));
1: 
1:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L));
1:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L, 93L));
1:         validateExclusions(onDisk, lower, random.nextLong(400, upper), Sets.newHashSet(42L, 55L, 93L, 205L));
1: 
1:         Set<Long> exclusions = Sets.newHashSet(3L, 12L, 13L, 14L, 27L, 54L, 81L, 125L, 384L, 771L, 1054L, 2048L, 78834L);
1: 
1:         // test that exclusions are properly bound by lower/upper of the expression
1:         Assert.assertEquals(392, validateExclusions(onDisk, lower, 400, exclusions, false));
1:         Assert.assertEquals(101, validateExclusions(onDisk, lower, 100, Sets.newHashSet(-10L, -5L, -1L), false));
1: 
1:         validateExclusions(onDisk, lower, upper, exclusions);
1: 
1:         Assert.assertEquals(100000, convert(onDisk.search(new Expression("", LongType.instance)
1:                                                     .add(Operator.NEQ, LongType.instance.decompose(100L)))).size());
1: 
1:         Assert.assertEquals(49, convert(onDisk.search(new Expression("", LongType.instance)
1:                                                     .add(Operator.LT, LongType.instance.decompose(50L))
1:                                                     .add(Operator.NEQ, LongType.instance.decompose(10L)))).size());
1: 
1:         Assert.assertEquals(99998, convert(onDisk.search(new Expression("", LongType.instance)
1:                                                     .add(Operator.GT, LongType.instance.decompose(1L))
1:                                                     .add(Operator.NEQ, LongType.instance.decompose(20L)))).size());
1: 
1:         onDisk.close();
1:     }
1: 
1:     private void validateExclusions(OnDiskIndex sa, long lower, long upper, Set<Long> exclusions)
1:     {
1:         validateExclusions(sa, lower, upper, exclusions, true);
1:     }
1: 
1:     private int validateExclusions(OnDiskIndex sa, long lower, long upper, Set<Long> exclusions, boolean checkCount)
1:     {
1:         int count = 0;
0:         for (DecoratedKey key : convert(sa.search(rangeWithExclusions(lower, true, upper, true, exclusions))))
1:         {
0:             String keyId = UTF8Type.instance.getString(key.getKey()).split("key")[1];
0:             Assert.assertFalse("key" + keyId + " is present.", exclusions.contains(Long.valueOf(keyId)));
1:             count++;
1:         }
1: 
1:         if (checkCount)
1:             Assert.assertEquals(upper - (lower == 0 ? -1 : lower) - exclusions.size(), count);
1: 
1:         return count;
1:     }
1: 
1:     @Test
1:     public void testDescriptor() throws Exception
1:     {
0:         final Map<ByteBuffer, Pair<DecoratedKey, Long>> data = new HashMap<ByteBuffer, Pair<DecoratedKey, Long>>()
1:         {{
0:                 put(Int32Type.instance.decompose(5), Pair.create(keyAt(1L), 1L));
1:         }};
1: 
1:         OnDiskIndexBuilder builder1 = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
0:         OnDiskIndexBuilder builder2 = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.PREFIX);
0:         for (Map.Entry<ByteBuffer, Pair<DecoratedKey, Long>> e : data.entrySet())
1:         {
0:             DecoratedKey key = e.getValue().left;
1:             Long position = e.getValue().right;
1: 
0:             builder1.add(e.getKey(), key, position);
0:             builder2.add(e.getKey(), key, position);
1:         }
1: 
1:         File index1 = File.createTempFile("on-disk-sa-int", "db");
0:         File index2 = File.createTempFile("on-disk-sa-int2", "db");
1:         index1.deleteOnExit();
0:         index2.deleteOnExit();
1: 
1:         builder1.finish(index1);
0:         builder2.finish(new Descriptor(Descriptor.VERSION_AA), index2);
1: 
0:         OnDiskIndex onDisk1 = new OnDiskIndex(index1, Int32Type.instance, new KeyConverter());
0:         OnDiskIndex onDisk2 = new OnDiskIndex(index2, Int32Type.instance, new KeyConverter());
1: 
1:         ByteBuffer number = Int32Type.instance.decompose(5);
1: 
0:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk1.search(expressionFor(Int32Type.instance, number))));
0:         Assert.assertEquals(Collections.singleton(data.get(number).left), convert(onDisk2.search(expressionFor(Int32Type.instance, number))));
1: 
0:         Assert.assertEquals(onDisk1.descriptor.version.version, Descriptor.CURRENT_VERSION);
0:         Assert.assertEquals(onDisk2.descriptor.version.version, Descriptor.VERSION_AA);
1:     }
1: 
1:     @Test
1:     public void testSuperBlocks() throws Exception
1:     {
1:         Map<ByteBuffer, TokenTreeBuilder> terms = new HashMap<>();
1:         terms.put(UTF8Type.instance.decompose("1234"), keyBuilder(1L, 2L));
1:         terms.put(UTF8Type.instance.decompose("2345"), keyBuilder(3L, 4L));
1:         terms.put(UTF8Type.instance.decompose("3456"), keyBuilder(5L, 6L));
1:         terms.put(UTF8Type.instance.decompose("4567"), keyBuilder(7L, 8L));
1:         terms.put(UTF8Type.instance.decompose("5678"), keyBuilder(9L, 10L));
1: 
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, Int32Type.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:         for (Map.Entry<ByteBuffer, TokenTreeBuilder> entry : terms.entrySet())
1:             addAll(builder, entry.getKey(), entry.getValue());
1: 
1:         File index = File.createTempFile("on-disk-sa-try-superblocks", ".db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDisk = new OnDiskIndex(index, Int32Type.instance, new KeyConverter());
1:         OnDiskIndex.OnDiskSuperBlock superBlock = onDisk.dataLevel.getSuperBlock(0);
1:         Iterator<Token> iter = superBlock.iterator();
1: 
1:         Long lastToken = null;
1:         while (iter.hasNext())
1:         {
1:             Token token = iter.next();
1: 
1:             if (lastToken != null)
1:                 Assert.assertTrue(lastToken.compareTo(token.get()) < 0);
1: 
1:             lastToken = token.get();
1:         }
1:     }
1: 
1:     @Test
1:     public void testSuperBlockRetrieval() throws Exception
1:     {
1:         OnDiskIndexBuilder builder = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.SPARSE);
1:         for (long i = 0; i < 100000; i++)
0:             builder.add(LongType.instance.decompose(i), keyAt(i), i);
1: 
1:         File index = File.createTempFile("on-disk-sa-multi-superblock-match", ".db");
1:         index.deleteOnExit();
1: 
1:         builder.finish(index);
1: 
0:         OnDiskIndex onDiskIndex = new OnDiskIndex(index, LongType.instance, new KeyConverter());
1: 
1:         testSearchRangeWithSuperBlocks(onDiskIndex, 0, 500);
1:         testSearchRangeWithSuperBlocks(onDiskIndex, 300, 93456);
1:         testSearchRangeWithSuperBlocks(onDiskIndex, 210, 1700);
1:         testSearchRangeWithSuperBlocks(onDiskIndex, 530, 3200);
1: 
1:         Random random = new Random(0xdeadbeef);
1:         for (int i = 0; i < 100000; i += random.nextInt(1500)) // random steps with max of 1500 elements
1:         {
1:             for (int j = 0; j < 3; j++)
1:                 testSearchRangeWithSuperBlocks(onDiskIndex, i, ThreadLocalRandom.current().nextInt(i, 100000));
1:         }
1:     }
1: 
1:     @Test
1:     public void testCombiningOfThePartitionedSA() throws Exception
1:     {
1:         OnDiskIndexBuilder builderA = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         OnDiskIndexBuilder builderB = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1: 
0:         TreeMap<Long, TreeMap<Long, LongSet>> expected = new TreeMap<>();
1: 
1:         for (long i = 0; i <= 100; i++)
1:         {
0:             TreeMap<Long, LongSet> offsets = expected.get(i);
1:             if (offsets == null)
1:                 expected.put(i, (offsets = new TreeMap<>()));
1: 
0:             builderA.add(LongType.instance.decompose(i), keyAt(i), i);
0:             offsets.putAll(keyBuilder(i).getTokens());
1:         }
1: 
1:         for (long i = 50; i < 100; i++)
1:         {
0:             TreeMap<Long, LongSet> offsets = expected.get(i);
1:             if (offsets == null)
1:                 expected.put(i, (offsets = new TreeMap<>()));
1: 
1:             long position = 100L + i;
0:             builderB.add(LongType.instance.decompose(i), keyAt(position), position);
0:             offsets.putAll(keyBuilder(100L + i).getTokens());
1:         }
1: 
1:         File indexA = File.createTempFile("on-disk-sa-partition-a", ".db");
1:         indexA.deleteOnExit();
1: 
1:         File indexB = File.createTempFile("on-disk-sa-partition-b", ".db");
1:         indexB.deleteOnExit();
1: 
1:         builderA.finish(indexA);
1:         builderB.finish(indexB);
1: 
0:         OnDiskIndex a = new OnDiskIndex(indexA, LongType.instance, new KeyConverter());
0:         OnDiskIndex b = new OnDiskIndex(indexB, LongType.instance, new KeyConverter());
1: 
1:         RangeIterator<OnDiskIndex.DataTerm, CombinedTerm> union = OnDiskIndexIterator.union(a, b);
1: 
0:         TreeMap<Long, TreeMap<Long, LongSet>> actual = new TreeMap<>();
1:         while (union.hasNext())
1:         {
1:             CombinedTerm term = union.next();
1: 
1:             Long composedTerm = LongType.instance.compose(term.getTerm());
1: 
0:             TreeMap<Long, LongSet> offsets = actual.get(composedTerm);
1:             if (offsets == null)
1:                 actual.put(composedTerm, (offsets = new TreeMap<>()));
1: 
0:             offsets.putAll(term.getTokens());
1:         }
1: 
1:         Assert.assertEquals(actual, expected);
1: 
1:         File indexC = File.createTempFile("on-disk-sa-partition-final", ".db");
1:         indexC.deleteOnExit();
1: 
1:         OnDiskIndexBuilder combined = new OnDiskIndexBuilder(UTF8Type.instance, LongType.instance, OnDiskIndexBuilder.Mode.PREFIX);
1:         combined.finish(Pair.create(keyAt(0).getKey(), keyAt(100).getKey()), indexC, new CombinedTermIterator(a, b));
1: 
0:         OnDiskIndex c = new OnDiskIndex(indexC, LongType.instance, new KeyConverter());
1:         union = OnDiskIndexIterator.union(c);
1:         actual.clear();
1: 
1:         while (union.hasNext())
1:         {
1:             CombinedTerm term = union.next();
1: 
1:             Long composedTerm = LongType.instance.compose(term.getTerm());
1: 
0:             TreeMap<Long, LongSet> offsets = actual.get(composedTerm);
1:             if (offsets == null)
1:                 actual.put(composedTerm, (offsets = new TreeMap<>()));
1: 
0:             offsets.putAll(term.getTokens());
1:         }
1: 
1:         Assert.assertEquals(actual, expected);
1: 
1:         a.close();
1:         b.close();
1:     }
1: 
1:     private void testSearchRangeWithSuperBlocks(OnDiskIndex onDiskIndex, long start, long end)
1:     {
1:         RangeIterator<Long, Token> tokens = onDiskIndex.search(expressionFor(start, true, end, false));
1: 
1:         int keyCount = 0;
1:         Long lastToken = null;
1:         while (tokens.hasNext())
1:         {
1:             Token token = tokens.next();
0:             Iterator<DecoratedKey> keys = token.iterator();
1: 
1:             // each of the values should have exactly a single key
1:             Assert.assertTrue(keys.hasNext());
1:             keys.next();
1:             Assert.assertFalse(keys.hasNext());
1: 
1:             // and it's last should always smaller than current
1:             if (lastToken != null)
0:                 Assert.assertTrue("last should be less than current", lastToken.compareTo(token.get()) < 0);
1: 
1:             lastToken = token.get();
1:             keyCount++;
1:         }
1: 
1:         Assert.assertEquals(end - start, keyCount);
1:     }
1: 
0:     private static DecoratedKey keyAt(long rawKey)
1:     {
0:         ByteBuffer key = ByteBuffer.wrap(("key" + rawKey).getBytes());
0:         return new BufferDecoratedKey(new Murmur3Partitioner.LongToken(MurmurHash.hash2_64(key, key.position(), key.remaining(), 0)), key);
1:     }
1: 
0:     private static TokenTreeBuilder keyBuilder(Long... keys)
1:     {
0:         TokenTreeBuilder builder = new TokenTreeBuilder();
1: 
0:         for (final Long key : keys)
1:         {
0:             DecoratedKey dk = keyAt(key);
0:             builder.add((Long) dk.getToken().getTokenValue(), key);
1:         }
1: 
1:         return builder.finish();
1:     }
1: 
0:     private static Set<DecoratedKey> convert(TokenTreeBuilder offsets)
1:     {
0:         Set<DecoratedKey> result = new HashSet<>();
1: 
0:         Iterator<Pair<Long, LongSet>> offsetIter = offsets.iterator();
1:         while (offsetIter.hasNext())
1:         {
0:             LongSet v = offsetIter.next().right;
1: 
0:             for (LongCursor offset : v)
0:                 result.add(keyAt(offset.value));
1:         }
1:         return result;
1:     }
1: 
0:     private static Set<DecoratedKey> convert(long... keyOffsets)
1:     {
0:         Set<DecoratedKey> result = new HashSet<>();
0:         for (long offset : keyOffsets)
0:             result.add(keyAt(offset));
1: 
1:         return result;
1:     }
1: 
0:     private static Set<DecoratedKey> convert(RangeIterator<Long, Token> results)
1:     {
1:         if (results == null)
1:             return Collections.emptySet();
1: 
0:         Set<DecoratedKey> keys = new TreeSet<>(DecoratedKey.comparator);
1: 
1:         while (results.hasNext())
1:         {
0:             for (DecoratedKey key : results.next())
1:                 keys.add(key);
1:         }
1: 
1:         return keys;
1:     }
1: 
1:     private static Expression expressionFor(long lower, boolean lowerInclusive, long upper, boolean upperInclusive)
1:     {
1:         Expression expression = new Expression("", LongType.instance);
1:         expression.add(lowerInclusive ? Operator.GTE : Operator.GT, LongType.instance.decompose(lower));
1:         expression.add(upperInclusive ? Operator.LTE : Operator.LT, LongType.instance.decompose(upper));
1:         return expression;
1:     }
1: 
1:     private static Expression expressionFor(AbstractType<?> validator, ByteBuffer term)
1:     {
1:         Expression expression = new Expression("", validator);
0:         expression.add(Operator.EQ, term);
1:         return expression;
1:     }
1: 
1:     private static Expression expressionForNot(AbstractType<?> validator, ByteBuffer lower, ByteBuffer upper, Iterable<ByteBuffer> terms)
1:     {
1:         Expression expression = new Expression("", validator);
1:         expression.setOp(Expression.Op.RANGE);
1:         expression.setLower(new Expression.Bound(lower, true));
1:         expression.setUpper(new Expression.Bound(upper, true));
1:         for (ByteBuffer term : terms)
1:             expression.add(Operator.NEQ, term);
1:         return expression;
1: 
1:     }
1: 
1:     private static Expression expressionForNot(Integer lower, Integer upper, Integer... terms)
1:     {
1:         return expressionForNot(Int32Type.instance,
1:                 Int32Type.instance.decompose(lower),
1:                 Int32Type.instance.decompose(upper),
1:                 Arrays.asList(terms).stream().map(Int32Type.instance::decompose).collect(Collectors.toList()));
1:     }
1: 
1:     private static Expression rangeWithExclusions(long lower, boolean lowerInclusive, long upper, boolean upperInclusive, Set<Long> exclusions)
1:     {
1:         Expression expression = expressionFor(lower, lowerInclusive, upper, upperInclusive);
1:         for (long e : exclusions)
1:             expression.add(Operator.NEQ, LongType.instance.decompose(e));
1: 
1:         return expression;
1:     }
1: 
1:     private static Expression expressionForNot(String lower, String upper, String... terms)
1:     {
1:         return expressionForNot(UTF8Type.instance,
1:                 UTF8Type.instance.decompose(lower),
1:                 UTF8Type.instance.decompose(upper),
1:                 Arrays.asList(terms).stream().map(UTF8Type.instance::decompose).collect(Collectors.toList()));
1:     }
1: 
1:     private static Expression expressionFor(String term)
1:     {
0:         return expressionFor(UTF8Type.instance, UTF8Type.instance.decompose(term));
1:     }
1: 
1:     private static void addAll(OnDiskIndexBuilder builder, ByteBuffer term, TokenTreeBuilder tokens)
1:     {
0:         for (Map.Entry<Long, LongSet> token : tokens.getTokens().entrySet())
1:         {
0:             for (long position : token.getValue().toArray())
0:                 builder.add(term, keyAt(position), position);
1:         }
1:     }
1: 
0:     private static class KeyConverter implements Function<Long, DecoratedKey>
1:     {
0:         @Override
0:         public DecoratedKey apply(Long offset)
1:         {
0:             return keyAt(offset);
1:         }
1:     }
1: }
author:Jordan West
-------------------------------------------------------------------------------
commit:2ca2fff
/////////////////////////////////////////////////////////////////////////
1:                 put(UTF8Type.instance.decompose("am"), keyBuilder(15L));
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals(convert(1, 2, 11, 12), convert(onDisk.search(expressionFor("m", Operator.LIKE_PREFIX))));
/////////////////////////////////////////////////////////////////////////
1:         return expressionFor(term, Operator.LIKE_CONTAINS);
0:     }
0: 
1:     private static Expression expressionFor(String term, Operator op)
0:     {
1:         return expressionFor(op, UTF8Type.instance, UTF8Type.instance.decompose(term));
commit:5c4d5c7
/////////////////////////////////////////////////////////////////////////
0:     public void putAll(SortedMap<Long, LongSet> offsets, TokenTreeBuilder ttb)
0:     {
0:         for (Pair<Long, LongSet> entry : ttb)
1:             offsets.put(entry.left, entry.right);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:             putAll(offsets, keyBuilder(i));
/////////////////////////////////////////////////////////////////////////
1:             putAll(offsets, keyBuilder(100L + i));
/////////////////////////////////////////////////////////////////////////
1:             putAll(offsets, term.getTokenTreeBuilder());
/////////////////////////////////////////////////////////////////////////
1:             putAll(offsets, term.getTokenTreeBuilder());
/////////////////////////////////////////////////////////////////////////
1:         TokenTreeBuilder builder = new DynamicTokenTreeBuilder();
/////////////////////////////////////////////////////////////////////////
0:         for (Pair<Long, LongSet> token : tokens)
0:             for (long position : token.right.toArray())
============================================================================