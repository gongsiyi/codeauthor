1:2683806: /*
1:2683806:  * Licensed to the Apache Software Foundation (ASF) under one
1:2683806:  * or more contributor license agreements.  See the NOTICE file
1:2683806:  * distributed with this work for additional information
1:2683806:  * regarding copyright ownership.  The ASF licenses this file
1:2683806:  * to you under the Apache License, Version 2.0 (the
1:2683806:  * "License"); you may not use this file except in compliance
1:2683806:  * with the License.  You may obtain a copy of the License at
1:2683806:  *
1:2683806:  *     http://www.apache.org/licenses/LICENSE-2.0
1:2683806:  *
1:2683806:  * Unless required by applicable law or agreed to in writing, software
1:2683806:  * distributed under the License is distributed on an "AS IS" BASIS,
1:2683806:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2683806:  * See the License for the specific language governing permissions and
1:2683806:  * limitations under the License.
1:2683806:  */
1:2683806: package org.apache.cassandra.db;
1:2683806: 
1:2683806: import java.nio.ByteBuffer;
1:2683806: import java.util.*;
1:2683806: 
1:2683806: import org.apache.cassandra.config.CFMetaData;
1:2683806: import org.apache.cassandra.config.ColumnDefinition;
1:2683806: import org.apache.cassandra.config.Schema;
1:2683806: import org.apache.cassandra.cql3.ColumnIdentifier;
1:2683806: import org.apache.cassandra.db.context.CounterContext;
1:2683806: import org.apache.cassandra.db.partitions.PartitionUpdate;
1:2683806: import org.apache.cassandra.db.rows.BTreeRow;
1:2683806: import org.apache.cassandra.db.rows.BufferCell;
1:2683806: import org.apache.cassandra.db.rows.Cell;
1:2683806: import org.apache.cassandra.db.rows.CellPath;
1:2683806: import org.apache.cassandra.db.rows.Row;
1:2683806: import org.apache.cassandra.db.marshal.*;
1:2683806: import org.apache.cassandra.utils.ByteBufferUtil;
1:2683806: import org.apache.cassandra.utils.CounterId;
1:2683806: import org.apache.cassandra.utils.FBUtilities;
1:2683806: import org.apache.cassandra.utils.UUIDGen;
1:2683806: 
1:2683806: public abstract class SimpleBuilders
1:2683806: {
1:2683806:     private SimpleBuilders()
1:2683806:     {
1:2683806:     }
1:2683806: 
1:2683806:     private static DecoratedKey makePartitonKey(CFMetaData metadata, Object... partitionKey)
1:2683806:     {
1:2683806:         if (partitionKey.length == 1 && partitionKey[0] instanceof DecoratedKey)
1:2683806:             return (DecoratedKey)partitionKey[0];
1:2683806: 
1:2683806:         ByteBuffer key = CFMetaData.serializePartitionKey(metadata.getKeyValidatorAsClusteringComparator().make(partitionKey));
1:2683806:         return metadata.decorateKey(key);
1:2683806:     }
1:2683806: 
1:2683806:     private static Clustering makeClustering(CFMetaData metadata, Object... clusteringColumns)
1:2683806:     {
1:2683806:         if (clusteringColumns.length == 1 && clusteringColumns[0] instanceof Clustering)
1:2683806:             return (Clustering)clusteringColumns[0];
1:2683806: 
1:2683806:         if (clusteringColumns.length == 0)
1:2683806:         {
1:2683806:             // If the table has clustering columns, passing no values is for updating the static values, so check we
1:2683806:             // do have some static columns defined.
1:2683806:             assert metadata.comparator.size() == 0 || !metadata.partitionColumns().statics.isEmpty();
1:2683806:             return metadata.comparator.size() == 0 ? Clustering.EMPTY : Clustering.STATIC_CLUSTERING;
1:2683806:         }
1:2683806:         else
1:2683806:         {
1:2683806:             return metadata.comparator.make(clusteringColumns);
1:2683806:         }
1:2683806:     }
1:2683806: 
1:2683806:     private static class AbstractBuilder<T>
1:2683806:     {
1:2683806:         protected long timestamp = FBUtilities.timestampMicros();
1:2683806:         protected int ttl = 0;
1:2683806:         protected int nowInSec = FBUtilities.nowInSeconds();
1:2683806: 
1:2683806:         protected void copyParams(AbstractBuilder<?> other)
1:2683806:         {
1:2683806:             other.timestamp = timestamp;
1:2683806:             other.ttl = ttl;
1:2683806:             other.nowInSec = nowInSec;
1:2683806:         }
1:2683806: 
1:2683806:         public T timestamp(long timestamp)
1:2683806:         {
1:2683806:             this.timestamp = timestamp;
1:2683806:             return (T)this;
1:2683806:         }
1:2683806: 
1:2683806:         public T ttl(int ttl)
1:2683806:         {
1:2683806:             this.ttl = ttl;
1:2683806:             return (T)this;
1:2683806:         }
1:2683806: 
1:2683806:         public T nowInSec(int nowInSec)
1:2683806:         {
1:2683806:             this.nowInSec = nowInSec;
1:2683806:             return (T)this;
1:2683806:         }
1:2683806:     }
1:2683806: 
1:2683806:     public static class MutationBuilder extends AbstractBuilder<Mutation.SimpleBuilder> implements Mutation.SimpleBuilder
1:2683806:     {
1:2683806:         private final String keyspaceName;
1:2683806:         private final DecoratedKey key;
1:2683806: 
1:2683806:         private final Map<UUID, PartitionUpdateBuilder> updateBuilders = new HashMap<>();
1:2683806: 
1:2683806:         public MutationBuilder(String keyspaceName, DecoratedKey key)
1:2683806:         {
1:2683806:             this.keyspaceName = keyspaceName;
1:2683806:             this.key = key;
1:2683806:         }
1:2683806: 
1:2683806:         public PartitionUpdate.SimpleBuilder update(CFMetaData metadata)
1:2683806:         {
1:2683806:             assert metadata.ksName.equals(keyspaceName);
1:2683806: 
1:2683806:             PartitionUpdateBuilder builder = updateBuilders.get(metadata.cfId);
1:2683806:             if (builder == null)
1:2683806:             {
1:2683806:                 builder = new PartitionUpdateBuilder(metadata, key);
1:2683806:                 updateBuilders.put(metadata.cfId, builder);
1:2683806:             }
1:2683806: 
1:2683806:             copyParams(builder);
1:2683806: 
1:2683806:             return builder;
1:2683806:         }
1:2683806: 
1:2683806:         public PartitionUpdate.SimpleBuilder update(String tableName)
1:2683806:         {
1:2683806:             CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, tableName);
1:2683806:             assert metadata != null : "Unknown table " + tableName + " in keyspace " + keyspaceName;
1:2683806:             return update(metadata);
1:2683806:         }
1:2683806: 
1:2683806:         public Mutation build()
1:2683806:         {
1:2683806:             assert !updateBuilders.isEmpty() : "Cannot create empty mutation";
1:2683806: 
1:2683806:             if (updateBuilders.size() == 1)
1:2683806:                 return new Mutation(updateBuilders.values().iterator().next().build());
1:2683806: 
1:2683806:             Mutation mutation = new Mutation(keyspaceName, key);
1:2683806:             for (PartitionUpdateBuilder builder : updateBuilders.values())
1:2683806:                 mutation.add(builder.build());
1:2683806:             return mutation;
1:2683806:         }
1:2683806:     }
1:2683806: 
1:2683806:     public static class PartitionUpdateBuilder extends AbstractBuilder<PartitionUpdate.SimpleBuilder> implements PartitionUpdate.SimpleBuilder
1:2683806:     {
1:2683806:         private final CFMetaData metadata;
1:2683806:         private final DecoratedKey key;
1:2683806:         private final Map<Clustering, RowBuilder> rowBuilders = new HashMap<>();
1:2683806:         private List<RTBuilder> rangeBuilders = null; // We use that rarely, so create lazily
1:2683806: 
1:2683806:         private DeletionTime partitionDeletion = DeletionTime.LIVE;
1:2683806: 
1:2683806:         public PartitionUpdateBuilder(CFMetaData metadata, Object... partitionKeyValues)
1:2683806:         {
1:2683806:             this.metadata = metadata;
1:2683806:             this.key = makePartitonKey(metadata, partitionKeyValues);
1:2683806:         }
1:2683806: 
1:2683806:         public CFMetaData metadata()
1:2683806:         {
1:2683806:             return metadata;
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder row(Object... clusteringValues)
1:2683806:         {
1:2683806:             Clustering clustering = makeClustering(metadata, clusteringValues);
1:2683806:             RowBuilder builder = rowBuilders.get(clustering);
1:2683806:             if (builder == null)
1:2683806:             {
1:2683806:                 builder = new RowBuilder(metadata, clustering);
1:2683806:                 rowBuilders.put(clustering, builder);
1:2683806:             }
1:2683806: 
1:2683806:             copyParams(builder);
1:2683806: 
1:2683806:             return builder;
1:2683806:         }
1:2683806: 
1:2683806:         public PartitionUpdate.SimpleBuilder delete()
1:2683806:         {
1:2683806:             this.partitionDeletion = new DeletionTime(timestamp, nowInSec);
1:2683806:             return this;
1:2683806:         }
1:2683806: 
1:2683806:         public RangeTombstoneBuilder addRangeTombstone()
1:2683806:         {
1:2683806:             if (rangeBuilders == null)
1:2683806:                 rangeBuilders = new ArrayList<>();
1:2683806: 
1:2683806:             RTBuilder builder = new RTBuilder(metadata.comparator, new DeletionTime(timestamp, nowInSec));
1:2683806:             rangeBuilders.add(builder);
1:2683806:             return builder;
1:2683806:         }
1:2683806: 
1:2683806:         public PartitionUpdate build()
1:2683806:         {
1:2683806:             // Collect all updated columns
1:2683806:             PartitionColumns.Builder columns = PartitionColumns.builder();
1:2683806:             for (RowBuilder builder : rowBuilders.values())
1:2683806:                 columns.addAll(builder.columns());
1:2683806: 
1:2683806:             // Note that rowBuilders.size() could include the static column so could be 1 off the really need capacity
1:2683806:             // of the final PartitionUpdate, but as that's just a sizing hint, we'll live.
1:2683806:             PartitionUpdate update = new PartitionUpdate(metadata, key, columns.build(), rowBuilders.size());
1:2683806: 
1:2683806:             update.addPartitionDeletion(partitionDeletion);
1:2683806:             if (rangeBuilders != null)
1:2683806:             {
1:2683806:                 for (RTBuilder builder : rangeBuilders)
1:2683806:                     update.add(builder.build());
1:2683806:             }
1:2683806: 
1:2683806:             for (RowBuilder builder : rowBuilders.values())
1:2683806:                 update.add(builder.build());
1:2683806: 
1:2683806:             return update;
1:2683806:         }
1:2683806: 
1:2683806:         public Mutation buildAsMutation()
1:2683806:         {
1:2683806:             return new Mutation(build());
1:2683806:         }
1:2683806: 
1:2683806:         private static class RTBuilder implements RangeTombstoneBuilder
1:2683806:         {
1:2683806:             private final ClusteringComparator comparator;
1:2683806:             private final DeletionTime deletionTime;
1:2683806: 
1:2683806:             private Object[] start;
1:2683806:             private Object[] end;
1:2683806: 
1:2683806:             private boolean startInclusive = true;
1:2683806:             private boolean endInclusive = true;
1:2683806: 
1:2683806:             private RTBuilder(ClusteringComparator comparator, DeletionTime deletionTime)
1:2683806:             {
1:2683806:                 this.comparator = comparator;
1:2683806:                 this.deletionTime = deletionTime;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder start(Object... values)
1:2683806:             {
1:2683806:                 this.start = values;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder end(Object... values)
1:2683806:             {
1:2683806:                 this.end = values;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder inclStart()
1:2683806:             {
1:2683806:                 this.startInclusive = true;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder exclStart()
1:2683806:             {
1:2683806:                 this.startInclusive = false;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder inclEnd()
1:2683806:             {
1:2683806:                 this.endInclusive = true;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             public RangeTombstoneBuilder exclEnd()
1:2683806:             {
1:2683806:                 this.endInclusive = false;
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             private RangeTombstone build()
1:2683806:             {
1:2683806:                 ClusteringBound startBound = ClusteringBound.create(comparator, true, startInclusive, start);
1:2683806:                 ClusteringBound endBound = ClusteringBound.create(comparator, false, endInclusive, end);
1:2683806:                 return new RangeTombstone(Slice.make(startBound, endBound), deletionTime);
1:2683806:             }
1:2683806:         }
1:2683806:     }
1:2683806: 
1:2683806:     public static class RowBuilder extends AbstractBuilder<Row.SimpleBuilder> implements Row.SimpleBuilder
1:2683806:     {
1:2683806:         private final CFMetaData metadata;
1:2683806: 
1:2683806:         private final Set<ColumnDefinition> columns = new HashSet<>();
1:2683806:         private final Row.Builder builder;
1:2683806: 
1:2683806:         private boolean initiated;
1:2683806:         private boolean noPrimaryKeyLivenessInfo;
1:2683806: 
1:2683806:         public RowBuilder(CFMetaData metadata, Object... clusteringColumns)
1:2683806:         {
1:2683806:             this.metadata = metadata;
1:2683806:             this.builder = BTreeRow.unsortedBuilder(FBUtilities.nowInSeconds());
1:2683806: 
1:2683806:             this.builder.newRow(makeClustering(metadata, clusteringColumns));
1:2683806:         }
1:2683806: 
1:2683806:         Set<ColumnDefinition> columns()
1:2683806:         {
1:2683806:             return columns;
1:2683806:         }
1:2683806: 
1:2683806:         private void maybeInit()
1:2683806:         {
1:2683806:             // We're working around the fact that Row.Builder requires that addPrimaryKeyLivenessInfo() and
1:2683806:             // addRowDeletion() are called before any cell addition (which is done so the builder can more easily skip
1:2683806:             // shadowed cells).
1:2683806:             if (initiated)
1:2683806:                 return;
1:2683806: 
1:2683806:             // If a CQL table, add the "row marker"
1:2683806:             if (metadata.isCQLTable() && !noPrimaryKeyLivenessInfo)
1:2683806:                 builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(timestamp, ttl, nowInSec));
1:2683806: 
1:2683806:             initiated = true;
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder add(String columnName, Object value)
1:2683806:         {
1:2683806:             return add(columnName, value, true);
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder appendAll(String columnName, Object value)
1:2683806:         {
1:2683806:             return add(columnName, value, false);
1:2683806:         }
1:2683806: 
1:2683806:         private Row.SimpleBuilder add(String columnName, Object value, boolean overwriteForCollection)
1:2683806:         {
1:2683806:             maybeInit();
1:2683806:             ColumnDefinition column = getColumn(columnName);
1:2683806: 
1:2683806:             if (!overwriteForCollection && !(column.type.isMultiCell() && column.type.isCollection()))
1:2683806:                 throw new IllegalArgumentException("appendAll() can only be called on non-frozen colletions");
1:2683806: 
1:2683806:             columns.add(column);
1:2683806: 
1:2683806:             if (!column.type.isMultiCell())
1:2683806:             {
1:2683806:                 builder.addCell(cell(column, toByteBuffer(value, column.type), null));
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             assert column.type instanceof CollectionType : "Collection are the only multi-cell types supported so far";
1:2683806: 
1:2683806:             if (value == null)
1:2683806:             {
1:2683806:                 builder.addComplexDeletion(column, new DeletionTime(timestamp, nowInSec));
1:2683806:                 return this;
1:2683806:             }
1:2683806: 
1:2683806:             // Erase previous entry if any.
1:2683806:             if (overwriteForCollection)
1:2683806:                 builder.addComplexDeletion(column, new DeletionTime(timestamp - 1, nowInSec));
1:2683806:             switch (((CollectionType)column.type).kind)
1:2683806:             {
1:2683806:                 case LIST:
1:2683806:                     ListType lt = (ListType)column.type;
1:2683806:                     assert value instanceof List;
1:2683806:                     for (Object elt : (List)value)
1:2683806:                         builder.addCell(cell(column, toByteBuffer(elt, lt.getElementsType()), CellPath.create(ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes()))));
1:2683806:                     break;
1:2683806:                 case SET:
1:2683806:                     SetType st = (SetType)column.type;
1:2683806:                     assert value instanceof Set;
1:2683806:                     for (Object elt : (Set)value)
1:2683806:                         builder.addCell(cell(column, ByteBufferUtil.EMPTY_BYTE_BUFFER, CellPath.create(toByteBuffer(elt, st.getElementsType()))));
1:2683806:                     break;
1:2683806:                 case MAP:
1:2683806:                     MapType mt = (MapType)column.type;
1:2683806:                     assert value instanceof Map;
1:2683806:                     for (Map.Entry entry : ((Map<?, ?>)value).entrySet())
1:2683806:                         builder.addCell(cell(column,
1:2683806:                                              toByteBuffer(entry.getValue(), mt.getValuesType()),
1:2683806:                                              CellPath.create(toByteBuffer(entry.getKey(), mt.getKeysType()))));
1:2683806:                     break;
1:2683806:                 default:
1:2683806:                     throw new AssertionError();
1:2683806:             }
1:2683806:             return this;
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder delete()
1:2683806:         {
1:2683806:             assert !initiated : "If called, delete() should be called before any other column value addition";
1:2683806:             builder.addRowDeletion(Row.Deletion.regular(new DeletionTime(timestamp, nowInSec)));
1:2683806:             return this;
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder delete(String columnName)
1:2683806:         {
1:2683806:             return add(columnName, null);
1:2683806:         }
1:2683806: 
1:2683806:         public Row.SimpleBuilder noPrimaryKeyLivenessInfo()
1:2683806:         {
1:2683806:             this.noPrimaryKeyLivenessInfo = true;
1:2683806:             return this;
1:2683806:         }
1:2683806: 
1:2683806:         public Row build()
1:2683806:         {
1:2683806:             maybeInit();
1:2683806:             return builder.build();
1:2683806:         }
1:2683806: 
1:2683806:         private ColumnDefinition getColumn(String columnName)
1:2683806:         {
1:2683806:             ColumnDefinition column = metadata.getColumnDefinition(new ColumnIdentifier(columnName, true));
1:2683806:             assert column != null : "Cannot find column " + columnName;
1:2683806:             assert !column.isPrimaryKeyColumn();
1:2683806:             assert !column.isStatic() || builder.clustering() == Clustering.STATIC_CLUSTERING : "Cannot add non-static column to static-row";
1:2683806:             return column;
1:2683806:         }
1:2683806: 
1:2683806:         private Cell cell(ColumnDefinition column, ByteBuffer value, CellPath path)
1:2683806:         {
1:2683806:             if (value == null)
1:2683806:                 return BufferCell.tombstone(column, timestamp, nowInSec, path);
1:2683806: 
1:2683806:             return ttl == LivenessInfo.NO_TTL
1:2683806:                  ? BufferCell.live(column, timestamp, value, path)
1:2683806:                  : BufferCell.expiring(column, timestamp, ttl, nowInSec, value, path);
1:2683806:         }
1:2683806: 
1:2683806:         private ByteBuffer toByteBuffer(Object value, AbstractType<?> type)
1:2683806:         {
1:2683806:             if (value == null)
1:2683806:                 return null;
1:2683806: 
1:2683806:             if (value instanceof ByteBuffer)
1:2683806:                 return (ByteBuffer)value;
1:2683806: 
1:2683806:             if (type.isCounter())
1:2683806:             {
1:2683806:                 // See UpdateParameters.addCounter()
1:2683806:                 assert value instanceof Long : "Attempted to adjust Counter cell with non-long value.";
1:2683806:                 return CounterContext.instance().createGlobal(CounterId.getLocalId(), 1, (Long)value);
1:2683806:             }
1:2683806: 
1:2683806:             return ((AbstractType)type).decompose(value);
1:2683806:         }
1:2683806:     }
1:2683806: }
============================================================================
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:2683806
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.context.CounterContext;
1: import org.apache.cassandra.db.partitions.PartitionUpdate;
1: import org.apache.cassandra.db.rows.BTreeRow;
1: import org.apache.cassandra.db.rows.BufferCell;
1: import org.apache.cassandra.db.rows.Cell;
1: import org.apache.cassandra.db.rows.CellPath;
1: import org.apache.cassandra.db.rows.Row;
1: import org.apache.cassandra.db.marshal.*;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.CounterId;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.UUIDGen;
1: 
1: public abstract class SimpleBuilders
1: {
1:     private SimpleBuilders()
1:     {
1:     }
1: 
1:     private static DecoratedKey makePartitonKey(CFMetaData metadata, Object... partitionKey)
1:     {
1:         if (partitionKey.length == 1 && partitionKey[0] instanceof DecoratedKey)
1:             return (DecoratedKey)partitionKey[0];
1: 
1:         ByteBuffer key = CFMetaData.serializePartitionKey(metadata.getKeyValidatorAsClusteringComparator().make(partitionKey));
1:         return metadata.decorateKey(key);
1:     }
1: 
1:     private static Clustering makeClustering(CFMetaData metadata, Object... clusteringColumns)
1:     {
1:         if (clusteringColumns.length == 1 && clusteringColumns[0] instanceof Clustering)
1:             return (Clustering)clusteringColumns[0];
1: 
1:         if (clusteringColumns.length == 0)
1:         {
1:             // If the table has clustering columns, passing no values is for updating the static values, so check we
1:             // do have some static columns defined.
1:             assert metadata.comparator.size() == 0 || !metadata.partitionColumns().statics.isEmpty();
1:             return metadata.comparator.size() == 0 ? Clustering.EMPTY : Clustering.STATIC_CLUSTERING;
1:         }
1:         else
1:         {
1:             return metadata.comparator.make(clusteringColumns);
1:         }
1:     }
1: 
1:     private static class AbstractBuilder<T>
1:     {
1:         protected long timestamp = FBUtilities.timestampMicros();
1:         protected int ttl = 0;
1:         protected int nowInSec = FBUtilities.nowInSeconds();
1: 
1:         protected void copyParams(AbstractBuilder<?> other)
1:         {
1:             other.timestamp = timestamp;
1:             other.ttl = ttl;
1:             other.nowInSec = nowInSec;
1:         }
1: 
1:         public T timestamp(long timestamp)
1:         {
1:             this.timestamp = timestamp;
1:             return (T)this;
1:         }
1: 
1:         public T ttl(int ttl)
1:         {
1:             this.ttl = ttl;
1:             return (T)this;
1:         }
1: 
1:         public T nowInSec(int nowInSec)
1:         {
1:             this.nowInSec = nowInSec;
1:             return (T)this;
1:         }
1:     }
1: 
1:     public static class MutationBuilder extends AbstractBuilder<Mutation.SimpleBuilder> implements Mutation.SimpleBuilder
1:     {
1:         private final String keyspaceName;
1:         private final DecoratedKey key;
1: 
1:         private final Map<UUID, PartitionUpdateBuilder> updateBuilders = new HashMap<>();
1: 
1:         public MutationBuilder(String keyspaceName, DecoratedKey key)
1:         {
1:             this.keyspaceName = keyspaceName;
1:             this.key = key;
1:         }
1: 
1:         public PartitionUpdate.SimpleBuilder update(CFMetaData metadata)
1:         {
1:             assert metadata.ksName.equals(keyspaceName);
1: 
1:             PartitionUpdateBuilder builder = updateBuilders.get(metadata.cfId);
1:             if (builder == null)
1:             {
1:                 builder = new PartitionUpdateBuilder(metadata, key);
1:                 updateBuilders.put(metadata.cfId, builder);
1:             }
1: 
1:             copyParams(builder);
1: 
1:             return builder;
1:         }
1: 
1:         public PartitionUpdate.SimpleBuilder update(String tableName)
1:         {
1:             CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, tableName);
1:             assert metadata != null : "Unknown table " + tableName + " in keyspace " + keyspaceName;
1:             return update(metadata);
1:         }
1: 
1:         public Mutation build()
1:         {
1:             assert !updateBuilders.isEmpty() : "Cannot create empty mutation";
1: 
1:             if (updateBuilders.size() == 1)
1:                 return new Mutation(updateBuilders.values().iterator().next().build());
1: 
1:             Mutation mutation = new Mutation(keyspaceName, key);
1:             for (PartitionUpdateBuilder builder : updateBuilders.values())
1:                 mutation.add(builder.build());
1:             return mutation;
1:         }
1:     }
1: 
1:     public static class PartitionUpdateBuilder extends AbstractBuilder<PartitionUpdate.SimpleBuilder> implements PartitionUpdate.SimpleBuilder
1:     {
1:         private final CFMetaData metadata;
1:         private final DecoratedKey key;
1:         private final Map<Clustering, RowBuilder> rowBuilders = new HashMap<>();
1:         private List<RTBuilder> rangeBuilders = null; // We use that rarely, so create lazily
1: 
1:         private DeletionTime partitionDeletion = DeletionTime.LIVE;
1: 
1:         public PartitionUpdateBuilder(CFMetaData metadata, Object... partitionKeyValues)
1:         {
1:             this.metadata = metadata;
1:             this.key = makePartitonKey(metadata, partitionKeyValues);
1:         }
1: 
1:         public CFMetaData metadata()
1:         {
1:             return metadata;
1:         }
1: 
1:         public Row.SimpleBuilder row(Object... clusteringValues)
1:         {
1:             Clustering clustering = makeClustering(metadata, clusteringValues);
1:             RowBuilder builder = rowBuilders.get(clustering);
1:             if (builder == null)
1:             {
1:                 builder = new RowBuilder(metadata, clustering);
1:                 rowBuilders.put(clustering, builder);
1:             }
1: 
1:             copyParams(builder);
1: 
1:             return builder;
1:         }
1: 
1:         public PartitionUpdate.SimpleBuilder delete()
1:         {
1:             this.partitionDeletion = new DeletionTime(timestamp, nowInSec);
1:             return this;
1:         }
1: 
1:         public RangeTombstoneBuilder addRangeTombstone()
1:         {
1:             if (rangeBuilders == null)
1:                 rangeBuilders = new ArrayList<>();
1: 
1:             RTBuilder builder = new RTBuilder(metadata.comparator, new DeletionTime(timestamp, nowInSec));
1:             rangeBuilders.add(builder);
1:             return builder;
1:         }
1: 
1:         public PartitionUpdate build()
1:         {
1:             // Collect all updated columns
1:             PartitionColumns.Builder columns = PartitionColumns.builder();
1:             for (RowBuilder builder : rowBuilders.values())
1:                 columns.addAll(builder.columns());
1: 
1:             // Note that rowBuilders.size() could include the static column so could be 1 off the really need capacity
1:             // of the final PartitionUpdate, but as that's just a sizing hint, we'll live.
1:             PartitionUpdate update = new PartitionUpdate(metadata, key, columns.build(), rowBuilders.size());
1: 
1:             update.addPartitionDeletion(partitionDeletion);
1:             if (rangeBuilders != null)
1:             {
1:                 for (RTBuilder builder : rangeBuilders)
1:                     update.add(builder.build());
1:             }
1: 
1:             for (RowBuilder builder : rowBuilders.values())
1:                 update.add(builder.build());
1: 
1:             return update;
1:         }
1: 
1:         public Mutation buildAsMutation()
1:         {
1:             return new Mutation(build());
1:         }
1: 
1:         private static class RTBuilder implements RangeTombstoneBuilder
1:         {
1:             private final ClusteringComparator comparator;
1:             private final DeletionTime deletionTime;
1: 
1:             private Object[] start;
1:             private Object[] end;
1: 
1:             private boolean startInclusive = true;
1:             private boolean endInclusive = true;
1: 
1:             private RTBuilder(ClusteringComparator comparator, DeletionTime deletionTime)
1:             {
1:                 this.comparator = comparator;
1:                 this.deletionTime = deletionTime;
1:             }
1: 
1:             public RangeTombstoneBuilder start(Object... values)
1:             {
1:                 this.start = values;
1:                 return this;
1:             }
1: 
1:             public RangeTombstoneBuilder end(Object... values)
1:             {
1:                 this.end = values;
1:                 return this;
1:             }
1: 
1:             public RangeTombstoneBuilder inclStart()
1:             {
1:                 this.startInclusive = true;
1:                 return this;
1:             }
1: 
1:             public RangeTombstoneBuilder exclStart()
1:             {
1:                 this.startInclusive = false;
1:                 return this;
1:             }
1: 
1:             public RangeTombstoneBuilder inclEnd()
1:             {
1:                 this.endInclusive = true;
1:                 return this;
1:             }
1: 
1:             public RangeTombstoneBuilder exclEnd()
1:             {
1:                 this.endInclusive = false;
1:                 return this;
1:             }
1: 
1:             private RangeTombstone build()
1:             {
1:                 ClusteringBound startBound = ClusteringBound.create(comparator, true, startInclusive, start);
1:                 ClusteringBound endBound = ClusteringBound.create(comparator, false, endInclusive, end);
1:                 return new RangeTombstone(Slice.make(startBound, endBound), deletionTime);
1:             }
1:         }
1:     }
1: 
1:     public static class RowBuilder extends AbstractBuilder<Row.SimpleBuilder> implements Row.SimpleBuilder
1:     {
1:         private final CFMetaData metadata;
1: 
1:         private final Set<ColumnDefinition> columns = new HashSet<>();
1:         private final Row.Builder builder;
1: 
1:         private boolean initiated;
1:         private boolean noPrimaryKeyLivenessInfo;
1: 
1:         public RowBuilder(CFMetaData metadata, Object... clusteringColumns)
1:         {
1:             this.metadata = metadata;
1:             this.builder = BTreeRow.unsortedBuilder(FBUtilities.nowInSeconds());
1: 
1:             this.builder.newRow(makeClustering(metadata, clusteringColumns));
1:         }
1: 
1:         Set<ColumnDefinition> columns()
1:         {
1:             return columns;
1:         }
1: 
1:         private void maybeInit()
1:         {
1:             // We're working around the fact that Row.Builder requires that addPrimaryKeyLivenessInfo() and
1:             // addRowDeletion() are called before any cell addition (which is done so the builder can more easily skip
1:             // shadowed cells).
1:             if (initiated)
1:                 return;
1: 
1:             // If a CQL table, add the "row marker"
1:             if (metadata.isCQLTable() && !noPrimaryKeyLivenessInfo)
1:                 builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(timestamp, ttl, nowInSec));
1: 
1:             initiated = true;
1:         }
1: 
1:         public Row.SimpleBuilder add(String columnName, Object value)
1:         {
1:             return add(columnName, value, true);
1:         }
1: 
1:         public Row.SimpleBuilder appendAll(String columnName, Object value)
1:         {
1:             return add(columnName, value, false);
1:         }
1: 
1:         private Row.SimpleBuilder add(String columnName, Object value, boolean overwriteForCollection)
1:         {
1:             maybeInit();
1:             ColumnDefinition column = getColumn(columnName);
1: 
1:             if (!overwriteForCollection && !(column.type.isMultiCell() && column.type.isCollection()))
1:                 throw new IllegalArgumentException("appendAll() can only be called on non-frozen colletions");
1: 
1:             columns.add(column);
1: 
1:             if (!column.type.isMultiCell())
1:             {
1:                 builder.addCell(cell(column, toByteBuffer(value, column.type), null));
1:                 return this;
1:             }
1: 
1:             assert column.type instanceof CollectionType : "Collection are the only multi-cell types supported so far";
1: 
1:             if (value == null)
1:             {
1:                 builder.addComplexDeletion(column, new DeletionTime(timestamp, nowInSec));
1:                 return this;
1:             }
1: 
1:             // Erase previous entry if any.
1:             if (overwriteForCollection)
1:                 builder.addComplexDeletion(column, new DeletionTime(timestamp - 1, nowInSec));
1:             switch (((CollectionType)column.type).kind)
1:             {
1:                 case LIST:
1:                     ListType lt = (ListType)column.type;
1:                     assert value instanceof List;
1:                     for (Object elt : (List)value)
1:                         builder.addCell(cell(column, toByteBuffer(elt, lt.getElementsType()), CellPath.create(ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes()))));
1:                     break;
1:                 case SET:
1:                     SetType st = (SetType)column.type;
1:                     assert value instanceof Set;
1:                     for (Object elt : (Set)value)
1:                         builder.addCell(cell(column, ByteBufferUtil.EMPTY_BYTE_BUFFER, CellPath.create(toByteBuffer(elt, st.getElementsType()))));
1:                     break;
1:                 case MAP:
1:                     MapType mt = (MapType)column.type;
1:                     assert value instanceof Map;
1:                     for (Map.Entry entry : ((Map<?, ?>)value).entrySet())
1:                         builder.addCell(cell(column,
1:                                              toByteBuffer(entry.getValue(), mt.getValuesType()),
1:                                              CellPath.create(toByteBuffer(entry.getKey(), mt.getKeysType()))));
1:                     break;
1:                 default:
1:                     throw new AssertionError();
1:             }
1:             return this;
1:         }
1: 
1:         public Row.SimpleBuilder delete()
1:         {
1:             assert !initiated : "If called, delete() should be called before any other column value addition";
1:             builder.addRowDeletion(Row.Deletion.regular(new DeletionTime(timestamp, nowInSec)));
1:             return this;
1:         }
1: 
1:         public Row.SimpleBuilder delete(String columnName)
1:         {
1:             return add(columnName, null);
1:         }
1: 
1:         public Row.SimpleBuilder noPrimaryKeyLivenessInfo()
1:         {
1:             this.noPrimaryKeyLivenessInfo = true;
1:             return this;
1:         }
1: 
1:         public Row build()
1:         {
1:             maybeInit();
1:             return builder.build();
1:         }
1: 
1:         private ColumnDefinition getColumn(String columnName)
1:         {
1:             ColumnDefinition column = metadata.getColumnDefinition(new ColumnIdentifier(columnName, true));
1:             assert column != null : "Cannot find column " + columnName;
1:             assert !column.isPrimaryKeyColumn();
1:             assert !column.isStatic() || builder.clustering() == Clustering.STATIC_CLUSTERING : "Cannot add non-static column to static-row";
1:             return column;
1:         }
1: 
1:         private Cell cell(ColumnDefinition column, ByteBuffer value, CellPath path)
1:         {
1:             if (value == null)
1:                 return BufferCell.tombstone(column, timestamp, nowInSec, path);
1: 
1:             return ttl == LivenessInfo.NO_TTL
1:                  ? BufferCell.live(column, timestamp, value, path)
1:                  : BufferCell.expiring(column, timestamp, ttl, nowInSec, value, path);
1:         }
1: 
1:         private ByteBuffer toByteBuffer(Object value, AbstractType<?> type)
1:         {
1:             if (value == null)
1:                 return null;
1: 
1:             if (value instanceof ByteBuffer)
1:                 return (ByteBuffer)value;
1: 
1:             if (type.isCounter())
1:             {
1:                 // See UpdateParameters.addCounter()
1:                 assert value instanceof Long : "Attempted to adjust Counter cell with non-long value.";
1:                 return CounterContext.instance().createGlobal(CounterId.getLocalId(), 1, (Long)value);
1:             }
1: 
1:             return ((AbstractType)type).decompose(value);
1:         }
1:     }
1: }
============================================================================