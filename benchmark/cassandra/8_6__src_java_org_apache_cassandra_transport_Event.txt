1:f199fa3: /*
1:f199fa3:  * Licensed to the Apache Software Foundation (ASF) under one
1:f199fa3:  * or more contributor license agreements.  See the NOTICE file
1:f199fa3:  * distributed with this work for additional information
1:f199fa3:  * regarding copyright ownership.  The ASF licenses this file
1:f199fa3:  * to you under the Apache License, Version 2.0 (the
1:f199fa3:  * "License"); you may not use this file except in compliance
1:f199fa3:  * with the License.  You may obtain a copy of the License at
1:f199fa3:  *
1:f199fa3:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f199fa3:  *
1:f199fa3:  * Unless required by applicable law or agreed to in writing, software
1:f199fa3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f199fa3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f199fa3:  * See the License for the specific language governing permissions and
1:f199fa3:  * limitations under the License.
1:f6217ae:  */
1:f199fa3: package org.apache.cassandra.transport;
10:f199fa3: 
1:f199fa3: import java.net.InetAddress;
1:f199fa3: import java.net.InetSocketAddress;
1:dcc3bb0: import java.util.Iterator;
1:dcc3bb0: import java.util.List;
1:f199fa3: 
1:9872b74: import com.google.common.base.Objects;
1:cbf304e: import io.netty.buffer.ByteBuf;
1:f199fa3: 
1:f199fa3: public abstract class Event
9:f199fa3: {
1:68d2526:     public enum Type
1:68d2526:     {
1:e0adc16:         TOPOLOGY_CHANGE(ProtocolVersion.V3),
1:e0adc16:         STATUS_CHANGE(ProtocolVersion.V3),
1:e0adc16:         SCHEMA_CHANGE(ProtocolVersion.V3),
1:e0adc16:         TRACE_COMPLETE(ProtocolVersion.V4);
1:f6217ae: 
1:e0adc16:         public final ProtocolVersion minimumVersion;
1:f6217ae: 
1:e0adc16:         Type(ProtocolVersion minimumVersion)
1:f6217ae:         {
1:f6217ae:             this.minimumVersion = minimumVersion;
1:f6217ae:         }
1:f6217ae:     }
1:f6cab37: 
1:f199fa3:     public final Type type;
1:f6217ae: 
1:f199fa3:     private Event(Type type)
1:f6217ae:     {
1:f199fa3:         this.type = type;
1:f6217ae:     }
1:f6217ae: 
1:e0adc16:     public static Event deserialize(ByteBuf cb, ProtocolVersion version)
1:f6217ae:     {
1:f6217ae:         Type eventType = CBUtil.readEnumValue(Type.class, cb);
1:e0adc16:         if (eventType.minimumVersion.isGreaterThan(version))
1:f6217ae:             throw new ProtocolException("Event " + eventType.name() + " not valid for protocol version " + version);
1:f6217ae:         switch (eventType)
1:f6217ae:         {
1:f199fa3:             case TOPOLOGY_CHANGE:
1:9872b74:                 return TopologyChange.deserializeEvent(cb, version);
1:f199fa3:             case STATUS_CHANGE:
1:9872b74:                 return StatusChange.deserializeEvent(cb, version);
1:11f7d72:             case SCHEMA_CHANGE:
1:9872b74:                 return SchemaChange.deserializeEvent(cb, version);
1:f6217ae:         }
1:f199fa3:         throw new AssertionError();
1:f6217ae:     }
1:f6217ae: 
1:e0adc16:     public void serialize(ByteBuf dest, ProtocolVersion version)
1:f6217ae:     {
1:e0adc16:         if (type.minimumVersion.isGreaterThan(version))
1:f6217ae:             throw new ProtocolException("Event " + type.name() + " not valid for protocol version " + version);
1:f8be23a:         CBUtil.writeEnumValue(type, dest);
1:9872b74:         serializeEvent(dest, version);
1:f6217ae:     }
1:f6217ae: 
1:e0adc16:     public int serializedSize(ProtocolVersion version)
1:f6217ae:     {
1:9872b74:         return CBUtil.sizeOfEnumValue(type) + eventSerializedSize(version);
1:9872b74:     }
1:f6217ae: 
1:e0adc16:     protected abstract void serializeEvent(ByteBuf dest, ProtocolVersion version);
1:e0adc16:     protected abstract int eventSerializedSize(ProtocolVersion version);
1:f6217ae: 
1:f6cab37:     public static abstract class NodeEvent extends Event
1:f6cab37:     {
1:f6cab37:         public final InetSocketAddress node;
1:f6cab37: 
1:f6cab37:         public InetAddress nodeAddress()
1:f6cab37:         {
1:f6cab37:             return node.getAddress();
1:f6cab37:         }
1:f6cab37: 
1:f6cab37:         private NodeEvent(Type type, InetSocketAddress node)
1:f6cab37:         {
1:f6cab37:             super(type);
1:f6cab37:             this.node = node;
1:f6cab37:         }
1:f6cab37:     }
1:f6cab37: 
1:f6cab37:     public static class TopologyChange extends NodeEvent
1:9872b74:     {
1:63a8bfe:         public enum Change { NEW_NODE, REMOVED_NODE, MOVED_NODE }
1:9872b74: 
1:f199fa3:         public final Change change;
1:9872b74: 
1:f199fa3:         private TopologyChange(Change change, InetSocketAddress node)
1:f8be23a:         {
1:f6cab37:             super(Type.TOPOLOGY_CHANGE, node);
1:f199fa3:             this.change = change;
1:f8be23a:         }
1:f8be23a: 
1:f199fa3:         public static TopologyChange newNode(InetAddress host, int port)
1:f199fa3:         {
1:f199fa3:             return new TopologyChange(Change.NEW_NODE, new InetSocketAddress(host, port));
9:f199fa3:         }
1:f199fa3: 
1:f199fa3:         public static TopologyChange removedNode(InetAddress host, int port)
1:f199fa3:         {
1:f199fa3:             return new TopologyChange(Change.REMOVED_NODE, new InetSocketAddress(host, port));
1:f199fa3:         }
1:f199fa3: 
1:63a8bfe:         public static TopologyChange movedNode(InetAddress host, int port)
1:63a8bfe:         {
1:63a8bfe:             return new TopologyChange(Change.MOVED_NODE, new InetSocketAddress(host, port));
1:63a8bfe:         }
1:63a8bfe: 
1:f8be23a:         // Assumes the type has already been deserialized
1:e0adc16:         private static TopologyChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:f199fa3:         {
1:e27a955:             Change change = CBUtil.readEnumValue(Change.class, cb);
1:f199fa3:             InetSocketAddress node = CBUtil.readInet(cb);
1:f199fa3:             return new TopologyChange(change, node);
1:f199fa3:         }
1:f199fa3: 
1:e0adc16:         protected void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:f199fa3:         {
1:9872b74:             CBUtil.writeEnumValue(change, dest);
1:f8be23a:             CBUtil.writeInet(node, dest);
1:f8be23a:         }
1:f8be23a: 
1:e0adc16:         protected int eventSerializedSize(ProtocolVersion version)
1:f8be23a:         {
1:f8be23a:             return CBUtil.sizeOfEnumValue(change) + CBUtil.sizeOfInet(node);
1:f199fa3:         }
1:f199fa3: 
1:f6217ae:         @Override
1:f6217ae:         public String toString()
1:f6217ae:         {
1:f199fa3:             return change + " " + node;
1:f6217ae:         }
1:f6217ae: 
1:f6217ae:         @Override
1:f6217ae:         public int hashCode()
1:f6217ae:         {
1:9872b74:             return Objects.hashCode(change, node);
1:f6217ae:         }
1:f6217ae: 
1:f6217ae:         @Override
1:f6217ae:         public boolean equals(Object other)
1:f6217ae:         {
1:9872b74:             if (!(other instanceof TopologyChange))
1:f6217ae:                 return false;
1:f6217ae: 
1:9872b74:             TopologyChange tpc = (TopologyChange)other;
1:9872b74:             return Objects.equal(change, tpc.change)
1:9872b74:                 && Objects.equal(node, tpc.node);
1:9872b74:         }
1:f199fa3:     }
1:9872b74: 
1:f199fa3: 
1:f6cab37:     public static class StatusChange extends NodeEvent
1:9872b74:     {
1:f199fa3:         public enum Status { UP, DOWN }
1:f199fa3: 
1:f199fa3:         public final Status status;
1:f199fa3: 
1:f199fa3:         private StatusChange(Status status, InetSocketAddress node)
1:f199fa3:         {
1:f6cab37:             super(Type.STATUS_CHANGE, node);
1:f199fa3:             this.status = status;
1:f199fa3:         }
1:f199fa3: 
1:f199fa3:         public static StatusChange nodeUp(InetAddress host, int port)
1:f199fa3:         {
1:f199fa3:             return new StatusChange(Status.UP, new InetSocketAddress(host, port));
1:f199fa3:         }
1:f199fa3: 
1:f199fa3:         public static StatusChange nodeDown(InetAddress host, int port)
1:f199fa3:         {
1:f199fa3:             return new StatusChange(Status.DOWN, new InetSocketAddress(host, port));
1:f199fa3:         }
1:f199fa3: 
1:f8be23a:         // Assumes the type has already been deserialized
1:e0adc16:         private static StatusChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:f199fa3:         {
1:e27a955:             Status status = CBUtil.readEnumValue(Status.class, cb);
1:f199fa3:             InetSocketAddress node = CBUtil.readInet(cb);
1:f199fa3:             return new StatusChange(status, node);
1:f199fa3:         }
1:f199fa3: 
1:e0adc16:         protected void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:f199fa3:         {
1:f8be23a:             CBUtil.writeEnumValue(status, dest);
1:f8be23a:             CBUtil.writeInet(node, dest);
1:f8be23a:         }
1:f8be23a: 
1:e0adc16:         protected int eventSerializedSize(ProtocolVersion version)
1:f8be23a:         {
1:f8be23a:             return CBUtil.sizeOfEnumValue(status) + CBUtil.sizeOfInet(node);
1:f199fa3:         }
1:f199fa3: 
1:9872b74:         @Override
2:f199fa3:         public String toString()
1:f199fa3:         {
1:f199fa3:             return status + " " + node;
1:11f7d72:         }
1:9872b74: 
1:9872b74:         @Override
1:9872b74:         public int hashCode()
1:9872b74:         {
1:9872b74:             return Objects.hashCode(status, node);
1:9872b74:         }
1:9872b74: 
1:9872b74:         @Override
1:9872b74:         public boolean equals(Object other)
1:9872b74:         {
1:9872b74:             if (!(other instanceof StatusChange))
1:9872b74:                 return false;
1:9872b74: 
1:9872b74:             StatusChange stc = (StatusChange)other;
1:9872b74:             return Objects.equal(status, stc.status)
1:9872b74:                 && Objects.equal(node, stc.node);
1:9872b74:         }
1:f199fa3:     }
1:11f7d72: 
1:11f7d72:     public static class SchemaChange extends Event
1:11f7d72:     {
1:11f7d72:         public enum Change { CREATED, UPDATED, DROPPED }
1:dcc3bb0:         public enum Target { KEYSPACE, TABLE, TYPE, FUNCTION, AGGREGATE }
1:11f7d72: 
1:11f7d72:         public final Change change;
1:9872b74:         public final Target target;
1:b4d7f3b:         public final String keyspace;
1:dcc3bb0:         public final String name;
1:dcc3bb0:         public final List<String> argTypes;
1:11f7d72: 
1:dcc3bb0:         public SchemaChange(Change change, Target target, String keyspace, String name, List<String> argTypes)
1:11f7d72:         {
1:11f7d72:             super(Type.SCHEMA_CHANGE);
1:11f7d72:             this.change = change;
1:9872b74:             this.target = target;
1:b4d7f3b:             this.keyspace = keyspace;
1:dcc3bb0:             this.name = name;
1:bd0eafd:             if (target != Target.KEYSPACE)
1:dcc3bb0:                 assert this.name != null : "Table, type, function or aggregate name should be set for non-keyspace schema change events";
1:dcc3bb0:             this.argTypes = argTypes;
1:dcc3bb0:         }
1:dcc3bb0: 
1:dcc3bb0:         public SchemaChange(Change change, Target target, String keyspace, String name)
1:dcc3bb0:         {
1:dcc3bb0:             this(change, target, keyspace, name, null);
1:11f7d72:         }
1:11f7d72: 
1:11f7d72:         public SchemaChange(Change change, String keyspace)
1:11f7d72:         {
1:9872b74:             this(change, Target.KEYSPACE, keyspace, null);
1:11f7d72:         }
1:11f7d72: 
1:f8be23a:         // Assumes the type has already been deserialized
1:e0adc16:         public static SchemaChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:9872b74:         {
1:e27a955:             Change change = CBUtil.readEnumValue(Change.class, cb);
1:e0adc16:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:11f7d72:             {
1:9872b74:                 Target target = CBUtil.readEnumValue(Target.class, cb);
1:9872b74:                 String keyspace = CBUtil.readString(cb);
1:9872b74:                 String tableOrType = target == Target.KEYSPACE ? null : CBUtil.readString(cb);
1:dcc3bb0:                 List<String> argTypes = null;
1:dcc3bb0:                 if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:dcc3bb0:                     argTypes = CBUtil.readStringList(cb);
1:dcc3bb0: 
1:dcc3bb0:                 return new SchemaChange(change, target, keyspace, tableOrType, argTypes);
1:9872b74:             }
1:9872b74:             else
1:dcc3bb0:             {
1:9872b74:                 String keyspace = CBUtil.readString(cb);
1:9872b74:                 String table = CBUtil.readString(cb);
1:9872b74:                 return new SchemaChange(change, table.isEmpty() ? Target.KEYSPACE : Target.TABLE, keyspace, table.isEmpty() ? null : table);
1:9872b74:             }
1:11f7d72:         }
1:11f7d72: 
1:e0adc16:         public void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:dcc3bb0:         {
1:dcc3bb0:             if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:9872b74:             {
1:e0adc16:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
1:9872b74:                 {
1:dcc3bb0:                     // available since protocol version 4
1:dcc3bb0:                     CBUtil.writeEnumValue(change, dest);
1:dcc3bb0:                     CBUtil.writeEnumValue(target, dest);
1:dcc3bb0:                     CBUtil.writeString(keyspace, dest);
1:dcc3bb0:                     CBUtil.writeString(name, dest);
1:dcc3bb0:                     CBUtil.writeStringList(argTypes, dest);
1:dcc3bb0:                 }
1:dcc3bb0:                 else
1:dcc3bb0:                 {
1:dcc3bb0:                     // not available in protocol versions < 4 - just say the keyspace was updated.
1:dcc3bb0:                     CBUtil.writeEnumValue(Change.UPDATED, dest);
1:e0adc16:                     if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:dcc3bb0:                         CBUtil.writeEnumValue(Target.KEYSPACE, dest);
1:dcc3bb0:                     CBUtil.writeString(keyspace, dest);
1:dcc3bb0:                     CBUtil.writeString("", dest);
1:dcc3bb0:                 }
1:dcc3bb0:                 return;
1:dcc3bb0:             }
1:dcc3bb0: 
1:e0adc16:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:9872b74:             {
1:9872b74:                 CBUtil.writeEnumValue(change, dest);
1:9872b74:                 CBUtil.writeEnumValue(target, dest);
1:b4d7f3b:                 CBUtil.writeString(keyspace, dest);
1:9872b74:                 if (target != Target.KEYSPACE)
1:dcc3bb0:                     CBUtil.writeString(name, dest);
1:9872b74:             }
1:9872b74:             else
1:9872b74:             {
1:9082281:                 if (target == Target.TYPE)
1:9082281:                 {
1:9082281:                     // For the v1/v2 protocol, we have no way to represent type changes, so we simply say the keyspace
1:9082281:                     // was updated.  See CASSANDRA-7617.
1:9082281:                     CBUtil.writeEnumValue(Change.UPDATED, dest);
1:9082281:                     CBUtil.writeString(keyspace, dest);
1:9082281:                     CBUtil.writeString("", dest);
1:9082281:                 }
1:9082281:                 else
1:9082281:                 {
1:9082281:                     CBUtil.writeEnumValue(change, dest);
1:9082281:                     CBUtil.writeString(keyspace, dest);
1:dcc3bb0:                     CBUtil.writeString(target == Target.KEYSPACE ? "" : name, dest);
1:9082281:                 }
1:9872b74:             }
1:f8be23a:         }
1:f8be23a: 
1:e0adc16:         public int eventSerializedSize(ProtocolVersion version)
1:9082281:         {
1:dcc3bb0:             if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:dcc3bb0:             {
1:e0adc16:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
1:dcc3bb0:                     return CBUtil.sizeOfEnumValue(change)
1:dcc3bb0:                                + CBUtil.sizeOfEnumValue(target)
1:dcc3bb0:                                + CBUtil.sizeOfString(keyspace)
1:dcc3bb0:                                + CBUtil.sizeOfString(name)
1:dcc3bb0:                                + CBUtil.sizeOfStringList(argTypes);
1:e0adc16:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:9082281:                     return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:dcc3bb0:                            + CBUtil.sizeOfEnumValue(Target.KEYSPACE)
1:dcc3bb0:                            + CBUtil.sizeOfString(keyspace);
1:dcc3bb0:                 return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:9082281:                        + CBUtil.sizeOfString(keyspace)
1:9082281:                        + CBUtil.sizeOfString("");
1:9082281:             }
1:dcc3bb0: 
1:e0adc16:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:f8be23a:             {
1:9872b74:                 int size = CBUtil.sizeOfEnumValue(change)
1:9872b74:                          + CBUtil.sizeOfEnumValue(target)
1:b4d7f3b:                          + CBUtil.sizeOfString(keyspace);
1:9872b74: 
1:9872b74:                 if (target != Target.KEYSPACE)
1:dcc3bb0:                     size += CBUtil.sizeOfString(name);
1:9872b74: 
1:9872b74:                 return size;
1:dcc3bb0:             }
1:9872b74:             else
1:9872b74:             {
1:9082281:                 if (target == Target.TYPE)
1:9872b74:                 {
1:dcc3bb0:                     return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:dcc3bb0:                          + CBUtil.sizeOfString(keyspace)
1:dcc3bb0:                          + CBUtil.sizeOfString("");
1:9872b74:                 }
1:9872b74:                 return CBUtil.sizeOfEnumValue(change)
2:b4d7f3b:                      + CBUtil.sizeOfString(keyspace)
1:dcc3bb0:                      + CBUtil.sizeOfString(target == Target.KEYSPACE ? "" : name);
1:9872b74:             }
1:9872b74:         }
1:9872b74: 
1:9872b74:         @Override
1:11f7d72:         public String toString()
1:9872b74:         {
1:dcc3bb0:             StringBuilder sb = new StringBuilder().append(change)
1:dcc3bb0:                                                   .append(' ').append(target)
1:dcc3bb0:                                                   .append(' ').append(keyspace);
1:dcc3bb0:             if (name != null)
1:dcc3bb0:                 sb.append('.').append(name);
1:dcc3bb0:             if (argTypes != null)
1:dcc3bb0:             {
1:dcc3bb0:                 sb.append(" (");
1:dcc3bb0:                 for (Iterator<String> iter = argTypes.iterator(); iter.hasNext(); )
1:dcc3bb0:                 {
1:dcc3bb0:                     sb.append(iter.next());
1:dcc3bb0:                     if (iter.hasNext())
1:dcc3bb0:                         sb.append(',');
1:dcc3bb0:                 }
1:dcc3bb0:                 sb.append(')');
1:dcc3bb0:             }
1:dcc3bb0:             return sb.toString();
1:9872b74:         }
1:9872b74: 
1:9872b74:         @Override
2:9872b74:         public int hashCode()
1:11f7d72:         {
1:dcc3bb0:             return Objects.hashCode(change, target, keyspace, name, argTypes);
1:11f7d72:         }
1:11f7d72: 
1:9872b74:         @Override
2:9872b74:         public boolean equals(Object other)
1:11f7d72:         {
1:9872b74:             if (!(other instanceof SchemaChange))
2:9872b74:                 return false;
1:9872b74: 
1:9872b74:             SchemaChange scc = (SchemaChange)other;
1:9872b74:             return Objects.equal(change, scc.change)
1:9872b74:                 && Objects.equal(target, scc.target)
1:b4d7f3b:                 && Objects.equal(keyspace, scc.keyspace)
1:dcc3bb0:                 && Objects.equal(name, scc.name)
1:dcc3bb0:                 && Objects.equal(argTypes, scc.argTypes);
1:f6217ae:         }
1:f6217ae:     }
1:11f7d72: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1:         TOPOLOGY_CHANGE(ProtocolVersion.V3),
1:         STATUS_CHANGE(ProtocolVersion.V3),
1:         SCHEMA_CHANGE(ProtocolVersion.V3),
1:         TRACE_COMPLETE(ProtocolVersion.V4);
1:         public final ProtocolVersion minimumVersion;
1:         Type(ProtocolVersion minimumVersion)
/////////////////////////////////////////////////////////////////////////
1:     public static Event deserialize(ByteBuf cb, ProtocolVersion version)
1:         if (eventType.minimumVersion.isGreaterThan(version))
/////////////////////////////////////////////////////////////////////////
1:     public void serialize(ByteBuf dest, ProtocolVersion version)
1:         if (type.minimumVersion.isGreaterThan(version))
1:     public int serializedSize(ProtocolVersion version)
1:     protected abstract void serializeEvent(ByteBuf dest, ProtocolVersion version);
1:     protected abstract int eventSerializedSize(ProtocolVersion version);
/////////////////////////////////////////////////////////////////////////
1:         private static TopologyChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:         protected void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:         protected int eventSerializedSize(ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         private static StatusChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:         protected void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:         protected int eventSerializedSize(ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:         public static SchemaChange deserializeEvent(ByteBuf cb, ProtocolVersion version)
1:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
/////////////////////////////////////////////////////////////////////////
1:         public void serializeEvent(ByteBuf dest, ProtocolVersion version)
1:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
/////////////////////////////////////////////////////////////////////////
1:                     if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
/////////////////////////////////////////////////////////////////////////
1:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
/////////////////////////////////////////////////////////////////////////
1:         public int eventSerializedSize(ProtocolVersion version)
1:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
1:                 if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
/////////////////////////////////////////////////////////////////////////
1:             if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
commit:f6cab37
/////////////////////////////////////////////////////////////////////////
1:     public static abstract class NodeEvent extends Event
1:     {
1:         public final InetSocketAddress node;
1: 
1:         public InetAddress nodeAddress()
1:         {
1:             return node.getAddress();
1:         }
1: 
1:         private NodeEvent(Type type, InetSocketAddress node)
1:         {
1:             super(type);
1:             this.node = node;
1:         }
1:     }
1: 
1:     public static class TopologyChange extends NodeEvent
1:             super(Type.TOPOLOGY_CHANGE, node);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static class StatusChange extends NodeEvent
1:             super(Type.STATUS_CHANGE, node);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:     public enum Type
1:     {
commit:0e23d17
/////////////////////////////////////////////////////////////////////////
0:                 if (version >= Server.VERSION_4)
commit:02fb218
/////////////////////////////////////////////////////////////////////////
author:Alex Petrov
-------------------------------------------------------------------------------
commit:d9322a1
/////////////////////////////////////////////////////////////////////////
0:             if (version >= Server.VERSION_3)
/////////////////////////////////////////////////////////////////////////
0:                 if (version >= Server.VERSION_4)
/////////////////////////////////////////////////////////////////////////
0:             if (version >= Server.VERSION_3)
/////////////////////////////////////////////////////////////////////////
0:                 if (version >= Server.VERSION_3)
0:                 if (version >= Server.VERSION_3)
/////////////////////////////////////////////////////////////////////////
0:             if (version >= Server.VERSION_3)
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:a039b7d
commit:7452b20
commit:6288dd9
/////////////////////////////////////////////////////////////////////////
0:         TOPOLOGY_CHANGE(Server.VERSION_1),
0:         STATUS_CHANGE(Server.VERSION_1),
0:         SCHEMA_CHANGE(Server.VERSION_1),
commit:9082281
/////////////////////////////////////////////////////////////////////////
1:                 if (target == Target.TYPE)
1:                 {
1:                     // For the v1/v2 protocol, we have no way to represent type changes, so we simply say the keyspace
1:                     // was updated.  See CASSANDRA-7617.
1:                     CBUtil.writeEnumValue(Change.UPDATED, dest);
1:                     CBUtil.writeString(keyspace, dest);
1:                     CBUtil.writeString("", dest);
1:                 }
1:                 else
1:                 {
1:                     CBUtil.writeEnumValue(change, dest);
1:                     CBUtil.writeString(keyspace, dest);
0:                     CBUtil.writeString(target == Target.KEYSPACE ? "" : tableOrType, dest);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (target == Target.TYPE)
1:                 {
1:                     return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:                          + CBUtil.sizeOfString(keyspace)
1:                          + CBUtil.sizeOfString("");
1:                 }
commit:bd0eafd
/////////////////////////////////////////////////////////////////////////
1:             if (target != Target.KEYSPACE)
0:                 assert this.tableOrType != null : "Table or type should be set for non-keyspace schema change events";
author:blerer
-------------------------------------------------------------------------------
commit:8439e74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TOPOLOGY_CHANGE(Server.VERSION_3),
0:         STATUS_CHANGE(Server.VERSION_3),
0:         SCHEMA_CHANGE(Server.VERSION_3),
author:Robert Stupp
-------------------------------------------------------------------------------
commit:e4eba25
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f6217ae
/////////////////////////////////////////////////////////////////////////
0: import java.util.UUID;
0:     public enum Type {
0:         TOPOLOGY_CHANGE(Server.VERSION_2),
0:         STATUS_CHANGE(Server.VERSION_2),
0:         SCHEMA_CHANGE(Server.VERSION_2),
0:         TRACE_COMPLETE(Server.VERSION_4);
1: 
0:         public final int minimumVersion;
1: 
0:         Type(int minimumVersion)
1:         {
1:             this.minimumVersion = minimumVersion;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         Type eventType = CBUtil.readEnumValue(Type.class, cb);
0:         if (eventType.minimumVersion > version)
1:             throw new ProtocolException("Event " + eventType.name() + " not valid for protocol version " + version);
1:         switch (eventType)
/////////////////////////////////////////////////////////////////////////
0:             case TRACE_COMPLETE:
0:                 return TraceComplete.deserializeEvent(cb, version);
0:         if (type.minimumVersion > version)
1:             throw new ProtocolException("Event " + type.name() + " not valid for protocol version " + version);
/////////////////////////////////////////////////////////////////////////
1: 
0:     /**
0:      * @since native protocol v4
1:      */
0:     public static class TraceComplete extends Event
1:     {
0:         public final UUID traceSessionId;
1: 
0:         public TraceComplete(UUID traceSessionId)
1:         {
0:             super(Type.TRACE_COMPLETE);
0:             this.traceSessionId = traceSessionId;
1:         }
1: 
0:         public static Event deserializeEvent(ByteBuf cb, int version)
1:         {
0:             UUID traceSessionId = CBUtil.readUUID(cb);
0:             return new TraceComplete(traceSessionId);
1:         }
1: 
0:         protected void serializeEvent(ByteBuf dest, int version)
1:         {
0:             CBUtil.writeUUID(traceSessionId, dest);
1:         }
1: 
0:         protected int eventSerializedSize(int version)
1:         {
0:             return CBUtil.sizeOfUUID(traceSessionId);
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
0:             return traceSessionId.toString();
1:         }
1: 
1:         @Override
1:         public int hashCode()
1:         {
0:             return Objects.hashCode(traceSessionId);
1:         }
1: 
1:         @Override
1:         public boolean equals(Object other)
1:         {
0:             if (!(other instanceof TraceComplete))
1:                 return false;
1: 
0:             TraceComplete tf = (TraceComplete)other;
0:             return Objects.equal(traceSessionId, tf.traceSessionId);
1:         }
1:     }
commit:dcc3bb0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         public enum Target { KEYSPACE, TABLE, TYPE, FUNCTION, AGGREGATE }
1:         public final String name;
1:         public final List<String> argTypes;
1:         public SchemaChange(Change change, Target target, String keyspace, String name, List<String> argTypes)
1:             this.name = name;
1:                 assert this.name != null : "Table, type, function or aggregate name should be set for non-keyspace schema change events";
1:             this.argTypes = argTypes;
1:         }
1: 
1:         public SchemaChange(Change change, Target target, String keyspace, String name)
1:         {
1:             this(change, target, keyspace, name, null);
/////////////////////////////////////////////////////////////////////////
1:                 List<String> argTypes = null;
1:                 if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:                     argTypes = CBUtil.readStringList(cb);
1: 
1:                 return new SchemaChange(change, target, keyspace, tableOrType, argTypes);
/////////////////////////////////////////////////////////////////////////
1:             if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:             {
0:                 if (version >= 4)
1:                 {
1:                     // available since protocol version 4
1:                     CBUtil.writeEnumValue(change, dest);
1:                     CBUtil.writeEnumValue(target, dest);
1:                     CBUtil.writeString(keyspace, dest);
1:                     CBUtil.writeString(name, dest);
1:                     CBUtil.writeStringList(argTypes, dest);
1:                 }
1:                 else
1:                 {
1:                     // not available in protocol versions < 4 - just say the keyspace was updated.
1:                     CBUtil.writeEnumValue(Change.UPDATED, dest);
0:                     if (version >= 3)
1:                         CBUtil.writeEnumValue(Target.KEYSPACE, dest);
1:                     CBUtil.writeString(keyspace, dest);
1:                     CBUtil.writeString("", dest);
1:                 }
1:                 return;
1:             }
1: 
1:                     CBUtil.writeString(name, dest);
/////////////////////////////////////////////////////////////////////////
1:                     CBUtil.writeString(target == Target.KEYSPACE ? "" : name, dest);
1:             if (target == Target.FUNCTION || target == Target.AGGREGATE)
1:             {
0:                 if (version >= 4)
1:                     return CBUtil.sizeOfEnumValue(change)
1:                                + CBUtil.sizeOfEnumValue(target)
1:                                + CBUtil.sizeOfString(keyspace)
1:                                + CBUtil.sizeOfString(name)
1:                                + CBUtil.sizeOfStringList(argTypes);
0:                 if (version >= 3)
1:                     return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:                            + CBUtil.sizeOfEnumValue(Target.KEYSPACE)
1:                            + CBUtil.sizeOfString(keyspace);
1:                 return CBUtil.sizeOfEnumValue(Change.UPDATED)
1:                        + CBUtil.sizeOfString(keyspace)
1:                        + CBUtil.sizeOfString("");
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     size += CBUtil.sizeOfString(name);
/////////////////////////////////////////////////////////////////////////
1:                      + CBUtil.sizeOfString(target == Target.KEYSPACE ? "" : name);
1:             StringBuilder sb = new StringBuilder().append(change)
1:                                                   .append(' ').append(target)
1:                                                   .append(' ').append(keyspace);
1:             if (name != null)
1:                 sb.append('.').append(name);
1:             if (argTypes != null)
1:             {
1:                 sb.append(" (");
1:                 for (Iterator<String> iter = argTypes.iterator(); iter.hasNext(); )
1:                 {
1:                     sb.append(iter.next());
1:                     if (iter.hasNext())
1:                         sb.append(',');
1:                 }
1:                 sb.append(')');
1:             }
1:             return sb.toString();
1:             return Objects.hashCode(change, target, keyspace, name, argTypes);
/////////////////////////////////////////////////////////////////////////
1:                 && Objects.equal(name, scc.name)
1:                 && Objects.equal(argTypes, scc.argTypes);
commit:b4d7f3b
/////////////////////////////////////////////////////////////////////////
1:         public final String keyspace;
0:         public SchemaChange(Change change, Target target, String keyspace, String tableOrTypeOrFunction)
1:             this.keyspace = keyspace;
/////////////////////////////////////////////////////////////////////////
1:                 CBUtil.writeString(keyspace, dest);
/////////////////////////////////////////////////////////////////////////
0:                     CBUtil.writeString(keyspace, dest);
0:                     CBUtil.writeString(keyspace, dest);
/////////////////////////////////////////////////////////////////////////
1:                          + CBUtil.sizeOfString(keyspace);
/////////////////////////////////////////////////////////////////////////
1:                          + CBUtil.sizeOfString(keyspace)
1:                      + CBUtil.sizeOfString(keyspace)
/////////////////////////////////////////////////////////////////////////
0:             return change + " " + target + " " + keyspace + (tableOrTypeOrFunction == null ? "" : "." + tableOrTypeOrFunction);
0:             return Objects.hashCode(change, target, keyspace, tableOrTypeOrFunction);
/////////////////////////////////////////////////////////////////////////
1:                 && Objects.equal(keyspace, scc.keyspace)
commit:25411bf
/////////////////////////////////////////////////////////////////////////
0:         public final String keyOrNamespace;
0:         public final String tableOrTypeOrFunction;
0:         public SchemaChange(Change change, Target target, String keyOrNamespace, String tableOrTypeOrFunction)
0:             this.keyOrNamespace = keyOrNamespace;
0:             this.tableOrTypeOrFunction = tableOrTypeOrFunction;
0:                 assert this.tableOrTypeOrFunction != null : "Table or type should be set for non-keyspace schema change events";
/////////////////////////////////////////////////////////////////////////
0:                 CBUtil.writeString(keyOrNamespace, dest);
0:                     CBUtil.writeString(tableOrTypeOrFunction, dest);
/////////////////////////////////////////////////////////////////////////
0:                     CBUtil.writeString(keyOrNamespace, dest);
0:                     CBUtil.writeString(keyOrNamespace, dest);
0:                     CBUtil.writeString(target == Target.KEYSPACE ? "" : tableOrTypeOrFunction, dest);
/////////////////////////////////////////////////////////////////////////
0:                          + CBUtil.sizeOfString(keyOrNamespace);
0:                     size += CBUtil.sizeOfString(tableOrTypeOrFunction);
/////////////////////////////////////////////////////////////////////////
0:                          + CBUtil.sizeOfString(keyOrNamespace)
0:                      + CBUtil.sizeOfString(keyOrNamespace)
0:                      + CBUtil.sizeOfString(target == Target.KEYSPACE ? "" : tableOrTypeOrFunction);
0:             return change + " " + target + " " + keyOrNamespace + (tableOrTypeOrFunction == null ? "" : "." + tableOrTypeOrFunction);
0:             return Objects.hashCode(change, target, keyOrNamespace, tableOrTypeOrFunction);
/////////////////////////////////////////////////////////////////////////
0:                 && Objects.equal(keyOrNamespace, scc.keyOrNamespace)
0:                 && Objects.equal(tableOrTypeOrFunction, scc.tableOrTypeOrFunction);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2fe6de6
/////////////////////////////////////////////////////////////////////////
0:         public static SchemaChange deserializeEvent(ByteBuf cb, int version)
/////////////////////////////////////////////////////////////////////////
0:         public void serializeEvent(ByteBuf dest, int version)
/////////////////////////////////////////////////////////////////////////
0:         public int eventSerializedSize(int version)
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Objects;
/////////////////////////////////////////////////////////////////////////
0:     public static Event deserialize(ByteBuf cb, int version)
1:                 return TopologyChange.deserializeEvent(cb, version);
1:                 return StatusChange.deserializeEvent(cb, version);
1:                 return SchemaChange.deserializeEvent(cb, version);
0:     public void serialize(ByteBuf dest, int version)
1:         serializeEvent(dest, version);
0:     public int serializedSize(int version)
1:         return CBUtil.sizeOfEnumValue(type) + eventSerializedSize(version);
0:     protected abstract void serializeEvent(ByteBuf dest, int version);
0:     protected abstract int eventSerializedSize(int version);
/////////////////////////////////////////////////////////////////////////
0:         private static TopologyChange deserializeEvent(ByteBuf cb, int version)
0:         protected void serializeEvent(ByteBuf dest, int version)
0:         protected int eventSerializedSize(int version)
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public int hashCode()
1:         {
1:             return Objects.hashCode(change, node);
1:         }
1: 
1:         @Override
1:         public boolean equals(Object other)
1:         {
1:             if (!(other instanceof TopologyChange))
1:                 return false;
1: 
1:             TopologyChange tpc = (TopologyChange)other;
1:             return Objects.equal(change, tpc.change)
1:                 && Objects.equal(node, tpc.node);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         private static StatusChange deserializeEvent(ByteBuf cb, int version)
0:         protected void serializeEvent(ByteBuf dest, int version)
0:         protected int eventSerializedSize(int version)
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public int hashCode()
1:         {
1:             return Objects.hashCode(status, node);
1:         }
1: 
1:         @Override
1:         public boolean equals(Object other)
1:         {
1:             if (!(other instanceof StatusChange))
1:                 return false;
1: 
1:             StatusChange stc = (StatusChange)other;
1:             return Objects.equal(status, stc.status)
1:                 && Objects.equal(node, stc.node);
1:         }
0:         public enum Target { KEYSPACE, TABLE, TYPE }
1:         public final Target target;
0:         public final String tableOrType;
0:         public SchemaChange(Change change, Target target, String keyspace, String tableOrType)
1:             this.target = target;
0:             this.tableOrType = tableOrType;
1:             this(change, Target.KEYSPACE, keyspace, null);
0:         private static SchemaChange deserializeEvent(ByteBuf cb, int version)
0:             if (version >= 3)
1:             {
1:                 Target target = CBUtil.readEnumValue(Target.class, cb);
1:                 String keyspace = CBUtil.readString(cb);
1:                 String tableOrType = target == Target.KEYSPACE ? null : CBUtil.readString(cb);
0:                 return new SchemaChange(change, target, keyspace, tableOrType);
1:             }
1:             else
1:             {
1:                 String keyspace = CBUtil.readString(cb);
1:                 String table = CBUtil.readString(cb);
1:                 return new SchemaChange(change, table.isEmpty() ? Target.KEYSPACE : Target.TABLE, keyspace, table.isEmpty() ? null : table);
1:             }
0:         protected void serializeEvent(ByteBuf dest, int version)
0:             if (version >= 3)
1:             {
1:                 CBUtil.writeEnumValue(change, dest);
1:                 CBUtil.writeEnumValue(target, dest);
0:                 CBUtil.writeString(keyspace, dest);
1:                 if (target != Target.KEYSPACE)
0:                     CBUtil.writeString(tableOrType, dest);
1:             }
1:             else
1:             {
1:                 CBUtil.writeEnumValue(change, dest);
0:                 CBUtil.writeString(keyspace, dest);
0:                 CBUtil.writeString(target == Target.KEYSPACE ? "" : tableOrType, dest);
1:             }
0:         protected int eventSerializedSize(int version)
0:             if (version >= 3)
1:             {
1:                 int size = CBUtil.sizeOfEnumValue(change)
1:                          + CBUtil.sizeOfEnumValue(target)
0:                          + CBUtil.sizeOfString(keyspace);
1: 
1:                 if (target != Target.KEYSPACE)
0:                     size += CBUtil.sizeOfString(tableOrType);
1: 
1:                 return size;
1:             }
1:             else
1:             {
1:                 return CBUtil.sizeOfEnumValue(change)
0:                      + CBUtil.sizeOfString(keyspace)
0:                      + CBUtil.sizeOfString(target == Target.KEYSPACE ? "" : tableOrType);
1:             }
0:             return change + " " + target + " " + keyspace + (tableOrType == null ? "" : "." + tableOrType);
1:         }
1: 
1:         @Override
1:         public int hashCode()
1:         {
0:             return Objects.hashCode(change, target, keyspace, tableOrType);
1:         }
1: 
1:         @Override
1:         public boolean equals(Object other)
1:         {
1:             if (!(other instanceof SchemaChange))
1:                 return false;
1: 
1:             SchemaChange scc = (SchemaChange)other;
1:             return Objects.equal(change, scc.change)
1:                 && Objects.equal(target, scc.target)
0:                 && Objects.equal(keyspace, scc.keyspace)
0:                 && Objects.equal(tableOrType, scc.tableOrType);
commit:f8be23a
/////////////////////////////////////////////////////////////////////////
0:     public void serialize(ChannelBuffer dest)
1:         CBUtil.writeEnumValue(type, dest);
0:         serializeEvent(dest);
0:     public int serializedSize()
1:     {
0:         return CBUtil.sizeOfEnumValue(type) + eventSerializedSize();
1:     }
1: 
0:     protected abstract void serializeEvent(ChannelBuffer dest);
0:     protected abstract int eventSerializedSize();
/////////////////////////////////////////////////////////////////////////
1:         // Assumes the type has already been deserialized
/////////////////////////////////////////////////////////////////////////
0:         protected void serializeEvent(ChannelBuffer dest)
0:             CBUtil.writeEnumValue(change, dest);
1:             CBUtil.writeInet(node, dest);
1:         }
1: 
0:         protected int eventSerializedSize()
1:         {
1:             return CBUtil.sizeOfEnumValue(change) + CBUtil.sizeOfInet(node);
/////////////////////////////////////////////////////////////////////////
1:         // Assumes the type has already been deserialized
/////////////////////////////////////////////////////////////////////////
0:         protected void serializeEvent(ChannelBuffer dest)
1:             CBUtil.writeEnumValue(status, dest);
1:             CBUtil.writeInet(node, dest);
1:         }
1: 
0:         protected int eventSerializedSize()
1:         {
1:             return CBUtil.sizeOfEnumValue(status) + CBUtil.sizeOfInet(node);
/////////////////////////////////////////////////////////////////////////
1:         // Assumes the type has already been deserialized
/////////////////////////////////////////////////////////////////////////
0:         protected void serializeEvent(ChannelBuffer dest)
0:             CBUtil.writeEnumValue(change, dest);
0:             CBUtil.writeString(keyspace, dest);
0:             CBUtil.writeString(table, dest);
1:         }
1: 
0:         protected int eventSerializedSize()
1:         {
0:             return CBUtil.sizeOfEnumValue(change)
0:                  + CBUtil.sizeOfString(keyspace)
0:                  + CBUtil.sizeOfString(table);
commit:e27a955
/////////////////////////////////////////////////////////////////////////
0:         switch (CBUtil.readEnumValue(Type.class, cb))
/////////////////////////////////////////////////////////////////////////
0:         return ChannelBuffers.wrappedBuffer(CBUtil.enumValueToCB(type), serializeEvent());
/////////////////////////////////////////////////////////////////////////
1:             Change change = CBUtil.readEnumValue(Change.class, cb);
0:             return ChannelBuffers.wrappedBuffer(CBUtil.enumValueToCB(change), CBUtil.inetToCB(node));
/////////////////////////////////////////////////////////////////////////
1:             Status status = CBUtil.readEnumValue(Status.class, cb);
0:             return ChannelBuffers.wrappedBuffer(CBUtil.enumValueToCB(status), CBUtil.inetToCB(node));
/////////////////////////////////////////////////////////////////////////
1:             Change change = CBUtil.readEnumValue(Change.class, cb);
/////////////////////////////////////////////////////////////////////////
0:             return ChannelBuffers.wrappedBuffer(CBUtil.enumValueToCB(change),
commit:63a8bfe
/////////////////////////////////////////////////////////////////////////
1:         public enum Change { NEW_NODE, REMOVED_NODE, MOVED_NODE }
/////////////////////////////////////////////////////////////////////////
1:         public static TopologyChange movedNode(InetAddress host, int port)
1:         {
1:             return new TopologyChange(Change.MOVED_NODE, new InetSocketAddress(host, port));
1:         }
1: 
commit:11f7d72
/////////////////////////////////////////////////////////////////////////
0:     public enum Type { TOPOLOGY_CHANGE, STATUS_CHANGE, SCHEMA_CHANGE }
/////////////////////////////////////////////////////////////////////////
1:             case SCHEMA_CHANGE:
0:                 return SchemaChange.deserializeEvent(cb);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static class SchemaChange extends Event
1:     {
1:         public enum Change { CREATED, UPDATED, DROPPED }
1: 
1:         public final Change change;
0:         public final String keyspace;
0:         public final String table;
1: 
0:         public SchemaChange(Change change, String keyspace, String table)
1:         {
1:             super(Type.SCHEMA_CHANGE);
1:             this.change = change;
0:             this.keyspace = keyspace;
0:             this.table = table;
1:         }
1: 
1:         public SchemaChange(Change change, String keyspace)
1:         {
0:             this(change, keyspace, "");
1:         }
1: 
0:         // Assumes the type has already by been deserialized
0:         private static SchemaChange deserializeEvent(ChannelBuffer cb)
1:         {
0:             Change change = Enum.valueOf(Change.class, CBUtil.readString(cb).toUpperCase());
0:             String keyspace = CBUtil.readString(cb);
0:             String table = CBUtil.readString(cb);
0:             return new SchemaChange(change, keyspace, table);
1:         }
1: 
0:         protected ChannelBuffer serializeEvent()
1:         {
0:             return ChannelBuffers.wrappedBuffer(CBUtil.stringToCB(change.toString()),
0:                                                 CBUtil.stringToCB(keyspace),
0:                                                 CBUtil.stringToCB(table));
1:         }
1: 
0:         @Override
1:         public String toString()
1:         {
0:             return change + " " + keyspace + (table.isEmpty() ? "" : "." + table);
1:         }
1:     }
commit:f199fa3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.transport;
1: 
1: import java.net.InetAddress;
1: import java.net.InetSocketAddress;
1: 
0: import org.jboss.netty.buffer.ChannelBuffer;
0: import org.jboss.netty.buffer.ChannelBuffers;
1: 
1: public abstract class Event
1: {
0:     public enum Type { TOPOLOGY_CHANGE, STATUS_CHANGE }
1: 
1:     public final Type type;
1: 
1:     private Event(Type type)
1:     {
1:         this.type = type;
1:     }
1: 
0:     public static Event deserialize(ChannelBuffer cb)
1:     {
0:         switch (Enum.valueOf(Type.class, CBUtil.readString(cb).toUpperCase()))
1:         {
1:             case TOPOLOGY_CHANGE:
0:                 return TopologyChange.deserializeEvent(cb);
1:             case STATUS_CHANGE:
0:                 return StatusChange.deserializeEvent(cb);
1:         }
1:         throw new AssertionError();
1:     }
1: 
0:     public ChannelBuffer serialize()
1:     {
0:         return ChannelBuffers.wrappedBuffer(CBUtil.stringToCB(type.toString()),
0:                                             serializeEvent());
1:     }
1: 
0:     protected abstract ChannelBuffer serializeEvent();
1: 
0:     public static class TopologyChange extends Event
1:     {
0:         public enum Change { NEW_NODE, REMOVED_NODE }
1: 
1:         public final Change change;
0:         public final InetSocketAddress node;
1: 
1:         private TopologyChange(Change change, InetSocketAddress node)
1:         {
0:             super(Type.TOPOLOGY_CHANGE);
1:             this.change = change;
0:             this.node = node;
1:         }
1: 
1:         public static TopologyChange newNode(InetAddress host, int port)
1:         {
1:             return new TopologyChange(Change.NEW_NODE, new InetSocketAddress(host, port));
1:         }
1: 
1:         public static TopologyChange removedNode(InetAddress host, int port)
1:         {
1:             return new TopologyChange(Change.REMOVED_NODE, new InetSocketAddress(host, port));
1:         }
1: 
0:         // Assumes the type has already by been deserialized
0:         private static TopologyChange deserializeEvent(ChannelBuffer cb)
1:         {
0:             Change change = Enum.valueOf(Change.class, CBUtil.readString(cb).toUpperCase());
1:             InetSocketAddress node = CBUtil.readInet(cb);
1:             return new TopologyChange(change, node);
1:         }
1: 
0:         protected ChannelBuffer serializeEvent()
1:         {
0:             return ChannelBuffers.wrappedBuffer(CBUtil.stringToCB(change.toString()),
0:                                                 CBUtil.inetToCB(node));
1:         }
1: 
0:         @Override
1:         public String toString()
1:         {
1:             return change + " " + node;
1:         }
1:     }
1: 
0:     public static class StatusChange extends Event
1:     {
1:         public enum Status { UP, DOWN }
1: 
1:         public final Status status;
0:         public final InetSocketAddress node;
1: 
1:         private StatusChange(Status status, InetSocketAddress node)
1:         {
0:             super(Type.STATUS_CHANGE);
1:             this.status = status;
0:             this.node = node;
1:         }
1: 
1:         public static StatusChange nodeUp(InetAddress host, int port)
1:         {
1:             return new StatusChange(Status.UP, new InetSocketAddress(host, port));
1:         }
1: 
1:         public static StatusChange nodeDown(InetAddress host, int port)
1:         {
1:             return new StatusChange(Status.DOWN, new InetSocketAddress(host, port));
1:         }
1: 
0:         // Assumes the type has already by been deserialized
0:         private static StatusChange deserializeEvent(ChannelBuffer cb)
1:         {
0:             Status status = Enum.valueOf(Status.class, CBUtil.readString(cb).toUpperCase());
1:             InetSocketAddress node = CBUtil.readInet(cb);
1:             return new StatusChange(status, node);
1:         }
1: 
0:         protected ChannelBuffer serializeEvent()
1:         {
0:             return ChannelBuffers.wrappedBuffer(CBUtil.stringToCB(status.toString()),
0:                                                 CBUtil.inetToCB(node));
1:         }
1: 
0:         @Override
1:         public String toString()
1:         {
1:             return status + " " + node;
1:         }
1:     }
1: }
author:belliottsmith
-------------------------------------------------------------------------------
commit:cbf304e
/////////////////////////////////////////////////////////////////////////
1: import io.netty.buffer.ByteBuf;
/////////////////////////////////////////////////////////////////////////
0:     public static Event deserialize(ByteBuf cb)
/////////////////////////////////////////////////////////////////////////
0:     public void serialize(ByteBuf dest)
/////////////////////////////////////////////////////////////////////////
0:     protected abstract void serializeEvent(ByteBuf dest);
/////////////////////////////////////////////////////////////////////////
0:         private static TopologyChange deserializeEvent(ByteBuf cb)
0:         protected void serializeEvent(ByteBuf dest)
/////////////////////////////////////////////////////////////////////////
0:         private static StatusChange deserializeEvent(ByteBuf cb)
0:         protected void serializeEvent(ByteBuf dest)
/////////////////////////////////////////////////////////////////////////
0:         private static SchemaChange deserializeEvent(ByteBuf cb)
/////////////////////////////////////////////////////////////////////////
0:         protected void serializeEvent(ByteBuf dest)
============================================================================