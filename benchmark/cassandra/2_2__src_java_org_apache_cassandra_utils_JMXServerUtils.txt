1:7b0c716: /*
1:7b0c716:  * Licensed to the Apache Software Foundation (ASF) under one
1:7b0c716:  * or more contributor license agreements.  See the NOTICE file
1:7b0c716:  * distributed with this work for additional information
1:7b0c716:  * regarding copyright ownership.  The ASF licenses this file
1:7b0c716:  * to you under the Apache License, Version 2.0 (the
1:7b0c716:  * "License"); you may not use this file except in compliance
1:7b0c716:  * with the License.  You may obtain a copy of the License at
1:7b0c716:  *
1:7b0c716:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7b0c716:  *
1:7b0c716:  * Unless required by applicable law or agreed to in writing, software
1:7b0c716:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7b0c716:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7b0c716:  * See the License for the specific language governing permissions and
1:7b0c716:  * limitations under the License.
1:7b0c716:  */
1:7b0c716: 
1:7b0c716: package org.apache.cassandra.utils;
1:7b0c716: 
1:7b0c716: import java.io.IOException;
1:7b0c716: import java.lang.management.ManagementFactory;
1:7b0c716: import java.lang.reflect.InvocationHandler;
1:7b0c716: import java.lang.reflect.Proxy;
1:bdd4a92: import java.net.Inet6Address;
1:7b0c716: import java.net.InetAddress;
1:9eae8d3: import java.rmi.*;
1:7b0c716: import java.rmi.server.RMIClientSocketFactory;
1:7b0c716: import java.rmi.server.RMIServerSocketFactory;
1:7b0c716: import java.rmi.server.UnicastRemoteObject;
1:7b0c716: import java.util.Arrays;
1:7b0c716: import java.util.HashMap;
1:7b0c716: import java.util.Map;
1:7b0c716: import java.util.stream.Collectors;
1:7b0c716: import javax.management.remote.*;
1:7b0c716: import javax.management.remote.rmi.RMIConnectorServer;
1:7b0c716: import javax.rmi.ssl.SslRMIClientSocketFactory;
1:7b0c716: import javax.rmi.ssl.SslRMIServerSocketFactory;
1:7b0c716: import javax.security.auth.Subject;
1:7b0c716: 
1:7b0c716: import com.google.common.collect.ImmutableMap;
1:7b0c716: import org.apache.commons.lang3.StringUtils;
1:7b0c716: import org.slf4j.Logger;
1:7b0c716: import org.slf4j.LoggerFactory;
1:7b0c716: 
1:7b0c716: import com.sun.jmx.remote.internal.RMIExporter;
1:7b0c716: import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
1:7b0c716: import org.apache.cassandra.auth.jmx.AuthenticationProxy;
1:9eae8d3: import sun.rmi.registry.RegistryImpl;
1:7b0c716: import sun.rmi.server.UnicastServerRef2;
1:7b0c716: 
1:7b0c716: public class JMXServerUtils
2:7b0c716: {
1:7b0c716:     private static final Logger logger = LoggerFactory.getLogger(JMXServerUtils.class);
1:7b0c716: 
1:9eae8d3:     private static java.rmi.registry.Registry registry;
1:7b0c716: 
1:7b0c716:     /**
1:7b0c716:      * Creates a server programmatically. This allows us to set parameters which normally are
1:7b0c716:      * inaccessable.
1:7b0c716:      */
1:7b0c716:     public static JMXConnectorServer createJMXServer(int port, boolean local)
1:7b0c716:     throws IOException
1:7b0c716:     {
1:7b0c716:         Map<String, Object> env = new HashMap<>();
1:7b0c716: 
1:c17cbe1:         InetAddress serverAddress = null;
1:7b0c716:         if (local)
1:7b0c716:         {
1:7b0c716:             serverAddress = InetAddress.getLoopbackAddress();
1:c17cbe1:             System.setProperty("java.rmi.server.hostname", serverAddress.getHostAddress());
2:7b0c716:         }
1:7b0c716: 
1:7b0c716:         // Configure the RMI client & server socket factories, including SSL config.
1:9eae8d3:         env.putAll(configureJmxSocketFactories(serverAddress, local));
1:7b0c716: 
1:7b0c716: 
1:7b0c716:         // Configure authn, using a JMXAuthenticator which either wraps a set log LoginModules configured
1:7b0c716:         // via a JAAS configuration entry, or one which delegates to the standard file based authenticator.
1:7b0c716:         // Authn is disabled if com.sun.management.jmxremote.authenticate=false
1:7b0c716:         env.putAll(configureJmxAuthentication());
1:7b0c716: 
1:7b0c716:         // Configure authz - if a custom proxy class is specified an instance will be returned.
1:7b0c716:         // If not, but a location for the standard access file is set in system properties, the
1:7b0c716:         // return value is null, and an entry is added to the env map detailing that location
1:7b0c716:         // If neither method is specified, no access control is applied
1:7b0c716:         MBeanServerForwarder authzProxy = configureJmxAuthorization(env);
1:7b0c716: 
1:7b0c716:         // Make sure we use our custom exporter so a full GC doesn't get scheduled every
1:7b0c716:         // sun.rmi.dgc.server.gcInterval millis (default is 3600000ms/1 hour)
1:7b0c716:         env.put(RMIExporter.EXPORTER_ATTRIBUTE, new Exporter());
1:9eae8d3: 
1:7b0c716: 
1:9eae8d3:         int rmiPort = Integer.getInteger("com.sun.management.jmxremote.rmi.port", 0);
1:7b0c716:         JMXConnectorServer jmxServer =
1:9eae8d3:             JMXConnectorServerFactory.newJMXConnectorServer(new JMXServiceURL("rmi", null, rmiPort),
1:7b0c716:                                                             env,
1:7b0c716:                                                             ManagementFactory.getPlatformMBeanServer());
1:7b0c716: 
1:7b0c716:         // If a custom authz proxy was created, attach it to the server now.
1:7b0c716:         if (authzProxy != null)
1:7b0c716:             jmxServer.setMBeanServerForwarder(authzProxy);
1:7b0c716: 
1:9eae8d3:         jmxServer.start();
1:9eae8d3: 
1:9eae8d3:         // use a custom Registry to avoid having to interact with it internally using the remoting interface
1:9eae8d3:         configureRMIRegistry(port, env);
1:9eae8d3: 
1:bdd4a92:         logJmxServiceUrl(serverAddress, port);
1:7b0c716:         return jmxServer;
1:7b0c716:     }
1:7b0c716: 
1:9eae8d3:     private static void configureRMIRegistry(int port, Map<String, Object> env) throws RemoteException
1:9eae8d3:     {
1:9eae8d3:         Exporter exporter = (Exporter)env.get(RMIExporter.EXPORTER_ATTRIBUTE);
1:9eae8d3:         // If ssl is enabled, make sure it's also in place for the RMI registry
1:9eae8d3:         // by using the SSL socket factories already created and stashed in env
1:9eae8d3:         if (Boolean.getBoolean("com.sun.management.jmxremote.ssl"))
1:9eae8d3:         {
1:9eae8d3:             registry = new Registry(port,
1:9eae8d3:                                    (RMIClientSocketFactory)env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),
1:9eae8d3:                                    (RMIServerSocketFactory)env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),
1:9eae8d3:                                    exporter.connectorServer);
1:9eae8d3:         }
1:9eae8d3:         else
1:9eae8d3:         {
1:9eae8d3:             registry = new Registry(port, exporter.connectorServer);
1:9eae8d3:         }
1:9eae8d3:     }
1:9eae8d3: 
1:7b0c716:     private static Map<String, Object> configureJmxAuthentication()
1:7b0c716:     {
1:7b0c716:         Map<String, Object> env = new HashMap<>();
1:7b0c716:         if (!Boolean.getBoolean("com.sun.management.jmxremote.authenticate"))
1:7b0c716:             return env;
1:7b0c716: 
1:7b0c716:         // If authentication is enabled, initialize the appropriate JMXAuthenticator
1:7b0c716:         // and stash it in the environment settings.
1:7b0c716:         // A JAAS configuration entry takes precedence. If one is supplied, use
1:7b0c716:         // Cassandra's own custom JMXAuthenticator implementation which delegates
1:7b0c716:         // auth to the LoginModules specified by the JAAS configuration entry.
1:7b0c716:         // If no JAAS entry is found, an instance of the JDK's own
1:7b0c716:         // JMXPluggableAuthenticator is created. In that case, the admin may have
1:7b0c716:         // set a location for the JMX password file which must be added to env
1:7b0c716:         // before creating the authenticator. If no password file has been
1:7b0c716:         // explicitly set, it's read from the default location
1:7b0c716:         // $JAVA_HOME/lib/management/jmxremote.password
1:7b0c716:         String configEntry = System.getProperty("cassandra.jmx.remote.login.config");
1:7b0c716:         if (configEntry != null)
1:7b0c716:         {
1:7b0c716:             env.put(JMXConnectorServer.AUTHENTICATOR, new AuthenticationProxy(configEntry));
1:7b0c716:         }
3:7b0c716:         else
1:7b0c716:         {
1:7b0c716:             String passwordFile = System.getProperty("com.sun.management.jmxremote.password.file");
1:7b0c716:             if (passwordFile != null)
1:7b0c716:             {
1:7b0c716:                 // stash the password file location where JMXPluggableAuthenticator expects it
1:7b0c716:                 env.put("jmx.remote.x.password.file", passwordFile);
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             env.put(JMXConnectorServer.AUTHENTICATOR, new JMXPluggableAuthenticatorWrapper(env));
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         return env;
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static MBeanServerForwarder configureJmxAuthorization(Map<String, Object> env)
1:7b0c716:     {
1:7b0c716:         // If a custom authz proxy is supplied (Cassandra ships with AuthorizationProxy, which
1:7b0c716:         // delegates to its own role based IAuthorizer), then instantiate and return one which
1:7b0c716:         // can be set as the JMXConnectorServer's MBeanServerForwarder.
1:7b0c716:         // If no custom proxy is supplied, check system properties for the location of the
1:7b0c716:         // standard access file & stash it in env
1:7b0c716:         String authzProxyClass = System.getProperty("cassandra.jmx.authorizer");
1:7b0c716:         if (authzProxyClass != null)
1:7b0c716:         {
1:7b0c716:             final InvocationHandler handler = FBUtilities.construct(authzProxyClass, "JMX authz proxy");
1:7b0c716:             final Class[] interfaces = { MBeanServerForwarder.class };
1:7b0c716: 
1:7b0c716:             Object proxy = Proxy.newProxyInstance(MBeanServerForwarder.class.getClassLoader(), interfaces, handler);
1:7b0c716:             return MBeanServerForwarder.class.cast(proxy);
1:7b0c716:         }
1:7b0c716:         else
1:7b0c716:         {
1:7b0c716:             String accessFile = System.getProperty("com.sun.management.jmxremote.access.file");
1:7b0c716:             if (accessFile != null)
1:7b0c716:             {
1:7b0c716:                 env.put("jmx.remote.x.access.file", accessFile);
1:7b0c716:             }
1:7b0c716:             return null;
1:7b0c716:         }
1:7b0c716:     }
1:7b0c716: 
1:9eae8d3:     private static Map<String, Object> configureJmxSocketFactories(InetAddress serverAddress, boolean localOnly)
1:7b0c716:     {
1:7b0c716:         Map<String, Object> env = new HashMap<>();
1:7b0c716:         if (Boolean.getBoolean("com.sun.management.jmxremote.ssl"))
1:7b0c716:         {
1:7b0c716:             boolean requireClientAuth = Boolean.getBoolean("com.sun.management.jmxremote.ssl.need.client.auth");
1:7b0c716:             String[] protocols = null;
1:7b0c716:             String protocolList = System.getProperty("com.sun.management.jmxremote.ssl.enabled.protocols");
1:7b0c716:             if (protocolList != null)
1:7b0c716:             {
1:7b0c716:                 System.setProperty("javax.rmi.ssl.client.enabledProtocols", protocolList);
1:7b0c716:                 protocols = StringUtils.split(protocolList, ',');
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             String[] ciphers = null;
1:7b0c716:             String cipherList = System.getProperty("com.sun.management.jmxremote.ssl.enabled.cipher.suites");
1:7b0c716:             if (cipherList != null)
1:7b0c716:             {
1:7b0c716:                 System.setProperty("javax.rmi.ssl.client.enabledCipherSuites", cipherList);
1:7b0c716:                 ciphers = StringUtils.split(cipherList, ',');
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             SslRMIClientSocketFactory clientFactory = new SslRMIClientSocketFactory();
1:7b0c716:             SslRMIServerSocketFactory serverFactory = new SslRMIServerSocketFactory(ciphers, protocols, requireClientAuth);
1:7b0c716:             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);
1:7b0c716:             env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, clientFactory);
1:7b0c716:             env.put("com.sun.jndi.rmi.factory.socket", clientFactory);
1:7b0c716:             logJmxSslConfig(serverFactory);
1:7b0c716:         }
1:68d2526:         else if (localOnly)
1:7b0c716:         {
1:7b0c716:             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
1:7b0c716:                     new RMIServerSocketFactoryImpl(serverAddress));
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         return env;
1:7b0c716:     }
1:7b0c716: 
1:bdd4a92:     private static void logJmxServiceUrl(InetAddress serverAddress, int port)
1:bdd4a92:     {
1:bdd4a92:         String urlTemplate = "service:jmx:rmi://%1$s/jndi/rmi://%1$s:%2$d/jmxrmi";
1:bdd4a92:         String hostName;
1:bdd4a92:         if (serverAddress == null)
1:bdd4a92:         {
1:bdd4a92:             hostName = FBUtilities.getBroadcastAddress() instanceof Inet6Address ? "[::]" : "0.0.0.0";
1:bdd4a92:         }
1:bdd4a92:         else
1:bdd4a92:         {
1:bdd4a92:             // hostnames based on IPv6 addresses must be wrapped in [ ]
1:bdd4a92:             hostName = serverAddress instanceof Inet6Address
1:bdd4a92:                        ? '[' + serverAddress.getHostAddress() + ']'
1:bdd4a92:                        : serverAddress.getHostAddress();
1:bdd4a92:         }
1:bdd4a92:         String url = String.format(urlTemplate, hostName, port);
1:bdd4a92:         logger.info("Configured JMX server at: {}", url);
1:bdd4a92:     }
1:bdd4a92: 
1:7b0c716:     private static void logJmxSslConfig(SslRMIServerSocketFactory serverFactory)
1:7b0c716:     {
1:7b0c716:         logger.debug("JMX SSL configuration. { protocols: [{}], cipher_suites: [{}], require_client_auth: {} }",
1:7b0c716:                      serverFactory.getEnabledProtocols() == null
1:7b0c716:                      ? "'JVM defaults'"
1:7b0c716:                      : Arrays.stream(serverFactory.getEnabledProtocols()).collect(Collectors.joining("','", "'", "'")),
1:7b0c716:                      serverFactory.getEnabledCipherSuites() == null
1:7b0c716:                      ? "'JVM defaults'"
1:7b0c716:                      : Arrays.stream(serverFactory.getEnabledCipherSuites()).collect(Collectors.joining("','", "'", "'")),
1:7b0c716:                      serverFactory.getNeedClientAuth());
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static class JMXPluggableAuthenticatorWrapper implements JMXAuthenticator
1:7b0c716:     {
1:7b0c716:         final Map<?, ?> env;
1:7b0c716:         private JMXPluggableAuthenticatorWrapper(Map<?, ?> env)
1:7b0c716:         {
1:7b0c716:             this.env = ImmutableMap.copyOf(env);
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         public Subject authenticate(Object credentials)
1:7b0c716:         {
1:7b0c716:             JMXPluggableAuthenticator authenticator = new JMXPluggableAuthenticator(env);
1:7b0c716:             return authenticator.authenticate(credentials);
1:7b0c716:         }
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     /**
1:7b0c716:      * In the RMI subsystem, the ObjectTable instance holds references to remote
1:7b0c716:      * objects for distributed garbage collection purposes. When objects are
1:7b0c716:      * added to the ObjectTable (exported), a flag is passed to * indicate the
1:7b0c716:      * "permanence" of that object. Exporting as permanent has two effects; the
1:7b0c716:      * object is not eligible for distributed garbage collection, and its
1:7b0c716:      * existence will not prevent the JVM from exiting after termination of all
1:7b0c716:      * non-daemon threads terminate. Neither of these is bad for our case, as we
1:7b0c716:      * attach the server exactly once (i.e. at startup, not subsequently using
1:7b0c716:      * the Attach API) and don't disconnect it before shutdown. The primary
1:7b0c716:      * benefit we gain is that it doesn't trigger the scheduled full GC that
1:7b0c716:      * is otherwise incurred by programatically configuring the management server.
1:7b0c716:      *
1:7b0c716:      * To that end, we use this private implementation of RMIExporter to register
1:7b0c716:      * our JMXConnectorServer as a permanent object by adding it to the map of
1:7b0c716:      * environment variables under the key RMIExporter.EXPORTER_ATTRIBUTE
1:7b0c716:      * (com.sun.jmx.remote.rmi.exporter) prior to calling server.start()
1:7b0c716:      *
1:7b0c716:      * See also:
1:7b0c716:      *  * CASSANDRA-2967 for background
1:7b0c716:      *  * https://www.jclarity.com/2015/01/27/rmi-system-gc-unplugged/ for more detail
1:7b0c716:      *  * https://bugs.openjdk.java.net/browse/JDK-6760712 for info on setting the exporter
1:7b0c716:      *  * sun.management.remote.ConnectorBootstrap to trace how the inbuilt management agent
1:7b0c716:      *    sets up the JMXConnectorServer
1:7b0c716:      */
1:7b0c716:     private static class Exporter implements RMIExporter
1:7b0c716:     {
1:9eae8d3:         // the first object to be exported by this instance is *always* the JMXConnectorServer
1:9eae8d3:         // instance created by createJMXServer. Keep a handle to it, as it needs to be supplied
1:9eae8d3:         // to our custom Registry too.
1:9eae8d3:         private Remote connectorServer;
1:9eae8d3: 
1:7b0c716:         public Remote exportObject(Remote obj, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)
1:7b0c716:         throws RemoteException
1:7b0c716:         {
1:9eae8d3:             Remote remote = new UnicastServerRef2(port, csf, ssf).exportObject(obj, null, true);
1:9eae8d3:             // Keep a reference to the first object exported, the JMXConnectorServer
1:9eae8d3:             if (connectorServer == null)
1:9eae8d3:                 connectorServer = remote;
1:7b0c716: 
1:9eae8d3:             return remote;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         public boolean unexportObject(Remote obj, boolean force) throws NoSuchObjectException
1:7b0c716:         {
1:7b0c716:             return UnicastRemoteObject.unexportObject(obj, force);
1:7b0c716:         }
1:7b0c716:     }
1:9eae8d3: 
1:9eae8d3:     /**
1:9eae8d3:      * Using this class avoids the necessity to interact with the registry via its
1:9eae8d3:      * remoting interface. This is necessary because when SSL is enabled for the registry,
1:9eae8d3:      * that remote interaction is treated just the same as one from an external client.
1:9eae8d3:      * That is problematic when binding the JMXConnectorServer to the Registry as it requires
1:9eae8d3:      * the client, which in this case is our own internal code, to connect like any other SSL
1:9eae8d3:      * client, meaning we need a truststore containing our own certificate.
1:9eae8d3:      * This bypasses the binding API completely, which emulates the behaviour of
1:9eae8d3:      * ConnectorBootstrap when the subsystem is initialized by the JVM Agent directly.
1:9eae8d3:      *
1:9eae8d3:      * See CASSANDRA-12109.
1:9eae8d3:      */
1:9eae8d3:     private static class Registry extends RegistryImpl
1:9eae8d3:     {
1:9eae8d3:         private final static String KEY = "jmxrmi";
1:9eae8d3:         private final Remote connectorServer;
1:9eae8d3: 
1:9eae8d3:         private Registry(int port, Remote connectorServer) throws RemoteException
1:9eae8d3:         {
1:9eae8d3:             super(port);
1:9eae8d3:             this.connectorServer = connectorServer;
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         private Registry(int port,
1:9eae8d3:                          RMIClientSocketFactory csf,
1:9eae8d3:                          RMIServerSocketFactory ssf,
1:9eae8d3:                          Remote connectorServer) throws RemoteException
1:9eae8d3:         {
1:9eae8d3:             super(port, csf, ssf);
1:9eae8d3:             this.connectorServer = connectorServer;
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         public Remote lookup(String name) throws RemoteException, NotBoundException
1:9eae8d3:         {
1:9eae8d3:             if (name.equals(KEY))
1:9eae8d3:                 return connectorServer;
1:9eae8d3: 
1:9eae8d3:             throw new NotBoundException(String.format("Only the JMX Connector Server named %s " +
1:9eae8d3:                                                       "is bound in this registry", KEY));
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         public void bind(String name, Remote obj) throws RemoteException, AlreadyBoundException
1:9eae8d3:         {
1:9eae8d3:             throw new UnsupportedOperationException("Unsupported");
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         public void unbind(String name) throws RemoteException, NotBoundException
1:9eae8d3:         {
1:9eae8d3:             throw new UnsupportedOperationException("Unsupported");
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         public void rebind(String name, Remote obj) throws RemoteException
1:9eae8d3:         {
1:9eae8d3:             throw new UnsupportedOperationException("Unsupported");
1:9eae8d3:         }
1:9eae8d3: 
1:9eae8d3:         public String[] list() throws RemoteException
1:9eae8d3:         {
1:9eae8d3:             return new String[] {KEY};
1:9eae8d3:         }
1:9eae8d3:     }
1:7b0c716: }
============================================================================
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:bdd4a92
/////////////////////////////////////////////////////////////////////////
1: import java.net.Inet6Address;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         logJmxServiceUrl(serverAddress, port);
/////////////////////////////////////////////////////////////////////////
1:     private static void logJmxServiceUrl(InetAddress serverAddress, int port)
1:     {
1:         String urlTemplate = "service:jmx:rmi://%1$s/jndi/rmi://%1$s:%2$d/jmxrmi";
1:         String hostName;
1:         if (serverAddress == null)
1:         {
1:             hostName = FBUtilities.getBroadcastAddress() instanceof Inet6Address ? "[::]" : "0.0.0.0";
1:         }
1:         else
1:         {
1:             // hostnames based on IPv6 addresses must be wrapped in [ ]
1:             hostName = serverAddress instanceof Inet6Address
1:                        ? '[' + serverAddress.getHostAddress() + ']'
1:                        : serverAddress.getHostAddress();
1:         }
1:         String url = String.format(urlTemplate, hostName, port);
1:         logger.info("Configured JMX server at: {}", url);
1:     }
1: 
commit:9eae8d3
/////////////////////////////////////////////////////////////////////////
1: import java.rmi.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
1: import sun.rmi.registry.RegistryImpl;
1:     private static java.rmi.registry.Registry registry;
/////////////////////////////////////////////////////////////////////////
1:         env.putAll(configureJmxSocketFactories(serverAddress, local));
/////////////////////////////////////////////////////////////////////////
0:         String url = String.format(urlTemplate, (serverAddress != null ? serverAddress.getHostAddress() : "0.0.0.0"), port);
1: 
1:         int rmiPort = Integer.getInteger("com.sun.management.jmxremote.rmi.port", 0);
1:             JMXConnectorServerFactory.newJMXConnectorServer(new JMXServiceURL("rmi", null, rmiPort),
/////////////////////////////////////////////////////////////////////////
1:         jmxServer.start();
1: 
1:         // use a custom Registry to avoid having to interact with it internally using the remoting interface
1:         configureRMIRegistry(port, env);
1: 
1:     private static void configureRMIRegistry(int port, Map<String, Object> env) throws RemoteException
1:     {
1:         Exporter exporter = (Exporter)env.get(RMIExporter.EXPORTER_ATTRIBUTE);
1:         // If ssl is enabled, make sure it's also in place for the RMI registry
1:         // by using the SSL socket factories already created and stashed in env
1:         if (Boolean.getBoolean("com.sun.management.jmxremote.ssl"))
1:         {
1:             registry = new Registry(port,
1:                                    (RMIClientSocketFactory)env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),
1:                                    (RMIServerSocketFactory)env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),
1:                                    exporter.connectorServer);
1:         }
1:         else
1:         {
1:             registry = new Registry(port, exporter.connectorServer);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static Map<String, Object> configureJmxSocketFactories(InetAddress serverAddress, boolean localOnly)
/////////////////////////////////////////////////////////////////////////
0:         else if (localOnly){
/////////////////////////////////////////////////////////////////////////
1:         // the first object to be exported by this instance is *always* the JMXConnectorServer
1:         // instance created by createJMXServer. Keep a handle to it, as it needs to be supplied
1:         // to our custom Registry too.
1:         private Remote connectorServer;
1: 
1:             Remote remote = new UnicastServerRef2(port, csf, ssf).exportObject(obj, null, true);
1:             // Keep a reference to the first object exported, the JMXConnectorServer
1:             if (connectorServer == null)
1:                 connectorServer = remote;
1:             return remote;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Using this class avoids the necessity to interact with the registry via its
1:      * remoting interface. This is necessary because when SSL is enabled for the registry,
1:      * that remote interaction is treated just the same as one from an external client.
1:      * That is problematic when binding the JMXConnectorServer to the Registry as it requires
1:      * the client, which in this case is our own internal code, to connect like any other SSL
1:      * client, meaning we need a truststore containing our own certificate.
1:      * This bypasses the binding API completely, which emulates the behaviour of
1:      * ConnectorBootstrap when the subsystem is initialized by the JVM Agent directly.
1:      *
1:      * See CASSANDRA-12109.
1:      */
1:     private static class Registry extends RegistryImpl
1:     {
1:         private final static String KEY = "jmxrmi";
1:         private final Remote connectorServer;
1: 
1:         private Registry(int port, Remote connectorServer) throws RemoteException
1:         {
1:             super(port);
1:             this.connectorServer = connectorServer;
1:         }
1: 
1:         private Registry(int port,
1:                          RMIClientSocketFactory csf,
1:                          RMIServerSocketFactory ssf,
1:                          Remote connectorServer) throws RemoteException
1:         {
1:             super(port, csf, ssf);
1:             this.connectorServer = connectorServer;
1:         }
1: 
1:         public Remote lookup(String name) throws RemoteException, NotBoundException
1:         {
1:             if (name.equals(KEY))
1:                 return connectorServer;
1: 
1:             throw new NotBoundException(String.format("Only the JMX Connector Server named %s " +
1:                                                       "is bound in this registry", KEY));
1:         }
1: 
1:         public void bind(String name, Remote obj) throws RemoteException, AlreadyBoundException
1:         {
1:             throw new UnsupportedOperationException("Unsupported");
1:         }
1: 
1:         public void unbind(String name) throws RemoteException, NotBoundException
1:         {
1:             throw new UnsupportedOperationException("Unsupported");
1:         }
1: 
1:         public void rebind(String name, Remote obj) throws RemoteException
1:         {
1:             throw new UnsupportedOperationException("Unsupported");
1:         }
1: 
1:         public String[] list() throws RemoteException
1:         {
1:             return new String[] {KEY};
1:         }
1:     }
commit:c17cbe1
/////////////////////////////////////////////////////////////////////////
1:         InetAddress serverAddress = null;
1:             System.setProperty("java.rmi.server.hostname", serverAddress.getHostAddress());
0:         String url = String.format(urlTemplate, (serverAddress != null ? serverAddress.getHostAddress() : "0.0.0.0"), port);
commit:7b0c716
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.utils;
1: 
1: import java.io.IOException;
1: import java.lang.management.ManagementFactory;
1: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.Proxy;
1: import java.net.InetAddress;
0: import java.rmi.NoSuchObjectException;
0: import java.rmi.Remote;
0: import java.rmi.RemoteException;
0: import java.rmi.registry.LocateRegistry;
1: import java.rmi.server.RMIClientSocketFactory;
1: import java.rmi.server.RMIServerSocketFactory;
1: import java.rmi.server.UnicastRemoteObject;
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.stream.Collectors;
1: import javax.management.remote.*;
1: import javax.management.remote.rmi.RMIConnectorServer;
0: import javax.management.remote.rmi.RMIJRMPServerImpl;
1: import javax.rmi.ssl.SslRMIClientSocketFactory;
1: import javax.rmi.ssl.SslRMIServerSocketFactory;
1: import javax.security.auth.Subject;
1: 
1: import com.google.common.collect.ImmutableMap;
1: import org.apache.commons.lang3.StringUtils;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import com.sun.jmx.remote.internal.RMIExporter;
1: import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
1: import org.apache.cassandra.auth.jmx.AuthenticationProxy;
1: import sun.rmi.server.UnicastServerRef2;
1: 
1: public class JMXServerUtils
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(JMXServerUtils.class);
1: 
1: 
1:     /**
1:      * Creates a server programmatically. This allows us to set parameters which normally are
1:      * inaccessable.
1:      */
1:     public static JMXConnectorServer createJMXServer(int port, boolean local)
1:     throws IOException
1:     {
1:         Map<String, Object> env = new HashMap<>();
1: 
0:         String urlTemplate = "service:jmx:rmi://%1$s/jndi/rmi://%1$s:%2$d/jmxrmi";
0:         String url;
0:         String host;
0:         InetAddress serverAddress;
1:         if (local)
1:         {
1:             serverAddress = InetAddress.getLoopbackAddress();
0:             host = serverAddress.getHostAddress();
0:             System.setProperty("java.rmi.server.hostname", host);
1:         }
1:         else
1:         {
0:             // if the java.rmi.server.hostname property is set, we'll take its value
0:             // and use that when creating the RMIServerSocket to which we bind the RMI
0:             // registry. This allows us to effectively restrict to a single interface
0:             // if required. See http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4880793
0:             // for more detail. If the hostname property is not set, the registry will
0:             // be bound to the wildcard address
0:             host = System.getProperty("java.rmi.server.hostname");
0:             serverAddress = host == null ? null : InetAddress.getByName(host);
1:         }
1: 
1:         // Configure the RMI client & server socket factories, including SSL config.
0:         env.putAll(configureJmxSocketFactories(serverAddress));
1: 
0:         url = String.format(urlTemplate, (host == null ? "0.0.0.0" : serverAddress.getHostAddress()), port);
0:         LocateRegistry.createRegistry(port,
0:                                      (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),
0:                                      (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE));
1: 
1:         // Configure authn, using a JMXAuthenticator which either wraps a set log LoginModules configured
1:         // via a JAAS configuration entry, or one which delegates to the standard file based authenticator.
1:         // Authn is disabled if com.sun.management.jmxremote.authenticate=false
1:         env.putAll(configureJmxAuthentication());
1: 
1:         // Configure authz - if a custom proxy class is specified an instance will be returned.
1:         // If not, but a location for the standard access file is set in system properties, the
1:         // return value is null, and an entry is added to the env map detailing that location
1:         // If neither method is specified, no access control is applied
1:         MBeanServerForwarder authzProxy = configureJmxAuthorization(env);
1: 
1:         // Make sure we use our custom exporter so a full GC doesn't get scheduled every
1:         // sun.rmi.dgc.server.gcInterval millis (default is 3600000ms/1 hour)
1:         env.put(RMIExporter.EXPORTER_ATTRIBUTE, new Exporter());
1: 
1:         JMXConnectorServer jmxServer =
0:             JMXConnectorServerFactory.newJMXConnectorServer(new JMXServiceURL(url),
1:                                                             env,
1:                                                             ManagementFactory.getPlatformMBeanServer());
1: 
1:         // If a custom authz proxy was created, attach it to the server now.
1:         if (authzProxy != null)
1:             jmxServer.setMBeanServerForwarder(authzProxy);
1: 
0:         logger.info("Configured JMX server at: {}", url);
1:         return jmxServer;
1:     }
1: 
1:     private static Map<String, Object> configureJmxAuthentication()
1:     {
1:         Map<String, Object> env = new HashMap<>();
1:         if (!Boolean.getBoolean("com.sun.management.jmxremote.authenticate"))
1:             return env;
1: 
1:         // If authentication is enabled, initialize the appropriate JMXAuthenticator
1:         // and stash it in the environment settings.
1:         // A JAAS configuration entry takes precedence. If one is supplied, use
1:         // Cassandra's own custom JMXAuthenticator implementation which delegates
1:         // auth to the LoginModules specified by the JAAS configuration entry.
1:         // If no JAAS entry is found, an instance of the JDK's own
1:         // JMXPluggableAuthenticator is created. In that case, the admin may have
1:         // set a location for the JMX password file which must be added to env
1:         // before creating the authenticator. If no password file has been
1:         // explicitly set, it's read from the default location
1:         // $JAVA_HOME/lib/management/jmxremote.password
1:         String configEntry = System.getProperty("cassandra.jmx.remote.login.config");
1:         if (configEntry != null)
1:         {
1:             env.put(JMXConnectorServer.AUTHENTICATOR, new AuthenticationProxy(configEntry));
1:         }
1:         else
1:         {
1:             String passwordFile = System.getProperty("com.sun.management.jmxremote.password.file");
1:             if (passwordFile != null)
1:             {
1:                 // stash the password file location where JMXPluggableAuthenticator expects it
1:                 env.put("jmx.remote.x.password.file", passwordFile);
1:             }
1: 
1:             env.put(JMXConnectorServer.AUTHENTICATOR, new JMXPluggableAuthenticatorWrapper(env));
1:         }
1: 
1:         return env;
1:     }
1: 
1:     private static MBeanServerForwarder configureJmxAuthorization(Map<String, Object> env)
1:     {
1:         // If a custom authz proxy is supplied (Cassandra ships with AuthorizationProxy, which
1:         // delegates to its own role based IAuthorizer), then instantiate and return one which
1:         // can be set as the JMXConnectorServer's MBeanServerForwarder.
1:         // If no custom proxy is supplied, check system properties for the location of the
1:         // standard access file & stash it in env
1:         String authzProxyClass = System.getProperty("cassandra.jmx.authorizer");
1:         if (authzProxyClass != null)
1:         {
1:             final InvocationHandler handler = FBUtilities.construct(authzProxyClass, "JMX authz proxy");
1:             final Class[] interfaces = { MBeanServerForwarder.class };
1: 
1:             Object proxy = Proxy.newProxyInstance(MBeanServerForwarder.class.getClassLoader(), interfaces, handler);
1:             return MBeanServerForwarder.class.cast(proxy);
1:         }
1:         else
1:         {
1:             String accessFile = System.getProperty("com.sun.management.jmxremote.access.file");
1:             if (accessFile != null)
1:             {
1:                 env.put("jmx.remote.x.access.file", accessFile);
1:             }
1:             return null;
1:         }
1:     }
1: 
0:     private static Map<String, Object> configureJmxSocketFactories(InetAddress serverAddress)
1:     {
1:         Map<String, Object> env = new HashMap<>();
1:         if (Boolean.getBoolean("com.sun.management.jmxremote.ssl"))
1:         {
1:             boolean requireClientAuth = Boolean.getBoolean("com.sun.management.jmxremote.ssl.need.client.auth");
1:             String[] protocols = null;
1:             String protocolList = System.getProperty("com.sun.management.jmxremote.ssl.enabled.protocols");
1:             if (protocolList != null)
1:             {
1:                 System.setProperty("javax.rmi.ssl.client.enabledProtocols", protocolList);
1:                 protocols = StringUtils.split(protocolList, ',');
1:             }
1: 
1:             String[] ciphers = null;
1:             String cipherList = System.getProperty("com.sun.management.jmxremote.ssl.enabled.cipher.suites");
1:             if (cipherList != null)
1:             {
1:                 System.setProperty("javax.rmi.ssl.client.enabledCipherSuites", cipherList);
1:                 ciphers = StringUtils.split(cipherList, ',');
1:             }
1: 
1:             SslRMIClientSocketFactory clientFactory = new SslRMIClientSocketFactory();
1:             SslRMIServerSocketFactory serverFactory = new SslRMIServerSocketFactory(ciphers, protocols, requireClientAuth);
1:             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);
1:             env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, clientFactory);
1:             env.put("com.sun.jndi.rmi.factory.socket", clientFactory);
1:             logJmxSslConfig(serverFactory);
1:         }
1:         else
1:         {
1:             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
1:                     new RMIServerSocketFactoryImpl(serverAddress));
1:         }
1: 
1:         return env;
1:     }
1: 
1:     private static void logJmxSslConfig(SslRMIServerSocketFactory serverFactory)
1:     {
1:         logger.debug("JMX SSL configuration. { protocols: [{}], cipher_suites: [{}], require_client_auth: {} }",
1:                      serverFactory.getEnabledProtocols() == null
1:                      ? "'JVM defaults'"
1:                      : Arrays.stream(serverFactory.getEnabledProtocols()).collect(Collectors.joining("','", "'", "'")),
1:                      serverFactory.getEnabledCipherSuites() == null
1:                      ? "'JVM defaults'"
1:                      : Arrays.stream(serverFactory.getEnabledCipherSuites()).collect(Collectors.joining("','", "'", "'")),
1:                      serverFactory.getNeedClientAuth());
1:     }
1: 
1:     private static class JMXPluggableAuthenticatorWrapper implements JMXAuthenticator
1:     {
1:         final Map<?, ?> env;
1:         private JMXPluggableAuthenticatorWrapper(Map<?, ?> env)
1:         {
1:             this.env = ImmutableMap.copyOf(env);
1:         }
1: 
1:         public Subject authenticate(Object credentials)
1:         {
1:             JMXPluggableAuthenticator authenticator = new JMXPluggableAuthenticator(env);
1:             return authenticator.authenticate(credentials);
1:         }
1:     }
1: 
1:     /**
1:      * In the RMI subsystem, the ObjectTable instance holds references to remote
1:      * objects for distributed garbage collection purposes. When objects are
1:      * added to the ObjectTable (exported), a flag is passed to * indicate the
1:      * "permanence" of that object. Exporting as permanent has two effects; the
1:      * object is not eligible for distributed garbage collection, and its
1:      * existence will not prevent the JVM from exiting after termination of all
1:      * non-daemon threads terminate. Neither of these is bad for our case, as we
1:      * attach the server exactly once (i.e. at startup, not subsequently using
1:      * the Attach API) and don't disconnect it before shutdown. The primary
1:      * benefit we gain is that it doesn't trigger the scheduled full GC that
1:      * is otherwise incurred by programatically configuring the management server.
1:      *
1:      * To that end, we use this private implementation of RMIExporter to register
1:      * our JMXConnectorServer as a permanent object by adding it to the map of
1:      * environment variables under the key RMIExporter.EXPORTER_ATTRIBUTE
1:      * (com.sun.jmx.remote.rmi.exporter) prior to calling server.start()
1:      *
1:      * See also:
1:      *  * CASSANDRA-2967 for background
1:      *  * https://www.jclarity.com/2015/01/27/rmi-system-gc-unplugged/ for more detail
1:      *  * https://bugs.openjdk.java.net/browse/JDK-6760712 for info on setting the exporter
1:      *  * sun.management.remote.ConnectorBootstrap to trace how the inbuilt management agent
1:      *    sets up the JMXConnectorServer
1:      */
1:     private static class Exporter implements RMIExporter
1:     {
1:         public Remote exportObject(Remote obj, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)
1:         throws RemoteException
1:         {
0:             // We should only ever get here by configuring our own JMX Connector server,
0:             // so assert some invariants we expect to be true in that case
0:             assert ssf != null; // we always configure a custom server socket factory
1: 
0:             // as we always configure a custom server socket factory, either for SSL or to ensure
0:             // only loopback addresses, we use a UnicastServerRef2 for exporting
0:             return new UnicastServerRef2(port, csf, ssf).exportObject(obj, null, true);
1:         }
1: 
1:         public boolean unexportObject(Remote obj, boolean force) throws NoSuchObjectException
1:         {
1:             return UnicastRemoteObject.unexportObject(obj, force);
1:         }
1:     }
1: }
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:         else if (localOnly)
0:         {
============================================================================