1:8704006: /*
1:8704006: * Licensed to the Apache Software Foundation (ASF) under one
1:8704006: * or more contributor license agreements.  See the NOTICE file
1:8704006: * distributed with this work for additional information
1:8704006: * regarding copyright ownership.  The ASF licenses this file
1:8704006: * to you under the Apache License, Version 2.0 (the
1:8704006: * "License"); you may not use this file except in compliance
1:8704006: * with the License.  You may obtain a copy of the License at
1:8704006: *
1:8704006: *    http://www.apache.org/licenses/LICENSE-2.0
1:8704006: *
1:8704006: * Unless required by applicable law or agreed to in writing,
1:8704006: * software distributed under the License is distributed on an
1:8704006: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:8704006: * KIND, either express or implied.  See the License for the
1:8704006: * specific language governing permissions and limitations
1:8704006: * under the License.
1:8704006: */
1:8704006: package org.apache.cassandra.utils.concurrent;
5:8704006: 
1:8704006: import static org.apache.cassandra.utils.Throwables.maybeFail;
1:8704006: import static org.apache.cassandra.utils.Throwables.merge;
1:8704006: 
1:8704006: /**
1:8704006:  * An abstraction for Transactional behaviour. An object implementing this interface has a lifetime
1:8704006:  * of the following pattern:
1:8704006:  *
1:8704006:  * Throwable failure = null;
1:8704006:  * try (Transactional t1, t2 = ...)
1:8704006:  * {
1:8704006:  *     // do work with t1 and t2
1:8704006:  *     t1.prepareToCommit();
1:8704006:  *     t2.prepareToCommit();
1:8704006:  *     failure = t1.commit(failure);
1:8704006:  *     failure = t2.commit(failure);
1:8704006:  * }
1:8704006:  * logger.error(failure);
1:8704006:  *
1:8704006:  * If something goes wrong before commit() is called on any transaction, then on exiting the try block
1:8704006:  * the auto close method should invoke cleanup() and then abort() to reset any state.
1:8704006:  * If everything completes normally, then on exiting the try block the auto close method will invoke cleanup
1:8704006:  * to release any temporary state/resources
1:8704006:  *
1:b09e60f:  * All exceptions and assertions that may be thrown should be checked and ruled out during commit preparation.
1:b09e60f:  * Commit should generally never throw an exception unless there is a real correctness-affecting exception that
1:b09e60f:  * cannot be moved to prepareToCommit, in which case this operation MUST be executed before any other commit
1:b09e60f:  * methods in the object graph.
1:b09e60f:  *
1:b09e60f:  * If exceptions are generated by commit after this initial moment, it is not at all clear what the correct behaviour
1:8704006:  * of the system should be, and so simply logging the exception is likely best (since it may have been an issue
1:8704006:  * during cleanup, say), and rollback cannot now occur. As such all exceptions and assertions that may be thrown
1:8704006:  * should be checked and ruled out during commit preparation.
1:a3fc425:  *
1:a3fc425:  * Since Transactional implementations will abort any changes they've made if calls to prepareToCommit() and commit()
1:a3fc425:  * aren't made prior to calling close(), the semantics of its close() method differ significantly from
1:a3fc425:  * most AutoCloseable implementations.
1:8704006:  */
1:8704006: public interface Transactional extends AutoCloseable
1:8704006: {
1:8704006:     /**
1:8704006:      * A simple abstract implementation of Transactional behaviour.
1:8704006:      * In general this should be used as the base class for any transactional implementations.
1:8704006:      *
1:8704006:      * If the implementation wraps any internal Transactional objects, it must proxy every
1:8704006:      * commit() and abort() call onto each internal object to ensure correct behaviour
1:8704006:      */
1:b09e60f:     abstract class AbstractTransactional implements Transactional
1:8704006:     {
1:b09e60f:         public enum State
1:8704006:         {
1:8704006:             IN_PROGRESS,
1:8704006:             READY_TO_COMMIT,
1:8704006:             COMMITTED,
1:8704006:             ABORTED;
1:8704006:         }
1:8704006: 
1:e5a76bd:         private boolean permitRedundantTransitions;
1:8704006:         private State state = State.IN_PROGRESS;
1:8704006: 
1:8704006:         // the methods for actually performing the necessary behaviours, that are themselves protected against
1:8704006:         // improper use by the external implementations provided by this class. empty default implementations
1:8704006:         // could be provided, but we consider it safer to force implementers to consider explicitly their presence
1:8704006: 
1:8704006:         protected abstract Throwable doCommit(Throwable accumulate);
1:8704006:         protected abstract Throwable doAbort(Throwable accumulate);
1:8704006: 
1:e5a76bd:         // these only needs to perform cleanup of state unique to this instance; any internal
1:8704006:         // Transactional objects will perform cleanup in the commit() or abort() calls
1:e5a76bd: 
1:e5a76bd:         /**
1:c163d0b:          * perform an exception-safe pre-abort/commit cleanup;
1:c163d0b:          * this will be run after prepareToCommit (so before commit), and before abort
1:e5a76bd:          */
1:e5a76bd:         protected Throwable doPreCleanup(Throwable accumulate){ return accumulate; }
1:e5a76bd: 
1:e5a76bd:         /**
1:e5a76bd:          * perform an exception-safe post-abort cleanup
1:e5a76bd:          */
1:e5a76bd:         protected Throwable doPostCleanup(Throwable accumulate){ return accumulate; }
1:8704006: 
1:8704006:         /**
1:8704006:          * Do any preparatory work prior to commit. This method should throw any exceptions that can be encountered
1:8704006:          * during the finalization of the behaviour.
1:8704006:          */
1:8704006:         protected abstract void doPrepare();
1:8704006: 
1:8704006:         /**
1:8704006:          * commit any effects of this transaction object graph, then cleanup; delegates first to doCommit, then to doCleanup
1:8704006:          */
1:8704006:         public final Throwable commit(Throwable accumulate)
1:8704006:         {
1:e5a76bd:             if (permitRedundantTransitions && state == State.COMMITTED)
1:e5a76bd:                 return accumulate;
1:8704006:             if (state != State.READY_TO_COMMIT)
1:e5a76bd:                 throw new IllegalStateException("Cannot commit unless READY_TO_COMMIT; state is " + state);
1:8704006:             accumulate = doCommit(accumulate);
1:e5a76bd:             accumulate = doPostCleanup(accumulate);
1:8704006:             state = State.COMMITTED;
1:8704006:             return accumulate;
1:8704006:         }
1:8704006: 
1:8704006:         /**
1:8704006:          * rollback any effects of this transaction object graph; delegates first to doCleanup, then to doAbort
1:8704006:          */
1:8704006:         public final Throwable abort(Throwable accumulate)
1:8704006:         {
1:8704006:             if (state == State.ABORTED)
1:8704006:                 return accumulate;
1:8704006:             if (state == State.COMMITTED)
1:8704006:             {
1:8704006:                 try
1:8704006:                 {
1:8704006:                     throw new IllegalStateException("Attempted to abort a committed operation");
1:8704006:                 }
1:8704006:                 catch (Throwable t)
1:8704006:                 {
1:8704006:                     accumulate = merge(accumulate, t);
1:8704006:                 }
1:8704006:                 return accumulate;
1:8704006:             }
1:8704006:             state = State.ABORTED;
1:8704006:             // we cleanup first so that, e.g., file handles can be released prior to deletion
1:e5a76bd:             accumulate = doPreCleanup(accumulate);
1:8704006:             accumulate = doAbort(accumulate);
1:e5a76bd:             accumulate = doPostCleanup(accumulate);
1:8704006:             return accumulate;
1:8704006:         }
1:8704006: 
1:8704006:         // if we are committed or aborted, then we are done; otherwise abort
1:8704006:         public final void close()
1:8704006:         {
1:8704006:             switch (state)
1:8704006:             {
1:8704006:                 case COMMITTED:
1:8704006:                 case ABORTED:
1:8704006:                     break;
1:8704006:                 default:
1:8704006:                     abort();
1:8704006:             }
1:8704006:         }
1:8704006: 
1:8704006:         /**
1:8704006:          * The first phase of commit: delegates to doPrepare(), with valid state transition enforcement.
1:8704006:          * This call should be propagated onto any child objects participating in the transaction
1:8704006:          */
1:8704006:         public final void prepareToCommit()
1:8704006:         {
1:e5a76bd:             if (permitRedundantTransitions && state == State.READY_TO_COMMIT)
1:e5a76bd:                 return;
1:8704006:             if (state != State.IN_PROGRESS)
1:8704006:                 throw new IllegalStateException("Cannot prepare to commit unless IN_PROGRESS; state is " + state);
1:8704006: 
1:8704006:             doPrepare();
1:c163d0b:             maybeFail(doPreCleanup(null));
1:8704006:             state = State.READY_TO_COMMIT;
1:8704006:         }
1:8704006: 
1:8704006:         /**
1:8704006:          * convenience method to both prepareToCommit() and commit() in one operation;
1:8704006:          * only of use to outer-most transactional object of an object graph
1:8704006:          */
1:8704006:         public Object finish()
1:8704006:         {
1:8704006:             prepareToCommit();
1:8704006:             commit();
1:8704006:             return this;
1:8704006:         }
1:8704006: 
1:8704006:         // convenience method wrapping abort, and throwing any exception encountered
1:8704006:         // only of use to (and to be used by) outer-most object in a transactional graph
1:8704006:         public final void abort()
1:8704006:         {
1:8704006:             maybeFail(abort(null));
1:8704006:         }
1:8704006: 
1:8704006:         // convenience method wrapping commit, and throwing any exception encountered
1:8704006:         // only of use to (and to be used by) outer-most object in a transactional graph
1:8704006:         public final void commit()
1:8704006:         {
1:8704006:             maybeFail(commit(null));
1:8704006:         }
1:8704006: 
1:8704006:         public final State state()
1:8704006:         {
1:8704006:             return state;
1:8704006:         }
1:e5a76bd: 
1:e5a76bd:         protected void permitRedundantTransitions()
1:e5a76bd:         {
1:e5a76bd:             permitRedundantTransitions = true;
1:e5a76bd:         }
1:8704006:     }
1:8704006: 
1:8704006:     // commit should generally never throw an exception, and preferably never generate one,
1:8704006:     // but if it does generate one it should accumulate it in the parameter and return the result
1:8704006:     // IF a commit implementation has a real correctness affecting exception that cannot be moved to
1:8704006:     // prepareToCommit, it MUST be executed before any other commit methods in the object graph
1:b09e60f:     Throwable commit(Throwable accumulate);
1:8704006: 
1:8704006:     // release any resources, then rollback all state changes (unless commit() has already been invoked)
1:b09e60f:     Throwable abort(Throwable accumulate);
1:e777301: 
1:b09e60f:     void prepareToCommit();
1:127f7c5: 
1:127f7c5:     // close() does not throw
1:127f7c5:     public void close();
1:8704006: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:127f7c5
/////////////////////////////////////////////////////////////////////////
1: 
1:     // close() does not throw
1:     public void close();
commit:e777301
/////////////////////////////////////////////////////////////////////////
1: 
0:     // close() does not throw
0:     public void close();
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:c163d0b
/////////////////////////////////////////////////////////////////////////
1:          * perform an exception-safe pre-abort/commit cleanup;
1:          * this will be run after prepareToCommit (so before commit), and before abort
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             maybeFail(doPreCleanup(null));
commit:b09e60f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * All exceptions and assertions that may be thrown should be checked and ruled out during commit preparation.
1:  * Commit should generally never throw an exception unless there is a real correctness-affecting exception that
1:  * cannot be moved to prepareToCommit, in which case this operation MUST be executed before any other commit
1:  * methods in the object graph.
1:  *
1:  * If exceptions are generated by commit after this initial moment, it is not at all clear what the correct behaviour
0:  * during cleanup, say), and rollback cannot now occur.
/////////////////////////////////////////////////////////////////////////
1:     abstract class AbstractTransactional implements Transactional
1:         public enum State
/////////////////////////////////////////////////////////////////////////
1:     Throwable commit(Throwable accumulate);
1:     Throwable abort(Throwable accumulate);
1:     void prepareToCommit();
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:1c27abf
commit:e5a76bd
/////////////////////////////////////////////////////////////////////////
1:         private boolean permitRedundantTransitions;
/////////////////////////////////////////////////////////////////////////
1:         // these only needs to perform cleanup of state unique to this instance; any internal
1: 
1:         /**
0:          * perform an exception-safe pre-abort cleanup; this will still be run *after* commit
1:          */
1:         protected Throwable doPreCleanup(Throwable accumulate){ return accumulate; }
1: 
1:         /**
1:          * perform an exception-safe post-abort cleanup
1:          */
1:         protected Throwable doPostCleanup(Throwable accumulate){ return accumulate; }
/////////////////////////////////////////////////////////////////////////
1:             if (permitRedundantTransitions && state == State.COMMITTED)
1:                 return accumulate;
1:                 throw new IllegalStateException("Cannot commit unless READY_TO_COMMIT; state is " + state);
1:             accumulate = doPreCleanup(accumulate);
1:             accumulate = doPostCleanup(accumulate);
/////////////////////////////////////////////////////////////////////////
0:             accumulate = doPreCleanup(accumulate);
1:             accumulate = doPostCleanup(accumulate);
/////////////////////////////////////////////////////////////////////////
1:             if (permitRedundantTransitions && state == State.READY_TO_COMMIT)
1:                 return;
/////////////////////////////////////////////////////////////////////////
1: 
1:         protected void permitRedundantTransitions()
1:         {
1:             permitRedundantTransitions = true;
1:         }
commit:8704006
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.utils.concurrent;
1: 
0: import java.util.Set;
1: 
0: import com.google.common.collect.ImmutableSet;
1: 
1: import static org.apache.cassandra.utils.Throwables.maybeFail;
1: import static org.apache.cassandra.utils.Throwables.merge;
1: 
1: /**
1:  * An abstraction for Transactional behaviour. An object implementing this interface has a lifetime
1:  * of the following pattern:
1:  *
1:  * Throwable failure = null;
1:  * try (Transactional t1, t2 = ...)
1:  * {
1:  *     // do work with t1 and t2
1:  *     t1.prepareToCommit();
1:  *     t2.prepareToCommit();
1:  *     failure = t1.commit(failure);
1:  *     failure = t2.commit(failure);
1:  * }
1:  * logger.error(failure);
1:  *
1:  * If something goes wrong before commit() is called on any transaction, then on exiting the try block
1:  * the auto close method should invoke cleanup() and then abort() to reset any state.
1:  * If everything completes normally, then on exiting the try block the auto close method will invoke cleanup
1:  * to release any temporary state/resources
1:  *
0:  * No exceptions should be thrown during commit; if they are, it is not at all clear what the correct behaviour
1:  * of the system should be, and so simply logging the exception is likely best (since it may have been an issue
1:  * during cleanup, say), and rollback cannot now occur. As such all exceptions and assertions that may be thrown
1:  * should be checked and ruled out during commit preparation.
1:  */
1: public interface Transactional extends AutoCloseable
1: {
1: 
1:     /**
1:      * A simple abstract implementation of Transactional behaviour.
1:      * In general this should be used as the base class for any transactional implementations.
1:      *
1:      * If the implementation wraps any internal Transactional objects, it must proxy every
1:      * commit() and abort() call onto each internal object to ensure correct behaviour
1:      */
0:     public static abstract class AbstractTransactional implements Transactional
1:     {
0:         public static enum State
1:         {
1:             IN_PROGRESS,
1:             READY_TO_COMMIT,
1:             COMMITTED,
1:             ABORTED;
1:         }
1: 
1:         private State state = State.IN_PROGRESS;
1: 
1:         // the methods for actually performing the necessary behaviours, that are themselves protected against
1:         // improper use by the external implementations provided by this class. empty default implementations
1:         // could be provided, but we consider it safer to force implementers to consider explicitly their presence
1: 
1:         protected abstract Throwable doCommit(Throwable accumulate);
1:         protected abstract Throwable doAbort(Throwable accumulate);
1: 
0:         // this only needs to perform cleanup of state unique to this instance; any internal
1:         // Transactional objects will perform cleanup in the commit() or abort() calls
0:         protected abstract Throwable doCleanup(Throwable accumulate);
1: 
1:         /**
1:          * Do any preparatory work prior to commit. This method should throw any exceptions that can be encountered
1:          * during the finalization of the behaviour.
1:          */
1:         protected abstract void doPrepare();
1: 
1:         /**
1:          * commit any effects of this transaction object graph, then cleanup; delegates first to doCommit, then to doCleanup
1:          */
1:         public final Throwable commit(Throwable accumulate)
1:         {
1:             if (state != State.READY_TO_COMMIT)
0:                 throw new IllegalStateException("Commit attempted before prepared to commit");
1:             accumulate = doCommit(accumulate);
0:             accumulate = doCleanup(accumulate);
1:             state = State.COMMITTED;
1:             return accumulate;
1:         }
1: 
1:         /**
1:          * rollback any effects of this transaction object graph; delegates first to doCleanup, then to doAbort
1:          */
1:         public final Throwable abort(Throwable accumulate)
1:         {
1:             if (state == State.ABORTED)
1:                 return accumulate;
1:             if (state == State.COMMITTED)
1:             {
1:                 try
1:                 {
1:                     throw new IllegalStateException("Attempted to abort a committed operation");
1:                 }
1:                 catch (Throwable t)
1:                 {
1:                     accumulate = merge(accumulate, t);
1:                 }
1:                 return accumulate;
1:             }
1:             state = State.ABORTED;
1:             // we cleanup first so that, e.g., file handles can be released prior to deletion
0:             accumulate = doCleanup(accumulate);
1:             accumulate = doAbort(accumulate);
1:             return accumulate;
1:         }
1: 
1:         // if we are committed or aborted, then we are done; otherwise abort
1:         public final void close()
1:         {
1:             switch (state)
1:             {
1:                 case COMMITTED:
1:                 case ABORTED:
1:                     break;
1:                 default:
1:                     abort();
1:             }
1:         }
1: 
1:         /**
1:          * The first phase of commit: delegates to doPrepare(), with valid state transition enforcement.
1:          * This call should be propagated onto any child objects participating in the transaction
1:          */
1:         public final void prepareToCommit()
1:         {
1:             if (state != State.IN_PROGRESS)
1:                 throw new IllegalStateException("Cannot prepare to commit unless IN_PROGRESS; state is " + state);
1: 
1:             doPrepare();
1:             state = State.READY_TO_COMMIT;
1:         }
1: 
1:         /**
1:          * convenience method to both prepareToCommit() and commit() in one operation;
1:          * only of use to outer-most transactional object of an object graph
1:          */
1:         public Object finish()
1:         {
1:             prepareToCommit();
1:             commit();
1:             return this;
1:         }
1: 
1:         // convenience method wrapping abort, and throwing any exception encountered
1:         // only of use to (and to be used by) outer-most object in a transactional graph
1:         public final void abort()
1:         {
1:             maybeFail(abort(null));
1:         }
1: 
1:         // convenience method wrapping commit, and throwing any exception encountered
1:         // only of use to (and to be used by) outer-most object in a transactional graph
1:         public final void commit()
1:         {
1:             maybeFail(commit(null));
1:         }
1: 
1:         public final State state()
1:         {
1:             return state;
1:         }
1:     }
1: 
1:     // commit should generally never throw an exception, and preferably never generate one,
1:     // but if it does generate one it should accumulate it in the parameter and return the result
1:     // IF a commit implementation has a real correctness affecting exception that cannot be moved to
1:     // prepareToCommit, it MUST be executed before any other commit methods in the object graph
0:     public Throwable commit(Throwable accumulate);
1: 
1:     // release any resources, then rollback all state changes (unless commit() has already been invoked)
0:     public Throwable abort(Throwable accumulate);
1: 
0:     public void prepareToCommit();
1: }
author:Blake Eggleston
-------------------------------------------------------------------------------
commit:a3fc425
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * Since Transactional implementations will abort any changes they've made if calls to prepareToCommit() and commit()
1:  * aren't made prior to calling close(), the semantics of its close() method differ significantly from
1:  * most AutoCloseable implementations.
============================================================================