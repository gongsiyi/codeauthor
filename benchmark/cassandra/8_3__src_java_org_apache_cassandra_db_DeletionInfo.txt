1:b4bcdfc: /*
1:4e17ac4:  * Licensed to the Apache Software Foundation (ASF) under one
1:4e17ac4:  * or more contributor license agreements.  See the NOTICE file
1:4e17ac4:  * distributed with this work for additional information
1:4e17ac4:  * regarding copyright ownership.  The ASF licenses this file
1:4e17ac4:  * to you under the Apache License, Version 2.0 (the
1:4e17ac4:  * "License"); you may not use this file except in compliance
1:4e17ac4:  * with the License.  You may obtain a copy of the License at
1:88f65a1:  *
1:4e17ac4:  *     http://www.apache.org/licenses/LICENSE-2.0
1:88f65a1:  *
1:4e17ac4:  * Unless required by applicable law or agreed to in writing, software
1:4e17ac4:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4e17ac4:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4e17ac4:  * See the License for the specific language governing permissions and
1:4e17ac4:  * limitations under the License.
1:88f65a1:  */
1:4e17ac4: package org.apache.cassandra.db;
1:362cc05: 
1:a2e7435: import java.util.Iterator;
1:74258e2: 
1:4b54b8a: import org.apache.cassandra.cache.IMeasurableMemory;
1:c055ab9: import org.apache.cassandra.db.rows.EncodingStats;
1:a14a01c: import org.apache.cassandra.utils.memory.AbstractAllocator;
1:adcb713: 
1:adcb713: /**
1:a991b64:  * A combination of a top-level (partition) tombstone and range tombstones describing the deletions
1:a991b64:  * within a partition.
1:2457599:  * <p>
1:2457599:  * Note that in practice {@link MutableDeletionInfo} is the only concrete implementation of this, however
1:2457599:  * different parts of the code will return either {@code DeletionInfo} or {@code MutableDeletionInfo} based
1:2457599:  * on whether it can/should be mutated or not.
1:2457599:  * <p>
1:2457599:  * <b>Warning:</b> do not ever cast a {@code DeletionInfo} into a {@code MutableDeletionInfo} to mutate it!!!
1:2457599:  * TODO: it would be safer to have 2 actual implementation of DeletionInfo, one mutable and one that isn't (I'm
1:2457599:  * just lazy right this minute).
1:adcb713:  */
1:2457599: public interface DeletionInfo extends IMeasurableMemory
2:74258e2: {
1:2457599:     // Note that while MutableDeletionInfo.live() is mutable, we expose it here as a non-mutable DeletionInfo so sharing is fine.
1:2457599:     public static final DeletionInfo LIVE = MutableDeletionInfo.live();
1:74258e2: 
1:88f65a1:     /**
1:4d34917:      * Returns whether this DeletionInfo is live, that is deletes no columns.
1:b4bcdfc:      */
1:2457599:     public boolean isLive();
1:362cc05: 
1:2457599:     public DeletionTime getPartitionDeletion();
1:b4bcdfc: 
1:88f65a1:     // Use sparingly, not the most efficient thing
1:2457599:     public Iterator<RangeTombstone> rangeIterator(boolean reversed);
1:b4bcdfc: 
1:2457599:     public Iterator<RangeTombstone> rangeIterator(Slice slice, boolean reversed);
1:37130b5: 
1:2457599:     public RangeTombstone rangeCovering(Clustering name);
1:37130b5: 
1:c055ab9:     public void collectStats(EncodingStats.Collector collector);
1:88f65a1: 
1:2457599:     public int dataSize();
1:88f65a1: 
1:2457599:     public boolean hasRanges();
1:2457599: 
1:2457599:     public int rangeCount();
1:2457599: 
1:2457599:     public long maxTimestamp();
11:88f65a1: 
1:88f65a1:     /**
1:adcb713:      * Whether this deletion info may modify the provided one if added to it.
1:88f65a1:      */
1:2457599:     public boolean mayModify(DeletionInfo delInfo);
1:adcb713: 
1:2457599:     public MutableDeletionInfo mutableCopy();
1:2457599:     public DeletionInfo copy(AbstractAllocator allocator);
2:74258e2: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:c055ab9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.EncodingStats;
/////////////////////////////////////////////////////////////////////////
1:     public void collectStats(EncodingStats.Collector collector);
commit:2457599
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.rows.RowStats;
1:  * <p>
1:  * Note that in practice {@link MutableDeletionInfo} is the only concrete implementation of this, however
1:  * different parts of the code will return either {@code DeletionInfo} or {@code MutableDeletionInfo} based
1:  * on whether it can/should be mutated or not.
1:  * <p>
1:  * <b>Warning:</b> do not ever cast a {@code DeletionInfo} into a {@code MutableDeletionInfo} to mutate it!!!
1:  * TODO: it would be safer to have 2 actual implementation of DeletionInfo, one mutable and one that isn't (I'm
1:  * just lazy right this minute).
1: public interface DeletionInfo extends IMeasurableMemory
1:     // Note that while MutableDeletionInfo.live() is mutable, we expose it here as a non-mutable DeletionInfo so sharing is fine.
1:     public static final DeletionInfo LIVE = MutableDeletionInfo.live();
1:     public boolean isLive();
1:     public DeletionTime getPartitionDeletion();
1:     public Iterator<RangeTombstone> rangeIterator(boolean reversed);
1:     public Iterator<RangeTombstone> rangeIterator(Slice slice, boolean reversed);
1:     public RangeTombstone rangeCovering(Clustering name);
0:     public void collectStats(RowStats.Collector collector);
1:     public int dataSize();
1:     public boolean hasRanges();
1: 
1:     public int rangeCount();
1: 
1:     public long maxTimestamp();
1:     public boolean mayModify(DeletionInfo delInfo);
1:     public MutableDeletionInfo mutableCopy();
1:     public DeletionInfo copy(AbstractAllocator allocator);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.rows.Cell;
1:  * A combination of a top-level (partition) tombstone and range tombstones describing the deletions
1:  * within a partition.
0:      * This represents a deletion of the entire partition. We can't represent this within the RangeTombstoneList, so it's
0:      * kept separately. This also slightly optimizes the common case of a full partition deletion.
0:     private DeletionTime partitionDeletion;
0:      * A list of range tombstones within the partition.  This is left as null if there are no range tombstones
/////////////////////////////////////////////////////////////////////////
0:         this(new SimpleDeletionTime(markedForDeleteAt, localDeletionTime == Integer.MIN_VALUE ? Integer.MAX_VALUE : localDeletionTime));
0:     public DeletionInfo(DeletionTime partitionDeletion)
0:         this(partitionDeletion, null);
0:     public DeletionInfo(ClusteringComparator comparator, Slice slice, long markedForDeleteAt, int localDeletionTime)
0:         ranges.add(slice.start(), slice.end(), markedForDeleteAt, localDeletionTime);
0:     public DeletionInfo(DeletionTime partitionDeletion, RangeTombstoneList ranges)
0:         this.partitionDeletion = partitionDeletion.takeAlias();
/////////////////////////////////////////////////////////////////////////
0:         return new DeletionInfo(partitionDeletion, ranges == null ? null : ranges.copy());
0:         return new DeletionInfo(partitionDeletion, rangesCopy);
/////////////////////////////////////////////////////////////////////////
0:         return partitionDeletion.isLive() && (ranges == null || ranges.isEmpty());
0:      * Return whether a given cell is deleted by this deletion info.
0:      * @param clustering the clustering for the cell to check.
0:     private boolean isDeleted(Clustering clustering, Cell cell)
0:         // If we're live, don't consider anything deleted, even if the cell ends up having as timestamp Long.MIN_VALUE
0:         // (which shouldn't happen in practice, but it would invalid to consider it deleted if it does).
0:         if (cell.livenessInfo().timestamp() <= partitionDeletion.markedForDeleteAt())
0:         if (!partitionDeletion.isLive() && cell.isCounterCell())
0:         return ranges != null && ranges.isDeleted(clustering, cell);
/////////////////////////////////////////////////////////////////////////
0:         if (newInfo.supersedes(partitionDeletion))
0:             partitionDeletion = newInfo;
0:     public void add(RangeTombstone tombstone, ClusteringComparator comparator)
/////////////////////////////////////////////////////////////////////////
0:         add(newInfo.partitionDeletion);
/////////////////////////////////////////////////////////////////////////
0:     public DeletionTime getPartitionDeletion()
0:         return partitionDeletion;
0:     public Iterator<RangeTombstone> rangeIterator(boolean reversed)
0:         return ranges == null ? Iterators.<RangeTombstone>emptyIterator() : ranges.iterator(reversed);
0:     public Iterator<RangeTombstone> rangeIterator(Slice slice, boolean reversed)
0:         return ranges == null ? Iterators.<RangeTombstone>emptyIterator() : ranges.iterator(slice, reversed);
0:     public RangeTombstone rangeCovering(Clustering name)
0:         int size = TypeSizes.NATIVE.sizeof(partitionDeletion.markedForDeleteAt());
/////////////////////////////////////////////////////////////////////////
0:         return partitionDeletion.compareTo(delInfo.partitionDeletion) > 0 || hasRanges();
0:             return String.format("{%s}", partitionDeletion);
0:             return String.format("{%s, ranges=%s}", partitionDeletion, rangesAsString());
0:         ClusteringComparator cc = ranges.comparator();
0:         Iterator<RangeTombstone> iter = rangeIterator(false);
0:             sb.append(i.deletedSlice().toString(cc));
0:             sb.append("@");
0:             sb.append(i.deletionTime());
0:     public DeletionInfo updateAllTimestamp(long timestamp)
0:         if (partitionDeletion.markedForDeleteAt() != Long.MIN_VALUE)
0:             partitionDeletion = new SimpleDeletionTime(timestamp, partitionDeletion.localDeletionTime());
0:         return this;
/////////////////////////////////////////////////////////////////////////
0:         return partitionDeletion.equals(that.partitionDeletion) && Objects.equal(ranges, that.ranges);
0:         return Objects.hashCode(partitionDeletion, ranges);
0:         return EMPTY_SIZE + partitionDeletion.unsharedHeapSize() + (ranges == null ? 0 : ranges.unsharedHeapSize());
commit:74258e2
/////////////////////////////////////////////////////////////////////////
0:     public Iterator<RangeTombstone> rangeIterator(Composite start, Composite finish)
1:     {
0:         return ranges == null ? Iterators.<RangeTombstone>emptyIterator() : ranges.iterator(start, finish);
1:     }
1: 
0:     public DeletionTime deletionTimeFor(Composite name)
1:     {
0:         return ranges == null ? null : ranges.searchDeletionTime(name);
1:     }
1: 
0:     public RangeTombstone rangeCovering(Composite name)
/////////////////////////////////////////////////////////////////////////
0:         return topLevel.compareTo(delInfo.topLevel) > 0 || hasRanges();
commit:fe4247e
commit:58e9481
commit:adcb713
/////////////////////////////////////////////////////////////////////////
0:     public int rangeCount()
0:     {
0:         return ranges == null ? 0 : ranges.size();
0:     }
1: 
1:     /**
1:      * Whether this deletion info may modify the provided one if added to it.
1:      */
0:     public boolean mayModify(DeletionInfo delInfo)
0:     {
0:         return topLevel.markedForDeleteAt > delInfo.topLevel.markedForDeleteAt
0:             || ranges == null;
0:     }
1: 
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:      * Return whether a given cell is deleted by the container having this deletion info.
0:      * @param cell the cell to check.
0:      * @return true if the cell is deleted, false otherwise
0:     public boolean isDeleted(Cell cell)
0:         return isDeleted(cell.name(), cell.timestamp());
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Cell cell)
0:             return isDeleted(cell.name(), cell.timestamp());
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.CType;
0: import org.apache.cassandra.db.composites.Composite;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo(Composite start, Composite end, Comparator<Composite> comparator, long markedForDeleteAt, int localDeletionTime)
0:     public DeletionInfo(RangeTombstone rangeTombstone, Comparator<Composite> comparator)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDeleted(Composite name, long timestamp)
/////////////////////////////////////////////////////////////////////////
0:     public void add(RangeTombstone tombstone, Comparator<Composite> comparator)
/////////////////////////////////////////////////////////////////////////
0:     public DeletionTime rangeCovering(Composite name)
/////////////////////////////////////////////////////////////////////////
0:         CType type = (CType)ranges.comparator();
0:         assert type != null;
0:             sb.append(type.getString(i.min)).append("-");
0:             sb.append(type.getString(i.max)).append(", ");
/////////////////////////////////////////////////////////////////////////
0:         private final RangeTombstoneList.Serializer rtlSerializer;
1: 
0:         public Serializer(CType type)
0:         {
0:             this.rtlSerializer = new RangeTombstoneList.Serializer(type);
0:         }
1: 
0:             rtlSerializer.serialize(info.ranges, out, version);
0:             RangeTombstoneList ranges = rtlSerializer.deserialize(in, version);
0:             return size + rtlSerializer.serializedSize(info.ranges, typeSizes, version);
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Composite name, long timestamp)
commit:b4bcdfc
/////////////////////////////////////////////////////////////////////////
1:         /*
0:          * Note that because because range tombstone are added to this DeletionInfo while we iterate,
0:          * ranges may be null initially and we need to wait the first range to create the tester (once
0:          * created the test will pick up new tombstones however). We do are guaranteed that a range tombstone
0:          * will be added *before* we test any column that it may delete so this is ok.
1:          */
0:         private RangeTombstoneList.InOrderTester tester;
/////////////////////////////////////////////////////////////////////////
0:             if (reversed)
0:                  return DeletionInfo.this.isDeleted(name, timestamp);
1: 
0:             // Maybe create the tester if we hadn't yet and we now have some ranges (see above).
0:             if (tester == null && ranges != null)
0:                 tester = ranges.inOrderTester();
1: 
0:             return tester != null && tester.isDeleted(name, timestamp);
commit:37130b5
/////////////////////////////////////////////////////////////////////////
0:     // Updates all the timestamp of the deletion contained in this DeletionInfo to be {@code timestamp}.
0:     public void updateAllTimestamp(long timestamp)
0:     {
0:         if (topLevel.markedForDeleteAt != Long.MIN_VALUE)
0:             topLevel = new DeletionTime(timestamp, topLevel.localDeletionTime);
1: 
0:         if (ranges != null)
0:             ranges.updateAllTimestamp(timestamp);
0:     }
1: 
commit:88f65a1
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Iterators;
/////////////////////////////////////////////////////////////////////////
0:     private DeletionTime topLevel;
0:     private RangeTombstoneList ranges; // null if no range tombstones (to save an allocation since it's a common case).
/////////////////////////////////////////////////////////////////////////
0:         this(topLevel, null);
0:         this(DeletionTime.LIVE, new RangeTombstoneList(comparator, 1));
0:         ranges.add(start, end, markedForDeleteAt, localDeletionTime);
0:         this(rangeTombstone.min, rangeTombstone.max, comparator, rangeTombstone.data.markedForDeleteAt, rangeTombstone.data.localDeletionTime);
0:     public static DeletionInfo live()
0:     {
0:         return new DeletionInfo(DeletionTime.LIVE);
0:     }
1: 
0:     private DeletionInfo(DeletionTime topLevel, RangeTombstoneList ranges)
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo copy()
0:     {
0:         return new DeletionInfo(topLevel, ranges == null ? null : ranges.copy());
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             && (ranges == null || ranges.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:         // We do rely on this test: if topLevel.markedForDeleteAt is MIN_VALUE, we should not
0:         // consider the column deleted even if timestamp=MIN_VALUE, otherwise this break QueryFilter.isRelevant
1: 
0:         return ranges != null && ranges.isDeleted(name, timestamp);
0:      * Returns a new {@link InOrderTester} in forward order.
1:      */
0:     InOrderTester inOrderTester()
0:     {
0:         return inOrderTester(false);
0:     }
1: 
1:     /**
0:      * Returns a new {@link InOrderTester} given the order in which
0:      * columns will be passed to it.
1:      */
0:     public InOrderTester inOrderTester(boolean reversed)
0:     {
0:         return new InOrderTester(reversed);
0:     }
1: 
1:     /**
0:      * Purge every tombstones that are older than {@code gcbefore}.
0:     public void purge(int gcBefore)
0:         topLevel = topLevel.localDeletionTime < gcBefore ? DeletionTime.LIVE : topLevel;
1: 
0:         if (ranges != null)
0:             ranges.purge(gcBefore);
0:             if (ranges.isEmpty())
0:                 ranges = null;
0:     public boolean hasIrrelevantData(int gcBefore)
0:     {
0:         if (topLevel.localDeletionTime < gcBefore)
0:             return true;
1: 
0:         return ranges != null && ranges.hasIrrelevantData(gcBefore);
0:     }
1: 
0:     public void add(DeletionTime newInfo)
0:     {
0:         if (topLevel.markedForDeleteAt < newInfo.markedForDeleteAt)
0:             topLevel = newInfo;
0:     }
1: 
0:     public void add(RangeTombstone tombstone, Comparator<ByteBuffer> comparator)
0:     {
0:         if (ranges == null)
0:             ranges = new RangeTombstoneList(comparator, 1);
1: 
0:         ranges.add(tombstone);
0:     }
1: 
0:      * Adds the provided deletion infos to the current ones.
1:      *
0:      * @return this object.
0:         add(newInfo.topLevel);
1: 
0:         if (ranges == null)
0:             ranges = newInfo.ranges == null ? null : newInfo.ranges.copy();
0:         else if (newInfo.ranges != null)
0:             ranges.addAll(newInfo.ranges);
1: 
0:         return this;
0:         return ranges == null
0:              ? topLevel.markedForDeleteAt
0:              : Math.min(topLevel.markedForDeleteAt, ranges.minMarkedAt());
/////////////////////////////////////////////////////////////////////////
0:         return ranges == null
0:              ? topLevel.markedForDeleteAt
0:              : Math.max(topLevel.markedForDeleteAt, ranges.maxMarkedAt());
/////////////////////////////////////////////////////////////////////////
1:     // Use sparingly, not the most efficient thing
0:         return ranges == null ? Iterators.<RangeTombstone>emptyIterator() : ranges.iterator();
0:     public DeletionTime rangeCovering(ByteBuffer name)
0:         return ranges == null ? null : ranges.search(name);
0:         return size + (ranges == null ? 0 : ranges.dataSize());
0:         if (ranges == null || ranges.isEmpty())
/////////////////////////////////////////////////////////////////////////
0:         Iterator<RangeTombstone> iter = rangeIterator();
0:         while (iter.hasNext())
0:             RangeTombstone i = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         return topLevel.equals(that.topLevel) && Objects.equal(ranges, that.ranges);
/////////////////////////////////////////////////////////////////////////
0:     public static class Serializer implements IVersionedSerializer<DeletionInfo>
0:             RangeTombstoneList.serializer.serialize(info.ranges, out, version);
/////////////////////////////////////////////////////////////////////////
0:             RangeTombstoneList ranges = RangeTombstoneList.serializer.deserialize(in, version, comparator);
0:             return size + RangeTombstoneList.serializer.serializedSize(info.ranges, typeSizes, version);
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * This object allow testing whether a given column (name/timestamp) is deleted
0:      * or not by this DeletionInfo, assuming that the column given to this
0:      * object are passed in forward or reversed comparator sorted order.
1:      *
0:      * This is more efficient that calling DeletionInfo.isDeleted() repeatedly
0:      * in that case.
0:      */
0:     public class InOrderTester
0:     {
0:         private final RangeTombstoneList.InOrderTester tester;
0:         private final boolean reversed;
0: 
0:         private InOrderTester(boolean reversed)
0:         {
0:             this.reversed = reversed;
0:             this.tester = ranges == null || reversed ? null : ranges.inOrderTester();
0:         }
0: 
0:         public boolean isDeleted(Column column)
0:         {
0:             return isDeleted(column.name(), column.timestamp());
0:         }
0: 
0:         public boolean isDeleted(ByteBuffer name, long timestamp)
0:         {
0:             if (timestamp <= topLevel.markedForDeleteAt)
0:                 return true;
0: 
0:             /*
0:              * We don't optimize the reversed case for now because RangeTombstoneList
0:              * is always in forward sorted order.
0:              */
0:             return reversed
0:                  ? DeletionInfo.this.isDeleted(name, timestamp)
0:                  : tester != null && tester.isDeleted(name, timestamp);
0:         }
0:     }
commit:6e81f81
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Iterators;
/////////////////////////////////////////////////////////////////////////
0:     private DeletionTime topLevel;
0:     private RangeTombstoneList ranges; // null if no range tombstones (to save an allocation since it's a common case).
0:         this(new DeletionTime(markedForDeleteAt, localDeletionTime == Integer.MIN_VALUE ? Integer.MAX_VALUE : localDeletionTime));
0:         this(topLevel, null);
0:     public DeletionInfo(ByteBuffer start, ByteBuffer end, Comparator<ByteBuffer> comparator, long markedForDeleteAt, int localDeletionTime)
0:     {
0:         this(DeletionTime.LIVE, new RangeTombstoneList(comparator, 1));
0:         ranges.add(start, end, markedForDeleteAt, localDeletionTime);
0:     }
0: 
0:     public DeletionInfo(RangeTombstone rangeTombstone, Comparator<ByteBuffer> comparator)
0:     {
0:         this(rangeTombstone.min, rangeTombstone.max, comparator, rangeTombstone.data.markedForDeleteAt, rangeTombstone.data.localDeletionTime);
0:     }
0: 
0:     public static DeletionInfo live()
0:     {
0:         return new DeletionInfo(DeletionTime.LIVE);
0:     }
0: 
0:     private DeletionInfo(DeletionTime topLevel, RangeTombstoneList ranges)
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo copy()
0:     {
0:         return new DeletionInfo(topLevel, ranges == null ? null : ranges.copy());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             && (ranges == null || ranges.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:         // We do rely on this test: if topLevel.markedForDeleteAt is MIN_VALUE, we should not
0:         // consider the column deleted even if timestamp=MIN_VALUE, otherwise this break QueryFilter.isRelevant
0:         return ranges != null && ranges.isDeleted(name, timestamp);
0:      * Purge every tombstones that are older than {@code gcbefore}.
0:     public void purge(int gcBefore)
0:         topLevel = topLevel.localDeletionTime < gcBefore ? DeletionTime.LIVE : topLevel;
0: 
0:         if (ranges != null)
0:             ranges.purge(gcBefore);
0:             if (ranges.isEmpty())
0:                 ranges = null;
0:     public boolean hasIrrelevantData(int gcBefore)
0:     {
0:         if (topLevel.localDeletionTime < gcBefore)
0:             return true;
0: 
0:         return ranges != null && ranges.hasIrrelevantData(gcBefore);
0:     }
0: 
0:     public void add(DeletionTime newInfo)
0:     {
0:         if (topLevel.markedForDeleteAt < newInfo.markedForDeleteAt)
0:             topLevel = newInfo;
0:     }
0: 
0:     public void add(RangeTombstone tombstone, Comparator<ByteBuffer> comparator)
0:     {
0:         if (ranges == null)
0:             ranges = new RangeTombstoneList(comparator, 1);
0: 
0:         ranges.add(tombstone);
0:     }
0: 
0:      * Adds the provided deletion infos to the current ones.
0:      *
0:      * @return this object.
0:         add(newInfo.topLevel);
0: 
0:         if (ranges == null)
0:             ranges = newInfo.ranges == null ? null : newInfo.ranges.copy();
0:         else if (newInfo.ranges != null)
0:             ranges.addAll(newInfo.ranges);
0: 
0:         return this;
0:         return ranges == null
0:              ? topLevel.markedForDeleteAt
0:              : Math.min(topLevel.markedForDeleteAt, ranges.minMarkedAt());
/////////////////////////////////////////////////////////////////////////
0:         return ranges == null
0:              ? topLevel.markedForDeleteAt
0:              : Math.max(topLevel.markedForDeleteAt, ranges.maxMarkedAt());
/////////////////////////////////////////////////////////////////////////
0:     // Use sparingly, not the most efficient thing
0:         return ranges == null ? Iterators.<RangeTombstone>emptyIterator() : ranges.iterator();
0:         return size + (ranges == null ? 0 : ranges.dataSize());
0:         if (ranges == null || ranges.isEmpty())
/////////////////////////////////////////////////////////////////////////
0:         Iterator<RangeTombstone> iter = rangeIterator();
0:         while (iter.hasNext())
0:             RangeTombstone i = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         return topLevel.equals(that.topLevel) && Objects.equal(ranges, that.ranges);
/////////////////////////////////////////////////////////////////////////
0:     public static class Serializer implements IVersionedSerializer<DeletionInfo>
0:                 if (info.ranges != null && !info.ranges.isEmpty())
0:                 RangeTombstoneList.serializer.serialize(info.ranges, out, version);
/////////////////////////////////////////////////////////////////////////
0: 
0:                 return new DeletionInfo(topLevel, null);
0:             RangeTombstoneList ranges = RangeTombstoneList.serializer.deserialize(in, version, comparator);
0:             return size + RangeTombstoneList.serializer.serializedSize(info.ranges, typeSizes, version);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0:         this(new DeletionTime(markedForDeleteAt, localDeletionTime == Integer.MIN_VALUE ? Integer.MAX_VALUE : localDeletionTime));
0:     }
0: 
0:     public DeletionInfo(DeletionTime topLevel)
0:     {
0:         this(topLevel, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDeleted(Column column)
/////////////////////////////////////////////////////////////////////////
0:     public List<DeletionTime> rangeCovering(ByteBuffer name)
0:     {
0:         return ranges.search(name);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             assert version < MessagingService.VERSION_12 || comparator != null;
commit:80ea03f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.ColumnSlice;
/////////////////////////////////////////////////////////////////////////
0:      * Return the slice range covered by this deletion info or null is nothing is deleted.
0:      */
0:     public ColumnSlice[] coveredSlices()
0:     {
0:         if (isLive())
0:             return null;
0: 
0:         if (!topLevel.equals(DeletionTime.LIVE))
0:             return ColumnSlice.ALL_COLUMNS_ARRAY;
0: 
0:         List<ColumnSlice> slices = new ArrayList<ColumnSlice>();
0:         ColumnSlice current = null;
0:         for (RangeTombstone tombstone : ranges)
0:         {
0:             if (current == null)
0:             {
0:                 current = new ColumnSlice(tombstone.min, tombstone.max);
0:             }
0:             else if (ranges.comparator().compare(current.finish, tombstone.min) < 0)
0:             {
0:                 // If next if strictly after current, we've finish current slice
0:                 slices.add(current);
0:                 current = new ColumnSlice(tombstone.min, tombstone.max);
0:             }
0:             else if (ranges.comparator().compare(current.finish, tombstone.max) < 0)
0:             {
0:                 // if tombstone end if after current end, extend current
0:                 current = new ColumnSlice(current.start, tombstone.max);
0:             }
0:             // otherwise, tombstone is fully included in current already, skip it
0:         }
0:         if (current != null)
0:             slices.add(current);
0:         return slices.isEmpty() ? null : slices.toArray(new ColumnSlice[slices.size()]);
0:     }
0: 
0:     /**
commit:5ab69b6
/////////////////////////////////////////////////////////////////////////
0:         {
0:             size += r.min.remaining() + r.max.remaining();
0:             size += TypeSizes.NATIVE.sizeof(r.data.markedForDeleteAt);
0:         }
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
0: import java.lang.reflect.Constructor;
0: import java.nio.ByteBuffer;
0: import java.util.*;
0: 
0: import com.google.common.base.Objects;
0: import com.google.common.collect.Iterables;
0: 
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.io.ISerializer;
0: import org.apache.cassandra.io.ISSTableSerializer;
0: import org.apache.cassandra.io.IVersionedSerializer;
0: import org.apache.cassandra.io.sstable.Descriptor;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.IntervalTree;
0: 
0:     private static final Serializer serializer = new Serializer();
0:     // We don't have way to represent the full interval of keys (Interval don't support the minimum token as the right bound),
0:     // so we keep the topLevel deletion info separatly. This also slightly optimize the case of full row deletion which is rather common.
0:     private final DeletionTime topLevel;
0:     private final IntervalTree<ByteBuffer, DeletionTime, RangeTombstone> ranges;
0: 
0:     public static final DeletionInfo LIVE = new DeletionInfo(DeletionTime.LIVE, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0:         this(new DeletionTime(markedForDeleteAt, localDeletionTime == Integer.MIN_VALUE ? Integer.MAX_VALUE : localDeletionTime),
0:              IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0:     }
0:     public DeletionInfo(ByteBuffer start, ByteBuffer end, Comparator<ByteBuffer> comparator, long markedForDeleteAt, int localDeletionTime)
0:     {
0:         this(new RangeTombstone(start, end, new DeletionTime(markedForDeleteAt, localDeletionTime)), comparator);
0:     }
0: 
0:     public DeletionInfo(RangeTombstone rangeTombstone, Comparator<ByteBuffer> comparator)
0:     {
0:         this(DeletionTime.LIVE, IntervalTree.build(Collections.<RangeTombstone>singletonList(rangeTombstone), comparator));
0:         assert comparator != null;
0:     }
0: 
0:     private DeletionInfo(DeletionTime topLevel, IntervalTree<ByteBuffer, DeletionTime, RangeTombstone> ranges)
0:     {
0:         this.topLevel = topLevel;
0:         this.ranges = ranges;
0:     }
0: 
0:     public static Serializer serializer()
0:     {
0:         return serializer;
0:     }
0: 
0:     /**
1:      * Returns whether this DeletionInfo is live, that is deletes no columns.
0:      */
0:     public boolean isLive()
0:     {
0:         return topLevel.markedForDeleteAt == Long.MIN_VALUE
0:             && topLevel.localDeletionTime == Integer.MAX_VALUE
0:             && ranges.isEmpty();
0:     }
0: 
0:     /**
0:      * Return whether a given column is deleted by the container having this
0:      * deletion info.
0:      *
0:      * @param col the column to check.
0:      * @return true if the column is deleted, false otherwise
0:      */
0:     public boolean isDeleted(IColumn column)
0:     {
0:         return isDeleted(column.name(), column.mostRecentLiveChangeAt());
0:     }
0: 
0:     public boolean isDeleted(ByteBuffer name, long timestamp)
0:     {
0:         if (isLive())
0:             return false;
0:         if (timestamp <= topLevel.markedForDeleteAt)
0:             return true;
0: 
0:         for (DeletionTime d : ranges.search(name))
0:         {
0:             if (timestamp <= d.markedForDeleteAt)
0:                 return true;
0:         }
0:         return false;
0:     }
0: 
0:     /**
0:      * Return a new DeletionInfo correspond to purging every tombstones that
0:      * are older than {@code gcbefore}.
0:      *
0:      * @param gcBefore timestamp (in seconds) before which tombstones should
0:      * be purged
0:      * @return a new DeletionInfo with the purged info remove. Should return
0:      * DeletionInfo.LIVE if no tombstones remain.
0:      */
0:     public DeletionInfo purge(int gcBefore)
0:     {
0:         if (ranges.isEmpty())
0:         {
0:             return topLevel.localDeletionTime < gcBefore ? LIVE : this;
0:         }
0:         else
0:         {
0:             // We rebuild a new intervalTree that contains only non expired range tombstones
0:             List<RangeTombstone> nonExpired = new ArrayList<RangeTombstone>();
0:             for (RangeTombstone range : ranges)
0:             {
0:                 if (range.data.localDeletionTime >= gcBefore)
0:                     nonExpired.add(range);
0:             }
0:             IntervalTree<ByteBuffer, DeletionTime, RangeTombstone> newRanges = nonExpired.size() == ranges.intervalCount()
0:                                                                              ? ranges
0:                                                                              : IntervalTree.build(nonExpired, ranges.comparator());
0:             return topLevel.localDeletionTime < gcBefore
0:                  ? new DeletionInfo(DeletionTime.LIVE, newRanges)
0:                  : new DeletionInfo(topLevel, newRanges);
0:         }
0:     }
0: 
0:     /**
0:      * Returns a new DeletionInfo containing of this plus the provided {@code
0:      * newInfo}.
0:      */
0:     public DeletionInfo add(DeletionInfo newInfo)
0:     {
0:         if (ranges.isEmpty())
0:         {
0:             return topLevel.markedForDeleteAt < newInfo.topLevel.markedForDeleteAt
0:                  ? newInfo
0:                  : newInfo.ranges.isEmpty() ? this : new DeletionInfo(topLevel, newInfo.ranges);
0:         }
0:         else
0:         {
0:             if (newInfo.ranges.isEmpty())
0:             {
0:                 return topLevel.markedForDeleteAt < newInfo.topLevel.markedForDeleteAt
0:                      ? new DeletionInfo(newInfo.topLevel, ranges)
0:                      : this;
0:             }
0:             else
0:             {
0:                 // Need to merge both ranges
0:                 Set<RangeTombstone> merged = new HashSet<RangeTombstone>();
0:                 Iterables.addAll(merged, Iterables.concat(ranges, newInfo.ranges));
0:                 return new DeletionInfo(topLevel.markedForDeleteAt < newInfo.topLevel.markedForDeleteAt ? newInfo.topLevel : topLevel,
0:                                         IntervalTree.build(merged, ranges.comparator()));
0:             }
0:         }
0:     }
0: 
0:     /**
0:      * The maximum timestamp mentioned by this DeletionInfo.
0:      */
0:     public long maxTimestamp()
0:     {
0:         long maxTimestamp = topLevel.markedForDeleteAt;
0:         for (RangeTombstone i : ranges)
0:         {
0:             maxTimestamp = Math.max(maxTimestamp, i.data.markedForDeleteAt);
0:         }
0:         return maxTimestamp;
0:     }
0: 
0:     public DeletionTime getTopLevelDeletion()
0:     {
0:         return topLevel;
0:     }
0: 
0:     public Iterator<RangeTombstone> rangeIterator()
0:     {
0:         return ranges.iterator();
0:     }
0: 
0:     public int dataSize()
0:     {
0:         int size = TypeSizes.NATIVE.sizeof(topLevel.markedForDeleteAt);
0:         for (RangeTombstone r : ranges)
0:             size += r.data.markedForDeleteAt;
0:         return size;
0:         if (ranges.isEmpty())
0:             return String.format("{%s}", topLevel);
0:         else
0:             return String.format("{%s, ranges=%s}", topLevel, rangesAsString());
0:     }
0: 
0:     private String rangesAsString()
0:     {
0:         assert !ranges.isEmpty();
0:         StringBuilder sb = new StringBuilder();
0:         AbstractType at = (AbstractType)ranges.comparator();
0:         assert at != null;
0:         for (RangeTombstone i : ranges)
0:         {
0:             sb.append("[");
0:             sb.append(at.getString(i.min)).append("-");
0:             sb.append(at.getString(i.max)).append(", ");
0:             sb.append(i.data);
0:             sb.append("]");
0:         }
0:         return sb.toString();
0:     }
0: 
0:     @Override
0:     public boolean equals(Object o)
0:     {
0:         if(!(o instanceof DeletionInfo))
0:             return false;
0:         DeletionInfo that = (DeletionInfo)o;
0:         return topLevel.equals(that.topLevel) && ranges.equals(that.ranges);
0:     }
0: 
0:     @Override
0:     public final int hashCode()
0:     {
0:         return Objects.hashCode(topLevel, ranges);
0:     }
0: 
0:     public static class Serializer implements IVersionedSerializer<DeletionInfo>, ISSTableSerializer<DeletionInfo>
0:     {
0:         private final static ISerializer<ByteBuffer> bbSerializer = new ISerializer<ByteBuffer>()
0:         {
0:             public void serialize(ByteBuffer bb, DataOutput dos) throws IOException
0:             {
0:                 ByteBufferUtil.writeWithShortLength(bb, dos);
0:             }
0: 
0:             public ByteBuffer deserialize(DataInput dis) throws IOException
0:             {
0:                 return ByteBufferUtil.readWithShortLength(dis);
0:             }
0: 
0:             public long serializedSize(ByteBuffer bb, TypeSizes typeSizes)
0:             {
0:                 int bbSize = bb.remaining();
0:                 return typeSizes.sizeof((short)bbSize) + bbSize;
0:             }
0:         };
0: 
0:         private final static IntervalTree.Serializer<ByteBuffer, DeletionTime, RangeTombstone> itSerializer;
0:         static
0:         {
0:             try
0:             {
0:                 Constructor<RangeTombstone> constructor = RangeTombstone.class.getConstructor(ByteBuffer.class, ByteBuffer.class, DeletionTime.class);
0:                 itSerializer = IntervalTree.serializer(bbSerializer, DeletionTime.serializer, constructor);
0:             }
0:             catch (NoSuchMethodException e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0: 
0:         public void serialize(DeletionInfo info, DataOutput out, int version) throws IOException
0:         {
0:             DeletionTime.serializer.serialize(info.topLevel, out);
0:             // Pre-1.2 version don't know about range tombstones and thus users should upgrade all
0:             // nodes before using them. If they didn't, better fail early that propagating bad info
0:             if (version < MessagingService.VERSION_12)
0:             {
0:                 if (!info.ranges.isEmpty())
0:                     throw new RuntimeException("Cannot send range tombstone to pre-1.2 node. You should upgrade all node to Cassandra 1.2+ before using range tombstone.");
0:                 // Otherwise we're done
0:             }
0:             else
0:             {
0:                 itSerializer.serialize(info.ranges, out, version);
0:             }
0:         }
0: 
0:         public void serializeForSSTable(DeletionInfo info, DataOutput out) throws IOException
0:         {
0:             DeletionTime.serializer.serialize(info.topLevel, out);
0:         }
0: 
0:         /*
0:          * Range tombstones internally depend on the column family serializer, but it is not serialized.
0:          * Thus deserialize(DataInput, int, Comparator<ByteBuffer>) should be used instead of this method.
0:          */
0:         public DeletionInfo deserialize(DataInput in, int version) throws IOException
0:         {
0:             throw new UnsupportedOperationException();
0:         }
0: 
0:         public DeletionInfo deserialize(DataInput in, int version, Comparator<ByteBuffer> comparator) throws IOException
0:         {
0:             assert comparator != null;
0:             DeletionTime topLevel = DeletionTime.serializer.deserialize(in);
0:             if (version < MessagingService.VERSION_12)
0:                 return new DeletionInfo(topLevel, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0: 
0:             IntervalTree<ByteBuffer, DeletionTime, RangeTombstone> ranges = itSerializer.deserialize(in, version, comparator);
0:             return new DeletionInfo(topLevel, ranges);
0:         }
0: 
0:         public DeletionInfo deserializeFromSSTable(DataInput in, Descriptor.Version version) throws IOException
0:         {
0:             DeletionTime topLevel = DeletionTime.serializer.deserialize(in);
0:             return new DeletionInfo(topLevel, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0:         }
0: 
0:         public long serializedSize(DeletionInfo info, TypeSizes typeSizes, int version)
0:         {
0:             long size = DeletionTime.serializer.serializedSize(info.topLevel, typeSizes);
0:             if (version < MessagingService.VERSION_12)
0:                 return size;
0: 
0:             return size + itSerializer.serializedSize(info.ranges, typeSizes, version);
0:         }
0: 
0:         public long serializedSize(DeletionInfo info, int version)
0:         {
0:             return serializedSize(info, TypeSizes.NATIVE, version);
0:         }
commit:4e17ac4
/////////////////////////////////////////////////////////////////////////
0: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.db;
0: 
0: public class DeletionInfo
0: {
0:     public final long markedForDeleteAt;
0:     public final int localDeletionTime;
0: 
0:     public static final DeletionInfo LIVE = new DeletionInfo(Long.MIN_VALUE, Integer.MAX_VALUE);
0: 
0:     public DeletionInfo(long markedForDeleteAt, int localDeletionTime)
0:     {
0:         // Pre-1.1 node may return MIN_VALUE for non-deleted container, but the new default is MAX_VALUE
0:         // (see CASSANDRA-3872)
0:         if (localDeletionTime == Integer.MIN_VALUE)
0:             localDeletionTime = Integer.MAX_VALUE;
0: 
0:         this.markedForDeleteAt = markedForDeleteAt;
0:         this.localDeletionTime = localDeletionTime;
0:     }
0: 
0:     @Override
0:     public String toString()
0:     {
0:         return String.format("{deletedAt=%d, localDeletion=%d}", markedForDeleteAt, localDeletionTime);
0:     }
0: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0:         int size = TypeSizes.sizeof(partitionDeletion.markedForDeleteAt());
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0:     public InOrderTester inOrderTester()
commit:a14a01c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.memory.AbstractAllocator;
0: import org.apache.cassandra.utils.memory.MemtableAllocator;
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo copy(AbstractAllocator allocator)
0:     {
0: 
0:         RangeTombstoneList rangesCopy = null;
0:         if (ranges != null)
0:              rangesCopy = ranges.copy(allocator);
0: 
0:         return new DeletionInfo(topLevel, rangesCopy);
0:     }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:3ca9576
/////////////////////////////////////////////////////////////////////////
commit:6f217f7
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:6858dd3
/////////////////////////////////////////////////////////////////////////
0:         return topLevel.isLive() && (ranges == null || ranges.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:         if (cell.timestamp() <= topLevel.markedForDeleteAt)
0:         // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
0:         if (!topLevel.isLive() && cell instanceof CounterCell)
0:             return true;
0: 
0:         return ranges != null && ranges.isDeleted(cell);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (cell.timestamp() <= topLevel.markedForDeleteAt)
0:                 return true;
0:             // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
0:             if (!topLevel.isLive() && cell instanceof CounterCell)
/////////////////////////////////////////////////////////////////////////
0:                  return DeletionInfo.this.isDeleted(cell);
0:             return tester != null && tester.isDeleted(cell);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a2e7435
/////////////////////////////////////////////////////////////////////////
0: import java.security.MessageDigest;
0: import java.util.Comparator;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:      * Evaluates difference between this deletion info and superset for read repair
0:      *
0:      * @return the difference between the two, or LIVE if no difference
0:      */
0:     public DeletionInfo diff(DeletionInfo superset)
0:     {
0:         RangeTombstoneList rangeDiff = superset.ranges == null || superset.ranges.isEmpty()
0:                                      ? null
0:                                      : ranges == null ? superset.ranges : ranges.diff(superset.ranges);
0: 
0:         return topLevel.markedForDeleteAt != superset.topLevel.markedForDeleteAt || rangeDiff != null
0:              ? new DeletionInfo(superset.topLevel, rangeDiff)
0:              : DeletionInfo.live();
0:     }
0: 
0: 
0:     /**
0:      * Digests deletion info. Used to trigger read repair on mismatch.
0:      */
0:     public void updateDigest(MessageDigest digest)
0:     {
0:         if (topLevel.markedForDeleteAt != Long.MIN_VALUE)
0:             digest.update(ByteBufferUtil.bytes(topLevel.markedForDeleteAt));
0: 
0:         if (ranges != null)
0:             ranges.updateDigest(digest);
0:     }
0: 
0:     /**
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cache.IMeasurableMemory;
0: import org.apache.cassandra.utils.ObjectSizes;
0: public class DeletionInfo implements IMeasurableMemory
0:     private static final long EMPTY_SIZE = ObjectSizes.measure(new DeletionInfo(0, 0));
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     public long unsharedHeapSize()
0:     {
0:         return EMPTY_SIZE + topLevel.unsharedHeapSize() + (ranges == null ? 0 : ranges.unsharedHeapSize());
0:     }
0: 
commit:3edb62b
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * A combination of a top-level (or row) tombstone and range tombstones describing the deletions
0:  * within a {@link ColumnFamily} (or row).
0:  */
0:     /**
0:      * This represents a deletion of the entire row.  We can't represent this within the RangeTombstoneList, so it's
0:      * kept separately.  This also slightly optimizes the common case of a full row deletion.
0:      */
0:     /**
0:      * A list of range tombstones within the row.  This is left as null if there are no range tombstones
0:      * (to save an allocation (since it's a common case).
0:      */
0:     private RangeTombstoneList ranges;
0: 
0:     /**
0:      * Creates a DeletionInfo with only a top-level (row) tombstone.
0:      * @param markedForDeleteAt the time after which the entire row should be considered deleted
0:      * @param localDeletionTime what time the deletion write was applied locally (for purposes of
0:      *                          purging the tombstone after gc_grace_seconds).
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns a new DeletionInfo that has no top-level tombstone or any range tombstones.
0:      */
0:     public static DeletionInfo live()
0:     {
0:         return new DeletionInfo(DeletionTime.LIVE);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:      * Return whether a given column is deleted by the container having this deletion info.
/////////////////////////////////////////////////////////////////////////
0:      * @param gcBefore timestamp (in seconds) before which tombstones should be purged
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns true if {@code purge} would remove the top-level tombstone or any of the range
0:      * tombstones, false otherwise.
0:      * @param gcBefore timestamp (in seconds) before which tombstones should be purged
0:      */
0:     public boolean hasPurgeableTombstones(int gcBefore)
0:         return ranges != null && ranges.hasPurgeableTombstones(gcBefore);
0:     /**
0:      * Potentially replaces the top-level tombstone with another, keeping whichever has the higher markedForDeleteAt
0:      * timestamp.
0:      * @param newInfo
0:      */
/////////////////////////////////////////////////////////////////////////
0:      * Combines another DeletionInfo with this one and returns the result.  Whichever top-level tombstone
0:      * has the higher markedForDeleteAt timestamp will be kept, along with its localDeletionTime.  The
0:      * range tombstones will be combined.
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns the minimum timestamp in any of the range tombstones or the top-level tombstone.
0:      */
/////////////////////////////////////////////////////////////////////////
0:      * Returns the maximum timestamp in any of the range tombstones or the top-level tombstone.
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns the top-level (or "row") tombstone.
0:      */
/////////////////////////////////////////////////////////////////////////
0:      * or not by this DeletionInfo, assuming that the columns given to this
/////////////////////////////////////////////////////////////////////////
0:          * `ranges` may be null initially and we need to wait for the first range to create the tester (once
0:          * created the test will pick up new tombstones however). We are guaranteed that a range tombstone
0:          * will be added *before* we test any column that it may delete, so this is ok.
commit:ed4a067
/////////////////////////////////////////////////////////////////////////
0:     public boolean hasRanges()
0:     {
0:         return ranges != null && !ranges.isEmpty();
0:     }
0: 
commit:ad191c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return isDeleted(column.name(), column.timestamp());
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
0:             itSerializer.serialize(info.ranges, out, version);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c48acd9
commit:573ddbf
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo(DeletionTime topLevel)
0:     {
0:         this(topLevel, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:7746225
/////////////////////////////////////////////////////////////////////////
commit:d7a0982
/////////////////////////////////////////////////////////////////////////
0:     public DeletionInfo(DeletionTime deletion)
0:     {
0:         this(deletion, IntervalTree.<ByteBuffer, DeletionTime, RangeTombstone>emptyTree());
0:     }
0: 
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:             public void serialize(ByteBuffer bb, DataOutput out) throws IOException
0:                 ByteBufferUtil.writeWithShortLength(bb, out);
0:             public ByteBuffer deserialize(DataInput in) throws IOException
0:                 return ByteBufferUtil.readWithShortLength(in);
commit:8a1b93d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4f1e5e2
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(DeletionInfo info, DataOutputPlus out, int version) throws IOException
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:7a6fbc1
commit:da93a1c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ObjectSizes;
/////////////////////////////////////////////////////////////////////////
0:     public long memorySize()
0:     {
0:         long fields = topLevel.memorySize() + (2 * ObjectSizes.getReferenceSize());
0:         if (ranges != null && !ranges.isEmpty())
0:             fields += ObjectSizes.measureDeep(ranges);
0:         return ObjectSizes.getFieldSize(fields);
0:     }
0: 
commit:ac9f478
/////////////////////////////////////////////////////////////////////////
0:     public long minTimestamp()
0:     {
0:         long minTimestamp = topLevel.markedForDeleteAt;
0:         for (RangeTombstone i : ranges)
0:         {
0:             minTimestamp = Math.min(minTimestamp, i.data.markedForDeleteAt);
0:         }
0:         return minTimestamp;
0:     }
0: 
============================================================================