1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:066ef58:  */
1:066ef58: package org.apache.cassandra.db;
1:686139a: 
1:84eeb28: import java.io.*;
1:e7a385a: import java.nio.ByteBuffer;
1:a991b64: import java.security.MessageDigest;
1:8c64cef: import java.util.ArrayList;
1:8c64cef: import java.util.Collections;
1:8c64cef: import java.util.List;
1:686139a: 
1:fe388d4: import com.google.common.annotations.VisibleForTesting;
1:686139a: 
1:8a97969: import org.apache.cassandra.config.CFMetaData;
1:8c64cef: import org.apache.cassandra.db.filter.ClusteringIndexFilter;
1:fe388d4: import org.apache.cassandra.db.filter.ColumnFilter;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:a991b64: import org.apache.cassandra.db.partitions.*;
1:24682d2: import org.apache.cassandra.dht.*;
1:fbd287a: import org.apache.cassandra.io.ForwardingVersionedSerializer;
1:84eeb28: import org.apache.cassandra.io.IVersionedSerializer;
1:c4c9eae: import org.apache.cassandra.io.util.DataInputBuffer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:a991b64: import org.apache.cassandra.io.util.DataOutputBuffer;
1:a991b64: import org.apache.cassandra.net.MessagingService;
1:2217695: import org.apache.cassandra.thrift.ThriftResultsMerger;
1:3787d6c: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:686139a: 
1:a991b64: public abstract class ReadResponse
1:be45eb6: {
1:be45eb6:     // Serializer for single partition read response
1:a991b64:     public static final IVersionedSerializer<ReadResponse> serializer = new Serializer();
1:be45eb6:     // Serializer for the pre-3.0 rang slice responses.
1:a991b64:     public static final IVersionedSerializer<ReadResponse> legacyRangeSliceReplySerializer = new LegacyRangeSliceReplySerializer();
1:fbd287a:     // Serializer for partition range read response (this actually delegate to 'serializer' in 3.0 and to
1:fbd287a:     // 'legacyRangeSliceReplySerializer' in older version.
1:fbd287a:     public static final IVersionedSerializer<ReadResponse> rangeSliceSerializer = new ForwardingVersionedSerializer<ReadResponse>()
1:fbd287a:     {
1:fbd287a:         @Override
1:fbd287a:         protected IVersionedSerializer<ReadResponse> delegate(int version)
1:fbd287a:         {
1:fbd287a:             return version < MessagingService.VERSION_30
1:fbd287a:                     ? legacyRangeSliceReplySerializer
1:fbd287a:                     : serializer;
1:fbd287a:         }
1:fbd287a:     };
1:8c64cef: 
1:8a97969:     // This is used only when serializing data responses and we can't it easily in other cases. So this can be null, which is slighly
1:8a97969:     // hacky, but as this hack doesn't escape this class, and it's easy enough to validate that it's not null when we need, it's "good enough".
1:3e37b4a:     private final ReadCommand command;
1:8c64cef: 
1:3e37b4a:     protected ReadResponse(ReadCommand command)
1:8c64cef:     {
1:3e37b4a:         this.command = command;
1:8c64cef:     }
1:8c64cef: 
1:3e37b4a:     public static ReadResponse createDataResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:8c64cef:     {
1:3e37b4a:         return new LocalDataResponse(data, command);
1:8c64cef:     }
1:8c64cef: 
1:fe388d4:     @VisibleForTesting
1:3e37b4a:     public static ReadResponse createRemoteDataResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:be45eb6:     {
1:3e37b4a:         return new RemoteDataResponse(LocalDataResponse.build(data, command.columnFilter()));
1:8a97969:     }
1:8a97969: 
1:3e37b4a:     public static ReadResponse createDigestResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:8a97969:     {
1:3e37b4a:         return new DigestResponse(makeDigest(data, command));
1:686139a:     }
1:8a97969: 
1:3e37b4a:     public abstract UnfilteredPartitionIterator makeIterator(ReadCommand command);
1:3e37b4a:     public abstract ByteBuffer digest(ReadCommand command);
1:a991b64: 
1:782a1c3:     public abstract boolean isDigestResponse();
1:07cdfd0: 
1:3e37b4a:     protected static ByteBuffer makeDigest(UnfilteredPartitionIterator iterator, ReadCommand command)
1:686139a:     {
1:a991b64:         MessageDigest digest = FBUtilities.threadLocalMD5Digest();
1:3e37b4a:         UnfilteredPartitionIterators.digest(command, iterator, digest, command.digestVersion());
1:a991b64:         return ByteBuffer.wrap(digest.digest());
1:a991b64:     }
1:07cdfd0: 
1:a991b64:     private static class DigestResponse extends ReadResponse
1:a991b64:     {
1:a991b64:         private final ByteBuffer digest;
1:a991b64: 
1:a991b64:         private DigestResponse(ByteBuffer digest)
1:a991b64:         {
1:8a97969:             super(null);
1:a991b64:             assert digest.hasRemaining();
1:a991b64:             this.digest = digest;
1:a991b64:         }
1:a991b64: 
1:3e37b4a:         public UnfilteredPartitionIterator makeIterator(ReadCommand command)
1:a991b64:         {
7:a991b64:             throw new UnsupportedOperationException();
1:686139a:         }
1:07cdfd0: 
1:3e37b4a:         public ByteBuffer digest(ReadCommand command)
1:a991b64:         {
1:782a1c3:             // We assume that the digest is in the proper version, which bug excluded should be true since this is called with
1:782a1c3:             // ReadCommand.digestVersion() as argument and that's also what we use to produce the digest in the first place.
1:782a1c3:             // Validating it's the proper digest in this method would require sending back the digest version along with the
1:782a1c3:             // digest which would waste bandwith for little gain.
1:a991b64:             return digest;
1:686139a:         }
1:a991b64: 
1:782a1c3:         public boolean isDigestResponse()
1:686139a:         {
1:a991b64:             return true;
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:fe388d4:     // built on the owning node responding to a query
1:fe388d4:     private static class LocalDataResponse extends DataResponse
1:686139a:     {
1:3e37b4a:         private LocalDataResponse(UnfilteredPartitionIterator iter, ReadCommand command)
1:fe388d4:         {
1:3e37b4a:             super(command, build(iter, command.columnFilter()), SerializationHelper.Flag.LOCAL);
1:fe388d4:         }
1:a991b64: 
1:fe388d4:         private static ByteBuffer build(UnfilteredPartitionIterator iter, ColumnFilter selection)
4:fe388d4:         {
1:a991b64:             try (DataOutputBuffer buffer = new DataOutputBuffer())
1:a991b64:             {
1:fe388d4:                 UnfilteredPartitionIterators.serializerForIntraNode().serialize(iter, selection, buffer, MessagingService.current_version);
1:fe388d4:                 return buffer.buffer();
1:a991b64:             }
1:a991b64:             catch (IOException e)
1:fe388d4:             {
1:a991b64:                 // We're serializing in memory so this shouldn't happen
1:a991b64:                 throw new RuntimeException(e);
1:a991b64:             }
1:a991b64:         }
4:fe388d4:     }
1:a991b64: 
1:fe388d4:     // built on the coordinator node receiving a response
1:fe388d4:     private static class RemoteDataResponse extends DataResponse
1:a991b64:     {
1:fe388d4:         protected RemoteDataResponse(ByteBuffer data)
1:a991b64:         {
1:fe388d4:             super(null, data, SerializationHelper.Flag.FROM_REMOTE);
1:fe388d4:         }
1:fe388d4:     }
1:a991b64: 
1:fe388d4:     static abstract class DataResponse extends ReadResponse
1:fe388d4:     {
1:fe388d4:         // TODO: can the digest be calculated over the raw bytes now?
1:a991b64:         // The response, serialized in the current messaging version
1:a991b64:         private final ByteBuffer data;
1:a991b64:         private final SerializationHelper.Flag flag;
1:a991b64: 
1:3e37b4a:         protected DataResponse(ReadCommand command, ByteBuffer data, SerializationHelper.Flag flag)
1:a991b64:         {
1:3e37b4a:             super(command);
1:a991b64:             this.data = data;
1:fe388d4:             this.flag = flag;
1:a991b64:         }
1:a991b64: 
1:3e37b4a:         public UnfilteredPartitionIterator makeIterator(ReadCommand command)
1:a991b64:         {
1:127f7c5:             try (DataInputBuffer in = new DataInputBuffer(data, true))
1:a991b64:             {
1:3e37b4a:                 // Note that the command parameter shadows the 'command' field and this is intended because
1:3e37b4a:                 // the later can be null (for RemoteDataResponse as those are created in the serializers and
1:3e37b4a:                 // those don't have easy access to the command). This is also why we need the command as parameter here.
1:fe388d4:                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in,
1:fe388d4:                                                                                          MessagingService.current_version,
1:3e37b4a:                                                                                          command.metadata(),
1:3e37b4a:                                                                                          command.columnFilter(),
1:fe388d4:                                                                                          flag);
1:a991b64:             }
1:a991b64:             catch (IOException e)
1:a991b64:             {
1:a991b64:                 // We're deserializing in memory so this shouldn't happen
1:a991b64:                 throw new RuntimeException(e);
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:3e37b4a:         public ByteBuffer digest(ReadCommand command)
1:a991b64:         {
1:3e37b4a:             try (UnfilteredPartitionIterator iterator = makeIterator(command))
1:a991b64:             {
1:3e37b4a:                 return makeDigest(iterator, command);
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:782a1c3:         public boolean isDigestResponse()
1:a991b64:         {
1:8c64cef:             return false;
1:8c64cef:         }
1:8c64cef:     }
1:8c64cef: 
1:8c64cef:     /**
1:8c64cef:      * A remote response from a pre-3.0 node.  This needs a separate class in order to cleanly handle trimming and
1:8c64cef:      * reversal of results when the read command calls for it.  Pre-3.0 nodes always return results in the normal
1:8c64cef:      * sorted order, even if the query asks for reversed results.  Additionally,  pre-3.0 nodes do not have a notion of
1:8c64cef:      * exclusive slices on non-composite tables, so extra rows may need to be trimmed.
1:8c64cef:      */
1:24682d2:     @VisibleForTesting
1:24682d2:     static class LegacyRemoteDataResponse extends ReadResponse
1:8c64cef:     {
1:e51f83b:         private final List<ImmutableBTreePartition> partitions;
1:8c64cef: 
1:24682d2:         @VisibleForTesting
1:24682d2:         LegacyRemoteDataResponse(List<ImmutableBTreePartition> partitions)
1:8c64cef:         {
1:3e37b4a:             super(null); // we never serialize LegacyRemoteDataResponses, so we don't care about the command
1:8c64cef:             this.partitions = partitions;
1:8c64cef:         }
1:8c64cef: 
1:3e37b4a:         public UnfilteredPartitionIterator makeIterator(final ReadCommand command)
1:8c64cef:         {
1:24682d2:             // Due to a bug in the serialization of AbstractBounds, anything that isn't a Range is understood by pre-3.0 nodes
1:24682d2:             // as a Bound, which means IncludingExcludingBounds and ExcludingBounds responses may include keys they shouldn't.
1:24682d2:             // So filter partitions that shouldn't be included here.
1:24682d2:             boolean skipFirst = false;
1:24682d2:             boolean skipLast = false;
1:24682d2:             if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand)
1:24682d2:             {
1:24682d2:                 AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand)command).dataRange().keyRange();
1:24682d2:                 boolean isExcludingBounds = keyRange instanceof ExcludingBounds;
1:24682d2:                 skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey());
1:24682d2:                 skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey());
1:24682d2:             }
1:24682d2: 
1:24682d2:             final List<ImmutableBTreePartition> toReturn;
1:24682d2:             if (skipFirst || skipLast)
1:24682d2:             {
1:24682d2:                 toReturn = partitions.size() == 1
1:24682d2:                          ? Collections.emptyList()
1:24682d2:                          : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size());
1:24682d2:             }
1:557c596:             else
1:24682d2:             {
1:24682d2:                 toReturn = partitions;
1:24682d2:             }
1:24682d2: 
1:8c64cef:             return new AbstractUnfilteredPartitionIterator()
1:8c64cef:             {
1:8c64cef:                 private int idx;
1:8c64cef: 
1:8c64cef:                 public boolean isForThrift()
1:8c64cef:                 {
1:8c64cef:                     return true;
1:8c64cef:                 }
1:8c64cef: 
1:8c64cef:                 public CFMetaData metadata()
1:8c64cef:                 {
1:3e37b4a:                     return command.metadata();
1:8c64cef:                 }
1:8c64cef: 
1:8c64cef:                 public boolean hasNext()
1:8c64cef:                 {
1:24682d2:                     return idx < toReturn.size();
1:8c64cef:                 }
1:8c64cef: 
1:8c64cef:                 public UnfilteredRowIterator next()
1:8c64cef:                 {
1:24682d2:                     ImmutableBTreePartition partition = toReturn.get(idx++);
1:8c64cef: 
1:8c64cef:                     ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey());
1:8c64cef: 
1:c11c7d7:                     // Pre-3.0, we would always request one more row than we actually needed and the command-level "start" would
1:c11c7d7:                     // be the last-returned cell name, so the response would always include it.
1:c11c7d7:                     UnfilteredRowIterator iterator = partition.unfilteredIterator(command.columnFilter(), filter.getSlices(command.metadata()), filter.isReversed());
1:8c64cef: 
1:557c596:                     // Wrap results with a ThriftResultMerger only if they're intended for the thrift command.
1:557c596:                     if (command.isForThrift())
1:557c596:                         return ThriftResultsMerger.maybeWrap(iterator, command.nowInSec());
1:557c596:                     else
1:557c596:                         return iterator;
1:8c64cef:                 }
1:8c64cef:             };
1:8c64cef:         }
1:8c64cef: 
1:3e37b4a:         public ByteBuffer digest(ReadCommand command)
1:8c64cef:         {
1:3e37b4a:             try (UnfilteredPartitionIterator iterator = makeIterator(command))
1:a991b64:             {
1:3e37b4a:                 return makeDigest(iterator, command);
1:a991b64:             }
1:a991b64:         }
1:24682d2: 
1:782a1c3:         public boolean isDigestResponse()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static class Serializer implements IVersionedSerializer<ReadResponse>
1:a991b64:     {
1:be45eb6:         public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
1:a991b64:         {
1:8c64cef:             boolean isDigest = response instanceof DigestResponse;
1:8c64cef:             ByteBuffer digest = isDigest ? ((DigestResponse)response).digest : ByteBufferUtil.EMPTY_BYTE_BUFFER;
1:be45eb6:             if (version < MessagingService.VERSION_30)
1:a991b64:             {
1:8c64cef:                 out.writeInt(digest.remaining());
1:8c64cef:                 out.write(digest);
1:8c64cef:                 out.writeBoolean(isDigest);
1:8c64cef:                 if (!isDigest)
1:8c64cef:                 {
1:3e37b4a:                     assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:3e37b4a:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.command))
1:8c64cef:                     {
1:8c64cef:                         assert iter.hasNext();
1:8c64cef:                         try (UnfilteredRowIterator partition = iter.next())
1:8c64cef:                         {
1:8c64cef:                             ByteBufferUtil.writeWithShortLength(partition.partitionKey().getKey(), out);
1:3e37b4a:                             LegacyLayout.serializeAsLegacyPartition(response.command, partition, out, version);
1:8c64cef:                         }
1:8c64cef:                         assert !iter.hasNext();
1:8c64cef:                     }
1:8c64cef:                 }
1:8c64cef:                 return;
1:be45eb6:             }
1:8c64cef: 
1:8c64cef:             ByteBufferUtil.writeWithVIntLength(digest, out);
1:a991b64:             if (!isDigest)
1:a991b64:             {
1:a991b64:                 ByteBuffer data = ((DataResponse)response).data;
1:a59be26:                 ByteBufferUtil.writeWithVIntLength(data, out);
1:a991b64:             }
1:a991b64:         }
1:be45eb6: 
1:be45eb6:         public ReadResponse deserialize(DataInputPlus in, int version) throws IOException
1:be45eb6:         {
2:a991b64:             if (version < MessagingService.VERSION_30)
1:a991b64:             {
1:8c64cef:                 byte[] digest = null;
1:8c64cef:                 int digestSize = in.readInt();
1:8c64cef:                 if (digestSize > 0)
1:8c64cef:                 {
1:8c64cef:                     digest = new byte[digestSize];
1:8c64cef:                     in.readFully(digest, 0, digestSize);
1:8c64cef:                 }
1:8c64cef:                 boolean isDigest = in.readBoolean();
1:8c64cef:                 assert isDigest == digestSize > 0;
1:8c64cef:                 if (isDigest)
1:8c64cef:                 {
1:8c64cef:                     assert digest != null;
1:8c64cef:                     return new DigestResponse(ByteBuffer.wrap(digest));
1:8c64cef:                 }
1:8c64cef: 
1:8c64cef:                 // ReadResponses from older versions are always single-partition (ranges are handled by RangeSliceReply)
1:8c64cef:                 ByteBuffer key = ByteBufferUtil.readWithShortLength(in);
1:127f7c5:                 try (UnfilteredRowIterator rowIterator = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key))
1:a991b64:                 {
1:8c64cef:                     if (rowIterator == null)
1:8c64cef:                         return new LegacyRemoteDataResponse(Collections.emptyList());
1:8c64cef: 
1:e51f83b:                     return new LegacyRemoteDataResponse(Collections.singletonList(ImmutableBTreePartition.create(rowIterator)));
1:8c64cef:                 }
1:8c64cef:             }
1:be45eb6: 
1:a59be26:             ByteBuffer digest = ByteBufferUtil.readWithVIntLength(in);
1:a991b64:             if (digest.hasRemaining())
1:a991b64:                 return new DigestResponse(digest);
1:a991b64: 
2:a991b64:             assert version == MessagingService.VERSION_30;
1:a59be26:             ByteBuffer data = ByteBufferUtil.readWithVIntLength(in);
1:fe388d4:             return new RemoteDataResponse(data);
1:be45eb6:         }
1:a991b64: 
1:be45eb6:         public long serializedSize(ReadResponse response, int version)
1:8c64cef:         {
1:8c64cef:             boolean isDigest = response instanceof DigestResponse;
1:8c64cef:             ByteBuffer digest = isDigest ? ((DigestResponse)response).digest : ByteBufferUtil.EMPTY_BYTE_BUFFER;
1:8c64cef: 
1:a991b64:             if (version < MessagingService.VERSION_30)
1:8c64cef:             {
1:8c64cef:                 long size = TypeSizes.sizeof(digest.remaining())
1:8c64cef:                         + digest.remaining()
1:8c64cef:                         + TypeSizes.sizeof(isDigest);
1:8c64cef:                 if (!isDigest)
1:8c64cef:                 {
1:3e37b4a:                     assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:3e37b4a:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.command))
1:8c64cef:                     {
1:8c64cef:                         assert iter.hasNext();
1:8c64cef:                         try (UnfilteredRowIterator partition = iter.next())
1:8c64cef:                         {
1:8c64cef:                             size += ByteBufferUtil.serializedSizeWithShortLength(partition.partitionKey().getKey());
1:3e37b4a:                             size += LegacyLayout.serializedSizeAsLegacyPartition(response.command, partition, version);
1:8c64cef:                         }
1:8c64cef:                         assert !iter.hasNext();
1:8c64cef:                     }
1:8c64cef:                 }
1:8c64cef:                 return size;
1:be45eb6:             }
1:be45eb6: 
1:8c64cef:             long size = ByteBufferUtil.serializedSizeWithVIntLength(digest);
1:a991b64:             if (!isDigest)
1:be45eb6:             {
2:a991b64:                 // Note that we can only get there if version == 3.0, which is the current_version. When we'll change the
2:a991b64:                 // version, we'll have to deserialize/re-serialize the data to be in the proper version.
1:a991b64:                 assert version == MessagingService.VERSION_30;
1:a991b64:                 ByteBuffer data = ((DataResponse)response).data;
1:a59be26:                 size += ByteBufferUtil.serializedSizeWithVIntLength(data);
1:be45eb6:             }
1:a991b64:             return size;
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static class LegacyRangeSliceReplySerializer implements IVersionedSerializer<ReadResponse>
1:a991b64:     {
2:a991b64:         public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
1:a991b64:         {
1:fbd287a:             assert version < MessagingService.VERSION_30;
1:fbd287a: 
1:8c64cef:             // determine the number of partitions upfront for serialization
1:8c64cef:             int numPartitions = 0;
1:3e37b4a:             assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:3e37b4a:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
1:8c64cef:             {
1:8c64cef:                 while (iterator.hasNext())
1:8c64cef:                 {
1:8c64cef:                     try (UnfilteredRowIterator atomIterator = iterator.next())
1:8c64cef:                     {
1:8c64cef:                         numPartitions++;
1:8c64cef: 
1:8c64cef:                         // we have to fully exhaust the subiterator
1:8c64cef:                         while (atomIterator.hasNext())
1:8c64cef:                             atomIterator.next();
1:8c64cef:                     }
1:8c64cef:                 }
1:8c64cef:             }
1:8c64cef: 
1:8c64cef:             out.writeInt(numPartitions);
1:8c64cef: 
1:3e37b4a:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
1:8c64cef:             {
1:8c64cef:                 while (iterator.hasNext())
1:8c64cef:                 {
1:8c64cef:                     try (UnfilteredRowIterator partition = iterator.next())
1:8c64cef:                     {
1:8c64cef:                         ByteBufferUtil.writeWithShortLength(partition.partitionKey().getKey(), out);
1:3e37b4a:                         LegacyLayout.serializeAsLegacyPartition(response.command, partition, out, version);
1:8c64cef:                     }
1:8c64cef:                 }
1:8c64cef:             }
1:a991b64:         }
1:a991b64: 
1:03f72ac:         public ReadResponse deserialize(DataInputPlus in, int version) throws IOException
1:a991b64:         {
1:8c64cef:             assert version < MessagingService.VERSION_30;
1:a991b64: 
1:8c64cef:             int partitionCount = in.readInt();
1:e51f83b:             ArrayList<ImmutableBTreePartition> partitions = new ArrayList<>(partitionCount);
1:8c64cef:             for (int i = 0; i < partitionCount; i++)
1:8c64cef:             {
1:8c64cef:                 ByteBuffer key = ByteBufferUtil.readWithShortLength(in);
1:8c64cef:                 try (UnfilteredRowIterator partition = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key))
1:8c64cef:                 {
1:e51f83b:                     partitions.add(ImmutableBTreePartition.create(partition));
1:8c64cef:                 }
1:8c64cef:             }
1:8c64cef:             return new LegacyRemoteDataResponse(partitions);
1:a991b64:         }
1:a991b64: 
2:a991b64:         public long serializedSize(ReadResponse response, int version)
1:8c64cef:         {
1:8c64cef:             assert version < MessagingService.VERSION_30;
1:8c64cef:             long size = TypeSizes.sizeof(0);  // number of partitions
1:8c64cef: 
1:3e37b4a:             assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:3e37b4a:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
1:8c64cef:             {
1:8c64cef:                 while (iterator.hasNext())
1:8c64cef:                 {
1:8c64cef:                     try (UnfilteredRowIterator partition = iterator.next())
1:a991b64:                     {
1:8c64cef:                         size += ByteBufferUtil.serializedSizeWithShortLength(partition.partitionKey().getKey());
1:3e37b4a:                         size += LegacyLayout.serializedSizeAsLegacyPartition(response.command, partition, version);
1:8c64cef:                     }
1:8c64cef:                 }
1:8c64cef:             }
1:8c64cef:             return size;
1:a991b64:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:c11c7d7
/////////////////////////////////////////////////////////////////////////
1:                     // Pre-3.0, we would always request one more row than we actually needed and the command-level "start" would
1:                     // be the last-returned cell name, so the response would always include it.
1:                     UnfilteredRowIterator iterator = partition.unfilteredIterator(command.columnFilter(), filter.getSlices(command.metadata()), filter.isReversed());
commit:932f3eb
/////////////////////////////////////////////////////////////////////////
0:                     // Pre-3.0 we would always request one more row than we actually needed and the command-level "start" would
0:                     // be the last-returned cell name, so the response would always include it. By consequence, we need to filter
0:                     // the results here.
0:                     UnfilteredRowIterator iterator = filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()));
commit:fb4eb5a
commit:fbd287a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.ForwardingVersionedSerializer;
/////////////////////////////////////////////////////////////////////////
1:     // Serializer for partition range read response (this actually delegate to 'serializer' in 3.0 and to
1:     // 'legacyRangeSliceReplySerializer' in older version.
1:     public static final IVersionedSerializer<ReadResponse> rangeSliceSerializer = new ForwardingVersionedSerializer<ReadResponse>()
1:     {
1:         @Override
1:         protected IVersionedSerializer<ReadResponse> delegate(int version)
1:         {
1:             return version < MessagingService.VERSION_30
1:                     ? legacyRangeSliceReplySerializer
1:                     : serializer;
1:         }
1:     };
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             assert version < MessagingService.VERSION_30;
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:136f6b1
commit:32825a9
commit:2217695
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.thrift.ThriftResultsMerger;
/////////////////////////////////////////////////////////////////////////
0:                         return ThriftResultsMerger.maybeWrap(
0:                                 filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed())), command.nowInSec());
0:                     return ThriftResultsMerger.maybeWrap(
0:                             partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed()), command.nowInSec());
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: import org.apache.cassandra.db.filter.ClusteringIndexFilter;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:     public abstract UnfilteredPartitionIterator makeIterator(CFMetaData metadata, ReadCommand command);
1: 
0:     public abstract ByteBuffer digest(CFMetaData metadata, ReadCommand command);
1: 
/////////////////////////////////////////////////////////////////////////
0:         public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, ReadCommand command)
0:         public ByteBuffer digest(CFMetaData metadata, ReadCommand command)
/////////////////////////////////////////////////////////////////////////
0:         public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, ReadCommand command)
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer digest(CFMetaData metadata, ReadCommand command)
0:             try (UnfilteredPartitionIterator iterator = makeIterator(metadata, command))
1:             {
0:                 return makeDigest(iterator);
1:             }
1:         }
1: 
0:         public boolean isDigestQuery()
1:         {
1:             return false;
1:         }
1:     }
1: 
1:     /**
1:      * A remote response from a pre-3.0 node.  This needs a separate class in order to cleanly handle trimming and
1:      * reversal of results when the read command calls for it.  Pre-3.0 nodes always return results in the normal
1:      * sorted order, even if the query asks for reversed results.  Additionally,  pre-3.0 nodes do not have a notion of
1:      * exclusive slices on non-composite tables, so extra rows may need to be trimmed.
1:      */
0:     private static class LegacyRemoteDataResponse extends ReadResponse
1:     {
0:         private final List<ArrayBackedPartition> partitions;
1: 
0:         private LegacyRemoteDataResponse(List<ArrayBackedPartition> partitions)
1:         {
0:             super(null); // we never serialize LegacyRemoteDataResponses, so we don't care about the metadata
1:             this.partitions = partitions;
1:         }
1: 
0:         public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command)
1:         {
1:             return new AbstractUnfilteredPartitionIterator()
1:             {
1:                 private int idx;
1: 
1:                 public boolean isForThrift()
1:                 {
1:                     return true;
1:                 }
1: 
1:                 public CFMetaData metadata()
1:                 {
0:                     return metadata;
1:                 }
1: 
1:                 public boolean hasNext()
1:                 {
0:                     return idx < partitions.size();
1:                 }
1: 
1:                 public UnfilteredRowIterator next()
1:                 {
0:                     ArrayBackedPartition partition = partitions.get(idx++);
1: 
1:                     ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey());
1: 
0:                     // Pre-3.0, we didn't have a way to express exclusivity for non-composite comparators, so all slices were
0:                     // inclusive on both ends. If we have exclusive slice ends, we need to filter the results here.
0:                     if (!command.metadata().isCompound())
0:                         return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()));
1: 
0:                     return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed());
1:                 }
1:             };
1:         }
1: 
0:         public ByteBuffer digest(CFMetaData metadata, ReadCommand command)
1:         {
0:             try (UnfilteredPartitionIterator iterator = makeIterator(metadata, command))
/////////////////////////////////////////////////////////////////////////
1:             boolean isDigest = response instanceof DigestResponse;
1:             ByteBuffer digest = isDigest ? ((DigestResponse)response).digest : ByteBufferUtil.EMPTY_BYTE_BUFFER;
1: 
1:                 out.writeInt(digest.remaining());
1:                 out.write(digest);
1:                 out.writeBoolean(isDigest);
1:                 if (!isDigest)
1:                 {
0:                     assert !(response instanceof LegacyRemoteDataResponse); // we only use those on the receiving side
0:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.metadata, null))
1:                     {
1:                         assert iter.hasNext();
1:                         try (UnfilteredRowIterator partition = iter.next())
1:                         {
1:                             ByteBufferUtil.writeWithShortLength(partition.partitionKey().getKey(), out);
0:                             LegacyLayout.serializeAsLegacyPartition(partition, out, version);
1:                         }
1:                         assert !iter.hasNext();
1:                     }
1:                 }
1:                 return;
1:             ByteBufferUtil.writeWithVIntLength(digest, out);
/////////////////////////////////////////////////////////////////////////
1:                 byte[] digest = null;
1:                 int digestSize = in.readInt();
1:                 if (digestSize > 0)
1:                 {
1:                     digest = new byte[digestSize];
1:                     in.readFully(digest, 0, digestSize);
1:                 }
1:                 boolean isDigest = in.readBoolean();
1:                 assert isDigest == digestSize > 0;
1:                 if (isDigest)
1:                 {
1:                     assert digest != null;
1:                     return new DigestResponse(ByteBuffer.wrap(digest));
1:                 }
1: 
1:                 // ReadResponses from older versions are always single-partition (ranges are handled by RangeSliceReply)
1:                 ByteBuffer key = ByteBufferUtil.readWithShortLength(in);
0:                 UnfilteredRowIterator rowIterator = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key);
1:                 if (rowIterator == null)
1:                     return new LegacyRemoteDataResponse(Collections.emptyList());
1: 
0:                 try
1:                 {
0:                     return new LegacyRemoteDataResponse(Collections.singletonList(ArrayBackedPartition.create(rowIterator)));
1:                 }
0:                 finally
1:                 {
0:                     rowIterator.close();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             boolean isDigest = response instanceof DigestResponse;
1:             ByteBuffer digest = isDigest ? ((DigestResponse)response).digest : ByteBufferUtil.EMPTY_BYTE_BUFFER;
1: 
1:                 long size = TypeSizes.sizeof(digest.remaining())
1:                         + digest.remaining()
1:                         + TypeSizes.sizeof(isDigest);
1:                 if (!isDigest)
1:                 {
0:                     assert !(response instanceof LegacyRemoteDataResponse); // we only use those on the receiving side
0:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.metadata, null))
1:                     {
1:                         assert iter.hasNext();
1:                         try (UnfilteredRowIterator partition = iter.next())
1:                         {
1:                             size += ByteBufferUtil.serializedSizeWithShortLength(partition.partitionKey().getKey());
0:                             size += LegacyLayout.serializedSizeAsLegacyPartition(partition, version);
1:                         }
1:                         assert !iter.hasNext();
1:                     }
1:                 }
1:                 return size;
1:             long size = ByteBufferUtil.serializedSizeWithVIntLength(digest);
/////////////////////////////////////////////////////////////////////////
1:             assert version < MessagingService.VERSION_30;
1: 
1:             // determine the number of partitions upfront for serialization
1:             int numPartitions = 0;
0:             assert !(response instanceof LegacyRemoteDataResponse); // we only use those on the receiving side
0:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.metadata, null))
1:             {
1:                 while (iterator.hasNext())
1:                 {
1:                     try (UnfilteredRowIterator atomIterator = iterator.next())
1:                     {
1:                         numPartitions++;
1: 
1:                         // we have to fully exhaust the subiterator
1:                         while (atomIterator.hasNext())
1:                             atomIterator.next();
1:                     }
1:                 }
1:             }
1: 
1:             out.writeInt(numPartitions);
1: 
0:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.metadata, null))
1:             {
1:                 while (iterator.hasNext())
1:                 {
1:                     try (UnfilteredRowIterator partition = iterator.next())
1:                     {
1:                         ByteBufferUtil.writeWithShortLength(partition.partitionKey().getKey(), out);
0:                         LegacyLayout.serializeAsLegacyPartition(partition, out, version);
1:                     }
1:                 }
1:             }
0:             // Contrarily to serialize, we have to read the number of serialized partitions here.
1:             int partitionCount = in.readInt();
0:             ArrayList<ArrayBackedPartition> partitions = new ArrayList<>(partitionCount);
1:             for (int i = 0; i < partitionCount; i++)
1:             {
1:                 ByteBuffer key = ByteBufferUtil.readWithShortLength(in);
1:                 try (UnfilteredRowIterator partition = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key))
1:                 {
0:                     partitions.add(ArrayBackedPartition.create(partition));
1:                 }
1:             }
1:             return new LegacyRemoteDataResponse(partitions);
1:             assert version < MessagingService.VERSION_30;
1:             long size = TypeSizes.sizeof(0);  // number of partitions
1: 
0:             assert !(response instanceof LegacyRemoteDataResponse); // we only use those on the receiving side
0:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.metadata, null))
1:             {
1:                 while (iterator.hasNext())
1:                 {
1:                     try (UnfilteredRowIterator partition = iterator.next())
1:                     {
1:                         size += ByteBufferUtil.serializedSizeWithShortLength(partition.partitionKey().getKey());
0:                         size += LegacyLayout.serializedSizeAsLegacyPartition(partition, version);
1:                     }
1:                 }
1:             }
1:             return size;
author:Alex Petrov
-------------------------------------------------------------------------------
commit:557c596
/////////////////////////////////////////////////////////////////////////
0:                     UnfilteredRowIterator iterator;
0:                         iterator = filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()));
1:                     else
0:                         iterator = partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed());
1:                     // Wrap results with a ThriftResultMerger only if they're intended for the thrift command.
1:                     if (command.isForThrift())
1:                         return ThriftResultsMerger.maybeWrap(iterator, command.nowInSec());
1:                     else
1:                         return iterator;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:de405f2
commit:3e37b4a
/////////////////////////////////////////////////////////////////////////
1:     private final ReadCommand command;
1:     protected ReadResponse(ReadCommand command)
1:         this.command = command;
1:     public static ReadResponse createDataResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:         return new LocalDataResponse(data, command);
1:     public static ReadResponse createRemoteDataResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:         return new RemoteDataResponse(LocalDataResponse.build(data, command.columnFilter()));
1:     public static ReadResponse createDigestResponse(UnfilteredPartitionIterator data, ReadCommand command)
1:         return new DigestResponse(makeDigest(data, command));
1:     public abstract UnfilteredPartitionIterator makeIterator(ReadCommand command);
1:     public abstract ByteBuffer digest(ReadCommand command);
1:     protected static ByteBuffer makeDigest(UnfilteredPartitionIterator iterator, ReadCommand command)
1:         UnfilteredPartitionIterators.digest(command, iterator, digest, command.digestVersion());
/////////////////////////////////////////////////////////////////////////
1:         public UnfilteredPartitionIterator makeIterator(ReadCommand command)
1:         public ByteBuffer digest(ReadCommand command)
/////////////////////////////////////////////////////////////////////////
1:         private LocalDataResponse(UnfilteredPartitionIterator iter, ReadCommand command)
1:             super(command, build(iter, command.columnFilter()), SerializationHelper.Flag.LOCAL);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         protected DataResponse(ReadCommand command, ByteBuffer data, SerializationHelper.Flag flag)
1:             super(command);
1:         public UnfilteredPartitionIterator makeIterator(ReadCommand command)
1:                 // Note that the command parameter shadows the 'command' field and this is intended because
1:                 // the later can be null (for RemoteDataResponse as those are created in the serializers and
1:                 // those don't have easy access to the command). This is also why we need the command as parameter here.
1:                                                                                          command.metadata(),
1:                                                                                          command.columnFilter(),
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer digest(ReadCommand command)
1:             try (UnfilteredPartitionIterator iterator = makeIterator(command))
1:                 return makeDigest(iterator, command);
/////////////////////////////////////////////////////////////////////////
1:             super(null); // we never serialize LegacyRemoteDataResponses, so we don't care about the command
1:         public UnfilteredPartitionIterator makeIterator(final ReadCommand command)
/////////////////////////////////////////////////////////////////////////
1:                     return command.metadata();
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer digest(ReadCommand command)
1:             try (UnfilteredPartitionIterator iterator = makeIterator(command))
1:                 return makeDigest(iterator, command);
/////////////////////////////////////////////////////////////////////////
1:                     assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.command))
1:                             LegacyLayout.serializeAsLegacyPartition(response.command, partition, out, version);
/////////////////////////////////////////////////////////////////////////
1:                     assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:                     try (UnfilteredPartitionIterator iter = response.makeIterator(response.command))
1:                             size += LegacyLayout.serializedSizeAsLegacyPartition(response.command, partition, version);
/////////////////////////////////////////////////////////////////////////
1:             assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
/////////////////////////////////////////////////////////////////////////
1:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
1:                         LegacyLayout.serializeAsLegacyPartition(response.command, partition, out, version);
/////////////////////////////////////////////////////////////////////////
1:             assert response.command != null; // we only serialize LocalDataResponse, which always has the command set
1:             try (UnfilteredPartitionIterator iterator = response.makeIterator(response.command))
1:                         size += LegacyLayout.serializedSizeAsLegacyPartition(response.command, partition, version);
commit:24682d2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.*;
/////////////////////////////////////////////////////////////////////////
1:     @VisibleForTesting
1:     static class LegacyRemoteDataResponse extends ReadResponse
1:         @VisibleForTesting
1:         LegacyRemoteDataResponse(List<ImmutableBTreePartition> partitions)
/////////////////////////////////////////////////////////////////////////
1:             // Due to a bug in the serialization of AbstractBounds, anything that isn't a Range is understood by pre-3.0 nodes
1:             // as a Bound, which means IncludingExcludingBounds and ExcludingBounds responses may include keys they shouldn't.
1:             // So filter partitions that shouldn't be included here.
1:             boolean skipFirst = false;
1:             boolean skipLast = false;
1:             if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand)
1:             {
1:                 AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand)command).dataRange().keyRange();
1:                 boolean isExcludingBounds = keyRange instanceof ExcludingBounds;
1:                 skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey());
1:                 skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey());
1:             }
1: 
1:             final List<ImmutableBTreePartition> toReturn;
1:             if (skipFirst || skipLast)
1:             {
1:                 toReturn = partitions.size() == 1
1:                          ? Collections.emptyList()
1:                          : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size());
1:             }
0:             else
1:             {
1:                 toReturn = partitions;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     return idx < toReturn.size();
1:                     ImmutableBTreePartition partition = toReturn.get(idx++);
1: 
/////////////////////////////////////////////////////////////////////////
commit:782a1c3
/////////////////////////////////////////////////////////////////////////
0:     public static ReadResponse createDigestResponse(UnfilteredPartitionIterator data, int version)
0:         return new DigestResponse(makeDigest(data, version));
1:     public abstract boolean isDigestResponse();
0:     protected static ByteBuffer makeDigest(UnfilteredPartitionIterator iterator, int version)
0:         UnfilteredPartitionIterators.digest(iterator, digest, version);
/////////////////////////////////////////////////////////////////////////
1:             // We assume that the digest is in the proper version, which bug excluded should be true since this is called with
1:             // ReadCommand.digestVersion() as argument and that's also what we use to produce the digest in the first place.
1:             // Validating it's the proper digest in this method would require sending back the digest version along with the
1:             // digest which would waste bandwith for little gain.
1:         public boolean isDigestResponse()
/////////////////////////////////////////////////////////////////////////
0:                 return makeDigest(iterator, command.digestVersion());
1:         public boolean isDigestResponse()
/////////////////////////////////////////////////////////////////////////
0:                 return makeDigest(iterator, command.digestVersion());
1:         public boolean isDigestResponse()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:be45eb6
/////////////////////////////////////////////////////////////////////////
1:     // Serializer for single partition read response
0:     // Serializer for partition range read response (this actually delegate to 'serializer' in 3.0 and to
0:     // 'legacyRangeSliceReplySerializer' in older version.
0:     public static final IVersionedSerializer<ReadResponse> rangeSliceSerializer = new RangeSliceSerializer();
1:     // Serializer for the pre-3.0 rang slice responses.
/////////////////////////////////////////////////////////////////////////
0:     private static class RangeSliceSerializer implements IVersionedSerializer<ReadResponse>
1:     {
1:         public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
1:         {
1:             if (version < MessagingService.VERSION_30)
0:                 legacyRangeSliceReplySerializer.serialize(response, out, version);
0:             else
0:                 serializer.serialize(response, out, version);
1:         }
1: 
1:         public ReadResponse deserialize(DataInputPlus in, int version) throws IOException
1:         {
0:             return version < MessagingService.VERSION_30
0:                  ? legacyRangeSliceReplySerializer.deserialize(in, version)
0:                  : serializer.deserialize(in, version);
1:         }
1: 
1:         public long serializedSize(ReadResponse response, int version)
1:         {
0:             return version < MessagingService.VERSION_30
0:                  ? legacyRangeSliceReplySerializer.serializedSize(response, version)
0:                  : serializer.serializedSize(response, version);
1:         }
1:     }
1: 
commit:a59be26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithVIntLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER, out);
1:                 ByteBufferUtil.writeWithVIntLength(data, out);
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer digest = ByteBufferUtil.readWithVIntLength(in);
1:             ByteBuffer data = ByteBufferUtil.readWithVIntLength(in);
/////////////////////////////////////////////////////////////////////////
0:             long size = ByteBufferUtil.serializedSizeWithVIntLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:                 size += ByteBufferUtil.serializedSizeWithVIntLength(data);
commit:8a97969
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
1:     // This is used only when serializing data responses and we can't it easily in other cases. So this can be null, which is slighly
1:     // hacky, but as this hack doesn't escape this class, and it's easy enough to validate that it's not null when we need, it's "good enough".
0:     private final CFMetaData metadata;
1: 
0:     protected ReadResponse(CFMetaData metadata)
1:     {
0:         this.metadata = metadata;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public abstract UnfilteredPartitionIterator makeIterator(CFMetaData metadata);
0:     public abstract ByteBuffer digest(CFMetaData metadata);
/////////////////////////////////////////////////////////////////////////
1:             super(null);
0:         public UnfilteredPartitionIterator makeIterator(CFMetaData metadata)
0:         public ByteBuffer digest(CFMetaData metadata)
/////////////////////////////////////////////////////////////////////////
0:             super(null); // This is never call on the serialization side, where we actually care of the metadata.
0:             super(iter.metadata());
/////////////////////////////////////////////////////////////////////////
0:         public UnfilteredPartitionIterator makeIterator(CFMetaData metadata)
0:                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in, MessagingService.current_version, metadata, flag);
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer digest(CFMetaData metadata)
0:             try (UnfilteredPartitionIterator iterator = makeIterator(metadata))
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithShortLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER, out);
/////////////////////////////////////////////////////////////////////////
0:             long size = ByteBufferUtil.serializedSizeWithShortLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER);
commit:6249a3b
/////////////////////////////////////////////////////////////////////////
0:                 DataInputPlus in = new DataInputPlus.DataInputStreamPlus(ByteBufferUtil.inputStream(data));
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.security.MessageDigest;
0: import java.util.ArrayList;
0: import java.util.List;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.db.partitions.*;
1: import org.apache.cassandra.io.util.DataOutputBuffer;
1: import org.apache.cassandra.net.MessagingService;
1: import org.apache.cassandra.utils.FBUtilities;
1: public abstract class ReadResponse
1:     public static final IVersionedSerializer<ReadResponse> serializer = new Serializer();
1:     public static final IVersionedSerializer<ReadResponse> legacyRangeSliceReplySerializer = new LegacyRangeSliceReplySerializer();
0:     public static ReadResponse createDataResponse(UnfilteredPartitionIterator data)
0:         return new DataResponse(data);
0:     public static ReadResponse createDigestResponse(UnfilteredPartitionIterator data)
0:         return new DigestResponse(makeDigest(data));
0:     public abstract UnfilteredPartitionIterator makeIterator();
0:     public abstract ByteBuffer digest();
0:     public abstract boolean isDigestQuery();
1: 
0:     protected static ByteBuffer makeDigest(UnfilteredPartitionIterator iterator)
1:         MessageDigest digest = FBUtilities.threadLocalMD5Digest();
0:         UnfilteredPartitionIterators.digest(iterator, digest);
1:         return ByteBuffer.wrap(digest.digest());
1:     private static class DigestResponse extends ReadResponse
1:         private final ByteBuffer digest;
1:         private DigestResponse(ByteBuffer digest)
1:             assert digest.hasRemaining();
1:             this.digest = digest;
0:         public UnfilteredPartitionIterator makeIterator()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
0:         public ByteBuffer digest()
1:         {
1:             return digest;
1:         }
1: 
0:         public boolean isDigestQuery()
1:         {
1:             return true;
1:         }
0:     private static class DataResponse extends ReadResponse
1:         // The response, serialized in the current messaging version
1:         private final ByteBuffer data;
1:         private final SerializationHelper.Flag flag;
1: 
0:         private DataResponse(ByteBuffer data)
1:         {
1:             this.data = data;
0:             this.flag = SerializationHelper.Flag.FROM_REMOTE;
1:         }
1: 
0:         private DataResponse(UnfilteredPartitionIterator iter)
1:         {
1:             try (DataOutputBuffer buffer = new DataOutputBuffer())
1:             {
0:                 UnfilteredPartitionIterators.serializerForIntraNode().serialize(iter, buffer, MessagingService.current_version);
0:                 this.data = buffer.buffer();
0:                 this.flag = SerializationHelper.Flag.LOCAL;
1:             }
1:             catch (IOException e)
1:             {
1:                 // We're serializing in memory so this shouldn't happen
1:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public UnfilteredPartitionIterator makeIterator()
1:         {
0:             try
1:             {
0:                 DataInput in = new DataInputStream(ByteBufferUtil.inputStream(data));
0:                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in, MessagingService.current_version, flag);
1:             }
1:             catch (IOException e)
1:             {
1:                 // We're deserializing in memory so this shouldn't happen
1:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public ByteBuffer digest()
1:         {
0:             try (UnfilteredPartitionIterator iterator = makeIterator())
1:             {
0:                 return makeDigest(iterator);
1:             }
1:         }
1: 
0:         public boolean isDigestQuery()
1:         {
1:             return false;
1:         }
1:     }
1: 
1:     private static class Serializer implements IVersionedSerializer<ReadResponse>
1:     {
1:         public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
1:         {
1:             if (version < MessagingService.VERSION_30)
1:             {
0:                 // TODO
1:                 throw new UnsupportedOperationException();
1:             }
1: 
0:             boolean isDigest = response.isDigestQuery();
0:             ByteBufferUtil.writeWithShortLength(isDigest ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER, out);
1:             if (!isDigest)
1:             {
1:                 // Note that we can only get there if version == 3.0, which is the current_version. When we'll change the
1:                 // version, we'll have to deserialize/re-serialize the data to be in the proper version.
1:                 assert version == MessagingService.VERSION_30;
1:                 ByteBuffer data = ((DataResponse)response).data;
0:                 ByteBufferUtil.writeWithLength(data, out);
1:             }
1:         }
1: 
0:         public ReadResponse deserialize(DataInput in, int version) throws IOException
1:         {
1:             if (version < MessagingService.VERSION_30)
1:             {
0:                 // TODO
1:                 throw new UnsupportedOperationException();
1:             }
1: 
0:             ByteBuffer digest = ByteBufferUtil.readWithShortLength(in);
1:             if (digest.hasRemaining())
1:                 return new DigestResponse(digest);
1: 
1:             assert version == MessagingService.VERSION_30;
0:             ByteBuffer data = ByteBufferUtil.readWithLength(in);
0:             return new DataResponse(data);
1:         }
1: 
1:         public long serializedSize(ReadResponse response, int version)
1:         {
1:             if (version < MessagingService.VERSION_30)
1:             {
0:                 // TODO
1:                 throw new UnsupportedOperationException();
1:             }
1: 
0:             TypeSizes sizes = TypeSizes.NATIVE;
0:             boolean isDigest = response.isDigestQuery();
0:             long size = ByteBufferUtil.serializedSizeWithShortLength(isDigest ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER, sizes);
1: 
1:             if (!isDigest)
1:             {
1:                 // Note that we can only get there if version == 3.0, which is the current_version. When we'll change the
1:                 // version, we'll have to deserialize/re-serialize the data to be in the proper version.
1:                 assert version == MessagingService.VERSION_30;
1:                 ByteBuffer data = ((DataResponse)response).data;
0:                 size += ByteBufferUtil.serializedSizeWithLength(data, sizes);
1:             }
1:             return size;
1:         }
1:     }
1: 
1:     private static class LegacyRangeSliceReplySerializer implements IVersionedSerializer<ReadResponse>
1:     {
1:         public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
1:         {
0:             // TODO
1:             throw new UnsupportedOperationException();
0:             //        out.writeInt(rsr.rows.size());
0:             //        for (Row row : rsr.rows)
0:             //            Row.serializer.serialize(row, out, version);
1:         }
1: 
0:         public ReadResponse deserialize(DataInput in, int version) throws IOException
1:         {
0:             // TODO
1:             throw new UnsupportedOperationException();
0:             //        int rowCount = in.readInt();
0:             //        List<Row> rows = new ArrayList<Row>(rowCount);
0:             //        for (int i = 0; i < rowCount; i++)
0:             //            rows.add(Row.serializer.deserialize(in, version));
0:             //        return new RangeSliceReply(rows);
1:         }
1: 
1:         public long serializedSize(ReadResponse response, int version)
1:         {
0:             // TODO
1:             throw new UnsupportedOperationException();
0:             //        int size = TypeSizes.NATIVE.sizeof(rsr.rows.size());
0:             //        for (Row row : rsr.rows)
0:             //            size += Row.serializer.serializedSize(row, version);
0:             //        return size;
1:         }
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer.deserialize(dis, version, ColumnSerializer.Flag.FROM_REMOTE, ArrayBackedSortedColumns.factory());
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:  * The read response message is sent by the server when reading data
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 	public Row row()
1: 
0: 	public ByteBuffer digest()
/////////////////////////////////////////////////////////////////////////
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0:  * The read response message is sent by the server when reading data
/////////////////////////////////////////////////////////////////////////
0:     public Row row()
0:     public ByteBuffer digest()
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0: private static final IVersionedSerializer<ReadResponse> serializer;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:f95fc45
/////////////////////////////////////////////////////////////////////////
0:         int size = DBConstants.INT_SIZE;
0:         size += DBConstants.BOOL_SIZE;
commit:686139a
/////////////////////////////////////////////////////////////////////////
0:     private final Row row;
0:     private final ByteBuffer digest;
1: 
0:     public ReadResponse(ByteBuffer digest)
0:         this.digest= digest;
1:     }
0:     public ReadResponse(Row row)
0:         this.row = row;
0:     public Row row() 
0:         return row;
1:     }
1: 
0:     public ByteBuffer digest() 
1:     {
0:         return digest;
1:     }
1: 
0:     public boolean isDigestQuery()
1:     {
0:         return digest != null;
0:     public void serialize(ReadResponse response, DataOutput dos, int version) throws IOException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 
commit:910b663
/////////////////////////////////////////////////////////////////////////
0: private static IVersionedSerializer<ReadResponse> serializer;
0:         serializer = new ReadResponseSerializer();
0:         return serializer;
0: 	private final Row row;
0: 	private final ByteBuffer digest;
0: 	public ReadResponse(ByteBuffer digest)
0: 		this.digest= digest;
0:         this.row = null;
0: 		this.row = row;
0:         this.digest = null;
0: 		return row;
0: 		return digest;
0:     	return digest != null;
commit:e029b7d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.IColumnSerializer;
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer().deserialize(dis, version, IColumnSerializer.Flag.FROM_REMOTE, ArrayBackedSortedColumns.factory());
commit:86d5da8
/////////////////////////////////////////////////////////////////////////
commit:f14980d
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer().deserialize(dis, version, true, ArrayBackedSortedColumns.factory());
commit:016068a
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer().deserialize(dis, version, true, ArrayBackedSortedColumns.FACTORY);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:4fb559b
/////////////////////////////////////////////////////////////////////////
0:                         return partition.unfilteredIterator(command.columnFilter(), filter.getSlices(command.metadata()), filter.isReversed());
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1:         private final List<ImmutableBTreePartition> partitions;
0:         private LegacyRemoteDataResponse(List<ImmutableBTreePartition> partitions)
/////////////////////////////////////////////////////////////////////////
0:                     ImmutableBTreePartition partition = partitions.get(idx++);
/////////////////////////////////////////////////////////////////////////
1:                     return new LegacyRemoteDataResponse(Collections.singletonList(ImmutableBTreePartition.create(rowIterator)));
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<ImmutableBTreePartition> partitions = new ArrayList<>(partitionCount);
1:                     partitions.add(ImmutableBTreePartition.create(partition));
commit:4623aa6
/////////////////////////////////////////////////////////////////////////
0:         protected ColumnFilter selection(ReadCommand sent)
0:             assert sent == null || sent.columnFilter() == received;
/////////////////////////////////////////////////////////////////////////
0:         protected ColumnFilter selection(ReadCommand sent)
0:             return sent.columnFilter();
/////////////////////////////////////////////////////////////////////////
0:         protected abstract ColumnFilter selection(ReadCommand command);
/////////////////////////////////////////////////////////////////////////
0:                                                                                          selection(command),
commit:fe388d4
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.annotations.VisibleForTesting;
0: 
1: import org.apache.cassandra.db.filter.ColumnFilter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static ReadResponse createDataResponse(UnfilteredPartitionIterator data, ColumnFilter selection)
0:         return new LocalDataResponse(data, selection);
1:     }
0: 
1:     @VisibleForTesting
0:     public static ReadResponse createRemoteDataResponse(UnfilteredPartitionIterator data, ColumnFilter selection)
1:     {
0:         return new RemoteDataResponse(LocalDataResponse.build(data, selection));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // built on the owning node responding to a query
1:     private static class LocalDataResponse extends DataResponse
0:         private final ColumnFilter received;
0:         private LocalDataResponse(UnfilteredPartitionIterator iter, ColumnFilter received)
0:             super(iter.metadata(), build(iter, received), SerializationHelper.Flag.LOCAL);
0:             this.received = received;
1:         private static ByteBuffer build(UnfilteredPartitionIterator iter, ColumnFilter selection)
1:                 UnfilteredPartitionIterators.serializerForIntraNode().serialize(iter, selection, buffer, MessagingService.current_version);
1:                 return buffer.buffer();
/////////////////////////////////////////////////////////////////////////
0:         protected ColumnFilter selection(ColumnFilter sent)
1:         {
0:             // we didn't send anything, so we don't provide it in the serializer methods, but use the
0:             // object's reference to the original column filter we received
0:             assert sent == null | sent == received;
0:             return received;
1:         }
1:     }
0: 
1:     // built on the coordinator node receiving a response
1:     private static class RemoteDataResponse extends DataResponse
1:     {
1:         protected RemoteDataResponse(ByteBuffer data)
1:         {
1:             super(null, data, SerializationHelper.Flag.FROM_REMOTE);
1:         }
0: 
0:         protected ColumnFilter selection(ColumnFilter sent)
1:         {
0:             // we should always know what we sent, and should provide it in digest() and makeIterator()
0:             assert sent != null;
0:             return sent;
1:         }
1:     }
0: 
1:     static abstract class DataResponse extends ReadResponse
1:     {
1:         // TODO: can the digest be calculated over the raw bytes now?
0:         // The response, serialized in the current messaging version
0:         private final ByteBuffer data;
0:         private final SerializationHelper.Flag flag;
0: 
0:         protected DataResponse(CFMetaData metadata, ByteBuffer data, SerializationHelper.Flag flag)
1:         {
0:             super(metadata);
0:             this.data = data;
1:             this.flag = flag;
1:         }
0: 
0:         protected abstract ColumnFilter selection(ColumnFilter filter);
0: 
1:                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in,
1:                                                                                          MessagingService.current_version,
0:                                                                                          metadata,
0:                                                                                          selection(command.columnFilter()),
1:                                                                                          flag);
/////////////////////////////////////////////////////////////////////////
1:             return new RemoteDataResponse(data);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:127f7c5
/////////////////////////////////////////////////////////////////////////
1:             try (DataInputBuffer in = new DataInputBuffer(data, true))
/////////////////////////////////////////////////////////////////////////
1:                 try (UnfilteredRowIterator rowIterator = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key))
0:                 {
0:                     if (rowIterator == null)
0:                         return new LegacyRemoteDataResponse(Collections.emptyList());
commit:e777301
/////////////////////////////////////////////////////////////////////////
0:             try (DataInputBuffer in = new DataInputBuffer(data, true))
/////////////////////////////////////////////////////////////////////////
0:                 try (UnfilteredRowIterator rowIterator = LegacyLayout.deserializeLegacyPartition(in, version, SerializationHelper.Flag.FROM_REMOTE, key))
0:                 {
0:                     if (rowIterator == null)
0:                         return new LegacyRemoteDataResponse(Collections.emptyList());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:2fea59d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithVIntLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER, out);
0:                 ByteBufferUtil.writeWithVIntLength(data, out);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer digest = ByteBufferUtil.readWithVIntLength(in);
0:             ByteBuffer data = ByteBufferUtil.readWithVIntLength(in);
/////////////////////////////////////////////////////////////////////////
0:             long size = ByteBufferUtil.serializedSizeWithVIntLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER);
0:                 size += ByteBufferUtil.serializedSizeWithVIntLength(data);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:  * this encapsulates the keyspacename and the row that has been read.
0:  * The keyspace name is needed so that we can use it to create repairs.
commit:a78cd54
commit:57eb87b
/////////////////////////////////////////////////////////////////////////
0:         size += buffer.remaining();
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:59a2861
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithShortLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER, out);
0:                 ByteBufferUtil.writeWithLength(data, out);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer digest = ByteBufferUtil.readWithShortLength(in);
0:             ByteBuffer data = ByteBufferUtil.readWithLength(in);
/////////////////////////////////////////////////////////////////////////
0:             long size = ByteBufferUtil.serializedSizeWithShortLength(isDigest ? response.digest(response.metadata) : ByteBufferUtil.EMPTY_BYTE_BUFFER);
0: 
0:                 size += ByteBufferUtil.serializedSizeWithLength(data);
commit:d21556f
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer.deserialize(in, version, ColumnSerializer.Flag.FROM_REMOTE);
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:     public void serialize(ReadResponse response, DataOutput out, int version) throws IOException
0:         out.writeInt(response.isDigestQuery() ? response.digest().remaining() : 0);
0:         ByteBufferUtil.write(buffer, out);
0:         out.writeBoolean(response.isDigestQuery());
0:             Row.serializer.serialize(response.row(), out, version);
0:     public ReadResponse deserialize(DataInput in, int version) throws IOException
0:         int digestSize = in.readInt();
0:             in.readFully(digest, 0, digestSize);
0:         boolean isDigest = in.readBoolean();
0:             row = Row.serializer.deserialize(in, version, ColumnSerializer.Flag.FROM_REMOTE, ArrayBackedSortedColumns.factory());
commit:2ae5272
/////////////////////////////////////////////////////////////////////////
0:         TypeSizes typeSizes = TypeSizes.NATIVE;
commit:787f9d6
/////////////////////////////////////////////////////////////////////////
0: 	public void serialize(ReadResponse response, DataOutput dos, int version) throws IOException
0:         dos.writeInt(response.isDigestQuery() ? response.digest().remaining() : 0);
0:         ByteBuffer buffer = response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:         dos.writeBoolean(response.isDigestQuery());
0:         if (!response.isDigestQuery())
0:             Row.serializer().serialize(response.row(), dos, version);
/////////////////////////////////////////////////////////////////////////
0:     public long serializedSize(ReadResponse response, int version)
0:         int size = DBConstants.intSize;
0:         size += (response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER).remaining();
0:         size += DBConstants.boolSize;
0:         if (response.isDigestQuery())
0:             size += response.digest().remaining();
0:         else
0:             size += Row.serializer().serializedSize(response.row(), version);
0:         return size;
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
1: import org.apache.cassandra.io.IVersionedSerializer;
/////////////////////////////////////////////////////////////////////////
0: private static IVersionedSerializer<ReadResponse> serializer_;
0:     public static IVersionedSerializer<ReadResponse> serializer()
/////////////////////////////////////////////////////////////////////////
0: class ReadResponseSerializer implements IVersionedSerializer<ReadResponse>
0: 	public void serialize(ReadResponse rm, DataOutput dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:     public ReadResponse deserialize(DataInput dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
0:     public long serializedSize(ReadResponse readResponse)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
commit:43d330d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer buffer = rm.isDigestQuery() ? rm.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER;
commit:ef25537
/////////////////////////////////////////////////////////////////////////
commit:9d291b0
/////////////////////////////////////////////////////////////////////////
0: 	private final Row row_;
0: 	private final ByteBuffer digest_;
0:         row_ = null;
0:         digest_ = null;
/////////////////////////////////////////////////////////////////////////
0:     	return digest_ != null;
/////////////////////////////////////////////////////////////////////////
0:         dos.writeInt(rm.isDigestQuery() ? rm.digest().remaining() : 0);
0:         ByteBuffer buffer = rm.isDigestQuery() ? rm.digest() : FBUtilities.EMPTY_BYTE_BUFFER;
0:         dos.write(buffer.array(), buffer.position() + buffer.arrayOffset(), buffer.remaining());
0: 
0:         if (!rm.isDigestQuery())
0:         {
0:         }
0:     }
0:         byte[] digest = null;
0:         if (digestSize > 0)
0:         {
0:             digest = new byte[digestSize];
0:             dis.readFully(digest, 0, digestSize);
0:         }
0:         assert isDigest == digestSize > 0;
0: 
0:         return isDigest ? new ReadResponse(ByteBuffer.wrap(digest)) : new ReadResponse(row);
commit:9ebc400
/////////////////////////////////////////////////////////////////////////
0:         assert row != null;
commit:0e97a38
/////////////////////////////////////////////////////////////////////////
0:         dos.write(rm.digest().array(), rm.digest().position() + rm.digest().arrayOffset(), rm.digest().remaining());
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: 	private ByteBuffer digest_ = FBUtilities.EMPTY_BYTE_BUFFER;
0: 	public ReadResponse(ByteBuffer digest )
/////////////////////////////////////////////////////////////////////////
0: 	public ByteBuffer digest() 
/////////////////////////////////////////////////////////////////////////
0:         dos.writeInt(rm.digest().remaining());
0:         dos.write(rm.digest().array(),rm.digest().position()+rm.digest().arrayOffset(),rm.digest().remaining());
/////////////////////////////////////////////////////////////////////////
0:         ReadResponse rmsg = isDigest ? new ReadResponse(ByteBuffer.wrap(digest)) : new ReadResponse(row);
commit:944a2a1
/////////////////////////////////////////////////////////////////////////
commit:6b5d8bf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.StageManager;
/////////////////////////////////////////////////////////////////////////
0:         Message message = new Message(FBUtilities.getLocalAddress(), StageManager.RESPONSE_STAGE, MessagingService.responseVerbHandler_, bos.toByteArray());
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.utils.FBUtilities;
0: 
/////////////////////////////////////////////////////////////////////////
0:         Message message = new Message(FBUtilities.getLocalAddress(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, bos.toByteArray());
commit:f48c5b6
/////////////////////////////////////////////////////////////////////////
0:         if (!isDigest)
0: 
0:         ReadResponse rmsg = isDigest ? new ReadResponse(digest) : new ReadResponse(row);
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:07330c1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class ReadResponse
/////////////////////////////////////////////////////////////////////////
0: }
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.cassandra.db;
0: 
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.Serializable;
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.commons.lang.ArrayUtils;
0: 
0: 
0: /*
0:  * The read response message is sent by the server when reading data 
0:  * this encapsulates the tablename and the row that has been read.
0:  * The table name is needed so that we can use it to create repairs.
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
1:  */
0: public class ReadResponse implements Serializable 
0: {
0: private static ICompactSerializer<ReadResponse> serializer_;
0: 
0:     static
0:     {
0:         serializer_ = new ReadResponseSerializer();
0:     }
0: 
0:     public static ICompactSerializer<ReadResponse> serializer()
0:     {
0:         return serializer_;
0:     }
0:     
0: 	public static Message makeReadResponseMessage(ReadResponse readResponse) throws IOException
0:     {
0:     	ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:         DataOutputStream dos = new DataOutputStream( bos );
0:         ReadResponse.serializer().serialize(readResponse, dos);
0:         Message message = new Message(StorageService.getLocalStorageEndPoint(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, bos.toByteArray());         
0:         return message;
0:     }
0: 	
0: 	private Row row_;
0: 	private byte[] digest_ = ArrayUtils.EMPTY_BYTE_ARRAY;
0:     private boolean isDigestQuery_ = false;
0: 
0: 	public ReadResponse(byte[] digest )
0:     {
0:         assert digest != null;
0: 		digest_= digest;
0: 	}
0: 
0: 	public ReadResponse(Row row)
0:     {
0: 		row_ = row;
0: 	}
0: 
0: 	public Row row() 
0:     {
0: 		return row_;
0:     }
0:         
0: 	public byte[] digest() 
0:     {
0: 		return digest_;
0: 	}
0: 
0: 	public boolean isDigestQuery()
0:     {
0:     	return isDigestQuery_;
0:     }
0:     
0:     public void setIsDigestQuery(boolean isDigestQuery)
0:     {
0:     	isDigestQuery_ = isDigestQuery;
0:     }
0: }
0: 
0: class ReadResponseSerializer implements ICompactSerializer<ReadResponse>
0: {
0: 	public void serialize(ReadResponse rm, DataOutputStream dos) throws IOException
0: 	{
0:         dos.writeInt(rm.digest().length);
0:         dos.write(rm.digest());
0:         dos.writeBoolean(rm.isDigestQuery());
0:         
0:         if( !rm.isDigestQuery() && rm.row() != null )
0:         {            
0:             Row.serializer().serialize(rm.row(), dos);
0:         }				
0: 	}
0: 	
0:     public ReadResponse deserialize(DataInputStream dis) throws IOException
0:     {
0:         int digestSize = dis.readInt();
0:         byte[] digest = new byte[digestSize];
0:         dis.read(digest, 0 , digestSize);
0:         boolean isDigest = dis.readBoolean();
0:         
0:         Row row = null;
0:         if ( !isDigest )
0:         {
0:             row = Row.serializer().deserialize(dis);
0:         }
0: 		
0: 		ReadResponse rmsg = null;
0:     	if( isDigest  )
0:         {
0:     		rmsg =  new ReadResponse(digest);
0:         }
0:     	else
0:         {
0:     		rmsg =  new ReadResponse(row);
0:         }
0:         rmsg.setIsDigestQuery(isDigest);
0:     	return rmsg;
0:     } 
commit:4e3a440
/////////////////////////////////////////////////////////////////////////
0:  * this encapsulates the tablename and the row that has been read.
commit:509cbb8
/////////////////////////////////////////////////////////////////////////
0: 	public ReadResponse(byte[] digest )
0: 	public ReadResponse(Row row)
/////////////////////////////////////////////////////////////////////////
0:             Row.serializer().serialize(rm.row(), dos);
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer().deserialize(dis);
0:     		rmsg =  new ReadResponse(digest);
0:     		rmsg =  new ReadResponse(row);
commit:9aeef94
/////////////////////////////////////////////////////////////////////////
0:             Row.serializer(rm.table()).serialize(rm.row(), dos);
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer(table).deserialize(dis);
commit:fb347bd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.ArrayUtils;
/////////////////////////////////////////////////////////////////////////
0: 	private byte[] digest_ = ArrayUtils.EMPTY_BYTE_ARRAY;
0:         assert digest != null;
commit:49211d5
/////////////////////////////////////////////////////////////////////////
0:         Message message = new Message(StorageService.getLocalStorageEndPoint(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, bos.toByteArray());         
commit:71739ef
commit:6578825
/////////////////////////////////////////////////////////////////////////
0: public class ReadResponse implements Serializable 
0: private static ICompactSerializer<ReadResponse> serializer_;
0: 
0:         serializer_ = new ReadResponseSerializer();
0:     public static ICompactSerializer<ReadResponse> serializer()
0: 	public static Message makeReadResponseMessage(ReadResponse readResponse) throws IOException
0:         ReadResponse.serializer().serialize(readResponse, dos);
/////////////////////////////////////////////////////////////////////////
0: 	public ReadResponse(String table, byte[] digest )
0: 	public ReadResponse(String table, Row row)
/////////////////////////////////////////////////////////////////////////
0: class ReadResponseSerializer implements ICompactSerializer<ReadResponse>
0: 	public void serialize(ReadResponse rm, DataOutputStream dos) throws IOException
/////////////////////////////////////////////////////////////////////////
0:     public ReadResponse deserialize(DataInputStream dis) throws IOException
/////////////////////////////////////////////////////////////////////////
0: 		ReadResponse rmsg = null;
0:     		rmsg =  new ReadResponse(table, digest);
0:     		rmsg =  new ReadResponse(table, row);
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:c4c9eae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputBuffer;
/////////////////////////////////////////////////////////////////////////
0:                 DataInputPlus in = new DataInputBuffer(data, true);
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public ReadResponse deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             long size = ByteBufferUtil.serializedSizeWithShortLength(isDigest ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER);
/////////////////////////////////////////////////////////////////////////
0:                 size += ByteBufferUtil.serializedSizeWithLength(data);
/////////////////////////////////////////////////////////////////////////
0:         public ReadResponse deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             //        int size = TypeSizes.sizeof(rsr.rows.size());
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:     public void serialize(ReadResponse response, DataOutputPlus out, int version) throws IOException
0:         out.write(buffer);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:587cb58
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static final IVersionedSerializer<ReadResponse> serializer = new ReadResponseSerializer();
/////////////////////////////////////////////////////////////////////////
0:             Row.serializer.serialize(response.row(), dos, version);
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer.deserialize(dis, version, IColumnSerializer.Flag.FROM_REMOTE, ArrayBackedSortedColumns.factory());
/////////////////////////////////////////////////////////////////////////
0:             size += Row.serializer.serializedSize(response.row(), version);
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:cb25a8f
/////////////////////////////////////////////////////////////////////////
0:         DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
0:         ByteBuffer buffer = response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:         int size = typeSizes.sizeof(buffer.remaining());
0:         size += typeSizes.sizeof(response.isDigestQuery());
0:         if (!response.isDigestQuery())
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:ab5a8c7
/////////////////////////////////////////////////////////////////////////
0:             // This is coming from a remote host
0:             row = Row.serializer().deserialize(dis, version, true);
commit:3787d6c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         ByteBufferUtil.write(buffer, dos);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
0: 	public void serialize(ReadResponse rm, DataOutputStream dos, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             Row.serializer().serialize(rm.row(), dos, version);
0:     public ReadResponse deserialize(DataInputStream dis, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:             row = Row.serializer().deserialize(dis, version);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:f5d1a12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public ReadResponseMessage(String table, byte[] digest ) 
0:     {
0: 	public ReadResponseMessage(String table, Row row) 
0:     {
0: 	public String table() 
0:     {
/////////////////////////////////////////////////////////////////////////
0: 	public byte[] digest() 
0:     {
/////////////////////////////////////////////////////////////////////////
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.Serializable;
0: 
0: import javax.xml.bind.annotation.XmlElement;
0: 
0: import org.apache.cassandra.io.ICompactSerializer;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.StorageService;
0: 
0: 
0: /*
0:  * The read response message is sent by the server when reading data 
0:  * this encapsulates the tablename and teh row that has been read.
0:  * The table name is needed so that we can use it to create repairs.
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: public class ReadResponseMessage implements Serializable 
0: {
0: private static ICompactSerializer<ReadResponseMessage> serializer_;	
0: 	
0:     static
0:     {
0:         serializer_ = new ReadResponseMessageSerializer();
0:     }
0: 
0:     public static ICompactSerializer<ReadResponseMessage> serializer()
0:     {
0:         return serializer_;
0:     }
0:     
0: 	public static Message makeReadResponseMessage(ReadResponseMessage readResponseMessage) throws IOException
0:     {
0:     	ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:         DataOutputStream dos = new DataOutputStream( bos );
0:         ReadResponseMessage.serializer().serialize(readResponseMessage, dos);
0:         Message message = new Message(StorageService.getLocalStorageEndPoint(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, new Object[]{bos.toByteArray()});         
0:         return message;
0:     }
0: 	
0: 	@XmlElement(name = "Table")
0: 	private String table_;
0: 
0: 	@XmlElement(name = "Row")
0: 	private Row row_;
0: 
0: 	@XmlElement(name = "Digest")
0: 	private byte[] digest_ = new byte[0];
0: 
0:     @XmlElement(name="isDigestQuery")
0:     private boolean isDigestQuery_ = false;
0: 	
0: 	private ReadResponseMessage() {
0: 	}
0: 
0: 	public ReadResponseMessage(String table, byte[] digest ) {
0: 		table_ = table;
0: 		digest_= digest;
0: 	}
0: 
0: 	public ReadResponseMessage(String table, Row row) {
0: 		table_ = table;
0: 		row_ = row;
0: 	}
0: 
0: 	public String table() {
0: 		return table_;
0: 	}
0: 
0: 	public Row row() 
0:     {
0: 		return row_;
0:     }
0:         
0: 	public byte[] digest() {
0: 		return digest_;
0: 	}
0: 
0: 	public boolean isDigestQuery()
0:     {
0:     	return isDigestQuery_;
0:     }
0:     
0:     public void setIsDigestQuery(boolean isDigestQuery)
0:     {
0:     	isDigestQuery_ = isDigestQuery;
0:     }
0: }
0: 
0: 
0: class ReadResponseMessageSerializer implements ICompactSerializer<ReadResponseMessage>
0: {
0: 	public void serialize(ReadResponseMessage rm, DataOutputStream dos) throws IOException
0: 	{
0: 		dos.writeUTF(rm.table());
0:         dos.writeInt(rm.digest().length);
0:         dos.write(rm.digest());
0:         dos.writeBoolean(rm.isDigestQuery());
0:         
0:         if( !rm.isDigestQuery() && rm.row() != null )
0:         {            
0:             Row.serializer().serialize(rm.row(), dos);
0:         }				
0: 	}
0: 	
0:     public ReadResponseMessage deserialize(DataInputStream dis) throws IOException
0:     {
0:     	String table = dis.readUTF();
0:         int digestSize = dis.readInt();
0:         byte[] digest = new byte[digestSize];
0:         dis.read(digest, 0 , digestSize);
0:         boolean isDigest = dis.readBoolean();
0:         
0:         Row row = null;
0:         if ( !isDigest )
0:         {
0:             row = Row.serializer().deserialize(dis);
0:         }
0: 		
0: 		ReadResponseMessage rmsg = null;
0:     	if( isDigest  )
0:         {
0:     		rmsg =  new ReadResponseMessage(table, digest);
0:         }
0:     	else
0:         {
0:     		rmsg =  new ReadResponseMessage(table, row);
0:         }
0:         rmsg.setIsDigestQuery(isDigest);
0:     	return rmsg;
0:     } 
0: }
============================================================================