1:7359601: /*
1:7359601:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7359601:  * contributor license agreements.  See the NOTICE file distributed with
1:7359601:  * this work for additional information regarding copyright ownership.
1:7359601:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7359601:  * (the "License"); you may not use this file except in compliance with
1:7359601:  * the License.  You may obtain a copy of the License at
1:7359601:  *
1:7359601:  *    http://www.apache.org/licenses/LICENSE-2.0
1:7359601:  *
1:7359601:  * Unless required by applicable law or agreed to in writing, software
1:7359601:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7359601:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7359601:  * See the License for the specific language governing permissions and
1:7359601:  * limitations under the License.
1:7359601:  */
6:7359601: 
1:7359601: package org.apache.carbondata.core.datastore.page;
1:7359601: 
1:8c1ddbf: import java.io.IOException;
1:7359601: 
1:6297ea0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:8925947: import org.apache.carbondata.core.constants.CarbonV3DataFormatConstants;
1:8925947: import org.apache.carbondata.core.datastore.ColumnType;
1:8c1ddbf: import org.apache.carbondata.core.datastore.TableSpec;
1:8f08c4a: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1:6f20437: import org.apache.carbondata.core.memory.CarbonUnsafe;
1:6f20437: import org.apache.carbondata.core.memory.MemoryBlock;
1:7359601: import org.apache.carbondata.core.memory.MemoryException;
1:6f20437: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1:7359601: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:9e064ee: import org.apache.carbondata.core.metadata.datatype.DecimalConverterFactory;
1:7359601: import org.apache.carbondata.core.util.ByteUtil;
1:6f20437: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
1:7359601: 
1:7359601: public abstract class VarLengthColumnPageBase extends ColumnPage {
1:7359601: 
1:f209e8e:   static final int byteBits = DataTypes.BYTE.getSizeBits();
1:956833e:   static final int shortBits = DataTypes.SHORT.getSizeBits();
1:956833e:   static final int intBits = DataTypes.INT.getSizeBits();
1:956833e:   static final int longBits = DataTypes.LONG.getSizeBits();
1:6f20437:   // default size for each row, grows as needed
1:6f20437:   static final int DEFAULT_ROW_SIZE = 8;
1:6f20437: 
1:6f20437:   static final double FACTOR = 1.25;
1:6f20437: 
1:6f20437:   final long taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
1:6f20437: 
1:6f20437:   // memory allocated by Unsafe
1:6f20437:   MemoryBlock memoryBlock;
1:6f20437: 
1:6f20437:   // base address of memoryBlock
1:6f20437:   Object baseAddress;
1:6f20437: 
1:7359601:   // the offset of row in the unsafe memory, its size is pageSize + 1
1:8925947:   ColumnPage rowOffset;
1:7359601: 
1:7359601:   // the length of bytes added in the page
1:7359601:   int totalLength;
1:7359601: 
1:6f20437:   // base offset of memoryBlock
1:6f20437:   long baseOffset;
1:6f20437: 
1:6f20437:   // size of the allocated memory, in bytes
1:6f20437:   int capacity;
1:f209e8e: 
1:8f08c4a:   VarLengthColumnPageBase(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:8f08c4a:     super(columnPageEncoderMeta, pageSize);
1:8f08c4a:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec.newInstance(
1:8f08c4a:         columnPageEncoderMeta.getColumnSpec().getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:8925947:     try {
1:8f08c4a:       rowOffset = ColumnPage.newPage(
1:8f08c4a:           new ColumnPageEncoderMeta(spec, DataTypes.INT, columnPageEncoderMeta.getCompressorName()),
1:8f08c4a:           pageSize);
1:8925947:     } catch (MemoryException e) {
1:8925947:       throw new RuntimeException(e);
4:7359601:     }
1:7359601:     totalLength = 0;
1:7359601:   }
1:7359601: 
1:9e064ee:   @Override
1:7359601:   public void setBytePage(byte[] byteData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
2:7359601:   @Override
1:7359601:   public void setShortPage(short[] shortData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public void setShortIntPage(byte[] shortIntData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public void setIntPage(int[] intData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setLongPage(long[] longData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setFloatPage(float[] floatData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void setDoublePage(double[] doubleData) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   /**
1:e6a4f64:    * Create a new column page for decimal page
1:7359601:    */
1:8f08c4a:   static ColumnPage newDecimalColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes,
1:8f08c4a:       String compressorName) throws MemoryException {
1:9e064ee:     DecimalConverterFactory.DecimalConverter decimalConverter =
1:8c1ddbf:         DecimalConverterFactory.INSTANCE.getDecimalConverter(columnSpec.getPrecision(),
1:8c1ddbf:             columnSpec.getScale());
1:9e064ee:     int size = decimalConverter.getSize();
1:9e064ee:     if (size < 0) {
1:f209e8e:       return getLVBytesColumnPage(columnSpec, lvEncodedBytes,
1:6297ea0:           DataTypes.createDecimalType(columnSpec.getPrecision(), columnSpec.getScale()),
1:8f08c4a:           CarbonCommonConstants.INT_SIZE_IN_BYTE, compressorName);
1:9e064ee:     } else {
1:9e064ee:       // Here the size is always fixed.
1:8f08c4a:       return getDecimalColumnPage(columnSpec, lvEncodedBytes, size, compressorName);
1:9e064ee:     }
1:9e064ee:   }
1:9e064ee: 
1:9e064ee:   /**
1:9e064ee:    * Create a new column page based on the LV (Length Value) encoded bytes
1:9e064ee:    */
1:6297ea0:   static ColumnPage newLVBytesColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes,
1:8f08c4a:       int lvLength, String compressorName) throws MemoryException {
1:8f08c4a:     return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY,
1:8f08c4a:         lvLength, compressorName);
1:6297ea0:   }
1:6297ea0: 
1:6297ea0:   /**
1:6297ea0:    * Create a new column page based on the LV (Length Value) encoded bytes
1:6297ea0:    */
1:6297ea0:   static ColumnPage newComplexLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedBytes, int lvLength, String compressorName) throws MemoryException {
1:8f08c4a:     return getComplexLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY,
1:8f08c4a:         lvLength, compressorName);
1:9e064ee:   }
1:9e064ee: 
1:8c1ddbf:   private static ColumnPage getDecimalColumnPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedBytes, int size, String compressorName) throws MemoryException {
1:8925947:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:8925947:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:8f08c4a:     ColumnPage rowOffset = ColumnPage.newPage(
1:8f08c4a:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
1:8925947:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:9e064ee:     int offset;
1:9e064ee:     int rowId = 0;
1:8925947:     int counter = 0;
1:9e064ee:     for (offset = 0; offset < lvEncodedBytes.length; offset += size) {
1:8925947:       rowOffset.putInt(counter, offset);
1:9e064ee:       rowId++;
1:8925947:       counter++;
1:8925947:     }
1:8925947:     rowOffset.putInt(counter, offset);
1:9e064ee: 
1:9e064ee:     VarLengthColumnPageBase page;
1:9e064ee:     if (unsafe) {
1:8f08c4a:       page = new UnsafeDecimalColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:8f08c4a:           rowId);
1:9e064ee:     } else {
1:8f08c4a:       page = new SafeDecimalColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:8f08c4a:           rowId);
1:9e064ee:     }
1:9e064ee: 
1:9e064ee:     // set total length and rowOffset in page
1:9e064ee:     page.totalLength = offset;
1:4a37e05:     page.rowOffset.freeMemory();
1:8925947:     page.rowOffset = rowOffset;
1:9e064ee:     for (int i = 0; i < rowId; i++) {
1:9e064ee:       page.putBytes(i, lvEncodedBytes, i * size, size);
1:9e064ee:     }
1:6297ea0:     return page;
1:9e064ee:   }
1:9e064ee: 
1:8c1ddbf:   private static ColumnPage getLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedBytes, DataType dataType, int lvLength, String compressorName)
1:e6a4f64:       throws MemoryException {
1:7359601:     // extract length and data, set them to rowOffset and unsafe memory correspondingly
1:7359601:     int rowId = 0;
1:8925947:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:8925947:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:8f08c4a:     ColumnPage rowOffset = ColumnPage.newPage(
1:8f08c4a:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
1:8925947:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:7359601:     int length;
1:7359601:     int offset;
1:7359601:     int lvEncodedOffset = 0;
1:8925947:     int counter = 0;
1:7359601:     // extract Length field in input and calculate total length
1:7359601:     for (offset = 0; lvEncodedOffset < lvEncodedBytes.length; offset += length) {
1:7359601:       length = ByteUtil.toInt(lvEncodedBytes, lvEncodedOffset);
1:8925947:       rowOffset.putInt(counter, offset);
1:6297ea0:       lvEncodedOffset += lvLength + length;
1:6297ea0:       rowId++;
1:8925947:       counter++;
1:6297ea0:     }
1:8925947:     rowOffset.putInt(counter, offset);
1:8f08c4a:     return getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType,
1:8f08c4a:         lvLength, rowId, rowOffset, offset, compressorName);
1:6297ea0:   }
1:6297ea0: 
1:6297ea0:   private static ColumnPage getComplexLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
1:8f08c4a:       byte[] lvEncodedBytes, DataType dataType, int lvLength, String compressorName)
1:6297ea0:       throws MemoryException {
1:6297ea0:     // extract length and data, set them to rowOffset and unsafe memory correspondingly
1:6297ea0:     int rowId = 0;
1:8925947:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:8925947:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:8f08c4a:     ColumnPage rowOffset = ColumnPage.newPage(
1:8f08c4a:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
1:8925947:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:6297ea0:     int length;
1:6297ea0:     int offset;
1:6297ea0:     int lvEncodedOffset = 0;
1:8925947:     int counter = 0;
1:6297ea0:     // extract Length field in input and calculate total length
1:6297ea0:     for (offset = 0; lvEncodedOffset < lvEncodedBytes.length; offset += length) {
1:6297ea0:       length = ByteUtil.toShort(lvEncodedBytes, lvEncodedOffset);
1:8925947:       rowOffset.putInt(counter, offset);
1:6297ea0:       lvEncodedOffset += lvLength + length;
1:7359601:       rowId++;
1:8925947:       counter++;
1:6297ea0:     }
1:8925947:     rowOffset.putInt(counter, offset);
1:6297ea0: 
1:8f08c4a:     return getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType,
1:8f08c4a:         lvLength, rowId, rowOffset, offset, compressorName);
1:9e064ee:   }
1:6297ea0: 
1:6297ea0:   private static VarLengthColumnPageBase getVarLengthColumnPage(TableSpec.ColumnSpec columnSpec,
1:8925947:       byte[] lvEncodedBytes, DataType dataType, int lvLength, int rowId, ColumnPage rowOffset,
1:8f08c4a:       int offset, String compressorName) throws MemoryException {
1:6297ea0:     int lvEncodedOffset;
1:6297ea0:     int length;
1:7359601:     int numRows = rowId;
1:7359601: 
1:7359601:     VarLengthColumnPageBase page;
1:fdb672a:     int inputDataLength = offset;
1:7359601:     if (unsafe) {
1:8f08c4a:       page = new UnsafeDecimalColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), numRows,
1:8f08c4a:           inputDataLength);
1:7359601:     } else {
1:8f08c4a:       page = new SafeDecimalColumnPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), numRows);
1:9e064ee:     }
1:7359601: 
1:7359601:     // set total length and rowOffset in page
1:7359601:     page.totalLength = offset;
1:4a37e05:     page.rowOffset.freeMemory();
1:8925947:     page.rowOffset = rowOffset;
1:7359601: 
1:7359601:     // set data in page
1:7359601:     lvEncodedOffset = 0;
1:7359601:     for (int i = 0; i < numRows; i++) {
1:8925947:       length = rowOffset.getInt(i + 1) - rowOffset.getInt(i);
1:6297ea0:       page.putBytes(i, lvEncodedBytes, lvEncodedOffset + lvLength, length);
1:6297ea0:       lvEncodedOffset += lvLength + length;
1:7359601:     }
1:6297ea0:     return page;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putByte(int rowId, byte value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putShort(int rowId, short value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public void putShortInt(int rowId, int value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public void putInt(int rowId, int value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putLong(int rowId, long value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putDouble(int rowId, double value) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   abstract void putBytesAtRow(int rowId, byte[] bytes);
1:7359601: 
1:7359601:   @Override
1:7359601:   public void putBytes(int rowId, byte[] bytes) {
1:dc53dee:     // rowId * 4 represents the length of L in LV
1:dc53dee:     if (bytes.length > (Integer.MAX_VALUE - totalLength - rowId * 4)) {
1:dc53dee:       // since we later store a column page in a byte array, so its maximum size is 2GB
1:dc53dee:       throw new RuntimeException("Carbondata only support maximum 2GB size for one column page,"
1:dc53dee:           + " exceed this limit at rowId " + rowId);
1:dc53dee:     }
1:7359601:     if (rowId == 0) {
1:8925947:       rowOffset.putInt(0, 0);
1:7359601:     }
1:8925947:     rowOffset.putInt(rowId + 1, rowOffset.getInt(rowId) + bytes.length);
1:7359601:     putBytesAtRow(rowId, bytes);
1:7359601:     totalLength += bytes.length;
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public byte getByte(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public short getShort(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public int getShortInt(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public int getInt(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public long getLong(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public float getFloat(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public double getDouble(int rowId) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public byte[] getBytePage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public short[] getShortPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7d386a4:   public byte[] getShortIntPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7d386a4:   }
1:7d386a4: 
1:7d386a4:   @Override
1:7359601:   public int[] getIntPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public long[] getLongPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public float[] getFloatPage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:7359601:   public double[] getDoublePage() {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:7359601: 
1:7359601:   @Override
1:9e064ee:   public byte[] getDecimalPage() {
1:6297ea0:     // output LV encoded byte array
1:6297ea0:     int offset = 0;
1:9e064ee:     byte[] data = new byte[totalLength];
2:6297ea0:     for (int rowId = 0; rowId < pageSize; rowId++) {
1:8925947:       int length = rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId);
1:9e064ee:       copyBytes(rowId, data, offset, length);
1:9e064ee:       offset += length;
1:9e064ee:     }
1:9e064ee:     return data;
1:9e064ee:   }
1:9e064ee: 
1:7359601:   /**
1:7359601:    * Copy `length` bytes from data at rowId to dest start from destOffset
1:7359601:    */
1:7359601:   abstract void copyBytes(int rowId, byte[] dest, int destOffset, int length);
1:7359601: 
1:7359601:   @Override
1:8c1ddbf:   public byte[] getLVFlattenedBytePage() throws IOException {
1:9e064ee:     // output LV encoded byte array
1:9e064ee:     int offset = 0;
1:8925947:     byte[] data = new byte[totalLength + ((rowOffset.getActualRowCount() - 1) * 4)];
1:8925947:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:8925947:       int length = rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId);
1:7359601:       ByteUtil.setInt(data, offset, length);
1:7359601:       copyBytes(rowId, data, offset + 4, length);
1:7359601:       offset += 4 + length;
1:7359601:     }
1:7359601:     return data;
1:7359601:   }
1:7359601: 
1:6297ea0:   @Override public byte[] getComplexChildrenLVFlattenedBytePage() throws IOException {
1:7359601:     // output LV encoded byte array
1:7359601:     int offset = 0;
1:8925947:     byte[] data = new byte[totalLength + ((rowOffset.getActualRowCount() - 1) * 2)];
1:8925947:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:8925947:       short length = (short) (rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId));
1:6297ea0:       ByteUtil.setShort(data, offset, length);
1:6297ea0:       copyBytes(rowId, data, offset + 2, length);
1:6297ea0:       offset += 2 + length;
1:6297ea0:     }
1:6297ea0:     return data;
1:6297ea0:   }
1:6297ea0: 
1:6297ea0:   @Override
1:6297ea0:   public byte[] getComplexParentFlattenedBytePage() throws IOException {
1:6297ea0:     // output LV encoded byte array
1:6297ea0:     int offset = 0;
1:6297ea0:     byte[] data = new byte[totalLength];
1:8925947:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:8925947:       int length =  (rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId));
1:6297ea0:       copyBytes(rowId, data, offset, length);
1:6297ea0:       offset += length;
1:6297ea0:     }
1:6297ea0:     return data;
1:6297ea0:   }
1:6297ea0: 
1:7359601:   @Override
1:e6a4f64:   public void convertValue(ColumnPageValueConverter codec) {
1:8f08c4a:     throw new UnsupportedOperationException(
1:8f08c4a:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:7359601:   }
1:6f20437: 
1:6f20437:   /**
1:6f20437:    * reallocate memory if capacity length than current size + request size
1:6f20437:    */
1:6f20437:   protected void ensureMemory(int requestSize) throws MemoryException {
1:6f20437:     if (totalLength + requestSize > capacity) {
1:e9c24c5:       int newSize = Math.max(2 * capacity, totalLength + requestSize);
1:6f20437:       MemoryBlock newBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, newSize);
1:6f20437:       CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
1:6f20437:           newBlock.getBaseObject(), newBlock.getBaseOffset(), capacity);
1:6f20437:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
1:6f20437:       memoryBlock = newBlock;
1:6f20437:       baseAddress = newBlock.getBaseObject();
1:6f20437:       baseOffset = newBlock.getBaseOffset();
1:6f20437:       capacity = newSize;
1:6f20437:     }
1:6f20437:   }
1:8925947: 
1:8925947:   /**
1:8925947:    * free memory as needed
1:8925947:    */
1:8925947:   public void freeMemory() {
1:8925947:     if (null != rowOffset) {
1:8925947:       rowOffset.freeMemory();
1:8925947:       rowOffset = null;
1:8925947:     }
1:8925947:   }
1:7359601: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
/////////////////////////////////////////////////////////////////////////
1:   VarLengthColumnPageBase(ColumnPageEncoderMeta columnPageEncoderMeta, int pageSize) {
1:     super(columnPageEncoderMeta, pageSize);
1:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec.newInstance(
1:         columnPageEncoderMeta.getColumnSpec().getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:       rowOffset = ColumnPage.newPage(
1:           new ColumnPageEncoderMeta(spec, DataTypes.INT, columnPageEncoderMeta.getCompressorName()),
1:           pageSize);
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:   static ColumnPage newDecimalColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes,
1:       String compressorName) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
1:           CarbonCommonConstants.INT_SIZE_IN_BYTE, compressorName);
1:       return getDecimalColumnPage(columnSpec, lvEncodedBytes, size, compressorName);
/////////////////////////////////////////////////////////////////////////
1:       int lvLength, String compressorName) throws MemoryException {
1:     return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY,
1:         lvLength, compressorName);
1:       byte[] lvEncodedBytes, int lvLength, String compressorName) throws MemoryException {
1:     return getComplexLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY,
1:         lvLength, compressorName);
1:       byte[] lvEncodedBytes, int size, String compressorName) throws MemoryException {
1:     ColumnPage rowOffset = ColumnPage.newPage(
1:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
/////////////////////////////////////////////////////////////////////////
1:       page = new UnsafeDecimalColumnPage(
1:           new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:           rowId);
1:       page = new SafeDecimalColumnPage(
1:           new ColumnPageEncoderMeta(columnSpec, columnSpec.getSchemaDataType(), compressorName),
1:           rowId);
/////////////////////////////////////////////////////////////////////////
1:       byte[] lvEncodedBytes, DataType dataType, int lvLength, String compressorName)
1:     ColumnPage rowOffset = ColumnPage.newPage(
1:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
/////////////////////////////////////////////////////////////////////////
1:     return getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType,
1:         lvLength, rowId, rowOffset, offset, compressorName);
1:       byte[] lvEncodedBytes, DataType dataType, int lvLength, String compressorName)
1:     ColumnPage rowOffset = ColumnPage.newPage(
1:         new ColumnPageEncoderMeta(spec, DataTypes.INT, compressorName),
/////////////////////////////////////////////////////////////////////////
1:     return getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType,
1:         lvLength, rowId, rowOffset, offset, compressorName);
1:       int offset, String compressorName) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
1:       page = new UnsafeDecimalColumnPage(
1:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), numRows,
1:           inputDataLength);
1:       page = new SafeDecimalColumnPage(
1:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), numRows);
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
/////////////////////////////////////////////////////////////////////////
1:     throw new UnsupportedOperationException(
1:         "invalid data type: " + columnPageEncoderMeta.getStoreDataType());
commit:dc53dee
/////////////////////////////////////////////////////////////////////////
1:     // rowId * 4 represents the length of L in LV
1:     if (bytes.length > (Integer.MAX_VALUE - totalLength - rowId * 4)) {
1:       // since we later store a column page in a byte array, so its maximum size is 2GB
1:       throw new RuntimeException("Carbondata only support maximum 2GB size for one column page,"
1:           + " exceed this limit at rowId " + rowId);
1:     }
author:kumarvishal09
-------------------------------------------------------------------------------
commit:4a37e05
/////////////////////////////////////////////////////////////////////////
1:     page.rowOffset.freeMemory();
/////////////////////////////////////////////////////////////////////////
1:     page.rowOffset.freeMemory();
commit:8925947
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonV3DataFormatConstants;
1: import org.apache.carbondata.core.datastore.ColumnType;
/////////////////////////////////////////////////////////////////////////
1:   ColumnPage rowOffset;
/////////////////////////////////////////////////////////////////////////
1:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
1:     try {
0:       rowOffset =
0:           ColumnPage.newPage(spec, DataTypes.INT, pageSize);
1:     } catch (MemoryException e) {
1:       throw new RuntimeException(e);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
0:     ColumnPage rowOffset = ColumnPage.newPage(spec, DataTypes.INT,
1:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:     int counter = 0;
1:       rowOffset.putInt(counter, offset);
1:       counter++;
1:     rowOffset.putInt(counter, offset);
/////////////////////////////////////////////////////////////////////////
1:     page.rowOffset = rowOffset;
/////////////////////////////////////////////////////////////////////////
1:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
1:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
0:     ColumnPage rowOffset = ColumnPage.newPage(spec, DataTypes.INT,
1:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:     int counter = 0;
1:       rowOffset.putInt(counter, offset);
1:       counter++;
1:     rowOffset.putInt(counter, offset);
0:             offset);
/////////////////////////////////////////////////////////////////////////
0:     TableSpec.ColumnSpec spec = TableSpec.ColumnSpec
0:         .newInstance(columnSpec.getFieldName(), DataTypes.INT, ColumnType.MEASURE);
0:     ColumnPage rowOffset = ColumnPage.newPage(spec, DataTypes.INT,
1:         CarbonV3DataFormatConstants.NUMBER_OF_ROWS_PER_BLOCKLET_COLUMN_PAGE_DEFAULT);
1:     int counter = 0;
1:       rowOffset.putInt(counter, offset);
1:       counter++;
1:     rowOffset.putInt(counter, offset);
0:              offset);
1:       byte[] lvEncodedBytes, DataType dataType, int lvLength, int rowId, ColumnPage rowOffset,
0:       int offset) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
1:     page.rowOffset = rowOffset;
1:       length = rowOffset.getInt(i + 1) - rowOffset.getInt(i);
/////////////////////////////////////////////////////////////////////////
1:       rowOffset.putInt(0, 0);
1:     rowOffset.putInt(rowId + 1, rowOffset.getInt(rowId) + bytes.length);
/////////////////////////////////////////////////////////////////////////
1:       int length = rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId);
/////////////////////////////////////////////////////////////////////////
1:     byte[] data = new byte[totalLength + ((rowOffset.getActualRowCount() - 1) * 4)];
1:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:       int length = rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId);
/////////////////////////////////////////////////////////////////////////
1:     byte[] data = new byte[totalLength + ((rowOffset.getActualRowCount() - 1) * 2)];
1:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:       short length = (short) (rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId));
/////////////////////////////////////////////////////////////////////////
1:     for (int rowId = 0; rowId < rowOffset.getActualRowCount() - 1; rowId++) {
1:       int length =  (rowOffset.getInt(rowId + 1) - rowOffset.getInt(rowId));
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * free memory as needed
1:    */
1:   public void freeMemory() {
1:     if (null != rowOffset) {
1:       rowOffset.freeMemory();
1:       rowOffset = null;
1:     }
1:   }
commit:3a4b881
/////////////////////////////////////////////////////////////////////////
0:       int length =  (rowOffset.get(rowId + 1) - rowOffset.get(rowId));
commit:e710339
/////////////////////////////////////////////////////////////////////////
0:   List<Integer> rowOffset;
/////////////////////////////////////////////////////////////////////////
0:     rowOffset = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:     page.rowOffset = new ArrayList<>();
0:     for (int i = 0; i < rowOffset.size(); i++) {
0:       page.rowOffset.add(rowOffset.get(i));
/////////////////////////////////////////////////////////////////////////
0:     page.rowOffset = new ArrayList<>();
0:     for (int i = 0; i < rowOffset.size(); i++) {
0:       page.rowOffset.add(rowOffset.get(i));
/////////////////////////////////////////////////////////////////////////
0:       rowOffset.add(0);
0:     rowOffset.add(rowOffset.get(rowId) + bytes.length);
/////////////////////////////////////////////////////////////////////////
0:       int length = rowOffset.get(rowId + 1) - rowOffset.get(rowId);
/////////////////////////////////////////////////////////////////////////
0:     byte[] data = new byte[totalLength + ((rowOffset.size() - 1) * 4)];
0:     for (int rowId = 0; rowId < rowOffset.size() - 1; rowId++) {
0:       int length = rowOffset.get(rowId + 1) - rowOffset.get(rowId);
/////////////////////////////////////////////////////////////////////////
0:     byte[] data = new byte[totalLength + ((rowOffset.size() - 1) * 2)];
0:     for (int rowId = 0; rowId < rowOffset.size() - 1; rowId++) {
0:       short length = (short) (rowOffset.get(rowId + 1) - rowOffset.get(rowId));
/////////////////////////////////////////////////////////////////////////
0:     for (int rowId = 0; rowId < rowOffset.size() - 1; rowId++) {
0:       short length = (short) (rowOffset.get(rowId + 1) - rowOffset.get(rowId));
commit:6297ea0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
/////////////////////////////////////////////////////////////////////////
1:           DataTypes.createDecimalType(columnSpec.getPrecision(), columnSpec.getScale()),
0:           CarbonCommonConstants.INT_SIZE_IN_BYTE);
/////////////////////////////////////////////////////////////////////////
1:   static ColumnPage newLVBytesColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes,
0:       int lvLength) throws MemoryException {
0:     return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY, lvLength);
1:   }
1: 
1:   /**
1:    * Create a new column page based on the LV (Length Value) encoded bytes
1:    */
1:   static ColumnPage newComplexLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedBytes, int lvLength) throws MemoryException {
0:     return getComplexLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY, lvLength);
/////////////////////////////////////////////////////////////////////////
0:       byte[] lvEncodedBytes, DataType dataType, int lvLength)
/////////////////////////////////////////////////////////////////////////
1:       lvEncodedOffset += lvLength + length;
1:       rowId++;
1:     }
0:     rowOffset.add(offset);
0:     VarLengthColumnPageBase page =
0:         getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType, lvLength, rowId, rowOffset,
0:             rowLength, offset);
1:     return page;
1:   }
1: 
1:   private static ColumnPage getComplexLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedBytes, DataType dataType, int lvLength)
1:       throws MemoryException {
1:     // extract length and data, set them to rowOffset and unsafe memory correspondingly
1:     int rowId = 0;
0:     List<Integer> rowOffset = new ArrayList<>();
0:     List<Integer> rowLength = new ArrayList<>();
1:     int length;
1:     int offset;
1:     int lvEncodedOffset = 0;
1: 
1:     // extract Length field in input and calculate total length
1:     for (offset = 0; lvEncodedOffset < lvEncodedBytes.length; offset += length) {
1:       length = ByteUtil.toShort(lvEncodedBytes, lvEncodedOffset);
0:       rowOffset.add(offset);
0:       rowLength.add(length);
1:       lvEncodedOffset += lvLength + length;
0:     VarLengthColumnPageBase page =
0:         getVarLengthColumnPage(columnSpec, lvEncodedBytes, dataType, lvLength, rowId, rowOffset,
0:             rowLength, offset);
1:     return page;
1:   }
1: 
1:   private static VarLengthColumnPageBase getVarLengthColumnPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedBytes, DataType dataType, int lvLength, int rowId, List<Integer> rowOffset,
0:       List<Integer> rowLength, int offset) throws MemoryException {
1:     int lvEncodedOffset;
1:     int length;
/////////////////////////////////////////////////////////////////////////
1:       page.putBytes(i, lvEncodedBytes, lvEncodedOffset + lvLength, length);
1:       lvEncodedOffset += lvLength + length;
/////////////////////////////////////////////////////////////////////////
1:   @Override public byte[] getComplexChildrenLVFlattenedBytePage() throws IOException {
1:     // output LV encoded byte array
1:     int offset = 0;
0:     byte[] data = new byte[totalLength + pageSize * 2];
1:     for (int rowId = 0; rowId < pageSize; rowId++) {
0:       short length = (short) (rowOffset[rowId + 1] - rowOffset[rowId]);
1:       ByteUtil.setShort(data, offset, length);
1:       copyBytes(rowId, data, offset + 2, length);
1:       offset += 2 + length;
1:     }
1:     return data;
1:   }
1: 
1:   @Override
1:   public byte[] getComplexParentFlattenedBytePage() throws IOException {
1:     // output LV encoded byte array
1:     int offset = 0;
1:     byte[] data = new byte[totalLength];
1:     for (int rowId = 0; rowId < pageSize; rowId++) {
0:       short length = (short) (rowOffset[rowId + 1] - rowOffset[rowId]);
1:       copyBytes(rowId, data, offset, length);
1:       offset += length;
1:     }
1:     return data;
1:   }
1: 
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
1:   static final int byteBits = DataTypes.BYTE.getSizeBits();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:       return getLVBytesColumnPage(columnSpec, lvEncodedBytes,
0:           DataTypes.createDecimalType(columnSpec.getPrecision(), columnSpec.getScale()));
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeDecimalColumnPage(columnSpec, columnSpec.getSchemaDataType(), rowId);
0:       page = new SafeDecimalColumnPage(columnSpec, columnSpec.getSchemaDataType(), rowId);
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeDecimalColumnPage(columnSpec, dataType, numRows, inputDataLength);
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
0: import static org.apache.carbondata.core.metadata.datatype.DataTypes.BYTE;
0: import static org.apache.carbondata.core.metadata.datatype.DataTypes.DECIMAL;
1:   static final int shortBits = DataTypes.SHORT.getSizeBits();
1:   static final int intBits = DataTypes.INT.getSizeBits();
1:   static final int longBits = DataTypes.LONG.getSizeBits();
/////////////////////////////////////////////////////////////////////////
0:       return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.DECIMAL);
/////////////////////////////////////////////////////////////////////////
0:     return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataTypes.BYTE_ARRAY);
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.carbondata.core.datastore.TableSpec;
/////////////////////////////////////////////////////////////////////////
0:   VarLengthColumnPageBase(TableSpec.ColumnSpec columnSpec, DataType dataType, int pageSize) {
0:     super(columnSpec, dataType, pageSize);
/////////////////////////////////////////////////////////////////////////
0:   static ColumnPage newDecimalColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes)
1:         DecimalConverterFactory.INSTANCE.getDecimalConverter(columnSpec.getPrecision(),
1:             columnSpec.getScale());
0:       return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataType.DECIMAL);
0:       return getDecimalColumnPage(columnSpec, lvEncodedBytes, size);
0:   static ColumnPage newLVBytesColumnPage(TableSpec.ColumnSpec columnSpec, byte[] lvEncodedBytes)
0:     return getLVBytesColumnPage(columnSpec, lvEncodedBytes, DataType.BYTE_ARRAY);
1:   private static ColumnPage getDecimalColumnPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedBytes, int size) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeVarLengthColumnPage(columnSpec, DECIMAL, rowId);
0:       page = new SafeVarLengthColumnPage(columnSpec, DECIMAL, rowId);
/////////////////////////////////////////////////////////////////////////
1:   private static ColumnPage getLVBytesColumnPage(TableSpec.ColumnSpec columnSpec,
0:       byte[] lvEncodedBytes, DataType dataType)
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeVarLengthColumnPage(columnSpec, DECIMAL, numRows, inputDataLength);
0:       page = new SafeVarLengthColumnPage(columnSpec, dataType, numRows);
/////////////////////////////////////////////////////////////////////////
1:   public byte[] getLVFlattenedBytePage() throws IOException {
commit:e6a4f64
/////////////////////////////////////////////////////////////////////////
1:    * Create a new column page for decimal page
/////////////////////////////////////////////////////////////////////////
0:       return getLVBytesColumnPage(lvEncodedBytes, DataType.DECIMAL);
/////////////////////////////////////////////////////////////////////////
0:   static ColumnPage newLVBytesColumnPage(byte[] lvEncodedBytes)
0:     return getLVBytesColumnPage(lvEncodedBytes, DataType.BYTE_ARRAY);
/////////////////////////////////////////////////////////////////////////
0:   private static ColumnPage getLVBytesColumnPage(byte[] lvEncodedBytes, DataType dataType)
1:       throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeVarLengthColumnPage(DECIMAL, numRows, inputDataLength, -1, -1);
0:       page = new SafeVarLengthColumnPage(dataType, numRows, -1, -1);
/////////////////////////////////////////////////////////////////////////
1:   public void convertValue(ColumnPageValueConverter codec) {
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:e9c24c5
/////////////////////////////////////////////////////////////////////////
1:       int newSize = Math.max(2 * capacity, totalLength + requestSize);
author:manishgupta88
-------------------------------------------------------------------------------
commit:6f20437
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.CarbonUnsafe;
1: import org.apache.carbondata.core.memory.MemoryBlock;
1: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
0: import static org.apache.carbondata.core.metadata.datatype.DataType.BYTE;
0:   static final int byteBits = BYTE.getSizeBits();
0:   static final int shortBits = DataType.SHORT.getSizeBits();
0:   static final int intBits = DataType.INT.getSizeBits();
0:   static final int longBits = DataType.LONG.getSizeBits();
1:   // default size for each row, grows as needed
1:   static final int DEFAULT_ROW_SIZE = 8;
1: 
1:   static final double FACTOR = 1.25;
1: 
1:   final long taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
1: 
1:   // memory allocated by Unsafe
1:   MemoryBlock memoryBlock;
1: 
1:   // base address of memoryBlock
1:   Object baseAddress;
1: 
1:   // base offset of memoryBlock
1:   long baseOffset;
1: 
1:   // size of the allocated memory, in bytes
1:   int capacity;
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeDecimalColumnPage(columnSpec, DECIMAL, rowId);
0:       page = new SafeDecimalColumnPage(columnSpec, DECIMAL, rowId);
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeDecimalColumnPage(columnSpec, DECIMAL, numRows, inputDataLength);
0:       page = new SafeDecimalColumnPage(columnSpec, dataType, numRows);
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * reallocate memory if capacity length than current size + request size
1:    */
1:   protected void ensureMemory(int requestSize) throws MemoryException {
1:     if (totalLength + requestSize > capacity) {
0:       int newSize = 2 * capacity;
1:       MemoryBlock newBlock = UnsafeMemoryManager.allocateMemoryWithRetry(taskId, newSize);
1:       CarbonUnsafe.getUnsafe().copyMemory(baseAddress, baseOffset,
1:           newBlock.getBaseObject(), newBlock.getBaseOffset(), capacity);
1:       UnsafeMemoryManager.INSTANCE.freeMemory(taskId, memoryBlock);
1:       memoryBlock = newBlock;
1:       baseAddress = newBlock.getBaseObject();
1:       baseOffset = newBlock.getBaseOffset();
1:       capacity = newSize;
1:     }
1:   }
author:ravipesala
-------------------------------------------------------------------------------
commit:9e064ee
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DecimalConverterFactory;
/////////////////////////////////////////////////////////////////////////
0:   VarLengthColumnPageBase(DataType dataType, int pageSize, int scale, int precision) {
0:     super(dataType, pageSize, scale, precision);
/////////////////////////////////////////////////////////////////////////
0:   static ColumnPage newDecimalColumnPage(byte[] lvEncodedBytes, int scale, int precision)
0:       throws MemoryException {
1:     DecimalConverterFactory.DecimalConverter decimalConverter =
0:         DecimalConverterFactory.INSTANCE.getDecimalConverter(precision, scale);
1:     int size = decimalConverter.getSize();
1:     if (size < 0) {
0:       return getLVBytesColumnPage(lvEncodedBytes, scale, precision, DataType.DECIMAL);
1:     } else {
1:       // Here the size is always fixed.
0:       return getDecimalColumnPage(lvEncodedBytes, scale, precision, size);
1:     }
1:   }
1: 
1:   /**
1:    * Create a new column page based on the LV (Length Value) encoded bytes
1:    */
0:   static ColumnPage newVarLengthColumnPage(byte[] lvEncodedBytes, int scale, int precision)
0:       throws MemoryException {
0:     return getLVBytesColumnPage(lvEncodedBytes, scale, precision, DataType.BYTE_ARRAY);
1:   }
1: 
0:   private static ColumnPage getDecimalColumnPage(byte[] lvEncodedBytes, int scale, int precision,
0:       int size) throws MemoryException {
0:     List<Integer> rowOffset = new ArrayList<>();
1:     int offset;
1:     int rowId = 0;
1:     for (offset = 0; offset < lvEncodedBytes.length; offset += size) {
0:       rowOffset.add(offset);
1:       rowId++;
1:     }
0:     rowOffset.add(offset);
1: 
1:     VarLengthColumnPageBase page;
1:     if (unsafe) {
0:       page = new UnsafeVarLengthColumnPage(DECIMAL, rowId, scale, precision);
1:     } else {
0:       page = new SafeVarLengthColumnPage(DECIMAL, rowId, scale, precision);
1:     }
1: 
1:     // set total length and rowOffset in page
1:     page.totalLength = offset;
0:     page.rowOffset = new int[rowId + 1];
0:     for (int i = 0; i < rowId + 1; i++) {
0:       page.rowOffset[i] = rowOffset.get(i);
1:     }
1:     for (int i = 0; i < rowId; i++) {
1:       page.putBytes(i, lvEncodedBytes, i * size, size);
1:     }
0:     return page;
1:   }
1: 
0:   private static ColumnPage getLVBytesColumnPage(byte[] lvEncodedBytes, int scale,
0:       int precision, DataType dataType) throws MemoryException {
/////////////////////////////////////////////////////////////////////////
0:       page = new UnsafeVarLengthColumnPage(DECIMAL, numRows, inputDataLength, scale, precision);
0:       page = new SafeVarLengthColumnPage(dataType, numRows, scale, precision);
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public byte[] getDecimalPage() {
1:     // output LV encoded byte array
1:     int offset = 0;
1:     byte[] data = new byte[totalLength];
0:     for (int rowId = 0; rowId < pageSize; rowId++) {
0:       int length = rowOffset[rowId + 1] - rowOffset[rowId];
1:       copyBytes(rowId, data, offset, length);
1:       offset += length;
1:     }
1:     return data;
1:   }
1: 
author:jackylk
-------------------------------------------------------------------------------
commit:fdb672a
/////////////////////////////////////////////////////////////////////////
1:     int inputDataLength = offset;
0:       page = new UnsafeVarLengthColumnPage(DECIMAL, numRows, inputDataLength);
commit:7d386a4
/////////////////////////////////////////////////////////////////////////
1:   public void setShortIntPage(byte[] shortIntData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   public void putShortInt(int rowId, int value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   public int getShortInt(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   public byte[] getShortIntPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
commit:7359601
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.datastore.page;
1: 
0: import java.util.ArrayList;
0: import java.util.List;
1: 
1: import org.apache.carbondata.core.memory.MemoryException;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.util.ByteUtil;
1: 
0: import static org.apache.carbondata.core.metadata.datatype.DataType.DECIMAL;
1: 
1: public abstract class VarLengthColumnPageBase extends ColumnPage {
1: 
1:   // the offset of row in the unsafe memory, its size is pageSize + 1
0:   int[] rowOffset;
1: 
1:   // the length of bytes added in the page
1:   int totalLength;
1: 
0:   VarLengthColumnPageBase(DataType dataType, int pageSize) {
0:     super(dataType, pageSize);
0:     rowOffset = new int[pageSize + 1];
1:     totalLength = 0;
1:   }
1: 
1:   @Override
1:   public void setBytePage(byte[] byteData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setShortPage(short[] shortData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setIntPage(int[] intData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setLongPage(long[] longData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setFloatPage(float[] floatData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void setDoublePage(double[] doubleData) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
0:   public void setByteArrayPage(byte[][] byteArray) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   /**
0:    * Create a new column page based on the LV (Length Value) encoded bytes
1:    */
0:   static ColumnPage newDecimalColumnPage(byte[] lvEncodedBytes) throws MemoryException {
1:     // extract length and data, set them to rowOffset and unsafe memory correspondingly
1:     int rowId = 0;
0:     List<Integer> rowOffset = new ArrayList<>();
0:     List<Integer> rowLength = new ArrayList<>();
1:     int length;
1:     int offset;
1:     int lvEncodedOffset = 0;
1: 
1:     // extract Length field in input and calculate total length
1:     for (offset = 0; lvEncodedOffset < lvEncodedBytes.length; offset += length) {
1:       length = ByteUtil.toInt(lvEncodedBytes, lvEncodedOffset);
0:       rowOffset.add(offset);
0:       rowLength.add(length);
0:       lvEncodedOffset += 4 + length;
1:       rowId++;
1:     }
0:     rowOffset.add(offset);
1: 
1:     int numRows = rowId;
1: 
1:     VarLengthColumnPageBase page;
1:     if (unsafe) {
0:       page = new UnsafeVarLengthColumnPage(DECIMAL, numRows);
1:     } else {
0:       page = new SafeVarLengthColumnPage(DECIMAL, numRows);
1:     }
1: 
1:     // set total length and rowOffset in page
1:     page.totalLength = offset;
0:     page.rowOffset = new int[rowId + 1];
0:     for (int i = 0; i < rowId + 1; i++) {
0:       page.rowOffset[i] = rowOffset.get(i);
1:     }
1: 
1:     // set data in page
1:     lvEncodedOffset = 0;
1:     for (int i = 0; i < numRows; i++) {
0:       length = rowLength.get(i);
0:       page.putBytes(i, lvEncodedBytes, lvEncodedOffset + 4, length);
0:       lvEncodedOffset += 4 + length;
1:     }
1: 
0:     return page;
1:   }
1: 
1:   @Override
1:   public void putByte(int rowId, byte value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void putShort(int rowId, short value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void putInt(int rowId, int value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void putLong(int rowId, long value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public void putDouble(int rowId, double value) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   abstract void putBytesAtRow(int rowId, byte[] bytes);
1: 
1:   @Override
1:   public void putBytes(int rowId, byte[] bytes) {
1:     if (rowId == 0) {
0:       rowOffset[0] = 0;
1:     }
0:     rowOffset[rowId + 1] = rowOffset[rowId] + bytes.length;
1:     putBytesAtRow(rowId, bytes);
1:     totalLength += bytes.length;
1:   }
1: 
1:   @Override
1:   public byte getByte(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public short getShort(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public int getInt(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public long getLong(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public float getFloat(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public double getDouble(int rowId) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public byte[] getBytePage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public short[] getShortPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public int[] getIntPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public long[] getLongPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public float[] getFloatPage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   @Override
1:   public double[] getDoublePage() {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: 
1:   /**
1:    * Copy `length` bytes from data at rowId to dest start from destOffset
1:    */
1:   abstract void copyBytes(int rowId, byte[] dest, int destOffset, int length);
1: 
1:   @Override
0:   public byte[] getFlattenedBytePage() {
1:     // output LV encoded byte array
1:     int offset = 0;
0:     byte[] data = new byte[totalLength + pageSize * 4];
0:     for (int rowId = 0; rowId < pageSize; rowId++) {
0:       int length = rowOffset[rowId + 1] - rowOffset[rowId];
1:       ByteUtil.setInt(data, offset, length);
1:       copyBytes(rowId, data, offset + 4, length);
1:       offset += 4 + length;
1:     }
1:     return data;
1:   }
1: 
1:   @Override
0:   public void encode(PrimitiveCodec codec) {
0:     throw new UnsupportedOperationException("invalid data type: " + dataType);
1:   }
1: }
============================================================================