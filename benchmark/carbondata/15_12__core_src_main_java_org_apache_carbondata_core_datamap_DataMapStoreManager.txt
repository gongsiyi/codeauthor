1:b434346: /*
1:b434346:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b434346:  * contributor license agreements.  See the NOTICE file distributed with
1:b434346:  * this work for additional information regarding copyright ownership.
1:b434346:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b434346:  * (the "License"); you may not use this file except in compliance with
1:b434346:  * the License.  You may obtain a copy of the License at
1:b434346:  *
1:b434346:  *    http://www.apache.org/licenses/LICENSE-2.0
1:b434346:  *
1:b434346:  * Unless required by applicable law or agreed to in writing, software
1:b434346:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b434346:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b434346:  * See the License for the specific language governing permissions and
1:b434346:  * limitations under the License.
1:b434346:  */
1:f089287: package org.apache.carbondata.core.datamap;
1:b434346: 
1:bbb1092: import java.io.IOException;
1:b681244: import java.util.ArrayList;
1:b434346: import java.util.HashMap;
1:b08ef00: import java.util.Iterator;
1:b681244: import java.util.List;
1:b434346: import java.util.Map;
1:f089287: import java.util.concurrent.ConcurrentHashMap;
1:b434346: 
1:fc2a7eb: import org.apache.carbondata.common.annotations.InterfaceAudience;
1:56330ae: import org.apache.carbondata.common.exceptions.MetadataProcessException;
1:56330ae: import org.apache.carbondata.common.exceptions.sql.MalformedDataMapCommandException;
1:9fba684: import org.apache.carbondata.common.exceptions.sql.NoSuchDataMapException;
1:b434346: import org.apache.carbondata.common.logging.LogService;
1:b434346: import org.apache.carbondata.common.logging.LogServiceFactory;
1:b08ef00: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:fc2a7eb: import org.apache.carbondata.core.datamap.dev.DataMapFactory;
1:28f78b2: import org.apache.carbondata.core.indexstore.BlockletDetailsFetcher;
1:ca7e2e3: import org.apache.carbondata.core.indexstore.SegmentPropertiesFetcher;
1:fc2a7eb: import org.apache.carbondata.core.indexstore.blockletindex.BlockletDataMapFactory;
1:b434346: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:2018048: import org.apache.carbondata.core.metadata.CarbonMetadata;
1:56330ae: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:56330ae: import org.apache.carbondata.core.metadata.schema.table.DataMapSchema;
1:05086e5: import org.apache.carbondata.core.metadata.schema.table.DataMapSchemaStorageProvider;
1:05086e5: import org.apache.carbondata.core.metadata.schema.table.DiskBasedDMSchemaStorageProvider;
1:05086e5: import org.apache.carbondata.core.metadata.schema.table.RelationIdentifier;
1:eb771f5: import org.apache.carbondata.core.mutate.SegmentUpdateDetails;
1:eb771f5: import org.apache.carbondata.core.mutate.UpdateVO;
1:f1a6c7c: import org.apache.carbondata.core.statusmanager.SegmentRefreshInfo;
1:eb771f5: import org.apache.carbondata.core.statusmanager.SegmentUpdateStatusManager;
1:05086e5: import org.apache.carbondata.core.util.CarbonProperties;
1:b08ef00: import org.apache.carbondata.core.util.CarbonSessionInfo;
1:b08ef00: import org.apache.carbondata.core.util.ThreadLocalSessionInfo;
1:b434346: 
1:cdee81d: import static org.apache.carbondata.core.metadata.schema.datamap.DataMapClassProvider.MV;
1:cdee81d: import static org.apache.carbondata.core.metadata.schema.datamap.DataMapClassProvider.PREAGGREGATE;
1:cdee81d: 
1:347b8e1: import org.apache.hadoop.fs.Path;
1:347b8e1: 
1:b434346: /**
1:b681244:  * It maintains all the DataMaps in it.
1:b434346:  */
1:fc2a7eb: @InterfaceAudience.Internal
1:b681244: public final class DataMapStoreManager {
1:b434346: 
1:b434346:   private static DataMapStoreManager instance = new DataMapStoreManager();
1:b434346: 
1:2018048:   public Map<String, List<TableDataMap>> getAllDataMaps() {
1:2018048:     return allDataMaps;
1:2018048:   }
1:9fba684: 
1:b681244:   /**
1:b681244:    * Contains the list of datamaps for each table.
1:05086e5:    */
1:f089287:   private Map<String, List<TableDataMap>> allDataMaps = new ConcurrentHashMap<>();
1:d35fbaf: 
1:05086e5:   /**
1:347b8e1:    * Contains the table name to the tablepath mapping.
1:347b8e1:    */
1:347b8e1:   private Map<String, String> tablePathMap = new ConcurrentHashMap<>();
1:347b8e1: 
1:347b8e1:   /**
1:05086e5:    * Contains the datamap catalog for each datamap provider.
1:05086e5:    */
1:ffddba7:   private Map<String, DataMapCatalog> dataMapCatalogs = null;
1:05086e5: 
1:eb771f5:   private Map<String, TableSegmentRefresher> segmentRefreshMap = new ConcurrentHashMap<>();
1:b434346: 
1:5f2a748:   private DataMapSchemaStorageProvider provider = new DiskBasedDMSchemaStorageProvider(
1:5f2a748:       CarbonProperties.getInstance().getSystemFolderLocation());
1:5f2a748: 
1:b434346:   private static final LogService LOGGER =
1:b434346:       LogServiceFactory.getLogService(DataMapStoreManager.class.getName());
1:b434346: 
1:b434346:   private DataMapStoreManager() {
1:b434346: 
1:9fba684:   }
1:b434346: 
1:b434346:   /**
1:b08ef00:    * It only gives the visible datamaps
1:b681244:    */
1:747be9b:   List<TableDataMap> getAllVisibleDataMap(CarbonTable carbonTable) throws IOException {
1:b08ef00:     CarbonSessionInfo sessionInfo = ThreadLocalSessionInfo.getCarbonSessionInfo();
1:b08ef00:     List<TableDataMap> allDataMaps = getAllDataMap(carbonTable);
1:b08ef00:     Iterator<TableDataMap> dataMapIterator = allDataMaps.iterator();
1:b08ef00:     while (dataMapIterator.hasNext()) {
1:b08ef00:       TableDataMap dataMap = dataMapIterator.next();
1:b08ef00:       String dbName = carbonTable.getDatabaseName();
1:b08ef00:       String tableName = carbonTable.getTableName();
1:b08ef00:       String dmName = dataMap.getDataMapSchema().getDataMapName();
1:b338459:       // TODO: need support get the visible status of datamap without sessionInfo in the future
1:b338459:       if (sessionInfo != null) {
1:b08ef00:         boolean isDmVisible = sessionInfo.getSessionParams().getProperty(
1:b08ef00:             String.format("%s%s.%s.%s", CarbonCommonConstants.CARBON_DATAMAP_VISIBLE,
1:b08ef00:                 dbName, tableName, dmName), "true").trim().equalsIgnoreCase("true");
1:b08ef00:         if (!isDmVisible) {
1:b08ef00:           LOGGER.warn(String.format("Ignore invisible datamap %s on table %s.%s",
1:b08ef00:               dmName, dbName, tableName));
1:b08ef00:           dataMapIterator.remove();
1:9fba684:         }
1:b434346:       } else {
1:b338459:         String message = "Carbon session info is null";
1:b338459:         LOGGER.info(message);
1:9fba684:       }
1:d35fbaf:     }
1:b08ef00:     return allDataMaps;
1:b681244:   }
1:b08ef00: 
1:b08ef00:   /**
1:56330ae:    * It gives all datamaps except the default datamap.
1:05086e5:    *
1:05086e5:    * @return
1:b08ef00:    */
1:5f2a748:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable) throws IOException {
1:5f2a748:     List<DataMapSchema> dataMapSchemas = getDataMapSchemasOfTable(carbonTable);
2:56330ae:     List<TableDataMap> dataMaps = new ArrayList<>();
1:05086e5:     if (dataMapSchemas != null) {
1:05086e5:       for (DataMapSchema dataMapSchema : dataMapSchemas) {
1:05086e5:         RelationIdentifier identifier = dataMapSchema.getParentTables().get(0);
1:cdee81d:         if (dataMapSchema.isIndexDataMap() && identifier.getTableId()
1:cdee81d:             .equals(carbonTable.getTableId())) {
1:7e0803f:           dataMaps.add(getDataMap(carbonTable, dataMapSchema));
1:05086e5:         }
1:05086e5:       }
1:05086e5:     }
1:05086e5:     return dataMaps;
1:05086e5:   }
1:05086e5: 
1:05086e5:   /**
1:5f2a748:    * It gives all datamap schemas of a given table.
1:b434346:    *
1:56330ae:    */
1:5f2a748:   public List<DataMapSchema> getDataMapSchemasOfTable(CarbonTable carbonTable) throws IOException {
1:5f2a748:     return provider.retrieveSchemas(carbonTable);
1:05086e5:   }
1:05086e5: 
1:5f2a748:   /**
1:5f2a748:    * It gives all datamap schemas from store.
1:5f2a748:    */
1:5f2a748:   public List<DataMapSchema> getAllDataMapSchemas() throws IOException {
1:5f2a748:     return provider.retrieveAllSchemas();
1:05086e5:   }
1:5f2a748: 
1:a85b4f4: 
1:5f2a748:   public DataMapSchema getDataMapSchema(String dataMapName)
1:5f2a748:       throws NoSuchDataMapException, IOException {
1:5f2a748:     return provider.retrieveSchema(dataMapName);
1:5f2a748:   }
1:5f2a748: 
1:5f2a748:   /**
1:5f2a748:    * Saves the datamap schema to storage
1:5f2a748:    * @param dataMapSchema
1:5f2a748:    */
1:5f2a748:   public void saveDataMapSchema(DataMapSchema dataMapSchema) throws IOException {
1:5f2a748:     provider.saveSchema(dataMapSchema);
1:5f2a748:   }
1:5f2a748: 
1:5f2a748:   /**
1:5f2a748:    * Drops the datamap schema from storage
1:5f2a748:    * @param dataMapName
1:5f2a748:    */
1:5f2a748:   public void dropDataMapSchema(String dataMapName) throws IOException {
1:5f2a748:     provider.dropSchema(dataMapName);
1:b434346:   }
1:2018048: 
1:56330ae:   /**
1:cdee81d:    * Update the datamap schema after table rename
1:cdee81d:    * This should be invoked after changing table name
1:cdee81d:    * @param dataMapSchemaList
1:cdee81d:    * @param newTableName
1:cdee81d:    */
1:cdee81d:   public void updateDataMapSchema(List<DataMapSchema> dataMapSchemaList,
1:cdee81d:       String newTableName) throws IOException {
1:cdee81d:     List<DataMapSchema> newDataMapSchemas = new ArrayList<>();
1:cdee81d:     for (DataMapSchema dataMapSchema : dataMapSchemaList) {
1:cdee81d:       RelationIdentifier relationIdentifier = dataMapSchema.getRelationIdentifier();
1:cdee81d:       String dataBaseName =  relationIdentifier.getDatabaseName();
1:cdee81d:       String tableId = relationIdentifier.getTableId();
1:cdee81d:       String providerName = dataMapSchema.getProviderName();
1:cdee81d:       // if the preaggregate datamap,not be modified the schema
1:cdee81d:       if (providerName.equalsIgnoreCase(PREAGGREGATE.toString())) {
1:cdee81d:         continue;
1:cdee81d:       }
1:cdee81d:       // if the mv datamap,not be modified the relationIdentifier
1:cdee81d:       if (!providerName.equalsIgnoreCase(MV.toString())) {
1:cdee81d:         RelationIdentifier newRelationIdentifier = new RelationIdentifier(dataBaseName,
1:cdee81d:             newTableName, tableId);
1:cdee81d:         dataMapSchema.setRelationIdentifier(newRelationIdentifier);
1:cdee81d:       }
1:cdee81d:       List<RelationIdentifier> newParentTables = new ArrayList<>();
1:cdee81d:       List<RelationIdentifier> parentTables = dataMapSchema.getParentTables();
1:cdee81d:       for (RelationIdentifier identifier : parentTables) {
1:cdee81d:         RelationIdentifier newParentTableIdentifier = new RelationIdentifier(
1:cdee81d:             identifier.getDatabaseName(), newTableName, identifier.getTableId());
1:cdee81d:         newParentTables.add(newParentTableIdentifier);
1:cdee81d:       }
1:cdee81d:       dataMapSchema.setParentTables(newParentTables);
1:cdee81d:       newDataMapSchemas.add(dataMapSchema);
1:cdee81d:       // frist drop old schema
1:cdee81d:       String dataMapName = dataMapSchema.getDataMapName();
1:cdee81d:       dropDataMapSchema(dataMapName);
1:cdee81d:     }
1:cdee81d:     // save new datamap schema to storage
1:cdee81d:     for (DataMapSchema newDataMapSchema : newDataMapSchemas) {
1:cdee81d:       saveDataMapSchema(newDataMapSchema);
1:cdee81d:     }
1:cdee81d:   }
1:cdee81d: 
1:cdee81d:   /**
1:05086e5:    * Register datamap catalog for the datamap provider
1:05086e5:    * @param dataMapProvider
1:05086e5:    * @param dataMapSchema
1:05086e5:    */
1:05086e5:   public synchronized void registerDataMapCatalog(DataMapProvider dataMapProvider,
1:ffddba7:       DataMapSchema dataMapSchema) throws IOException {
1:e30a84c:     initializeDataMapCatalogs(dataMapProvider);
1:05086e5:     String name = dataMapSchema.getProviderName();
1:05086e5:     DataMapCatalog dataMapCatalog = dataMapCatalogs.get(name);
1:05086e5:     if (dataMapCatalog == null) {
1:05086e5:       dataMapCatalog = dataMapProvider.createDataMapCatalog();
1:05086e5:       if (dataMapCatalog != null) {
1:05086e5:         dataMapCatalogs.put(name, dataMapCatalog);
1:05086e5:         dataMapCatalog.registerSchema(dataMapSchema);
1:05086e5:       }
1:05086e5:     } else {
1:05086e5:       dataMapCatalog.registerSchema(dataMapSchema);
1:05086e5:     }
1:05086e5:   }
1:05086e5: 
1:05086e5:   /**
1:05086e5:    * Unregister datamap catalog.
1:05086e5:    * @param dataMapSchema
1:05086e5:    */
1:05086e5:   public synchronized void unRegisterDataMapCatalog(DataMapSchema dataMapSchema) {
1:ffddba7:     if (dataMapCatalogs == null) {
1:ffddba7:       return;
1:b08ef00:     }
1:05086e5:     String name = dataMapSchema.getProviderName();
1:05086e5:     DataMapCatalog dataMapCatalog = dataMapCatalogs.get(name);
1:05086e5:     if (dataMapCatalog != null) {
1:05086e5:       dataMapCatalog.unregisterSchema(dataMapSchema.getDataMapName());
1:05086e5:     }
1:05086e5:   }
1:05086e5: 
1:05086e5:   /**
1:05086e5:    * Get the datamap catalog for provider.
1:05086e5:    * @param providerName
1:b434346:    * @return
1:56330ae:    */
1:7ef9164:   public synchronized DataMapCatalog getDataMapCatalog(DataMapProvider dataMapProvider,
1:7ef9164:       String providerName) throws IOException {
1:e30a84c:     initializeDataMapCatalogs(dataMapProvider);
1:05086e5:     return dataMapCatalogs.get(providerName);
1:b08ef00:   }
1:f089287: 
1:56330ae:   /**
1:ffddba7:    * Initialize by reading all datamaps from store and re register it
1:ffddba7:    * @param dataMapProvider
1:ffddba7:    */
1:e30a84c:   private void initializeDataMapCatalogs(DataMapProvider dataMapProvider) throws IOException {
1:ffddba7:     if (dataMapCatalogs == null) {
1:ffddba7:       dataMapCatalogs = new ConcurrentHashMap<>();
1:05086e5:       List<DataMapSchema> dataMapSchemas = getAllDataMapSchemas();
1:ffddba7:       for (DataMapSchema schema : dataMapSchemas) {
1:ffddba7:         DataMapCatalog dataMapCatalog = dataMapCatalogs.get(schema.getProviderName());
1:ffddba7:         if (dataMapCatalog == null) {
1:ffddba7:           dataMapCatalog = dataMapProvider.createDataMapCatalog();
1:7ef9164:           if (null == dataMapCatalog) {
1:7ef9164:             throw new RuntimeException("Internal Error.");
1:b08ef00:           }
1:ffddba7:           dataMapCatalogs.put(schema.getProviderName(), dataMapCatalog);
1:a85b4f4:         }
1:05086e5:         try {
1:ffddba7:           dataMapCatalog.registerSchema(schema);
1:ffddba7:         } catch (Exception e) {
1:ffddba7:           // Ignore the schema
1:ffddba7:           LOGGER.error(e, "Error while registering schema");
1:a85b4f4:         }
1:b338459:       }
1:7ef9164:     }
1:ffddba7:   }
1:ffddba7: 
1:ffddba7:   /**
1:fc2a7eb:    * It gives the default datamap of the table. Default datamap of any table is BlockletDataMap
1:56330ae:    *
1:7e0803f:    * @param table
1:2018048:    * @return
1:56330ae:    */
1:7e0803f:   public TableDataMap getDefaultDataMap(CarbonTable table) {
1:7e0803f:     return getDataMap(table, BlockletDataMapFactory.DATA_MAP_SCHEMA);
1:ffddba7:   }
1:56330ae: 
1:56330ae:   /**
1:b434346:    * Get the datamap for reading data.
1:b434346:    */
1:7e0803f:   public TableDataMap getDataMap(CarbonTable table, DataMapSchema dataMapSchema) {
1:7e0803f:     String tableUniqueName =
1:7e0803f:         table.getAbsoluteTableIdentifier().getCarbonTableIdentifier().getTableUniqueName();
1:7e0803f:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:de0f545:     if (tableIndices == null) {
1:de0f545:       String keyUsingTablePath = getKeyUsingTablePath(table.getTablePath());
1:de0f545:       if (keyUsingTablePath != null) {
1:de0f545:         tableUniqueName = keyUsingTablePath;
1:de0f545:         tableIndices = allDataMaps.get(tableUniqueName);
1:de0f545:       }
1:de0f545:     }
1:b434346:     TableDataMap dataMap = null;
1:fc2a7eb:     if (tableIndices != null) {
1:fc2a7eb:       dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableIndices);
1:2018048:     }
1:b681244:     if (dataMap == null) {
1:7e0803f:       synchronized (tableUniqueName.intern()) {
1:7e0803f:         tableIndices = allDataMaps.get(tableUniqueName);
1:fc2a7eb:         if (tableIndices != null) {
1:fc2a7eb:           dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableIndices);
1:2018048:         }
1:b434346:         if (dataMap == null) {
1:ffddba7:           try {
1:7e0803f:             dataMap = createAndRegisterDataMap(table, dataMapSchema);
1:b434346:           } catch (Exception e) {
1:05086e5:             throw new RuntimeException(e);
1:f089287:           }
1:56330ae:         }
1:56330ae:       }
1:56330ae:     }
1:2018048: 
2:56330ae:     if (dataMap == null) {
1:b681244:       throw new RuntimeException("Datamap does not exist");
1:b434346:     }
1:d35fbaf:     return dataMap;
1:d35fbaf:   }
1:b434346: 
1:de0f545:   private String getKeyUsingTablePath(String tablePath) {
1:de0f545:     if (tablePath != null) {
1:de0f545:       // Try get using table path
1:de0f545:       for (Map.Entry<String, String> entry : tablePathMap.entrySet()) {
1:de0f545:         if (new Path(entry.getValue()).equals(new Path(tablePath))) {
1:de0f545:           return entry.getKey();
1:de0f545:         }
1:de0f545:       }
1:de0f545:     }
1:de0f545:     return null;
1:de0f545:   }
1:de0f545: 
1:b434346:   /**
1:9db662a:    * Return a new datamap instance and registered in the store manager.
1:9db662a:    * The datamap is created using datamap name, datamap factory class and table identifier.
1:05086e5:    */
1:9db662a:   public DataMapFactory getDataMapFactoryClass(CarbonTable table, DataMapSchema dataMapSchema)
1:5229443:       throws MalformedDataMapCommandException {
1:b434346:     try {
1:fc2a7eb:       // try to create datamap by reflection to test whether it is a valid DataMapFactory class
1:9db662a:       return (DataMapFactory)
1:9db662a:           Class.forName(dataMapSchema.getProviderName()).getConstructors()[0]
1:9db662a:               .newInstance(table, dataMapSchema);
1:89a12af:     } catch (ClassNotFoundException e) {
1:860e144:       // try to create DataMapClassProvider instance by taking providerName as short name
1:9db662a:       return DataMapRegistry.getDataMapFactoryByShortName(table, dataMapSchema);
1:89a12af:     } catch (Throwable e) {
1:89a12af:       throw new MetadataProcessException(
1:5229443:           "failed to get DataMap factory for'" + dataMapSchema.getProviderName() + "'", e);
1:d35fbaf:     }
1:d35fbaf:   }
1:b434346: 
1:2018048:   /**
1:5229443:    * registered in the store manager.
1:5229443:    * The datamap is created using datamap name, datamap factory class and table identifier.
1:b434346:    */
1:5229443:   // TODO: make it private
1:5229443:   public TableDataMap createAndRegisterDataMap(CarbonTable table,
1:9db662a:       DataMapSchema dataMapSchema) throws MalformedDataMapCommandException {
1:9db662a:     DataMapFactory dataMapFactory  = getDataMapFactoryClass(table, dataMapSchema);
1:7e0803f:     return registerDataMap(table, dataMapSchema, dataMapFactory);
1:b434346:   }
1:b434346: 
1:7e0803f:   public TableDataMap registerDataMap(CarbonTable table,
1:9db662a:       DataMapSchema dataMapSchema,  DataMapFactory dataMapFactory) {
1:7e0803f:     String tableUniqueName = table.getCarbonTableIdentifier().getTableUniqueName();
1:eb771f5:     // Just update the segmentRefreshMap with the table if not added.
1:7e0803f:     getTableSegmentRefresher(table);
1:7e0803f:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:de0f545:     if (tableIndices == null) {
1:de0f545:       String keyUsingTablePath = getKeyUsingTablePath(table.getTablePath());
1:de0f545:       if (keyUsingTablePath != null) {
1:de0f545:         tableUniqueName = keyUsingTablePath;
1:de0f545:         tableIndices = allDataMaps.get(tableUniqueName);
1:de0f545:       }
1:de0f545:     }
1:fc2a7eb:     if (tableIndices == null) {
1:fc2a7eb:       tableIndices = new ArrayList<>();
1:b434346:     }
1:b434346: 
1:89a12af:     BlockletDetailsFetcher blockletDetailsFetcher;
1:89a12af:     SegmentPropertiesFetcher segmentPropertiesFetcher = null;
1:fc2a7eb:     if (dataMapFactory instanceof BlockletDetailsFetcher) {
1:fc2a7eb:       blockletDetailsFetcher = (BlockletDetailsFetcher) dataMapFactory;
1:d35fbaf:     } else {
1:7e0803f:       blockletDetailsFetcher = getBlockletDetailsFetcher(table);
1:b434346:     }
1:89a12af:     segmentPropertiesFetcher = (SegmentPropertiesFetcher) blockletDetailsFetcher;
1:7e0803f:     TableDataMap dataMap = new TableDataMap(table.getAbsoluteTableIdentifier(),
1:7e0803f:         dataMapSchema, dataMapFactory, blockletDetailsFetcher, segmentPropertiesFetcher);
1:5229443: 
1:fc2a7eb:     tableIndices.add(dataMap);
1:7e0803f:     allDataMaps.put(tableUniqueName, tableIndices);
1:347b8e1:     tablePathMap.put(tableUniqueName, table.getTablePath());
2:b434346:     return dataMap;
1:b434346:   }
1:89a12af: 
1:fc2a7eb:   private TableDataMap getTableDataMap(String dataMapName, List<TableDataMap> tableIndices) {
1:b681244:     TableDataMap dataMap = null;
1:fc2a7eb:     for (TableDataMap tableDataMap : tableIndices) {
1:56330ae:       if (tableDataMap.getDataMapSchema().getDataMapName().equals(dataMapName)) {
1:b681244:         dataMap = tableDataMap;
1:347b8e1:         break;
1:b681244:       }
1:b681244:     }
1:b681244:     return dataMap;
1:b681244:   }
1:b681244: 
1:b681244:   /**
1:56330ae:    * Clear the invalid segments from all the datamaps of the table
1:56330ae:    * @param carbonTable
1:56330ae:    * @param segments
1:5229443:    */
1:5f2a748:   public void clearInvalidSegments(CarbonTable carbonTable, List<Segment> segments)
1:5f2a748:       throws IOException {
1:7e0803f:     getDefaultDataMap(carbonTable).clear(segments);
1:56330ae:     List<TableDataMap> allDataMap = getAllDataMap(carbonTable);
1:56330ae:     for (TableDataMap dataMap: allDataMap) {
1:56330ae:       dataMap.clear(segments);
1:b434346:     }
1:89a12af: 
1:b434346:   }
1:56330ae: 
1:5229443:   /**
1:1a62189:    * Clear the datamap/datamaps of a table from memory
1:b434346:    *
1:eb771f5:    * @param identifier Table identifier
1:56330ae:    */
1:1a62189:   public void clearDataMaps(AbsoluteTableIdentifier identifier) {
1:2018048:     CarbonTable carbonTable = getCarbonTable(identifier);
1:d35fbaf:     String tableUniqueName = identifier.getCarbonTableIdentifier().getTableUniqueName();
1:fc2a7eb:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:de0f545:     if (tableIndices == null) {
1:de0f545:       String keyUsingTablePath = getKeyUsingTablePath(identifier.getTablePath());
1:de0f545:       if (keyUsingTablePath != null) {
1:de0f545:         tableUniqueName = keyUsingTablePath;
1:de0f545:         tableIndices = allDataMaps.get(tableUniqueName);
1:347b8e1:       }
1:347b8e1:     }
1:2018048:     if (null != carbonTable && tableIndices != null) {
1:2018048:       try {
1:2018048:         DataMapUtil.executeDataMapJobForClearingDataMaps(carbonTable);
1:05086e5:       } catch (IOException e) {
1:2018048:         LOGGER.error(e, "clear dataMap job failed");
1:2018048:         // ignoring the exception
1:347b8e1:       }
1:05086e5:     }
1:eb771f5:     segmentRefreshMap.remove(identifier.uniqueName());
1:2018048:     clearDataMaps(tableUniqueName);
1:d35fbaf:     allDataMaps.remove(tableUniqueName);
1:347b8e1:     tablePathMap.remove(tableUniqueName);
1:b434346:   }
1:05086e5: 
1:05086e5:   /**
1:2018048:    * This method returns the carbonTable from identifier
1:b681244:    * @param identifier
1:05086e5:    * @return
1:b681244:    */
1:2018048:   public CarbonTable getCarbonTable(AbsoluteTableIdentifier identifier) {
1:2018048:     CarbonTable carbonTable = null;
1:2018048:     carbonTable = CarbonMetadata.getInstance()
1:2018048:         .getCarbonTable(identifier.getDatabaseName(), identifier.getTableName());
1:2018048:     if (carbonTable == null) {
1:2018048:       try {
1:2018048:         carbonTable = CarbonTable
1:2018048:             .buildFromTablePath(identifier.getTableName(), identifier.getDatabaseName(),
1:cb10d03:                 identifier.getTablePath(), identifier.getCarbonTableIdentifier().getTableId());
1:2018048:       } catch (IOException e) {
1:de0f545:         LOGGER.warn("failed to get carbon table from table Path" + e.getMessage());
1:2018048:         // ignoring exception
1:b434346:       }
1:2018048:     }
1:2018048:     return carbonTable;
1:2018048:   }
1:2018048: 
1:2018048:   /**
1:a7ac656:    * this methods clears the datamap of table from memory
1:2018048:    */
1:2018048:   public void clearDataMaps(String tableUniqName) {
1:2018048:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqName);
1:fc2a7eb:     if (tableIndices != null) {
1:fc2a7eb:       for (TableDataMap tableDataMap : tableIndices) {
1:eb771f5:         if (tableDataMap != null) {
1:2018048:           // clear the segmentMap in BlockletDetailsFetcher,else the Segment will remain in executor
1:2018048:           // and the query fails as we will check whether the blocklet contains in the index or not
1:2018048:           tableDataMap.getBlockletDetailsFetcher().clear();
1:1462495:           tableDataMap.clear();
1:2018048:         }
1:2018048:       }
1:5229443:     }
1:98c7581:     allDataMaps.remove(tableUniqName);
1:347b8e1:     tablePathMap.remove(tableUniqName);
1:ffddba7:   }
1:56330ae: 
1:56330ae:   /**
1:0112ed0:    * Clear the datamap/datamaps of a table from memory and disk
1:56330ae:    *
1:1a62189:    * @param identifier Table identifier
1:1a62189:    */
1:1a62189:   public void clearDataMap(AbsoluteTableIdentifier identifier, String dataMapName) {
1:2018048:     CarbonTable carbonTable = getCarbonTable(identifier);
1:2018048:     String tableUniqueName = identifier.getCarbonTableIdentifier().getTableUniqueName();
1:2018048:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:fc2a7eb:     if (tableIndices != null) {
1:1a62189:       int i = 0;
1:fc2a7eb:       for (TableDataMap tableDataMap : tableIndices) {
1:2018048:         if (carbonTable != null && tableDataMap != null && dataMapName
1:56330ae:             .equalsIgnoreCase(tableDataMap.getDataMapSchema().getDataMapName())) {
1:2018048:           try {
1:2018048:             DataMapUtil.executeDataMapJobForClearingDataMaps(carbonTable);
1:1a62189:             tableDataMap.clear();
1:2018048:           } catch (IOException e) {
1:2018048:             LOGGER.error(e, "clear dataMap job failed");
1:2018048:             // ignoring the exception
1:b681244:           }
1:860e144:           tableDataMap.deleteDatamapData();
1:fc2a7eb:           tableIndices.remove(i);
1:1a62189:           break;
1:2018048:         }
1:1a62189:         i++;
1:ffddba7:       }
1:98c7581:       allDataMaps.put(tableUniqueName, tableIndices);
1:ffddba7:     }
1:ffddba7:   }
1:56330ae: 
1:28f78b2:   /**
1:b08ef00:    * is datamap exist
1:b08ef00:    * @return true if exist, else return false
1:b08ef00:    */
1:b08ef00:   public boolean isDataMapExist(String dbName, String tableName, String dmName) {
1:b08ef00:     List<TableDataMap> tableDataMaps = allDataMaps.get(dbName + '_' + tableName);
1:1a62189:     if (tableDataMaps != null) {
1:b08ef00:       for (TableDataMap dm : tableDataMaps) {
1:b08ef00:         if (dm != null && dmName.equalsIgnoreCase(dm.getDataMapSchema().getDataMapName())) {
1:b08ef00:           return true;
1:1a62189:         }
1:1a62189:       }
1:1a62189:     }
1:b08ef00:     return false;
1:1a62189:   }
1:1a62189: 
1:1a62189:   /**
1:28f78b2:    * Get the blocklet datamap factory to get the detail information of blocklets
1:56330ae:    *
1:7e0803f:    * @param table
1:b434346:    * @return
1:2018048:    */
1:7e0803f:   private BlockletDetailsFetcher getBlockletDetailsFetcher(CarbonTable table) {
1:7e0803f:     TableDataMap blockletMap = getDataMap(table, BlockletDataMapFactory.DATA_MAP_SCHEMA);
1:fc2a7eb:     return (BlockletDetailsFetcher) blockletMap.getDataMapFactory();
1:b681244:   }
1:b08ef00: 
1:b681244:   /**
1:b681244:    * Returns the singleton instance
1:56330ae:    *
1:b681244:    * @return
1:b681244:    */
1:b434346:   public static DataMapStoreManager getInstance() {
1:b434346:     return instance;
1:b434346:   }
1:b434346: 
1:b08ef00:   /**
1:eb771f5:    * Get the TableSegmentRefresher for the table. If not existed then add one and return.
1:28f78b2:    */
1:7e0803f:   public TableSegmentRefresher getTableSegmentRefresher(CarbonTable table) {
1:7e0803f:     String uniqueName = table.getAbsoluteTableIdentifier().uniqueName();
1:eb771f5:     if (segmentRefreshMap.get(uniqueName) == null) {
1:7e0803f:       segmentRefreshMap.put(uniqueName, new TableSegmentRefresher(table));
1:b434346:     }
1:eb771f5:     return segmentRefreshMap.get(uniqueName);
1:b08ef00:   }
1:28f78b2: 
2:eb771f5:   /**
1:eb771f5:    * Keep track of the segment refresh time.
2:eb771f5:    */
1:eb771f5:   public static class TableSegmentRefresher {
1:eb771f5: 
1:eb771f5:     // This map stores the latest segment refresh time.So in case of update/delete we check the
1:eb771f5:     // time against this map.
1:f1a6c7c:     private Map<String, SegmentRefreshInfo> segmentRefreshTime = new HashMap<>();
4:eb771f5: 
1:eb771f5:     // This map keeps the manual refresh entries from users. It is mainly used for partition
1:eb771f5:     // altering.
1:eb771f5:     private Map<String, Boolean> manualSegmentRefresh = new HashMap<>();
1:eb771f5: 
1:7e0803f:     TableSegmentRefresher(CarbonTable table) {
1:7e0803f:       SegmentUpdateStatusManager statusManager = new SegmentUpdateStatusManager(table);
1:eb771f5:       SegmentUpdateDetails[] updateStatusDetails = statusManager.getUpdateStatusDetails();
1:eb771f5:       for (SegmentUpdateDetails updateDetails : updateStatusDetails) {
1:eb771f5:         UpdateVO updateVO = statusManager.getInvalidTimestampRange(updateDetails.getSegmentName());
1:f1a6c7c:         segmentRefreshTime.put(updateVO.getSegmentId(),
1:f1a6c7c:             new SegmentRefreshInfo(updateVO.getCreatedOrUpdatedTimeStamp(), 0));
1:b08ef00:       }
1:b08ef00:     }
1:eb771f5: 
1:f1a6c7c:     public boolean isRefreshNeeded(Segment seg, UpdateVO updateVo) throws IOException {
1:f1a6c7c:       SegmentRefreshInfo segmentRefreshInfo =
1:f1a6c7c:           seg.getSegmentRefreshInfo(updateVo);
1:f1a6c7c:       String segmentId = seg.getSegmentNo();
1:6c5abdd:       if (segmentRefreshTime.get(segmentId) == null
1:6c5abdd:           && segmentRefreshInfo.getSegmentUpdatedTimestamp() != null) {
1:f1a6c7c:         segmentRefreshTime.put(segmentId, segmentRefreshInfo);
1:eb771f5:         return true;
1:b08ef00:       }
1:eb771f5:       if (manualSegmentRefresh.get(segmentId) != null && manualSegmentRefresh.get(segmentId)) {
1:eb771f5:         manualSegmentRefresh.put(segmentId, false);
1:eb771f5:         return true;
1:89a12af:       }
1:f1a6c7c: 
1:f1a6c7c:       boolean isRefresh = segmentRefreshInfo.compare(segmentRefreshTime.get(segmentId));
1:eb771f5:       if (isRefresh) {
1:eb771f5:         segmentRefreshTime.remove(segmentId);
1:89a12af:       }
1:eb771f5:       return isRefresh;
1:56330ae:     }
1:eb771f5: 
1:eb771f5:     public void refreshSegments(List<String> segmentIds) {
1:56330ae:       for (String segmentId : segmentIds) {
1:eb771f5:         manualSegmentRefresh.put(segmentId, true);
1:56330ae:       }
1:56330ae:     }
1:eb771f5: 
1:eb771f5:     public boolean isRefreshNeeded(String segmentId) {
1:eb771f5:       if (manualSegmentRefresh.get(segmentId) != null && manualSegmentRefresh.get(segmentId)) {
1:eb771f5:         manualSegmentRefresh.put(segmentId, false);
1:eb771f5:         return true;
1:a85b4f4:       } else {
1:eb771f5:         return false;
1:56330ae:       }
1:56330ae:     }
1:56330ae:   }
1:eb771f5: 
1:56330ae: }
============================================================================
author:ravipesala
-------------------------------------------------------------------------------
commit:de0f545
/////////////////////////////////////////////////////////////////////////
1:     if (tableIndices == null) {
1:       String keyUsingTablePath = getKeyUsingTablePath(table.getTablePath());
1:       if (keyUsingTablePath != null) {
1:         tableUniqueName = keyUsingTablePath;
1:         tableIndices = allDataMaps.get(tableUniqueName);
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
1:   private String getKeyUsingTablePath(String tablePath) {
1:     if (tablePath != null) {
1:       // Try get using table path
1:       for (Map.Entry<String, String> entry : tablePathMap.entrySet()) {
1:         if (new Path(entry.getValue()).equals(new Path(tablePath))) {
1:           return entry.getKey();
1:         }
1:       }
1:     }
1:     return null;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:       String keyUsingTablePath = getKeyUsingTablePath(table.getTablePath());
1:       if (keyUsingTablePath != null) {
1:         tableUniqueName = keyUsingTablePath;
1:         tableIndices = allDataMaps.get(tableUniqueName);
1:       }
1:     }
1:     if (tableIndices == null) {
/////////////////////////////////////////////////////////////////////////
1:     if (tableIndices == null) {
1:       String keyUsingTablePath = getKeyUsingTablePath(identifier.getTablePath());
1:       if (keyUsingTablePath != null) {
1:         tableUniqueName = keyUsingTablePath;
1:         tableIndices = allDataMaps.get(tableUniqueName);
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.warn("failed to get carbon table from table Path" + e.getMessage());
commit:347b8e1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.fs.Path;
1: 
/////////////////////////////////////////////////////////////////////////
1:    * Contains the table name to the tablepath mapping.
1:    */
1:   private Map<String, String> tablePathMap = new ConcurrentHashMap<>();
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     tablePathMap.put(tableUniqueName, table.getTablePath());
/////////////////////////////////////////////////////////////////////////
0:     if (tableIndices == null && identifier.getTablePath() != null) {
0:       // Try get using table path
0:       for (Map.Entry<String, String> entry : tablePathMap.entrySet()) {
0:         if (new Path(entry.getValue()).equals(new Path(identifier.getTablePath()))) {
0:           tableIndices = allDataMaps.get(entry.getKey());
0:           tableUniqueName = entry.getKey();
1:           break;
1:         }
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     tablePathMap.remove(tableUniqueName);
/////////////////////////////////////////////////////////////////////////
1:     tablePathMap.remove(tableUniqName);
commit:5f2a748
/////////////////////////////////////////////////////////////////////////
1:   private DataMapSchemaStorageProvider provider = new DiskBasedDMSchemaStorageProvider(
1:       CarbonProperties.getInstance().getSystemFolderLocation());
1: 
/////////////////////////////////////////////////////////////////////////
0:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable, DataMapLevel mapType)
1:       throws IOException {
/////////////////////////////////////////////////////////////////////////
1:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable) throws IOException {
1:     List<DataMapSchema> dataMapSchemas = getDataMapSchemasOfTable(carbonTable);
/////////////////////////////////////////////////////////////////////////
1:    * It gives all datamap schemas of a given table.
1:   public List<DataMapSchema> getDataMapSchemasOfTable(CarbonTable carbonTable) throws IOException {
1:     return provider.retrieveSchemas(carbonTable);
1:   /**
1:    * It gives all datamap schemas from store.
1:    */
1:   public List<DataMapSchema> getAllDataMapSchemas() throws IOException {
1:     return provider.retrieveAllSchemas();
1: 
1:   public DataMapSchema getDataMapSchema(String dataMapName)
1:       throws NoSuchDataMapException, IOException {
1:     return provider.retrieveSchema(dataMapName);
1:   }
1: 
1:   /**
1:    * Saves the datamap schema to storage
1:    * @param dataMapSchema
1:    */
1:   public void saveDataMapSchema(DataMapSchema dataMapSchema) throws IOException {
1:     provider.saveSchema(dataMapSchema);
1:   }
1: 
1:   /**
1:    * Drops the datamap schema from storage
1:    * @param dataMapName
1:    */
1:   public void dropDataMapSchema(String dataMapName) throws IOException {
1:     provider.dropSchema(dataMapName);
/////////////////////////////////////////////////////////////////////////
1:   public void clearInvalidSegments(CarbonTable carbonTable, List<Segment> segments)
0:       throws IOException {
commit:9fba684
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.exceptions.sql.NoSuchDataMapException;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapSchema getDataMapSchema(String dataMapName) throws NoSuchDataMapException {
0:     List<DataMapSchema> allDataMapSchemas = getAllDataMapSchemas();
0:     for (DataMapSchema dataMapSchema : allDataMapSchemas) {
0:       if (dataMapSchema.getDataMapName().equalsIgnoreCase(dataMapName)) {
0:         return dataMapSchema;
1:       }
1:     }
0:     throw new NoSuchDataMapException(dataMapName);
1:   }
1: 
commit:05086e5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.schema.table.DataMapSchemaStorageProvider;
1: import org.apache.carbondata.core.metadata.schema.table.DiskBasedDMSchemaStorageProvider;
1: import org.apache.carbondata.core.metadata.schema.table.RelationIdentifier;
1: import org.apache.carbondata.core.util.CarbonProperties;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Contains the datamap catalog for each datamap provider.
1:    */
0:   private Map<String, DataMapCatalog> dataMapCatalogs = new ConcurrentHashMap<>();
1: 
/////////////////////////////////////////////////////////////////////////
0:     // TODO cache all schemas and update only when datamap status file updates
1:     List<DataMapSchema> dataMapSchemas = getAllDataMapSchemas();
1:     if (dataMapSchemas != null) {
1:       for (DataMapSchema dataMapSchema : dataMapSchemas) {
1:         RelationIdentifier identifier = dataMapSchema.getParentTables().get(0);
0:         if (dataMapSchema.isIndexDataMap() && identifier.getTableName()
0:             .equals(carbonTable.getTableName()) && identifier.getDatabaseName()
0:             .equals(carbonTable.getDatabaseName())) {
/////////////////////////////////////////////////////////////////////////
0:    * It gives all datamap schemas.
1:    *
1:    * @return
1:    */
0:   public List<DataMapSchema> getAllDataMapSchemas(CarbonTable carbonTable) {
0:     // TODO cache all schemas and update only when datamap status file updates
0:     List<DataMapSchema> dataMapSchemas = getAllDataMapSchemas();
0:     List<DataMapSchema> dataMaps = new ArrayList<>();
0:     if (dataMapSchemas != null) {
0:       for (DataMapSchema dataMapSchema : dataMapSchemas) {
0:         RelationIdentifier identifier = dataMapSchema.getParentTables().get(0);
0:         if (dataMapSchema.isIndexDataMap() && identifier.getTableName()
0:             .equals(carbonTable.getTableName()) && identifier.getDatabaseName()
0:             .equals(carbonTable.getDatabaseName())) {
0:           dataMaps.add(dataMapSchema);
1:         }
1:       }
1:     }
1:     return dataMaps;
1:   }
1: 
0:   public List<DataMapSchema> getAllDataMapSchemas() {
0:     DataMapSchemaStorageProvider provider = new DiskBasedDMSchemaStorageProvider(
0:         CarbonProperties.getInstance().getSystemFolderLocation());
0:     List<DataMapSchema> dataMapSchemas;
1:     try {
0:       dataMapSchemas = provider.retrieveAllSchemas();
1:     } catch (IOException e) {
1:       throw new RuntimeException(e);
1:     }
0:     return dataMapSchemas;
1:   }
1: 
1:   /**
1:    * Register datamap catalog for the datamap provider
1:    * @param dataMapProvider
1:    * @param dataMapSchema
1:    */
1:   public synchronized void registerDataMapCatalog(DataMapProvider dataMapProvider,
0:       DataMapSchema dataMapSchema) {
1:     String name = dataMapSchema.getProviderName();
1:     DataMapCatalog dataMapCatalog = dataMapCatalogs.get(name);
1:     if (dataMapCatalog == null) {
1:       dataMapCatalog = dataMapProvider.createDataMapCatalog();
1:       if (dataMapCatalog != null) {
1:         dataMapCatalogs.put(name, dataMapCatalog);
1:         dataMapCatalog.registerSchema(dataMapSchema);
1:       }
1:     } else {
1:       dataMapCatalog.registerSchema(dataMapSchema);
1:     }
1:   }
1: 
1:   /**
1:    * Unregister datamap catalog.
1:    * @param dataMapSchema
1:    */
1:   public synchronized void unRegisterDataMapCatalog(DataMapSchema dataMapSchema) {
1:     String name = dataMapSchema.getProviderName();
1:     DataMapCatalog dataMapCatalog = dataMapCatalogs.get(name);
1:     if (dataMapCatalog != null) {
1:       dataMapCatalog.unregisterSchema(dataMapSchema.getDataMapName());
1:     }
1:   }
1: 
1:   /**
1:    * Get the datamap catalog for provider.
1:    * @param providerName
1:    * @return
1:    */
0:   public DataMapCatalog getDataMapCatalog(String providerName) {
1:     return dataMapCatalogs.get(providerName);
1:   }
1: 
1:   /**
commit:d35fbaf
/////////////////////////////////////////////////////////////////////////
0:     return allDataMaps.get(identifier.getCarbonTableIdentifier().getTableUniqueName());
1:   }
1: 
0:   // TODO its a temporary method till chooser is implemented
0:   public TableDataMap chooseDataMap(AbsoluteTableIdentifier identifier) {
0:     List<TableDataMap> tableDataMaps = getAllDataMap(identifier);
0:     if (tableDataMaps != null && tableDataMaps.size() > 0) {
0:       for (TableDataMap dataMap: tableDataMaps) {
0:         if (!dataMap.getDataMapName().equalsIgnoreCase(BlockletDataMap.NAME)) {
1:           return dataMap;
1:         }
1:       }
0:       return tableDataMaps.get(0);
1:     } else {
0:       return getDataMap(identifier, BlockletDataMap.NAME, BlockletDataMapFactory.class.getName());
1:     }
/////////////////////////////////////////////////////////////////////////
0:     String table = identifier.getCarbonTableIdentifier().getTableUniqueName();
/////////////////////////////////////////////////////////////////////////
0:     String table = identifier.getCarbonTableIdentifier().getTableUniqueName();
/////////////////////////////////////////////////////////////////////////
1:     String tableUniqueName = identifier.getCarbonTableIdentifier().getTableUniqueName();
0:     List<TableDataMap> tableDataMaps =
0:         allDataMaps.get(tableUniqueName);
/////////////////////////////////////////////////////////////////////////
1:       allDataMaps.remove(tableUniqueName);
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableDataMaps =
0:         allDataMaps.get(identifier.getCarbonTableIdentifier().getTableUniqueName());
commit:1a62189
/////////////////////////////////////////////////////////////////////////
1:   public void clearDataMaps(AbsoluteTableIdentifier identifier) {
1:    * Clear the datamap/datamaps of a table from memory
1:    * @param identifier Table identifier
1:    */
1:   public void clearDataMap(AbsoluteTableIdentifier identifier, String dataMapName) {
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(identifier.uniqueName());
1:     if (tableDataMaps != null) {
1:       int i = 0;
0:       for (TableDataMap tableDataMap: tableDataMaps) {
0:         if (tableDataMap != null && dataMapName.equalsIgnoreCase(tableDataMap.getDataMapName())) {
1:           tableDataMap.clear();
0:           tableDataMaps.remove(i);
1:           break;
1:         }
1:         i++;
1:       }
1:     }
1:   }
1: 
1:   /**
commit:1462495
/////////////////////////////////////////////////////////////////////////
1:           tableDataMap.clear();
commit:b681244
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:  * It maintains all the DataMaps in it.
1: public final class DataMapStoreManager {
1:   /**
1:    * Contains the list of datamaps for each table.
1:    */
0:   private Map<AbsoluteTableIdentifier, List<TableDataMap>> dataMapMappping = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableDataMaps = dataMapMappping.get(identifier);
0:     TableDataMap dataMap;
0:     if (tableDataMaps == null) {
0:       createTableDataMap(identifier, mapType, dataMapName);
0:       tableDataMaps = dataMapMappping.get(identifier);
0:     dataMap = getAbstractTableDataMap(dataMapName, tableDataMaps);
1:     if (dataMap == null) {
1:       throw new RuntimeException("Datamap does not exist");
1:     }
0:    * Create new datamap instance using datamap name, datamap type and table identifier
0:   private TableDataMap createTableDataMap(AbsoluteTableIdentifier identifier,
0:       DataMapType mapType, String dataMapName) {
0:     List<TableDataMap> tableDataMaps = dataMapMappping.get(identifier);
0:     if (tableDataMaps == null) {
0:       tableDataMaps = new ArrayList<>();
0:       dataMapMappping.put(identifier, tableDataMaps);
0:     TableDataMap dataMap = getAbstractTableDataMap(dataMapName, tableDataMaps);
0:       DataMapFactory dataMapFactory = mapType.getClassObject().newInstance();
0:       dataMapFactory.init(identifier, dataMapName);
0:       dataMap = new TableDataMap(identifier, dataMapName, dataMapFactory);
0:       throw new RuntimeException(e);
0:     tableDataMaps.add(dataMap);
0:   private TableDataMap getAbstractTableDataMap(String dataMapName,
0:       List<TableDataMap> tableDataMaps) {
1:     TableDataMap dataMap = null;
0:     for (TableDataMap tableDataMap: tableDataMaps) {
0:       if (tableDataMap.getDataMapName().equals(dataMapName)) {
1:         dataMap = tableDataMap;
0:         break;
1:       }
1:     }
1:     return dataMap;
1:   }
1: 
1:   /**
0:    * Clear the datamap/datamaps of a mentioned datamap name and table from memory
1:    * @param identifier
0:    * @param dataMapName
1:    */
0:   public void clearDataMap(AbsoluteTableIdentifier identifier, String dataMapName) {
0:     List<TableDataMap> tableDataMaps = dataMapMappping.get(identifier);
0:     if (tableDataMaps != null) {
0:       int i = 0;
0:       for (TableDataMap tableDataMap: tableDataMaps) {
0:         if (tableDataMap != null && dataMapName.equals(tableDataMap.getDataMapName())) {
0:           tableDataMap.clear(new ArrayList<String>());
0:           tableDataMaps.remove(i);
0:           break;
1:         }
0:         i++;
1:       }
1:   /**
1:    * Returns the singleton instance
1:    * @return
1:    */
commit:b434346
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.carbondata.core.indexstore;
1: 
1: import java.util.HashMap;
1: import java.util.Map;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1: 
1: /**
0:  * It maintains all the index tables in it.
1:  */
0: public class DataMapStoreManager {
1: 
1:   private static DataMapStoreManager instance = new DataMapStoreManager();
1: 
0:   private Map<DataMapType, Map<String, TableDataMap>> dataMapMappping = new HashMap<>();
1: 
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(DataMapStoreManager.class.getName());
1: 
1:   private DataMapStoreManager() {
1: 
1:   }
1: 
1:   /**
1:    * Get the datamap for reading data.
1:    *
0:    * @param dataMapName
0:    * @param mapType
1:    * @return
1:    */
0:   public TableDataMap getDataMap(AbsoluteTableIdentifier identifier, String dataMapName,
0:       DataMapType mapType) {
0:     Map<String, TableDataMap> map = dataMapMappping.get(mapType);
1:     TableDataMap dataMap = null;
0:     if (map == null) {
0:       throw new RuntimeException("Datamap does not exist");
1:     } else {
0:       dataMap = map.get(dataMapName);
1:       if (dataMap == null) {
0:         throw new RuntimeException("Datamap does not exist");
1:       }
1:     }
0:     // Initialize datamap
0:     dataMap.init(identifier, dataMapName);
1:     return dataMap;
1:   }
1: 
1:   /**
0:    * Create new datamap instance using datamap type and path
1:    *
0:    * @param mapType
1:    * @return
1:    */
0:   public TableDataMap createTableDataMap(AbsoluteTableIdentifier identifier, DataMapType mapType,
0:       String dataMapName) {
0:     Map<String, TableDataMap> map = dataMapMappping.get(mapType);
0:     if (map == null) {
0:       map = new HashMap<>();
0:       dataMapMappping.put(mapType, map);
1:     }
0:     TableDataMap dataMap = map.get(dataMapName);
0:     if (dataMap != null) {
0:       throw new RuntimeException("Already datamap exists in that path with type " + mapType);
1:     }
1: 
1:     try {
0:       //TODO create datamap using @mapType.getClassName())
1:     } catch (Exception e) {
0:       LOGGER.error(e);
1:     }
0:     dataMap.init(identifier, dataMapName);
0:     map.put(dataMapName, dataMap);
1:     return dataMap;
1:   }
1: 
0:   public void clearDataMap(String dataMapName, DataMapType mapType) {
0:     Map<String, TableDataMap> map = dataMapMappping.get(mapType);
0:     if (map != null && map.get(dataMapName) != null) {
0:       map.remove(dataMapName).clear();
1:     }
1:   }
1: 
1:   public static DataMapStoreManager getInstance() {
1:     return instance;
1:   }
1: 
1: }
author:dhatchayani
-------------------------------------------------------------------------------
commit:6c5abdd
/////////////////////////////////////////////////////////////////////////
1:       if (segmentRefreshTime.get(segmentId) == null
1:           && segmentRefreshInfo.getSegmentUpdatedTimestamp() != null) {
author:ndwangsen
-------------------------------------------------------------------------------
commit:cdee81d
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.core.metadata.schema.datamap.DataMapClassProvider.MV;
1: import static org.apache.carbondata.core.metadata.schema.datamap.DataMapClassProvider.PREAGGREGATE;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (dataMapSchema.isIndexDataMap() && identifier.getTableId()
1:             .equals(carbonTable.getTableId())) {
/////////////////////////////////////////////////////////////////////////
1:    * Update the datamap schema after table rename
1:    * This should be invoked after changing table name
1:    * @param dataMapSchemaList
1:    * @param newTableName
1:    */
1:   public void updateDataMapSchema(List<DataMapSchema> dataMapSchemaList,
1:       String newTableName) throws IOException {
1:     List<DataMapSchema> newDataMapSchemas = new ArrayList<>();
1:     for (DataMapSchema dataMapSchema : dataMapSchemaList) {
1:       RelationIdentifier relationIdentifier = dataMapSchema.getRelationIdentifier();
1:       String dataBaseName =  relationIdentifier.getDatabaseName();
1:       String tableId = relationIdentifier.getTableId();
1:       String providerName = dataMapSchema.getProviderName();
1:       // if the preaggregate datamap,not be modified the schema
1:       if (providerName.equalsIgnoreCase(PREAGGREGATE.toString())) {
1:         continue;
1:       }
1:       // if the mv datamap,not be modified the relationIdentifier
1:       if (!providerName.equalsIgnoreCase(MV.toString())) {
1:         RelationIdentifier newRelationIdentifier = new RelationIdentifier(dataBaseName,
1:             newTableName, tableId);
1:         dataMapSchema.setRelationIdentifier(newRelationIdentifier);
1:       }
1:       List<RelationIdentifier> newParentTables = new ArrayList<>();
1:       List<RelationIdentifier> parentTables = dataMapSchema.getParentTables();
1:       for (RelationIdentifier identifier : parentTables) {
1:         RelationIdentifier newParentTableIdentifier = new RelationIdentifier(
1:             identifier.getDatabaseName(), newTableName, identifier.getTableId());
1:         newParentTables.add(newParentTableIdentifier);
1:       }
1:       dataMapSchema.setParentTables(newParentTables);
1:       newDataMapSchemas.add(dataMapSchema);
1:       // frist drop old schema
1:       String dataMapName = dataMapSchema.getDataMapName();
1:       dropDataMapSchema(dataMapName);
1:     }
1:     // save new datamap schema to storage
1:     for (DataMapSchema newDataMapSchema : newDataMapSchemas) {
1:       saveDataMapSchema(newDataMapSchema);
1:     }
1:   }
1: 
1:   /**
author:xuchuanyin
-------------------------------------------------------------------------------
commit:98c7581
/////////////////////////////////////////////////////////////////////////
1:     allDataMaps.remove(tableUniqName);
/////////////////////////////////////////////////////////////////////////
1:       allDataMaps.put(tableUniqueName, tableIndices);
commit:0112ed0
/////////////////////////////////////////////////////////////////////////
1:    * Clear the datamap/datamaps of a table from memory and disk
commit:b08ef00
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.CarbonSessionInfo;
1: import org.apache.carbondata.core.util.ThreadLocalSessionInfo;
/////////////////////////////////////////////////////////////////////////
0:    * It gives all visible datamaps of type @mapType except the default datamap.
0:   public List<TableDataMap> getAllVisibleDataMap(CarbonTable carbonTable, DataMapLevel mapType)
0:     List<TableDataMap> tableIndices = getAllVisibleDataMap(carbonTable);
/////////////////////////////////////////////////////////////////////////
1:    * It only gives the visible datamaps
1:    */
0:   private List<TableDataMap> getAllVisibleDataMap(CarbonTable carbonTable) throws IOException {
1:     CarbonSessionInfo sessionInfo = ThreadLocalSessionInfo.getCarbonSessionInfo();
1:     List<TableDataMap> allDataMaps = getAllDataMap(carbonTable);
1:     Iterator<TableDataMap> dataMapIterator = allDataMaps.iterator();
1:     while (dataMapIterator.hasNext()) {
1:       TableDataMap dataMap = dataMapIterator.next();
1:       String dbName = carbonTable.getDatabaseName();
1:       String tableName = carbonTable.getTableName();
1:       String dmName = dataMap.getDataMapSchema().getDataMapName();
1:       boolean isDmVisible = sessionInfo.getSessionParams().getProperty(
1:           String.format("%s%s.%s.%s", CarbonCommonConstants.CARBON_DATAMAP_VISIBLE,
1:               dbName, tableName, dmName), "true").trim().equalsIgnoreCase("true");
1:       if (!isDmVisible) {
1:         LOGGER.warn(String.format("Ignore invisible datamap %s on table %s.%s",
1:             dmName, dbName, tableName));
1:         dataMapIterator.remove();
1:       }
1:     }
1:     return allDataMaps;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * is datamap exist
1:    * @return true if exist, else return false
1:    */
1:   public boolean isDataMapExist(String dbName, String tableName, String dmName) {
1:     List<TableDataMap> tableDataMaps = allDataMaps.get(dbName + '_' + tableName);
0:     if (tableDataMaps != null) {
1:       for (TableDataMap dm : tableDataMaps) {
1:         if (dm != null && dmName.equalsIgnoreCase(dm.getDataMapSchema().getDataMapName())) {
1:           return true;
1:         }
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
commit:a85b4f4
/////////////////////////////////////////////////////////////////////////
0:   public TableDataMap getDataMap(AbsoluteTableIdentifier identifier,
0:       synchronized (table.intern()) {
0:         tableDataMaps = allDataMaps.get(table);
0:         if (tableDataMaps == null) {
0:           dataMap = createAndRegisterDataMap(identifier, factoryClass, dataMapName);
1:         } else {
0:           dataMap = getTableDataMap(dataMapName, tableDataMaps);
1:         }
1:       }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     allDataMaps.put(table, tableDataMaps);
author:kunal642
-------------------------------------------------------------------------------
commit:cb10d03
/////////////////////////////////////////////////////////////////////////
1:                 identifier.getTablePath(), identifier.getCarbonTableIdentifier().getTableId());
author:xubo245
-------------------------------------------------------------------------------
commit:e30a84c
/////////////////////////////////////////////////////////////////////////
1:     initializeDataMapCatalogs(dataMapProvider);
/////////////////////////////////////////////////////////////////////////
1:     initializeDataMapCatalogs(dataMapProvider);
/////////////////////////////////////////////////////////////////////////
1:   private void initializeDataMapCatalogs(DataMapProvider dataMapProvider) throws IOException {
commit:b338459
/////////////////////////////////////////////////////////////////////////
1:       // TODO: need support get the visible status of datamap without sessionInfo in the future
1:       if (sessionInfo != null) {
0:         boolean isDmVisible = sessionInfo.getSessionParams().getProperty(
0:             String.format("%s%s.%s.%s", CarbonCommonConstants.CARBON_DATAMAP_VISIBLE,
0:                 dbName, tableName, dmName), "true").trim().equalsIgnoreCase("true");
0:         if (!isDmVisible) {
0:           LOGGER.warn(String.format("Ignore invisible datamap %s on table %s.%s",
0:               dmName, dbName, tableName));
0:           dataMapIterator.remove();
1:         }
0:       } else {
1:         String message = "Carbon session info is null";
1:         LOGGER.info(message);
commit:a7ac656
/////////////////////////////////////////////////////////////////////////
1:    * this methods clears the datamap of table from memory
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:   public synchronized DataMapCatalog getDataMapCatalog(DataMapProvider dataMapProvider,
1:       String providerName) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:           if (null == dataMapCatalog) {
1:             throw new RuntimeException("Internal Error.");
1:           }
author:akashrn5
-------------------------------------------------------------------------------
commit:2018048
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.CarbonMetadata;
/////////////////////////////////////////////////////////////////////////
1:   public Map<String, List<TableDataMap>> getAllDataMaps() {
1:     return allDataMaps;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     CarbonTable carbonTable = getCarbonTable(identifier);
1:     if (null != carbonTable && tableIndices != null) {
1:       try {
1:         DataMapUtil.executeDataMapJobForClearingDataMaps(carbonTable);
1:       } catch (IOException e) {
1:         LOGGER.error(e, "clear dataMap job failed");
1:         // ignoring the exception
1:       }
1:     }
1:     clearDataMaps(tableUniqueName);
0:     allDataMaps.remove(tableUniqueName);
1:   }
1: 
1:   /**
1:    * This method returns the carbonTable from identifier
0:    * @param identifier
1:    * @return
1:    */
1:   public CarbonTable getCarbonTable(AbsoluteTableIdentifier identifier) {
1:     CarbonTable carbonTable = null;
1:     carbonTable = CarbonMetadata.getInstance()
1:         .getCarbonTable(identifier.getDatabaseName(), identifier.getTableName());
1:     if (carbonTable == null) {
1:       try {
1:         carbonTable = CarbonTable
1:             .buildFromTablePath(identifier.getTableName(), identifier.getDatabaseName(),
0:                 identifier.getTablePath());
1:       } catch (IOException e) {
0:         LOGGER.error("failed to get carbon table from table Path");
1:         // ignoring exception
1:       }
1:     }
1:     return carbonTable;
1:   }
1: 
1:   /**
0:    * this methos clears the datamap of table from memory
1:    */
1:   public void clearDataMaps(String tableUniqName) {
1:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqName);
1:           // clear the segmentMap in BlockletDetailsFetcher,else the Segment will remain in executor
1:           // and the query fails as we will check whether the blocklet contains in the index or not
1:           tableDataMap.getBlockletDetailsFetcher().clear();
/////////////////////////////////////////////////////////////////////////
1:     CarbonTable carbonTable = getCarbonTable(identifier);
1:     String tableUniqueName = identifier.getCarbonTableIdentifier().getTableUniqueName();
1:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:         if (carbonTable != null && tableDataMap != null && dataMapName
1:           try {
1:             DataMapUtil.executeDataMapJobForClearingDataMaps(carbonTable);
0:             tableDataMap.clear();
0:           } catch (IOException e) {
1:             LOGGER.error(e, "clear dataMap job failed");
1:             // ignoring the exception
1:           }
commit:5229443
/////////////////////////////////////////////////////////////////////////
0:    * Return a new datamap instance for the given
0:    * @param dataMapSchema
0:    * @return
0:    * @throws MalformedDataMapCommandException
0:   public DataMapFactory getDataMapFactoryClass(DataMapSchema dataMapSchema)
1:       throws MalformedDataMapCommandException {
0:       return factoryClass.newInstance();
0:       return IndexDataMapProvider.getDataMapFactoryByShortName(dataMapSchema.getProviderName());
1:           "failed to get DataMap factory for'" + dataMapSchema.getProviderName() + "'", e);
1:   }
1: 
1:   /**
1:    * registered in the store manager.
1:    * The datamap is created using datamap name, datamap factory class and table identifier.
1:    */
1:   // TODO: make it private
1:   public TableDataMap createAndRegisterDataMap(CarbonTable table,
0:       DataMapSchema dataMapSchema) throws MalformedDataMapCommandException, IOException {
0:     DataMapFactory dataMapFactory  = getDataMapFactoryClass(dataMapSchema);
commit:860e144
/////////////////////////////////////////////////////////////////////////
1:       // try to create DataMapClassProvider instance by taking providerName as short name
0:       dataMapFactory =
0:           IndexDataMapProvider.getDataMapFactoryByShortName(dataMapSchema.getProviderName());
/////////////////////////////////////////////////////////////////////////
0:     dataMapFactory.init(table, dataMapSchema);
/////////////////////////////////////////////////////////////////////////
1:           tableDataMap.deleteDatamapData();
author:rahulforallp
-------------------------------------------------------------------------------
commit:f1a6c7c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.statusmanager.SegmentRefreshInfo;
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, SegmentRefreshInfo> segmentRefreshTime = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         segmentRefreshTime.put(updateVO.getSegmentId(),
1:             new SegmentRefreshInfo(updateVO.getCreatedOrUpdatedTimeStamp(), 0));
1:     public boolean isRefreshNeeded(Segment seg, UpdateVO updateVo) throws IOException {
1:       SegmentRefreshInfo segmentRefreshInfo =
1:           seg.getSegmentRefreshInfo(updateVo);
1:       String segmentId = seg.getSegmentNo();
1:         segmentRefreshTime.put(segmentId, segmentRefreshInfo);
1: 
1:       boolean isRefresh = segmentRefreshInfo.compare(segmentRefreshTime.get(segmentId));
author:Jacky Li
-------------------------------------------------------------------------------
commit:ffddba7
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, DataMapCatalog> dataMapCatalogs = null;
/////////////////////////////////////////////////////////////////////////
1:       DataMapSchema dataMapSchema) throws IOException {
0:     intializeDataMapCatalogs(dataMapProvider);
/////////////////////////////////////////////////////////////////////////
1:     if (dataMapCatalogs == null) {
1:       return;
1:     }
/////////////////////////////////////////////////////////////////////////
0:   public DataMapCatalog getDataMapCatalog(DataMapProvider dataMapProvider, String providerName)
0:       throws IOException {
0:     intializeDataMapCatalogs(dataMapProvider);
1:    * Initialize by reading all datamaps from store and re register it
1:    * @param dataMapProvider
1:    */
0:   private void intializeDataMapCatalogs(DataMapProvider dataMapProvider) throws IOException {
1:     if (dataMapCatalogs == null) {
1:       dataMapCatalogs = new ConcurrentHashMap<>();
0:       List<DataMapSchema> dataMapSchemas = getAllDataMapSchemas();
1:       for (DataMapSchema schema : dataMapSchemas) {
1:         DataMapCatalog dataMapCatalog = dataMapCatalogs.get(schema.getProviderName());
1:         if (dataMapCatalog == null) {
1:           dataMapCatalog = dataMapProvider.createDataMapCatalog();
1:           dataMapCatalogs.put(schema.getProviderName(), dataMapCatalog);
1:         }
1:         try {
1:           dataMapCatalog.registerSchema(schema);
1:         } catch (Exception e) {
1:           // Ignore the schema
1:           LOGGER.error(e, "Error while registering schema");
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
commit:747be9b
/////////////////////////////////////////////////////////////////////////
1:   List<TableDataMap> getAllVisibleDataMap(CarbonTable carbonTable) throws IOException {
commit:9db662a
/////////////////////////////////////////////////////////////////////////
0:         if (mapType == dataMap.getDataMapFactory().getDataMapLevel()) {
/////////////////////////////////////////////////////////////////////////
1:    * Return a new datamap instance and registered in the store manager.
1:    * The datamap is created using datamap name, datamap factory class and table identifier.
1:   public DataMapFactory getDataMapFactoryClass(CarbonTable table, DataMapSchema dataMapSchema)
1:       return (DataMapFactory)
1:           Class.forName(dataMapSchema.getProviderName()).getConstructors()[0]
1:               .newInstance(table, dataMapSchema);
1:       return DataMapRegistry.getDataMapFactoryByShortName(table, dataMapSchema);
/////////////////////////////////////////////////////////////////////////
1:       DataMapSchema dataMapSchema) throws MalformedDataMapCommandException {
1:     DataMapFactory dataMapFactory  = getDataMapFactoryClass(table, dataMapSchema);
1:       DataMapSchema dataMapSchema,  DataMapFactory dataMapFactory) {
/////////////////////////////////////////////////////////////////////////
commit:7e0803f
/////////////////////////////////////////////////////////////////////////
1:           dataMaps.add(getDataMap(carbonTable, dataMapSchema));
/////////////////////////////////////////////////////////////////////////
1:    * @param table
1:   public TableDataMap getDefaultDataMap(CarbonTable table) {
1:     return getDataMap(table, BlockletDataMapFactory.DATA_MAP_SCHEMA);
1:   public TableDataMap getDataMap(CarbonTable table, DataMapSchema dataMapSchema) {
1:     String tableUniqueName =
1:         table.getAbsoluteTableIdentifier().getCarbonTableIdentifier().getTableUniqueName();
1:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:       synchronized (tableUniqueName.intern()) {
1:         tableIndices = allDataMaps.get(tableUniqueName);
1:             dataMap = createAndRegisterDataMap(table, dataMapSchema);
/////////////////////////////////////////////////////////////////////////
0:   public TableDataMap createAndRegisterDataMap(CarbonTable table,
/////////////////////////////////////////////////////////////////////////
1:     return registerDataMap(table, dataMapSchema, dataMapFactory);
1:   public TableDataMap registerDataMap(CarbonTable table,
1:     String tableUniqueName = table.getCarbonTableIdentifier().getTableUniqueName();
1:     getTableSegmentRefresher(table);
1:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
0:     dataMapFactory.init(table.getAbsoluteTableIdentifier(), dataMapSchema);
1:       blockletDetailsFetcher = getBlockletDetailsFetcher(table);
1:     TableDataMap dataMap = new TableDataMap(table.getAbsoluteTableIdentifier(),
1:         dataMapSchema, dataMapFactory, blockletDetailsFetcher, segmentPropertiesFetcher);
1:     allDataMaps.put(tableUniqueName, tableIndices);
/////////////////////////////////////////////////////////////////////////
1:     getDefaultDataMap(carbonTable).clear(segments);
/////////////////////////////////////////////////////////////////////////
1:    * @param table
1:   private BlockletDetailsFetcher getBlockletDetailsFetcher(CarbonTable table) {
1:     TableDataMap blockletMap = getDataMap(table, BlockletDataMapFactory.DATA_MAP_SCHEMA);
/////////////////////////////////////////////////////////////////////////
1:   public TableSegmentRefresher getTableSegmentRefresher(CarbonTable table) {
1:     String uniqueName = table.getAbsoluteTableIdentifier().uniqueName();
1:       segmentRefreshMap.put(uniqueName, new TableSegmentRefresher(table));
/////////////////////////////////////////////////////////////////////////
1:     TableSegmentRefresher(CarbonTable table) {
1:       SegmentUpdateStatusManager statusManager = new SegmentUpdateStatusManager(table);
commit:bbb1092
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:       DataMapSchema dataMapSchema) throws MalformedDataMapCommandException, IOException {
/////////////////////////////////////////////////////////////////////////
0:       DataMapSchema dataMapSchema,  DataMapFactory dataMapFactory) throws IOException {
commit:fc2a7eb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.annotations.InterfaceAudience;
1: import org.apache.carbondata.core.datamap.dev.DataMapFactory;
1: import org.apache.carbondata.core.indexstore.blockletindex.BlockletDataMapFactory;
/////////////////////////////////////////////////////////////////////////
1: @InterfaceAudience.Internal
/////////////////////////////////////////////////////////////////////////
0:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable, DataMapLevel mapType) {
0:     List<TableDataMap> tableIndices = getAllDataMap(carbonTable);
1:     if (tableIndices != null) {
0:       for (TableDataMap dataMap : tableIndices) {
0:         if (mapType == dataMap.getDataMapFactory().getDataMapType()) {
/////////////////////////////////////////////////////////////////////////
1:    * It gives the default datamap of the table. Default datamap of any table is BlockletDataMap
0:     return getDataMap(identifier, BlockletDataMapFactory.DATA_MAP_SCHEMA);
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableIndices = allDataMaps.get(table);
1:     if (tableIndices != null) {
1:       dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableIndices);
0:         tableIndices = allDataMaps.get(table);
1:         if (tableIndices != null) {
1:           dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableIndices);
/////////////////////////////////////////////////////////////////////////
0:     DataMapFactory dataMapFactory;
1:       // try to create datamap by reflection to test whether it is a valid DataMapFactory class
0:       Class<? extends DataMapFactory> factoryClass =
0:           (Class<? extends DataMapFactory>) Class.forName(dataMapSchema.getClassName());
0:       dataMapFactory = factoryClass.newInstance();
/////////////////////////////////////////////////////////////////////////
0:     return registerDataMap(identifier, dataMapSchema, dataMapFactory);
0:       DataMapSchema dataMapSchema,  DataMapFactory dataMapFactory) {
0:     List<TableDataMap> tableIndices = allDataMaps.get(table);
1:     if (tableIndices == null) {
1:       tableIndices = new ArrayList<>();
0:     dataMapFactory.init(identifier, dataMapSchema);
1:     if (dataMapFactory instanceof BlockletDetailsFetcher) {
1:       blockletDetailsFetcher = (BlockletDetailsFetcher) dataMapFactory;
0:     TableDataMap dataMap = new TableDataMap(identifier, dataMapSchema, dataMapFactory,
1:     tableIndices.add(dataMap);
0:     allDataMaps.put(table, tableIndices);
1:   private TableDataMap getTableDataMap(String dataMapName, List<TableDataMap> tableIndices) {
1:     for (TableDataMap tableDataMap : tableIndices) {
/////////////////////////////////////////////////////////////////////////
1:     List<TableDataMap> tableIndices = allDataMaps.get(tableUniqueName);
1:     if (tableIndices != null) {
1:       for (TableDataMap tableDataMap : tableIndices) {
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableIndices =
0:     if (tableIndices != null) {
1:       for (TableDataMap tableDataMap : tableIndices) {
1:           tableIndices.remove(i);
/////////////////////////////////////////////////////////////////////////
0:     TableDataMap blockletMap = getDataMap(identifier, BlockletDataMapFactory.DATA_MAP_SCHEMA);
1:     return (BlockletDetailsFetcher) blockletMap.getDataMapFactory();
commit:89a12af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datamap.dev.IndexDataMapFactory;
0: import org.apache.carbondata.core.indexstore.blockletindex.BlockletIndexDataMapFactory;
/////////////////////////////////////////////////////////////////////////
0:         if (mapType == dataMap.getIndexDataMapFactory().getDataMapType()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!dataMapSchema.getClassName().equalsIgnoreCase(
0:             DataMapProvider.PREAGGREGATE.toString())) {
/////////////////////////////////////////////////////////////////////////
0:    * It gives the default datamap of the table. Default datamap of any table is BlockletIndexDataMap
0:     return getDataMap(identifier, BlockletIndexDataMapFactory.DATA_MAP_SCHEMA);
/////////////////////////////////////////////////////////////////////////
0:   private TableDataMap createAndRegisterDataMap(AbsoluteTableIdentifier identifier,
0:       DataMapSchema dataMapSchema) throws MalformedDataMapCommandException {
0:     IndexDataMapFactory indexDataMapFactory;
0:     try {
0:       // try to create datamap by reflection to test whether it is a valid IndexDataMapFactory class
0:       Class<? extends IndexDataMapFactory> factoryClass =
0:           (Class<? extends IndexDataMapFactory>) Class.forName(dataMapSchema.getClassName());
0:       indexDataMapFactory = factoryClass.newInstance();
1:     } catch (ClassNotFoundException e) {
0:       throw new MalformedDataMapCommandException(
0:           "DataMap '" + dataMapSchema.getClassName() + "' not found");
1:     } catch (Throwable e) {
1:       throw new MetadataProcessException(
0:           "failed to create DataMap '" + dataMapSchema.getClassName() + "'", e);
1:     }
0:     return registerDataMap(identifier, dataMapSchema, indexDataMapFactory);
1:   }
1: 
0:   public TableDataMap registerDataMap(AbsoluteTableIdentifier identifier,
0:       DataMapSchema dataMapSchema,  IndexDataMapFactory indexDataMapFactory) {
/////////////////////////////////////////////////////////////////////////
0:     indexDataMapFactory.init(identifier, dataMapSchema);
1:     BlockletDetailsFetcher blockletDetailsFetcher;
1:     SegmentPropertiesFetcher segmentPropertiesFetcher = null;
0:     if (indexDataMapFactory instanceof BlockletDetailsFetcher) {
0:       blockletDetailsFetcher = (BlockletDetailsFetcher) indexDataMapFactory;
0:     } else {
0:       blockletDetailsFetcher = getBlockletDetailsFetcher(identifier);
1:     segmentPropertiesFetcher = (SegmentPropertiesFetcher) blockletDetailsFetcher;
0:     TableDataMap dataMap = new TableDataMap(identifier, dataMapSchema, indexDataMapFactory,
0:         blockletDetailsFetcher, segmentPropertiesFetcher);
1: 
/////////////////////////////////////////////////////////////////////////
0:     TableDataMap blockletMap = getDataMap(identifier, BlockletIndexDataMapFactory.DATA_MAP_SCHEMA);
0:     return (BlockletDetailsFetcher) blockletMap.getIndexDataMapFactory();
commit:f089287
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.core.datamap;
1: import java.util.concurrent.ConcurrentHashMap;
0: import org.apache.carbondata.core.datamap.dev.DataMapFactory;
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, List<TableDataMap>> allDataMaps = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
0:   public List<TableDataMap> getAllDataMap(AbsoluteTableIdentifier identifier) {
0:     return allDataMaps.get(identifier.uniqueName());
1:   }
1: 
0:    * @param factoryClass
0:       Class<? extends DataMapFactory> factoryClass) {
0:     String table = identifier.uniqueName();
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(table);
0:       dataMap = createAndRegisterDataMap(identifier, factoryClass, dataMapName);
0:     } else {
0:       dataMap = getAbstractTableDataMap(dataMapName, tableDataMaps);
/////////////////////////////////////////////////////////////////////////
0:    * Return a new datamap instance and registered in the store manager.
0:    * The datamap is created using datamap name, datamap factory class and table identifier.
0:   public TableDataMap createAndRegisterDataMap(AbsoluteTableIdentifier identifier,
0:       Class<? extends DataMapFactory> factoryClass, String dataMapName) {
0:     String table = identifier.uniqueName();
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(table);
0:       allDataMaps.put(table, tableDataMaps);
0:       throw new RuntimeException("Already datamap exists in that path with type " + dataMapName);
0:       DataMapFactory dataMapFactory = factoryClass.newInstance();
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(identifier);
author:QiangCai
-------------------------------------------------------------------------------
commit:d23f7fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (dataMapSchema.isIndexDataMap()) {
/////////////////////////////////////////////////////////////////////////
0:   // TODO: make it private
0:   public TableDataMap createAndRegisterDataMap(AbsoluteTableIdentifier identifier,
0:           (Class<? extends DataMapFactory>) Class.forName(dataMapSchema.getProviderName());
0:           "DataMap '" + dataMapSchema.getProviderName() + "' not found");
0:           "failed to create DataMap '" + dataMapSchema.getProviderName() + "'", e);
0:       DataMapSchema dataMapSchema,  DataMapFactory dataMapFactory)
0:       throws IOException, MalformedDataMapCommandException {
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:56330ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.exceptions.MetadataProcessException;
1: import org.apache.carbondata.common.exceptions.sql.MalformedDataMapCommandException;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.metadata.schema.datamap.DataMapProvider;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.metadata.schema.table.DataMapSchema;
/////////////////////////////////////////////////////////////////////////
1:   /**
0:    * It gives all datamaps of type @mapType except the default datamap.
1:    *
1:    */
0:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable, DataMapType mapType) {
1:     List<TableDataMap> dataMaps = new ArrayList<>();
0:     List<TableDataMap> tableDataMaps = getAllDataMap(carbonTable);
0:     if (tableDataMaps != null) {
0:       for (TableDataMap dataMap : tableDataMaps) {
0:         if (mapType == dataMap.getDataMapFactory().getDataMapType()) {
0:           dataMaps.add(dataMap);
0:     return dataMaps;
1:   }
1: 
1:   /**
1:    * It gives all datamaps except the default datamap.
1:    *
0:    * @return
1:    */
0:   public List<TableDataMap> getAllDataMap(CarbonTable carbonTable) {
0:     List<DataMapSchema> dataMapSchemaList = carbonTable.getTableInfo().getDataMapSchemaList();
1:     List<TableDataMap> dataMaps = new ArrayList<>();
0:     if (dataMapSchemaList != null) {
0:       for (DataMapSchema dataMapSchema : dataMapSchemaList) {
0:         if (!dataMapSchema.getClassName()
0:             .equalsIgnoreCase(DataMapProvider.PREAGGREGATE.getClassName())) {
0:           dataMaps.add(getDataMap(carbonTable.getAbsoluteTableIdentifier(), dataMapSchema));
1:         }
1:       }
1:     }
0:     return dataMaps;
1:   }
1: 
1:   /**
0:    * It gives the default datamap of the table. Default datamap of any table is BlockletDataMap
1:    *
0:    * @param identifier
0:    * @return
1:    */
0:   public TableDataMap getDefaultDataMap(AbsoluteTableIdentifier identifier) {
0:     return getDataMap(identifier, BlockletDataMapFactory.DATA_MAP_SCHEMA);
0:   public TableDataMap getDataMap(AbsoluteTableIdentifier identifier, DataMapSchema dataMapSchema) {
0:     TableDataMap dataMap = null;
0:     if (tableDataMaps != null) {
0:       dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableDataMaps);
1:     }
1:     if (dataMap == null) {
0:         if (tableDataMaps != null) {
0:           dataMap = getTableDataMap(dataMapSchema.getDataMapName(), tableDataMaps);
1:         }
1:         if (dataMap == null) {
0:           try {
0:             dataMap = createAndRegisterDataMap(identifier, dataMapSchema);
0:           } catch (Exception e) {
0:             throw new RuntimeException(e);
1:           }
/////////////////////////////////////////////////////////////////////////
0:       DataMapSchema dataMapSchema)
0:       throws MalformedDataMapCommandException {
/////////////////////////////////////////////////////////////////////////
0:     String dataMapName = dataMapSchema.getDataMapName();
0:     if (dataMap != null && dataMap.getDataMapSchema().getDataMapName()
0:         .equalsIgnoreCase(dataMapName)) {
0:       throw new MalformedDataMapCommandException("Already datamap exists in that path with type " +
0:           dataMapName);
0:       // try to create datamap by reflection to test whether it is a valid DataMapFactory class
0:           (Class<? extends DataMapFactory>) Class.forName(dataMapSchema.getClassName());
0:       dataMapFactory.init(identifier, dataMapSchema);
/////////////////////////////////////////////////////////////////////////
0:       dataMap = new TableDataMap(identifier, dataMapSchema, dataMapFactory, blockletDetailsFetcher,
0:     } catch (ClassNotFoundException e) {
0:       throw new MalformedDataMapCommandException("DataMap class '" +
0:           dataMapSchema.getClassName() + "' not found");
0:     } catch (Throwable e) {
0:       throw new MetadataProcessException(
0:           "failed to create DataMap instance for '" + dataMapSchema.getClassName() + "'", e);
/////////////////////////////////////////////////////////////////////////
1:       if (tableDataMap.getDataMapSchema().getDataMapName().equals(dataMapName)) {
/////////////////////////////////////////////////////////////////////////
1:    * Clear the invalid segments from all the datamaps of the table
1:    * @param carbonTable
1:    * @param segments
1:    */
0:   public void clearInvalidSegments(CarbonTable carbonTable, List<Segment> segments) {
0:     getDefaultDataMap(carbonTable.getAbsoluteTableIdentifier()).clear(segments);
1:     List<TableDataMap> allDataMap = getAllDataMap(carbonTable);
1:     for (TableDataMap dataMap: allDataMap) {
1:       dataMap.clear(segments);
1:     }
1: 
1:   }
1: 
1:   /**
1:    *
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(tableUniqueName);
0:       for (TableDataMap tableDataMap : tableDataMaps) {
/////////////////////////////////////////////////////////////////////////
0:    *
/////////////////////////////////////////////////////////////////////////
0:       for (TableDataMap tableDataMap : tableDataMaps) {
0:         if (tableDataMap != null && dataMapName
1:             .equalsIgnoreCase(tableDataMap.getDataMapSchema().getDataMapName())) {
/////////////////////////////////////////////////////////////////////////
0:    *
0:     TableDataMap blockletMap = getDataMap(identifier, BlockletDataMapFactory.DATA_MAP_SCHEMA);
0:    *
/////////////////////////////////////////////////////////////////////////
1:       for (String segmentId : segmentIds) {
/////////////////////////////////////////////////////////////////////////
commit:28f78b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.BlockletDetailsFetcher;
0: import org.apache.carbondata.core.indexstore.blockletindex.BlockletDataMap;
0: import org.apache.carbondata.core.indexstore.blockletindex.BlockletDataMapFactory;
/////////////////////////////////////////////////////////////////////////
0:       BlockletDetailsFetcher blockletDetailsFetcher;
0:       if (dataMapFactory instanceof BlockletDetailsFetcher) {
0:         blockletDetailsFetcher = (BlockletDetailsFetcher) dataMapFactory;
0:       } else {
0:         blockletDetailsFetcher = getBlockletDetailsFetcher(identifier);
0:       }
0:       dataMap = new TableDataMap(identifier, dataMapName, dataMapFactory, blockletDetailsFetcher);
/////////////////////////////////////////////////////////////////////////
1:    * Get the blocklet datamap factory to get the detail information of blocklets
0:    * @param identifier
0:    * @return
1:    */
0:   private BlockletDetailsFetcher getBlockletDetailsFetcher(AbsoluteTableIdentifier identifier) {
0:     TableDataMap blockletMap =
0:         getDataMap(identifier, BlockletDataMap.NAME, BlockletDataMapFactory.class.getName());
0:     return (BlockletDetailsFetcher) blockletMap.getDataMapFactory();
0:   }
1: 
1:   /**
commit:eb771f5
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.mutate.SegmentUpdateDetails;
1: import org.apache.carbondata.core.mutate.UpdateVO;
1: import org.apache.carbondata.core.statusmanager.SegmentUpdateStatusManager;
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, TableSegmentRefresher> segmentRefreshMap = new ConcurrentHashMap<>();
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Just update the segmentRefreshMap with the table if not added.
0:     getTableSegmentRefresher(identifier);
/////////////////////////////////////////////////////////////////////////
0:    * Clear the datamap/datamaps of a table from memory
1:    * @param identifier Table identifier
0:   public void clearDataMap(AbsoluteTableIdentifier identifier) {
1:     segmentRefreshMap.remove(identifier.uniqueName());
1:         if (tableDataMap != null) {
0:       allDataMaps.remove(identifier.uniqueName());
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Get the TableSegmentRefresher for the table. If not existed then add one and return.
1:    */
0:   public TableSegmentRefresher getTableSegmentRefresher(AbsoluteTableIdentifier identifier) {
0:     String uniqueName = identifier.uniqueName();
1:     if (segmentRefreshMap.get(uniqueName) == null) {
0:       segmentRefreshMap.put(uniqueName, new TableSegmentRefresher(identifier));
0:     }
1:     return segmentRefreshMap.get(uniqueName);
0:   }
1: 
1:   /**
1:    * Keep track of the segment refresh time.
1:    */
1:   public static class TableSegmentRefresher {
1: 
1:     // This map stores the latest segment refresh time.So in case of update/delete we check the
1:     // time against this map.
0:     private Map<String, Long> segmentRefreshTime = new HashMap<>();
1: 
1:     // This map keeps the manual refresh entries from users. It is mainly used for partition
1:     // altering.
1:     private Map<String, Boolean> manualSegmentRefresh = new HashMap<>();
1: 
0:     public TableSegmentRefresher(AbsoluteTableIdentifier identifier) {
0:       SegmentUpdateStatusManager statusManager = new SegmentUpdateStatusManager(identifier);
1:       SegmentUpdateDetails[] updateStatusDetails = statusManager.getUpdateStatusDetails();
1:       for (SegmentUpdateDetails updateDetails : updateStatusDetails) {
1:         UpdateVO updateVO = statusManager.getInvalidTimestampRange(updateDetails.getSegmentName());
0:         segmentRefreshTime.put(updateVO.getSegmentId(), updateVO.getCreatedOrUpdatedTimeStamp());
0:       }
0:     }
1: 
0:     public boolean isRefreshNeeded(String segmentId, SegmentUpdateStatusManager statusManager) {
0:       UpdateVO updateVO = statusManager.getInvalidTimestampRange(segmentId);
0:       if (segmentRefreshTime.get(segmentId) == null) {
0:         segmentRefreshTime.put(segmentId, updateVO.getCreatedOrUpdatedTimeStamp());
1:         return true;
0:       }
1:       if (manualSegmentRefresh.get(segmentId) != null && manualSegmentRefresh.get(segmentId)) {
1:         manualSegmentRefresh.put(segmentId, false);
1:         return true;
0:       }
0:       Long updateTimestamp = updateVO.getLatestUpdateTimestamp();
0:       boolean isRefresh =
0:           updateTimestamp != null && (updateTimestamp > segmentRefreshTime.get(segmentId));
1:       if (isRefresh) {
1:         segmentRefreshTime.remove(segmentId);
0:       }
1:       return isRefresh;
0:     }
1: 
1:     public void refreshSegments(List<String> segmentIds) {
0:       for (String segmentId: segmentIds) {
1:         manualSegmentRefresh.put(segmentId, true);
0:       }
0:     }
1: 
1:     public boolean isRefreshNeeded(String segmentId) {
1:       if (manualSegmentRefresh.get(segmentId) != null && manualSegmentRefresh.get(segmentId)) {
1:         manualSegmentRefresh.put(segmentId, false);
1:         return true;
0:       } else {
1:         return false;
0:       }
0:     }
0:   }
1: 
1: 
commit:1e21cd1
/////////////////////////////////////////////////////////////////////////
0:   public synchronized TableDataMap getDataMap(AbsoluteTableIdentifier identifier,
0:       String dataMapName, String factoryClass) {
0:       dataMap = getTableDataMap(dataMapName, tableDataMaps);
/////////////////////////////////////////////////////////////////////////
0:       String factoryClassName, String dataMapName) {
0:     TableDataMap dataMap = getTableDataMap(dataMapName, tableDataMaps);
0:       Class<? extends DataMapFactory> factoryClass =
0:           (Class<? extends DataMapFactory>) Class.forName(factoryClassName);
0:       dataMap = new TableDataMap(identifier, dataMapName, dataMapFactory);
/////////////////////////////////////////////////////////////////////////
0:   private TableDataMap getTableDataMap(String dataMapName,
author:sounakr
-------------------------------------------------------------------------------
commit:ca7e2e3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.SegmentPropertiesFetcher;
/////////////////////////////////////////////////////////////////////////
0:     if (dataMap != null && dataMap.getDataMapName().equalsIgnoreCase(dataMapName)) {
/////////////////////////////////////////////////////////////////////////
0:       SegmentPropertiesFetcher segmentPropertiesFetcher = null;
0:       segmentPropertiesFetcher = (SegmentPropertiesFetcher) blockletDetailsFetcher;
0:       dataMap = new TableDataMap(identifier, dataMapName, dataMapFactory, blockletDetailsFetcher,
0:           segmentPropertiesFetcher);
/////////////////////////////////////////////////////////////////////////
0:   private TableDataMap getTableDataMap(String dataMapName, List<TableDataMap> tableDataMaps) {
0:     for (TableDataMap tableDataMap : tableDataMaps) {
0:       if (tableDataMap.getDataMapName().equals(dataMapName) || (!tableDataMap.getDataMapName()
0:           .equals(""))) {
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:       dataMap = new TableDataMap(dataMapName, dataMapFactory);
/////////////////////////////////////////////////////////////////////////
0:     List<TableDataMap> tableDataMaps = allDataMaps.get(identifier.uniqueName());
author:manishgupta88
-------------------------------------------------------------------------------
commit:2b66476
/////////////////////////////////////////////////////////////////////////
0:     // TODO: Initialize a data map by calling init method on the data map
============================================================================