1:379d4f6: /*
1:379d4f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:379d4f6:  * contributor license agreements.  See the NOTICE file distributed with
1:379d4f6:  * this work for additional information regarding copyright ownership.
1:379d4f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:379d4f6:  * (the "License"); you may not use this file except in compliance with
1:379d4f6:  * the License.  You may obtain a copy of the License at
1:379d4f6:  *
1:379d4f6:  *    http://www.apache.org/licenses/LICENSE-2.0
1:379d4f6:  *
1:379d4f6:  * Unless required by applicable law or agreed to in writing, software
1:379d4f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:379d4f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:379d4f6:  * See the License for the specific language governing permissions and
1:379d4f6:  * limitations under the License.
2:379d4f6:  */
4:379d4f6: 
1:e6a4f64: package org.apache.carbondata.core.datastore.page.encoding.rle;
1:379d4f6: 
1:379d4f6: import java.io.ByteArrayInputStream;
1:379d4f6: import java.io.ByteArrayOutputStream;
1:379d4f6: import java.io.DataInputStream;
1:379d4f6: import java.io.DataOutputStream;
1:379d4f6: import java.io.IOException;
1:379d4f6: import java.util.ArrayList;
1:379d4f6: import java.util.List;
1:e6a4f64: import java.util.Map;
1:379d4f6: 
1:8c1ddbf: import org.apache.carbondata.core.datastore.TableSpec;
1:379d4f6: import org.apache.carbondata.core.datastore.page.ColumnPage;
1:e6a4f64: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageCodec;
1:e6a4f64: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageDecoder;
1:e6a4f64: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoder;
1:e6a4f64: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1:379d4f6: import org.apache.carbondata.core.memory.MemoryException;
1:379d4f6: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:e6a4f64: import org.apache.carbondata.format.Encoding;
1:379d4f6: 
2:379d4f6: /**
1:379d4f6:  * RLE encoding implementation for integral column page.
1:379d4f6:  * This encoding keeps track of repeated-run and non-repeated-run, and make use
1:379d4f6:  * of the highest bit of the length field to indicate the type of run.
1:379d4f6:  * The length field is encoded as 16 bits value. (Page size must be less than 65535 rows)
1:379d4f6:  *
1:379d4f6:  * For example: input data {5, 5, 1, 2, 3, 3, 3, 3, 3} will be encoded to
1:379d4f6:  * {0x00, 0x02, 0x05,             (repeated-run, 2 values of 5)
1:379d4f6:  *  0x80, 0x03, 0x01, 0x02, 0x03, (non-repeated-run, 3 values: 1, 2, 3)
1:379d4f6:  *  0x00, 0x04, 0x03}             (repeated-run, 4 values of 3)
1:379d4f6:  */
1:379d4f6: public class RLECodec implements ColumnPageCodec {
1:379d4f6: 
1:379d4f6:   enum RUN_STATE { INIT, START, REPEATED_RUN, NONREPEATED_RUN }
1:379d4f6: 
2:379d4f6:   @Override
1:379d4f6:   public String getName() {
1:379d4f6:     return "RLECodec";
7:379d4f6:   }
1:379d4f6: 
1:379d4f6:   @Override
1:e6a4f64:   public ColumnPageEncoder createEncoder(Map<String, String> parameter) {
1:e6a4f64:     return new RLEEncoder();
1:379d4f6:   }
1:379d4f6: 
1:379d4f6:   @Override
1:e6a4f64:   public ColumnPageDecoder createDecoder(ColumnPageEncoderMeta meta) {
1:bb0b347:     assert meta instanceof RLEEncoderMeta;
1:e6a4f64:     RLEEncoderMeta codecMeta = (RLEEncoderMeta) meta;
1:8f08c4a:     return new RLEDecoder(meta.getColumnSpec(), codecMeta.getPageSize(), meta.getCompressorName());
1:379d4f6:   }
1:379d4f6: 
1:379d4f6:   // This codec supports integral type only
1:379d4f6:   private void validateDataType(DataType dataType) {
1:6abdd97:     if (! (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE ||
1:6abdd97:         dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:956833e:         dataType == DataTypes.LONG)) {
1:956833e:       throw new UnsupportedOperationException(dataType + " is not supported for RLE");
1:379d4f6:     }
1:379d4f6:   }
1:379d4f6: 
1:e6a4f64:   private class RLEEncoder extends ColumnPageEncoder {
1:379d4f6:     // While encoding RLE, this class internally work as a state machine
1:379d4f6:     // INIT state is the initial state before any value comes
1:379d4f6:     // START state is the start for each run
1:379d4f6:     // REPEATED_RUN state means it is collecting repeated values (`lastValue`)
1:379d4f6:     // NONREPEATED_RUN state means it is collecting non-repeated values (`nonRepeatValues`)
1:379d4f6:     private RUN_STATE runState;
1:379d4f6: 
1:379d4f6:     // count for each run, either REPEATED_RUN or NONREPEATED_RUN
1:379d4f6:     private short valueCount;
1:379d4f6: 
1:379d4f6:     // collected value for REPEATED_RUN
1:379d4f6:     private Object lastValue;
1:379d4f6: 
1:379d4f6:     // collected value for NONREPEATED_RUN
1:379d4f6:     private List<Object> nonRepeatValues;
1:379d4f6: 
1:379d4f6:     // data type of input page
3:379d4f6:     private DataType dataType;
1:379d4f6: 
1:379d4f6:     // output stream for encoded data
1:379d4f6:     private ByteArrayOutputStream bao;
1:379d4f6:     private DataOutputStream stream;
1:379d4f6: 
1:e6a4f64:     private RLEEncoder() {
1:379d4f6:       this.runState = RUN_STATE.INIT;
1:379d4f6:       this.valueCount = 0;
1:379d4f6:       this.nonRepeatValues = new ArrayList<>();
1:379d4f6:       this.bao = new ByteArrayOutputStream();
1:379d4f6:       this.stream = new DataOutputStream(bao);
1:379d4f6:     }
1:379d4f6: 
1:e6a4f64:     @Override
1:e6a4f64:     protected byte[] encodeData(ColumnPage input) throws MemoryException, IOException {
1:379d4f6:       validateDataType(input.getDataType());
1:379d4f6:       this.dataType = input.getDataType();
1:956833e:       if (dataType == DataTypes.BYTE) {
1:956833e:         byte[] bytePage = input.getBytePage();
1:956833e:         for (int i = 0; i < bytePage.length; i++) {
1:956833e:           putValue(bytePage[i]);
1:956833e:         }
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:956833e:         short[] shortPage = input.getShortPage();
1:956833e:         for (int i = 0; i < shortPage.length; i++) {
1:956833e:           putValue(shortPage[i]);
1:956833e:         }
1:956833e:       } else if (dataType == DataTypes.INT) {
1:956833e:         int[] intPage = input.getIntPage();
1:956833e:         for (int i = 0; i < intPage.length; i++) {
1:956833e:           putValue(intPage[i]);
1:956833e:         }
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         long[] longPage = input.getLongPage();
1:956833e:         for (int i = 0; i < longPage.length; i++) {
1:956833e:           putValue(longPage[i]);
1:956833e:         }
1:956833e:       } else {
1:956833e:         throw new UnsupportedOperationException(input.getDataType() +
1:956833e:             " does not support RLE encoding");
1:379d4f6:       }
1:e6a4f64:       return collectResult();
1:e6a4f64:     }
1:e6a4f64: 
1:e6a4f64:     @Override
1:e6a4f64:     protected List<Encoding> getEncodingList() {
1:e6a4f64:       List<Encoding> encodings = new ArrayList<>();
1:e6a4f64:       encodings.add(Encoding.RLE_INTEGRAL);
1:e6a4f64:       return encodings;
1:e6a4f64:     }
1:e6a4f64: 
1:e6a4f64:     @Override
1:e6a4f64:     protected ColumnPageEncoderMeta getEncoderMeta(ColumnPage inputPage) {
1:8c1ddbf:       return new RLEEncoderMeta(inputPage.getColumnSpec(),
1:8f08c4a:           inputPage.getDataType(),
1:8f08c4a:           inputPage.getPageSize(),
1:8f08c4a:           inputPage.getStatistics(),
1:8f08c4a:           inputPage.getColumnCompressorName());
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void putValue(Object value) throws IOException {
1:379d4f6:       if (runState == RUN_STATE.INIT) {
1:379d4f6:         startNewRun(value);
1:379d4f6:       } else {
1:379d4f6:         if (lastValue.equals(value)) {
1:379d4f6:           putRepeatValue(value);
1:379d4f6:         } else {
1:379d4f6:           putNonRepeatValue(value);
1:379d4f6:         }
1:379d4f6:       }
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     // when last row is reached, write out all collected data
1:379d4f6:     private byte[] collectResult() throws IOException {
1:379d4f6:       switch (runState) {
1:379d4f6:         case REPEATED_RUN:
1:379d4f6:           writeRunLength(valueCount);
1:379d4f6:           writeRunValue(lastValue);
14:379d4f6:           break;
1:379d4f6:         case NONREPEATED_RUN:
1:379d4f6:           writeRunLength(valueCount | 0x8000);
1:379d4f6:           for (int i = 0; i < valueCount; i++) {
1:379d4f6:             writeRunValue(nonRepeatValues.get(i));
1:379d4f6:           }
1:379d4f6:           break;
4:379d4f6:         default:
1:379d4f6:           assert (runState == RUN_STATE.START);
1:379d4f6:           writeRunLength(1);
1:379d4f6:           writeRunValue(lastValue);
1:379d4f6:       }
1:379d4f6:       return bao.toByteArray();
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void writeRunLength(int length) throws IOException {
1:379d4f6:       stream.writeShort(length);
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void writeRunValue(Object value) throws IOException {
1:956833e:       if (dataType == DataTypes.BYTE) {
1:956833e:         stream.writeByte((byte) value);
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:956833e:         stream.writeShort((short) value);
1:956833e:       } else if (dataType == DataTypes.INT) {
1:956833e:         stream.writeInt((int) value);
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         stream.writeLong((long) value);
1:956833e:       } else {
1:956833e:         throw new RuntimeException("internal error");
1:379d4f6:       }
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     // for each run, call this to initialize the state and clear the collected data
1:379d4f6:     private void startNewRun(Object value) {
1:379d4f6:       runState = RUN_STATE.START;
1:379d4f6:       valueCount = 1;
1:379d4f6:       lastValue = value;
1:379d4f6:       nonRepeatValues.clear();
1:379d4f6:       nonRepeatValues.add(value);
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     // non-repeated run ends, put the collected data to result page
1:379d4f6:     private void encodeNonRepeatedRun() throws IOException {
1:379d4f6:       // put the value count (highest bit is 1) and all collected values
1:379d4f6:       writeRunLength(valueCount | 0x8000);
1:379d4f6:       for (int i = 0; i < valueCount; i++) {
1:379d4f6:         writeRunValue(nonRepeatValues.get(i));
1:379d4f6:       }
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     // repeated run ends, put repeated value to result page
1:379d4f6:     private void encodeRepeatedRun() throws IOException {
1:379d4f6:       // put the value count (highest bit is 0) and repeated value
1:379d4f6:       writeRunLength(valueCount);
1:379d4f6:       writeRunValue(lastValue);
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void putRepeatValue(Object value) throws IOException {
1:379d4f6:       switch (runState) {
1:379d4f6:         case REPEATED_RUN:
1:379d4f6:           valueCount++;
1:379d4f6:           break;
1:379d4f6:         case NONREPEATED_RUN:
1:379d4f6:           // non-repeated run ends, encode this run
1:379d4f6:           encodeNonRepeatedRun();
1:379d4f6:           startNewRun(value);
1:379d4f6:           break;
1:379d4f6:         default:
1:379d4f6:           assert (runState == RUN_STATE.START);
1:379d4f6:           // enter repeated run
1:379d4f6:           runState = RUN_STATE.REPEATED_RUN;
1:379d4f6:           valueCount++;
1:379d4f6:           break;
1:379d4f6:       }
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void putNonRepeatValue(Object value) throws IOException {
1:379d4f6:       switch (runState) {
1:379d4f6:         case NONREPEATED_RUN:
1:379d4f6:           // collect the non-repeated value
1:379d4f6:           nonRepeatValues.add(value);
1:379d4f6:           lastValue = value;
1:379d4f6:           valueCount++;
1:379d4f6:           break;
1:379d4f6:         case REPEATED_RUN:
1:379d4f6:           // repeated-run ends, encode this run
1:379d4f6:           encodeRepeatedRun();
1:379d4f6:           startNewRun(value);
1:379d4f6:           break;
1:379d4f6:         default:
1:379d4f6:           assert (runState == RUN_STATE.START);
1:379d4f6:           // enter non-repeated run
1:379d4f6:           runState = RUN_STATE.NONREPEATED_RUN;
1:379d4f6:           nonRepeatValues.add(value);
1:379d4f6:           lastValue = value;
1:379d4f6:           valueCount++;
1:379d4f6:           break;
1:379d4f6:       }
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:   }
1:379d4f6: 
1:379d4f6:   // It decodes data in one shot. It is suitable for scan query
1:379d4f6:   // TODO: add a on-the-fly decoder for filter query with high selectivity
1:e6a4f64:   private class RLEDecoder implements ColumnPageDecoder {
1:379d4f6: 
1:8c1ddbf:     private TableSpec.ColumnSpec columnSpec;
2:379d4f6:     private int pageSize;
1:8f08c4a:     private String compressorName;
1:379d4f6: 
1:8f08c4a:     private RLEDecoder(TableSpec.ColumnSpec columnSpec, int pageSize, String compressorName) {
1:8c1ddbf:       validateDataType(columnSpec.getSchemaDataType());
1:8c1ddbf:       this.columnSpec = columnSpec;
2:379d4f6:       this.pageSize = pageSize;
1:8f08c4a:       this.compressorName = compressorName;
1:379d4f6:     }
1:379d4f6: 
1:e6a4f64:     @Override
1:e6a4f64:     public ColumnPage decode(byte[] input, int offset, int length)
1:379d4f6:         throws MemoryException, IOException {
1:8c1ddbf:       DataType dataType = columnSpec.getSchemaDataType();
1:379d4f6:       DataInputStream in = new DataInputStream(new ByteArrayInputStream(input, offset, length));
1:8f08c4a:       ColumnPage resultPage = ColumnPage.newPage(
1:8f08c4a:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
1:6abdd97:       if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:         decodeBytePage(in, resultPage);
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:956833e:         decodeShortPage(in, resultPage);
1:956833e:       } else if (dataType == DataTypes.INT) {
1:956833e:         decodeIntPage(in, resultPage);
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         decodeLongPage(in, resultPage);
1:956833e:       } else {
1:956833e:         throw new RuntimeException("unsupported datatype:" + dataType);
1:379d4f6:       }
1:379d4f6:       return resultPage;
1:379d4f6:     }
1:379d4f6: 
1:43285bb:     @Override public ColumnPage decode(byte[] input, int offset, int length, boolean isLVEncoded)
1:43285bb:         throws MemoryException, IOException {
1:43285bb:       return decode(input, offset, length);
1:43285bb:     }
1:43285bb: 
1:379d4f6:     private void decodeBytePage(DataInputStream in, ColumnPage decodedPage)
1:379d4f6:         throws IOException {
1:379d4f6:       int rowId = 0;
1:379d4f6:       do {
1:379d4f6:         int runLength = in.readShort();
1:379d4f6:         int count = runLength & 0x7FFF;
1:379d4f6:         if (runLength < 0) {
1:379d4f6:           // non-repeated run
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putByte(rowId++, in.readByte());
1:379d4f6:           }
1:379d4f6:         } else {
1:379d4f6:           // repeated run
1:379d4f6:           byte value = in.readByte();
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putByte(rowId++, value);
1:379d4f6:           }
1:379d4f6:         }
1:379d4f6:       } while (in.available() > 0);
1:379d4f6:     }
1:e6a4f64: 
1:379d4f6:     private void decodeShortPage(DataInputStream in, ColumnPage decodedPage)
1:379d4f6:         throws IOException {
1:379d4f6:       int rowId = 0;
1:379d4f6:       do {
1:379d4f6:         int runLength = in.readShort();
1:379d4f6:         int count = runLength & 0x7FFF;
1:379d4f6:         if (runLength < 0) {
1:379d4f6:           // non-repeated run
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putShort(rowId++, in.readShort());
1:379d4f6:           }
1:379d4f6:         } else {
1:379d4f6:           // repeated run
1:379d4f6:           short value = in.readShort();
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putShort(rowId++, value);
1:379d4f6:           }
1:379d4f6:         }
1:379d4f6:       } while (in.available() > 0);
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void decodeIntPage(DataInputStream in, ColumnPage decodedPage)
1:379d4f6:         throws IOException {
1:379d4f6:       int rowId = 0;
1:379d4f6:       do {
1:379d4f6:         int runLength = in.readShort();
1:379d4f6:         int count = runLength & 0x7FFF;
1:379d4f6:         if (runLength < 0) {
1:379d4f6:           // non-repeated run
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putInt(rowId++, in.readInt());
1:379d4f6:           }
1:379d4f6:         } else {
1:379d4f6:           // repeated run
1:379d4f6:           int value = in.readInt();
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putInt(rowId++, value);
1:379d4f6:           }
1:379d4f6:         }
1:379d4f6:       } while (in.available() > 0);
1:379d4f6:     }
1:379d4f6: 
1:379d4f6:     private void decodeLongPage(DataInputStream in, ColumnPage decodedPage)
1:379d4f6:         throws IOException {
1:379d4f6:       int rowId = 0;
1:379d4f6:       do {
1:379d4f6:         int runLength = in.readShort();
1:379d4f6:         int count = runLength & 0x7FFF;
1:379d4f6:         if (runLength < 0) {
1:379d4f6:           // non-repeated run
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putLong(rowId++, in.readLong());
1:379d4f6:           }
1:379d4f6:         } else {
1:379d4f6:           // repeated run
1:379d4f6:           long value = in.readLong();
1:379d4f6:           for (int i = 0; i < count; i++) {
1:379d4f6:             decodedPage.putLong(rowId++, value);
1:379d4f6:           }
1:379d4f6:         }
1:379d4f6:       } while (in.available() > 0);
1:379d4f6:     }
1:379d4f6:   }
1:379d4f6: 
1:379d4f6: }
============================================================================
author:xuchuanyin
-------------------------------------------------------------------------------
commit:8f08c4a
/////////////////////////////////////////////////////////////////////////
1:     return new RLEDecoder(meta.getColumnSpec(), codecMeta.getPageSize(), meta.getCompressorName());
/////////////////////////////////////////////////////////////////////////
1:           inputPage.getDataType(),
1:           inputPage.getPageSize(),
1:           inputPage.getStatistics(),
1:           inputPage.getColumnCompressorName());
/////////////////////////////////////////////////////////////////////////
1:     private String compressorName;
1:     private RLEDecoder(TableSpec.ColumnSpec columnSpec, int pageSize, String compressorName) {
1:       this.compressorName = compressorName;
/////////////////////////////////////////////////////////////////////////
1:       ColumnPage resultPage = ColumnPage.newPage(
1:           new ColumnPageEncoderMeta(columnSpec, dataType, compressorName), pageSize);
author:kumarvishal09
-------------------------------------------------------------------------------
commit:43285bb
/////////////////////////////////////////////////////////////////////////
1:     @Override public ColumnPage decode(byte[] input, int offset, int length, boolean isLVEncoded)
1:         throws MemoryException, IOException {
1:       return decode(input, offset, length);
1:     }
1: 
author:xubo245
-------------------------------------------------------------------------------
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
1:     if (! (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE ||
1:         dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
/////////////////////////////////////////////////////////////////////////
1:       if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
author:Jacky Li
-------------------------------------------------------------------------------
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:     if (! (dataType == DataTypes.BYTE || dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:         dataType == DataTypes.LONG)) {
1:       throw new UnsupportedOperationException(dataType + " is not supported for RLE");
/////////////////////////////////////////////////////////////////////////
1:       if (dataType == DataTypes.BYTE) {
1:         byte[] bytePage = input.getBytePage();
1:         for (int i = 0; i < bytePage.length; i++) {
1:           putValue(bytePage[i]);
1:         }
1:       } else if (dataType == DataTypes.SHORT) {
1:         short[] shortPage = input.getShortPage();
1:         for (int i = 0; i < shortPage.length; i++) {
1:           putValue(shortPage[i]);
1:         }
1:       } else if (dataType == DataTypes.INT) {
1:         int[] intPage = input.getIntPage();
1:         for (int i = 0; i < intPage.length; i++) {
1:           putValue(intPage[i]);
1:         }
1:       } else if (dataType == DataTypes.LONG) {
1:         long[] longPage = input.getLongPage();
1:         for (int i = 0; i < longPage.length; i++) {
1:           putValue(longPage[i]);
1:         }
1:       } else {
1:         throw new UnsupportedOperationException(input.getDataType() +
1:             " does not support RLE encoding");
/////////////////////////////////////////////////////////////////////////
1:       if (dataType == DataTypes.BYTE) {
1:         stream.writeByte((byte) value);
1:       } else if (dataType == DataTypes.SHORT) {
1:         stream.writeShort((short) value);
1:       } else if (dataType == DataTypes.INT) {
1:         stream.writeInt((int) value);
1:       } else if (dataType == DataTypes.LONG) {
1:         stream.writeLong((long) value);
1:       } else {
1:         throw new RuntimeException("internal error");
/////////////////////////////////////////////////////////////////////////
0:       if (dataType == DataTypes.BYTE) {
1:         decodeBytePage(in, resultPage);
1:       } else if (dataType == DataTypes.SHORT) {
1:         decodeShortPage(in, resultPage);
1:       } else if (dataType == DataTypes.INT) {
1:         decodeIntPage(in, resultPage);
1:       } else if (dataType == DataTypes.LONG) {
1:         decodeLongPage(in, resultPage);
1:       } else {
1:         throw new RuntimeException("unsupported datatype:" + dataType);
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.TableSpec;
/////////////////////////////////////////////////////////////////////////
0:     return new RLEDecoder(meta.getColumnSpec(), codecMeta.getPageSize());
/////////////////////////////////////////////////////////////////////////
1:       return new RLEEncoderMeta(inputPage.getColumnSpec(),
/////////////////////////////////////////////////////////////////////////
1:     private TableSpec.ColumnSpec columnSpec;
0:     private RLEDecoder(TableSpec.ColumnSpec columnSpec, int pageSize) {
1:       validateDataType(columnSpec.getSchemaDataType());
1:       this.columnSpec = columnSpec;
1:       DataType dataType = columnSpec.getSchemaDataType();
0:       ColumnPage resultPage = ColumnPage.newPage(columnSpec, dataType, pageSize);
commit:e6a4f64
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.core.datastore.page.encoding.rle;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageCodec;
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageDecoder;
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoder;
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1: import org.apache.carbondata.format.Encoding;
/////////////////////////////////////////////////////////////////////////
1:   public ColumnPageEncoder createEncoder(Map<String, String> parameter) {
1:     return new RLEEncoder();
1:   public ColumnPageDecoder createDecoder(ColumnPageEncoderMeta meta) {
1:     RLEEncoderMeta codecMeta = (RLEEncoderMeta) meta;
0:     return new RLEDecoder(codecMeta.getDataType(), codecMeta.getPageSize());
/////////////////////////////////////////////////////////////////////////
1:   private class RLEEncoder extends ColumnPageEncoder {
/////////////////////////////////////////////////////////////////////////
1:     private RLEEncoder() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected byte[] encodeData(ColumnPage input) throws MemoryException, IOException {
/////////////////////////////////////////////////////////////////////////
1:       return collectResult();
1:     }
1: 
1:     @Override
1:     protected List<Encoding> getEncodingList() {
1:       List<Encoding> encodings = new ArrayList<>();
1:       encodings.add(Encoding.RLE_INTEGRAL);
1:       return encodings;
1:     }
1: 
1:     @Override
1:     protected ColumnPageEncoderMeta getEncoderMeta(ColumnPage inputPage) {
0:       return new RLEEncoderMeta(
0:           inputPage.getDataType(), inputPage.getPageSize(), inputPage.getStatistics());
/////////////////////////////////////////////////////////////////////////
1:   private class RLEDecoder implements ColumnPageDecoder {
0:     private RLEDecoder(DataType dataType, int pageSize) {
1:     @Override
1:     public ColumnPage decode(byte[] input, int offset, int length)
/////////////////////////////////////////////////////////////////////////
1: 
commit:379d4f6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
0: package org.apache.carbondata.core.datastore.page.encoding;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: import org.apache.carbondata.core.datastore.page.ColumnPage;
0: import org.apache.carbondata.core.datastore.page.ComplexColumnPage;
0: import org.apache.carbondata.core.datastore.page.statistics.SimpleStatsResult;
1: import org.apache.carbondata.core.memory.MemoryException;
0: import org.apache.carbondata.core.metadata.CodecMetaFactory;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: 
1: /**
1:  * RLE encoding implementation for integral column page.
1:  * This encoding keeps track of repeated-run and non-repeated-run, and make use
1:  * of the highest bit of the length field to indicate the type of run.
1:  * The length field is encoded as 16 bits value. (Page size must be less than 65535 rows)
1:  *
1:  * For example: input data {5, 5, 1, 2, 3, 3, 3, 3, 3} will be encoded to
1:  * {0x00, 0x02, 0x05,             (repeated-run, 2 values of 5)
1:  *  0x80, 0x03, 0x01, 0x02, 0x03, (non-repeated-run, 3 values: 1, 2, 3)
1:  *  0x00, 0x04, 0x03}             (repeated-run, 4 values of 3)
1:  */
1: public class RLECodec implements ColumnPageCodec {
1: 
1:   enum RUN_STATE { INIT, START, REPEATED_RUN, NONREPEATED_RUN }
1: 
1:   private DataType dataType;
1:   private int pageSize;
1: 
1:   /**
0:    * New RLECodec
0:    * @param dataType data type of the raw column page before encode
0:    * @param pageSize page size of the raw column page before encode
1:    */
0:   RLECodec(DataType dataType, int pageSize) {
0:     this.dataType = dataType;
1:     this.pageSize = pageSize;
1:   }
1: 
1:   @Override
1:   public String getName() {
1:     return "RLECodec";
1:   }
1: 
1:   @Override
0:   public EncodedColumnPage encode(ColumnPage input) throws MemoryException, IOException {
0:     Encoder encoder = new Encoder();
0:     return encoder.encode(input);
1:   }
1: 
1:   @Override
0:   public EncodedColumnPage[] encodeComplexColumn(ComplexColumnPage input) {
0:     throw new UnsupportedOperationException("complex column does not support RLE encoding");
1:   }
1: 
1:   @Override
0:   public ColumnPage decode(byte[] input, int offset, int length) throws MemoryException,
0:       IOException {
0:     Decoder decoder = new Decoder(dataType, pageSize);
0:     return decoder.decode(input, offset, length);
1:   }
1: 
1:   // This codec supports integral type only
1:   private void validateDataType(DataType dataType) {
0:     switch (dataType) {
0:       case BYTE:
0:       case SHORT:
0:       case INT:
0:       case LONG:
1:         break;
1:       default:
0:         throw new UnsupportedOperationException(dataType + " is not supported for RLE");
1:     }
1:   }
1: 
0:   private class Encoder {
1:     // While encoding RLE, this class internally work as a state machine
1:     // INIT state is the initial state before any value comes
1:     // START state is the start for each run
1:     // REPEATED_RUN state means it is collecting repeated values (`lastValue`)
1:     // NONREPEATED_RUN state means it is collecting non-repeated values (`nonRepeatValues`)
1:     private RUN_STATE runState;
1: 
1:     // count for each run, either REPEATED_RUN or NONREPEATED_RUN
1:     private short valueCount;
1: 
1:     // collected value for REPEATED_RUN
1:     private Object lastValue;
1: 
1:     // collected value for NONREPEATED_RUN
1:     private List<Object> nonRepeatValues;
1: 
1:     // data type of input page
1:     private DataType dataType;
1: 
1:     // output stream for encoded data
1:     private ByteArrayOutputStream bao;
1:     private DataOutputStream stream;
1: 
0:     private Encoder() {
1:       this.runState = RUN_STATE.INIT;
1:       this.valueCount = 0;
1:       this.nonRepeatValues = new ArrayList<>();
1:       this.bao = new ByteArrayOutputStream();
1:       this.stream = new DataOutputStream(bao);
1:     }
1: 
0:     private EncodedColumnPage encode(ColumnPage input) throws MemoryException, IOException {
1:       validateDataType(input.getDataType());
1:       this.dataType = input.getDataType();
0:       switch (dataType) {
0:         case BYTE:
0:           byte[] bytePage = input.getBytePage();
0:           for (int i = 0; i < bytePage.length; i++) {
0:             putValue(bytePage[i]);
1:           }
1:           break;
0:         case SHORT:
0:           short[] shortPage = input.getShortPage();
0:           for (int i = 0; i < shortPage.length; i++) {
0:             putValue(shortPage[i]);
1:           }
1:           break;
0:         case INT:
0:           int[] intPage = input.getIntPage();
0:           for (int i = 0; i < intPage.length; i++) {
0:             putValue(intPage[i]);
1:           }
1:           break;
0:         case LONG:
0:           long[] longPage = input.getLongPage();
0:           for (int i = 0; i < longPage.length; i++) {
0:             putValue(longPage[i]);
1:           }
1:           break;
1:         default:
0:           throw new UnsupportedOperationException(input.getDataType() +
0:               " does not support RLE encoding");
1:       }
0:       byte[] encoded = collectResult();
0:       SimpleStatsResult stats = (SimpleStatsResult) input.getStatistics();
0:       return new EncodedMeasurePage(
0:           input.getPageSize(),
0:           encoded,
0:           CodecMetaFactory.createMeta(stats, input.getDataType()),
0:           stats.getNullBits());
1:     }
1: 
1:     private void putValue(Object value) throws IOException {
1:       if (runState == RUN_STATE.INIT) {
1:         startNewRun(value);
1:       } else {
1:         if (lastValue.equals(value)) {
1:           putRepeatValue(value);
1:         } else {
1:           putNonRepeatValue(value);
1:         }
1:       }
1:     }
1: 
1:     // when last row is reached, write out all collected data
1:     private byte[] collectResult() throws IOException {
1:       switch (runState) {
1:         case REPEATED_RUN:
1:           writeRunLength(valueCount);
1:           writeRunValue(lastValue);
1:           break;
1:         case NONREPEATED_RUN:
1:           writeRunLength(valueCount | 0x8000);
1:           for (int i = 0; i < valueCount; i++) {
1:             writeRunValue(nonRepeatValues.get(i));
1:           }
1:           break;
1:         default:
1:           assert (runState == RUN_STATE.START);
1:           writeRunLength(1);
1:           writeRunValue(lastValue);
1:       }
1:       return bao.toByteArray();
1:     }
1: 
1:     private void writeRunLength(int length) throws IOException {
1:       stream.writeShort(length);
1:     }
1: 
1:     private void writeRunValue(Object value) throws IOException {
0:       switch (dataType) {
0:         case BYTE:
0:           stream.writeByte((byte) value);
1:           break;
0:         case SHORT:
0:           stream.writeShort((short) value);
1:           break;
0:         case INT:
0:           stream.writeInt((int) value);
1:           break;
0:         case LONG:
0:           stream.writeLong((long) value);
1:           break;
1:         default:
0:           throw new RuntimeException("internal error");
1:       }
1:     }
1: 
1:     // for each run, call this to initialize the state and clear the collected data
1:     private void startNewRun(Object value) {
1:       runState = RUN_STATE.START;
1:       valueCount = 1;
1:       lastValue = value;
1:       nonRepeatValues.clear();
1:       nonRepeatValues.add(value);
1:     }
1: 
1:     // non-repeated run ends, put the collected data to result page
1:     private void encodeNonRepeatedRun() throws IOException {
1:       // put the value count (highest bit is 1) and all collected values
1:       writeRunLength(valueCount | 0x8000);
1:       for (int i = 0; i < valueCount; i++) {
1:         writeRunValue(nonRepeatValues.get(i));
1:       }
1:     }
1: 
1:     // repeated run ends, put repeated value to result page
1:     private void encodeRepeatedRun() throws IOException {
1:       // put the value count (highest bit is 0) and repeated value
1:       writeRunLength(valueCount);
1:       writeRunValue(lastValue);
1:     }
1: 
1:     private void putRepeatValue(Object value) throws IOException {
1:       switch (runState) {
1:         case REPEATED_RUN:
1:           valueCount++;
1:           break;
1:         case NONREPEATED_RUN:
1:           // non-repeated run ends, encode this run
1:           encodeNonRepeatedRun();
1:           startNewRun(value);
1:           break;
1:         default:
1:           assert (runState == RUN_STATE.START);
1:           // enter repeated run
1:           runState = RUN_STATE.REPEATED_RUN;
1:           valueCount++;
1:           break;
1:       }
1:     }
1: 
1:     private void putNonRepeatValue(Object value) throws IOException {
1:       switch (runState) {
1:         case NONREPEATED_RUN:
1:           // collect the non-repeated value
1:           nonRepeatValues.add(value);
1:           lastValue = value;
1:           valueCount++;
1:           break;
1:         case REPEATED_RUN:
1:           // repeated-run ends, encode this run
1:           encodeRepeatedRun();
1:           startNewRun(value);
1:           break;
1:         default:
1:           assert (runState == RUN_STATE.START);
1:           // enter non-repeated run
1:           runState = RUN_STATE.NONREPEATED_RUN;
1:           nonRepeatValues.add(value);
1:           lastValue = value;
1:           valueCount++;
1:           break;
1:       }
1:     }
1: 
1:   }
1: 
1:   // It decodes data in one shot. It is suitable for scan query
1:   // TODO: add a on-the-fly decoder for filter query with high selectivity
0:   private class Decoder {
1: 
0:     // src data type
1:     private DataType dataType;
1:     private int pageSize;
1: 
0:     private Decoder(DataType dataType, int pageSize) throws MemoryException {
0:       validateDataType(dataType);
0:       this.dataType = dataType;
1:       this.pageSize = pageSize;
1:     }
1: 
0:     private ColumnPage decode(byte[] input, int offset, int length)
1:         throws MemoryException, IOException {
1:       DataInputStream in = new DataInputStream(new ByteArrayInputStream(input, offset, length));
0:       ColumnPage resultPage = ColumnPage.newPage(dataType, pageSize);
0:       switch (dataType) {
0:         case BYTE:
0:           decodeBytePage(in, resultPage);
1:           break;
0:         case SHORT:
0:           decodeShortPage(in, resultPage);
1:           break;
0:         case INT:
0:           decodeIntPage(in, resultPage);
1:           break;
0:         case LONG:
0:           decodeLongPage(in, resultPage);
1:           break;
1:       }
1:       return resultPage;
1:     }
1: 
1:     private void decodeBytePage(DataInputStream in, ColumnPage decodedPage)
1:         throws IOException {
1:       int rowId = 0;
1:       do {
1:         int runLength = in.readShort();
1:         int count = runLength & 0x7FFF;
1:         if (runLength < 0) {
1:           // non-repeated run
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putByte(rowId++, in.readByte());
1:           }
1:         } else {
1:           // repeated run
1:           byte value = in.readByte();
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putByte(rowId++, value);
1:           }
1:         }
1:       } while (in.available() > 0);
1:     }
1: 
1:     private void decodeShortPage(DataInputStream in, ColumnPage decodedPage)
1:         throws IOException {
1:       int rowId = 0;
1:       do {
1:         int runLength = in.readShort();
1:         int count = runLength & 0x7FFF;
1:         if (runLength < 0) {
1:           // non-repeated run
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putShort(rowId++, in.readShort());
1:           }
1:         } else {
1:           // repeated run
1:           short value = in.readShort();
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putShort(rowId++, value);
1:           }
1:         }
1:       } while (in.available() > 0);
1:     }
1: 
1:     private void decodeIntPage(DataInputStream in, ColumnPage decodedPage)
1:         throws IOException {
1:       int rowId = 0;
1:       do {
1:         int runLength = in.readShort();
1:         int count = runLength & 0x7FFF;
1:         if (runLength < 0) {
1:           // non-repeated run
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putInt(rowId++, in.readInt());
1:           }
1:         } else {
1:           // repeated run
1:           int value = in.readInt();
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putInt(rowId++, value);
1:           }
1:         }
1:       } while (in.available() > 0);
1:     }
1: 
1:     private void decodeLongPage(DataInputStream in, ColumnPage decodedPage)
1:         throws IOException {
1:       int rowId = 0;
1:       do {
1:         int runLength = in.readShort();
1:         int count = runLength & 0x7FFF;
1:         if (runLength < 0) {
1:           // non-repeated run
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putLong(rowId++, in.readLong());
1:           }
1:         } else {
1:           // repeated run
1:           long value = in.readLong();
1:           for (int i = 0; i < count; i++) {
1:             decodedPage.putLong(rowId++, value);
1:           }
1:         }
1:       } while (in.available() > 0);
1:     }
1:   }
1: }
author:Raghunandan S
-------------------------------------------------------------------------------
commit:bb0b347
/////////////////////////////////////////////////////////////////////////
1:     assert meta instanceof RLEEncoderMeta;
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:         default:
0:           throw new RuntimeException("unsupported datatype:" + dataType);
============================================================================