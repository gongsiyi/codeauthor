1:f910cfa: /*
1:f910cfa:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f910cfa:  * contributor license agreements.  See the NOTICE file distributed with
1:f910cfa:  * this work for additional information regarding copyright ownership.
1:f910cfa:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f910cfa:  * (the "License"); you may not use this file except in compliance with
1:f910cfa:  * the License.  You may obtain a copy of the License at
1:f910cfa:  *
1:f910cfa:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f910cfa:  *
1:f910cfa:  * Unless required by applicable law or agreed to in writing, software
1:f910cfa:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f910cfa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f910cfa:  * See the License for the specific language governing permissions and
1:f910cfa:  * limitations under the License.
1:f910cfa:  */
6:f910cfa: 
1:f910cfa: package org.apache.carbondata.sdk.file;
1:f910cfa: 
1:8896a63: import java.io.*;
1:a7ac656: import java.sql.Date;
1:a7ac656: import java.sql.Timestamp;
1:290ef5a: import java.util.*;
1:f910cfa: 
1:8896a63: import org.apache.avro.generic.GenericData;
1:8896a63: import org.apache.carbondata.common.exceptions.sql.InvalidLoadOptionException;
1:a7ac656: import org.apache.carbondata.common.logging.LogService;
1:a7ac656: import org.apache.carbondata.common.logging.LogServiceFactory;
1:a7ac656: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:f910cfa: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:bea277f: import org.apache.carbondata.core.metadata.schema.table.DiskBasedDMSchemaStorageProvider;
1:290ef5a: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1:290ef5a: import org.apache.carbondata.core.scan.expression.LiteralExpression;
1:459331c: import org.apache.carbondata.core.scan.expression.conditional.*;
1:290ef5a: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1:290ef5a: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1:a7ac656: import org.apache.carbondata.core.util.CarbonProperties;
1:a7ac656: import org.apache.carbondata.core.util.path.CarbonTablePath;
1:f910cfa: 
1:a7ac656: import junit.framework.TestCase;
1:f910cfa: import org.apache.commons.io.FileUtils;
1:8896a63: import org.apache.commons.lang.CharEncoding;
1:8f1a029: import org.apache.hadoop.conf.Configuration;
1:8896a63: import org.junit.*;
1:cf55028: 
1:a7ac656: public class CarbonReaderTest extends TestCase {
1:f910cfa: 
1:8f1a029:   private Configuration conf = new Configuration(false);
1:8f1a029:   
1:cf55028:   @Before
1:cf55028:   public void cleanFile() {
1:cf55028:     assert (TestUtil.cleanMdtFile());
1:cf55028:   }
1:8896a63: 
1:cf55028:   @After
1:cf55028:   public void verifyDMFile() {
1:cf55028:     assert (!TestUtil.verifyMdtFile());
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     try {
1:290ef5a:       FileUtils.deleteDirectory(new File(path));
1:290ef5a:     } catch (IOException e) {
1:290ef5a:       e.printStackTrace();
1:290ef5a:     }
1:cf55028:   }
1:8896a63: 
1:fb6dffe:   @Test
1:f910cfa:   public void testWriteAndReadFiles() throws IOException, InterruptedException {
1:f910cfa:     String path = "./testWriteFiles";
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:8b80b12:     Field[] fields = new Field[2];
1:8b80b12:     fields[0] = new Field("name", DataTypes.STRING);
1:f910cfa:     fields[1] = new Field("age", DataTypes.INT);
1:cf55028: 
1:92d9b92:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1:4b8dc0a: 
1:74770aa:     CarbonReader reader = CarbonReader.builder(path, "_temp").isTransactionalTable(true)
1:8f1a029:         .projection(new String[]{"name", "age"}).build(conf);
1:4b8dc0a: 
1:5f32647:     // expected output after sorting
1:92d9b92:     String[] name = new String[200];
1:92d9b92:     Integer[] age = new Integer[200];
1:92d9b92:     for (int i = 0; i < 200; i++) {
1:5f32647:       name[i] = "robot" + (i / 10);
1:92d9b92:       age[i] = i;
2:f910cfa:     }
1:4b8dc0a: 
1:f910cfa:     int i = 0;
1:4b8dc0a:     while (reader.hasNext()) {
1:5f32647:       Object[] row = (Object[]) reader.readNextRow();
1:5f32647:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:92d9b92:       assert(Arrays.asList(name).contains(row[0]));
1:92d9b92:       assert(Arrays.asList(age).contains(row[1]));
1:f910cfa:       i++;
1:f910cfa:     }
1:92d9b92:     Assert.assertEquals(i, 200);
1:4b8dc0a: 
1:92d9b92:     reader.close();
1:a7ac656: 
1:a7ac656:     // Read again
1:a7ac656:     CarbonReader reader2 = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:8896a63:         .isTransactionalTable(true)
1:a7ac656:         .projection(new String[]{"name", "age"})
1:8f1a029:         .build(conf);
1:a7ac656: 
1:a7ac656:     i = 0;
1:a7ac656:     while (reader2.hasNext()) {
1:a7ac656:       Object[] row = (Object[]) reader2.readNextRow();
1:a7ac656:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:92d9b92:       assert(Arrays.asList(name).contains(row[0]));
1:92d9b92:       assert(Arrays.asList(age).contains(row[1]));
1:a7ac656:       i++;
1:a7ac656:     }
1:92d9b92:     Assert.assertEquals(i, 200);
1:a7ac656:     reader2.close();
1:a7ac656: 
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7ac656:   }
1:a7ac656: 
1:a7ac656:   @Test
1:290ef5a:   public void testReadWithFilterOfTransactional() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[2];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1:290ef5a: 
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(
1:290ef5a:         new ColumnExpression("name", DataTypes.STRING),
1:290ef5a:         new LiteralExpression("robot1", DataTypes.STRING));
1:290ef5a:     CarbonReader reader = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(true)
1:290ef5a:         .projection(new String[]{"name", "age"})
1:290ef5a:         .filter(equalToExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:290ef5a:       assert ("robot1".equals(row[0]));
1:290ef5a:       i++;
1:290ef5a:     }
2:290ef5a:     Assert.assertEquals(i, 20);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:290ef5a: 
1:290ef5a:   @Test
1:290ef5a:   public void testReadWithFilterOfTransactionalAnd() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[3];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:290ef5a:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:290ef5a:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:290ef5a:         new LiteralExpression("robot7", DataTypes.STRING));
1:290ef5a: 
1:290ef5a:     AndExpression andExpression = new AndExpression(equalToExpression, equalToExpression2);
1:290ef5a:     CarbonReader reader = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(true)
1:290ef5a:         .projection(new String[]{"name", "age", "doubleField"})
1:290ef5a:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       assert (((String) row[0]).contains("robot7"));
1:290ef5a:       assert (7 == (int) (row[1]));
1:290ef5a:       assert (3.5 == (double) (row[2]));
1:290ef5a:       i++;
1:290ef5a:     }
1:290ef5a:     Assert.assertEquals(i, 1);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:290ef5a: 
1:290ef5a:   @Test
1:290ef5a:   public void testReadWithFilterOfNonTransactionalSimple() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[2];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression = new ColumnExpression("name", DataTypes.STRING);
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:290ef5a:         new LiteralExpression("robot1", DataTypes.STRING));
1:290ef5a: 
1:290ef5a:     CarbonReader reader = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(false)
1:290ef5a:         .projection(new String[]{"name", "age"})
1:290ef5a:         .filter(equalToExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:290ef5a:       assert ("robot1".equals(row[0]));
1:290ef5a:       i++;
1:290ef5a:     }
1:290ef5a:     Assert.assertEquals(i, 20);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:290ef5a: 
1:290ef5a:   @Test
1:290ef5a:   public void testReadWithFilterOfNonTransactional2() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[2];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression = new ColumnExpression("age", DataTypes.INT);
1:290ef5a: 
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:290ef5a:         new LiteralExpression("1", DataTypes.INT));
1:290ef5a:     CarbonReader reader = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(false)
1:290ef5a:         .projection(new String[]{"name", "age"})
1:290ef5a:         .filter(equalToExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:290ef5a:       assert (((String) row[0]).contains("robot"));
1:290ef5a:       assert (1 == (int) (row[1]));
1:290ef5a:       i++;
1:290ef5a:     }
1:290ef5a:     Assert.assertEquals(i, 1);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:290ef5a: 
1:290ef5a:   @Test
1:290ef5a:   public void testReadWithFilterOfNonTransactionalAnd() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[3];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:290ef5a:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:290ef5a:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:290ef5a:         new LiteralExpression("robot7", DataTypes.STRING));
1:290ef5a: 
1:290ef5a:     AndExpression andExpression = new AndExpression(equalToExpression, equalToExpression2);
1:290ef5a:     CarbonReader reader = CarbonReader
1:290ef5a:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(false)
1:290ef5a:         .projection(new String[]{"name", "age", "doubleField"})
1:290ef5a:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       assert (((String) row[0]).contains("robot7"));
1:290ef5a:       assert (7 == (int) (row[1]));
1:290ef5a:       assert (3.5 == (double) (row[2]));
1:290ef5a:       i++;
1:290ef5a:     }
1:290ef5a:     Assert.assertEquals(i, 1);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:290ef5a: 
1:290ef5a:   @Test
1:290ef5a:   public void testReadWithFilterOfNonTransactionalOr() throws IOException, InterruptedException {
1:290ef5a:     String path = "./testWriteFiles";
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a: 
1:290ef5a:     Field[] fields = new Field[3];
1:290ef5a:     fields[0] = new Field("name", DataTypes.STRING);
1:290ef5a:     fields[1] = new Field("age", DataTypes.INT);
1:290ef5a:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:290ef5a: 
1:290ef5a:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:290ef5a:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:290ef5a:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1:290ef5a: 
1:290ef5a:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:290ef5a:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:290ef5a:         new LiteralExpression("robot7", DataTypes.STRING));
1:290ef5a: 
1:459331c:     OrExpression orExpression = new OrExpression(equalToExpression, equalToExpression2);
1:459331c:     CarbonReader reader = CarbonReader
1:459331c:         .builder(path, "_temp")
1:459331c:         .isTransactionalTable(false)
1:459331c:         .projection(new String[]{"name", "age", "doubleField"})
1:459331c:         .filter(orExpression)
1:8f1a029:         .build(conf);
1:459331c: 
1:459331c:     int i = 0;
1:459331c:     while (reader.hasNext()) {
1:459331c:       Object[] row = (Object[]) reader.readNextRow();
1:459331c:       assert (((String) row[0]).contains("robot7"));
1:459331c:       assert (7 == ((int) (row[1]) % 10));
1:459331c:       assert (0.5 == ((double) (row[2]) % 1));
1:459331c:       i++;
1:459331c:     }
1:459331c:     Assert.assertEquals(i, 20);
1:459331c: 
1:459331c:     reader.close();
1:459331c: 
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c:   }
1:459331c: 
1:459331c:   @Test
1:459331c:   public void testReadWithFilterOfNonTransactionalGreaterThan() throws IOException, InterruptedException {
1:459331c:     String path = "./testWriteFiles";
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c: 
1:459331c:     Field[] fields = new Field[3];
1:459331c:     fields[0] = new Field("name", DataTypes.STRING);
1:459331c:     fields[1] = new Field("age", DataTypes.INT);
1:459331c:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:459331c: 
1:459331c:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:459331c: 
1:459331c:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:459331c:     GreaterThanExpression greaterThanExpression = new GreaterThanExpression(columnExpression,
1:459331c:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1:459331c: 
1:459331c:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:459331c:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:459331c:         new LiteralExpression("robot7", DataTypes.STRING));
1:459331c: 
1:459331c:     AndExpression andExpression = new AndExpression(greaterThanExpression, equalToExpression2);
1:290ef5a:     CarbonReader reader = CarbonReader
1:a7faef8:         .builder(path, "_temp")
1:290ef5a:         .isTransactionalTable(false)
1:290ef5a:         .projection(new String[]{"name", "age", "doubleField"})
1:290ef5a:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:290ef5a: 
1:290ef5a:     int i = 0;
1:290ef5a:     while (reader.hasNext()) {
1:290ef5a:       Object[] row = (Object[]) reader.readNextRow();
1:290ef5a:       assert (((String) row[0]).contains("robot7"));
1:290ef5a:       assert (7 == ((int) (row[1]) % 10));
1:459331c:       assert ((double) row[2] > 13.5);
1:290ef5a:       i++;
1:290ef5a:     }
1:459331c:     Assert.assertEquals(i, 17);
1:459331c: 
1:459331c:     reader.close();
1:459331c: 
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c:   }
1:459331c: 
1:459331c:   @Test
1:459331c:   public void testReadWithFilterOfNonTransactionalLessThan() throws IOException, InterruptedException {
1:459331c:     String path = "./testWriteFiles";
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c: 
1:459331c:     Field[] fields = new Field[3];
1:459331c:     fields[0] = new Field("name", DataTypes.STRING);
1:459331c:     fields[1] = new Field("age", DataTypes.INT);
1:459331c:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:459331c: 
1:459331c:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:459331c: 
1:459331c:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:459331c:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:459331c:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1:459331c: 
1:459331c:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:459331c:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:459331c:         new LiteralExpression("robot7", DataTypes.STRING));
1:459331c: 
1:459331c:     AndExpression andExpression = new AndExpression(lessThanExpression, equalToExpression2);
1:459331c:     CarbonReader reader = CarbonReader
1:459331c:         .builder(path, "_temp")
1:459331c:         .isTransactionalTable(false)
1:459331c:         .projection(new String[]{"name", "age", "doubleField"})
1:459331c:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:459331c: 
1:459331c:     int i = 0;
1:459331c:     while (reader.hasNext()) {
1:459331c:       Object[] row = (Object[]) reader.readNextRow();
1:459331c:       assert (((String) row[0]).contains("robot7"));
1:459331c:       assert (7 == ((int) (row[1]) % 10));
1:459331c:       assert ((double) row[2] < 13.5);
1:459331c:       i++;
1:459331c:     }
1:459331c:     Assert.assertEquals(i, 2);
1:459331c: 
1:459331c:     reader.close();
1:459331c: 
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c:   }
1:459331c: 
1:459331c:   @Test
1:459331c:   public void testReadWithFilterOfNonTransactionalNotEqual() throws IOException, InterruptedException {
1:459331c:     String path = "./testWriteFiles";
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c: 
1:459331c:     Field[] fields = new Field[3];
1:459331c:     fields[0] = new Field("name", DataTypes.STRING);
1:459331c:     fields[1] = new Field("age", DataTypes.INT);
1:459331c:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:459331c: 
1:459331c:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:459331c: 
1:459331c:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:459331c:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:459331c:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1:459331c: 
1:459331c:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:459331c:     NotEqualsExpression notEqualsExpression = new NotEqualsExpression(columnExpression2,
1:459331c:         new LiteralExpression("robot7", DataTypes.STRING));
1:459331c: 
1:459331c:     AndExpression andExpression = new AndExpression(lessThanExpression, notEqualsExpression);
1:459331c:     CarbonReader reader = CarbonReader
1:459331c:         .builder(path, "_temp")
1:459331c:         .isTransactionalTable(false)
1:459331c:         .projection(new String[]{"name", "age", "doubleField"})
1:459331c:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:459331c: 
1:459331c:     int i = 0;
1:459331c:     while (reader.hasNext()) {
1:459331c:       Object[] row = (Object[]) reader.readNextRow();
1:459331c:       assert (!((String) row[0]).contains("robot7"));
1:459331c:       assert (7 != ((int) (row[1]) % 10));
1:459331c:       assert ((double) row[2] < 13.5);
1:459331c:       i++;
1:459331c:     }
1:459331c:     Assert.assertEquals(i, 25);
1:459331c: 
1:459331c:     reader.close();
1:459331c: 
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c:   }
1:459331c: 
1:459331c:   @Test
1:459331c:   public void testReadWithFilterOfNonTransactionalIn() throws IOException, InterruptedException {
1:459331c:     String path = "./testWriteFiles";
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c: 
1:459331c:     Field[] fields = new Field[3];
1:459331c:     fields[0] = new Field("name", DataTypes.STRING);
1:459331c:     fields[1] = new Field("age", DataTypes.INT);
1:459331c:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:459331c: 
1:459331c:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:459331c: 
1:459331c:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:459331c:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:459331c:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1:459331c: 
1:459331c:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:459331c:     InExpression inExpression = new InExpression(columnExpression2,
1:459331c:         new LiteralExpression("robot7", DataTypes.STRING));
1:459331c: 
1:459331c:     AndExpression andExpression = new AndExpression(lessThanExpression, inExpression);
1:459331c:     CarbonReader reader = CarbonReader
1:459331c:         .builder(path, "_temp")
1:459331c:         .isTransactionalTable(false)
1:459331c:         .projection(new String[]{"name", "age", "doubleField"})
1:459331c:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:459331c: 
1:459331c:     int i = 0;
1:459331c:     while (reader.hasNext()) {
1:459331c:       Object[] row = (Object[]) reader.readNextRow();
1:459331c:       assert (((String) row[0]).contains("robot7"));
1:459331c:       assert (7 == ((int) (row[1]) % 10));
1:459331c:       assert ((double) row[2] < 13.5);
1:459331c:       i++;
1:459331c:     }
1:459331c:     Assert.assertEquals(i, 2);
1:459331c: 
1:459331c:     reader.close();
1:459331c: 
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c:   }
1:459331c: 
1:459331c:   @Test
1:459331c:   public void testReadWithFilterOfNonTransactionalNotIn() throws IOException, InterruptedException {
1:459331c:     String path = "./testWriteFiles";
1:459331c:     FileUtils.deleteDirectory(new File(path));
1:459331c: 
1:459331c:     Field[] fields = new Field[3];
1:459331c:     fields[0] = new Field("name", DataTypes.STRING);
1:459331c:     fields[1] = new Field("age", DataTypes.INT);
1:459331c:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1:459331c: 
1:459331c:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1:459331c: 
1:459331c:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:459331c:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:459331c:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1:459331c: 
1:459331c:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:459331c:     NotInExpression notInExpression = new NotInExpression(columnExpression2,
1:459331c:         new LiteralExpression("robot7", DataTypes.STRING));
1:459331c: 
1:459331c:     AndExpression andExpression = new AndExpression(lessThanExpression, notInExpression);
1:459331c:     CarbonReader reader = CarbonReader
1:459331c:         .builder(path, "_temp")
1:459331c:         .isTransactionalTable(false)
1:459331c:         .projection(new String[]{"name", "age", "doubleField"})
1:459331c:         .filter(andExpression)
1:8f1a029:         .build(conf);
1:459331c: 
1:459331c:     int i = 0;
1:459331c:     while (reader.hasNext()) {
1:459331c:       Object[] row = (Object[]) reader.readNextRow();
1:459331c:       assert (!((String) row[0]).contains("robot7"));
1:459331c:       assert (7 != ((int) (row[1]) % 10));
1:459331c:       assert ((double) row[2] < 13.5);
1:459331c:       i++;
1:459331c:     }
1:459331c:     Assert.assertEquals(i, 25);
1:290ef5a: 
1:290ef5a:     reader.close();
1:290ef5a: 
1:290ef5a:     FileUtils.deleteDirectory(new File(path));
1:290ef5a:   }
1:a7ac656: 
1:290ef5a:   @Test
1:9b88a06:   public void testWriteAndReadFilesWithReaderBuildFail() throws IOException, InterruptedException {
1:9b88a06:     String path1 = "./testWriteFiles";
1:9b88a06:     String path2 = "./testWriteFiles2";
1:9b88a06:     FileUtils.deleteDirectory(new File(path1));
1:9b88a06:     FileUtils.deleteDirectory(new File(path2));
1:a7ac656: 
1:9b88a06:     Field[] fields = new Field[] { new Field("c1", "string"),
1:9b88a06:          new Field("c2", "int") };
1:9b88a06:     Schema schema = new Schema(fields);
1:9b88a06:     CarbonWriterBuilder builder = CarbonWriter.builder();
1:9b88a06: 
1:9b88a06:     CarbonWriter carbonWriter = null;
1:a7faef8:     try {
1:9b88a06:       carbonWriter = builder.outputPath(path1).isTransactionalTable(false).uniqueIdentifier(12345)
1:8f1a029:   .buildWriterForCSVInput(schema, TestUtil.configuration);
1:9b88a06:     } catch (InvalidLoadOptionException e) {
1:9b88a06:       e.printStackTrace();
1:9b88a06:     }
1:9b88a06:     carbonWriter.write(new String[] { "MNO", "100" });
1:9b88a06:     carbonWriter.close();
1:9b88a06: 
1:9b88a06:     Field[] fields1 = new Field[] { new Field("p1", "string"),
1:9b88a06:          new Field("p2", "int") };
1:9b88a06:     Schema schema1 = new Schema(fields1);
1:9b88a06:     CarbonWriterBuilder builder1 = CarbonWriter.builder();
1:9b88a06: 
1:9b88a06:     CarbonWriter carbonWriter1 = null;
1:a7ac656:     try {
1:9b88a06:       carbonWriter1 = builder1.outputPath(path2).isTransactionalTable(false).uniqueIdentifier(12345)
1:8f1a029:    .buildWriterForCSVInput(schema1, TestUtil.configuration);
1:9b88a06:     } catch (InvalidLoadOptionException e) {
1:9b88a06:       e.printStackTrace();
1:9b88a06:     }
1:9b88a06:     carbonWriter1.write(new String[] { "PQR", "200" });
1:9b88a06:     carbonWriter1.close();
1:9b88a06: 
1:9b88a06:     try {
1:9b88a06:        CarbonReader reader =
1:9b88a06:        CarbonReader.builder(path1, "_temp").
1:9b88a06:        projection(new String[] { "c1", "c3" })
1:8f1a029:        .isTransactionalTable(false).build(conf);
1:9b88a06:     } catch (Exception e){
1:9b88a06:        System.out.println("Success");
1:9b88a06:     }
1:9b88a06:     CarbonReader reader1 =
1:9b88a06:          CarbonReader.builder(path2, "_temp1")
1:9b88a06:      .projection(new String[] { "p1", "p2" })
1:8f1a029:      .isTransactionalTable(false).build(conf);
1:9b88a06: 
1:9b88a06:     while (reader1.hasNext()) {
1:9b88a06:        Object[] row1 = (Object[]) reader1.readNextRow();
1:9b88a06:        System.out.println(row1[0]);
1:9b88a06:        System.out.println(row1[1]);
1:9b88a06:     }
1:9b88a06:     reader1.close();
1:9b88a06: 
1:9b88a06:     FileUtils.deleteDirectory(new File(path1));
1:9b88a06:     FileUtils.deleteDirectory(new File(path2));
1:9b88a06:   }
1:9b88a06: 
1:9b88a06:   @Test
1:a7faef8:   public void testReadColumnTwice() throws IOException, InterruptedException {
1:a7faef8:     String path = "./testWriteFiles";
1:a7faef8:     FileUtils.deleteDirectory(new File(path));
1:a7faef8: 
1:a7faef8:     Field[] fields = new Field[2];
1:a7faef8:     fields[0] = new Field("name", DataTypes.STRING);
1:a7faef8:     fields[1] = new Field("age", DataTypes.INT);
1:a7faef8: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:a7faef8: 
1:a7faef8:     CarbonReader reader = CarbonReader
1:a7faef8:         .builder(path, "_temp")
1:a7faef8:         .projection(new String[]{"name", "name", "age", "name"})
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:a7faef8: 
1:a7faef8:     // expected output after sorting
1:a7faef8:     String[] name = new String[100];
1:a7faef8:     int[] age = new int[100];
1:a7faef8:     for (int i = 0; i < 100; i++) {
1:a7faef8:       name[i] = "robot" + (i / 10);
1:a7faef8:       age[i] = (i % 10) * 10 + i / 10;
1:a7faef8:     }
1:a7faef8: 
1:a7faef8:     int i = 0;
1:a7faef8:     while (reader.hasNext()) {
1:a7faef8:       Object[] row = (Object[]) reader.readNextRow();
1:a7faef8:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:a7faef8:       Assert.assertEquals(name[i], row[0]);
1:a7faef8:       Assert.assertEquals(name[i], row[1]);
1:a7faef8:       Assert.assertEquals(age[i], row[2]);
1:a7faef8:       Assert.assertEquals(name[i], row[3]);
1:a7faef8:       i++;
1:a7faef8:     }
1:a7faef8:     Assert.assertEquals(i, 100);
1:70fe514: 
1:a7faef8:     reader.close();
1:a7faef8: 
1:a7faef8:     FileUtils.deleteDirectory(new File(path));
1:a7faef8:   }
1:a7faef8: 
1:70fe514:   @Test
1:a7ac656:   public void testReadFilesParallel() throws IOException, InterruptedException {
1:a7ac656:     String path = "./testWriteFiles";
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7faef8: 
1:a7ac656:     Field[] fields = new Field[2];
1:a7ac656:     fields[0] = new Field("name", DataTypes.STRING);
1:a7ac656:     fields[1] = new Field("age", DataTypes.INT);
1:a7ac656: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:a7ac656: 
1:a7faef8:     CarbonReader reader = CarbonReader
1:8896a63:         .builder(path, "_temp")
1:a7ac656:         .projection(new String[]{"name", "age"})
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:a7ac656:     // Reader 2
1:a7ac656:     CarbonReader reader2 = CarbonReader
3:a7ac656:         .builder(path, "_temp")
1:a7ac656:         .projection(new String[]{"name", "age"})
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:a7ac656: 
1:a7ac656:     while (reader.hasNext()) {
1:a7ac656:       Object[] row = (Object[]) reader.readNextRow();
1:a7ac656:       Object[] row2 = (Object[]) reader2.readNextRow();
1:a7ac656:       // parallel compare
1:a7ac656:       Assert.assertEquals(row[0], row2[0]);
1:a7ac656:       Assert.assertEquals(row[1], row2[1]);
1:a7ac656:     }
1:a7ac656: 
1:a7ac656:     reader.close();
1:a7ac656:     reader2.close();
1:a7ac656: 
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7ac656:   }
1:a7ac656: 
1:a7faef8:   @Test
1:a7ac656:   public void testReadAfterClose() throws IOException, InterruptedException {
1:a7ac656:     String path = "./testWriteFiles";
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7ac656: 
1:a7ac656:     Field[] fields = new Field[2];
1:a7ac656:     fields[0] = new Field("name", DataTypes.STRING);
1:a7ac656:     fields[1] = new Field("age", DataTypes.INT);
1:a7ac656: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:a7ac656: 
1:74770aa:     CarbonReader reader = CarbonReader.builder(path, "_temp").isTransactionalTable(true)
1:8f1a029:         .projection(new String[]{"name", "age"}).build(conf);
1:a7ac656: 
1:a7ac656:     reader.close();
1:a7ac656:     String msg = "CarbonReader not initialise, please create it first.";
1:a7ac656:     try {
1:a7ac656:       reader.hasNext();
1:a7ac656:       assert (false);
1:a7ac656:     } catch (RuntimeException e) {
1:a7ac656:       assert (e.getMessage().equals(msg));
1:a7ac656:     }
1:a7ac656: 
1:a7ac656:     try {
1:a7ac656:       reader.readNextRow();
1:a7ac656:       assert (false);
1:a7ac656:     } catch (RuntimeException e) {
1:a7ac656:       assert (e.getMessage().equals(msg));
1:4b8dc0a:     }
1:9b88a06: 
1:9b88a06:     try {
1:f7c0670:       reader.close();
1:a7ac656:       assert (false);
1:a7ac656:     } catch (RuntimeException e) {
1:a7ac656:       assert (e.getMessage().equals(msg));
1:f910cfa:     }
1:f910cfa: 
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:f910cfa:   }
1:f910cfa: 
1:4b8dc0a:   @Test
1:5b2b913:   public void testWriteAndReadFilesWithoutTableName() throws IOException, InterruptedException {
1:5b2b913:     String path = "./testWriteFiles";
1:5b2b913:     FileUtils.deleteDirectory(new File(path));
1:5b2b913: 
1:5b2b913:     Field[] fields = new Field[2];
1:5b2b913:     fields[0] = new Field("name", DataTypes.STRING);
1:5b2b913:     fields[1] = new Field("age", DataTypes.INT);
1:5b2b913: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:5b2b913: 
1:5b2b913:     CarbonReader reader = CarbonReader
1:5b2b913:         .builder(path)
1:5b2b913:         .projection(new String[]{"name", "age"})
1:5b2b913:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:5b2b913: 
1:5b2b913:     // expected output after sorting
1:5b2b913:     String[] name = new String[100];
1:5b2b913:     int[] age = new int[100];
1:5b2b913:     for (int i = 0; i < 100; i++) {
1:5b2b913:       name[i] = "robot" + (i / 10);
1:5b2b913:       age[i] = (i % 10) * 10 + i / 10;
1:5b2b913:     }
1:5b2b913: 
1:5b2b913:     int i = 0;
1:5b2b913:     while (reader.hasNext()) {
1:5b2b913:       Object[] row = (Object[]) reader.readNextRow();
1:5b2b913:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:5b2b913:       Assert.assertEquals(name[i], row[0]);
1:5b2b913:       Assert.assertEquals(age[i], row[1]);
1:5b2b913:       i++;
1:5b2b913:     }
1:5b2b913:     Assert.assertEquals(i, 100);
1:5b2b913: 
1:5b2b913:     reader.close();
1:5b2b913:     FileUtils.deleteDirectory(new File(path));
1:5b2b913:   }
1:5b2b913: 
1:5b2b913:   @Test
1:5b2b913:   public void testWriteAndReadFilesWithoutTableName2() throws IOException, InterruptedException {
1:5b2b913:     String path = "./testWriteFiles";
1:5b2b913:     FileUtils.deleteDirectory(new File(path));
1:5b2b913: 
1:5b2b913:     Field[] fields = new Field[2];
1:5b2b913:     fields[0] = new Field("name", DataTypes.STRING);
1:5b2b913:     fields[1] = new Field("age", DataTypes.INT);
1:5b2b913: 
1:5b2b913:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true,false);
1:5b2b913: 
1:5b2b913:     CarbonReader reader = CarbonReader
1:5b2b913:         .builder(path)
1:8f1a029:         .build(conf);
1:5b2b913: 
1:5b2b913:     // expected output after sorting
1:5b2b913:     String[] name = new String[100];
1:5b2b913:     int[] age = new int[100];
1:5b2b913:     for (int i = 0; i < 100; i++) {
1:5b2b913:       name[i] = "robot" + (i / 10);
1:5b2b913:       age[i] = (i % 10) * 10 + i / 10;
1:5b2b913:     }
1:5b2b913: 
1:5b2b913:     int i = 0;
1:5b2b913:     while (reader.hasNext()) {
1:5b2b913:       Object[] row = (Object[]) reader.readNextRow();
1:5b2b913:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:5b2b913:       Assert.assertEquals(name[i], row[0]);
1:5b2b913:       Assert.assertEquals(age[i], row[1]);
1:5b2b913:       i++;
1:5b2b913:     }
1:5b2b913:     Assert.assertEquals(i, 100);
1:5b2b913: 
1:5b2b913:     reader.close();
1:5b2b913:     FileUtils.deleteDirectory(new File(path));
1:5b2b913:   }
1:5b2b913: 
1:5b2b913:   @Test
1:f910cfa:   public void testReadSchemaFromDataFile() throws IOException {
1:8b80b12:     String path = "./testWriteFiles";
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:8b80b12: 
1:f910cfa:     Field[] fields = new Field[2];
1:f910cfa:     fields[0] = new Field("name", DataTypes.STRING);
1:8b80b12:     fields[1] = new Field("age", DataTypes.INT);
1:8b80b12: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:8b80b12: 
1:f910cfa:     File[] dataFiles = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:f910cfa:       @Override public boolean accept(File dir, String name) {
1:f910cfa:         return name.endsWith("carbondata");
1:4b8dc0a:       }
1:f910cfa:     });
1:f910cfa:     Assert.assertTrue(dataFiles != null);
1:f910cfa:     Assert.assertTrue(dataFiles.length > 0);
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInDataFile(dataFiles[0].getAbsolutePath());
1:e740182:     Assert.assertTrue(schema.getFields().length == 2);
1:e740182:     Assert.assertEquals("name", (schema.getFields())[0].getFieldName());
1:e740182:     Assert.assertEquals("age", (schema.getFields())[1].getFieldName());
1:e740182:     Assert.assertEquals(DataTypes.STRING, (schema.getFields())[0].getDataType());
1:e740182:     Assert.assertEquals(DataTypes.INT, (schema.getFields())[1].getDataType());
1:f910cfa: 
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:f910cfa:   }
1:f910cfa: 
1:8b80b12:   @Test
1:f910cfa:   public void testReadSchemaFromSchemaFile() throws IOException {
1:f910cfa:     String path = "./testWriteFiles";
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:f910cfa: 
1:f910cfa:     Field[] fields = new Field[2];
1:f910cfa:     fields[0] = new Field("name", DataTypes.STRING);
1:f910cfa:     fields[1] = new Field("age", DataTypes.INT);
1:f910cfa: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:f910cfa: 
1:f910cfa:     File[] dataFiles = new File(path + "/Metadata").listFiles(new FilenameFilter() {
1:f910cfa:       @Override public boolean accept(File dir, String name) {
1:f910cfa:         return name.endsWith("schema");
1:f910cfa:       }
1:f910cfa:     });
1:f910cfa:     Assert.assertTrue(dataFiles != null);
1:f910cfa:     Assert.assertTrue(dataFiles.length > 0);
1:f910cfa: 
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInSchemaFile(dataFiles[0].getAbsolutePath());
1:e740182: 
1:e740182:     // sort the schema
1:e740182:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:e740182:       @Override
1:e740182:       public int compare(Field o1, Field o2) {
1:e740182:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:e740182:       }
1:e740182:     });
1:e740182: 
1:e740182:     // Transform the schema
1:e740182:     String[] strings = new String[schema.getFields().length];
1:e740182:     for (int i = 0; i < schema.getFields().length; i++) {
1:e740182:       strings[i] = (schema.getFields())[i].getFieldName();
1:e740182:     }
1:e740182: 
1:e740182:     Assert.assertEquals(2, schema.getFields().length);
1:e740182: 
1:e740182:     Assert.assertEquals("name", (schema.getFields())[0].getFieldName());
1:e740182:     Assert.assertEquals("age", (schema.getFields())[1].getFieldName());
1:e740182:     Assert.assertEquals(DataTypes.STRING, (schema.getFields())[0].getDataType());
1:e740182:     Assert.assertEquals(DataTypes.INT, (schema.getFields())[1].getDataType());
1:a7ac656: 
1:f910cfa:     FileUtils.deleteDirectory(new File(path));
1:a7ac656:   }
1:f910cfa: 
1:a7ac656:   @Test
1:4b8dc0a:   public void testWriteAndReadFilesNonTransactional() throws IOException, InterruptedException {
1:4b8dc0a:     String path = "./testWriteFiles";
1:4b8dc0a:     FileUtils.deleteDirectory(new File(path));
1:4b8dc0a: 
1:4b8dc0a:     Field[] fields = new Field[2];
1:4b8dc0a:     fields[0] = new Field("name", DataTypes.STRING);
1:4b8dc0a:     fields[1] = new Field("age", DataTypes.INT);
1:4b8dc0a: 
1:4b8dc0a:     // Write to a Non Transactional Table
1:4b8dc0a:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true, false);
1:4b8dc0a: 
1:a7ac656:     CarbonReader reader = CarbonReader.builder(path, "_temp")
1:4b8dc0a:         .projection(new String[]{"name", "age"})
1:8f1a029:         .build(conf);
1:a7ac656: 
1:8b80b12:     // expected output after sorting
1:8b80b12:     String[] name = new String[100];
1:8b80b12:     int[] age = new int[100];
1:8b80b12:     for (int i = 0; i < 100; i++) {
1:8b80b12:       name[i] = "robot" + (i / 10);
1:8b80b12:       age[i] = (i % 10) * 10 + i / 10;
1:a7ac656:     }
1:a7ac656: 
1:4b8dc0a:     int i = 0;
1:a7ac656:     while (reader.hasNext()) {
1:a7ac656:       Object[] row = (Object[]) reader.readNextRow();
1:8b80b12:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:8b80b12:       Assert.assertEquals(name[i], row[0]);
1:8b80b12:       Assert.assertEquals(age[i], row[1]);
1:4b8dc0a:       i++;
1:a7ac656:     }
1:a7ac656:     Assert.assertEquals(i, 100);
1:a7ac656:     reader.close();
1:4b8dc0a:     FileUtils.deleteDirectory(new File(path));
1:5f32647:   }
1:5f32647: 
1:a7ac656:   CarbonProperties carbonProperties;
1:a7ac656: 
1:a7ac656:   @Override
1:a7ac656:   public void setUp() {
1:a7ac656:     carbonProperties = CarbonProperties.getInstance();
1:bea277f:     String path = null;
1:bea277f:     try {
1:bea277f:       path = new File(CarbonReaderTest.class.getResource("/").getPath() + "../")
1:bea277f:           .getCanonicalPath().replaceAll("\\\\", "/");
1:bea277f:     } catch (IOException e) {
1:bea277f:       assert (false);
1:bea277f:     }
1:bea277f:     CarbonProperties.getInstance()
1:bea277f:         .addProperty(CarbonCommonConstants.CARBON_SYSTEM_FOLDER_LOCATION, path);
1:a7ac656:   }
1:a7ac656: 
1:a7ac656:   private static final LogService LOGGER =
1:a7ac656:       LogServiceFactory.getLogService(CarbonReaderTest.class.getName());
1:a7ac656: 
1:a7ac656:   @Test
1:a7ac656:   public void testTimeStampAndBadRecord() throws IOException, InterruptedException {
1:a7ac656:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:a7ac656:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:a7ac656:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:a7ac656:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:a7ac656:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:a7ac656:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:a7ac656:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:a7ac656:         + "../../").getCanonicalPath();
1:a7ac656:     String storeLocation = rootPath + "/target/";
1:a7ac656:     carbonProperties
1:a7ac656:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:a7ac656:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:a7ac656:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:a7ac656:     String path = "./testWriteFiles";
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7ac656: 
1:a7ac656:     Field[] fields = new Field[9];
1:a7ac656:     fields[0] = new Field("stringField", DataTypes.STRING);
1:a7ac656:     fields[1] = new Field("intField", DataTypes.INT);
1:a7ac656:     fields[2] = new Field("shortField", DataTypes.SHORT);
1:a7ac656:     fields[3] = new Field("longField", DataTypes.LONG);
1:a7ac656:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:a7ac656:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:a7ac656:     fields[6] = new Field("dateField", DataTypes.DATE);
1:a7ac656:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:a7ac656:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1:a7ac656: 
1:a7ac656:     try {
1:a7ac656:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:a7ac656:           .isTransactionalTable(true)
1:a7ac656:           .persistSchemaFile(true)
1:a7ac656:           .outputPath(path);
1:8896a63: 
1:8f1a029:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
1:a7ac656: 
1:a7ac656:       for (int i = 0; i < 100; i++) {
1:a7ac656:         String[] row = new String[]{
1:a7ac656:             "robot" + (i % 10),
1:a7ac656:             String.valueOf(i),
1:a7ac656:             String.valueOf(i),
1:a7ac656:             String.valueOf(Long.MAX_VALUE - i),
1:a7ac656:             String.valueOf((double) i / 2),
1:a7ac656:             String.valueOf(true),
1:a7ac656:             "2018-05-12",
1:a7ac656:             "2018-05-12",
1:a7ac656:             "12.345"
1:a7ac656:         };
1:a7ac656:         writer.write(row);
1:a7ac656:         String[] row2 = new String[]{
1:a7ac656:             "robot" + (i % 10),
1:a7ac656:             String.valueOf(i),
1:a7ac656:             String.valueOf(i),
1:a7ac656:             String.valueOf(Long.MAX_VALUE - i),
1:a7ac656:             String.valueOf((double) i / 2),
1:a7ac656:             String.valueOf(true),
1:a7ac656:             "2019-03-02",
1:a7ac656:             "2019-02-12 03:03:34",
1:a7ac656:             "12.345"
1:a7ac656:         };
1:a7ac656:         writer.write(row2);
1:8896a63:       }
1:a7ac656:       writer.close();
1:a7ac656:     } catch (Exception e) {
1:a7ac656:       e.printStackTrace();
1:a7ac656:       Assert.fail(e.getMessage());
1:a7ac656:     }
1:a7ac656:     LOGGER.audit("Bad record location:" + storeLocation);
1:a7ac656:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:a7ac656:     Assert.assertTrue(segmentFolder.exists());
1:a7ac656: 
1:a7ac656:     File[] dataFiles = segmentFolder.listFiles(new FileFilter() {
1:a7ac656:       @Override
1:a7ac656:       public boolean accept(File pathname) {
1:a7ac656:         return pathname.getName().endsWith(CarbonCommonConstants.FACT_FILE_EXT);
1:a7ac656:       }
1:a7ac656:     });
1:a7ac656:     Assert.assertNotNull(dataFiles);
1:a7ac656:     Assert.assertTrue(dataFiles.length > 0);
1:a7ac656: 
1:a7ac656:     CarbonReader reader = CarbonReader.builder(path, "_temp")
1:74770aa:         .isTransactionalTable(true)
1:a7ac656:         .projection(new String[]{
1:a7ac656:             "stringField"
1:a7ac656:             , "shortField"
1:a7ac656:             , "intField"
1:a7ac656:             , "longField"
1:a7ac656:             , "doubleField"
1:a7ac656:             , "boolField"
1:a7ac656:             , "dateField"
1:a7ac656:             , "timeField"
1:8896a63:             , "decimalField"})
1:8f1a029:         .build(conf);
1:8896a63: 
1:8896a63:     int i = 0;
1:8896a63:     while (reader.hasNext()) {
1:8896a63:       Object[] row = (Object[]) reader.readNextRow();
1:8896a63:       int id = (int) row[2];
1:8896a63:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:8896a63:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:8896a63:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:8896a63:       Assert.assertEquals((double) id / 2, row[4]);
1:8896a63:       Assert.assertEquals(true, (boolean) row[5]);
1:8896a63:       long day = 24L * 3600 * 1000;
1:8896a63:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:8896a63:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:8896a63:       i++;
1:8896a63:     }
1:8896a63:     Assert.assertEquals(i, 100);
1:8896a63: 
1:8896a63:     reader.close();
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         timestampFormat);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         badRecordAction);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         badRecordLoc);
1:8896a63:   }
1:8896a63: 
1:8896a63:   @Test
1:8896a63:   public void testReadSchemaFileAndSort() throws IOException, InterruptedException {
1:8896a63:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:8896a63:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:8896a63:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:8896a63:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:8896a63:         + "../../").getCanonicalPath();
1:8896a63:     String storeLocation = rootPath + "/target/";
1:8896a63:     carbonProperties
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:8896a63:     String path = "./testWriteFiles";
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63: 
1:8896a63:     Field[] fields = new Field[9];
1:8896a63:     fields[0] = new Field("stringField", DataTypes.STRING);
1:8896a63:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:8896a63:     fields[2] = new Field("intField", DataTypes.INT);
1:8896a63:     fields[3] = new Field("longField", DataTypes.LONG);
1:8896a63:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:8896a63:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:8896a63:     fields[6] = new Field("dateField", DataTypes.DATE);
1:8896a63:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:8896a63:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1:8896a63: 
1:8896a63:     try {
1:8896a63:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:8896a63:           .isTransactionalTable(true)
1:8896a63:           .persistSchemaFile(true)
1:8896a63:           .outputPath(path);
1:8896a63: 
1:8f1a029:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
1:8896a63: 
1:8896a63:       for (int i = 0; i < 100; i++) {
1:8896a63:         String[] row2 = new String[]{
1:8896a63:             "robot" + (i % 10),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(Long.MAX_VALUE - i),
1:8896a63:             String.valueOf((double) i / 2),
1:8896a63:             String.valueOf(true),
1:8896a63:             "2019-03-02",
1:8896a63:             "2019-02-12 03:03:34",
1:8896a63:             "12.345"
1:8896a63:         };
1:8896a63:         writer.write(row2);
1:8896a63:       }
1:8896a63:       writer.close();
1:8896a63:     } catch (Exception e) {
1:8896a63:       e.printStackTrace();
1:8896a63:       Assert.fail(e.getMessage());
1:8896a63:     }
1:8896a63: 
1:8896a63:     File[] dataFiles = new File(path + "/Metadata").listFiles(new FilenameFilter() {
1:8896a63:       @Override public boolean accept(File dir, String name) {
1:8896a63:         return name.endsWith("schema");
1:8896a63:       }
1:8896a63:     });
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInSchemaFile(dataFiles[0].getAbsolutePath());
1:8896a63: 
1:8896a63:     // sort the schema
1:e740182:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:8896a63:       @Override
1:e740182:       public int compare(Field o1, Field o2) {
1:8896a63:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:8896a63:       }
1:8896a63:     });
1:8896a63: 
1:8896a63:     // Transform the schema
1:e740182:     String[] strings = new String[schema.getFields().length];
1:e740182:     for (int i = 0; i < schema.getFields().length; i++) {
1:e740182:       strings[i] = (schema.getFields())[i].getFieldName();
1:8896a63:     }
1:8896a63: 
1:8896a63:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:8896a63:     Assert.assertTrue(segmentFolder.exists());
1:8896a63: 
1:8896a63:     Assert.assertNotNull(dataFiles);
1:8896a63:     Assert.assertTrue(dataFiles.length > 0);
1:8896a63: 
1:8896a63:     CarbonReader reader = CarbonReader
1:8896a63:         .builder(path, "_temp")
1:74770aa:         .isTransactionalTable(true)
1:8896a63:         .projection(strings)
1:8f1a029:         .build(conf);
1:8896a63: 
1:8896a63:     int i = 0;
1:8896a63:     while (reader.hasNext()) {
1:8896a63:       Object[] row = (Object[]) reader.readNextRow();
1:8896a63:       int id = (int) row[2];
1:8896a63:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:8896a63:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:8896a63:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:8896a63:       Assert.assertEquals((double) id / 2, row[4]);
1:8896a63:       Assert.assertEquals(true, (boolean) row[5]);
1:8896a63:       long day = 24L * 3600 * 1000;
1:8896a63:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:8896a63:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:8896a63:       i++;
1:8896a63:     }
1:8896a63:     Assert.assertEquals(i, 100);
1:8896a63: 
1:8896a63:     reader.close();
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         timestampFormat);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         badRecordAction);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         badRecordLoc);
1:8896a63:   }
1:8896a63: 
1:8896a63:   @Test
1:8896a63:   public void testReadSchemaInDataFileAndSort() throws IOException, InterruptedException {
1:8896a63:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:8896a63:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:8896a63:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:8896a63:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:8896a63:         + "../../").getCanonicalPath();
1:8896a63:     String storeLocation = rootPath + "/target/";
1:8896a63:     carbonProperties
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:8896a63:     String path = "./testWriteFiles";
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63: 
1:8896a63:     Field[] fields = new Field[9];
1:8896a63:     fields[0] = new Field("stringField", DataTypes.STRING);
1:8896a63:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:8896a63:     fields[2] = new Field("intField", DataTypes.INT);
1:8896a63:     fields[3] = new Field("longField", DataTypes.LONG);
1:8896a63:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:8896a63:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:8896a63:     fields[6] = new Field("dateField", DataTypes.DATE);
1:8896a63:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:8896a63:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1:8896a63: 
1:8896a63:     try {
1:8896a63:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:8896a63:           .isTransactionalTable(true)
1:8896a63:           .persistSchemaFile(true)
1:8896a63:           .outputPath(path);
1:8896a63: 
1:8f1a029:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
1:8896a63: 
1:8896a63:       for (int i = 0; i < 100; i++) {
1:8896a63:         String[] row2 = new String[]{
1:8896a63:             "robot" + (i % 10),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(Long.MAX_VALUE - i),
1:8896a63:             String.valueOf((double) i / 2),
1:8896a63:             String.valueOf(true),
1:8896a63:             "2019-03-02",
1:8896a63:             "2019-02-12 03:03:34",
1:8896a63:             "12.345"
1:8896a63:         };
1:8896a63:         writer.write(row2);
1:8896a63:       }
1:8896a63:       writer.close();
1:8896a63:     } catch (Exception e) {
1:8896a63:       e.printStackTrace();
1:8896a63:       Assert.fail(e.getMessage());
1:8896a63:     }
1:8896a63: 
1:8896a63:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:8896a63:       @Override public boolean accept(File dir, String name) {
1:8896a63:         return name.endsWith("carbondata");
1:8896a63:       }
1:8896a63:     });
1:8896a63: 
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInDataFile(dataFiles2[0].getAbsolutePath());
1:8896a63: 
1:8896a63:     // sort the schema
1:e740182:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:8896a63:       @Override
1:e740182:       public int compare(Field o1, Field o2) {
1:8896a63:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:8896a63:       }
1:8896a63:     });
1:8896a63: 
1:8896a63:     // Transform the schema
1:e740182:     String[] strings = new String[schema.getFields().length];
1:e740182:     for (int i = 0; i < schema.getFields().length; i++) {
1:e740182:       strings[i] = (schema.getFields())[i].getFieldName();
1:8896a63:     }
1:8896a63: 
1:8896a63:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:8896a63:     Assert.assertTrue(segmentFolder.exists());
1:8896a63: 
1:8896a63:     CarbonReader reader = CarbonReader
1:8896a63:         .builder(path, "_temp")
1:8896a63:         .projection(strings)
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:8896a63: 
1:8896a63:     int i = 0;
1:8896a63:     while (reader.hasNext()) {
1:8896a63:       Object[] row = (Object[]) reader.readNextRow();
1:8896a63:       int id = (int) row[2];
1:8896a63:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:8896a63:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:8896a63:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:8896a63:       Assert.assertEquals((double) id / 2, row[4]);
1:8896a63:       Assert.assertEquals(true, (boolean) row[5]);
1:8896a63:       long day = 24L * 3600 * 1000;
1:8896a63:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:8896a63:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:8896a63:       i++;
1:8896a63:     }
1:8896a63:     Assert.assertEquals(i, 100);
1:8896a63: 
1:8896a63:     reader.close();
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         timestampFormat);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         badRecordAction);
1:8896a63:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         badRecordLoc);
1:8896a63:   }
1:8896a63: 
1:8896a63:   @Test
1:8896a63:   public void testReadUserSchema() throws IOException, InterruptedException {
1:8896a63:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:8896a63:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:8896a63:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:8896a63:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:8896a63:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:8896a63:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:8896a63:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:8896a63:         + "../../").getCanonicalPath();
1:8896a63:     String storeLocation = rootPath + "/target/";
1:8896a63:     carbonProperties
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:8896a63:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:8896a63:     String path = "./testWriteFiles";
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63: 
1:8896a63:     Field[] fields = new Field[9];
1:8896a63:     fields[0] = new Field("stringField", DataTypes.STRING);
1:8896a63:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:8896a63:     fields[2] = new Field("intField", DataTypes.INT);
1:8896a63:     fields[3] = new Field("longField", DataTypes.LONG);
1:8896a63:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:8896a63:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:8896a63:     fields[6] = new Field("dateField", DataTypes.DATE);
1:8896a63:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:8896a63:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1:8896a63: 
1:8896a63:     try {
1:8896a63:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:8896a63:           .isTransactionalTable(true)
1:8896a63:           .persistSchemaFile(true)
1:8896a63:           .outputPath(path);
1:8896a63: 
1:8f1a029:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
1:8896a63: 
1:8896a63:       for (int i = 0; i < 100; i++) {
1:8896a63:         String[] row2 = new String[]{
1:8896a63:             "robot" + (i % 10),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(i),
1:8896a63:             String.valueOf(Long.MAX_VALUE - i),
1:8896a63:             String.valueOf((double) i / 2),
1:8896a63:             String.valueOf(true),
1:8896a63:             "2019-03-02",
1:8896a63:             "2019-02-12 03:03:34",
1:8896a63:             "12.345"
1:8896a63:         };
1:8896a63:         writer.write(row2);
1:8896a63:       }
1:8896a63:       writer.close();
1:8896a63:     } catch (Exception e) {
1:8896a63:       e.printStackTrace();
1:8896a63:       Assert.fail(e.getMessage());
1:8b80b12:     }
1:8896a63: 
1:8896a63:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:8896a63:       @Override public boolean accept(File dir, String name) {
1:8896a63:         return name.endsWith("carbonindex");
1:8896a63:       }
1:8896a63:     });
1:8896a63: 
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInIndexFile(dataFiles2[0].getAbsolutePath()).asOriginOrder();
1:8896a63: 
1:8896a63:     // Transform the schema
1:e740182:     String[] strings = new String[schema.getFields().length];
1:e740182:     for (int i = 0; i < schema.getFields().length; i++) {
1:e740182:       strings[i] = (schema.getFields())[i].getFieldName();
1:8896a63:     }
1:8896a63: 
1:8896a63:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:8896a63:     Assert.assertTrue(segmentFolder.exists());
1:8896a63: 
1:8896a63:     CarbonReader reader = CarbonReader
1:8896a63:         .builder(path, "_temp")
1:74770aa:         .isTransactionalTable(true)
1:8896a63:         .projection(strings)
1:8f1a029:         .build(conf);
1:8b80b12: 
1:8b80b12:     int i = 0;
1:8b80b12:     while (reader.hasNext()) {
1:8b80b12:       Object[] row = (Object[]) reader.readNextRow();
1:a7ac656:       int id = (int) row[2];
1:a7ac656:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:a7ac656:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:a7ac656:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:a7ac656:       Assert.assertEquals((double) id / 2, row[4]);
1:a7ac656:       Assert.assertEquals(true, (boolean) row[5]);
1:a7ac656:       long day = 24L * 3600 * 1000;
1:a7ac656:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:a7ac656:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:8b80b12:       i++;
1:8b80b12:     }
1:8b80b12:     Assert.assertEquals(i, 100);
1:8b80b12: 
1:a7ac656:     reader.close();
1:8b80b12:     FileUtils.deleteDirectory(new File(path));
1:a7ac656:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:a7ac656:         timestampFormat);
1:a7ac656:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:a7ac656:         badRecordAction);
1:a7ac656:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:a7ac656:         badRecordLoc);
1:8b80b12:   }
1:8b80b12: 
1:8b80b12:   @Test
1:8b80b12:   public void testReadFilesWithProjectAllColumns() throws IOException, InterruptedException {
1:8b80b12:     String path = "./testWriteFiles";
1:8b80b12:     FileUtils.deleteDirectory(new File(path));
1:8b80b12: 
1:8b80b12:     Field[] fields = new Field[2];
1:8b80b12:     fields[0] = new Field("name", DataTypes.STRING);
1:8b80b12:     fields[1] = new Field("age", DataTypes.INT);
1:8b80b12: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:8b80b12: 
1:8896a63:     CarbonReader reader = CarbonReader
1:8b80b12:         .builder(path, "_temp")
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:8b80b12: 
1:8b80b12:     // expected output after sorting
1:8b80b12:     String[] name = new String[100];
1:8b80b12:     int[] age = new int[100];
1:8b80b12:     for (int i = 0; i < 100; i++) {
1:8b80b12:       name[i] = "robot" + (i / 10);
1:8b80b12:       age[i] = (i % 10) * 10 + i / 10;
1:8b80b12:     }
1:8b80b12: 
1:8b80b12:     int i = 0;
1:8b80b12:     while (reader.hasNext()) {
1:8b80b12:       Object[] row = (Object[]) reader.readNextRow();
1:8b80b12:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:8b80b12:       Assert.assertEquals(name[i], row[0]);
1:8b80b12:       Assert.assertEquals(age[i], row[1]);
1:8b80b12:       i++;
1:8b80b12:     }
1:8b80b12:     Assert.assertEquals(i, 100);
1:8b80b12: 
1:8b80b12:     reader.close();
1:8b80b12:     FileUtils.deleteDirectory(new File(path));
1:8b80b12:   }
1:8b80b12: 
1:8b80b12:   @Test
1:8b80b12:   public void testReadFilesWithDefaultProjection() throws IOException, InterruptedException {
1:8b80b12:     String path = "./testWriteFiles";
1:8b80b12:     FileUtils.deleteDirectory(new File(path));
1:8b80b12: 
1:8b80b12:     Field[] fields = new Field[2];
1:8b80b12:     fields[0] = new Field("name", DataTypes.STRING);
1:8b80b12:     fields[1] = new Field("age", DataTypes.INT);
1:8b80b12: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:8b80b12: 
2:8b80b12:     CarbonReader reader = CarbonReader
1:8b80b12:         .builder(path, "_temp")
1:74770aa:         .isTransactionalTable(true)
1:8f1a029:         .build(conf);
1:8b80b12: 
1:8b80b12:     // expected output after sorting
1:8b80b12:     String[] name = new String[100];
1:8b80b12:     int[] age = new int[100];
1:8b80b12:     for (int i = 0; i < 100; i++) {
1:8b80b12:       name[i] = "robot" + (i / 10);
1:8b80b12:       age[i] = (i % 10) * 10 + i / 10;
1:8b80b12:     }
1:a7ac656: 
1:a7ac656:     int i = 0;
1:8b80b12:     while (reader.hasNext()) {
1:8b80b12:       Object[] row = (Object[]) reader.readNextRow();
1:a7ac656:       Assert.assertEquals(name[i], row[0]);
1:a7ac656:       Assert.assertEquals(age[i], row[1]);
1:a7ac656:       i++;
1:a7ac656:     }
1:cf1b50b:     reader.close();
1:a7ac656:     Assert.assertEquals(i, 100);
1:a7ac656:   }
1:a7ac656: 
1:f910cfa:   @Test
1:8b80b12:   public void testReadFilesWithNullProjection() throws IOException, InterruptedException {
1:f910cfa:     String path = "./testWriteFiles";
1:a7ac656:     FileUtils.deleteDirectory(new File(path));
1:a7ac656: 
1:f910cfa:     Field[] fields = new Field[2];
1:f910cfa:     fields[0] = new Field("name", DataTypes.STRING);
1:f910cfa:     fields[1] = new Field("age", DataTypes.INT);
1:4b8dc0a: 
1:92d9b92:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
1:f910cfa: 
1:9b88a06:     try {
1:8b80b12:       CarbonReader reader = CarbonReader
1:8b80b12:           .builder(path, "_temp")
1:a7faef8:           .projection(new String[]{})
1:74770aa:           .isTransactionalTable(true)
1:8f1a029:           .build(conf);
1:a7faef8:       assert (false);
1:a7faef8:     } catch (RuntimeException e) {
1:a7faef8:       assert (e.getMessage().equalsIgnoreCase("Projection can't be empty"));
1:8b80b12:     }
1:8b80b12:   }
1:8b80b12: 
1:fb6dffe:   private void WriteAvroComplexData(String mySchema, String json, String[] sortColumns, String path,
1:fb6dffe:       boolean isTransactionalTable)
1:8896a63:       throws IOException, InvalidLoadOptionException {
1:f910cfa: 
1:8896a63:     // conversion to GenericData.Record
1:8896a63:     org.apache.avro.Schema nn = new org.apache.avro.Schema.Parser().parse(mySchema);
1:4d3ecfb:     GenericData.Record record = TestUtil.jsonToAvro(json, mySchema);
1:8896a63: 
1:8896a63:     try {
1:8896a63:       CarbonWriter writer = CarbonWriter.builder()
1:8896a63:           .outputPath(path)
1:fb6dffe:           .isTransactionalTable(isTransactionalTable)
1:8f1a029:           .buildWriterForAvroInput(nn, TestUtil.configuration);
1:8896a63: 
1:8896a63:       for (int i = 0; i < 100; i++) {
1:8896a63:         writer.write(record);
1:8896a63:       }
1:8896a63:       writer.close();
1:8896a63:     } catch (Exception e) {
1:8896a63:       e.printStackTrace();
1:8896a63:       throw e;
1:8896a63:     }
1:8896a63:   }
1:8896a63: 
1:8896a63:   // TODO: support get schema of complex data type
1:8896a63:   @Ignore
1:8896a63:   public void testReadUserSchemaOfComplex() throws IOException {
1:8896a63:     String path = "./testWriteFiles";
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63: 
1:8896a63:     String mySchema =
1:8896a63:         "{" +
1:8896a63:             "  \"name\": \"address\", " +
1:8896a63:             "   \"type\": \"record\", " +
1:8896a63:             "    \"fields\": [  " +
1:8896a63:             "  { \"name\": \"name\", \"type\": \"string\"}, " +
1:8896a63:             "  { \"name\": \"age\", \"type\": \"int\"}, " +
1:8896a63:             "  { " +
1:8896a63:             "    \"name\": \"address\", " +
1:8896a63:             "      \"type\": { " +
1:8896a63:             "    \"type\" : \"record\", " +
1:8896a63:             "        \"name\" : \"my_address\", " +
1:8896a63:             "        \"fields\" : [ " +
1:8896a63:             "    {\"name\": \"street\", \"type\": \"string\"}, " +
1:8896a63:             "    {\"name\": \"city\", \"type\": \"string\"} " +
1:8896a63:             "  ]} " +
1:8896a63:             "  }, " +
1:8896a63:             "  {\"name\" :\"doorNum\", " +
1:8896a63:             "   \"type\" : { " +
1:8896a63:             "   \"type\" :\"array\", " +
1:8896a63:             "   \"items\":{ " +
1:8896a63:             "   \"name\" :\"EachdoorNums\", " +
1:8896a63:             "   \"type\" : \"int\", " +
1:8896a63:             "   \"default\":-1} " +
1:8896a63:             "              } " +
1:8896a63:             "  }] " +
1:8896a63:             "}";
1:8896a63: 
1:8896a63:     String json = "{\"name\":\"bob\", \"age\":10, \"address\" : {\"street\":\"abc\", \"city\":\"bang\"}, "
1:8896a63:         + "   \"doorNum\" : [1,2,3,4]}";
1:8896a63: 
1:8896a63:     try {
1:fb6dffe:       WriteAvroComplexData(mySchema, json, null, path, true);
1:8896a63:     } catch (InvalidLoadOptionException e) {
1:8896a63:       e.printStackTrace();
1:8896a63:     }
1:8896a63: 
1:8896a63:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:8896a63:     Assert.assertTrue(segmentFolder.exists());
1:8896a63: 
1:8896a63:     File[] dataFiles = segmentFolder.listFiles(new FileFilter() {
1:8896a63:       @Override
1:8896a63:       public boolean accept(File pathname) {
1:8896a63:         return pathname.getName().endsWith(CarbonCommonConstants.FACT_FILE_EXT);
1:8896a63:       }
1:8896a63:     });
1:8896a63:     Assert.assertNotNull(dataFiles);
1:8896a63:     Assert.assertEquals(1, dataFiles.length);
1:8896a63: 
1:8896a63: 
1:8896a63:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:8896a63:       @Override
1:8896a63:       public boolean accept(File dir, String name) {
1:8896a63:         return name.endsWith("carbonindex");
1:8896a63:       }
1:8896a63:     });
1:8896a63: 
1:e740182:     Schema schema = CarbonSchemaReader.readSchemaInIndexFile(dataFiles2[0].getAbsolutePath()).asOriginOrder();
1:8896a63: 
1:e740182:     for (int i = 0; i < schema.getFields().length; i++) {
1:e740182:       System.out.println((schema.getFields())[i].getFieldName() + "\t" + schema.getFields()[i].getSchemaOrdinal());
1:8896a63:     }
1:8896a63:     FileUtils.deleteDirectory(new File(path));
1:8896a63:   }
1:8896a63: 
1:f910cfa:   @Test
1:fb6dffe:   public void testReadMapType() throws IOException, InterruptedException {
1:fb6dffe:     String path = "./testWriteFiles";
1:fb6dffe:     FileUtils.deleteDirectory(new File(path));
1:fb6dffe: 
1:fb6dffe:     String mySchema =
1:fb6dffe:         "{ "+
1:fb6dffe:             "  \"name\": \"address\", "+
1:fb6dffe:             "  \"type\": \"record\", "+
1:fb6dffe:             "  \"fields\": [ "+
1:fb6dffe:             "    { "+
1:fb6dffe:             "      \"name\": \"name\", "+
1:fb6dffe:             "      \"type\": \"string\" "+
1:fb6dffe:             "    }, "+
1:fb6dffe:             "    { "+
1:fb6dffe:             "      \"name\": \"age\", "+
1:fb6dffe:             "      \"type\": \"int\" "+
1:fb6dffe:             "    }, "+
1:fb6dffe:             "    { "+
1:fb6dffe:             "      \"name\": \"mapRecord\", "+
1:fb6dffe:             "      \"type\": { "+
1:fb6dffe:             "        \"type\": \"map\", "+
1:fb6dffe:             "        \"values\": \"string\" "+
1:fb6dffe:             "      } "+
1:fb6dffe:             "    } "+
1:fb6dffe:             "  ] "+
1:fb6dffe:             "} ";
1:fb6dffe: 
1:fb6dffe:     String json =
1:fb6dffe:         "{\"name\":\"bob\", \"age\":10, \"mapRecord\": {\"street\": \"k-lane\", \"city\": \"bangalore\"}}";
1:fb6dffe: 
1:fb6dffe:     try {
1:fb6dffe:       WriteAvroComplexData(mySchema, json, null, path, false);
1:fb6dffe:     } catch (InvalidLoadOptionException e) {
1:fb6dffe:       e.printStackTrace();
1:fb6dffe:     }
1:fb6dffe: 
1:fb6dffe:     Field[] fields = new Field[3];
1:fb6dffe:     fields[0] = new Field("name", DataTypes.STRING);
1:fb6dffe:     fields[1] = new Field("age", DataTypes.INT);
1:fb6dffe:     fields[2] = new Field("mapRecord", DataTypes.createMapType(DataTypes.STRING, DataTypes.STRING));
1:fb6dffe: 
1:fb6dffe:     CarbonReader reader = CarbonReader
1:fb6dffe:         .builder(path, "_temp")
1:fb6dffe:         .isTransactionalTable(false)
1:8f1a029:         .build(conf);
1:fb6dffe: 
1:fb6dffe:     // expected output
1:fb6dffe:     String name = "bob";
1:fb6dffe:     int age = 10;
1:fb6dffe:     Object[] mapKeValue = new Object[2];
1:fb6dffe:     mapKeValue[0] = new Object[] { "city", "street" };
1:fb6dffe:     mapKeValue[1] = new Object[] { "bangalore", "k-lane" };
1:fb6dffe:     int i = 0;
1:fb6dffe:     while (reader.hasNext()) {
1:fb6dffe:       Object[] row = (Object[]) reader.readNextRow();
1:fb6dffe:       Assert.assertEquals(name, row[0]);
1:fb6dffe:       Assert.assertArrayEquals(mapKeValue, (Object[]) row[1]);
1:fb6dffe:       Assert.assertEquals(age, row[2]);
1:fb6dffe:       i++;
1:fb6dffe:     }
1:fb6dffe:     reader.close();
1:fb6dffe:     Assert.assertEquals(i, 100);
1:fb6dffe:   }
1:fb6dffe: 
1:f910cfa:   @Test
1:70fe514:   public void testReadWithFilterOfnonTransactionalwithsubfolders() throws IOException, InterruptedException {
1:70fe514:     String path1 = "./testWriteFiles/1/"+System.nanoTime();
1:70fe514:     String path2 = "./testWriteFiles/2/"+System.nanoTime();
1:70fe514:     String path3 = "./testWriteFiles/3/"+System.nanoTime();
1:70fe514:     FileUtils.deleteDirectory(new File("./testWriteFiles"));
1:70fe514: 
1:70fe514:     Field[] fields = new Field[2];
1:70fe514:     fields[0] = new Field("name", DataTypes.STRING);
1:70fe514:     fields[1] = new Field("age", DataTypes.INT);
1:70fe514: 
1:70fe514:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path1, false, false);
1:70fe514:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path2, false, false);
1:70fe514:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path3, false, false);
1:70fe514: 
1:70fe514:     EqualToExpression equalToExpression = new EqualToExpression(
1:70fe514:         new ColumnExpression("name", DataTypes.STRING),
1:70fe514:         new LiteralExpression("robot1", DataTypes.STRING));
1:70fe514:     CarbonReader reader = CarbonReader
1:70fe514:         .builder("./testWriteFiles", "_temp")
1:70fe514:         .isTransactionalTable(false)
1:70fe514:         .projection(new String[]{"name", "age"})
1:70fe514:         .filter(equalToExpression)
1:8f1a029:         .build(conf);
1:70fe514: 
1:70fe514:     int i = 0;
1:70fe514:     while (reader.hasNext()) {
1:70fe514:       Object[] row = (Object[]) reader.readNextRow();
1:70fe514:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:70fe514:       assert ("robot1".equals(row[0]));
1:70fe514:       i++;
1:70fe514:     }
1:70fe514:     Assert.assertEquals(i, 60);
1:70fe514: 
1:70fe514:     reader.close();
1:70fe514: 
1:70fe514:     FileUtils.deleteDirectory(new File("./testWriteFiles"));
1:70fe514:   }
1:70fe514: 
1:f910cfa: 
1:4b8dc0a: }
============================================================================
author:kunal642
-------------------------------------------------------------------------------
commit:8f1a029
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.conf.Configuration;
1:   private Configuration conf = new Configuration(false);
1:   
/////////////////////////////////////////////////////////////////////////
1:         .projection(new String[]{"name", "age"}).build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:   .buildWriterForCSVInput(schema, TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:    .buildWriterForCSVInput(schema1, TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:        .isTransactionalTable(false).build(conf);
1:      .isTransactionalTable(false).build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .projection(new String[]{"name", "age"}).build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields), TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:           .build(conf);
/////////////////////////////////////////////////////////////////////////
1:           .buildWriterForAvroInput(nn, TestUtil.configuration);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
/////////////////////////////////////////////////////////////////////////
1:         .build(conf);
author:ravipesala
-------------------------------------------------------------------------------
commit:70fe514
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testReadWithFilterOfnonTransactionalwithsubfolders() throws IOException, InterruptedException {
1:     String path1 = "./testWriteFiles/1/"+System.nanoTime();
1:     String path2 = "./testWriteFiles/2/"+System.nanoTime();
1:     String path3 = "./testWriteFiles/3/"+System.nanoTime();
1:     FileUtils.deleteDirectory(new File("./testWriteFiles"));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path1, false, false);
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path2, false, false);
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path3, false, false);
1: 
1:     EqualToExpression equalToExpression = new EqualToExpression(
1:         new ColumnExpression("name", DataTypes.STRING),
1:         new LiteralExpression("robot1", DataTypes.STRING));
1:     CarbonReader reader = CarbonReader
1:         .builder("./testWriteFiles", "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age"})
1:         .filter(equalToExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       assert ("robot1".equals(row[0]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 60);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File("./testWriteFiles"));
1:   }
1: 
1: 
author:manishgupta88
-------------------------------------------------------------------------------
commit:fb6dffe
/////////////////////////////////////////////////////////////////////////
1:   private void WriteAvroComplexData(String mySchema, String json, String[] sortColumns, String path,
1:       boolean isTransactionalTable)
/////////////////////////////////////////////////////////////////////////
1:           .isTransactionalTable(isTransactionalTable)
/////////////////////////////////////////////////////////////////////////
1:       WriteAvroComplexData(mySchema, json, null, path, true);
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testReadMapType() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     String mySchema =
1:         "{ "+
1:             "  \"name\": \"address\", "+
1:             "  \"type\": \"record\", "+
1:             "  \"fields\": [ "+
1:             "    { "+
1:             "      \"name\": \"name\", "+
1:             "      \"type\": \"string\" "+
1:             "    }, "+
1:             "    { "+
1:             "      \"name\": \"age\", "+
1:             "      \"type\": \"int\" "+
1:             "    }, "+
1:             "    { "+
1:             "      \"name\": \"mapRecord\", "+
1:             "      \"type\": { "+
1:             "        \"type\": \"map\", "+
1:             "        \"values\": \"string\" "+
1:             "      } "+
1:             "    } "+
1:             "  ] "+
1:             "} ";
1: 
1:     String json =
1:         "{\"name\":\"bob\", \"age\":10, \"mapRecord\": {\"street\": \"k-lane\", \"city\": \"bangalore\"}}";
1: 
1:     try {
1:       WriteAvroComplexData(mySchema, json, null, path, false);
1:     } catch (InvalidLoadOptionException e) {
1:       e.printStackTrace();
1:     }
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("mapRecord", DataTypes.createMapType(DataTypes.STRING, DataTypes.STRING));
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
0:         .build();
1: 
1:     // expected output
1:     String name = "bob";
1:     int age = 10;
1:     Object[] mapKeValue = new Object[2];
1:     mapKeValue[0] = new Object[] { "city", "street" };
1:     mapKeValue[1] = new Object[] { "bangalore", "k-lane" };
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       Assert.assertEquals(name, row[0]);
1:       Assert.assertArrayEquals(mapKeValue, (Object[]) row[1]);
1:       Assert.assertEquals(age, row[2]);
1:       i++;
1:     }
1:     reader.close();
1:     Assert.assertEquals(i, 100);
1:   }
1: 
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:bea277f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.schema.table.DiskBasedDMSchemaStorageProvider;
/////////////////////////////////////////////////////////////////////////
1:     String path = null;
1:     try {
1:       path = new File(CarbonReaderTest.class.getResource("/").getPath() + "../")
1:           .getCanonicalPath().replaceAll("\\\\", "/");
1:     } catch (IOException e) {
1:       assert (false);
1:     }
1:     CarbonProperties.getInstance()
1:         .addProperty(CarbonCommonConstants.CARBON_SYSTEM_FOLDER_LOCATION, path);
author:xubo245
-------------------------------------------------------------------------------
commit:459331c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.expression.conditional.*;
/////////////////////////////////////////////////////////////////////////
1:     OrExpression orExpression = new OrExpression(equalToExpression, equalToExpression2);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(orExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == ((int) (row[1]) % 10));
1:       assert (0.5 == ((double) (row[2]) % 1));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 20);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalGreaterThan() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     GreaterThanExpression greaterThanExpression = new GreaterThanExpression(columnExpression,
1:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(greaterThanExpression, equalToExpression2);
/////////////////////////////////////////////////////////////////////////
1:       assert ((double) row[2] > 13.5);
1:     Assert.assertEquals(i, 17);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalLessThan() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(lessThanExpression, equalToExpression2);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == ((int) (row[1]) % 10));
1:       assert ((double) row[2] < 13.5);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 2);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalNotEqual() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     NotEqualsExpression notEqualsExpression = new NotEqualsExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(lessThanExpression, notEqualsExpression);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (!((String) row[0]).contains("robot7"));
1:       assert (7 != ((int) (row[1]) % 10));
1:       assert ((double) row[2] < 13.5);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 25);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalIn() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     InExpression inExpression = new InExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(lessThanExpression, inExpression);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == ((int) (row[1]) % 10));
1:       assert ((double) row[2] < 13.5);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 2);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalNotIn() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     LessThanExpression lessThanExpression = new LessThanExpression(columnExpression,
1:         new LiteralExpression("13.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     NotInExpression notInExpression = new NotInExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(lessThanExpression, notInExpression);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (!((String) row[0]).contains("robot7"));
1:       assert (7 != ((int) (row[1]) % 10));
1:       assert ((double) row[2] < 13.5);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 25);
commit:290ef5a
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1: import org.apache.carbondata.core.scan.expression.LiteralExpression;
0: import org.apache.carbondata.core.scan.expression.conditional.EqualToExpression;
1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
/////////////////////////////////////////////////////////////////////////
1:     String path = "./testWriteFiles";
1:     try {
1:       FileUtils.deleteDirectory(new File(path));
1:     } catch (IOException e) {
1:       e.printStackTrace();
1:     }
/////////////////////////////////////////////////////////////////////////
1:   public void testReadWithFilterOfTransactional() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1: 
1:     EqualToExpression equalToExpression = new EqualToExpression(
1:         new ColumnExpression("name", DataTypes.STRING),
1:         new LiteralExpression("robot1", DataTypes.STRING));
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(true)
1:         .projection(new String[]{"name", "age"})
1:         .filter(equalToExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       assert ("robot1".equals(row[0]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 20);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfTransactionalAnd() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(equalToExpression, equalToExpression2);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(true)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == (int) (row[1]));
1:       assert (3.5 == (double) (row[2]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 1);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalSimple() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:         new LiteralExpression("robot1", DataTypes.STRING));
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age"})
1:         .filter(equalToExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       assert ("robot1".equals(row[0]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 20);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactional2() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("age", DataTypes.INT);
1: 
1:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:         new LiteralExpression("1", DataTypes.INT));
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age"})
1:         .filter(equalToExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       assert (((String) row[0]).contains("robot"));
1:       assert (1 == (int) (row[1]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 1);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalAnd() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
1:     AndExpression andExpression = new AndExpression(equalToExpression, equalToExpression2);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == (int) (row[1]));
1:       assert (3.5 == (double) (row[2]));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 1);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadWithFilterOfNonTransactionalOr() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[3];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1:     fields[2] = new Field("doubleField", DataTypes.DOUBLE);
1: 
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, false, false);
1: 
1:     ColumnExpression columnExpression = new ColumnExpression("doubleField", DataTypes.DOUBLE);
1:     EqualToExpression equalToExpression = new EqualToExpression(columnExpression,
1:         new LiteralExpression("3.5", DataTypes.DOUBLE));
1: 
1:     ColumnExpression columnExpression2 = new ColumnExpression("name", DataTypes.STRING);
1:     EqualToExpression equalToExpression2 = new EqualToExpression(columnExpression2,
1:         new LiteralExpression("robot7", DataTypes.STRING));
1: 
0:     OrExpression andExpression = new OrExpression(equalToExpression, equalToExpression2);
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .isTransactionalTable(false)
1:         .projection(new String[]{"name", "age", "doubleField"})
1:         .filter(andExpression)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       assert (((String) row[0]).contains("robot7"));
1:       assert (7 == ((int) (row[1]) % 10));
0:       assert (0.5 == ((double) (row[2]) % 1));
1:       i++;
1:     }
1:     Assert.assertEquals(i, 20);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
commit:5b2b913
/////////////////////////////////////////////////////////////////////////
1:   public void testWriteAndReadFilesWithoutTableName() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path)
1:         .projection(new String[]{"name", "age"})
1:         .isTransactionalTable(true)
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testWriteAndReadFilesWithoutTableName2() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true,false);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path)
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
commit:a7faef8
/////////////////////////////////////////////////////////////////////////
1:   public void testReadColumnTwice() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(new String[]{"name", "name", "age", "name"})
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(name[i], row[1]);
1:       Assert.assertEquals(age[i], row[2]);
1:       Assert.assertEquals(name[i], row[3]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       CarbonReader reader = CarbonReader
1:           .builder(path, "_temp")
1:           .projection(new String[]{})
0:           .build();
1:       assert (false);
1:     } catch (RuntimeException e) {
1:       assert (e.getMessage().equalsIgnoreCase("Projection can't be empty"));
commit:e740182
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInDataFile(dataFiles[0].getAbsolutePath());
1:     Assert.assertTrue(schema.getFields().length == 2);
1:     Assert.assertEquals("name", (schema.getFields())[0].getFieldName());
1:     Assert.assertEquals("age", (schema.getFields())[1].getFieldName());
1:     Assert.assertEquals(DataTypes.STRING, (schema.getFields())[0].getDataType());
1:     Assert.assertEquals(DataTypes.INT, (schema.getFields())[1].getDataType());
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInSchemaFile(dataFiles[0].getAbsolutePath());
1: 
1:     // sort the schema
1:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:       @Override
1:       public int compare(Field o1, Field o2) {
1:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:       }
1:     });
1: 
1:     // Transform the schema
1:     String[] strings = new String[schema.getFields().length];
1:     for (int i = 0; i < schema.getFields().length; i++) {
1:       strings[i] = (schema.getFields())[i].getFieldName();
1:     }
1: 
1:     Assert.assertEquals(2, schema.getFields().length);
1: 
1:     Assert.assertEquals("name", (schema.getFields())[0].getFieldName());
1:     Assert.assertEquals("age", (schema.getFields())[1].getFieldName());
1:     Assert.assertEquals(DataTypes.STRING, (schema.getFields())[0].getDataType());
1:     Assert.assertEquals(DataTypes.INT, (schema.getFields())[1].getDataType());
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInSchemaFile(dataFiles[0].getAbsolutePath());
1:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:       public int compare(Field o1, Field o2) {
1:     String[] strings = new String[schema.getFields().length];
1:     for (int i = 0; i < schema.getFields().length; i++) {
1:       strings[i] = (schema.getFields())[i].getFieldName();
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInDataFile(dataFiles2[0].getAbsolutePath());
1:     Arrays.sort(schema.getFields(), new Comparator<Field>() {
1:       public int compare(Field o1, Field o2) {
1:     String[] strings = new String[schema.getFields().length];
1:     for (int i = 0; i < schema.getFields().length; i++) {
1:       strings[i] = (schema.getFields())[i].getFieldName();
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInIndexFile(dataFiles2[0].getAbsolutePath()).asOriginOrder();
1:     String[] strings = new String[schema.getFields().length];
1:     for (int i = 0; i < schema.getFields().length; i++) {
1:       strings[i] = (schema.getFields())[i].getFieldName();
/////////////////////////////////////////////////////////////////////////
1:     Schema schema = CarbonSchemaReader.readSchemaInIndexFile(dataFiles2[0].getAbsolutePath()).asOriginOrder();
1:     for (int i = 0; i < schema.getFields().length; i++) {
1:       System.out.println((schema.getFields())[i].getFieldName() + "\t" + schema.getFields()[i].getSchemaOrdinal());
commit:8896a63
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
0: import java.util.Collections;
0: import java.util.Comparator;
1: import org.apache.avro.generic.GenericData;
1: import org.apache.carbondata.common.exceptions.sql.InvalidLoadOptionException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.lang.CharEncoding;
1: import org.junit.*;
0: import tech.allegro.schema.json2avro.converter.JsonAvroConverter;
/////////////////////////////////////////////////////////////////////////
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
/////////////////////////////////////////////////////////////////////////
1:             , "decimalField"})
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       int id = (int) row[2];
1:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:       Assert.assertEquals((double) id / 2, row[4]);
1:       Assert.assertEquals(true, (boolean) row[5]);
1:       long day = 24L * 3600 * 1000;
1:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         timestampFormat);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         badRecordAction);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         badRecordLoc);
1:   }
1: 
1:   @Test
1:   public void testReadSchemaFileAndSort() throws IOException, InterruptedException {
1:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:         + "../../").getCanonicalPath();
1:     String storeLocation = rootPath + "/target/";
1:     carbonProperties
1:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[9];
1:     fields[0] = new Field("stringField", DataTypes.STRING);
1:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:     fields[2] = new Field("intField", DataTypes.INT);
1:     fields[3] = new Field("longField", DataTypes.LONG);
1:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:     fields[6] = new Field("dateField", DataTypes.DATE);
1:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1: 
1:     try {
1:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:           .isTransactionalTable(true)
1:           .persistSchemaFile(true)
1:           .outputPath(path);
1: 
0:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields));
1: 
1:       for (int i = 0; i < 100; i++) {
1:         String[] row2 = new String[]{
1:             "robot" + (i % 10),
1:             String.valueOf(i),
1:             String.valueOf(i),
1:             String.valueOf(Long.MAX_VALUE - i),
1:             String.valueOf((double) i / 2),
1:             String.valueOf(true),
1:             "2019-03-02",
1:             "2019-02-12 03:03:34",
1:             "12.345"
1:         };
1:         writer.write(row2);
1:       }
1:       writer.close();
1:     } catch (Exception e) {
1:       e.printStackTrace();
1:       Assert.fail(e.getMessage());
1:     }
1: 
1:     File[] dataFiles = new File(path + "/Metadata").listFiles(new FilenameFilter() {
1:       @Override public boolean accept(File dir, String name) {
1:         return name.endsWith("schema");
1:       }
1:     });
0:     TableInfo tableInfo = CarbonReader.readSchemaFile(dataFiles[0].getAbsolutePath());
1: 
0:     List<ColumnSchema> columns = tableInfo.getFactTable().getListOfColumns();
1: 
1:     // sort the schema
0:     Collections.sort(tableInfo.getFactTable().getListOfColumns(), new Comparator<ColumnSchema>() {
1:       @Override
0:       public int compare(ColumnSchema o1, ColumnSchema o2) {
1:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:       }
1:     });
1: 
1:     // Transform the schema
0:     String[] strings= new String[columns.size()];
0:     for (int i = 0; i < columns.size(); i++) {
0:       strings[i]= columns.get(i).getColumnName();
1:     }
1: 
1:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:     Assert.assertTrue(segmentFolder.exists());
1: 
1:     Assert.assertNotNull(dataFiles);
1:     Assert.assertTrue(dataFiles.length > 0);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(strings)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       int id = (int) row[2];
1:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:       Assert.assertEquals((double) id / 2, row[4]);
1:       Assert.assertEquals(true, (boolean) row[5]);
1:       long day = 24L * 3600 * 1000;
1:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         timestampFormat);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         badRecordAction);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         badRecordLoc);
1:   }
1: 
1:   @Test
1:   public void testReadSchemaInDataFileAndSort() throws IOException, InterruptedException {
1:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:         + "../../").getCanonicalPath();
1:     String storeLocation = rootPath + "/target/";
1:     carbonProperties
1:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[9];
1:     fields[0] = new Field("stringField", DataTypes.STRING);
1:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:     fields[2] = new Field("intField", DataTypes.INT);
1:     fields[3] = new Field("longField", DataTypes.LONG);
1:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:     fields[6] = new Field("dateField", DataTypes.DATE);
1:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1: 
1:     try {
1:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:           .isTransactionalTable(true)
1:           .persistSchemaFile(true)
1:           .outputPath(path);
1: 
0:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields));
1: 
1:       for (int i = 0; i < 100; i++) {
1:         String[] row2 = new String[]{
1:             "robot" + (i % 10),
1:             String.valueOf(i),
1:             String.valueOf(i),
1:             String.valueOf(Long.MAX_VALUE - i),
1:             String.valueOf((double) i / 2),
1:             String.valueOf(true),
1:             "2019-03-02",
1:             "2019-02-12 03:03:34",
1:             "12.345"
1:         };
1:         writer.write(row2);
1:       }
1:       writer.close();
1:     } catch (Exception e) {
1:       e.printStackTrace();
1:       Assert.fail(e.getMessage());
1:     }
1: 
1:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:       @Override public boolean accept(File dir, String name) {
1:         return name.endsWith("carbondata");
1:       }
1:     });
1: 
0:     List<ColumnSchema> columns = CarbonReader.readSchemaInDataFile(dataFiles2[0].getAbsolutePath());
1: 
1:     // sort the schema
0:     Collections.sort(columns, new Comparator<ColumnSchema>() {
1:       @Override
0:       public int compare(ColumnSchema o1, ColumnSchema o2) {
1:         return Integer.compare(o1.getSchemaOrdinal(), o2.getSchemaOrdinal());
1:       }
1:     });
1: 
1:     // Transform the schema
0:     String[] strings= new String[columns.size()];
0:     for (int i = 0; i < columns.size(); i++) {
0:       strings[i]= columns.get(i).getColumnName();
1:     }
1: 
1:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:     Assert.assertTrue(segmentFolder.exists());
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(strings)
0:         .build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       int id = (int) row[2];
1:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:       Assert.assertEquals((double) id / 2, row[4]);
1:       Assert.assertEquals(true, (boolean) row[5]);
1:       long day = 24L * 3600 * 1000;
1:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         timestampFormat);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         badRecordAction);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         badRecordLoc);
1:   }
1: 
1:   @Test
1:   public void testReadUserSchema() throws IOException, InterruptedException {
1:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:         + "../../").getCanonicalPath();
1:     String storeLocation = rootPath + "/target/";
1:     carbonProperties
1:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[9];
1:     fields[0] = new Field("stringField", DataTypes.STRING);
1:     fields[1] = new Field("shortField", DataTypes.SHORT);
1:     fields[2] = new Field("intField", DataTypes.INT);
1:     fields[3] = new Field("longField", DataTypes.LONG);
1:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:     fields[6] = new Field("dateField", DataTypes.DATE);
1:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1: 
1:     try {
1:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:           .isTransactionalTable(true)
1:           .persistSchemaFile(true)
1:           .outputPath(path);
1: 
0:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields));
1: 
1:       for (int i = 0; i < 100; i++) {
1:         String[] row2 = new String[]{
1:             "robot" + (i % 10),
1:             String.valueOf(i),
1:             String.valueOf(i),
1:             String.valueOf(Long.MAX_VALUE - i),
1:             String.valueOf((double) i / 2),
1:             String.valueOf(true),
1:             "2019-03-02",
1:             "2019-02-12 03:03:34",
1:             "12.345"
1:         };
1:         writer.write(row2);
1:       }
1:       writer.close();
1:     } catch (Exception e) {
1:       e.printStackTrace();
1:       Assert.fail(e.getMessage());
1:     }
1: 
1:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:       @Override public boolean accept(File dir, String name) {
1:         return name.endsWith("carbonindex");
1:       }
1:     });
1: 
0:     List<ColumnSchema> columns = CarbonReader.readUserSchema(dataFiles2[0].getAbsolutePath());
1: 
1:     // Transform the schema
0:     String[] strings= new String[columns.size()];
0:     for (int i = 0; i < columns.size(); i++) {
0:       strings[i]= columns.get(i).getColumnName();
1:     }
1: 
1:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:     Assert.assertTrue(segmentFolder.exists());
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(strings)
0:         .build();
/////////////////////////////////////////////////////////////////////////
1: 
0:   private void WriteAvroComplexData(String mySchema, String json, String[] sortColumns, String path)
1:       throws IOException, InvalidLoadOptionException {
1: 
1:     // conversion to GenericData.Record
1:     org.apache.avro.Schema nn = new org.apache.avro.Schema.Parser().parse(mySchema);
0:     JsonAvroConverter converter = new JsonAvroConverter();
0:     GenericData.Record record = converter.convertToGenericDataRecord(
0:         json.getBytes(CharEncoding.UTF_8), nn);
1: 
1:     try {
1:       CarbonWriter writer = CarbonWriter.builder()
1:           .outputPath(path)
1:           .isTransactionalTable(true)
0:           .buildWriterForAvroInput(nn);
1: 
1:       for (int i = 0; i < 100; i++) {
1:         writer.write(record);
1:       }
1:       writer.close();
1:     } catch (Exception e) {
1:       e.printStackTrace();
1:       throw e;
1:     }
1:   }
1: 
1:   // TODO: support get schema of complex data type
1:   @Ignore
1:   public void testReadUserSchemaOfComplex() throws IOException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     String mySchema =
1:         "{" +
1:             "  \"name\": \"address\", " +
1:             "   \"type\": \"record\", " +
1:             "    \"fields\": [  " +
1:             "  { \"name\": \"name\", \"type\": \"string\"}, " +
1:             "  { \"name\": \"age\", \"type\": \"int\"}, " +
1:             "  { " +
1:             "    \"name\": \"address\", " +
1:             "      \"type\": { " +
1:             "    \"type\" : \"record\", " +
1:             "        \"name\" : \"my_address\", " +
1:             "        \"fields\" : [ " +
1:             "    {\"name\": \"street\", \"type\": \"string\"}, " +
1:             "    {\"name\": \"city\", \"type\": \"string\"} " +
1:             "  ]} " +
1:             "  }, " +
1:             "  {\"name\" :\"doorNum\", " +
1:             "   \"type\" : { " +
1:             "   \"type\" :\"array\", " +
1:             "   \"items\":{ " +
1:             "   \"name\" :\"EachdoorNums\", " +
1:             "   \"type\" : \"int\", " +
1:             "   \"default\":-1} " +
1:             "              } " +
1:             "  }] " +
1:             "}";
1: 
1:     String json = "{\"name\":\"bob\", \"age\":10, \"address\" : {\"street\":\"abc\", \"city\":\"bang\"}, "
1:         + "   \"doorNum\" : [1,2,3,4]}";
1: 
1:     try {
0:       WriteAvroComplexData(mySchema, json, null, path);
1:     } catch (InvalidLoadOptionException e) {
1:       e.printStackTrace();
1:     }
1: 
1:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:     Assert.assertTrue(segmentFolder.exists());
1: 
1:     File[] dataFiles = segmentFolder.listFiles(new FileFilter() {
1:       @Override
1:       public boolean accept(File pathname) {
1:         return pathname.getName().endsWith(CarbonCommonConstants.FACT_FILE_EXT);
1:       }
1:     });
1:     Assert.assertNotNull(dataFiles);
1:     Assert.assertEquals(1, dataFiles.length);
1: 
1: 
1:     File[] dataFiles2 = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:       @Override
1:       public boolean accept(File dir, String name) {
1:         return name.endsWith("carbonindex");
1:       }
1:     });
1: 
0:     List<ColumnSchema> columns = CarbonReader.readUserSchema(dataFiles2[0].getAbsolutePath());
1: 
0:     for (int i = 0; i < columns.size(); i++) {
0:       System.out.println(columns.get(i).getColumnName() + "\t" + columns.get(i).getSchemaOrdinal());
1:     }
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
commit:8b80b12
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testReadFilesWithProjectAllColumns() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
0:         .projectAllColumns()
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadFilesWithDefaultProjection() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1:   }
1: 
1:   @Test
1:   public void testReadFilesWithNullProjection() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
0:         .projection(new String[]{})
0:         .build();
1: 
1:     // expected output after sorting
1:     String[] name = new String[100];
1:     int[] age = new int[100];
1:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
1:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1:     // Default sort column is applied for dimensions. So, need  to validate accordingly
1: 
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
0:       assert(row.length==0);
1:     }
1:   }
commit:a7ac656
/////////////////////////////////////////////////////////////////////////
0: import java.io.FileFilter;
1: import java.sql.Date;
1: import java.sql.Timestamp;
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.util.CarbonProperties;
1: import org.apache.carbondata.core.util.path.CarbonTablePath;
1: import junit.framework.TestCase;
1: public class CarbonReaderTest extends TestCase {
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Read again
1:     CarbonReader reader2 = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(new String[]{"name", "age"})
0:         .build();
1: 
1:     i = 0;
1:     while (reader2.hasNext()) {
1:       Object[] row = (Object[]) reader2.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
1:       Assert.assertEquals(name[i], row[0]);
1:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1:     reader2.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadFilesParallel() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
0:     CarbonReader reader = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(new String[]{"name", "age"})
0:         .build();
1:     // Reader 2
1:     CarbonReader reader2 = CarbonReader
1:         .builder(path, "_temp")
1:         .projection(new String[]{"name", "age"})
0:         .build();
1: 
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       Object[] row2 = (Object[]) reader2.readNextRow();
1:       // parallel compare
1:       Assert.assertEquals(row[0], row2[0]);
1:       Assert.assertEquals(row[1], row2[1]);
1:     }
1: 
1:     reader.close();
1:     reader2.close();
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadAfterClose() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     CarbonReader reader = CarbonReader.builder(path, "_temp")
0:         .projection(new String[]{"name", "age"}).build();
1: 
1:     reader.close();
1:     String msg = "CarbonReader not initialise, please create it first.";
1:     try {
1:       reader.hasNext();
1:       assert (false);
1:     } catch (RuntimeException e) {
1:       assert (e.getMessage().equals(msg));
1:     }
1: 
1:     try {
1:       reader.readNextRow();
1:       assert (false);
1:     } catch (RuntimeException e) {
1:       assert (e.getMessage().equals(msg));
1:     }
1: 
1:     try {
1:       reader.close();
1:       assert (false);
1:     } catch (RuntimeException e) {
1:       assert (e.getMessage().equals(msg));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   CarbonProperties carbonProperties;
1: 
1:   @Override
1:   public void setUp() {
1:     carbonProperties = CarbonProperties.getInstance();
1:   }
1: 
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(CarbonReaderTest.class.getName());
1: 
1:   @Test
1:   public void testTimeStampAndBadRecord() throws IOException, InterruptedException {
1:     String timestampFormat = carbonProperties.getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT);
1:     String badRecordAction = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION_DEFAULT);
1:     String badRecordLoc = carbonProperties.getProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         CarbonCommonConstants.CARBON_BADRECORDS_LOC_DEFAULT_VAL);
1:     String rootPath = new File(this.getClass().getResource("/").getPath()
1:         + "../../").getCanonicalPath();
1:     String storeLocation = rootPath + "/target/";
1:     carbonProperties
1:         .addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC, storeLocation)
1:         .addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT, "yyyy-MM-dd hh:mm:ss")
1:         .addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION, "REDIRECT");
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[9];
1:     fields[0] = new Field("stringField", DataTypes.STRING);
1:     fields[1] = new Field("intField", DataTypes.INT);
1:     fields[2] = new Field("shortField", DataTypes.SHORT);
1:     fields[3] = new Field("longField", DataTypes.LONG);
1:     fields[4] = new Field("doubleField", DataTypes.DOUBLE);
1:     fields[5] = new Field("boolField", DataTypes.BOOLEAN);
1:     fields[6] = new Field("dateField", DataTypes.DATE);
1:     fields[7] = new Field("timeField", DataTypes.TIMESTAMP);
1:     fields[8] = new Field("decimalField", DataTypes.createDecimalType(8, 2));
1: 
1:     try {
1:       CarbonWriterBuilder builder = CarbonWriter.builder()
1:           .isTransactionalTable(true)
1:           .persistSchemaFile(true)
1:           .outputPath(path);
1: 
0:       CarbonWriter writer = builder.buildWriterForCSVInput(new Schema(fields));
1: 
1:       for (int i = 0; i < 100; i++) {
1:         String[] row = new String[]{
1:             "robot" + (i % 10),
1:             String.valueOf(i),
1:             String.valueOf(i),
1:             String.valueOf(Long.MAX_VALUE - i),
1:             String.valueOf((double) i / 2),
1:             String.valueOf(true),
1:             "2018-05-12",
1:             "2018-05-12",
1:             "12.345"
1:         };
1:         writer.write(row);
1:         String[] row2 = new String[]{
1:             "robot" + (i % 10),
1:             String.valueOf(i),
1:             String.valueOf(i),
1:             String.valueOf(Long.MAX_VALUE - i),
1:             String.valueOf((double) i / 2),
1:             String.valueOf(true),
1:             "2019-03-02",
1:             "2019-02-12 03:03:34",
1:             "12.345"
1:         };
1:         writer.write(row2);
1:       }
1:       writer.close();
1:     } catch (Exception e) {
1:       e.printStackTrace();
1:       Assert.fail(e.getMessage());
1:     }
1:     LOGGER.audit("Bad record location:" + storeLocation);
1:     File segmentFolder = new File(CarbonTablePath.getSegmentPath(path, "null"));
1:     Assert.assertTrue(segmentFolder.exists());
1: 
1:     File[] dataFiles = segmentFolder.listFiles(new FileFilter() {
1:       @Override
1:       public boolean accept(File pathname) {
1:         return pathname.getName().endsWith(CarbonCommonConstants.FACT_FILE_EXT);
1:       }
1:     });
1:     Assert.assertNotNull(dataFiles);
1:     Assert.assertTrue(dataFiles.length > 0);
1: 
1:     CarbonReader reader = CarbonReader.builder(path, "_temp")
1:         .projection(new String[]{
1:             "stringField"
1:             , "shortField"
1:             , "intField"
1:             , "longField"
1:             , "doubleField"
1:             , "boolField"
1:             , "dateField"
1:             , "timeField"
0:             , "decimalField"}).build();
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
1:       Object[] row = (Object[]) reader.readNextRow();
1:       int id = (int) row[2];
1:       Assert.assertEquals("robot" + (id % 10), row[0]);
1:       Assert.assertEquals(Short.parseShort(String.valueOf(id)), row[1]);
1:       Assert.assertEquals(Long.MAX_VALUE - id, row[3]);
1:       Assert.assertEquals((double) id / 2, row[4]);
1:       Assert.assertEquals(true, (boolean) row[5]);
1:       long day = 24L * 3600 * 1000;
1:       Assert.assertEquals("2019-03-02", new Date((day * ((int) row[6]))).toString());
1:       Assert.assertEquals("2019-02-12 03:03:34.0", new Timestamp((long) row[7] / 1000).toString());
1:       i++;
1:     }
1:     Assert.assertEquals(i, 100);
1: 
1:     reader.close();
1:     FileUtils.deleteDirectory(new File(path));
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:         timestampFormat);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BAD_RECORDS_ACTION,
1:         badRecordAction);
1:     carbonProperties.addProperty(CarbonCommonConstants.CARBON_BADRECORDS_LOC,
1:         badRecordLoc);
1:   }
1: 
commit:cf55028
/////////////////////////////////////////////////////////////////////////
0: import org.junit.After;
0: import org.junit.Before;
1:   @Before
1:   public void cleanFile() {
1:     assert (TestUtil.cleanMdtFile());
1:   }
1: 
1:   @After
1:   public void verifyDMFile() {
1:     assert (!TestUtil.verifyMdtFile());
1:   }
1: 
commit:f7c0670
/////////////////////////////////////////////////////////////////////////
1:     reader.close();
author:rahul
-------------------------------------------------------------------------------
commit:4d3ecfb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     GenericData.Record record = TestUtil.jsonToAvro(json, mySchema);
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:9b88a06
/////////////////////////////////////////////////////////////////////////
1:   public void testWriteAndReadFilesWithReaderBuildFail() throws IOException, InterruptedException {
1:     String path1 = "./testWriteFiles";
1:     String path2 = "./testWriteFiles2";
1:     FileUtils.deleteDirectory(new File(path1));
1:     FileUtils.deleteDirectory(new File(path2));
1: 
1:     Field[] fields = new Field[] { new Field("c1", "string"),
1:          new Field("c2", "int") };
1:     Schema schema = new Schema(fields);
1:     CarbonWriterBuilder builder = CarbonWriter.builder();
1: 
1:     CarbonWriter carbonWriter = null;
1:     try {
1:       carbonWriter = builder.outputPath(path1).isTransactionalTable(false).uniqueIdentifier(12345)
0:   .buildWriterForCSVInput(schema);
1:     } catch (InvalidLoadOptionException e) {
1:       e.printStackTrace();
1:     }
1:     carbonWriter.write(new String[] { "MNO", "100" });
1:     carbonWriter.close();
1: 
1:     Field[] fields1 = new Field[] { new Field("p1", "string"),
1:          new Field("p2", "int") };
1:     Schema schema1 = new Schema(fields1);
1:     CarbonWriterBuilder builder1 = CarbonWriter.builder();
1: 
1:     CarbonWriter carbonWriter1 = null;
1:     try {
1:       carbonWriter1 = builder1.outputPath(path2).isTransactionalTable(false).uniqueIdentifier(12345)
0:    .buildWriterForCSVInput(schema1);
1:     } catch (InvalidLoadOptionException e) {
1:       e.printStackTrace();
1:     }
1:     carbonWriter1.write(new String[] { "PQR", "200" });
1:     carbonWriter1.close();
1: 
1:     try {
1:        CarbonReader reader =
1:        CarbonReader.builder(path1, "_temp").
1:        projection(new String[] { "c1", "c3" })
0:        .isTransactionalTable(false).build();
1:     } catch (Exception e){
1:        System.out.println("Success");
1:     }
1:     CarbonReader reader1 =
1:          CarbonReader.builder(path2, "_temp1")
1:      .projection(new String[] { "p1", "p2" })
0:      .isTransactionalTable(false).build();
1: 
1:     while (reader1.hasNext()) {
1:        Object[] row1 = (Object[]) reader1.readNextRow();
1:        System.out.println(row1[0]);
1:        System.out.println(row1[1]);
1:     }
1:     reader1.close();
1: 
1:     FileUtils.deleteDirectory(new File(path1));
1:     FileUtils.deleteDirectory(new File(path2));
1:   }
1: 
1:   @Test
commit:5f68a79
/////////////////////////////////////////////////////////////////////////
0:     CarbonReader reader = CarbonReader.builder(path, "_temp")
/////////////////////////////////////////////////////////////////////////
commit:74770aa
/////////////////////////////////////////////////////////////////////////
1:     CarbonReader reader = CarbonReader.builder(path, "_temp").isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:     CarbonReader reader = CarbonReader.builder(path, "_temp").isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
0:     CarbonReader reader = CarbonReader.builder(path, "_temp").isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
0:     CarbonReader reader = CarbonReader.builder(path, "_temp")
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
1:         .isTransactionalTable(true)
/////////////////////////////////////////////////////////////////////////
0:           .isTransactionalTable(true)
commit:cf1b50b
/////////////////////////////////////////////////////////////////////////
1:     reader.close();
commit:5f32647
/////////////////////////////////////////////////////////////////////////
1:     // expected output after sorting
0:     String[] name = new String[100];
0:     int[] age = new int[100];
0:     for (int i = 0; i < 100; i++) {
1:       name[i] = "robot" + (i / 10);
0:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:       Object[] row = (Object[]) reader.readNextRow();
1:       // Default sort column is applied for dimensions. So, need  to validate accordingly
0:       Assert.assertEquals(name[i], row[0]);
0:       Assert.assertEquals(age[i], row[1]);
0:     Assert.assertEquals(i, 100);
commit:280a400
/////////////////////////////////////////////////////////////////////////
0:     CarbonReader reader = CarbonReader.builder(path, "_temp")
author:rahulforallp
-------------------------------------------------------------------------------
commit:92d9b92
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(200, new Schema(fields), path, true);
1:     String[] name = new String[200];
1:     Integer[] age = new Integer[200];
1:     for (int i = 0; i < 200; i++) {
1:       age[i] = i;
1:       assert(Arrays.asList(name).contains(row[0]));
1:       assert(Arrays.asList(age).contains(row[1]));
1:     Assert.assertEquals(i, 200);
/////////////////////////////////////////////////////////////////////////
1:       assert(Arrays.asList(name).contains(row[0]));
1:       assert(Arrays.asList(age).contains(row[1]));
1:     Assert.assertEquals(i, 200);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
/////////////////////////////////////////////////////////////////////////
1:     reader.close();
/////////////////////////////////////////////////////////////////////////
1:     TestUtil.writeFilesAndVerify(100, new Schema(fields), path, true);
author:sounakr
-------------------------------------------------------------------------------
commit:4b8dc0a
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:   @Test
1:   public void testWriteAndReadFilesNonTransactional() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
1:     // Write to a Non Transactional Table
1:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true, false);
1: 
0:     CarbonReader reader = CarbonReader.builder(path, "_temp")
1:         .projection(new String[]{"name", "age"})
0:         .isTransactionalTable(false)
0:         .build();
1: 
0:     // expected output after sorting
0:     String[] name = new String[100];
0:     int[] age = new int[100];
0:     for (int i = 0; i < 100; i++) {
0:       name[i] = "robot" + (i / 10);
0:       age[i] = (i % 10) * 10 + i / 10;
1:     }
1: 
1:     int i = 0;
1:     while (reader.hasNext()) {
0:       Object[] row = (Object[]) reader.readNextRow();
0:       // Default sort column is applied for dimensions. So, need  to validate accordingly
0:       Assert.assertEquals(name[i], row[0]);
0:       Assert.assertEquals(age[i], row[1]);
1:       i++;
1:     }
0:     Assert.assertEquals(i, 100);
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
author:Jacky Li
-------------------------------------------------------------------------------
commit:f910cfa
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.sdk.file;
1: 
0: import java.io.File;
0: import java.io.FilenameFilter;
0: import java.io.IOException;
0: import java.util.List;
1: 
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
0: import org.apache.carbondata.core.metadata.schema.table.TableInfo;
0: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1: 
1: import org.apache.commons.io.FileUtils;
0: import org.junit.Assert;
0: import org.junit.Test;
1: 
0: public class CarbonReaderTest {
1: 
1:   @Test
1:   public void testWriteAndReadFiles() throws IOException, InterruptedException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
0:     CarbonReader reader = CarbonReader.builder(path)
0:         .projection(new String[]{"name", "age"}).build();
1: 
1:     int i = 0;
0:     while (reader.hasNext()) {
0:       Object[] row = (Object[])reader.readNextRow();
0:       Assert.assertEquals("robot" + (i % 10), row[0]);
0:       Assert.assertEquals(i, row[1]);
1:       i++;
1:     }
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadSchemaFromDataFile() throws IOException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     File[] dataFiles = new File(path + "/Fact/Part0/Segment_null/").listFiles(new FilenameFilter() {
1:       @Override public boolean accept(File dir, String name) {
1:         return name.endsWith("carbondata");
1:       }
1:     });
1:     Assert.assertTrue(dataFiles != null);
1:     Assert.assertTrue(dataFiles.length > 0);
0:     List<ColumnSchema> columns = CarbonReader.readSchemaInDataFile(dataFiles[0].getAbsolutePath());
0:     Assert.assertTrue(columns.size() == 2);
0:     Assert.assertEquals("name", columns.get(0).getColumnName());
0:     Assert.assertEquals("age", columns.get(1).getColumnName());
0:     Assert.assertEquals(DataTypes.STRING, columns.get(0).getDataType());
0:     Assert.assertEquals(DataTypes.INT, columns.get(1).getDataType());
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: 
1:   @Test
1:   public void testReadSchemaFromSchemaFile() throws IOException {
1:     String path = "./testWriteFiles";
1:     FileUtils.deleteDirectory(new File(path));
1: 
1:     Field[] fields = new Field[2];
1:     fields[0] = new Field("name", DataTypes.STRING);
1:     fields[1] = new Field("age", DataTypes.INT);
1: 
0:     TestUtil.writeFilesAndVerify(new Schema(fields), path, true);
1: 
1:     File[] dataFiles = new File(path + "/Metadata").listFiles(new FilenameFilter() {
1:       @Override public boolean accept(File dir, String name) {
1:         return name.endsWith("schema");
1:       }
1:     });
1:     Assert.assertTrue(dataFiles != null);
1:     Assert.assertTrue(dataFiles.length > 0);
0:     TableInfo tableInfo = CarbonReader.readSchemaFile(dataFiles[0].getAbsolutePath());
0:     Assert.assertEquals(2, tableInfo.getFactTable().getListOfColumns().size());
1: 
0:     List<ColumnSchema> columns = tableInfo.getFactTable().getListOfColumns();
0:     Assert.assertEquals(2, columns.size());
0:     Assert.assertEquals("name", columns.get(0).getColumnName());
0:     Assert.assertEquals("age", columns.get(1).getColumnName());
0:     Assert.assertEquals(DataTypes.STRING, columns.get(0).getDataType());
0:     Assert.assertEquals(DataTypes.INT, columns.get(1).getDataType());
1: 
1:     FileUtils.deleteDirectory(new File(path));
1:   }
1: }
============================================================================