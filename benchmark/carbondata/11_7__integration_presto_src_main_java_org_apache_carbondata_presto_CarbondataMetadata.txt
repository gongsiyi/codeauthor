1:0e93a3f: /*
1:0e93a3f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0e93a3f:  * contributor license agreements.  See the NOTICE file distributed with
1:0e93a3f:  * this work for additional information regarding copyright ownership.
1:0e93a3f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:0e93a3f:  * (the "License"); you may not use this file except in compliance with
1:0e93a3f:  * the License.  You may obtain a copy of the License at
1:0e93a3f:  *
1:0e93a3f:  *    http://www.apache.org/licenses/LICENSE-2.0
1:0e93a3f:  *
1:0e93a3f:  * Unless required by applicable law or agreed to in writing, software
1:0e93a3f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0e93a3f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0e93a3f:  * See the License for the specific language governing permissions and
1:0e93a3f:  * limitations under the License.
1:0e93a3f:  */
8:0e93a3f: 
1:0e93a3f: package org.apache.carbondata.presto;
1:0e93a3f: 
1:01b48fc: import java.util.LinkedList;
1:01b48fc: import java.util.List;
1:01b48fc: import java.util.Map;
1:01b48fc: import java.util.Optional;
1:01b48fc: import java.util.Set;
1:01b48fc: 
1:d4a1577: import javax.inject.Inject;
1:d4a1577: 
1:d4a1577: import static java.util.Objects.requireNonNull;
1:d4a1577: 
1:0e93a3f: import org.apache.carbondata.core.metadata.datatype.DataType;
1:01b48fc: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:0e93a3f: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:01b48fc: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1:0e93a3f: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:0e93a3f: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1:0e93a3f: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:01b48fc: import org.apache.carbondata.presto.impl.CarbonTableReader;
1:0e93a3f: 
1:d4a1577: import static org.apache.carbondata.presto.Types.checkType;
1:d4a1577: 
1:01b48fc: import com.facebook.presto.spi.ColumnHandle;
1:01b48fc: import com.facebook.presto.spi.ColumnMetadata;
1:01b48fc: import com.facebook.presto.spi.ConnectorSession;
1:01b48fc: import com.facebook.presto.spi.ConnectorTableHandle;
1:01b48fc: import com.facebook.presto.spi.ConnectorTableLayout;
1:01b48fc: import com.facebook.presto.spi.ConnectorTableLayoutHandle;
1:01b48fc: import com.facebook.presto.spi.ConnectorTableLayoutResult;
1:01b48fc: import com.facebook.presto.spi.ConnectorTableMetadata;
1:01b48fc: import com.facebook.presto.spi.Constraint;
1:01b48fc: import com.facebook.presto.spi.SchemaNotFoundException;
1:01b48fc: import com.facebook.presto.spi.SchemaTableName;
1:01b48fc: import com.facebook.presto.spi.SchemaTablePrefix;
1:01b48fc: import com.facebook.presto.spi.connector.ConnectorMetadata;
1:01b48fc: import com.facebook.presto.spi.type.BigintType;
1:01b48fc: import com.facebook.presto.spi.type.BooleanType;
1:01b48fc: import com.facebook.presto.spi.type.DateType;
1:01b48fc: import com.facebook.presto.spi.type.DecimalType;
1:01b48fc: import com.facebook.presto.spi.type.DoubleType;
1:01b48fc: import com.facebook.presto.spi.type.IntegerType;
1:01b48fc: import com.facebook.presto.spi.type.SmallintType;
1:01b48fc: import com.facebook.presto.spi.type.TimestampType;
1:01b48fc: import com.facebook.presto.spi.type.Type;
1:01b48fc: import com.facebook.presto.spi.type.VarcharType;
1:01b48fc: import com.google.common.collect.ImmutableList;
1:01b48fc: import com.google.common.collect.ImmutableMap;
1:0e93a3f: 
1:0e93a3f: import static com.google.common.base.Preconditions.checkArgument;
1:0e93a3f: 
1:0e93a3f: public class CarbondataMetadata implements ConnectorMetadata {
1:0e93a3f:   private final String connectorId;
1:0e93a3f:   private CarbonTableReader carbonTableReader;
1:0e93a3f: 
1:0e93a3f:   private Map<String, ColumnHandle> columnHandleMap;
1:0e93a3f: 
1:0e93a3f:   @Inject public CarbondataMetadata(CarbondataConnectorId connectorId, CarbonTableReader reader) {
1:0e93a3f:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
1:0e93a3f:     this.carbonTableReader = requireNonNull(reader, "client is null");
7:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f: 
1:0e93a3f:   @Override public List<String> listSchemaNames(ConnectorSession session) {
1:0e93a3f:     return listSchemaNamesInternal();
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   public List<String> listSchemaNamesInternal() {
1:910d496:     return carbonTableReader.getSchemaNames();
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override
1:0e93a3f:   public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull) {
1:0e93a3f: 
1:0e93a3f:     List<String> schemaNames;
1:0e93a3f:     if (schemaNameOrNull != null) {
1:0e93a3f:       schemaNames = ImmutableList.of(schemaNameOrNull);
1:956833e:     } else {
1:0e93a3f:       schemaNames = carbonTableReader.getSchemaNames();
1:0e93a3f:     }
1:0e93a3f: 
1:0e93a3f:     ImmutableList.Builder<SchemaTableName> builder = ImmutableList.builder();
1:0e93a3f:     for (String schemaName : schemaNames) {
1:0e93a3f:       for (String tableName : carbonTableReader.getTableNames(schemaName)) {
1:d4a1577:         if (!tableName.equalsIgnoreCase(".DS_Store")) {
1:d4a1577:           builder.add(new SchemaTableName(schemaName, tableName));
1:d4a1577:         }
1:0e93a3f:       }
1:0e93a3f:     }
1:0e93a3f:     return builder.build();
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override
1:0e93a3f:   public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session,
1:0e93a3f:       SchemaTablePrefix prefix) {
1:0e93a3f:     requireNonNull(prefix, "SchemaTablePrefix is null");
1:0e93a3f: 
1:0e93a3f:     ImmutableMap.Builder<SchemaTableName, List<ColumnMetadata>> columns = ImmutableMap.builder();
1:0e93a3f:     for (SchemaTableName tableName : listTables(session, prefix)) {
1:0e93a3f:       ConnectorTableMetadata tableMetadata = getTableMetadata(tableName);
1:0e93a3f:       if (tableMetadata != null) {
1:0e93a3f:         columns.put(tableName, tableMetadata.getColumns());
1:0e93a3f:       }
1:0e93a3f:     }
1:0e93a3f:     return columns.build();
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   //if prefix is null. return all tables
1:0e93a3f:   //if prefix is not null, just return this table
1:0e93a3f:   private List<SchemaTableName> listTables(ConnectorSession session, SchemaTablePrefix prefix) {
1:0e93a3f:     if (prefix.getSchemaName() == null) {
1:0e93a3f:       return listTables(session, prefix.getSchemaName());
1:0e93a3f:     }
1:0e93a3f:     return ImmutableList.of(new SchemaTableName(prefix.getSchemaName(), prefix.getTableName()));
1:0e93a3f:   }
1:0e93a3f: 
1:7c0e660:   private ConnectorTableMetadata getTableMetadata(SchemaTableName schemaTableName) {
1:7c0e660:     if (!listSchemaNamesInternal().contains(schemaTableName.getSchemaName())) {
1:c7e7f70:       throw new SchemaNotFoundException(schemaTableName.getSchemaName());
1:0e93a3f:     }
1:0e93a3f: 
1:7c0e660:     CarbonTable carbonTable = carbonTableReader.getTable(schemaTableName);
1:0e93a3f: 
1:7c0e660:     List<ColumnMetadata> columnsMetaList = new LinkedList<>();
1:d4a1577:     List<CarbonColumn> carbonColumns =
1:d4a1577:         carbonTable.getCreateOrderColumn(schemaTableName.getTableName());
1:abffb4a:     for (CarbonColumn col : carbonColumns) {
1:0e93a3f:       //show columns command will return these data
1:01b48fc:       ColumnSchema columnSchema = col.getColumnSchema();
1:01b48fc:       Type columnType = carbonDataType2SpiMapper(columnSchema);
1:01b48fc:       String extraValues =
1:01b48fc:           columnSchema.getEncodingList().stream().map(encoding -> encoding.toString() + " ")
1:01b48fc:               .reduce("", String::concat);
1:01b48fc:       ColumnMetadata columnMeta =
1:01b48fc:           new ColumnMetadata(columnSchema.getColumnName(), columnType, "", extraValues, false);
1:7c0e660:       columnsMetaList.add(columnMeta);
1:0e93a3f:     }
1:0e93a3f: 
1:0e93a3f:     //carbondata connector's table metadata
1:7c0e660:     return new ConnectorTableMetadata(schemaTableName, columnsMetaList);
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session,
1:0e93a3f:       ConnectorTableHandle tableHandle) {
1:0e93a3f: 
1:0e93a3f:     CarbondataTableHandle handle =
1:0e93a3f:         checkType(tableHandle, CarbondataTableHandle.class, "tableHandle");
1:0e93a3f:     checkArgument(handle.getConnectorId().equals(connectorId),
1:0e93a3f:         "tableHandle is not for this connector");
1:0e93a3f: 
1:0e93a3f:     String schemaName = handle.getSchemaTableName().getSchemaName();
1:7c0e660: 
1:0e93a3f:     if (!listSchemaNamesInternal().contains(schemaName)) {
1:0e93a3f:       throw new SchemaNotFoundException(schemaName);
1:0e93a3f:     }
1:0e93a3f: 
1:0e93a3f:     //CarbonTable(official struct) is stored in CarbonMetadata(official struct)
1:0e93a3f:     CarbonTable cb = carbonTableReader.getTable(handle.getSchemaTableName());
1:0e93a3f: 
1:0e93a3f:     ImmutableMap.Builder<String, ColumnHandle> columnHandles = ImmutableMap.builder();
1:0e93a3f:     String tableName = handle.getSchemaTableName().getTableName();
1:0e93a3f:     for (CarbonDimension column : cb.getDimensionByTableName(tableName)) {
1:0e93a3f:       ColumnSchema cs = column.getColumnSchema();
1:0e93a3f: 
1:110f9b2:       Type spiType = carbonDataType2SpiMapper(cs);
1:0e93a3f:       columnHandles.put(cs.getColumnName(),
1:d4a1577:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
1:d4a1577:               column.getSchemaOrdinal(), column.getKeyOrdinal(), false, cs.getColumnUniqueId(),
1:d4a1577:               cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
1:0e93a3f:     }
1:0e93a3f: 
1:0e93a3f:     for (CarbonMeasure measure : cb.getMeasureByTableName(tableName)) {
1:0e93a3f:       ColumnSchema cs = measure.getColumnSchema();
1:110f9b2:       Type spiType = carbonDataType2SpiMapper(cs);
1:0e93a3f:       columnHandles.put(cs.getColumnName(),
1:d4a1577:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
1:d4a1577:               cs.getSchemaOrdinal(), measure.getOrdinal(), true, cs.getColumnUniqueId(),
1:d4a1577:               cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
1:0e93a3f:     }
1:0e93a3f: 
1:0e93a3f:     columnHandleMap = columnHandles.build();
1:0e93a3f: 
1:0e93a3f:     return columnHandleMap;
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override public ColumnMetadata getColumnMetadata(ConnectorSession session,
1:0e93a3f:       ConnectorTableHandle tableHandle, ColumnHandle columnHandle) {
1:0e93a3f: 
1:0e93a3f:     checkType(tableHandle, CarbondataTableHandle.class, "tableHandle");
1:0e93a3f:     return checkType(columnHandle, CarbondataColumnHandle.class, "columnHandle")
1:0e93a3f:         .getColumnMetadata();
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override
1:0e93a3f:   public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName) {
1:d4a1577:     return new CarbondataTableHandle(connectorId, tableName);
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session,
1:0e93a3f:       ConnectorTableHandle table, Constraint<ColumnHandle> constraint,
1:0e93a3f:       Optional<Set<ColumnHandle>> desiredColumns) {
1:0e93a3f:     CarbondataTableHandle handle = checkType(table, CarbondataTableHandle.class, "table");
1:0e93a3f:     ConnectorTableLayout layout = new ConnectorTableLayout(
1:01b48fc:         new CarbondataTableLayoutHandle(handle, constraint.getSummary()));
1:0e93a3f:     return ImmutableList.of(new ConnectorTableLayoutResult(layout, constraint.getSummary()));
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override public ConnectorTableLayout getTableLayout(ConnectorSession session,
1:0e93a3f:       ConnectorTableLayoutHandle handle) {
1:0e93a3f:     return new ConnectorTableLayout(handle);
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   @Override public ConnectorTableMetadata getTableMetadata(ConnectorSession session,
1:0e93a3f:       ConnectorTableHandle table) {
1:0e93a3f:     return getTableMetadataInternal(table);
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f:   public ConnectorTableMetadata getTableMetadataInternal(ConnectorTableHandle table) {
1:0e93a3f:     CarbondataTableHandle carbondataTableHandle =
1:0e93a3f:         checkType(table, CarbondataTableHandle.class, "table");
1:0e93a3f:     checkArgument(carbondataTableHandle.getConnectorId().equals(connectorId),
1:0e93a3f:         "tableHandle is not for this connector");
1:0e93a3f:     return getTableMetadata(carbondataTableHandle.getSchemaTableName());
1:0e93a3f:   }
1:0e93a3f: 
1:110f9b2:   public static Type carbonDataType2SpiMapper(ColumnSchema columnSchema) {
1:9669c0b:     DataType colType = columnSchema.getDataType();
1:956833e:     if (colType == DataTypes.BOOLEAN) {
1:956833e:       return BooleanType.BOOLEAN;
1:956833e:     } else if (colType == DataTypes.SHORT) {
1:956833e:       return SmallintType.SMALLINT;
1:956833e:     } else if (colType == DataTypes.INT) {
1:956833e:       return IntegerType.INTEGER;
1:956833e:     } else if (colType == DataTypes.LONG) {
1:956833e:       return BigintType.BIGINT;
1:956833e:     } else if (colType == DataTypes.FLOAT || colType == DataTypes.DOUBLE) {
1:956833e:       return DoubleType.DOUBLE;
1:f209e8e:     } else if (DataTypes.isDecimal(colType)) {
1:956833e:       if (columnSchema.getPrecision() > 0) {
1:9669c0b:         return DecimalType.createDecimalType(columnSchema.getPrecision(), columnSchema.getScale());
1:9669c0b:       } else {
1:9669c0b:         return DecimalType.createDecimalType();
1:9669c0b:       }
1:956833e:     } else if (colType == DataTypes.STRING) {
1:956833e:       return VarcharType.VARCHAR;
1:956833e:     } else if (colType == DataTypes.DATE) {
1:956833e:       return DateType.DATE;
1:956833e:     } else if (colType == DataTypes.TIMESTAMP) {
1:956833e:       return TimestampType.TIMESTAMP;
1:956833e:     } else {
1:956833e:       return VarcharType.VARCHAR;
1:956833e:     }
1:0e93a3f:   }
1:0e93a3f: 
1:0e93a3f: }
============================================================================
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:d4a1577
/////////////////////////////////////////////////////////////////////////
1: import javax.inject.Inject;
1: 
1: import static java.util.Objects.requireNonNull;
1: 
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.carbondata.presto.Types.checkType;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!tableName.equalsIgnoreCase(".DS_Store")) {
1:           builder.add(new SchemaTableName(schemaName, tableName));
1:         }
/////////////////////////////////////////////////////////////////////////
1:     List<CarbonColumn> carbonColumns =
1:         carbonTable.getCreateOrderColumn(schemaTableName.getTableName());
/////////////////////////////////////////////////////////////////////////
1:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
1:               column.getSchemaOrdinal(), column.getKeyOrdinal(), false, cs.getColumnUniqueId(),
1:               cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
1:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
1:               cs.getSchemaOrdinal(), measure.getOrdinal(), true, cs.getColumnUniqueId(),
1:               cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
/////////////////////////////////////////////////////////////////////////
1:     return new CarbondataTableHandle(connectorId, tableName);
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, column.getSchemaOrdinal(),
0:               column.getKeyOrdinal(), false,
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, cs.getSchemaOrdinal(),
0:               measure.getOrdinal(), true,
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
author:Bhavya
-------------------------------------------------------------------------------
commit:01b48fc
/////////////////////////////////////////////////////////////////////////
0: import javax.inject.Inject;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Optional;
1: import java.util.Set;
1: 
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1: import org.apache.carbondata.presto.impl.CarbonTableReader;
1: import com.facebook.presto.spi.ColumnHandle;
1: import com.facebook.presto.spi.ColumnMetadata;
1: import com.facebook.presto.spi.ConnectorSession;
1: import com.facebook.presto.spi.ConnectorTableHandle;
1: import com.facebook.presto.spi.ConnectorTableLayout;
1: import com.facebook.presto.spi.ConnectorTableLayoutHandle;
1: import com.facebook.presto.spi.ConnectorTableLayoutResult;
1: import com.facebook.presto.spi.ConnectorTableMetadata;
1: import com.facebook.presto.spi.Constraint;
1: import com.facebook.presto.spi.SchemaNotFoundException;
1: import com.facebook.presto.spi.SchemaTableName;
1: import com.facebook.presto.spi.SchemaTablePrefix;
1: import com.facebook.presto.spi.connector.ConnectorMetadata;
1: import com.facebook.presto.spi.type.BigintType;
1: import com.facebook.presto.spi.type.BooleanType;
1: import com.facebook.presto.spi.type.DateType;
1: import com.facebook.presto.spi.type.DecimalType;
1: import com.facebook.presto.spi.type.DoubleType;
1: import com.facebook.presto.spi.type.IntegerType;
1: import com.facebook.presto.spi.type.SmallintType;
1: import com.facebook.presto.spi.type.TimestampType;
1: import com.facebook.presto.spi.type.Type;
1: import com.facebook.presto.spi.type.VarcharType;
1: import com.google.common.collect.ImmutableList;
1: import com.google.common.collect.ImmutableMap;
0: import static org.apache.carbondata.presto.Types.checkType;
/////////////////////////////////////////////////////////////////////////
1:       ColumnSchema columnSchema = col.getColumnSchema();
1:       Type columnType = carbonDataType2SpiMapper(columnSchema);
1:       String extraValues =
1:           columnSchema.getEncodingList().stream().map(encoding -> encoding.toString() + " ")
1:               .reduce("", String::concat);
1:       ColumnMetadata columnMeta =
1:           new ColumnMetadata(columnSchema.getColumnName(), columnType, "", extraValues, false);
/////////////////////////////////////////////////////////////////////////
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
0:               column.getSchemaOrdinal(), column.getKeyOrdinal(), column.getColumnGroupOrdinal(),
0:               false, cs.getColumnGroupId(), cs.getColumnUniqueId(), cs.isUseInvertedIndex(),
0:               cs.getPrecision(), cs.getScale()));
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType,
0:               cs.getSchemaOrdinal(), measure.getOrdinal(), cs.getColumnGroupId(), true,
0:               cs.getColumnGroupId(), cs.getColumnUniqueId(), cs.isUseInvertedIndex(),
0:               cs.getPrecision(), cs.getScale()));
/////////////////////////////////////////////////////////////////////////
0:       return new CarbondataTableHandle(connectorId, tableName);
/////////////////////////////////////////////////////////////////////////
1:         new CarbondataTableLayoutHandle(handle, constraint.getSummary()));
commit:e5e74fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     List<String> schemaNameList = carbonTableReader.getSchemaNames();;
commit:9669c0b
/////////////////////////////////////////////////////////////////////////
0:       Type columnType = CarbondataType2SpiMapper(col.getColumnSchema());
0:       ColumnMetadata columnMeta = new ColumnMetadata(col.getColumnSchema().getColumnName(), columnType);
/////////////////////////////////////////////////////////////////////////
0:       Type spiType = CarbondataType2SpiMapper(cs);
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
0:       Type spiType = CarbondataType2SpiMapper(cs);
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex(), cs.getPrecision(), cs.getScale()));
/////////////////////////////////////////////////////////////////////////
0:   public static Type CarbondataType2SpiMapper(ColumnSchema columnSchema) {
1:     DataType colType = columnSchema.getDataType();
/////////////////////////////////////////////////////////////////////////
0:         if(columnSchema.getPrecision() > 0){
1:           return DecimalType.createDecimalType(columnSchema.getPrecision(), columnSchema.getScale());
1:         } else {
1:           return DecimalType.createDecimalType();
1:         }
commit:abffb4a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
/////////////////////////////////////////////////////////////////////////
0:     List<CarbonColumn> carbonColumns = cb.getCreateOrderColumn(tableName.getTableName());
1:     for (CarbonColumn col : carbonColumns) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, column.getSchemaOrdinal(),
/////////////////////////////////////////////////////////////////////////
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, cs.getSchemaOrdinal(),
author:anubhav100
-------------------------------------------------------------------------------
commit:dc4f87b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastore.impl.FileFactory;
0: import org.apache.carbondata.presto.impl.CarbonTableConfig;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.hadoop.fs.s3a.Constants.ACCESS_KEY;
0: import static org.apache.hadoop.fs.s3a.Constants.ENDPOINT;
0: import static org.apache.hadoop.fs.s3a.Constants.SECRET_KEY;
commit:15ab6b0
/////////////////////////////////////////////////////////////////////////
0:         if(!tableName.equalsIgnoreCase(".DS_Store"))
author:xuchuanyin
-------------------------------------------------------------------------------
commit:910d496
/////////////////////////////////////////////////////////////////////////
1:     return carbonTableReader.getSchemaNames();
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(colType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
1:     if (colType == DataTypes.BOOLEAN) {
1:       return BooleanType.BOOLEAN;
1:     } else if (colType == DataTypes.SHORT) {
1:       return SmallintType.SMALLINT;
1:     } else if (colType == DataTypes.INT) {
1:       return IntegerType.INTEGER;
1:     } else if (colType == DataTypes.LONG) {
1:       return BigintType.BIGINT;
1:     } else if (colType == DataTypes.FLOAT || colType == DataTypes.DOUBLE) {
1:       return DoubleType.DOUBLE;
0:     } else if (colType == DataTypes.DECIMAL) {
1:       if (columnSchema.getPrecision() > 0) {
0:         return DecimalType.createDecimalType(columnSchema.getPrecision(), columnSchema.getScale());
1:       } else {
0:         return DecimalType.createDecimalType();
1:       }
1:     } else if (colType == DataTypes.STRING) {
1:       return VarcharType.VARCHAR;
1:     } else if (colType == DataTypes.DATE) {
1:       return DateType.DATE;
1:     } else if (colType == DataTypes.TIMESTAMP) {
1:       return TimestampType.TIMESTAMP;
1:     } else {
1:       return VarcharType.VARCHAR;
author:Raghunandan S
-------------------------------------------------------------------------------
commit:110f9b2
/////////////////////////////////////////////////////////////////////////
0:       Type columnType = carbonDataType2SpiMapper(col.getColumnSchema());
/////////////////////////////////////////////////////////////////////////
1:       Type spiType = carbonDataType2SpiMapper(cs);
/////////////////////////////////////////////////////////////////////////
1:       Type spiType = carbonDataType2SpiMapper(cs);
/////////////////////////////////////////////////////////////////////////
1:   public static Type carbonDataType2SpiMapper(ColumnSchema columnSchema) {
author:Geetika Gupta
-------------------------------------------------------------------------------
commit:c7e7f70
/////////////////////////////////////////////////////////////////////////
1:       throw new SchemaNotFoundException(schemaTableName.getSchemaName());
author:jatin
-------------------------------------------------------------------------------
commit:92d1d97
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:chenliang613
-------------------------------------------------------------------------------
commit:7c0e660
/////////////////////////////////////////////////////////////////////////
0:     List<String> schemaNameList;
0:       schemaNameList = carbonTableReader.getSchemaNames();
0:     return schemaNameList;
/////////////////////////////////////////////////////////////////////////
1:   private ConnectorTableMetadata getTableMetadata(SchemaTableName schemaTableName) {
1:     if (!listSchemaNamesInternal().contains(schemaTableName.getSchemaName())) {
1:     CarbonTable carbonTable = carbonTableReader.getTable(schemaTableName);
0:     if (carbonTable == null) {
1:     List<ColumnMetadata> columnsMetaList = new LinkedList<>();
0:     List<CarbonColumn> carbonColumns = carbonTable.getCreateOrderColumn(schemaTableName.getTableName());
0:       Type columnType = CarbondataType2SpiMapper(col.getColumnSchema().getDataType());
0:       ColumnMetadata columnMeta = new ColumnMetadata(col.getColumnSchema().getColumnName(),
0:           columnType);
1:       columnsMetaList.add(columnMeta);
1:     return new ConnectorTableMetadata(schemaTableName, columnsMetaList);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:0e93a3f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.presto;
1: 
0: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
0: import org.apache.carbondata.presto.impl.CarbonTableReader;
0: import com.facebook.presto.spi.*;
0: import com.facebook.presto.spi.classloader.ThreadContextClassLoader;
0: import com.facebook.presto.spi.connector.ConnectorMetadata;
0: import com.facebook.presto.spi.type.*;
0: import com.google.common.collect.ImmutableList;
0: import com.google.common.collect.ImmutableMap;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1: 
0: import javax.inject.Inject;
0: import java.util.*;
1: 
0: import static org.apache.carbondata.presto.Types.checkType;
1: import static com.google.common.base.Preconditions.checkArgument;
0: import static java.util.Objects.requireNonNull;
1: 
1: public class CarbondataMetadata implements ConnectorMetadata {
1:   private final String connectorId;
1:   private CarbonTableReader carbonTableReader;
0:   private ClassLoader classLoader;
1: 
1:   private Map<String, ColumnHandle> columnHandleMap;
1: 
1:   @Inject public CarbondataMetadata(CarbondataConnectorId connectorId, CarbonTableReader reader) {
1:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
1:     this.carbonTableReader = requireNonNull(reader, "client is null");
1:   }
1: 
0:   public void putClassLoader(ClassLoader classLoader) {
0:     this.classLoader = classLoader;
1:   }
1: 
1:   @Override public List<String> listSchemaNames(ConnectorSession session) {
1:     return listSchemaNamesInternal();
1:   }
1: 
1:   public List<String> listSchemaNamesInternal() {
0:     List<String> ret;
0:     try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
0:       ret = carbonTableReader.getSchemaNames();
1:     }
0:     return ret;
1:   }
1: 
1:   @Override
1:   public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull) {
1: 
0:         /*List<SchemaTableName> all = carbonTableReader.getTableList();
0:         if(schemaNameOrNull != null)
0:         {
0:             return all.stream().filter(a -> schemaNameOrNull.equals(a.getSchemaName())).collect(Collectors.toList());
1:         }
0:         return all;*/
1: 
1:     List<String> schemaNames;
1:     if (schemaNameOrNull != null) {
1:       schemaNames = ImmutableList.of(schemaNameOrNull);
0:     } else {
1:       schemaNames = carbonTableReader.getSchemaNames();
1:     }
1: 
1:     ImmutableList.Builder<SchemaTableName> builder = ImmutableList.builder();
1:     for (String schemaName : schemaNames) {
1:       for (String tableName : carbonTableReader.getTableNames(schemaName)) {
0:         builder.add(new SchemaTableName(schemaName, tableName));
1:       }
1:     }
1:     return builder.build();
1:   }
1: 
1:   @Override
1:   public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session,
1:       SchemaTablePrefix prefix) {
1:     requireNonNull(prefix, "SchemaTablePrefix is null");
1: 
1:     ImmutableMap.Builder<SchemaTableName, List<ColumnMetadata>> columns = ImmutableMap.builder();
1:     for (SchemaTableName tableName : listTables(session, prefix)) {
1:       ConnectorTableMetadata tableMetadata = getTableMetadata(tableName);
1:       if (tableMetadata != null) {
1:         columns.put(tableName, tableMetadata.getColumns());
1:       }
1:     }
1:     return columns.build();
1:   }
1: 
1:   //if prefix is null. return all tables
1:   //if prefix is not null, just return this table
1:   private List<SchemaTableName> listTables(ConnectorSession session, SchemaTablePrefix prefix) {
1:     if (prefix.getSchemaName() == null) {
1:       return listTables(session, prefix.getSchemaName());
1:     }
1:     return ImmutableList.of(new SchemaTableName(prefix.getSchemaName(), prefix.getTableName()));
1:   }
1: 
0:   private ConnectorTableMetadata getTableMetadata(SchemaTableName tableName) {
0:     if (!listSchemaNamesInternal().contains(tableName.getSchemaName())) {
0:       return null;
1:     }
1: 
0:     CarbonTable cb = carbonTableReader.getTable(tableName);
0:     if (cb == null) {
0:       return null;
1:     }
1: 
0:     List<ColumnMetadata> spiCols = new LinkedList<>();
0:     List<CarbonColumn> carbonColumns = cb.getCreateOrderColumn(tableName.getTableName());
0:     for (CarbonColumn col : carbonColumns) {
1:       //show columns command will return these data
0:       Type spiType = CarbondataType2SpiMapper(col.getColumnSchema().getDataType());
0:       ColumnMetadata spiCol = new ColumnMetadata(col.getColumnSchema().getColumnName(), spiType);
0:       spiCols.add(spiCol);
1:     }
1: 
1:     //carbondata connector's table metadata
0:     return new ConnectorTableMetadata(tableName, spiCols);
1:   }
1: 
1:   @Override public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session,
1:       ConnectorTableHandle tableHandle) {
1: 
1:     CarbondataTableHandle handle =
1:         checkType(tableHandle, CarbondataTableHandle.class, "tableHandle");
1:     checkArgument(handle.getConnectorId().equals(connectorId),
1:         "tableHandle is not for this connector");
1: 
1:     String schemaName = handle.getSchemaTableName().getSchemaName();
1:     if (!listSchemaNamesInternal().contains(schemaName)) {
1:       throw new SchemaNotFoundException(schemaName);
1:     }
1: 
1:     //CarbonTable(official struct) is stored in CarbonMetadata(official struct)
1:     CarbonTable cb = carbonTableReader.getTable(handle.getSchemaTableName());
0:     if (cb == null) {
0:       throw new TableNotFoundException(handle.getSchemaTableName());
1:     }
1: 
1:     ImmutableMap.Builder<String, ColumnHandle> columnHandles = ImmutableMap.builder();
1:     String tableName = handle.getSchemaTableName().getTableName();
1:     for (CarbonDimension column : cb.getDimensionByTableName(tableName)) {
1:       ColumnSchema cs = column.getColumnSchema();
1: 
0:       int complex = column.getComplexTypeOrdinal();
0:       column.getNumberOfChild();
0:       column.getListOfChildDimensions();
1: 
0:       Type spiType = CarbondataType2SpiMapper(cs.getDataType());
1:       columnHandles.put(cs.getColumnName(),
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, column.getSchemaOrdinal(),
0:               column.getKeyOrdinal(), column.getColumnGroupOrdinal(), false, cs.getColumnGroupId(),
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex()));
1:     }
1: 
1:     for (CarbonMeasure measure : cb.getMeasureByTableName(tableName)) {
1:       ColumnSchema cs = measure.getColumnSchema();
1: 
0:       Type spiType = CarbondataType2SpiMapper(cs.getDataType());
1:       columnHandles.put(cs.getColumnName(),
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, cs.getSchemaOrdinal(),
0:               measure.getOrdinal(), cs.getColumnGroupId(), true, cs.getColumnGroupId(),
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex()));
1:     }
1: 
0:     //should i cache it?
1:     columnHandleMap = columnHandles.build();
1: 
1:     return columnHandleMap;
1:   }
1: 
1:   @Override public ColumnMetadata getColumnMetadata(ConnectorSession session,
1:       ConnectorTableHandle tableHandle, ColumnHandle columnHandle) {
1: 
1:     checkType(tableHandle, CarbondataTableHandle.class, "tableHandle");
1:     return checkType(columnHandle, CarbondataColumnHandle.class, "columnHandle")
1:         .getColumnMetadata();
1:   }
1: 
1:   @Override
1:   public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName) {
0:     //check tablename is valid
0:     //schema is exist
0:     //tables is exist
1: 
0:     //CarbondataTable  get from jar
0:     return new CarbondataTableHandle(connectorId, tableName);
1:   }
1: 
1:   @Override public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session,
1:       ConnectorTableHandle table, Constraint<ColumnHandle> constraint,
1:       Optional<Set<ColumnHandle>> desiredColumns) {
1:     CarbondataTableHandle handle = checkType(table, CarbondataTableHandle.class, "table");
1:     ConnectorTableLayout layout = new ConnectorTableLayout(
0:         new CarbondataTableLayoutHandle(handle, constraint.getSummary()/*, constraint.getPredicateMap(),constraint.getFilterTuples()*/));
1:     return ImmutableList.of(new ConnectorTableLayoutResult(layout, constraint.getSummary()));
1:   }
1: 
1:   @Override public ConnectorTableLayout getTableLayout(ConnectorSession session,
1:       ConnectorTableLayoutHandle handle) {
1:     return new ConnectorTableLayout(handle);
1:   }
1: 
1:   @Override public ConnectorTableMetadata getTableMetadata(ConnectorSession session,
1:       ConnectorTableHandle table) {
1:     return getTableMetadataInternal(table);
1:   }
1: 
1:   public ConnectorTableMetadata getTableMetadataInternal(ConnectorTableHandle table) {
1:     CarbondataTableHandle carbondataTableHandle =
1:         checkType(table, CarbondataTableHandle.class, "table");
1:     checkArgument(carbondataTableHandle.getConnectorId().equals(connectorId),
1:         "tableHandle is not for this connector");
1:     return getTableMetadata(carbondataTableHandle.getSchemaTableName());
1:   }
1: 
0:   public static Type CarbondataType2SpiMapper(DataType colType) {
0:     switch (colType) {
0:       case BOOLEAN:
0:         return BooleanType.BOOLEAN;
0:       case SHORT:
0:         return SmallintType.SMALLINT;
0:       case INT:
0:         return IntegerType.INTEGER;
0:       case LONG:
0:         return BigintType.BIGINT;
0:       case FLOAT:
0:       case DOUBLE:
0:         return DoubleType.DOUBLE;
1: 
0:       case DECIMAL:
0:         return DecimalType.createDecimalType();
0:       case STRING:
0:         return VarcharType.VARCHAR;
0:       case DATE:
0:         return DateType.DATE;
0:       case TIMESTAMP:
0:         return TimestampType.TIMESTAMP;
1: 
0:             /*case DataType.MAP:
0:             case DataType.ARRAY:
0:             case DataType.STRUCT:
0:             case DataType.NULL:*/
1: 
0:       default:
0:         return VarcharType.VARCHAR;
1:     }
1:   }
1: 
1: }
commit:7ee8e27
/////////////////////////////////////////////////////////////////////////
commit:2712330
/////////////////////////////////////////////////////////////////////////
0: public class CarbondataMetadata implements ConnectorMetadata {
0:   private final String connectorId;
0:   private CarbonTableReader carbonTableReader;
0:   private ClassLoader classLoader;
0:   private Map<String, ColumnHandle> columnHandleMap;
0:   @Inject public CarbondataMetadata(CarbondataConnectorId connectorId, CarbonTableReader reader) {
0:     this.connectorId = requireNonNull(connectorId, "connectorId is null").toString();
0:     this.carbonTableReader = requireNonNull(reader, "client is null");
0:   }
0: 
0:   public void putClassLoader(ClassLoader classLoader) {
0:     this.classLoader = classLoader;
0:   }
0: 
0:   @Override public List<String> listSchemaNames(ConnectorSession session) {
0:     return listSchemaNamesInternal();
0:   }
0: 
0:   public List<String> listSchemaNamesInternal() {
0:     List<String> ret;
0:     try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
0:       ret = carbonTableReader.getSchemaNames();
0:     return ret;
0:   }
0:   @Override
0:   public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull) {
/////////////////////////////////////////////////////////////////////////
0:     List<String> schemaNames;
0:     if (schemaNameOrNull != null) {
0:       schemaNames = ImmutableList.of(schemaNameOrNull);
0:     } else {
0:       schemaNames = carbonTableReader.getSchemaNames();
0:     ImmutableList.Builder<SchemaTableName> builder = ImmutableList.builder();
0:     for (String schemaName : schemaNames) {
0:       for (String tableName : carbonTableReader.getTableNames(schemaName)) {
0:         builder.add(new SchemaTableName(schemaName, tableName));
0:       }
0:     }
0:     return builder.build();
0:   }
0:   @Override
0:   public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session,
0:       SchemaTablePrefix prefix) {
0:     requireNonNull(prefix, "SchemaTablePrefix is null");
0: 
0:     ImmutableMap.Builder<SchemaTableName, List<ColumnMetadata>> columns = ImmutableMap.builder();
0:     for (SchemaTableName tableName : listTables(session, prefix)) {
0:       ConnectorTableMetadata tableMetadata = getTableMetadata(tableName);
0:       if (tableMetadata != null) {
0:         columns.put(tableName, tableMetadata.getColumns());
0:       }
0:     }
0:     return columns.build();
0:   }
0: 
0:   //if prefix is null. return all tables
0:   //if prefix is not null, just return this table
0:   private List<SchemaTableName> listTables(ConnectorSession session, SchemaTablePrefix prefix) {
0:     if (prefix.getSchemaName() == null) {
0:       return listTables(session, prefix.getSchemaName());
0:     }
0:     return ImmutableList.of(new SchemaTableName(prefix.getSchemaName(), prefix.getTableName()));
0:   }
0: 
0:   private ConnectorTableMetadata getTableMetadata(SchemaTableName tableName) {
0:     if (!listSchemaNamesInternal().contains(tableName.getSchemaName())) {
0:       return null;
0:     CarbonTable cb = carbonTableReader.getTable(tableName);
0:     if (cb == null) {
0:       return null;
0:     List<ColumnMetadata> spiCols = new LinkedList<>();
0:     List<CarbonDimension> cols = cb.getDimensionByTableName(tableName.getTableName());
0:     for (CarbonDimension col : cols) {
0:       //show columns command will return these data
0:       Type spiType = CarbondataType2SpiMapper(col.getColumnSchema().getDataType());
0:       ColumnMetadata spiCol = new ColumnMetadata(col.getColumnSchema().getColumnName(), spiType);
0:       spiCols.add(spiCol);
0:     List<CarbonMeasure> mcols = cb.getMeasureByTableName(tableName.getTableName());
0:     for (CarbonMeasure mcol : mcols) {
0:       Type spiType = CarbondataType2SpiMapper(mcol.getColumnSchema().getDataType());
0:       ColumnMetadata spiCol = new ColumnMetadata(mcol.getColumnSchema().getColumnName(), spiType);
0:       spiCols.add(spiCol);
0:     //封装carbonTable
0:     return new ConnectorTableMetadata(tableName, spiCols);
0:   }
0:   @Override public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session,
0:       ConnectorTableHandle tableHandle) {
0: 
0:     CarbondataTableHandle handle =
0:     checkArgument(handle.getConnectorId().equals(connectorId),
0:         "tableHandle is not for this connector");
0: 
0:     String schemaName = handle.getSchemaTableName().getSchemaName();
0:     if (!listSchemaNamesInternal().contains(schemaName)) {
0:       throw new SchemaNotFoundException(schemaName);
0:     //CarbonTable(official struct) is stored in CarbonMetadata(official struct)
0:     CarbonTable cb = carbonTableReader.getTable(handle.getSchemaTableName());
0:     if (cb == null) {
0:       throw new TableNotFoundException(handle.getSchemaTableName());
0:     ImmutableMap.Builder<String, ColumnHandle> columnHandles = ImmutableMap.builder();
0:     int index = 0;
0:     String tableName = handle.getSchemaTableName().getTableName();
0:     for (CarbonDimension column : cb.getDimensionByTableName(tableName)) {
0:       ColumnSchema cs = column.getColumnSchema();
0: 
0:       int complex = column.getComplexTypeOrdinal();
0:       column.getNumberOfChild();
0:       column.getListOfChildDimensions();
0: 
0:       Type spiType = CarbondataType2SpiMapper(cs.getDataType());
0:       columnHandles.put(cs.getColumnName(),
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, index,
0:               column.getKeyOrdinal(), column.getColumnGroupOrdinal(), false, cs.getColumnGroupId(),
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex()));
0:       index++;
0:     for (CarbonMeasure measure : cb.getMeasureByTableName(tableName)) {
0:       ColumnSchema cs = measure.getColumnSchema();
0: 
0:       Type spiType = CarbondataType2SpiMapper(cs.getDataType());
0:       columnHandles.put(cs.getColumnName(),
0:           new CarbondataColumnHandle(connectorId, cs.getColumnName(), spiType, index,
0:               measure.getOrdinal(), cs.getColumnGroupId(), true, cs.getColumnGroupId(),
0:               cs.getColumnUniqueId(), cs.isUseInvertedIndex()));
0:       index++;
0:     //should i cache it?
0:     columnHandleMap = columnHandles.build();
0:     return columnHandleMap;
0:   }
0:   @Override public ColumnMetadata getColumnMetadata(ConnectorSession session,
0:       ConnectorTableHandle tableHandle, ColumnHandle columnHandle) {
0:     checkType(tableHandle, CarbondataTableHandle.class, "tableHandle");
0:     return checkType(columnHandle, CarbondataColumnHandle.class, "columnHandle")
0:         .getColumnMetadata();
0:   }
0:   @Override
0:   public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName) {
0:     //check tablename is valid
0:     //schema is exist
0:     //tables is exist
0: 
0:     //CarbondataTable  get from jar
0:     return new CarbondataTableHandle(connectorId, tableName);
0:   }
0: 
0:   @Override public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session,
0:       ConnectorTableHandle table, Constraint<ColumnHandle> constraint,
0:       Optional<Set<ColumnHandle>> desiredColumns) {
0:     CarbondataTableHandle handle = checkType(table, CarbondataTableHandle.class, "table");
0:     ConnectorTableLayout layout = new ConnectorTableLayout(
0:         new CarbondataTableLayoutHandle(handle, constraint.getSummary()/*, constraint.getPredicateMap(),constraint.getFilterTuples()*/));
0:     return ImmutableList.of(new ConnectorTableLayoutResult(layout, constraint.getSummary()));
0:   }
0: 
0:   @Override public ConnectorTableLayout getTableLayout(ConnectorSession session,
0:       ConnectorTableLayoutHandle handle) {
0:     return new ConnectorTableLayout(handle);
0:   }
0: 
0:   @Override public ConnectorTableMetadata getTableMetadata(ConnectorSession session,
0:       ConnectorTableHandle table) {
0:     return getTableMetadataInternal(table);
0:   }
0: 
0:   public ConnectorTableMetadata getTableMetadataInternal(ConnectorTableHandle table) {
0:     CarbondataTableHandle carbondataTableHandle =
0:         checkType(table, CarbondataTableHandle.class, "table");
0:     checkArgument(carbondataTableHandle.getConnectorId().equals(connectorId),
0:         "tableHandle is not for this connector");
0:     return getTableMetadata(carbondataTableHandle.getSchemaTableName());
0:   }
0: 
0:   public static Type CarbondataType2SpiMapper(DataType colType) {
0:     switch (colType) {
0:       case BOOLEAN:
0:         return BooleanType.BOOLEAN;
0:       case SHORT:
0:         return SmallintType.SMALLINT;
0:       case INT:
0:         return IntegerType.INTEGER;
0:       case LONG:
0:         return BigintType.BIGINT;
0:       case FLOAT:
0:       case DOUBLE:
0:         return DoubleType.DOUBLE;
0: 
0:       case DECIMAL:
0:         return DecimalType.createDecimalType();
0:       case STRING:
0:         return VarcharType.VARCHAR;
0:       case DATE:
0:         return DateType.DATE;
0:       case TIMESTAMP:
0:         return TimestampType.TIMESTAMP;
0:       default:
0:         return VarcharType.VARCHAR;
0:   }
commit:9e3818e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.presto.impl.CarbonTableReader;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.carbondata.presto.Types.checkType;
commit:32bf296
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *    http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: 
0: package org.apache.carbondata.presto;
commit:9d7dbea
author:ffpeng90
-------------------------------------------------------------------------------
commit:4422c52
/////////////////////////////////////////////////////////////////////////
============================================================================