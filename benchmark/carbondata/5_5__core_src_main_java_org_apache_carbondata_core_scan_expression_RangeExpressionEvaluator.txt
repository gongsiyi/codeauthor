1:c2e4eb2: /*
1:c2e4eb2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c2e4eb2:  * contributor license agreements.  See the NOTICE file distributed with
1:c2e4eb2:  * this work for additional information regarding copyright ownership.
1:c2e4eb2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c2e4eb2:  * (the "License"); you may not use this file except in compliance with
1:c2e4eb2:  * the License.  You may obtain a copy of the License at
1:c2e4eb2:  *
1:c2e4eb2:  *    http://www.apache.org/licenses/LICENSE-2.0
1:c2e4eb2:  *
1:c2e4eb2:  * Unless required by applicable law or agreed to in writing, software
1:c2e4eb2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c2e4eb2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c2e4eb2:  * See the License for the specific language governing permissions and
1:c2e4eb2:  * limitations under the License.
1:c2e4eb2:  */
1:c2e4eb2: 
1:c2e4eb2: package org.apache.carbondata.core.scan.expression;
1:c2e4eb2: 
1:c2e4eb2: import java.util.ArrayList;
1:c2e4eb2: import java.util.HashMap;
1:500654e: import java.util.Iterator;
1:c2e4eb2: import java.util.List;
1:c2e4eb2: import java.util.Map;
1:c2e4eb2: 
1:3af2d65: import org.apache.carbondata.common.logging.LogService;
1:3af2d65: import org.apache.carbondata.common.logging.LogServiceFactory;
1:c2e4eb2: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:c2e4eb2: import org.apache.carbondata.core.metadata.datatype.DataType;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.RangeExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.expression.logical.TrueExpression;
1:c2e4eb2: import org.apache.carbondata.core.scan.filter.intf.ExpressionType;
1:c2e4eb2: 
1:c2e4eb2: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.FALSE;
1:c2e4eb2: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.GREATERTHAN;
1:c2e4eb2: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.GREATERTHAN_EQUALTO;
1:c2e4eb2: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.LESSTHAN;
1:c2e4eb2: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.LESSTHAN_EQUALTO;
1:c2e4eb2: 
1:c2e4eb2: public class RangeExpressionEvaluator {
1:3af2d65:   private static final LogService LOG =
1:3af2d65:       LogServiceFactory.getLogService(RangeExpressionEvaluator.class.getName());
1:c2e4eb2:   private Expression expr;
1:c2e4eb2:   private Expression srcNode;
1:c2e4eb2:   private Expression tarNode;
1:c2e4eb2:   private Expression tarParentNode;
1:c2e4eb2: 
1:c2e4eb2:   public RangeExpressionEvaluator(Expression expr) {
1:c2e4eb2:     this.expr = expr;
5:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   public Expression getExpr() {
1:c2e4eb2:     return expr;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   public void setExpr(Expression expr) {
1:c2e4eb2:     this.expr = expr;
1:c2e4eb2:   }
1:c2e4eb2: 
1:daa6465:   private Expression getSrcNode() {
1:c2e4eb2:     return srcNode;
1:c2e4eb2:   }
1:c2e4eb2: 
1:daa6465:   private void setTarNode(Expression expr) {
1:c2e4eb2:     this.tarNode = expr;
1:c2e4eb2:   }
1:c2e4eb2: 
1:daa6465:   private void setTarParentNode(Expression expr) {
1:c2e4eb2:     this.tarParentNode = expr;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method evaluates is any greaterthan or less than expression can be transformed
1:c2e4eb2:    * into a single RANGE filter.
1:c2e4eb2:    */
1:c2e4eb2:   public void rangeExpressionEvaluatorMapBased() {
1:c2e4eb2:     // The algorithm :
1:c2e4eb2:     // Get all the nodes of the Expression Tree and fill it into a MAP.
1:c2e4eb2:     // The Map structure will be currentNode, ColumnName, LessThanOrgreaterThan, Value, ParentNode
1:c2e4eb2:     // Group the rows in MAP according to the columns and then evaluate if it can be transformed
1:c2e4eb2:     // into a RANGE or not.
1:c2e4eb2:     //
1:c2e4eb2:     //            AND                                           AND
1:c2e4eb2:     //             |                                             |
1:c2e4eb2:     //            / \                                           / \
1:c2e4eb2:     //           /   \                                         /   \
1:c2e4eb2:     //        Less   Greater         =>                    TRUE   Range
1:c2e4eb2:     //         / \    / \                                         / \
1:c2e4eb2:     //        /   \  /   \                                       /   \
1:c2e4eb2:     //       a    10 a   5                                   Less   greater
1:c2e4eb2:     //                                                        /\      /\
1:c2e4eb2:     //                                                       /  \    /  \
1:c2e4eb2:     //                                                      a   10  a    5
1:c2e4eb2:     //
1:c2e4eb2: 
1:c2e4eb2:     Map<String, List<FilterModificationNode>> filterExpressionMap;
1:c2e4eb2:     filterExpressionMap = convertFilterTreeToMap();
1:c2e4eb2:     replaceWithRangeExpression(filterExpressionMap);
1:c2e4eb2:     filterExpressionMap.clear();
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   public void replaceWithRangeExpression(
1:c2e4eb2:       Map<String, List<FilterModificationNode>> filterExpressionMap) {
1:c2e4eb2: 
1:c2e4eb2:     List<FilterModificationNode> deleteExp = new ArrayList<>();
1:500654e:     Iterator<Map.Entry<String, List<FilterModificationNode>>> iterator =
1:500654e:         filterExpressionMap.entrySet().iterator();
1:500654e:     Map.Entry<String, List<FilterModificationNode>> nextEntry = null;
1:500654e:     while (iterator.hasNext()) {
1:500654e:       nextEntry = iterator.next();
1:500654e:       List<FilterModificationNode> filterExp = nextEntry.getValue();
1:c2e4eb2:       if (filterExp.size() > 1) {
1:c2e4eb2:         // There are multiple Expression for the same column traverse and check if they can
1:c2e4eb2:         // form a range.
1:c2e4eb2:         FilterModificationNode startMin = null;
1:c2e4eb2:         FilterModificationNode endMax = null;
1:c2e4eb2: 
1:c2e4eb2:         for (FilterModificationNode exp : filterExp) {
1:c2e4eb2:           if ((exp.getExpType() == GREATERTHAN) || (exp.getExpType() == GREATERTHAN_EQUALTO)) {
1:500654e:             if ((null == endMax) || ((checkLiteralValue(exp.getCurrentExp(),
1:500654e:                 endMax.getCurrentExp())))) {
1:c2e4eb2:               if (null == startMin) {
1:c2e4eb2:                 startMin = exp;
4:c2e4eb2:               } else {
1:c2e4eb2:                 // There is already some value in startMin so check which one is greater.
1:c2e4eb2:                 LiteralExpression srcLiteral = getChildLiteralExpression(startMin.getCurrentExp());
1:c2e4eb2:                 LiteralExpression tarLiteral = getChildLiteralExpression(exp.getCurrentExp());
1:c2e4eb2: 
1:c2e4eb2:                 ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:c2e4eb2:                 ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1:c2e4eb2:                 if (srcExpResult.compareTo(tarExpResult) < 0) {
1:c2e4eb2:                   // Before replacing the startMin add the current StartMin into deleteExp List
1:c2e4eb2:                   // as they will be replaced with TRUE expression after RANGE formation.
1:c2e4eb2:                   deleteExp.add(startMin);
1:c2e4eb2:                   startMin = exp;
1:c2e4eb2:                 }
1:c2e4eb2:               }
1:c2e4eb2:             }
1:c2e4eb2:           }
1:c2e4eb2:           if ((exp.getExpType() == LESSTHAN) || (exp.getExpType() == LESSTHAN_EQUALTO)) {
1:500654e:             if ((null == startMin) || ((checkLiteralValue(exp.getCurrentExp(),
1:500654e:                 startMin.getCurrentExp())))) {
1:c2e4eb2:               if (null == endMax) {
1:c2e4eb2:                 endMax = exp;
1:c2e4eb2:               } else {
1:c2e4eb2:                 // There is already some value in endMax so check which one is less.
1:c2e4eb2:                 LiteralExpression srcLiteral = getChildLiteralExpression(endMax.getCurrentExp());
1:c2e4eb2:                 LiteralExpression tarLiteral = getChildLiteralExpression(exp.getCurrentExp());
1:c2e4eb2: 
1:c2e4eb2:                 ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:c2e4eb2:                 ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1:c2e4eb2:                 if (srcExpResult.compareTo(tarExpResult) > 0) {
1:c2e4eb2:                   // Before replacing the endMax add the current endMax into deleteExp List
1:c2e4eb2:                   // as they will be replaced with TRUE expression after RANGE formation.
1:c2e4eb2:                   deleteExp.add(endMax);
1:c2e4eb2:                   endMax = exp;
1:c2e4eb2:                 }
1:c2e4eb2:               }
1:c2e4eb2:             }
1:c2e4eb2:           }
1:c2e4eb2:         }
1:c2e4eb2: 
1:c2e4eb2:         if ((null != startMin) && (null != endMax)) {
1:3af2d65:           LOG.info(
1:3af2d65:               "GreaterThan and LessThan Filter Expression changed to Range Expression for column "
1:500654e:                   + nextEntry.getKey());
1:c2e4eb2:           // the node can be converted to RANGE.
1:c2e4eb2:           Expression n1 = startMin.getCurrentExp();
1:c2e4eb2:           Expression n2 = endMax.getCurrentExp();
1:c2e4eb2: 
1:c2e4eb2:           RangeExpression rangeTree = new RangeExpression(n1, n2);
1:c2e4eb2:           Expression srcParentNode = startMin.getParentExp();
1:c2e4eb2:           Expression tarParentNode = endMax.getParentExp();
1:c2e4eb2: 
1:c2e4eb2:           srcParentNode.findAndSetChild(startMin.getCurrentExp(), rangeTree);
1:c2e4eb2:           tarParentNode.findAndSetChild(endMax.getCurrentExp(), new TrueExpression(null));
1:c2e4eb2: 
1:c2e4eb2:           if (deleteExp.size() > 0) {
1:c2e4eb2:             // There are some expression to Delete as they are Redundant after Range Formation.
1:c2e4eb2:             for (FilterModificationNode trueExp : deleteExp) {
1:c2e4eb2:               trueExp.getParentExp()
1:c2e4eb2:                   .findAndSetChild(trueExp.getCurrentExp(), new TrueExpression(null));
1:c2e4eb2:             }
1:c2e4eb2:           }
1:c2e4eb2:         }
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2: 
1:c2e4eb2:   private Map<String, List<FilterModificationNode>> convertFilterTreeToMap() {
1:c2e4eb2:     // Traverse the Filter Tree and add the nodes in filterExpressionMap.
1:c2e4eb2:     // Only those nodes will be added which has got LessThan, LessThanEqualTo
1:c2e4eb2:     // GreaterThan, GreaterThanEqualTo Expression Only.
1:c2e4eb2:     Map<String, List<FilterModificationNode>> filterExpressionMap =
1:c2e4eb2:         new HashMap<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:c2e4eb2: 
1:c2e4eb2:     // Traverse the Tree.
1:c2e4eb2:     fillExpressionMap(filterExpressionMap, null, null);
1:c2e4eb2: 
1:c2e4eb2:     return filterExpressionMap;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2: 
1:c2e4eb2:   private void fillExpressionMap(Map<String, List<FilterModificationNode>> filterExpressionMap,
1:c2e4eb2:       Expression currentNode, Expression parentNode) {
1:c2e4eb2:     if (null == currentNode) {
1:c2e4eb2:       currentNode = this.getExpr();
1:c2e4eb2:       parentNode  = currentNode;
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     // if the parentNode is a ANDExpression and the current node is LessThan, GreaterThan
1:c2e4eb2:     // then add the node into filterExpressionMap.
1:c2e4eb2:     if ((parentNode instanceof AndExpression) && (isLessThanGreaterThanExp(currentNode)
1:c2e4eb2:         && eligibleForRangeExpConv(currentNode))) {
1:c2e4eb2:       addFilterExpressionMap(filterExpressionMap, currentNode, parentNode);
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     for (Expression exp : currentNode.getChildren()) {
1:c2e4eb2:       if (null != exp) {
1:c2e4eb2:         fillExpressionMap(filterExpressionMap, exp, currentNode);
1:c2e4eb2:         if (exp instanceof OrExpression) {
1:c2e4eb2:           replaceWithRangeExpression(filterExpressionMap);
1:c2e4eb2:           filterExpressionMap.clear();
1:c2e4eb2:         }
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   private void addFilterExpressionMap(Map<String, List<FilterModificationNode>> filterExpressionMap,
1:c2e4eb2:       Expression currentNode, Expression parentNode) {
1:c2e4eb2:     String colName = getColumnName(currentNode);
1:c2e4eb2:     ExpressionType expType = getExpressionType(currentNode);
1:c2e4eb2: 
1:c2e4eb2:     FilterModificationNode filterExpression =
1:daa6465:         new FilterModificationNode(currentNode, parentNode, expType);
1:c2e4eb2: 
1:c2e4eb2:     if (null == filterExpressionMap.get(colName)) {
1:c2e4eb2:       filterExpressionMap.put(colName, new ArrayList<FilterModificationNode>());
1:c2e4eb2:     }
1:c2e4eb2:     filterExpressionMap.get(colName).add(filterExpression);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method checks if the Expression is among LessThan, LessThanEqualTo,
1:c2e4eb2:    * GreaterThan or GreaterThanEqualTo
1:c2e4eb2:    *
1:c2e4eb2:    * @param expr
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean isLessThanGreaterThanExp(Expression expr) {
1:933e30c:     return (expr instanceof LessThanEqualToExpression) || (expr instanceof LessThanExpression)
1:c2e4eb2:         || (expr instanceof GreaterThanEqualToExpression)
1:933e30c:         || (expr instanceof GreaterThanExpression);
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method verifies if the Expression is qualified for Range Expression conversion.
1:c2e4eb2:    *
1:c2e4eb2:    * @param expChild
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean eligibleForRangeExpConv(Expression expChild) {
1:c2e4eb2:     for (Expression exp : expChild.getChildren()) {
1:c2e4eb2:       if (exp instanceof ColumnExpression) {
1:933e30c:         return ((ColumnExpression) exp).isDimension() &&
1:933e30c:             ! (((ColumnExpression) exp).getDimension().getDataType().isComplexType());
1:c2e4eb2:       }
1:c2e4eb2:     }
5:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method returns the Column name from the ColumnExpression ExpressionType.
1:c2e4eb2:    *
1:c2e4eb2:    * @param andNode
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private String getColumnName(Expression andNode) {
1:c2e4eb2:     // returns the Column Name from Column Expression.
1:c2e4eb2:     for (Expression exp : andNode.getChildren()) {
1:c2e4eb2:       if (exp instanceof ColumnExpression) {
1:c2e4eb2:         return ((ColumnExpression) exp).getColumnName();
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return null;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method returns the Value from the Literal ExpressionType.
1:c2e4eb2:    *
1:c2e4eb2:    * @param exp
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private Object getLiteralValue(Expression exp) {
1:c2e4eb2:     for (Expression expr : exp.getChildren()) {
1:c2e4eb2:       if (expr instanceof LiteralExpression) {
1:c2e4eb2:         return (((LiteralExpression) expr).getLiteralExpValue());
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return null;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method returns the DataType of the Literal Expression.
1:c2e4eb2:    *
1:c2e4eb2:    * @param exp
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private DataType getLiteralDataType(Expression exp) {
1:c2e4eb2:     for (Expression expr : exp.getChildren()) {
1:c2e4eb2:       if (expr instanceof LiteralExpression) {
1:c2e4eb2:         return (((LiteralExpression) expr).getLiteralExpDataType());
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return null;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method returns the DataType of the Literal Expression.
1:c2e4eb2:    *
1:c2e4eb2:    * @param exp
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private LiteralExpression getChildLiteralExpression(Expression exp) {
1:c2e4eb2:     for (Expression expr : exp.getChildren()) {
1:c2e4eb2:       if (expr instanceof LiteralExpression) {
1:c2e4eb2:         return ((LiteralExpression) expr);
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return null;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method returns the ExpressionType based on the Expression.
1:c2e4eb2:    *
1:c2e4eb2:    * @param exp
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private ExpressionType getExpressionType(Expression exp) {
1:c2e4eb2:     // return the expressionType. Note among the children of the
1:c2e4eb2:     // andNode one should be columnExpression others should be
1:c2e4eb2:     // LessThan, LessThanEqualTo, GreaterThan, GreaterThanEqualTo.
1:c2e4eb2:     //
1:c2e4eb2:     if (exp instanceof LessThanExpression) {
1:c2e4eb2:       return LESSTHAN;
1:c2e4eb2:     } else if (exp instanceof LessThanEqualToExpression) {
1:c2e4eb2:       return LESSTHAN_EQUALTO;
1:c2e4eb2:     } else if (exp instanceof GreaterThanExpression) {
1:c2e4eb2:       return GREATERTHAN;
1:c2e4eb2:     } else if (exp instanceof GreaterThanEqualToExpression) {
1:c2e4eb2:       return GREATERTHAN_EQUALTO;
1:c2e4eb2:     } else {
1:c2e4eb2:       return FALSE;
1:c2e4eb2:     }
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method checks if the Source Expression matches with Target Expression.
1:c2e4eb2:    *
1:c2e4eb2:    * @param src
1:c2e4eb2:    * @param tar
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean matchExpType(ExpressionType src, ExpressionType tar) {
1:933e30c:     return (((src == LESSTHAN) || (src == LESSTHAN_EQUALTO)) && ((tar == GREATERTHAN) || (tar
1:c2e4eb2:         == GREATERTHAN_EQUALTO))) || (((src == GREATERTHAN) || (src == GREATERTHAN_EQUALTO)) && (
1:933e30c:         (tar == LESSTHAN) || (tar == LESSTHAN_EQUALTO)));
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This Method Traverses the Expression Tree to find the corresponding node of the Range
1:c2e4eb2:    * Expression. If one node of Range Expression is LessThan then a corresponding GreaterThan
1:c2e4eb2:    * will be choosen or vice versa.
1:c2e4eb2:    *
1:c2e4eb2:    * @param currentNode
1:c2e4eb2:    * @param parentNode
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private Expression traverseTree(Expression currentNode, Expression parentNode) {
1:c2e4eb2:     Expression result = null;
1:c2e4eb2: 
1:c2e4eb2:     if (null == parentNode) {
1:c2e4eb2:       currentNode = this.getExpr();
1:c2e4eb2:       parentNode = currentNode;
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     if (!this.getSrcNode().equals(currentNode) && isLessThanGreaterThanExp(currentNode)) {
1:c2e4eb2:       String srcColumnName = getColumnName(this.getSrcNode());
1:c2e4eb2:       String tarColumnName = getColumnName(currentNode);
1:c2e4eb2:       ExpressionType srcExpType = getExpressionType(this.getSrcNode());
1:c2e4eb2:       ExpressionType tarExpType = getExpressionType(currentNode);
1:c2e4eb2: 
1:d25fee2:       if ((null != srcColumnName) && (null != tarColumnName) && (srcColumnName
1:d25fee2:           .equals(tarColumnName)) && (srcExpType != ExpressionType.FALSE) && (tarExpType
1:d25fee2:           != ExpressionType.FALSE) && ((matchExpType(srcExpType, tarExpType)) && checkLiteralValue(
1:d25fee2:           this.getSrcNode(), currentNode))) {
1:c2e4eb2:         this.setTarNode(currentNode);
1:c2e4eb2:         this.setTarParentNode(parentNode);
1:c2e4eb2:         return parentNode;
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     for (Expression exp : currentNode.getChildren()) {
1:c2e4eb2:       if (null != exp && !(exp instanceof RangeExpression)) {
1:c2e4eb2:         result = traverseTree(exp, currentNode);
1:c2e4eb2:         if (null != result) {
1:c2e4eb2:           return result;
1:c2e4eb2:         }
1:c2e4eb2:       }
1:c2e4eb2:     }
1:c2e4eb2:     return null;
1:c2e4eb2:   }
1:c2e4eb2: 
1:c2e4eb2:   /**
1:c2e4eb2:    * This method will check if the literal values attached to GreaterThan of GreaterThanEqualTo
1:c2e4eb2:    * is less or equal to LessThan and LessThanEqualTo literal.
1:c2e4eb2:    *
1:c2e4eb2:    * @param src
1:c2e4eb2:    * @param tar
1:c2e4eb2:    * @return
1:c2e4eb2:    */
1:c2e4eb2:   private boolean checkLiteralValue(Expression src, Expression tar) {
1:c2e4eb2:     ExpressionType srcExpressionType = getExpressionType(src);
1:c2e4eb2:     ExpressionType tarExpressionType = getExpressionType(tar);
1:c2e4eb2:     LiteralExpression srcLiteral = getChildLiteralExpression(src);
1:c2e4eb2:     LiteralExpression tarLiteral = getChildLiteralExpression(tar);
1:c2e4eb2: 
1:c2e4eb2:     ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:c2e4eb2:     ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1:c2e4eb2: 
1:c2e4eb2:     switch (srcExpressionType) {
1:c2e4eb2:       case LESSTHAN:
1:c2e4eb2:       case LESSTHAN_EQUALTO:
1:c2e4eb2:         switch (tarExpressionType) {
1:c2e4eb2:           case GREATERTHAN:
1:c2e4eb2:             if (srcExpResult.compareTo(tarExpResult) > 0) {
4:c2e4eb2:               return true;
1:c2e4eb2:             }
1:c2e4eb2:             break;
1:c2e4eb2:           case GREATERTHAN_EQUALTO:
1:c2e4eb2:             if (srcExpResult.compareTo(tarExpResult) >= 0) {
1:c2e4eb2:               return true;
1:c2e4eb2:             }
1:c2e4eb2:             break;
1:c2e4eb2:         }
1:c2e4eb2:         break;
1:c2e4eb2:       case GREATERTHAN:
1:c2e4eb2:       case GREATERTHAN_EQUALTO:
1:c2e4eb2:         switch (tarExpressionType) {
1:c2e4eb2:           case LESSTHAN:
1:c2e4eb2:             if (srcExpResult.compareTo(tarExpResult) < 0) {
1:c2e4eb2:               return true;
1:c2e4eb2:             }
1:c2e4eb2:             break;
1:c2e4eb2:           case LESSTHAN_EQUALTO:
1:c2e4eb2:             if (srcExpResult.compareTo(tarExpResult) <= 0) {
1:c2e4eb2:               return true;
1:c2e4eb2:             }
1:c2e4eb2:             break;
1:c2e4eb2:         }
1:c2e4eb2:         break;
1:c2e4eb2:     }
1:c2e4eb2: 
1:c2e4eb2:     return false;
1:c2e4eb2:   }
1:c2e4eb2: }
============================================================================
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private Expression getSrcNode() {
1:   private void setTarNode(Expression expr) {
1:   private void setTarParentNode(Expression expr) {
/////////////////////////////////////////////////////////////////////////
1:         new FilterModificationNode(currentNode, parentNode, expType);
commit:933e30c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return (expr instanceof LessThanEqualToExpression) || (expr instanceof LessThanExpression)
1:         || (expr instanceof GreaterThanExpression);
/////////////////////////////////////////////////////////////////////////
1:         return ((ColumnExpression) exp).isDimension() &&
1:             ! (((ColumnExpression) exp).getDimension().getDataType().isComplexType());
/////////////////////////////////////////////////////////////////////////
1:     return (((src == LESSTHAN) || (src == LESSTHAN_EQUALTO)) && ((tar == GREATERTHAN) || (tar
1:         (tar == LESSTHAN) || (tar == LESSTHAN_EQUALTO)));
commit:956833e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:         if ((((ColumnExpression) exp).getDimension().getDataType() == DataTypes.ARRAY) || (
0:             ((ColumnExpression) exp).getDimension().getDataType() == DataTypes.STRUCT)) {
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     Iterator<Map.Entry<String, List<FilterModificationNode>>> iterator =
1:         filterExpressionMap.entrySet().iterator();
1:     Map.Entry<String, List<FilterModificationNode>> nextEntry = null;
1:     while (iterator.hasNext()) {
1:       nextEntry = iterator.next();
1:       List<FilterModificationNode> filterExp = nextEntry.getValue();
/////////////////////////////////////////////////////////////////////////
1:             if ((null == endMax) || ((checkLiteralValue(exp.getCurrentExp(),
1:                 endMax.getCurrentExp())))) {
/////////////////////////////////////////////////////////////////////////
1:             if ((null == startMin) || ((checkLiteralValue(exp.getCurrentExp(),
1:                 startMin.getCurrentExp())))) {
/////////////////////////////////////////////////////////////////////////
1:                   + nextEntry.getKey());
author:dhatchayani
-------------------------------------------------------------------------------
commit:d25fee2
/////////////////////////////////////////////////////////////////////////
0:             if ((null == endMax) || checkLiteralValue(exp.getCurrentExp(),
0:                 endMax.getCurrentExp())) {
/////////////////////////////////////////////////////////////////////////
0:             if ((null == startMin) || checkLiteralValue(exp.getCurrentExp(),
0:                 startMin.getCurrentExp())) {
/////////////////////////////////////////////////////////////////////////
1:       if ((null != srcColumnName) && (null != tarColumnName) && (srcColumnName
1:           .equals(tarColumnName)) && (srcExpType != ExpressionType.FALSE) && (tarExpType
1:           != ExpressionType.FALSE) && ((matchExpType(srcExpType, tarExpType)) && checkLiteralValue(
1:           this.getSrcNode(), currentNode))) {
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:3af2d65
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
/////////////////////////////////////////////////////////////////////////
1:   private static final LogService LOG =
1:       LogServiceFactory.getLogService(RangeExpressionEvaluator.class.getName());
/////////////////////////////////////////////////////////////////////////
1:           LOG.info(
1:               "GreaterThan and LessThan Filter Expression changed to Range Expression for column "
0:                   + colName);
author:sounakr
-------------------------------------------------------------------------------
commit:c2e4eb2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.scan.expression;
1: 
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1: import org.apache.carbondata.core.scan.expression.logical.RangeExpression;
1: import org.apache.carbondata.core.scan.expression.logical.TrueExpression;
1: import org.apache.carbondata.core.scan.filter.intf.ExpressionType;
1: 
1: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.FALSE;
1: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.GREATERTHAN;
1: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.GREATERTHAN_EQUALTO;
1: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.LESSTHAN;
1: import static org.apache.carbondata.core.scan.filter.intf.ExpressionType.LESSTHAN_EQUALTO;
1: 
1: public class RangeExpressionEvaluator {
1:   private Expression expr;
1:   private Expression srcNode;
0:   private Expression srcParentNode;
1:   private Expression tarNode;
1:   private Expression tarParentNode;
1: 
1:   public RangeExpressionEvaluator(Expression expr) {
1:     this.expr = expr;
1:   }
1: 
1:   public Expression getExpr() {
1:     return expr;
1:   }
1: 
1:   public void setExpr(Expression expr) {
1:     this.expr = expr;
1:   }
1: 
0:   public Expression getSrcNode() {
1:     return srcNode;
1:   }
1: 
0:   public void setTarNode(Expression expr) {
1:     this.tarNode = expr;
1:   }
1: 
0:   public void setTarParentNode(Expression expr) {
1:     this.tarParentNode = expr;
1:   }
1: 
1:   /**
1:    * This method evaluates is any greaterthan or less than expression can be transformed
1:    * into a single RANGE filter.
1:    */
1:   public void rangeExpressionEvaluatorMapBased() {
1:     // The algorithm :
1:     // Get all the nodes of the Expression Tree and fill it into a MAP.
1:     // The Map structure will be currentNode, ColumnName, LessThanOrgreaterThan, Value, ParentNode
1:     // Group the rows in MAP according to the columns and then evaluate if it can be transformed
1:     // into a RANGE or not.
1:     //
1:     //            AND                                           AND
1:     //             |                                             |
1:     //            / \                                           / \
1:     //           /   \                                         /   \
1:     //        Less   Greater         =>                    TRUE   Range
1:     //         / \    / \                                         / \
1:     //        /   \  /   \                                       /   \
1:     //       a    10 a   5                                   Less   greater
1:     //                                                        /\      /\
1:     //                                                       /  \    /  \
1:     //                                                      a   10  a    5
1:     //
1: 
1:     Map<String, List<FilterModificationNode>> filterExpressionMap;
1:     filterExpressionMap = convertFilterTreeToMap();
1:     replaceWithRangeExpression(filterExpressionMap);
1:     filterExpressionMap.clear();
1:   }
1: 
1:   public void replaceWithRangeExpression(
1:       Map<String, List<FilterModificationNode>> filterExpressionMap) {
1: 
1:     List<FilterModificationNode> deleteExp = new ArrayList<>();
0:     for (String colName : filterExpressionMap.keySet()) {
0:       // Check is there are multiple list for this Column.
0:       List<FilterModificationNode> filterExp = filterExpressionMap.get(colName);
1:       if (filterExp.size() > 1) {
1:         // There are multiple Expression for the same column traverse and check if they can
1:         // form a range.
1:         FilterModificationNode startMin = null;
1:         FilterModificationNode endMax = null;
1: 
1:         for (FilterModificationNode exp : filterExp) {
1:           if ((exp.getExpType() == GREATERTHAN) || (exp.getExpType() == GREATERTHAN_EQUALTO)) {
0:             if ((null == endMax) || ((null != endMax) && (checkLiteralValue(exp.getCurrentExp(),
0:                 endMax.getCurrentExp())))) {
1:               if (null == startMin) {
1:                 startMin = exp;
1:               } else {
1:                 // There is already some value in startMin so check which one is greater.
1:                 LiteralExpression srcLiteral = getChildLiteralExpression(startMin.getCurrentExp());
1:                 LiteralExpression tarLiteral = getChildLiteralExpression(exp.getCurrentExp());
1: 
1:                 ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:                 ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1:                 if (srcExpResult.compareTo(tarExpResult) < 0) {
1:                   // Before replacing the startMin add the current StartMin into deleteExp List
1:                   // as they will be replaced with TRUE expression after RANGE formation.
1:                   deleteExp.add(startMin);
1:                   startMin = exp;
1:                 }
1:               }
1:             }
1:           }
1:           if ((exp.getExpType() == LESSTHAN) || (exp.getExpType() == LESSTHAN_EQUALTO)) {
0:             if ((null == startMin) || ((null != startMin) && (checkLiteralValue(exp.getCurrentExp(),
0:                 startMin.getCurrentExp())))) {
1:               if (null == endMax) {
1:                 endMax = exp;
1:               } else {
1:                 // There is already some value in endMax so check which one is less.
1:                 LiteralExpression srcLiteral = getChildLiteralExpression(endMax.getCurrentExp());
1:                 LiteralExpression tarLiteral = getChildLiteralExpression(exp.getCurrentExp());
1: 
1:                 ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:                 ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1:                 if (srcExpResult.compareTo(tarExpResult) > 0) {
1:                   // Before replacing the endMax add the current endMax into deleteExp List
1:                   // as they will be replaced with TRUE expression after RANGE formation.
1:                   deleteExp.add(endMax);
1:                   endMax = exp;
1:                 }
1:               }
1:             }
1:           }
1:         }
1: 
1:         if ((null != startMin) && (null != endMax)) {
1:           // the node can be converted to RANGE.
1:           Expression n1 = startMin.getCurrentExp();
1:           Expression n2 = endMax.getCurrentExp();
1: 
1:           RangeExpression rangeTree = new RangeExpression(n1, n2);
1:           Expression srcParentNode = startMin.getParentExp();
1:           Expression tarParentNode = endMax.getParentExp();
1: 
1:           srcParentNode.findAndSetChild(startMin.getCurrentExp(), rangeTree);
1:           tarParentNode.findAndSetChild(endMax.getCurrentExp(), new TrueExpression(null));
1: 
1:           if (deleteExp.size() > 0) {
1:             // There are some expression to Delete as they are Redundant after Range Formation.
1:             for (FilterModificationNode trueExp : deleteExp) {
1:               trueExp.getParentExp()
1:                   .findAndSetChild(trueExp.getCurrentExp(), new TrueExpression(null));
1:             }
1:           }
1:         }
1:       }
1:     }
1:   }
1: 
1: 
1:   private Map<String, List<FilterModificationNode>> convertFilterTreeToMap() {
1:     // Traverse the Filter Tree and add the nodes in filterExpressionMap.
1:     // Only those nodes will be added which has got LessThan, LessThanEqualTo
1:     // GreaterThan, GreaterThanEqualTo Expression Only.
1:     Map<String, List<FilterModificationNode>> filterExpressionMap =
1:         new HashMap<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1: 
1:     // Traverse the Tree.
1:     fillExpressionMap(filterExpressionMap, null, null);
1: 
1:     return filterExpressionMap;
1:   }
1: 
1: 
1:   private void fillExpressionMap(Map<String, List<FilterModificationNode>> filterExpressionMap,
1:       Expression currentNode, Expression parentNode) {
1:     if (null == currentNode) {
1:       currentNode = this.getExpr();
1:       parentNode  = currentNode;
1:     }
1: 
1:     // if the parentNode is a ANDExpression and the current node is LessThan, GreaterThan
1:     // then add the node into filterExpressionMap.
1:     if ((parentNode instanceof AndExpression) && (isLessThanGreaterThanExp(currentNode)
1:         && eligibleForRangeExpConv(currentNode))) {
1:       addFilterExpressionMap(filterExpressionMap, currentNode, parentNode);
1:     }
1: 
1:     for (Expression exp : currentNode.getChildren()) {
1:       if (null != exp) {
1:         fillExpressionMap(filterExpressionMap, exp, currentNode);
1:         if (exp instanceof OrExpression) {
1:           replaceWithRangeExpression(filterExpressionMap);
1:           filterExpressionMap.clear();
1:         }
1:       }
1:     }
1:   }
1: 
1:   private void addFilterExpressionMap(Map<String, List<FilterModificationNode>> filterExpressionMap,
1:       Expression currentNode, Expression parentNode) {
1:     String colName = getColumnName(currentNode);
0:     DataType dataType = getLiteralDataType(currentNode);
0:     Object literalVal = getLiteralValue(currentNode);
1:     ExpressionType expType = getExpressionType(currentNode);
1: 
1:     FilterModificationNode filterExpression =
0:         new FilterModificationNode(currentNode, parentNode, expType, dataType, literalVal, colName);
1: 
1:     if (null == filterExpressionMap.get(colName)) {
1:       filterExpressionMap.put(colName, new ArrayList<FilterModificationNode>());
1:     }
1:     filterExpressionMap.get(colName).add(filterExpression);
1:   }
1: 
1:   /**
1:    * This method checks if the Expression is among LessThan, LessThanEqualTo,
1:    * GreaterThan or GreaterThanEqualTo
1:    *
1:    * @param expr
1:    * @return
1:    */
1:   private boolean isLessThanGreaterThanExp(Expression expr) {
0:     if ((expr instanceof LessThanEqualToExpression) || (expr instanceof LessThanExpression)
1:         || (expr instanceof GreaterThanEqualToExpression)
0:         || (expr instanceof GreaterThanExpression)) {
1:       return true;
1:     } else {
1:       return false;
1:     }
1:   }
1: 
1:   /**
1:    * This method verifies if the Expression is qualified for Range Expression conversion.
1:    *
1:    * @param expChild
1:    * @return
1:    */
1:   private boolean eligibleForRangeExpConv(Expression expChild) {
1:     for (Expression exp : expChild.getChildren()) {
1:       if (exp instanceof ColumnExpression) {
0:         if (((ColumnExpression) exp).isDimension() == false) {
1:           return false;
1:         }
0:         if ((((ColumnExpression) exp).getDimension().getDataType() == DataType.ARRAY) || (
0:             ((ColumnExpression) exp).getDimension().getDataType() == DataType.STRUCT)) {
1:           return false;
1:         } else {
1:           return true;
1:         }
1:       }
1:     }
1:     return false;
1:   }
1: 
1:   /**
1:    * This method returns the Column name from the ColumnExpression ExpressionType.
1:    *
1:    * @param andNode
1:    * @return
1:    */
1:   private String getColumnName(Expression andNode) {
1:     // returns the Column Name from Column Expression.
1:     for (Expression exp : andNode.getChildren()) {
1:       if (exp instanceof ColumnExpression) {
1:         return ((ColumnExpression) exp).getColumnName();
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * This method returns the Value from the Literal ExpressionType.
1:    *
1:    * @param exp
1:    * @return
1:    */
1:   private Object getLiteralValue(Expression exp) {
1:     for (Expression expr : exp.getChildren()) {
1:       if (expr instanceof LiteralExpression) {
1:         return (((LiteralExpression) expr).getLiteralExpValue());
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * This method returns the DataType of the Literal Expression.
1:    *
1:    * @param exp
1:    * @return
1:    */
1:   private DataType getLiteralDataType(Expression exp) {
1:     for (Expression expr : exp.getChildren()) {
1:       if (expr instanceof LiteralExpression) {
1:         return (((LiteralExpression) expr).getLiteralExpDataType());
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * This method returns the DataType of the Literal Expression.
1:    *
1:    * @param exp
1:    * @return
1:    */
1:   private LiteralExpression getChildLiteralExpression(Expression exp) {
1:     for (Expression expr : exp.getChildren()) {
1:       if (expr instanceof LiteralExpression) {
1:         return ((LiteralExpression) expr);
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * This method returns the ExpressionType based on the Expression.
1:    *
1:    * @param exp
1:    * @return
1:    */
1:   private ExpressionType getExpressionType(Expression exp) {
1:     // return the expressionType. Note among the children of the
1:     // andNode one should be columnExpression others should be
1:     // LessThan, LessThanEqualTo, GreaterThan, GreaterThanEqualTo.
1:     //
1:     if (exp instanceof LessThanExpression) {
1:       return LESSTHAN;
1:     } else if (exp instanceof LessThanEqualToExpression) {
1:       return LESSTHAN_EQUALTO;
1:     } else if (exp instanceof GreaterThanExpression) {
1:       return GREATERTHAN;
1:     } else if (exp instanceof GreaterThanEqualToExpression) {
1:       return GREATERTHAN_EQUALTO;
1:     } else {
1:       return FALSE;
1:     }
1:   }
1: 
1:   /**
1:    * This method checks if the Source Expression matches with Target Expression.
1:    *
1:    * @param src
1:    * @param tar
1:    * @return
1:    */
1:   private boolean matchExpType(ExpressionType src, ExpressionType tar) {
0:     if ((((src == LESSTHAN) || (src == LESSTHAN_EQUALTO)) && ((tar == GREATERTHAN) || (tar
1:         == GREATERTHAN_EQUALTO))) || (((src == GREATERTHAN) || (src == GREATERTHAN_EQUALTO)) && (
0:         (tar == LESSTHAN) || (tar == LESSTHAN_EQUALTO)))) {
1:       return true;
1:     } else {
1:       return false;
1:     }
1:   }
1: 
1:   /**
1:    * This Method Traverses the Expression Tree to find the corresponding node of the Range
1:    * Expression. If one node of Range Expression is LessThan then a corresponding GreaterThan
1:    * will be choosen or vice versa.
1:    *
1:    * @param currentNode
1:    * @param parentNode
1:    * @return
1:    */
1:   private Expression traverseTree(Expression currentNode, Expression parentNode) {
1:     Expression result = null;
1: 
1:     if (null == parentNode) {
1:       currentNode = this.getExpr();
1:       parentNode = currentNode;
1:     }
1: 
1:     if (!this.getSrcNode().equals(currentNode) && isLessThanGreaterThanExp(currentNode)) {
1:       String srcColumnName = getColumnName(this.getSrcNode());
1:       String tarColumnName = getColumnName(currentNode);
1:       ExpressionType srcExpType = getExpressionType(this.getSrcNode());
1:       ExpressionType tarExpType = getExpressionType(currentNode);
1: 
0:       if ((null != srcColumnName) && (null != tarColumnName) && (srcColumnName == tarColumnName)
0:           && (srcExpType != ExpressionType.FALSE) && (tarExpType != ExpressionType.FALSE) && (
0:           (matchExpType(srcExpType, tarExpType)) && checkLiteralValue(this.getSrcNode(),
0:               currentNode))) {
1:         this.setTarNode(currentNode);
1:         this.setTarParentNode(parentNode);
1:         return parentNode;
1:       }
1:     }
1: 
1:     for (Expression exp : currentNode.getChildren()) {
1:       if (null != exp && !(exp instanceof RangeExpression)) {
1:         result = traverseTree(exp, currentNode);
1:         if (null != result) {
1:           return result;
1:         }
1:       }
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * This method will check if the literal values attached to GreaterThan of GreaterThanEqualTo
1:    * is less or equal to LessThan and LessThanEqualTo literal.
1:    *
1:    * @param src
1:    * @param tar
1:    * @return
1:    */
1:   private boolean checkLiteralValue(Expression src, Expression tar) {
1:     ExpressionType srcExpressionType = getExpressionType(src);
1:     ExpressionType tarExpressionType = getExpressionType(tar);
1:     LiteralExpression srcLiteral = getChildLiteralExpression(src);
1:     LiteralExpression tarLiteral = getChildLiteralExpression(tar);
1: 
1:     ExpressionResult srcExpResult = srcLiteral.evaluate(null);
1:     ExpressionResult tarExpResult = tarLiteral.evaluate(null);
1: 
1:     switch (srcExpressionType) {
1:       case LESSTHAN:
1:       case LESSTHAN_EQUALTO:
1:         switch (tarExpressionType) {
1:           case GREATERTHAN:
1:             if (srcExpResult.compareTo(tarExpResult) > 0) {
1:               return true;
1:             }
1:             break;
1:           case GREATERTHAN_EQUALTO:
1:             if (srcExpResult.compareTo(tarExpResult) >= 0) {
1:               return true;
1:             }
1:             break;
1:         }
1:         break;
1:       case GREATERTHAN:
1:       case GREATERTHAN_EQUALTO:
1:         switch (tarExpressionType) {
1:           case LESSTHAN:
1:             if (srcExpResult.compareTo(tarExpResult) < 0) {
1:               return true;
1:             }
1:             break;
1:           case LESSTHAN_EQUALTO:
1:             if (srcExpResult.compareTo(tarExpResult) <= 0) {
1:               return true;
1:             }
1:             break;
1:         }
1:         break;
1:     }
1: 
1:     return false;
1:   }
1: }
============================================================================