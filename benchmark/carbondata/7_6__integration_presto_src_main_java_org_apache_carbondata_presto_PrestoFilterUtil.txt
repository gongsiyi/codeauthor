1:9c83bd1: /*
1:9c83bd1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9c83bd1:  * contributor license agreements.  See the NOTICE file distributed with
1:9c83bd1:  * this work for additional information regarding copyright ownership.
1:9c83bd1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9c83bd1:  * (the "License"); you may not use this file except in compliance with
1:9c83bd1:  * the License.  You may obtain a copy of the License at
1:9c83bd1:  *
1:9c83bd1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:9c83bd1:  *
1:9c83bd1:  * Unless required by applicable law or agreed to in writing, software
1:9c83bd1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9c83bd1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9c83bd1:  * See the License for the specific language governing permissions and
1:9c83bd1:  * limitations under the License.
1:9c83bd1:  */
8:9c83bd1: 
1:9c83bd1: package org.apache.carbondata.presto;
1:9c83bd1: 
1:1551a7c: import java.math.BigDecimal;
1:1551a7c: import java.math.BigInteger;
1:3740535: import java.sql.Timestamp;
1:9c83bd1: import java.util.ArrayList;
1:9c83bd1: import java.util.Calendar;
1:9c83bd1: import java.util.Date;
1:9c83bd1: import java.util.HashMap;
1:9c83bd1: import java.util.List;
1:9c83bd1: import java.util.Map;
1:9c83bd1: 
1:d4a1577: import static java.lang.String.format;
1:d4a1577: import static java.util.stream.Collectors.toList;
1:d4a1577: 
1:9c83bd1: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:3740535: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:3740535: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.Expression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.LiteralExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.EqualToExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.InExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.conditional.ListExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1:9c83bd1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1:9c83bd1: 
1:9c83bd1: import com.facebook.presto.spi.ColumnHandle;
1:3740535: import com.facebook.presto.spi.PrestoException;
1:9c83bd1: import com.facebook.presto.spi.predicate.Domain;
1:9c83bd1: import com.facebook.presto.spi.predicate.Range;
1:9c83bd1: import com.facebook.presto.spi.predicate.TupleDomain;
1:e5e74fc: import com.facebook.presto.spi.type.BigintType;
1:e5e74fc: import com.facebook.presto.spi.type.BooleanType;
1:e5e74fc: import com.facebook.presto.spi.type.DateType;
1:e5e74fc: import com.facebook.presto.spi.type.DecimalType;
1:e5e74fc: import com.facebook.presto.spi.type.Decimals;
1:e5e74fc: import com.facebook.presto.spi.type.DoubleType;
1:e5e74fc: import com.facebook.presto.spi.type.IntegerType;
1:e5e74fc: import com.facebook.presto.spi.type.SmallintType;
1:e5e74fc: import com.facebook.presto.spi.type.TimestampType;
1:e5e74fc: import com.facebook.presto.spi.type.Type;
1:e5e74fc: import com.facebook.presto.spi.type.VarcharType;
1:9c83bd1: import io.airlift.slice.Slice;
1:9c83bd1: 
1:3740535: import static com.facebook.presto.spi.StandardErrorCode.NOT_SUPPORTED;
1:9c83bd1: import static com.google.common.base.Preconditions.checkArgument;
1:9c83bd1: 
1:9c83bd1: /**
1:9c83bd1:  * PrestoFilterUtil create the carbonData Expression from the presto-domain
1:9c83bd1:  */
1:9c83bd1: public class PrestoFilterUtil {
1:9c83bd1: 
1:9c83bd1:   private static Map<Integer, Expression> filterMap = new HashMap<>();
1:3740535: 
1:d4a1577:   private static final String HIVE_DEFAULT_DYNAMIC_PARTITION = "__HIVE_DEFAULT_PARTITION__";
1:9c83bd1: 
1:3740535:   /**
1:3740535:    * @param carbondataColumnHandle
1:3740535:    * @return
1:3740535:    */
1:d4a1577:   private static DataType spi2CarbondataTypeMapper(CarbondataColumnHandle carbondataColumnHandle) {
1:9c83bd1:     Type colType = carbondataColumnHandle.getColumnType();
1:d4a1577:     if (colType == BooleanType.BOOLEAN) {
1:d4a1577:       return DataTypes.BOOLEAN;
1:d4a1577:     } else if (colType == SmallintType.SMALLINT) {
1:d4a1577:       return DataTypes.SHORT;
1:d4a1577:     } else if (colType == IntegerType.INTEGER) {
1:d4a1577:       return DataTypes.INT;
1:d4a1577:     } else if (colType == BigintType.BIGINT) {
1:d4a1577:       return DataTypes.LONG;
1:d4a1577:     } else if (colType == DoubleType.DOUBLE) {
1:d4a1577:       return DataTypes.DOUBLE;
1:d4a1577:     } else if (colType == VarcharType.VARCHAR) {
1:d4a1577:       return DataTypes.STRING;
1:d4a1577:     } else if (colType == DateType.DATE) {
1:d4a1577:       return DataTypes.DATE;
1:d4a1577:     } else if (colType == TimestampType.TIMESTAMP) {
1:d4a1577:       return DataTypes.TIMESTAMP;
1:d4a1577:     } else if (colType.equals(DecimalType.createDecimalType(carbondataColumnHandle.getPrecision(),
1:d4a1577:         carbondataColumnHandle.getScale()))) {
1:d4a1577:       return DataTypes.createDecimalType(carbondataColumnHandle.getPrecision(),
1:d4a1577:           carbondataColumnHandle.getScale());
1:d4a1577:     } else {
1:d4a1577:       return DataTypes.STRING;
1:d4a1577:     }
1:6add19a:   }
1:9c83bd1: 
1:9c83bd1:   /**
1:3740535:    * Return partition filters using domain constraints
1:3740535:    * @param carbonTable
1:3740535:    * @param originalConstraint
1:3740535:    * @return
1:3740535:    */
1:d4a1577:   public static List<String> getPartitionFilters(CarbonTable carbonTable,
1:d4a1577:       TupleDomain<ColumnHandle> originalConstraint) {
1:3740535:     List<ColumnSchema> columnSchemas = carbonTable.getPartitionInfo().getColumnSchemaList();
1:3740535:     List<String> filter = new ArrayList<>();
1:3740535:     for (ColumnHandle columnHandle : originalConstraint.getDomains().get().keySet()) {
1:3740535:       CarbondataColumnHandle carbondataColumnHandle = (CarbondataColumnHandle) columnHandle;
1:3740535:       List<ColumnSchema> partitionedColumnSchema = columnSchemas.stream().filter(
1:d4a1577:           columnSchema -> carbondataColumnHandle.getColumnName()
1:d4a1577:               .equals(columnSchema.getColumnName())).collect(toList());
1:d4a1577:       if (partitionedColumnSchema.size() != 0) {
1:3740535:         filter.addAll(createPartitionFilters(originalConstraint, carbondataColumnHandle));
1:3740535:       }
1:3740535:     }
1:3740535:     return filter;
1:3740535:   }
1:3740535: 
1:3740535:   /** Returns list of partition key and values using domain constraints
1:3740535:    * @param originalConstraint
1:3740535:    * @param carbonDataColumnHandle
1:3740535:    */
1:3740535:   private static List<String> createPartitionFilters(TupleDomain<ColumnHandle> originalConstraint,
1:3740535:       CarbondataColumnHandle carbonDataColumnHandle) {
1:3740535:     List<String> filter = new ArrayList<>();
1:3740535:     Domain domain = originalConstraint.getDomains().get().get(carbonDataColumnHandle);
1:3740535:     if (domain != null && domain.isNullableSingleValue()) {
1:3740535:       Object value = domain.getNullableSingleValue();
1:3740535:       Type type = domain.getType();
1:3740535:       if (value == null) {
1:3740535:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + HIVE_DEFAULT_DYNAMIC_PARTITION);
1:d4a1577:       } else if (carbonDataColumnHandle.getColumnType() instanceof DecimalType) {
1:3740535:         int scale = ((DecimalType) carbonDataColumnHandle.getColumnType()).getScale();
1:3740535:         if (value instanceof Long) {
1:3740535:           //create decimal value from Long
1:3740535:           BigDecimal decimalValue = new BigDecimal(new BigInteger(String.valueOf(value)), scale);
1:3740535:           filter.add(carbonDataColumnHandle.getColumnName() + "=" + decimalValue.toString());
1:3740535:         } else if (value instanceof Slice) {
1:3740535:           //create decimal value from Slice
1:d4a1577:           BigDecimal decimalValue =
1:d4a1577:               new BigDecimal(Decimals.decodeUnscaledValue((Slice) value), scale);
1:3740535:           filter.add(carbonDataColumnHandle.getColumnName() + "=" + decimalValue.toString());
1:3740535:         }
1:3740535:       } else if (value instanceof Slice) {
1:3740535:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + ((Slice) value).toStringUtf8());
1:3740535:       } else if (value instanceof Long && carbonDataColumnHandle.getColumnType()
1:3740535:           .equals(DateType.DATE)) {
1:3740535:         Calendar c = Calendar.getInstance();
1:3740535:         c.setTime(new java.sql.Date(0));
1:3740535:         c.add(Calendar.DAY_OF_YEAR, ((Long) value).intValue());
1:3740535:         java.sql.Date date = new java.sql.Date(c.getTime().getTime());
1:3740535:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + date.toString());
1:3740535:       } else if (value instanceof Long && carbonDataColumnHandle.getColumnType()
1:3740535:           .equals(TimestampType.TIMESTAMP)) {
1:3740535:         String timeStamp = new Timestamp((Long) value).toString();
1:d4a1577:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + timeStamp
1:d4a1577:             .substring(0, timeStamp.indexOf('.')));
1:d4a1577:       } else if ((value instanceof Boolean) || (value instanceof Double)
1:d4a1577:           || (value instanceof Long)) {
1:3740535:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + value.toString());
1:3740535:       } else {
1:d4a1577:         throw new PrestoException(NOT_SUPPORTED,
1:d4a1577:             format("Unsupported partition key type: %s", type.getDisplayName()));
1:3740535:       }
1:3740535:     }
1:3740535:     return filter;
1:3740535:   }
1:3740535: 
1:3740535:   /**
1:9c83bd1:    * Convert presto-TupleDomain predication into Carbon scan express condition
1:9c83bd1:    *
1:9c83bd1:    * @param originalConstraint presto-TupleDomain
1:9c83bd1:    * @return
1:9c83bd1:    */
1:9c83bd1:   static Expression parseFilterExpression(TupleDomain<ColumnHandle> originalConstraint) {
1:9c83bd1: 
1:9c83bd1:     Domain domain;
1:9c83bd1: 
1:d4a1577:     // final expression for the table,
1:d4a1577:     // returned by the method after combining all the column filters (colValueExpression).
1:53a9fa7:     Expression finalFilters = null;
1:53a9fa7: 
1:9c83bd1:     for (ColumnHandle c : originalConstraint.getDomains().get().keySet()) {
1:1551a7c: 
1:9c83bd1:       // Build ColumnExpression for Expression(Carbondata)
1:9c83bd1:       CarbondataColumnHandle cdch = (CarbondataColumnHandle) c;
1:9c83bd1:       Type type = cdch.getColumnType();
1:d4a1577:       DataType coltype = spi2CarbondataTypeMapper(cdch);
1:9c83bd1:       Expression colExpression = new ColumnExpression(cdch.getColumnName(), coltype);
1:3740535: 
1:9c83bd1:       domain = originalConstraint.getDomains().get().get(c);
1:9c83bd1:       checkArgument(domain.getType().isOrderable(), "Domain type must be orderable");
1:9c83bd1:       List<Object> singleValues = new ArrayList<>();
1:53a9fa7: 
1:d4a1577:       // combination of multiple rangeExpression for a single column,
1:d4a1577:       // in case of multiple range Filter on single column
1:d4a1577:       // else this is equal to rangeExpression, combined to create finalFilters
1:53a9fa7:       Expression colValueExpression = null;
1:53a9fa7: 
1:9c83bd1:       for (Range range : domain.getValues().getRanges().getOrderedRanges()) {
1:9c83bd1:         if (range.isSingleValue()) {
1:d4a1577:           Object value = convertDataByType(range.getLow().getValue(), type);
1:9c83bd1:           singleValues.add(value);
3:9c83bd1:         } else {
1:53a9fa7:           // generated for each range of column i.e. lessThan, greaterThan,
1:53a9fa7:           // there can be multiple ranges for a single column. combined to create colValueExpression
1:53a9fa7:           Expression rangeExpression = null;
1:9c83bd1:           if (!range.getLow().isLowerUnbounded()) {
1:d4a1577:             Object value = convertDataByType(range.getLow().getValue(), type);
1:9c83bd1:             switch (range.getLow().getBound()) {
1:9c83bd1:               case ABOVE:
1:53a9fa7:                 rangeExpression =
1:53a9fa7:                     new GreaterThanExpression(colExpression, new LiteralExpression(value, coltype));
1:9c83bd1:                 break;
1:9c83bd1:               case EXACTLY:
1:53a9fa7:                 rangeExpression = new GreaterThanEqualToExpression(colExpression,
1:53a9fa7:                     new LiteralExpression(value, coltype));
1:9c83bd1:                 break;
1:9c83bd1:               case BELOW:
1:9c83bd1:                 throw new IllegalArgumentException("Low marker should never use BELOW bound");
1:9c83bd1:               default:
1:9c83bd1:                 throw new AssertionError("Unhandled bound: " + range.getLow().getBound());
1:6add19a:             }
1:1551a7c:           }
1:53a9fa7: 
1:9c83bd1:           if (!range.getHigh().isUpperUnbounded()) {
1:53a9fa7:             Expression lessThanExpression;
1:d4a1577:             Object value = convertDataByType(range.getHigh().getValue(), type);
1:9c83bd1:             switch (range.getHigh().getBound()) {
1:9c83bd1:               case ABOVE:
1:9c83bd1:                 throw new IllegalArgumentException("High marker should never use ABOVE bound");
1:9c83bd1:               case EXACTLY:
1:53a9fa7:                 lessThanExpression = new LessThanEqualToExpression(colExpression,
3:9c83bd1:                     new LiteralExpression(value, coltype));
1:9c83bd1:                 break;
1:9c83bd1:               case BELOW:
1:53a9fa7:                 lessThanExpression =
1:9c83bd1:                     new LessThanExpression(colExpression, new LiteralExpression(value, coltype));
1:9c83bd1:                 break;
1:9c83bd1:               default:
1:9c83bd1:                 throw new AssertionError("Unhandled bound: " + range.getHigh().getBound());
1:1551a7c:             }
1:53a9fa7:             rangeExpression = (rangeExpression == null ?
1:53a9fa7:                 lessThanExpression :
1:53a9fa7:                 new AndExpression(rangeExpression, lessThanExpression));
1:1551a7c:           }
1:53a9fa7:           colValueExpression = (colValueExpression == null ?
1:53a9fa7:               rangeExpression :
1:53a9fa7:               new OrExpression(colValueExpression, rangeExpression));
1:1551a7c:         }
1:1551a7c:       }
1:53a9fa7: 
1:9c83bd1:       if (singleValues.size() == 1) {
1:53a9fa7:         colValueExpression = new EqualToExpression(colExpression,
2:9c83bd1:             new LiteralExpression(singleValues.get(0), coltype));
1:9c83bd1:       } else if (singleValues.size() > 1) {
1:53a9fa7:         List<Expression> exs =
1:53a9fa7:             singleValues.stream().map((a) -> new LiteralExpression(a, coltype)).collect(toList());
1:53a9fa7:         colValueExpression = new InExpression(colExpression, new ListExpression(exs));
1:53a9fa7:       }
1:1551a7c: 
1:53a9fa7:       if (colValueExpression != null) {
1:53a9fa7:         finalFilters = (finalFilters == null ?
1:53a9fa7:             colValueExpression :
1:53a9fa7:             new AndExpression(finalFilters, colValueExpression));
1:1551a7c:       }
1:1551a7c:     }
1:9c83bd1:     return finalFilters;
16:9c83bd1:   }
1:9c83bd1: 
1:d4a1577:   private static Object convertDataByType(Object rawdata, Type type) {
1:d4a1577:     if (type.equals(IntegerType.INTEGER) || type.equals(SmallintType.SMALLINT)) {
1:6add19a:       return Integer.valueOf(rawdata.toString());
1:d4a1577:     } else if (type.equals(BigintType.BIGINT)) {
1:d4a1577:       return rawdata;
1:d4a1577:     } else if (type.equals(VarcharType.VARCHAR)) {
1:9c83bd1:       if (rawdata instanceof Slice) {
1:9c83bd1:         return ((Slice) rawdata).toStringUtf8();
1:9c83bd1:       } else {
1:9c83bd1:         return rawdata;
1:9c83bd1:       }
1:d4a1577:     } else if (type.equals(BooleanType.BOOLEAN)) {
1:d4a1577:       return rawdata;
1:d4a1577:     } else if (type.equals(DateType.DATE)) {
1:9c83bd1:       Calendar c = Calendar.getInstance();
1:9c83bd1:       c.setTime(new Date(0));
1:9c83bd1:       c.add(Calendar.DAY_OF_YEAR, ((Long) rawdata).intValue());
1:9c83bd1:       Date date = c.getTime();
1:9c83bd1:       return date.getTime() * 1000;
1:6add19a:     } else if (type instanceof DecimalType) {
1:6add19a:       if (rawdata instanceof Double) {
1:1551a7c:         return new BigDecimal((Double) rawdata);
1:6add19a:       } else if (rawdata instanceof Long) {
1:1551a7c:         return new BigDecimal(new BigInteger(String.valueOf(rawdata)),
1:1551a7c:             ((DecimalType) type).getScale());
1:6add19a:       } else if (rawdata instanceof Slice) {
1:6add19a:         return new BigDecimal(Decimals.decodeUnscaledValue((Slice) rawdata),
1:6add19a:             ((DecimalType) type).getScale());
1:1551a7c:       }
1:fa19331:     } else if (type.equals(TimestampType.TIMESTAMP)) {
1:6add19a:       return (Long) rawdata * 1000;
1:1551a7c:     }
1:9c83bd1: 
1:9c83bd1:     return rawdata;
1:9c83bd1:   }
1:9c83bd1: 
1:9c83bd1:   /**
1:9c83bd1:    * get the filters from key
1:9c83bd1:    */
1:9c83bd1:   static Expression getFilters(Integer key) {
1:9c83bd1:     return filterMap.get(key);
1:9c83bd1:   }
1:9c83bd1: 
1:9c83bd1:   static void setFilter(Integer tableId, Expression filter) {
1:9c83bd1:     filterMap.put(tableId, filter);
1:9c83bd1:   }
1:9c83bd1: }
============================================================================
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:d4a1577
/////////////////////////////////////////////////////////////////////////
1: import static java.lang.String.format;
1: import static java.util.stream.Collectors.toList;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private static final String HIVE_DEFAULT_DYNAMIC_PARTITION = "__HIVE_DEFAULT_PARTITION__";
1:   private static DataType spi2CarbondataTypeMapper(CarbondataColumnHandle carbondataColumnHandle) {
1:     if (colType == BooleanType.BOOLEAN) {
1:       return DataTypes.BOOLEAN;
1:     } else if (colType == SmallintType.SMALLINT) {
1:       return DataTypes.SHORT;
1:     } else if (colType == IntegerType.INTEGER) {
1:       return DataTypes.INT;
1:     } else if (colType == BigintType.BIGINT) {
1:       return DataTypes.LONG;
1:     } else if (colType == DoubleType.DOUBLE) {
1:       return DataTypes.DOUBLE;
1:     } else if (colType == VarcharType.VARCHAR) {
1:       return DataTypes.STRING;
1:     } else if (colType == DateType.DATE) {
1:       return DataTypes.DATE;
1:     } else if (colType == TimestampType.TIMESTAMP) {
1:       return DataTypes.TIMESTAMP;
1:     } else if (colType.equals(DecimalType.createDecimalType(carbondataColumnHandle.getPrecision(),
1:         carbondataColumnHandle.getScale()))) {
1:       return DataTypes.createDecimalType(carbondataColumnHandle.getPrecision(),
1:           carbondataColumnHandle.getScale());
1:     } else {
1:       return DataTypes.STRING;
1:     }
/////////////////////////////////////////////////////////////////////////
1:   public static List<String> getPartitionFilters(CarbonTable carbonTable,
1:       TupleDomain<ColumnHandle> originalConstraint) {
1:           columnSchema -> carbondataColumnHandle.getColumnName()
1:               .equals(columnSchema.getColumnName())).collect(toList());
1:       if (partitionedColumnSchema.size() != 0) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (carbonDataColumnHandle.getColumnType() instanceof DecimalType) {
/////////////////////////////////////////////////////////////////////////
1:           BigDecimal decimalValue =
1:               new BigDecimal(Decimals.decodeUnscaledValue((Slice) value), scale);
/////////////////////////////////////////////////////////////////////////
1:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + timeStamp
1:             .substring(0, timeStamp.indexOf('.')));
1:       } else if ((value instanceof Boolean) || (value instanceof Double)
1:           || (value instanceof Long)) {
1:         throw new PrestoException(NOT_SUPPORTED,
1:             format("Unsupported partition key type: %s", type.getDisplayName()));
/////////////////////////////////////////////////////////////////////////
1:     // final expression for the table,
1:     // returned by the method after combining all the column filters (colValueExpression).
/////////////////////////////////////////////////////////////////////////
1:       DataType coltype = spi2CarbondataTypeMapper(cdch);
1:       // combination of multiple rangeExpression for a single column,
1:       // in case of multiple range Filter on single column
1:       // else this is equal to rangeExpression, combined to create finalFilters
1:           Object value = convertDataByType(range.getLow().getValue(), type);
1:             Object value = convertDataByType(range.getLow().getValue(), type);
/////////////////////////////////////////////////////////////////////////
1:             Object value = convertDataByType(range.getHigh().getValue(), type);
/////////////////////////////////////////////////////////////////////////
1:   private static Object convertDataByType(Object rawdata, Type type) {
1:     if (type.equals(IntegerType.INTEGER) || type.equals(SmallintType.SMALLINT)) {
1:     } else if (type.equals(BigintType.BIGINT)) {
1:       return rawdata;
1:     } else if (type.equals(VarcharType.VARCHAR)) {
1:     } else if (type.equals(BooleanType.BOOLEAN)) {
1:       return rawdata;
1:     } else if (type.equals(DateType.DATE)) {
author:sv71294
-------------------------------------------------------------------------------
commit:53a9fa7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     // final expression for the table, returned by the method after combining all the column filters (colValueExpression).
1:     Expression finalFilters = null;
1: 
1: 
0:       // combination of multiple rangeExpression for a single column in case of multiple range Filter
0:       // on single column else this is equal to rangeExpression, combined to create finalFilters
1:       Expression colValueExpression = null;
1: 
1:           // generated for each range of column i.e. lessThan, greaterThan,
1:           // there can be multiple ranges for a single column. combined to create colValueExpression
1:           Expression rangeExpression = null;
1:                 rangeExpression =
1:                     new GreaterThanExpression(colExpression, new LiteralExpression(value, coltype));
1:                 rangeExpression = new GreaterThanEqualToExpression(colExpression,
1:                     new LiteralExpression(value, coltype));
/////////////////////////////////////////////////////////////////////////
1: 
1:             Expression lessThanExpression;
1:                 lessThanExpression = new LessThanEqualToExpression(colExpression,
1:                 lessThanExpression =
1:             rangeExpression = (rangeExpression == null ?
1:                 lessThanExpression :
1:                 new AndExpression(rangeExpression, lessThanExpression));
1:           colValueExpression = (colValueExpression == null ?
1:               rangeExpression :
1:               new OrExpression(colValueExpression, rangeExpression));
1: 
1:         colValueExpression = new EqualToExpression(colExpression,
1:         List<Expression> exs =
1:             singleValues.stream().map((a) -> new LiteralExpression(a, coltype)).collect(toList());
1:         colValueExpression = new InExpression(colExpression, new ListExpression(exs));
1:       }
1:       if (colValueExpression != null) {
1:         finalFilters = (finalFilters == null ?
1:             colValueExpression :
1:             new AndExpression(finalFilters, colValueExpression));
author:anubhav100
-------------------------------------------------------------------------------
commit:3740535
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
/////////////////////////////////////////////////////////////////////////
1: import com.facebook.presto.spi.PrestoException;
/////////////////////////////////////////////////////////////////////////
1: import static com.facebook.presto.spi.StandardErrorCode.NOT_SUPPORTED;
0: import static java.lang.String.format;
0: import static java.util.stream.Collectors.toList;
/////////////////////////////////////////////////////////////////////////
0:   private final static String HIVE_DEFAULT_DYNAMIC_PARTITION = "__HIVE_DEFAULT_PARTITION__";
1: 
1:   /**
1:    * @param carbondataColumnHandle
1:    * @return
1:    */
/////////////////////////////////////////////////////////////////////////
1:    * Return partition filters using domain constraints
1:    * @param carbonTable
1:    * @param originalConstraint
1:    * @return
1:    */
0:   public static List<String> getPartitionFilters(CarbonTable carbonTable, TupleDomain<ColumnHandle> originalConstraint) {
1:     List<ColumnSchema> columnSchemas = carbonTable.getPartitionInfo().getColumnSchemaList();
1:     List<String> filter = new ArrayList<>();
1:     for (ColumnHandle columnHandle : originalConstraint.getDomains().get().keySet()) {
1:       CarbondataColumnHandle carbondataColumnHandle = (CarbondataColumnHandle) columnHandle;
1:       List<ColumnSchema> partitionedColumnSchema = columnSchemas.stream().filter(
0:           columnSchema -> carbondataColumnHandle.getColumnName().equals(columnSchema.getColumnName())).collect(toList());
0:       if(partitionedColumnSchema.size() != 0) {
1:         filter.addAll(createPartitionFilters(originalConstraint, carbondataColumnHandle));
1:       }
1:     }
1:     return filter;
1:   }
1: 
1:   /** Returns list of partition key and values using domain constraints
1:    * @param originalConstraint
1:    * @param carbonDataColumnHandle
1:    */
1:   private static List<String> createPartitionFilters(TupleDomain<ColumnHandle> originalConstraint,
1:       CarbondataColumnHandle carbonDataColumnHandle) {
1:     List<String> filter = new ArrayList<>();
1:     Domain domain = originalConstraint.getDomains().get().get(carbonDataColumnHandle);
1:     if (domain != null && domain.isNullableSingleValue()) {
1:       Object value = domain.getNullableSingleValue();
1:       Type type = domain.getType();
1:       if (value == null) {
1:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + HIVE_DEFAULT_DYNAMIC_PARTITION);
0:       } else if(carbonDataColumnHandle.getColumnType() instanceof DecimalType) {
1:         int scale = ((DecimalType) carbonDataColumnHandle.getColumnType()).getScale();
1:         if (value instanceof Long) {
1:           //create decimal value from Long
1:           BigDecimal decimalValue = new BigDecimal(new BigInteger(String.valueOf(value)), scale);
1:           filter.add(carbonDataColumnHandle.getColumnName() + "=" + decimalValue.toString());
1:         } else if (value instanceof Slice) {
1:           //create decimal value from Slice
0:           BigDecimal decimalValue = new BigDecimal(Decimals.decodeUnscaledValue((Slice) value), scale);
1:           filter.add(carbonDataColumnHandle.getColumnName() + "=" + decimalValue.toString());
1:         }
1:       } else if (value instanceof Slice) {
1:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + ((Slice) value).toStringUtf8());
1:       } else if (value instanceof Long && carbonDataColumnHandle.getColumnType()
1:           .equals(DateType.DATE)) {
1:         Calendar c = Calendar.getInstance();
1:         c.setTime(new java.sql.Date(0));
1:         c.add(Calendar.DAY_OF_YEAR, ((Long) value).intValue());
1:         java.sql.Date date = new java.sql.Date(c.getTime().getTime());
1:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + date.toString());
1:       } else if (value instanceof Long && carbonDataColumnHandle.getColumnType()
1:           .equals(TimestampType.TIMESTAMP)) {
1:         String timeStamp = new Timestamp((Long) value).toString();
0:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + timeStamp.substring(0,timeStamp.indexOf('.')));
0:       } else if ((value instanceof Boolean) || (value instanceof Double) || (value instanceof Long)) {
1:         filter.add(carbonDataColumnHandle.getColumnName() + "=" + value.toString());
1:       } else {
0:         throw new PrestoException(NOT_SUPPORTED, format("Unsupported partition key type: %s", type.getDisplayName()));
1:       }
1:     }
1:     return filter;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             .collect(toList());
/////////////////////////////////////////////////////////////////////////
commit:b120601
/////////////////////////////////////////////////////////////////////////
0:             .map((a) -> new LiteralExpression(a, coltype))
commit:6add19a
/////////////////////////////////////////////////////////////////////////
0:                   valueExpressionMap.computeIfAbsent(value, key -> new ArrayList<>()).add(greater);
0:                 valueExpressionMap.computeIfAbsent(value, key -> new ArrayList<>()).add(greater);
/////////////////////////////////////////////////////////////////////////
0:                 valueExpressionMap.computeIfAbsent(value, key -> new ArrayList<>()).add(less);
0:                 valueExpressionMap.computeIfAbsent(value, key -> new ArrayList<>()).add(less2);
/////////////////////////////////////////////////////////////////////////
0:         if (valuefilters.size() == 1) {
0:           finalFilters = new AndExpression(valuefilters.get(0), valuefilters.get(1));
0:           for (int i = 2; i < valuefilters.size(); i++) {
0:             finalFilters = new AndExpression(finalFilters, valuefilters.get(i));
1:           }
1:         }
/////////////////////////////////////////////////////////////////////////
0:     if (type.equals(IntegerType.INTEGER) || type.equals(SmallintType.SMALLINT))
1:       return Integer.valueOf(rawdata.toString());
0:       // new Integer((rawdata.toString()));
/////////////////////////////////////////////////////////////////////////
1:     } else if (type instanceof DecimalType) {
1:       if (rawdata instanceof Double) {
1:       } else if (rawdata instanceof Long) {
1:       } else if (rawdata instanceof Slice) {
1:         return new BigDecimal(Decimals.decodeUnscaledValue((Slice) rawdata),
1:             ((DecimalType) type).getScale());
1:       return (Long) rawdata * 1000;
author:Bhavya
-------------------------------------------------------------------------------
commit:e5e74fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import com.facebook.presto.spi.type.BigintType;
1: import com.facebook.presto.spi.type.BooleanType;
1: import com.facebook.presto.spi.type.DateType;
1: import com.facebook.presto.spi.type.DecimalType;
1: import com.facebook.presto.spi.type.Decimals;
1: import com.facebook.presto.spi.type.DoubleType;
1: import com.facebook.presto.spi.type.IntegerType;
1: import com.facebook.presto.spi.type.SmallintType;
1: import com.facebook.presto.spi.type.TimestampType;
1: import com.facebook.presto.spi.type.Type;
1: import com.facebook.presto.spi.type.VarcharType;
/////////////////////////////////////////////////////////////////////////
0:         carbondataColumnHandle.getScale()))) return DataTypes
0:         .createDecimalType(carbondataColumnHandle.getPrecision(),
0:             carbondataColumnHandle.getScale());
commit:1551a7c
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
/////////////////////////////////////////////////////////////////////////
0:     else if (colType.equals(DecimalType.createDecimalType(carbondataColumnHandle.getPrecision(),
0:         carbondataColumnHandle.getScale()))) return DataType.DECIMAL;
/////////////////////////////////////////////////////////////////////////
0:       Map<Object, List<Expression>> valueExpressionMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
0:                   if(valueExpressionMap.get(value) == null) {
0:                     valueExpressionMap.put(value, new ArrayList<>());
1:                   }
0:                   valueExpressionMap.get(value).add(greater);
0:                 if(valueExpressionMap.get(value) == null) {
0:                   valueExpressionMap.put(value, new ArrayList<>());
1:                 }
0:                 valueExpressionMap.get(value).add(greater);
/////////////////////////////////////////////////////////////////////////
0:                 if(valueExpressionMap.get(value) == null) {
0:                   valueExpressionMap.put(value, new ArrayList<>());
1:                 }
0:                 valueExpressionMap.get(value).add(less);
0:                 if(valueExpressionMap.get(value) == null) {
0:                   valueExpressionMap.put(value, new ArrayList<>());
1:                 }
0:                 valueExpressionMap.get(value).add(less2);
/////////////////////////////////////////////////////////////////////////
0:       } else if (valueExpressionMap.size() > 0) {
0:         List<Expression> valuefilters = new ArrayList<>();
0:         Expression finalFilters = null;
0:         List<Expression> expressions;
0:         for (Map.Entry<Object, List<Expression>> entry : valueExpressionMap.entrySet()) {
0:           expressions = valueExpressionMap.get(entry.getKey());
0:           if (expressions.size() == 1) {
0:             finalFilters = expressions.get(0);
0:           } else if (expressions.size() >= 2) {
0:             finalFilters = new OrExpression(expressions.get(0), expressions.get(1));
0:             for (int i = 2; i < expressions.size(); i++) {
0:               finalFilters = new OrExpression(finalFilters, expressions.get(i));
0:           valuefilters.add(finalFilters);
1:         }
1: 
0:         if(valuefilters.size() == 1){
0:           finalFilters = valuefilters.get(0);
0:         } else if (valuefilters.size() >= 2) {
0:          finalFilters = new AndExpression(valuefilters.get(0), valuefilters.get(1));
0:          for (int i = 2; i < valuefilters.size() ; i++) {
0:            finalFilters = new AndExpression(finalFilters, valuefilters.get(i));
1:          }
1:        }
1: 
0:         filters.add(finalFilters);
/////////////////////////////////////////////////////////////////////////
0:           finalFilters = new AndExpression(finalFilters, tmp.get(i));
/////////////////////////////////////////////////////////////////////////
0:     else if (type instanceof DecimalType) {
0:       if(rawdata instanceof  Double) {
1:         return new BigDecimal((Double) rawdata);
0:       } else if (rawdata instanceof  Long) {
1:         return new BigDecimal(new BigInteger(String.valueOf(rawdata)),
1:             ((DecimalType) type).getScale());
1:       }
1:     }
commit:9c83bd1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.presto;
1: 
1: import java.util.ArrayList;
1: import java.util.Calendar;
1: import java.util.Date;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
0: import java.util.stream.Collectors;
1: 
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.scan.expression.ColumnExpression;
1: import org.apache.carbondata.core.scan.expression.Expression;
1: import org.apache.carbondata.core.scan.expression.LiteralExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.EqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.GreaterThanExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.InExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanEqualToExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.LessThanExpression;
1: import org.apache.carbondata.core.scan.expression.conditional.ListExpression;
1: import org.apache.carbondata.core.scan.expression.logical.AndExpression;
1: import org.apache.carbondata.core.scan.expression.logical.OrExpression;
1: 
1: import com.facebook.presto.spi.ColumnHandle;
1: import com.facebook.presto.spi.predicate.Domain;
1: import com.facebook.presto.spi.predicate.Range;
1: import com.facebook.presto.spi.predicate.TupleDomain;
0: import com.facebook.presto.spi.type.BigintType;
0: import com.facebook.presto.spi.type.BooleanType;
0: import com.facebook.presto.spi.type.DateType;
0: import com.facebook.presto.spi.type.DecimalType;
0: import com.facebook.presto.spi.type.DoubleType;
0: import com.facebook.presto.spi.type.IntegerType;
0: import com.facebook.presto.spi.type.SmallintType;
0: import com.facebook.presto.spi.type.TimestampType;
0: import com.facebook.presto.spi.type.Type;
0: import com.facebook.presto.spi.type.VarcharType;
0: import com.google.common.collect.ImmutableList;
1: import io.airlift.slice.Slice;
1: 
1: import static com.google.common.base.Preconditions.checkArgument;
1: 
1: /**
1:  * PrestoFilterUtil create the carbonData Expression from the presto-domain
1:  */
1: public class PrestoFilterUtil {
1: 
1:   private static Map<Integer, Expression> filterMap = new HashMap<>();
1: 
0:   private static DataType Spi2CarbondataTypeMapper(CarbondataColumnHandle carbondataColumnHandle) {
1:     Type colType = carbondataColumnHandle.getColumnType();
0:     if (colType == BooleanType.BOOLEAN) return DataType.BOOLEAN;
0:     else if (colType == SmallintType.SMALLINT) return DataType.SHORT;
0:     else if (colType == IntegerType.INTEGER) return DataType.INT;
0:     else if (colType == BigintType.BIGINT) return DataType.LONG;
0:     else if (colType == DoubleType.DOUBLE) return DataType.DOUBLE;
0:     else if (colType == VarcharType.VARCHAR) return DataType.STRING;
0:     else if (colType == DateType.DATE) return DataType.DATE;
0:     else if (colType == TimestampType.TIMESTAMP) return DataType.TIMESTAMP;
0:     else if (colType == DecimalType.createDecimalType(carbondataColumnHandle.getPrecision(),
0:         carbondataColumnHandle.getScale())) return DataType.DECIMAL;
0:     else return DataType.STRING;
1:   }
1: 
1:   /**
1:    * Convert presto-TupleDomain predication into Carbon scan express condition
1:    *
1:    * @param originalConstraint presto-TupleDomain
1:    * @return
1:    */
1:   static Expression parseFilterExpression(TupleDomain<ColumnHandle> originalConstraint) {
0:     ImmutableList.Builder<Expression> filters = ImmutableList.builder();
1: 
1:     Domain domain;
1: 
1:     for (ColumnHandle c : originalConstraint.getDomains().get().keySet()) {
1: 
1:       // Build ColumnExpression for Expression(Carbondata)
1:       CarbondataColumnHandle cdch = (CarbondataColumnHandle) c;
1:       Type type = cdch.getColumnType();
1: 
0:       DataType coltype = Spi2CarbondataTypeMapper(cdch);
1:       Expression colExpression = new ColumnExpression(cdch.getColumnName(), coltype);
1: 
1:       domain = originalConstraint.getDomains().get().get(c);
1:       checkArgument(domain.getType().isOrderable(), "Domain type must be orderable");
1: 
1:       List<Object> singleValues = new ArrayList<>();
0:       List<Expression> disjuncts = new ArrayList<>();
1:       for (Range range : domain.getValues().getRanges().getOrderedRanges()) {
1:         if (range.isSingleValue()) {
0:           Object value = ConvertDataByType(range.getLow().getValue(), type);
1:           singleValues.add(value);
1:         } else {
0:           List<Expression> rangeConjuncts = new ArrayList<>();
1:           if (!range.getLow().isLowerUnbounded()) {
0:             Object value = ConvertDataByType(range.getLow().getValue(), type);
1:             switch (range.getLow().getBound()) {
1:               case ABOVE:
0:                 if (type == TimestampType.TIMESTAMP) {
0:                   //todo not now
1:                 } else {
0:                   GreaterThanExpression greater = new GreaterThanExpression(colExpression,
1:                       new LiteralExpression(value, coltype));
0:                   rangeConjuncts.add(greater);
1:                 }
1:                 break;
1:               case EXACTLY:
0:                 GreaterThanEqualToExpression greater =
0:                     new GreaterThanEqualToExpression(colExpression,
1:                         new LiteralExpression(value, coltype));
0:                 rangeConjuncts.add(greater);
1:                 break;
1:               case BELOW:
1:                 throw new IllegalArgumentException("Low marker should never use BELOW bound");
1:               default:
1:                 throw new AssertionError("Unhandled bound: " + range.getLow().getBound());
1:             }
1:           }
1:           if (!range.getHigh().isUpperUnbounded()) {
0:             Object value = ConvertDataByType(range.getHigh().getValue(), type);
1:             switch (range.getHigh().getBound()) {
1:               case ABOVE:
1:                 throw new IllegalArgumentException("High marker should never use ABOVE bound");
1:               case EXACTLY:
0:                 LessThanEqualToExpression less = new LessThanEqualToExpression(colExpression,
1:                     new LiteralExpression(value, coltype));
0:                 rangeConjuncts.add(less);
1:                 break;
1:               case BELOW:
0:                 LessThanExpression less2 =
1:                     new LessThanExpression(colExpression, new LiteralExpression(value, coltype));
0:                 rangeConjuncts.add(less2);
1:                 break;
1:               default:
1:                 throw new AssertionError("Unhandled bound: " + range.getHigh().getBound());
1:             }
1:           }
0:           disjuncts.addAll(rangeConjuncts);
1:         }
1:       }
1:       if (singleValues.size() == 1) {
0:         Expression ex;
0:         if (coltype.equals(DataType.STRING)) {
0:           ex = new EqualToExpression(colExpression,
1:               new LiteralExpression(singleValues.get(0), coltype));
0:         } else if (coltype.equals(DataType.TIMESTAMP) || coltype.equals(DataType.DATE)) {
0:           Long value = (Long) singleValues.get(0);
0:           ex = new EqualToExpression(colExpression, new LiteralExpression(value, coltype));
0:         } else ex = new EqualToExpression(colExpression,
1:             new LiteralExpression(singleValues.get(0), coltype));
0:         filters.add(ex);
1:       } else if (singleValues.size() > 1) {
0:         ListExpression candidates = null;
0:         List<Expression> exs = singleValues.stream()
0:             .map((a) -> new LiteralExpression(ConvertDataByType(a, type), coltype))
0:             .collect(Collectors.toList());
0:         candidates = new ListExpression(exs);
1: 
0:         filters.add(new InExpression(colExpression, candidates));
0:       } else if (disjuncts.size() > 0) {
0:         if (disjuncts.size() > 1) {
0:           Expression finalFilters = new OrExpression(disjuncts.get(0), disjuncts.get(1));
0:           if (disjuncts.size() > 2) {
0:             for (int i = 2; i < disjuncts.size(); i++) {
0:               filters.add(new AndExpression(finalFilters, disjuncts.get(i)));
1:             }
1:           } else {
0:             filters.add(finalFilters);
1:           }
0:         } else if (disjuncts.size() == 1) filters.add(disjuncts.get(0));
1:       }
1:     }
1: 
0:     Expression finalFilters;
0:     List<Expression> tmp = filters.build();
0:     if (tmp.size() > 1) {
0:       finalFilters = new AndExpression(tmp.get(0), tmp.get(1));
0:       if (tmp.size() > 2) {
0:         for (int i = 2; i < tmp.size(); i++) {
0:           finalFilters = new OrExpression(finalFilters, tmp.get(i));
1:         }
1:       }
0:     } else if (tmp.size() == 1) finalFilters = tmp.get(0);
0:     else return null;
1:     return finalFilters;
1:   }
1: 
0:   private static Object ConvertDataByType(Object rawdata, Type type) {
0:     if (type.equals(IntegerType.INTEGER)) return new Integer((rawdata.toString()));
0:     else if (type.equals(BigintType.BIGINT)) return rawdata;
0:     else if (type.equals(VarcharType.VARCHAR)) {
1:       if (rawdata instanceof Slice) {
1:         return ((Slice) rawdata).toStringUtf8();
1:       } else {
1:         return rawdata;
1:       }
1: 
0:     } else if (type.equals(BooleanType.BOOLEAN)) return rawdata;
0:     else if (type.equals(DateType.DATE)) {
1:       Calendar c = Calendar.getInstance();
1:       c.setTime(new Date(0));
1:       c.add(Calendar.DAY_OF_YEAR, ((Long) rawdata).intValue());
1:       Date date = c.getTime();
1:       return date.getTime() * 1000;
1:     }
1: 
1:     return rawdata;
1:   }
1: 
1:   /**
1:    * get the filters from key
1:    */
1:   static Expression getFilters(Integer key) {
1:     return filterMap.get(key);
1:   }
1: 
1:   static void setFilter(Integer tableId, Expression filter) {
1:     filterMap.put(tableId, filter);
1:   }
1: }
author:Geetika Gupta
-------------------------------------------------------------------------------
commit:f3b507c
/////////////////////////////////////////////////////////////////////////
0: import com.facebook.presto.spi.type.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       } else if(rawdata instanceof Slice) {
0:         return new BigDecimal(Decimals.decodeUnscaledValue((Slice) rawdata), ((DecimalType) type).getScale());
commit:fa19331
/////////////////////////////////////////////////////////////////////////
1:     } else if (type.equals(TimestampType.TIMESTAMP)) {
0:       return (Long)rawdata * 1000;
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
0:         carbondataColumnHandle.getScale())))
0:       return org.apache.carbondata.core.metadata.datatype.DataTypes.createDecimalType(
0:           carbondataColumnHandle.getPrecision(),
0:           carbondataColumnHandle.getScale());
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:     if (colType == BooleanType.BOOLEAN) return DataTypes.BOOLEAN;
0:     else if (colType == SmallintType.SMALLINT) return DataTypes.SHORT;
0:     else if (colType == IntegerType.INTEGER) return DataTypes.INT;
0:     else if (colType == BigintType.BIGINT) return DataTypes.LONG;
0:     else if (colType == DoubleType.DOUBLE) return DataTypes.DOUBLE;
0:     else if (colType == VarcharType.VARCHAR) return DataTypes.STRING;
0:     else if (colType == DateType.DATE) return DataTypes.DATE;
0:     else if (colType == TimestampType.TIMESTAMP) return DataTypes.TIMESTAMP;
0:         carbondataColumnHandle.getScale()))) return DataTypes.DECIMAL;
0:     else return DataTypes.STRING;
/////////////////////////////////////////////////////////////////////////
0:         if (coltype.equals(DataTypes.STRING)) {
0:         } else if (coltype.equals(DataTypes.TIMESTAMP) || coltype.equals(DataTypes.DATE)) {
author:Raghunandan S
-------------------------------------------------------------------------------
commit:bb0b347
/////////////////////////////////////////////////////////////////////////
0:     if (type.equals(IntegerType.INTEGER)) return Integer.valueOf(rawdata.toString());
0:     // new Integer((rawdata.toString()));
============================================================================