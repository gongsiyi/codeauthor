1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
2:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
5:cd6a4ff:  */
1:377dee9: 
1:cd6a4ff: package org.apache.carbondata.core.cache.dictionary;
1:377dee9: 
1:cd6a4ff: import java.io.IOException;
1:cd6a4ff: import java.util.List;
11:cd6a4ff: 
1:cd6a4ff: import org.apache.carbondata.core.cache.Cache;
1:cd6a4ff: import org.apache.carbondata.core.cache.CacheType;
1:cd6a4ff: import org.apache.carbondata.core.cache.CarbonLRUCache;
1:cd6a4ff: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:ce09aaa: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
1:ce09aaa: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:cd6a4ff: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
1:cd6a4ff: import org.apache.carbondata.core.reader.CarbonDictionaryMetadataReader;
1:ce09aaa: import org.apache.carbondata.core.service.CarbonCommonFactory;
1:cd6a4ff: import org.apache.carbondata.core.service.DictionaryService;
1:cd6a4ff: import org.apache.carbondata.core.util.CarbonProperties;
1:377dee9: import org.apache.carbondata.core.util.ObjectSizeCalculator;
1:cd6a4ff: 
5:cd6a4ff: /**
1:cd6a4ff:  * Abstract class which implements methods common to reverse and forward dictionary cache
1:cd6a4ff:  */
1:cd6a4ff: public abstract class AbstractDictionaryCache<K extends DictionaryColumnUniqueIdentifier,
1:cd6a4ff:     V extends Dictionary>
1:cd6a4ff:     implements Cache<DictionaryColumnUniqueIdentifier, Dictionary> {
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * thread pool size to be used for dictionary data reading
1:cd6a4ff:    */
1:cd6a4ff:   protected int thread_pool_size;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * LRU cache variable
1:cd6a4ff:    */
1:cd6a4ff:   protected CarbonLRUCache carbonLRUCache;
1:cd6a4ff: 
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * @param carbonLRUCache
1:cd6a4ff:    */
1:1155d4d:   public AbstractDictionaryCache(CarbonLRUCache carbonLRUCache) {
1:cd6a4ff:     this.carbonLRUCache = carbonLRUCache;
1:cd6a4ff:     initThreadPoolSize();
11:cd6a4ff:   }
1:377dee9: 
1:531ecdf:   @Override
1:531ecdf:   public void put(DictionaryColumnUniqueIdentifier key, Dictionary value) {
1:531ecdf:     throw new UnsupportedOperationException("Operation not supported");
1:531ecdf:   }
1:531ecdf: 
1:531ecdf: 
1:377dee9:   /**
1:cd6a4ff:    * This method will initialize the thread pool size to be used for creating the
1:cd6a4ff:    * max number of threads for a job
1:cd6a4ff:    */
1:cd6a4ff:   private void initThreadPoolSize() {
1:9e9d689:     thread_pool_size = CarbonProperties.getInstance().getNumberOfCores();
1:531ecdf:   }
1:531ecdf: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will read dictionary metadata file and return the dictionary meta chunks
1:cd6a4ff:    *
1:377dee9:    * @param dictionaryColumnUniqueIdentifier
1:cd6a4ff:    * @return list of dictionary metadata chunks
1:cd6a4ff:    * @throws IOException read and close method throws IO exception
1:377dee9:    */
1:cd6a4ff:   protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile(
1:bcd2839:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
1:377dee9:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
1:377dee9:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
1:1155d4d:         .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
1:531ecdf: 
1:377dee9:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
1:377dee9:     // read metadata file
1:377dee9:     try {
1:377dee9:       carbonDictionaryColumnMetaChunk =
1:cd6a4ff:           columnMetadataReaderImpl.readLastEntryOfDictionaryMetaChunk();
1:377dee9:     } finally {
1:377dee9:       // close the metadata reader
1:377dee9:       columnMetadataReaderImpl.close();
1:cd6a4ff:     }
1:cd6a4ff:     return carbonDictionaryColumnMetaChunk;
1:cd6a4ff:   }
1:377dee9: 
1:cd6a4ff:   /**
1:377dee9:    * get the dictionary column meta chunk for object already read and stored in LRU cache
1:377dee9:    * @param dictionaryColumnUniqueIdentifier
1:377dee9:    * @param offsetRead
1:377dee9:    * @return
1:377dee9:    * @throws IOException
1:377dee9:    */
1:377dee9:   protected long getNumRecordsInCarbonDictionaryColumnMetaChunk(
1:377dee9:           DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, long offsetRead)
1:377dee9:           throws IOException {
1:377dee9:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
1:377dee9:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
1:1155d4d:             .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
1:377dee9: 
1:377dee9:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
1:377dee9:     // read metadata file
1:377dee9:     try {
1:377dee9:       carbonDictionaryColumnMetaChunk =
1:377dee9:               columnMetadataReaderImpl.readEntryOfDictionaryMetaChunk(offsetRead);
1:377dee9:     } finally {
1:377dee9:       // close the metadata reader
1:377dee9:       columnMetadataReaderImpl.close();
1:377dee9:     }
1:377dee9:     return carbonDictionaryColumnMetaChunk.getMax_surrogate_key();
1:377dee9:   }
1:377dee9: 
1:377dee9:   /**
1:cd6a4ff:    * This method will validate dictionary metadata file for any modification
1:cd6a4ff:    *
1:cd6a4ff:    * @param carbonFile
1:cd6a4ff:    * @param fileTimeStamp
1:cd6a4ff:    * @param endOffset
1:377dee9:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   private boolean isDictionaryMetaFileModified(CarbonFile carbonFile, long fileTimeStamp,
1:cd6a4ff:       long endOffset) {
1:cd6a4ff:     return carbonFile.isFileModified(fileTimeStamp, endOffset);
1:377dee9:   }
1:377dee9: 
1:377dee9:   /**
1:cd6a4ff:    * This method will return the carbon file objetc based on its type (local, HDFS)
1:cd6a4ff:    *
1:377dee9:    * @param dictionaryColumnUniqueIdentifier
4:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   private CarbonFile getDictionaryMetaCarbonFile(
1:bcd2839:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
1:29dc302:     String dictionaryFilePath = dictionaryColumnUniqueIdentifier.getDictionaryFilePath();
1:cd6a4ff:     FileFactory.FileType fileType = FileFactory.getFileType(dictionaryFilePath);
1:bcd2839:     CarbonFile dictFile = FileFactory.getCarbonFile(dictionaryFilePath, fileType);
1:bcd2839:     // When rename table triggered parallely with select query, dictionary files may not exist
1:bcd2839:     if (!dictFile.exists()) {
1:bcd2839:       throw new IOException("Dictionary file does not exist: " + dictionaryFilePath);
1:377dee9:     }
1:bcd2839:     return dictFile;
1:bcd2839:   }
1:cd6a4ff: 
1:377dee9:   protected long getSortIndexSize(long numOfRecords) {
1:377dee9:     // sort index has sort index and reverse sort index,each is 4 byte integer.
1:377dee9:     // 32 byte is the array header of both the integer arrays
1:500654e:     return numOfRecords * ObjectSizeCalculator.estimate(0, 16) * 2 + 32;
1:377dee9:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will get the value for the given key. If value does not exist
1:cd6a4ff:    * for the given key, it will check and load the value.
1:cd6a4ff:    *
2:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
2:cd6a4ff:    *                                         tableName and columnIdentifier
1:377dee9:    * @param dictionaryInfo
1:cd6a4ff:    * @param lruCacheKey
1:eaadc88:    * @throws IOException                    in case memory is not sufficient to load dictionary
1:eaadc88:    *                                        into memory
1:377dee9:    */
1:cd6a4ff:   protected void checkAndLoadDictionaryData(
1:cd6a4ff:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
1:cd6a4ff:       DictionaryInfo dictionaryInfo, String lruCacheKey, boolean loadSortIndex)
1:377dee9:       throws IOException {
1:eaadc88:     // read last segm
1:eaadc88:     // ent dictionary meta chunk entry to get the end offset of file
1:eaadc88:     CarbonFile carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
1:eaadc88:     boolean dictionaryMetaFileModified =
1:eaadc88:         isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
1:eaadc88:             dictionaryInfo.getDictionaryMetaFileLength());
1:eaadc88:     // if dictionary metadata file is modified then only read the last entry from dictionary
1:eaadc88:     // meta file
1:eaadc88:     if (dictionaryMetaFileModified) {
1:eaadc88:       synchronized (dictionaryInfo) {
1:eaadc88:         carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
1:eaadc88:         dictionaryMetaFileModified =
1:eaadc88:             isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
1:eaadc88:                 dictionaryInfo.getDictionaryMetaFileLength());
1:eaadc88:         // Double Check :
1:eaadc88:         // if dictionary metadata file is modified then only read the last entry from dictionary
1:eaadc88:         // meta file
1:eaadc88:         if (dictionaryMetaFileModified) {
1:eaadc88:           CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk =
1:eaadc88:               readLastChunkFromDictionaryMetadataFile(dictionaryColumnUniqueIdentifier);
1:377dee9: 
1:377dee9:           long requiredSize = getEstimatedDictionarySize(dictionaryInfo,
1:377dee9:               carbonDictionaryColumnMetaChunk,
1:377dee9:               dictionaryColumnUniqueIdentifier, loadSortIndex);
1:377dee9: 
1:eaadc88:           if (requiredSize > 0) {
1:377dee9:             dictionaryInfo.setMemorySize(requiredSize);
1:377dee9:             boolean colCanBeAddedToLRUCache =
1:377dee9:                     carbonLRUCache.tryPut(lruCacheKey, requiredSize);
1:377dee9:             // if column can be added to lru cache then only load the
1:eaadc88:             // dictionary data
1:377dee9:             if (colCanBeAddedToLRUCache) {
1:eaadc88:               // load dictionary data
1:eaadc88:               loadDictionaryData(dictionaryInfo, dictionaryColumnUniqueIdentifier,
1:377dee9:                       dictionaryInfo.getOffsetTillFileIsRead(),
1:377dee9:                       carbonDictionaryColumnMetaChunk.getEnd_offset(),
1:377dee9:                       loadSortIndex);
1:eaadc88:               // set the end offset till where file is read
1:eaadc88:               dictionaryInfo
1:377dee9:                       .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
1:377dee9:               long updateRequiredSize = ObjectSizeCalculator.estimate(dictionaryInfo, requiredSize);
1:377dee9:               dictionaryInfo.setMemorySize(updateRequiredSize);
1:377dee9:               if (!carbonLRUCache.put(lruCacheKey, dictionaryInfo, updateRequiredSize)) {
1:377dee9:                 throw new DictionaryBuilderException(
1:377dee9:                         "Cannot load dictionary into memory. Not enough memory available");
1:377dee9:               }
1:eaadc88:               dictionaryInfo.setFileTimeStamp(carbonFile.getLastModifiedTime());
1:eaadc88:               dictionaryInfo.setDictionaryMetaFileLength(carbonFile.getSize());
1:eaadc88:             } else {
1:377dee9:               throw new DictionaryBuilderException(
1:377dee9:                       "Cannot load dictionary into memory. Not enough memory available");
1:377dee9:             }
1:377dee9:           }
1:bcd2839:         }
1:cd6a4ff:       }
1:cd6a4ff:     }
1:eaadc88:     // increment the column access count
1:eaadc88:     incrementDictionaryAccessCount(dictionaryInfo);
1:cd6a4ff:   }
1:377dee9: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will prepare the lru cache key and return the same
1:cd6a4ff:    *
1:cd6a4ff:    * @param columnIdentifier
1:377dee9:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   protected String getLruCacheKey(String columnIdentifier, CacheType cacheType) {
1:eaadc88:     return columnIdentifier + CarbonCommonConstants.UNDERSCORE + cacheType.getCacheName();
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will check and load the dictionary file in memory for a given column
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryInfo                   holds dictionary information and data
1:cd6a4ff:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:cd6a4ff:    *                                         tableName and columnIdentifier
1:cd6a4ff:    * @param dictionaryChunkStartOffset       start offset from where dictionary file has to
1:cd6a4ff:    *                                         be read
1:cd6a4ff:    * @param dictionaryChunkEndOffset         end offset till where dictionary file has to
1:cd6a4ff:    *                                         be read
1:cd6a4ff:    * @param loadSortIndex
1:377dee9:    * @throws IOException
1:cd6a4ff:    */
1:cd6a4ff:   private void loadDictionaryData(DictionaryInfo dictionaryInfo,
1:cd6a4ff:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
1:cd6a4ff:       long dictionaryChunkStartOffset, long dictionaryChunkEndOffset, boolean loadSortIndex)
1:eaadc88:       throws IOException {
1:cd6a4ff:     DictionaryCacheLoader dictionaryCacheLoader =
1:1155d4d:         new DictionaryCacheLoaderImpl(dictionaryColumnUniqueIdentifier);
1:cd6a4ff:     dictionaryCacheLoader
1:daa6465:         .load(dictionaryInfo, dictionaryChunkStartOffset, dictionaryChunkEndOffset, loadSortIndex);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will increment the access count for a given dictionary column
1:cd6a4ff:    *
2:cd6a4ff:    * @param dictionaryInfo
1:cd6a4ff:    */
1:cd6a4ff:   protected void incrementDictionaryAccessCount(DictionaryInfo dictionaryInfo) {
1:cd6a4ff:     dictionaryInfo.incrementAccessCount();
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will update the dictionary acceess count which is required for its removal
1:cd6a4ff:    * from column LRU cache
1:cd6a4ff:    *
1:cd6a4ff:    * @param dictionaryList
1:cd6a4ff:    */
1:cd6a4ff:   protected void clearDictionary(List<Dictionary> dictionaryList) {
1:cd6a4ff:     for (Dictionary dictionary : dictionaryList) {
1:cd6a4ff:       dictionary.clear();
1:cd6a4ff:     }
1:cd6a4ff:   }
1:377dee9: 
1:377dee9:   /**
1:377dee9:    * calculate the probable size of Dictionary in java heap
1:377dee9:    * Use the value to check if can be added to lru cache
1:377dee9:    * This helps to avoid unnecessary loading of dictionary files
1:377dee9:    * if estimated size more than that can be fit into lru cache
1:377dee9:    * Estimated size can be less or greater than the actual size
1:377dee9:    * due to java optimizations
1:377dee9:    * @param dictionaryInfo
1:377dee9:    * @param carbonDictionaryColumnMetaChunk
1:377dee9:    * @param dictionaryColumnUniqueIdentifier
1:377dee9:    * @param readSortIndexSize
1:377dee9:    * @return
1:377dee9:    * @throws IOException
1:377dee9:    */
1:377dee9:   protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
1:377dee9:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
1:377dee9:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
1:377dee9:       readSortIndexSize) throws IOException {
1:377dee9:     return 0;
1:377dee9:   }
1:377dee9: }
============================================================================
author:dhatchayani
-------------------------------------------------------------------------------
commit:531ecdf
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public void put(DictionaryColumnUniqueIdentifier key, Dictionary value) {
1:     throw new UnsupportedOperationException("Operation not supported");
1:   }
1: 
1: 
commit:d3a09e2
/////////////////////////////////////////////////////////////////////////
0:             dictionaryColumnUniqueIdentifier, carbonStorePath);
/////////////////////////////////////////////////////////////////////////
0:                     dictionaryColumnUniqueIdentifier, carbonStorePath);
/////////////////////////////////////////////////////////////////////////
0:         dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:         dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:             carbonStorePath, dictionaryColumnUniqueIdentifier);
commit:531ecdf
/////////////////////////////////////////////////////////////////////////
0:   @Override
0:   public void put(DictionaryColumnUniqueIdentifier key, Dictionary value) {
0:     throw new UnsupportedOperationException("Operation not supported");
1:   }
1: 
1: 
commit:d3a09e2
/////////////////////////////////////////////////////////////////////////
0:             dictionaryColumnUniqueIdentifier, carbonStorePath);
/////////////////////////////////////////////////////////////////////////
0:                     dictionaryColumnUniqueIdentifier, carbonStorePath);
/////////////////////////////////////////////////////////////////////////
0:         dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:         dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:             carbonStorePath, dictionaryColumnUniqueIdentifier);
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1:         .load(dictionaryInfo, dictionaryChunkStartOffset, dictionaryChunkEndOffset, loadSortIndex);
commit:daa6465
/////////////////////////////////////////////////////////////////////////
0:         .load(dictionaryInfo, dictionaryChunkStartOffset, dictionaryChunkEndOffset, loadSortIndex);
author:manishgupta88
-------------------------------------------------------------------------------
commit:29dc302
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     String dictionaryFilePath = dictionaryColumnUniqueIdentifier.getDictionaryFilePath();
commit:29dc302
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     String dictionaryFilePath = dictionaryColumnUniqueIdentifier.getDictionaryFilePath();
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
1:   public AbstractDictionaryCache(CarbonLRUCache carbonLRUCache) {
/////////////////////////////////////////////////////////////////////////
1:         .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
1:             .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getAbsoluteCarbonTableIdentifier(),
0:             dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
1:         new DictionaryCacheLoaderImpl(dictionaryColumnUniqueIdentifier);
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
0:   public AbstractDictionaryCache(CarbonLRUCache carbonLRUCache) {
/////////////////////////////////////////////////////////////////////////
0:         .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:             .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getAbsoluteCarbonTableIdentifier(),
0:             dictionaryColumnUniqueIdentifier);
/////////////////////////////////////////////////////////////////////////
0:         new DictionaryCacheLoaderImpl(dictionaryColumnUniqueIdentifier);
author:Zhang Zhichao
-------------------------------------------------------------------------------
commit:9e9d689
/////////////////////////////////////////////////////////////////////////
1:     thread_pool_size = CarbonProperties.getInstance().getNumberOfCores();
commit:9e9d689
/////////////////////////////////////////////////////////////////////////
0:     thread_pool_size = CarbonProperties.getInstance().getNumberOfCores();
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
1:     return numOfRecords * ObjectSizeCalculator.estimate(0, 16) * 2 + 32;
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:     return numOfRecords * ObjectSizeCalculator.estimate(0, 16) * 2 + 32;
author:Raghunandan S
-------------------------------------------------------------------------------
commit:377dee9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.ObjectSizeCalculator;
/////////////////////////////////////////////////////////////////////////
1:    * get the dictionary column meta chunk for object already read and stored in LRU cache
1:    * @param dictionaryColumnUniqueIdentifier
1:    * @param offsetRead
1:    * @return
1:    * @throws IOException
1:    */
1:   protected long getNumRecordsInCarbonDictionaryColumnMetaChunk(
1:           DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, long offsetRead)
1:           throws IOException {
1:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
1:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
0:             .getDictionaryMetadataReader(
0:                     dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:                     dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath);
1: 
1:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
1:     // read metadata file
1:     try {
1:       carbonDictionaryColumnMetaChunk =
1:               columnMetadataReaderImpl.readEntryOfDictionaryMetaChunk(offsetRead);
1:     } finally {
1:       // close the metadata reader
1:       columnMetadataReaderImpl.close();
1:     }
1:     return carbonDictionaryColumnMetaChunk.getMax_surrogate_key();
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   protected long getSortIndexSize(long numOfRecords) {
1:     // sort index has sort index and reverse sort index,each is 4 byte integer.
1:     // 32 byte is the array header of both the integer arrays
0:     return numOfRecords * ObjectSizeCalculator.estimate(new Integer(0), 16) * 2 + 32;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:           long requiredSize = getEstimatedDictionarySize(dictionaryInfo,
1:               carbonDictionaryColumnMetaChunk,
1:               dictionaryColumnUniqueIdentifier, loadSortIndex);
1: 
1:             dictionaryInfo.setMemorySize(requiredSize);
1:             boolean colCanBeAddedToLRUCache =
1:                     carbonLRUCache.tryPut(lruCacheKey, requiredSize);
1:             // if column can be added to lru cache then only load the
1:             if (colCanBeAddedToLRUCache) {
1:                       dictionaryInfo.getOffsetTillFileIsRead(),
1:                       carbonDictionaryColumnMetaChunk.getEnd_offset(),
1:                       loadSortIndex);
1:                       .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
1:               long updateRequiredSize = ObjectSizeCalculator.estimate(dictionaryInfo, requiredSize);
1:               dictionaryInfo.setMemorySize(updateRequiredSize);
1:               if (!carbonLRUCache.put(lruCacheKey, dictionaryInfo, updateRequiredSize)) {
1:                 throw new DictionaryBuilderException(
1:                         "Cannot load dictionary into memory. Not enough memory available");
1:               }
1:                       "Cannot load dictionary into memory. Not enough memory available");
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * calculate the probable size of Dictionary in java heap
1:    * Use the value to check if can be added to lru cache
1:    * This helps to avoid unnecessary loading of dictionary files
1:    * if estimated size more than that can be fit into lru cache
1:    * Estimated size can be less or greater than the actual size
1:    * due to java optimizations
1:    * @param dictionaryInfo
1:    * @param carbonDictionaryColumnMetaChunk
1:    * @param dictionaryColumnUniqueIdentifier
1:    * @param readSortIndexSize
1:    * @return
1:    * @throws IOException
1:    */
1:   protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
1:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
1:       readSortIndexSize) throws IOException {
1:     return 0;
1:   }
commit:377dee9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.util.ObjectSizeCalculator;
/////////////////////////////////////////////////////////////////////////
0:    * get the dictionary column meta chunk for object already read and stored in LRU cache
1:    * @param dictionaryColumnUniqueIdentifier
0:    * @param offsetRead
1:    * @return
1:    * @throws IOException
1:    */
0:   protected long getNumRecordsInCarbonDictionaryColumnMetaChunk(
0:           DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, long offsetRead)
1:           throws IOException {
1:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
1:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
0:             .getDictionaryMetadataReader(
0:                     dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:                     dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath);
1: 
1:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
1:     // read metadata file
1:     try {
1:       carbonDictionaryColumnMetaChunk =
0:               columnMetadataReaderImpl.readEntryOfDictionaryMetaChunk(offsetRead);
1:     } finally {
1:       // close the metadata reader
1:       columnMetadataReaderImpl.close();
1:     }
0:     return carbonDictionaryColumnMetaChunk.getMax_surrogate_key();
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
0:   protected long getSortIndexSize(long numOfRecords) {
0:     // sort index has sort index and reverse sort index,each is 4 byte integer.
0:     // 32 byte is the array header of both the integer arrays
0:     return numOfRecords * ObjectSizeCalculator.estimate(new Integer(0), 16) * 2 + 32;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:           long requiredSize = getEstimatedDictionarySize(dictionaryInfo,
0:               carbonDictionaryColumnMetaChunk,
0:               dictionaryColumnUniqueIdentifier, loadSortIndex);
1: 
0:             dictionaryInfo.setMemorySize(requiredSize);
0:             boolean colCanBeAddedToLRUCache =
0:                     carbonLRUCache.tryPut(lruCacheKey, requiredSize);
0:             // if column can be added to lru cache then only load the
0:             if (colCanBeAddedToLRUCache) {
0:                       dictionaryInfo.getOffsetTillFileIsRead(),
0:                       carbonDictionaryColumnMetaChunk.getEnd_offset(),
0:                       loadSortIndex);
0:                       .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
0:               long updateRequiredSize = ObjectSizeCalculator.estimate(dictionaryInfo, requiredSize);
0:               dictionaryInfo.setMemorySize(updateRequiredSize);
0:               if (!carbonLRUCache.put(lruCacheKey, dictionaryInfo, updateRequiredSize)) {
1:                 throw new DictionaryBuilderException(
0:                         "Cannot load dictionary into memory. Not enough memory available");
1:               }
0:                       "Cannot load dictionary into memory. Not enough memory available");
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
0:    * calculate the probable size of Dictionary in java heap
0:    * Use the value to check if can be added to lru cache
0:    * This helps to avoid unnecessary loading of dictionary files
0:    * if estimated size more than that can be fit into lru cache
0:    * Estimated size can be less or greater than the actual size
0:    * due to java optimizations
1:    * @param dictionaryInfo
0:    * @param carbonDictionaryColumnMetaChunk
1:    * @param dictionaryColumnUniqueIdentifier
0:    * @param readSortIndexSize
1:    * @return
0:    * @throws IOException
1:    */
0:   protected long getEstimatedDictionarySize(DictionaryInfo dictionaryInfo,
0:       CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk,
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier, boolean
0:       readSortIndexSize) throws IOException {
0:     return 0;
1:   }
author:nareshpr
-------------------------------------------------------------------------------
commit:bcd2839
/////////////////////////////////////////////////////////////////////////
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
0:         dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
0:     String dictionaryFilePath = carbonTablePath.getDictionaryMetaFilePath(
0:         dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId());
1:     CarbonFile dictFile = FileFactory.getCarbonFile(dictionaryFilePath, fileType);
1:     // When rename table triggered parallely with select query, dictionary files may not exist
1:     if (!dictFile.exists()) {
1:       throw new IOException("Dictionary file does not exist: " + dictionaryFilePath);
1:     }
1:     return dictFile;
commit:bcd2839
/////////////////////////////////////////////////////////////////////////
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
0:         dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
0:     String dictionaryFilePath = carbonTablePath.getDictionaryMetaFilePath(
0:         dictionaryColumnUniqueIdentifier.getColumnIdentifier().getColumnId());
0:     CarbonFile dictFile = FileFactory.getCarbonFile(dictionaryFilePath, fileType);
0:     // When rename table triggered parallely with select query, dictionary files may not exist
0:     if (!dictFile.exists()) {
0:       throw new IOException("Dictionary file does not exist: " + dictionaryFilePath);
1:     }
0:     return dictFile;
author:QiangCai
-------------------------------------------------------------------------------
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:41347d8
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
author:jackylk
-------------------------------------------------------------------------------
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
1: import org.apache.carbondata.core.service.CarbonCommonFactory;
0: import org.apache.carbondata.core.util.path.CarbonTablePath;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     return FileFactory.getCarbonFile(dictionaryFilePath, fileType);
/////////////////////////////////////////////////////////////////////////
1:    * @throws IOException                    in case memory is not sufficient to load dictionary
1:    *                                        into memory
1:       throws IOException {
1:     // read last segm
1:     // ent dictionary meta chunk entry to get the end offset of file
1:     CarbonFile carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
1:     boolean dictionaryMetaFileModified =
1:         isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
1:             dictionaryInfo.getDictionaryMetaFileLength());
1:     // if dictionary metadata file is modified then only read the last entry from dictionary
1:     // meta file
1:     if (dictionaryMetaFileModified) {
1:       synchronized (dictionaryInfo) {
1:         carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
1:         dictionaryMetaFileModified =
1:             isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
1:                 dictionaryInfo.getDictionaryMetaFileLength());
1:         // Double Check :
1:         // if dictionary metadata file is modified then only read the last entry from dictionary
1:         // meta file
1:         if (dictionaryMetaFileModified) {
1:           CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk =
1:               readLastChunkFromDictionaryMetadataFile(dictionaryColumnUniqueIdentifier);
0:           // required size will be size total size of file - offset till file is
0:           // already read
0:           long requiredSize =
0:               carbonDictionaryColumnMetaChunk.getEnd_offset() - dictionaryInfo.getMemorySize();
1:           if (requiredSize > 0) {
0:             boolean columnAddedToLRUCache =
0:                 carbonLRUCache.put(lruCacheKey, dictionaryInfo, requiredSize);
0:             // if column is successfully added to lru cache then only load the
1:             // dictionary data
0:             if (columnAddedToLRUCache) {
1:               // load dictionary data
1:               loadDictionaryData(dictionaryInfo, dictionaryColumnUniqueIdentifier,
0:                   dictionaryInfo.getMemorySize(), carbonDictionaryColumnMetaChunk.getEnd_offset(),
0:                   loadSortIndex);
1:               // set the end offset till where file is read
1:               dictionaryInfo
0:                   .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
1:               dictionaryInfo.setFileTimeStamp(carbonFile.getLastModifiedTime());
1:               dictionaryInfo.setDictionaryMetaFileLength(carbonFile.getSize());
1:             } else {
0:               throw new DictionaryBuilderException(
0:                   "Cannot load dictionary into memory. Not enough memory available");
1:     // increment the column access count
1:     incrementDictionaryAccessCount(dictionaryInfo);
/////////////////////////////////////////////////////////////////////////
1:     return columnIdentifier + CarbonCommonConstants.UNDERSCORE + cacheType.getCacheName();
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
0: import org.apache.carbondata.core.datastore.impl.FileFactory;
0: import org.apache.carbondata.core.service.CarbonCommonFactory;
0: import org.apache.carbondata.core.util.path.CarbonTablePath;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     return FileFactory.getCarbonFile(dictionaryFilePath, fileType);
/////////////////////////////////////////////////////////////////////////
0:    * @throws IOException                    in case memory is not sufficient to load dictionary
0:    *                                        into memory
0:       throws IOException {
0:     // read last segm
0:     // ent dictionary meta chunk entry to get the end offset of file
0:     CarbonFile carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:     boolean dictionaryMetaFileModified =
0:         isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:             dictionaryInfo.getDictionaryMetaFileLength());
0:     // if dictionary metadata file is modified then only read the last entry from dictionary
0:     // meta file
0:     if (dictionaryMetaFileModified) {
0:       synchronized (dictionaryInfo) {
0:         carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:         dictionaryMetaFileModified =
0:             isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:                 dictionaryInfo.getDictionaryMetaFileLength());
0:         // Double Check :
0:         // if dictionary metadata file is modified then only read the last entry from dictionary
0:         // meta file
0:         if (dictionaryMetaFileModified) {
0:           CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk =
0:               readLastChunkFromDictionaryMetadataFile(dictionaryColumnUniqueIdentifier);
0:           // required size will be size total size of file - offset till file is
0:           // already read
0:           long requiredSize =
0:               carbonDictionaryColumnMetaChunk.getEnd_offset() - dictionaryInfo.getMemorySize();
0:           if (requiredSize > 0) {
0:             boolean columnAddedToLRUCache =
0:                 carbonLRUCache.put(lruCacheKey, dictionaryInfo, requiredSize);
0:             // if column is successfully added to lru cache then only load the
0:             // dictionary data
0:             if (columnAddedToLRUCache) {
0:               // load dictionary data
0:               loadDictionaryData(dictionaryInfo, dictionaryColumnUniqueIdentifier,
0:                   dictionaryInfo.getMemorySize(), carbonDictionaryColumnMetaChunk.getEnd_offset(),
0:                   loadSortIndex);
0:               // set the end offset till where file is read
0:               dictionaryInfo
0:                   .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
0:               dictionaryInfo.setFileTimeStamp(carbonFile.getLastModifiedTime());
0:               dictionaryInfo.setDictionaryMetaFileLength(carbonFile.getSize());
0:             } else {
0:               throw new DictionaryBuilderException(
0:                   "Cannot load dictionary into memory. Not enough memory available");
0:     // increment the column access count
0:     incrementDictionaryAccessCount(dictionaryInfo);
/////////////////////////////////////////////////////////////////////////
0:     return columnIdentifier + CarbonCommonConstants.UNDERSCORE + cacheType.getCacheName();
author:ravipesala
-------------------------------------------------------------------------------
commit:05b2654
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.cache.dictionary;
1: 
1: import java.io.IOException;
1: import java.util.List;
1: 
0: import org.apache.carbondata.common.factory.CarbonCommonFactory;
1: import org.apache.carbondata.core.cache.Cache;
1: import org.apache.carbondata.core.cache.CacheType;
1: import org.apache.carbondata.core.cache.CarbonLRUCache;
0: import org.apache.carbondata.core.carbon.path.CarbonTablePath;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastorage.store.filesystem.CarbonFile;
0: import org.apache.carbondata.core.datastorage.store.impl.FileFactory;
1: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
1: import org.apache.carbondata.core.reader.CarbonDictionaryMetadataReader;
1: import org.apache.carbondata.core.service.DictionaryService;
0: import org.apache.carbondata.core.service.PathService;
1: import org.apache.carbondata.core.util.CarbonProperties;
0: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.core.util.CarbonUtilException;
1: 
1: /**
1:  * Abstract class which implements methods common to reverse and forward dictionary cache
1:  */
1: public abstract class AbstractDictionaryCache<K extends DictionaryColumnUniqueIdentifier,
1:     V extends Dictionary>
1:     implements Cache<DictionaryColumnUniqueIdentifier, Dictionary> {
1: 
1:   /**
1:    * thread pool size to be used for dictionary data reading
1:    */
1:   protected int thread_pool_size;
1: 
1:   /**
1:    * LRU cache variable
1:    */
1:   protected CarbonLRUCache carbonLRUCache;
1: 
1:   /**
0:    * c store path
1:    */
0:   protected String carbonStorePath;
1: 
1:   /**
0:    * @param carbonStorePath
1:    * @param carbonLRUCache
1:    */
0:   public AbstractDictionaryCache(String carbonStorePath, CarbonLRUCache carbonLRUCache) {
0:     this.carbonStorePath = carbonStorePath;
1:     this.carbonLRUCache = carbonLRUCache;
1:     initThreadPoolSize();
1:   }
1: 
1:   /**
1:    * This method will initialize the thread pool size to be used for creating the
1:    * max number of threads for a job
1:    */
1:   private void initThreadPoolSize() {
0:     try {
0:       thread_pool_size = Integer.parseInt(CarbonProperties.getInstance()
0:           .getProperty(CarbonCommonConstants.NUM_CORES_LOADING,
0:               CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
0:     } catch (NumberFormatException e) {
0:       thread_pool_size = Integer.parseInt(CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
1:     }
1:   }
1: 
1:   /**
0:    * This method will check if dictionary and its metadata file exists for a given column
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @return
1:    */
0:   protected boolean isFileExistsForGivenColumn(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     PathService pathService = CarbonCommonFactory.getPathService();
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath,
0:             dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
1: 
0:     String dictionaryFilePath =
0:         carbonTablePath.getDictionaryFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
0:     String dictionaryMetadataFilePath =
0:         carbonTablePath.getDictionaryMetaFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
0:     // check if both dictionary and its metadata file exists for a given column
0:     return CarbonUtil.isFileExists(dictionaryFilePath) && CarbonUtil
0:         .isFileExists(dictionaryMetadataFilePath);
1:   }
1: 
1:   /**
1:    * This method will read dictionary metadata file and return the dictionary meta chunks
1:    *
0:    * @param dictionaryColumnUniqueIdentifier
1:    * @return list of dictionary metadata chunks
1:    * @throws IOException read and close method throws IO exception
1:    */
1:   protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
0:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
0:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
0:         .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:             dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath);
1: 
0:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
0:     // read metadata file
0:     try {
0:       carbonDictionaryColumnMetaChunk =
1:           columnMetadataReaderImpl.readLastEntryOfDictionaryMetaChunk();
0:     } finally {
0:       // close the metadata reader
0:       columnMetadataReaderImpl.close();
1:     }
1:     return carbonDictionaryColumnMetaChunk;
1:   }
1: 
1:   /**
1:    * This method will validate dictionary metadata file for any modification
1:    *
1:    * @param carbonFile
1:    * @param fileTimeStamp
1:    * @param endOffset
1:    * @return
1:    */
1:   private boolean isDictionaryMetaFileModified(CarbonFile carbonFile, long fileTimeStamp,
1:       long endOffset) {
1:     return carbonFile.isFileModified(fileTimeStamp, endOffset);
1:   }
1: 
1:   /**
1:    * This method will return the carbon file objetc based on its type (local, HDFS)
1:    *
0:    * @param dictionaryColumnUniqueIdentifier
1:    * @return
1:    */
1:   private CarbonFile getDictionaryMetaCarbonFile(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     PathService pathService = CarbonCommonFactory.getPathService();
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath,
0:             dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
0:     String dictionaryFilePath =
0:         carbonTablePath.getDictionaryMetaFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
1:     FileFactory.FileType fileType = FileFactory.getFileType(dictionaryFilePath);
0:     CarbonFile carbonFile = FileFactory.getCarbonFile(dictionaryFilePath, fileType);
0:     return carbonFile;
1:   }
1: 
1:   /**
1:    * This method will get the value for the given key. If value does not exist
1:    * for the given key, it will check and load the value.
1:    *
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @param dictionaryInfo
1:    * @param lruCacheKey
0:    * @param loadSortIndex                    read and load sort index file in memory
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
1:    */
1:   protected void checkAndLoadDictionaryData(
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
1:       DictionaryInfo dictionaryInfo, String lruCacheKey, boolean loadSortIndex)
0:       throws CarbonUtilException {
0:     try {
0:       // read last segment dictionary meta chunk entry to get the end offset of file
0:       CarbonFile carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:       boolean dictionaryMetaFileModified =
0:           isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:               dictionaryInfo.getDictionaryMetaFileLength());
0:       // if dictionary metadata file is modified then only read the last entry from dictionary
0:       // meta file
0:       if (dictionaryMetaFileModified) {
0:         synchronized (dictionaryInfo) {
0:           carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:           dictionaryMetaFileModified =
0:               isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:                   dictionaryInfo.getDictionaryMetaFileLength());
0:           // Double Check :
0:           // if dictionary metadata file is modified then only read the last entry from dictionary
0:           // meta file
0:           if (dictionaryMetaFileModified) {
0:             CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk =
0:                 readLastChunkFromDictionaryMetadataFile(dictionaryColumnUniqueIdentifier);
0:             // required size will be size total size of file - offset till file is
0:             // already read
0:             long requiredSize =
0:                 carbonDictionaryColumnMetaChunk.getEnd_offset() - dictionaryInfo.getMemorySize();
0:             if (requiredSize > 0) {
0:               boolean columnAddedToLRUCache =
0:                   carbonLRUCache.put(lruCacheKey, dictionaryInfo, requiredSize);
0:               // if column is successfully added to lru cache then only load the
0:               // dictionary data
0:               if (columnAddedToLRUCache) {
0:                 // load dictionary data
0:                 loadDictionaryData(dictionaryInfo, dictionaryColumnUniqueIdentifier,
0:                     dictionaryInfo.getMemorySize(), carbonDictionaryColumnMetaChunk.getEnd_offset(),
0:                     loadSortIndex);
0:                 // set the end offset till where file is read
0:                 dictionaryInfo
0:                     .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
0:                 dictionaryInfo.setFileTimeStamp(carbonFile.getLastModifiedTime());
0:                 dictionaryInfo.setDictionaryMetaFileLength(carbonFile.getSize());
0:               } else {
0:                 throw new CarbonUtilException(
0:                     "Cannot load dictionary into memory. Not enough memory available");
1:               }
1:             }
1:           }
1:         }
1:       }
0:       // increment the column access count
0:       incrementDictionaryAccessCount(dictionaryInfo);
0:     } catch (IOException e) {
0:       throw new CarbonUtilException(e.getMessage());
1:     }
1:   }
1: 
1:   /**
1:    * This method will prepare the lru cache key and return the same
1:    *
1:    * @param columnIdentifier
1:    * @return
1:    */
1:   protected String getLruCacheKey(String columnIdentifier, CacheType cacheType) {
0:     String lruCacheKey =
0:         columnIdentifier + CarbonCommonConstants.UNDERSCORE + cacheType.getCacheName();
0:     return lruCacheKey;
1:   }
1: 
1:   /**
1:    * This method will check and load the dictionary file in memory for a given column
1:    *
1:    * @param dictionaryInfo                   holds dictionary information and data
1:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
1:    *                                         tableName and columnIdentifier
1:    * @param dictionaryChunkStartOffset       start offset from where dictionary file has to
1:    *                                         be read
1:    * @param dictionaryChunkEndOffset         end offset till where dictionary file has to
1:    *                                         be read
1:    * @param loadSortIndex
0:    * @throws IOException
1:    */
1:   private void loadDictionaryData(DictionaryInfo dictionaryInfo,
1:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
1:       long dictionaryChunkStartOffset, long dictionaryChunkEndOffset, boolean loadSortIndex)
0:       throws IOException {
1:     DictionaryCacheLoader dictionaryCacheLoader =
0:         new DictionaryCacheLoaderImpl(dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:             carbonStorePath);
1:     dictionaryCacheLoader
0:         .load(dictionaryInfo, dictionaryColumnUniqueIdentifier.getColumnIdentifier(),
0:             dictionaryChunkStartOffset, dictionaryChunkEndOffset, loadSortIndex);
1:   }
1: 
1:   /**
1:    * This method will increment the access count for a given dictionary column
1:    *
1:    * @param dictionaryInfo
1:    */
1:   protected void incrementDictionaryAccessCount(DictionaryInfo dictionaryInfo) {
1:     dictionaryInfo.incrementAccessCount();
1:   }
1: 
1:   /**
1:    * This method will update the dictionary acceess count which is required for its removal
1:    * from column LRU cache
1:    *
1:    * @param dictionaryList
1:    */
1:   protected void clearDictionary(List<Dictionary> dictionaryList) {
1:     for (Dictionary dictionary : dictionaryList) {
1:       dictionary.clear();
1:     }
1:   }
1: }
commit:05b2654
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.carbondata.core.cache.dictionary;
0: 
0: import java.io.IOException;
0: import java.util.List;
0: 
0: import org.apache.carbondata.common.factory.CarbonCommonFactory;
0: import org.apache.carbondata.core.cache.Cache;
0: import org.apache.carbondata.core.cache.CacheType;
0: import org.apache.carbondata.core.cache.CarbonLRUCache;
0: import org.apache.carbondata.core.carbon.path.CarbonTablePath;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastorage.store.filesystem.CarbonFile;
0: import org.apache.carbondata.core.datastorage.store.impl.FileFactory;
0: import org.apache.carbondata.core.reader.CarbonDictionaryColumnMetaChunk;
0: import org.apache.carbondata.core.reader.CarbonDictionaryMetadataReader;
0: import org.apache.carbondata.core.service.DictionaryService;
0: import org.apache.carbondata.core.service.PathService;
0: import org.apache.carbondata.core.util.CarbonProperties;
0: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.core.util.CarbonUtilException;
0: 
0: /**
0:  * Abstract class which implements methods common to reverse and forward dictionary cache
0:  */
0: public abstract class AbstractDictionaryCache<K extends DictionaryColumnUniqueIdentifier,
0:     V extends Dictionary>
0:     implements Cache<DictionaryColumnUniqueIdentifier, Dictionary> {
0: 
0:   /**
0:    * thread pool size to be used for dictionary data reading
0:    */
0:   protected int thread_pool_size;
0: 
0:   /**
0:    * LRU cache variable
0:    */
0:   protected CarbonLRUCache carbonLRUCache;
0: 
0:   /**
0:    * c store path
0:    */
0:   protected String carbonStorePath;
0: 
0:   /**
0:    * @param carbonStorePath
0:    * @param carbonLRUCache
0:    */
0:   public AbstractDictionaryCache(String carbonStorePath, CarbonLRUCache carbonLRUCache) {
0:     this.carbonStorePath = carbonStorePath;
0:     this.carbonLRUCache = carbonLRUCache;
0:     initThreadPoolSize();
0:   }
0: 
0:   /**
0:    * This method will initialize the thread pool size to be used for creating the
0:    * max number of threads for a job
0:    */
0:   private void initThreadPoolSize() {
0:     try {
0:       thread_pool_size = Integer.parseInt(CarbonProperties.getInstance()
0:           .getProperty(CarbonCommonConstants.NUM_CORES_LOADING,
0:               CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
0:     } catch (NumberFormatException e) {
0:       thread_pool_size = Integer.parseInt(CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
0:     }
0:   }
0: 
0:   /**
0:    * This method will check if dictionary and its metadata file exists for a given column
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @return
0:    */
0:   protected boolean isFileExistsForGivenColumn(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     PathService pathService = CarbonCommonFactory.getPathService();
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath,
0:             dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
0: 
0:     String dictionaryFilePath =
0:         carbonTablePath.getDictionaryFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
0:     String dictionaryMetadataFilePath =
0:         carbonTablePath.getDictionaryMetaFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
0:     // check if both dictionary and its metadata file exists for a given column
0:     return CarbonUtil.isFileExists(dictionaryFilePath) && CarbonUtil
0:         .isFileExists(dictionaryMetadataFilePath);
0:   }
0: 
0:   /**
0:    * This method will read dictionary metadata file and return the dictionary meta chunks
0:    *
0:    * @param dictionaryColumnUniqueIdentifier
0:    * @return list of dictionary metadata chunks
0:    * @throws IOException read and close method throws IO exception
0:    */
0:   protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {
0:     DictionaryService dictService = CarbonCommonFactory.getDictionaryService();
0:     CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService
0:         .getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:             dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath);
0: 
0:     CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null;
0:     // read metadata file
0:     try {
0:       carbonDictionaryColumnMetaChunk =
0:           columnMetadataReaderImpl.readLastEntryOfDictionaryMetaChunk();
0:     } finally {
0:       // close the metadata reader
0:       columnMetadataReaderImpl.close();
0:     }
0:     return carbonDictionaryColumnMetaChunk;
0:   }
0: 
0:   /**
0:    * This method will validate dictionary metadata file for any modification
0:    *
0:    * @param carbonFile
0:    * @param fileTimeStamp
0:    * @param endOffset
0:    * @return
0:    */
0:   private boolean isDictionaryMetaFileModified(CarbonFile carbonFile, long fileTimeStamp,
0:       long endOffset) {
0:     return carbonFile.isFileModified(fileTimeStamp, endOffset);
0:   }
0: 
0:   /**
0:    * This method will return the carbon file objetc based on its type (local, HDFS)
0:    *
0:    * @param dictionaryColumnUniqueIdentifier
0:    * @return
0:    */
0:   private CarbonFile getDictionaryMetaCarbonFile(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) {
0:     PathService pathService = CarbonCommonFactory.getPathService();
0:     CarbonTablePath carbonTablePath = pathService
0:         .getCarbonTablePath(dictionaryColumnUniqueIdentifier.getColumnIdentifier(), carbonStorePath,
0:             dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier());
0:     String dictionaryFilePath =
0:         carbonTablePath.getDictionaryMetaFilePath(dictionaryColumnUniqueIdentifier
0:             .getColumnIdentifier().getColumnId());
0:     FileFactory.FileType fileType = FileFactory.getFileType(dictionaryFilePath);
0:     CarbonFile carbonFile = FileFactory.getCarbonFile(dictionaryFilePath, fileType);
0:     return carbonFile;
0:   }
0: 
0:   /**
0:    * This method will get the value for the given key. If value does not exist
0:    * for the given key, it will check and load the value.
0:    *
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @param dictionaryInfo
0:    * @param lruCacheKey
0:    * @param loadSortIndex                    read and load sort index file in memory
0:    * @throws CarbonUtilException in case memory is not sufficient to load dictionary into memory
0:    */
0:   protected void checkAndLoadDictionaryData(
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
0:       DictionaryInfo dictionaryInfo, String lruCacheKey, boolean loadSortIndex)
0:       throws CarbonUtilException {
0:     try {
0:       // read last segment dictionary meta chunk entry to get the end offset of file
0:       CarbonFile carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:       boolean dictionaryMetaFileModified =
0:           isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:               dictionaryInfo.getDictionaryMetaFileLength());
0:       // if dictionary metadata file is modified then only read the last entry from dictionary
0:       // meta file
0:       if (dictionaryMetaFileModified) {
0:         synchronized (dictionaryInfo) {
0:           carbonFile = getDictionaryMetaCarbonFile(dictionaryColumnUniqueIdentifier);
0:           dictionaryMetaFileModified =
0:               isDictionaryMetaFileModified(carbonFile, dictionaryInfo.getFileTimeStamp(),
0:                   dictionaryInfo.getDictionaryMetaFileLength());
0:           // Double Check :
0:           // if dictionary metadata file is modified then only read the last entry from dictionary
0:           // meta file
0:           if (dictionaryMetaFileModified) {
0:             CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk =
0:                 readLastChunkFromDictionaryMetadataFile(dictionaryColumnUniqueIdentifier);
0:             // required size will be size total size of file - offset till file is
0:             // already read
0:             long requiredSize =
0:                 carbonDictionaryColumnMetaChunk.getEnd_offset() - dictionaryInfo.getMemorySize();
0:             if (requiredSize > 0) {
0:               boolean columnAddedToLRUCache =
0:                   carbonLRUCache.put(lruCacheKey, dictionaryInfo, requiredSize);
0:               // if column is successfully added to lru cache then only load the
0:               // dictionary data
0:               if (columnAddedToLRUCache) {
0:                 // load dictionary data
0:                 loadDictionaryData(dictionaryInfo, dictionaryColumnUniqueIdentifier,
0:                     dictionaryInfo.getMemorySize(), carbonDictionaryColumnMetaChunk.getEnd_offset(),
0:                     loadSortIndex);
0:                 // set the end offset till where file is read
0:                 dictionaryInfo
0:                     .setOffsetTillFileIsRead(carbonDictionaryColumnMetaChunk.getEnd_offset());
0:                 dictionaryInfo.setFileTimeStamp(carbonFile.getLastModifiedTime());
0:                 dictionaryInfo.setDictionaryMetaFileLength(carbonFile.getSize());
0:               } else {
0:                 throw new CarbonUtilException(
0:                     "Cannot load dictionary into memory. Not enough memory available");
0:               }
0:             }
0:           }
0:         }
0:       }
0:       // increment the column access count
0:       incrementDictionaryAccessCount(dictionaryInfo);
0:     } catch (IOException e) {
0:       throw new CarbonUtilException(e.getMessage());
0:     }
0:   }
0: 
0:   /**
0:    * This method will prepare the lru cache key and return the same
0:    *
0:    * @param columnIdentifier
0:    * @return
0:    */
0:   protected String getLruCacheKey(String columnIdentifier, CacheType cacheType) {
0:     String lruCacheKey =
0:         columnIdentifier + CarbonCommonConstants.UNDERSCORE + cacheType.getCacheName();
0:     return lruCacheKey;
0:   }
0: 
0:   /**
0:    * This method will check and load the dictionary file in memory for a given column
0:    *
0:    * @param dictionaryInfo                   holds dictionary information and data
0:    * @param dictionaryColumnUniqueIdentifier unique identifier which contains dbName,
0:    *                                         tableName and columnIdentifier
0:    * @param dictionaryChunkStartOffset       start offset from where dictionary file has to
0:    *                                         be read
0:    * @param dictionaryChunkEndOffset         end offset till where dictionary file has to
0:    *                                         be read
0:    * @param loadSortIndex
0:    * @throws IOException
0:    */
0:   private void loadDictionaryData(DictionaryInfo dictionaryInfo,
0:       DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier,
0:       long dictionaryChunkStartOffset, long dictionaryChunkEndOffset, boolean loadSortIndex)
0:       throws IOException {
0:     DictionaryCacheLoader dictionaryCacheLoader =
0:         new DictionaryCacheLoaderImpl(dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),
0:             carbonStorePath);
0:     dictionaryCacheLoader
0:         .load(dictionaryInfo, dictionaryColumnUniqueIdentifier.getColumnIdentifier(),
0:             dictionaryChunkStartOffset, dictionaryChunkEndOffset, loadSortIndex);
0:   }
0: 
0:   /**
0:    * This method will increment the access count for a given dictionary column
0:    *
0:    * @param dictionaryInfo
0:    */
0:   protected void incrementDictionaryAccessCount(DictionaryInfo dictionaryInfo) {
0:     dictionaryInfo.incrementAccessCount();
0:   }
0: 
0:   /**
0:    * This method will update the dictionary acceess count which is required for its removal
0:    * from column LRU cache
0:    *
0:    * @param dictionaryList
0:    */
0:   protected void clearDictionary(List<Dictionary> dictionaryList) {
0:     for (Dictionary dictionary : dictionaryList) {
0:       dictionary.clear();
0:     }
0:   }
0: }
author:hexiaoqiao
-------------------------------------------------------------------------------
commit:77c90b8
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService.getCarbonTablePath(carbonStorePath,
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService.getCarbonTablePath(carbonStorePath,
commit:77c90b8
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService.getCarbonTablePath(carbonStorePath,
/////////////////////////////////////////////////////////////////////////
0:     CarbonTablePath carbonTablePath = pathService.getCarbonTablePath(carbonStorePath,
============================================================================