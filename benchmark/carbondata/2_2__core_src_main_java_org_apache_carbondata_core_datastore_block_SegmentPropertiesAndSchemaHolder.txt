1:f4a58c5: /*
1:f4a58c5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f4a58c5:  * contributor license agreements.  See the NOTICE file distributed with
1:f4a58c5:  * this work for additional information regarding copyright ownership.
1:f4a58c5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f4a58c5:  * (the "License"); you may not use this file except in compliance with
1:f4a58c5:  * the License.  You may obtain a copy of the License at
1:f4a58c5:  *
1:f4a58c5:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f4a58c5:  *
1:f4a58c5:  * Unless required by applicable law or agreed to in writing, software
1:f4a58c5:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f4a58c5:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f4a58c5:  * See the License for the specific language governing permissions and
1:f4a58c5:  * limitations under the License.
1:f4a58c5:  */
1:f4a58c5: package org.apache.carbondata.core.datastore.block;
1:f4a58c5: 
1:f4a58c5: import java.util.ArrayList;
1:f4a58c5: import java.util.Arrays;
1:f4a58c5: import java.util.HashSet;
1:f4a58c5: import java.util.List;
1:f4a58c5: import java.util.Map;
1:f4a58c5: import java.util.Set;
1:f4a58c5: import java.util.concurrent.ConcurrentHashMap;
1:f4a58c5: import java.util.concurrent.atomic.AtomicInteger;
1:f4a58c5: 
1:f4a58c5: import org.apache.carbondata.common.logging.LogService;
1:f4a58c5: import org.apache.carbondata.common.logging.LogServiceFactory;
1:f4a58c5: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:f4a58c5: import org.apache.carbondata.core.indexstore.schema.CarbonRowSchema;
1:f4a58c5: import org.apache.carbondata.core.indexstore.schema.SchemaGenerator;
1:dc29319: import org.apache.carbondata.core.memory.MemoryException;
1:f4a58c5: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:dc29319: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:dc29319: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1:f4a58c5: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:f4a58c5: 
1:f4a58c5: /**
1:f4a58c5:  * Singleton class which will help in creating the segment properties
1:f4a58c5:  */
1:f4a58c5: public class SegmentPropertiesAndSchemaHolder {
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Logger
1:f4a58c5:    */
1:f4a58c5:   private static final LogService LOGGER =
1:f4a58c5:       LogServiceFactory.getLogService(SegmentPropertiesAndSchemaHolder.class.getName());
1:f4a58c5:   /**
1:f4a58c5:    * SegmentPropertiesAndSchemaHolder instance
1:f4a58c5:    */
1:f4a58c5:   private static final SegmentPropertiesAndSchemaHolder INSTANCE =
1:f4a58c5:       new SegmentPropertiesAndSchemaHolder();
1:f4a58c5:   /**
1:f4a58c5:    * object level lock
1:f4a58c5:    */
1:f4a58c5:   private static final Object lock = new Object();
1:f4a58c5:   /**
1:f4a58c5:    * counter for maintaining the index of segmentProperties
1:f4a58c5:    */
1:f4a58c5:   private static final AtomicInteger segmentPropertiesIndexCounter = new AtomicInteger(0);
1:f4a58c5:   /**
1:f4a58c5:    * holds segmentPropertiesWrapper to segment ID and segmentProperties Index wrapper mapping.
1:f4a58c5:    * Will be used while invaliding a segment and drop table
1:f4a58c5:    */
1:f4a58c5:   private Map<SegmentPropertiesWrapper, SegmentIdAndSegmentPropertiesIndexWrapper>
1:f4a58c5:       segmentPropWrapperToSegmentSetMap = new ConcurrentHashMap<>();
1:f4a58c5:   /**
1:f4a58c5:    * reverse mapping for segmentProperties index to segmentPropertiesWrapper
1:f4a58c5:    */
1:f4a58c5:   private static Map<Integer, SegmentPropertiesWrapper> indexToSegmentPropertiesWrapperMapping =
1:f4a58c5:       new ConcurrentHashMap<>();
1:f4a58c5:   /**
1:f4a58c5:    * Map to be used for table level locking while populating segmentProperties
1:f4a58c5:    */
1:f4a58c5:   private Map<String, Object> absoluteTableIdentifierByteMap = new ConcurrentHashMap<>();
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * private constructor for singleton instance
1:f4a58c5:    */
1:f4a58c5:   private SegmentPropertiesAndSchemaHolder() {
1:f4a58c5: 
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   public static SegmentPropertiesAndSchemaHolder getInstance() {
1:f4a58c5:     return INSTANCE;
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Method to add the segment properties and avoid construction of new segment properties until
1:f4a58c5:    * the schema is not modified
1:f4a58c5:    *
1:dc29319:    * @param carbonTable
1:f4a58c5:    * @param columnsInTable
1:f4a58c5:    * @param columnCardinality
1:f4a58c5:    * @param segmentId
1:f4a58c5:    */
1:dc29319:   public int addSegmentProperties(CarbonTable carbonTable,
1:f4a58c5:       List<ColumnSchema> columnsInTable, int[] columnCardinality, String segmentId) {
1:f4a58c5:     SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper segmentPropertiesWrapper =
1:dc29319:         new SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper(carbonTable,
1:f4a58c5:             columnsInTable, columnCardinality);
1:f4a58c5:     SegmentIdAndSegmentPropertiesIndexWrapper segmentIdSetAndIndexWrapper =
1:f4a58c5:         this.segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:f4a58c5:     if (null == segmentIdSetAndIndexWrapper) {
1:dc29319:       synchronized (getOrCreateTableLock(carbonTable.getAbsoluteTableIdentifier())) {
1:f4a58c5:         segmentIdSetAndIndexWrapper =
1:f4a58c5:             this.segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:f4a58c5:         if (null == segmentIdSetAndIndexWrapper) {
1:f4a58c5:           // create new segmentProperties
1:a20f22e:           segmentPropertiesWrapper.initSegmentProperties();
1:a20f22e:           segmentPropertiesWrapper.addMinMaxColumns(carbonTable);
1:f4a58c5:           int segmentPropertiesIndex = segmentPropertiesIndexCounter.incrementAndGet();
1:f4a58c5:           indexToSegmentPropertiesWrapperMapping
1:f4a58c5:               .put(segmentPropertiesIndex, segmentPropertiesWrapper);
1:dc29319:           LOGGER.info("Constructing new SegmentProperties for table: " + carbonTable
1:f4a58c5:               .getCarbonTableIdentifier().getTableUniqueName()
1:f4a58c5:               + ". Current size of segment properties" + " holder list is: "
1:f4a58c5:               + indexToSegmentPropertiesWrapperMapping.size());
1:f4a58c5:           // populate the SegmentIdAndSegmentPropertiesIndexWrapper to maintain the set of segments
1:f4a58c5:           // having same SegmentPropertiesWrapper instance this will used to decide during the
1:f4a58c5:           // tblSegmentsProperties map clean-up for the invalid segments
1:f4a58c5:           segmentIdSetAndIndexWrapper =
1:f4a58c5:               new SegmentIdAndSegmentPropertiesIndexWrapper(segmentId, segmentPropertiesIndex);
1:f4a58c5:           segmentPropWrapperToSegmentSetMap
1:f4a58c5:               .put(segmentPropertiesWrapper, segmentIdSetAndIndexWrapper);
1:f4a58c5:         }
1:f4a58c5:       }
1:f4a58c5:     } else {
1:dc29319:       synchronized (getOrCreateTableLock(carbonTable.getAbsoluteTableIdentifier())) {
1:f4a58c5:         segmentIdSetAndIndexWrapper.addSegmentId(segmentId);
1:a20f22e:         indexToSegmentPropertiesWrapperMapping
1:a20f22e:             .get(segmentIdSetAndIndexWrapper.getSegmentPropertiesIndex())
1:a20f22e:             .addMinMaxColumns(carbonTable);
1:f4a58c5:       }
1:f4a58c5:     }
1:f4a58c5:     return segmentIdSetAndIndexWrapper.getSegmentPropertiesIndex();
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Method to create table Level lock
1:f4a58c5:    *
1:f4a58c5:    * @param absoluteTableIdentifier
1:f4a58c5:    * @return
1:f4a58c5:    */
1:f4a58c5:   private Object getOrCreateTableLock(AbsoluteTableIdentifier absoluteTableIdentifier) {
1:f4a58c5:     Object tableLock = absoluteTableIdentifierByteMap
1:f4a58c5:         .get(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:f4a58c5:     if (null == tableLock) {
1:f4a58c5:       synchronized (lock) {
1:f4a58c5:         tableLock = absoluteTableIdentifierByteMap
1:f4a58c5:             .get(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:f4a58c5:         if (null == tableLock) {
1:f4a58c5:           tableLock = new Object();
1:f4a58c5:           absoluteTableIdentifierByteMap
1:f4a58c5:               .put(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName(),
1:f4a58c5:                   tableLock);
1:f4a58c5:         }
1:f4a58c5:       }
1:f4a58c5:     }
1:f4a58c5:     return tableLock;
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Method to get the segment properties from given index
1:f4a58c5:    *
1:f4a58c5:    * @param segmentPropertiesIndex
1:f4a58c5:    * @return
1:f4a58c5:    */
1:f4a58c5:   public SegmentProperties getSegmentProperties(int segmentPropertiesIndex) {
1:f4a58c5:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:f4a58c5:         getSegmentPropertiesWrapper(segmentPropertiesIndex);
1:f4a58c5:     if (null != segmentPropertiesWrapper) {
1:f4a58c5:       return segmentPropertiesWrapper.getSegmentProperties();
1:f4a58c5:     }
1:f4a58c5:     return null;
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Method to get the segment properties from given index
1:f4a58c5:    *
1:f4a58c5:    * @param segmentPropertiesWrapperIndex
1:f4a58c5:    * @return
1:f4a58c5:    */
1:f4a58c5:   public SegmentPropertiesWrapper getSegmentPropertiesWrapper(int segmentPropertiesWrapperIndex) {
1:f4a58c5:     return indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesWrapperIndex);
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * This method will remove the segment properties from the map on drop table
1:f4a58c5:    *
1:f4a58c5:    * @param absoluteTableIdentifier
1:f4a58c5:    */
1:f4a58c5:   public void invalidate(AbsoluteTableIdentifier absoluteTableIdentifier) {
1:f4a58c5:     List<SegmentPropertiesWrapper> segmentPropertiesWrappersToBeRemoved = new ArrayList<>();
1:f4a58c5:     // remove segmentProperties wrapper entries from the copyOnWriteArrayList
1:f4a58c5:     for (Map.Entry<SegmentPropertiesWrapper, SegmentIdAndSegmentPropertiesIndexWrapper> entry :
1:f4a58c5:           segmentPropWrapperToSegmentSetMap.entrySet()) {
1:f4a58c5:       SegmentPropertiesWrapper segmentPropertiesWrapper = entry.getKey();
1:f4a58c5:       if (segmentPropertiesWrapper.getTableIdentifier().getCarbonTableIdentifier()
1:f4a58c5:           .getTableUniqueName()
1:f4a58c5:           .equals(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName())) {
1:f4a58c5:         SegmentIdAndSegmentPropertiesIndexWrapper value = entry.getValue();
1:f4a58c5:         // remove from the reverse mapping map
1:f4a58c5:         indexToSegmentPropertiesWrapperMapping.remove(value.getSegmentPropertiesIndex());
1:f4a58c5:         segmentPropertiesWrappersToBeRemoved.add(segmentPropertiesWrapper);
1:f4a58c5:       }
1:f4a58c5:     }
1:f4a58c5:     // remove all the segmentPropertiesWrapper entries from map
1:f4a58c5:     for (SegmentPropertiesWrapper segmentPropertiesWrapper : segmentPropertiesWrappersToBeRemoved) {
1:f4a58c5:       segmentPropWrapperToSegmentSetMap.remove(segmentPropertiesWrapper);
1:f4a58c5:     }
1:f4a58c5:     // remove the table lock
1:f4a58c5:     absoluteTableIdentifierByteMap
1:f4a58c5:         .remove(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * Method to remove the given segment ID
1:f4a58c5:    *
1:f4a58c5:    * @param segmentId
1:f4a58c5:    * @param segmentPropertiesIndex
1:8e78957:    * @param clearSegmentWrapperFromMap flag to specify whether to clear segmentPropertiesWrapper
1:8e78957:    *                                   from Map if all the segment's using it have become stale
1:f4a58c5:    */
1:8e78957:   public void invalidate(String segmentId, int segmentPropertiesIndex,
1:8e78957:       boolean clearSegmentWrapperFromMap) {
1:f4a58c5:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:f4a58c5:         indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesIndex);
1:f4a58c5:     if (null != segmentPropertiesWrapper) {
1:f4a58c5:       SegmentIdAndSegmentPropertiesIndexWrapper segmentIdAndSegmentPropertiesIndexWrapper =
1:f4a58c5:           segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:a20f22e:       synchronized (getOrCreateTableLock(segmentPropertiesWrapper.getTableIdentifier())) {
1:f4a58c5:         segmentIdAndSegmentPropertiesIndexWrapper.removeSegmentId(segmentId);
1:f4a58c5:       }
1:f4a58c5:       // if after removal of given SegmentId, the segmentIdSet becomes empty that means this
1:f4a58c5:       // segmentPropertiesWrapper is not getting used at all. In that case this object can be
1:f4a58c5:       // removed from all the holders
1:8e78957:       if (clearSegmentWrapperFromMap && segmentIdAndSegmentPropertiesIndexWrapper.segmentIdSet
1:8e78957:           .isEmpty()) {
1:f4a58c5:         indexToSegmentPropertiesWrapperMapping.remove(segmentPropertiesIndex);
1:f4a58c5:         segmentPropWrapperToSegmentSetMap.remove(segmentPropertiesWrapper);
1:a20f22e:       } else if (!clearSegmentWrapperFromMap
1:a20f22e:           && segmentIdAndSegmentPropertiesIndexWrapper.segmentIdSet.isEmpty()) {
1:a20f22e:         // min max columns can very when cache is modified. So even though entry is not required
1:a20f22e:         // to be deleted from map clear the column cache so that it can filled again
1:a20f22e:         segmentPropertiesWrapper.clear();
1:a20f22e:         LOGGER.info("cleared min max for segmentProperties at index: " + segmentPropertiesIndex);
1:a20f22e:       }
1:a20f22e:     }
1:a20f22e:   }
1:a20f22e: 
1:a20f22e:   /**
1:a20f22e:    * add segmentId at given segmentPropertyIndex
1:a20f22e:    * Note: This method is getting used in extension with other features. Please do not remove
1:a20f22e:    *
1:a20f22e:    * @param segmentPropertiesIndex
1:a20f22e:    * @param segmentId
1:a20f22e:    */
1:a20f22e:   public void addSegmentId(int segmentPropertiesIndex, String segmentId) {
1:a20f22e:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:a20f22e:         indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesIndex);
1:a20f22e:     if (null != segmentPropertiesWrapper) {
1:a20f22e:       SegmentIdAndSegmentPropertiesIndexWrapper segmentIdAndSegmentPropertiesIndexWrapper =
1:a20f22e:           segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:a20f22e:       synchronized (getOrCreateTableLock(segmentPropertiesWrapper.getTableIdentifier())) {
1:a20f22e:         segmentIdAndSegmentPropertiesIndexWrapper.addSegmentId(segmentId);
1:f4a58c5:       }
1:f4a58c5:     }
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * This class wraps tableIdentifier, columnsInTable and columnCardinality as a key to determine
1:f4a58c5:    * whether the SegmentProperties object can be reused.
1:f4a58c5:    */
1:f4a58c5:   public static class SegmentPropertiesWrapper {
1:f4a58c5: 
1:a20f22e:     private static final Object taskSchemaLock = new Object();
1:a20f22e:     private static final Object fileFooterSchemaLock = new Object();
1:a20f22e: 
1:f4a58c5:     private AbsoluteTableIdentifier tableIdentifier;
1:f4a58c5:     private List<ColumnSchema> columnsInTable;
1:f4a58c5:     private int[] columnCardinality;
1:f4a58c5:     private SegmentProperties segmentProperties;
1:dc29319:     private List<CarbonColumn> minMaxCacheColumns;
1:a20f22e:     private CarbonRowSchema[] taskSummarySchema;
1:a20f22e:     // same variable can be used for block and blocklet schema because at any given cache_level
1:a20f22e:     // with either block or blocklet and whenever cache_level is changed the cache and its
1:a20f22e:     // corresponding segmentProperties is flushed
1:a20f22e:     private CarbonRowSchema[] fileFooterEntrySchema;
1:f4a58c5: 
1:dc29319:     public SegmentPropertiesWrapper(CarbonTable carbonTable,
1:f4a58c5:         List<ColumnSchema> columnsInTable, int[] columnCardinality) {
1:dc29319:       this.tableIdentifier = carbonTable.getAbsoluteTableIdentifier();
1:f4a58c5:       this.columnsInTable = columnsInTable;
1:f4a58c5:       this.columnCardinality = columnCardinality;
1:f4a58c5:     }
1:f4a58c5: 
1:a20f22e:     public void initSegmentProperties() {
1:f4a58c5:       segmentProperties = new SegmentProperties(columnsInTable, columnCardinality);
1:a20f22e:     }
1:a20f22e: 
1:a20f22e:     public void addMinMaxColumns(CarbonTable carbonTable) {
1:a20f22e:       if (null == minMaxCacheColumns || minMaxCacheColumns.isEmpty()) {
1:a20f22e:         minMaxCacheColumns = carbonTable.getMinMaxCacheColumns(segmentProperties);
1:a20f22e:       }
1:a20f22e:     }
1:a20f22e: 
1:a20f22e:     /**
1:a20f22e:      * clear required fields
1:a20f22e:      */
1:a20f22e:     public void clear() {
1:a20f22e:       if (null != minMaxCacheColumns) {
1:a20f22e:         minMaxCacheColumns.clear();
1:a20f22e:       }
1:a20f22e:       taskSummarySchema = null;
1:a20f22e:       fileFooterEntrySchema = null;
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     @Override public boolean equals(Object obj) {
1:f4a58c5:       if (!(obj instanceof SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper)) {
1:f4a58c5:         return false;
1:f4a58c5:       }
1:f4a58c5:       SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper other =
1:f4a58c5:           (SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper) obj;
1:f4a58c5:       return tableIdentifier.equals(other.tableIdentifier) && columnsInTable
1:f4a58c5:           .equals(other.columnsInTable) && Arrays
1:f4a58c5:           .equals(columnCardinality, other.columnCardinality);
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     @Override public int hashCode() {
1:f4a58c5:       return tableIdentifier.hashCode() + columnsInTable.hashCode() + Arrays
1:f4a58c5:           .hashCode(columnCardinality);
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public AbsoluteTableIdentifier getTableIdentifier() {
1:f4a58c5:       return tableIdentifier;
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public SegmentProperties getSegmentProperties() {
1:f4a58c5:       return segmentProperties;
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public List<ColumnSchema> getColumnsInTable() {
1:f4a58c5:       return columnsInTable;
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public int[] getColumnCardinality() {
1:f4a58c5:       return columnCardinality;
1:f4a58c5:     }
1:f4a58c5: 
1:dc29319:     public CarbonRowSchema[] getTaskSummarySchema(boolean storeBlockletCount,
1:dc29319:         boolean filePathToBeStored) throws MemoryException {
1:a20f22e:       if (null == taskSummarySchema) {
1:a20f22e:         synchronized (taskSchemaLock) {
1:a20f22e:           if (null == taskSummarySchema) {
1:a20f22e:             taskSummarySchema = SchemaGenerator
1:a20f22e:                 .createTaskSummarySchema(segmentProperties, minMaxCacheColumns, storeBlockletCount,
1:a20f22e:                     filePathToBeStored);
1:a20f22e:           }
1:a20f22e:         }
1:a20f22e:       }
1:a20f22e:       return taskSummarySchema;
1:f4a58c5:     }
1:f4a58c5: 
1:dc29319:     public CarbonRowSchema[] getBlockFileFooterEntrySchema() {
1:a20f22e:       return getOrCreateFileFooterEntrySchema(true);
1:f4a58c5:     }
1:f4a58c5: 
1:dc29319:     public CarbonRowSchema[] getBlockletFileFooterEntrySchema() {
1:a20f22e:       return getOrCreateFileFooterEntrySchema(false);
1:f4a58c5:     }
1:f4a58c5: 
1:dc29319:     public List<CarbonColumn> getMinMaxCacheColumns() {
1:dc29319:       return minMaxCacheColumns;
1:f4a58c5:     }
1:a20f22e: 
1:a20f22e:     private CarbonRowSchema[] getOrCreateFileFooterEntrySchema(boolean isCacheLevelBlock) {
1:a20f22e:       if (null == fileFooterEntrySchema) {
1:a20f22e:         synchronized (fileFooterSchemaLock) {
1:a20f22e:           if (null == fileFooterEntrySchema) {
1:a20f22e:             if (isCacheLevelBlock) {
1:a20f22e:               fileFooterEntrySchema =
1:a20f22e:                   SchemaGenerator.createBlockSchema(segmentProperties, minMaxCacheColumns);
1:a20f22e:             } else {
1:a20f22e:               fileFooterEntrySchema =
1:a20f22e:                   SchemaGenerator.createBlockletSchema(segmentProperties, minMaxCacheColumns);
1:a20f22e:             }
1:a20f22e:           }
1:a20f22e:         }
1:a20f22e:       }
1:a20f22e:       return fileFooterEntrySchema;
1:a20f22e:     }
1:f4a58c5:   }
1:f4a58c5: 
1:f4a58c5:   /**
1:f4a58c5:    * holder for segmentId and segmentPropertiesIndex
1:f4a58c5:    */
1:f4a58c5:   public static class SegmentIdAndSegmentPropertiesIndexWrapper {
1:f4a58c5: 
1:f4a58c5:     /**
1:f4a58c5:      * set holding all unique segment Id's using the same segmentProperties
1:f4a58c5:      */
1:f4a58c5:     private Set<String> segmentIdSet;
1:f4a58c5:     /**
1:f4a58c5:      * index which maps to segmentPropertiesWrpper Index from where segmentProperties
1:f4a58c5:      * can be retrieved
1:f4a58c5:      */
1:f4a58c5:     private int segmentPropertiesIndex;
1:f4a58c5: 
1:f4a58c5:     public SegmentIdAndSegmentPropertiesIndexWrapper(String segmentId, int segmentPropertiesIndex) {
1:f4a58c5:       segmentIdSet = new HashSet<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:f4a58c5:       addSegmentId(segmentId);
1:f4a58c5:       this.segmentPropertiesIndex = segmentPropertiesIndex;
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public void addSegmentId(String segmentId) {
1:f4a58c5:       segmentIdSet.add(segmentId);
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public void removeSegmentId(String segmentId) {
1:f4a58c5:       segmentIdSet.remove(segmentId);
1:f4a58c5:     }
1:f4a58c5: 
1:f4a58c5:     public int getSegmentPropertiesIndex() {
1:f4a58c5:       return segmentPropertiesIndex;
1:f4a58c5:     }
1:f4a58c5:   }
1:f4a58c5: }
============================================================================
author:manishgupta88
-------------------------------------------------------------------------------
commit:a20f22e
/////////////////////////////////////////////////////////////////////////
1:           segmentPropertiesWrapper.initSegmentProperties();
1:           segmentPropertiesWrapper.addMinMaxColumns(carbonTable);
/////////////////////////////////////////////////////////////////////////
1:         indexToSegmentPropertiesWrapperMapping
1:             .get(segmentIdSetAndIndexWrapper.getSegmentPropertiesIndex())
1:             .addMinMaxColumns(carbonTable);
/////////////////////////////////////////////////////////////////////////
1:       synchronized (getOrCreateTableLock(segmentPropertiesWrapper.getTableIdentifier())) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (!clearSegmentWrapperFromMap
1:           && segmentIdAndSegmentPropertiesIndexWrapper.segmentIdSet.isEmpty()) {
1:         // min max columns can very when cache is modified. So even though entry is not required
1:         // to be deleted from map clear the column cache so that it can filled again
1:         segmentPropertiesWrapper.clear();
1:         LOGGER.info("cleared min max for segmentProperties at index: " + segmentPropertiesIndex);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * add segmentId at given segmentPropertyIndex
1:    * Note: This method is getting used in extension with other features. Please do not remove
1:    *
1:    * @param segmentPropertiesIndex
1:    * @param segmentId
1:    */
1:   public void addSegmentId(int segmentPropertiesIndex, String segmentId) {
1:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:         indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesIndex);
1:     if (null != segmentPropertiesWrapper) {
1:       SegmentIdAndSegmentPropertiesIndexWrapper segmentIdAndSegmentPropertiesIndexWrapper =
1:           segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:       synchronized (getOrCreateTableLock(segmentPropertiesWrapper.getTableIdentifier())) {
1:         segmentIdAndSegmentPropertiesIndexWrapper.addSegmentId(segmentId);
/////////////////////////////////////////////////////////////////////////
1:     private static final Object taskSchemaLock = new Object();
1:     private static final Object fileFooterSchemaLock = new Object();
1: 
1:     private CarbonRowSchema[] taskSummarySchema;
1:     // same variable can be used for block and blocklet schema because at any given cache_level
1:     // with either block or blocklet and whenever cache_level is changed the cache and its
1:     // corresponding segmentProperties is flushed
1:     private CarbonRowSchema[] fileFooterEntrySchema;
/////////////////////////////////////////////////////////////////////////
1:     public void initSegmentProperties() {
1:     }
1: 
1:     public void addMinMaxColumns(CarbonTable carbonTable) {
1:       if (null == minMaxCacheColumns || minMaxCacheColumns.isEmpty()) {
1:         minMaxCacheColumns = carbonTable.getMinMaxCacheColumns(segmentProperties);
1:       }
1:     }
1: 
1:     /**
1:      * clear required fields
1:      */
1:     public void clear() {
1:       if (null != minMaxCacheColumns) {
1:         minMaxCacheColumns.clear();
1:       }
1:       taskSummarySchema = null;
1:       fileFooterEntrySchema = null;
/////////////////////////////////////////////////////////////////////////
1:       if (null == taskSummarySchema) {
1:         synchronized (taskSchemaLock) {
1:           if (null == taskSummarySchema) {
1:             taskSummarySchema = SchemaGenerator
1:                 .createTaskSummarySchema(segmentProperties, minMaxCacheColumns, storeBlockletCount,
1:                     filePathToBeStored);
1:           }
1:         }
1:       }
1:       return taskSummarySchema;
1:       return getOrCreateFileFooterEntrySchema(true);
1:       return getOrCreateFileFooterEntrySchema(false);
1: 
1:     private CarbonRowSchema[] getOrCreateFileFooterEntrySchema(boolean isCacheLevelBlock) {
1:       if (null == fileFooterEntrySchema) {
1:         synchronized (fileFooterSchemaLock) {
1:           if (null == fileFooterEntrySchema) {
1:             if (isCacheLevelBlock) {
1:               fileFooterEntrySchema =
1:                   SchemaGenerator.createBlockSchema(segmentProperties, minMaxCacheColumns);
1:             } else {
1:               fileFooterEntrySchema =
1:                   SchemaGenerator.createBlockletSchema(segmentProperties, minMaxCacheColumns);
1:             }
1:           }
1:         }
1:       }
1:       return fileFooterEntrySchema;
1:     }
commit:dc29319
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.MemoryException;
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
/////////////////////////////////////////////////////////////////////////
1:    * @param carbonTable
1:   public int addSegmentProperties(CarbonTable carbonTable,
1:         new SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper(carbonTable,
1:       synchronized (getOrCreateTableLock(carbonTable.getAbsoluteTableIdentifier())) {
/////////////////////////////////////////////////////////////////////////
1:           LOGGER.info("Constructing new SegmentProperties for table: " + carbonTable
/////////////////////////////////////////////////////////////////////////
1:       synchronized (getOrCreateTableLock(carbonTable.getAbsoluteTableIdentifier())) {
/////////////////////////////////////////////////////////////////////////
1:     private List<CarbonColumn> minMaxCacheColumns;
1:     public SegmentPropertiesWrapper(CarbonTable carbonTable,
1:       this.tableIdentifier = carbonTable.getAbsoluteTableIdentifier();
0:       this.minMaxCacheColumns = carbonTable.getMinMaxCacheColumns();
/////////////////////////////////////////////////////////////////////////
1:     public CarbonRowSchema[] getTaskSummarySchema(boolean storeBlockletCount,
1:         boolean filePathToBeStored) throws MemoryException {
0:       return SchemaGenerator
0:           .createTaskSummarySchema(segmentProperties, minMaxCacheColumns, storeBlockletCount,
0:               filePathToBeStored);
1:     public CarbonRowSchema[] getBlockFileFooterEntrySchema() {
0:       return SchemaGenerator.createBlockSchema(segmentProperties, minMaxCacheColumns);
1:     public CarbonRowSchema[] getBlockletFileFooterEntrySchema() {
0:       return SchemaGenerator.createBlockletSchema(segmentProperties, minMaxCacheColumns);
1:     public List<CarbonColumn> getMinMaxCacheColumns() {
1:       return minMaxCacheColumns;
commit:f4a58c5
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.datastore.block;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.indexstore.schema.CarbonRowSchema;
1: import org.apache.carbondata.core.indexstore.schema.SchemaGenerator;
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1: 
1: /**
1:  * Singleton class which will help in creating the segment properties
1:  */
1: public class SegmentPropertiesAndSchemaHolder {
1: 
1:   /**
1:    * Logger
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(SegmentPropertiesAndSchemaHolder.class.getName());
1:   /**
1:    * SegmentPropertiesAndSchemaHolder instance
1:    */
1:   private static final SegmentPropertiesAndSchemaHolder INSTANCE =
1:       new SegmentPropertiesAndSchemaHolder();
1:   /**
1:    * object level lock
1:    */
1:   private static final Object lock = new Object();
1:   /**
1:    * counter for maintaining the index of segmentProperties
1:    */
1:   private static final AtomicInteger segmentPropertiesIndexCounter = new AtomicInteger(0);
1:   /**
1:    * holds segmentPropertiesWrapper to segment ID and segmentProperties Index wrapper mapping.
1:    * Will be used while invaliding a segment and drop table
1:    */
1:   private Map<SegmentPropertiesWrapper, SegmentIdAndSegmentPropertiesIndexWrapper>
1:       segmentPropWrapperToSegmentSetMap = new ConcurrentHashMap<>();
1:   /**
1:    * reverse mapping for segmentProperties index to segmentPropertiesWrapper
1:    */
1:   private static Map<Integer, SegmentPropertiesWrapper> indexToSegmentPropertiesWrapperMapping =
1:       new ConcurrentHashMap<>();
1:   /**
1:    * Map to be used for table level locking while populating segmentProperties
1:    */
1:   private Map<String, Object> absoluteTableIdentifierByteMap = new ConcurrentHashMap<>();
1: 
1:   /**
1:    * private constructor for singleton instance
1:    */
1:   private SegmentPropertiesAndSchemaHolder() {
1: 
1:   }
1: 
1:   public static SegmentPropertiesAndSchemaHolder getInstance() {
1:     return INSTANCE;
1:   }
1: 
1:   /**
1:    * Method to add the segment properties and avoid construction of new segment properties until
1:    * the schema is not modified
1:    *
0:    * @param tableIdentifier
1:    * @param columnsInTable
1:    * @param columnCardinality
1:    * @param segmentId
1:    */
0:   public int addSegmentProperties(AbsoluteTableIdentifier tableIdentifier,
1:       List<ColumnSchema> columnsInTable, int[] columnCardinality, String segmentId) {
1:     SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper segmentPropertiesWrapper =
0:         new SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper(tableIdentifier,
1:             columnsInTable, columnCardinality);
1:     SegmentIdAndSegmentPropertiesIndexWrapper segmentIdSetAndIndexWrapper =
1:         this.segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:     if (null == segmentIdSetAndIndexWrapper) {
0:       synchronized (getOrCreateTableLock(tableIdentifier)) {
1:         segmentIdSetAndIndexWrapper =
1:             this.segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
1:         if (null == segmentIdSetAndIndexWrapper) {
1:           // create new segmentProperties
0:           segmentPropertiesWrapper.initSegmentProperties();
1:           int segmentPropertiesIndex = segmentPropertiesIndexCounter.incrementAndGet();
1:           indexToSegmentPropertiesWrapperMapping
1:               .put(segmentPropertiesIndex, segmentPropertiesWrapper);
0:           LOGGER.info("Constructing new SegmentProperties for table: " + tableIdentifier
1:               .getCarbonTableIdentifier().getTableUniqueName()
1:               + ". Current size of segment properties" + " holder list is: "
1:               + indexToSegmentPropertiesWrapperMapping.size());
1:           // populate the SegmentIdAndSegmentPropertiesIndexWrapper to maintain the set of segments
1:           // having same SegmentPropertiesWrapper instance this will used to decide during the
1:           // tblSegmentsProperties map clean-up for the invalid segments
1:           segmentIdSetAndIndexWrapper =
1:               new SegmentIdAndSegmentPropertiesIndexWrapper(segmentId, segmentPropertiesIndex);
1:           segmentPropWrapperToSegmentSetMap
1:               .put(segmentPropertiesWrapper, segmentIdSetAndIndexWrapper);
1:         }
1:       }
1:     } else {
0:       synchronized (getOrCreateTableLock(tableIdentifier)) {
1:         segmentIdSetAndIndexWrapper.addSegmentId(segmentId);
1:       }
1:     }
1:     return segmentIdSetAndIndexWrapper.getSegmentPropertiesIndex();
1:   }
1: 
1:   /**
1:    * Method to create table Level lock
1:    *
1:    * @param absoluteTableIdentifier
1:    * @return
1:    */
1:   private Object getOrCreateTableLock(AbsoluteTableIdentifier absoluteTableIdentifier) {
1:     Object tableLock = absoluteTableIdentifierByteMap
1:         .get(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:     if (null == tableLock) {
1:       synchronized (lock) {
1:         tableLock = absoluteTableIdentifierByteMap
1:             .get(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:         if (null == tableLock) {
1:           tableLock = new Object();
1:           absoluteTableIdentifierByteMap
1:               .put(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName(),
1:                   tableLock);
1:         }
1:       }
1:     }
1:     return tableLock;
1:   }
1: 
1:   /**
1:    * Method to get the segment properties from given index
1:    *
1:    * @param segmentPropertiesIndex
1:    * @return
1:    */
1:   public SegmentProperties getSegmentProperties(int segmentPropertiesIndex) {
1:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:         getSegmentPropertiesWrapper(segmentPropertiesIndex);
1:     if (null != segmentPropertiesWrapper) {
1:       return segmentPropertiesWrapper.getSegmentProperties();
1:     }
1:     return null;
1:   }
1: 
1:   /**
1:    * Method to get the segment properties from given index
1:    *
1:    * @param segmentPropertiesWrapperIndex
1:    * @return
1:    */
1:   public SegmentPropertiesWrapper getSegmentPropertiesWrapper(int segmentPropertiesWrapperIndex) {
1:     return indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesWrapperIndex);
1:   }
1: 
1:   /**
1:    * This method will remove the segment properties from the map on drop table
1:    *
1:    * @param absoluteTableIdentifier
1:    */
1:   public void invalidate(AbsoluteTableIdentifier absoluteTableIdentifier) {
1:     List<SegmentPropertiesWrapper> segmentPropertiesWrappersToBeRemoved = new ArrayList<>();
1:     // remove segmentProperties wrapper entries from the copyOnWriteArrayList
1:     for (Map.Entry<SegmentPropertiesWrapper, SegmentIdAndSegmentPropertiesIndexWrapper> entry :
1:           segmentPropWrapperToSegmentSetMap.entrySet()) {
1:       SegmentPropertiesWrapper segmentPropertiesWrapper = entry.getKey();
1:       if (segmentPropertiesWrapper.getTableIdentifier().getCarbonTableIdentifier()
1:           .getTableUniqueName()
1:           .equals(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName())) {
1:         SegmentIdAndSegmentPropertiesIndexWrapper value = entry.getValue();
1:         // remove from the reverse mapping map
1:         indexToSegmentPropertiesWrapperMapping.remove(value.getSegmentPropertiesIndex());
1:         segmentPropertiesWrappersToBeRemoved.add(segmentPropertiesWrapper);
1:       }
1:     }
1:     // remove all the segmentPropertiesWrapper entries from map
1:     for (SegmentPropertiesWrapper segmentPropertiesWrapper : segmentPropertiesWrappersToBeRemoved) {
1:       segmentPropWrapperToSegmentSetMap.remove(segmentPropertiesWrapper);
1:     }
1:     // remove the table lock
1:     absoluteTableIdentifierByteMap
1:         .remove(absoluteTableIdentifier.getCarbonTableIdentifier().getTableUniqueName());
1:   }
1: 
1:   /**
1:    * Method to remove the given segment ID
1:    *
1:    * @param segmentId
1:    * @param segmentPropertiesIndex
1:    */
0:   public void invalidate(String segmentId, int segmentPropertiesIndex) {
1:     SegmentPropertiesWrapper segmentPropertiesWrapper =
1:         indexToSegmentPropertiesWrapperMapping.get(segmentPropertiesIndex);
1:     if (null != segmentPropertiesWrapper) {
1:       SegmentIdAndSegmentPropertiesIndexWrapper segmentIdAndSegmentPropertiesIndexWrapper =
1:           segmentPropWrapperToSegmentSetMap.get(segmentPropertiesWrapper);
0:       synchronized (segmentPropertiesWrapper.getTableIdentifier().getCarbonTableIdentifier()
0:           .getTableUniqueName()) {
1:         segmentIdAndSegmentPropertiesIndexWrapper.removeSegmentId(segmentId);
1:       }
1:       // if after removal of given SegmentId, the segmentIdSet becomes empty that means this
1:       // segmentPropertiesWrapper is not getting used at all. In that case this object can be
1:       // removed from all the holders
0:       if (segmentIdAndSegmentPropertiesIndexWrapper.segmentIdSet.isEmpty()) {
1:         indexToSegmentPropertiesWrapperMapping.remove(segmentPropertiesIndex);
1:         segmentPropWrapperToSegmentSetMap.remove(segmentPropertiesWrapper);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * This class wraps tableIdentifier, columnsInTable and columnCardinality as a key to determine
1:    * whether the SegmentProperties object can be reused.
1:    */
1:   public static class SegmentPropertiesWrapper {
1: 
1:     private AbsoluteTableIdentifier tableIdentifier;
1:     private List<ColumnSchema> columnsInTable;
1:     private int[] columnCardinality;
1:     private SegmentProperties segmentProperties;
0:     private CarbonRowSchema[] taskSummarySchema;
1: 
0:     public SegmentPropertiesWrapper(AbsoluteTableIdentifier tableIdentifier,
1:         List<ColumnSchema> columnsInTable, int[] columnCardinality) {
0:       this.tableIdentifier = tableIdentifier;
1:       this.columnsInTable = columnsInTable;
1:       this.columnCardinality = columnCardinality;
1:     }
1: 
0:     public void initSegmentProperties() {
1:       segmentProperties = new SegmentProperties(columnsInTable, columnCardinality);
1:     }
1: 
1:     @Override public boolean equals(Object obj) {
1:       if (!(obj instanceof SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper)) {
1:         return false;
1:       }
1:       SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper other =
1:           (SegmentPropertiesAndSchemaHolder.SegmentPropertiesWrapper) obj;
1:       return tableIdentifier.equals(other.tableIdentifier) && columnsInTable
1:           .equals(other.columnsInTable) && Arrays
1:           .equals(columnCardinality, other.columnCardinality);
1:     }
1: 
1:     @Override public int hashCode() {
1:       return tableIdentifier.hashCode() + columnsInTable.hashCode() + Arrays
1:           .hashCode(columnCardinality);
1:     }
1: 
1:     public AbsoluteTableIdentifier getTableIdentifier() {
1:       return tableIdentifier;
1:     }
1: 
1:     public SegmentProperties getSegmentProperties() {
1:       return segmentProperties;
1:     }
1: 
1:     public List<ColumnSchema> getColumnsInTable() {
1:       return columnsInTable;
1:     }
1: 
1:     public int[] getColumnCardinality() {
1:       return columnCardinality;
1:     }
1: 
0:     public CarbonRowSchema[] getBlockSchema() {
0:       return SchemaGenerator.createBlockSchema(segmentProperties);
1:     }
1: 
0:     public CarbonRowSchema[] getBlocketSchema() {
0:       return SchemaGenerator.createBlockletSchema(segmentProperties);
1:     }
1: 
0:     public CarbonRowSchema[] getTaskSummarySchema() {
0:       return taskSummarySchema;
1:     }
1: 
0:     public void setTaskSummarySchema(CarbonRowSchema[] taskSummarySchema) {
0:       this.taskSummarySchema = taskSummarySchema;
1:     }
1:   }
1: 
1:   /**
1:    * holder for segmentId and segmentPropertiesIndex
1:    */
1:   public static class SegmentIdAndSegmentPropertiesIndexWrapper {
1: 
1:     /**
1:      * set holding all unique segment Id's using the same segmentProperties
1:      */
1:     private Set<String> segmentIdSet;
1:     /**
1:      * index which maps to segmentPropertiesWrpper Index from where segmentProperties
1:      * can be retrieved
1:      */
1:     private int segmentPropertiesIndex;
1: 
1:     public SegmentIdAndSegmentPropertiesIndexWrapper(String segmentId, int segmentPropertiesIndex) {
1:       segmentIdSet = new HashSet<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:       addSegmentId(segmentId);
1:       this.segmentPropertiesIndex = segmentPropertiesIndex;
1:     }
1: 
1:     public void addSegmentId(String segmentId) {
1:       segmentIdSet.add(segmentId);
1:     }
1: 
1:     public void removeSegmentId(String segmentId) {
1:       segmentIdSet.remove(segmentId);
1:     }
1: 
1:     public int getSegmentPropertiesIndex() {
1:       return segmentPropertiesIndex;
1:     }
1:   }
1: }
author:m00258959
-------------------------------------------------------------------------------
commit:8e78957
/////////////////////////////////////////////////////////////////////////
0:           segmentPropertiesWrapper.initSegmentProperties(carbonTable);
/////////////////////////////////////////////////////////////////////////
1:    * @param clearSegmentWrapperFromMap flag to specify whether to clear segmentPropertiesWrapper
1:    *                                   from Map if all the segment's using it have become stale
1:   public void invalidate(String segmentId, int segmentPropertiesIndex,
1:       boolean clearSegmentWrapperFromMap) {
/////////////////////////////////////////////////////////////////////////
1:       if (clearSegmentWrapperFromMap && segmentIdAndSegmentPropertiesIndexWrapper.segmentIdSet
1:           .isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:     public void initSegmentProperties(CarbonTable carbonTable) {
0:       this.minMaxCacheColumns = carbonTable.getMinMaxCacheColumns(segmentProperties);
============================================================================