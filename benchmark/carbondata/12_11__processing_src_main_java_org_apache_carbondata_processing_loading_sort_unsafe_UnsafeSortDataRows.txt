1:f1f9348: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
2:f1f9348:  *
1:f1f9348:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f1f9348:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:f1f9348:  */
15:f1f9348: 
1:349c59c: package org.apache.carbondata.processing.loading.sort.unsafe;
1:8d8b589: 
1:f1f9348: import java.io.DataOutputStream;
1:f1f9348: import java.io.File;
1:f1f9348: import java.io.IOException;
1:2b41f14: import java.nio.ByteBuffer;
1:ded8b41: import java.util.Random;
1:f1f9348: import java.util.concurrent.ExecutorService;
1:f1f9348: import java.util.concurrent.Executors;
1:013db60: import java.util.concurrent.Semaphore;
1:f1f9348: import java.util.concurrent.TimeUnit;
1:f1f9348: 
1:f1f9348: import org.apache.carbondata.common.logging.LogService;
1:f1f9348: import org.apache.carbondata.common.logging.LogServiceFactory;
1:f1f9348: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:c100251: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:df22368: import org.apache.carbondata.core.memory.CarbonUnsafe;
1:edda248: import org.apache.carbondata.core.memory.IntPointerBuffer;
1:f1f9348: import org.apache.carbondata.core.memory.MemoryBlock;
1:edda248: import org.apache.carbondata.core.memory.MemoryException;
1:edda248: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
1:df22368: import org.apache.carbondata.core.memory.UnsafeSortMemoryManager;
1:f1f9348: import org.apache.carbondata.core.util.CarbonProperties;
1:a734add: import org.apache.carbondata.core.util.CarbonThreadFactory;
1:f1f9348: import org.apache.carbondata.core.util.CarbonUtil;
1:df22368: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
1:349c59c: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparator;
1:2b41f14: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparatorForNormalDims;
1:349c59c: import org.apache.carbondata.processing.loading.sort.unsafe.holder.UnsafeCarbonRow;
1:349c59c: import org.apache.carbondata.processing.loading.sort.unsafe.merger.UnsafeIntermediateMerger;
1:349c59c: import org.apache.carbondata.processing.loading.sort.unsafe.sort.TimSort;
1:349c59c: import org.apache.carbondata.processing.loading.sort.unsafe.sort.UnsafeIntSortDataFormat;
1:349c59c: import org.apache.carbondata.processing.sort.exception.CarbonSortKeyAndGroupByException;
1:349c59c: import org.apache.carbondata.processing.sort.sortdata.SortParameters;
1:2b41f14: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
1:f1f9348: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1:f1f9348: 
1:f1f9348: public class UnsafeSortDataRows {
1:f1f9348:   /**
1:f1f9348:    * LOGGER
1:f1f9348:    */
1:f1f9348:   private static final LogService LOGGER =
1:f1f9348:       LogServiceFactory.getLogService(UnsafeSortDataRows.class.getName());
1:f1f9348:   /**
1:f1f9348:    * threadStatusObserver
1:f1f9348:    */
1:f1f9348:   private ThreadStatusObserver threadStatusObserver;
1:f1f9348:   /**
1:f1f9348:    * executor service for data sort holder
1:f1f9348:    */
1:f1f9348:   private ExecutorService dataSorterAndWriterExecutorService;
1:f1f9348:   /**
1:f1f9348:    * semaphore which will used for managing sorted data object arrays
1:f1f9348:    */
1:f1f9348: 
1:f1f9348:   private SortParameters parameters;
1:2b41f14:   private TableFieldStat tableFieldStat;
1:2b41f14:   private ThreadLocal<ByteBuffer> rowBuffer;
1:f1f9348:   private UnsafeIntermediateMerger unsafeInMemoryIntermediateFileMerger;
1:f1f9348: 
1:f1f9348:   private UnsafeCarbonRowPage rowPage;
1:f1f9348: 
1:f1f9348:   private final Object addRowsLock = new Object();
1:f1f9348: 
1:013db60:   private long inMemoryChunkSize;
1:f1f9348: 
1:f1f9348:   private boolean enableInMemoryIntermediateMerge;
1:f1f9348: 
1:b13ead9:   private int bytesAdded;
1:b13ead9: 
1:b13ead9:   private long maxSizeAllowed;
1:b13ead9: 
1:013db60:   /**
1:013db60:    * semaphore which will used for managing sorted data object arrays
1:013db60:    */
1:013db60:   private Semaphore semaphore;
1:013db60: 
1:df22368:   private final long taskId;
1:df22368: 
1:f1f9348:   public UnsafeSortDataRows(SortParameters parameters,
1:f82b10b:       UnsafeIntermediateMerger unsafeInMemoryIntermediateFileMerger, int inMemoryChunkSize) {
1:f1f9348:     this.parameters = parameters;
1:2b41f14:     this.tableFieldStat = new TableFieldStat(parameters);
1:2b41f14:     this.rowBuffer = new ThreadLocal<ByteBuffer>() {
1:2b41f14:       @Override protected ByteBuffer initialValue() {
1:2b41f14:         byte[] backedArray = new byte[2 * 1024 * 1024];
1:2b41f14:         return ByteBuffer.wrap(backedArray);
1:2b41f14:       }
1:2b41f14:     };
1:f1f9348:     this.unsafeInMemoryIntermediateFileMerger = unsafeInMemoryIntermediateFileMerger;
1:8d8b589: 
1:f1f9348:     // observer of writing file in thread
1:f1f9348:     this.threadStatusObserver = new ThreadStatusObserver();
1:df22368:     this.taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
1:06b0d08:     this.inMemoryChunkSize = inMemoryChunkSize * 1024L * 1024L;
1:f1f9348:     enableInMemoryIntermediateMerge = Boolean.parseBoolean(CarbonProperties.getInstance()
1:f1f9348:         .getProperty(CarbonCommonConstants.ENABLE_INMEMORY_MERGE_SORT,
1:f1f9348:             CarbonCommonConstants.ENABLE_INMEMORY_MERGE_SORT_DEFAULT));
1:b13ead9: 
1:3807b2f:     this.maxSizeAllowed = parameters.getBatchSortSizeinMb();
1:b13ead9:     if (maxSizeAllowed <= 0) {
1:3807b2f:       // If user does not input any memory size, then take half the size of usable memory configured
1:3807b2f:       // in sort memory size.
1:b13ead9:       this.maxSizeAllowed = UnsafeMemoryManager.INSTANCE.getUsableMemory() / 2;
1:b13ead9:     } else {
1:7ef9164:       this.maxSizeAllowed = this.maxSizeAllowed * 1024L * 1024L;
1:21704cf:     }
1:b13ead9:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * This method will be used to initialize
1:f1f9348:    */
1:b439b00:   public void initialize() throws MemoryException, CarbonSortKeyAndGroupByException {
1:a161841:     this.rowPage = createUnsafeRowPage();
1:f1f9348:     // Delete if any older file exists in sort temp folder
1:f1f9348:     deleteSortLocationIfExists();
1:f1f9348: 
1:f1f9348:     // create new sort temp directory
1:ded8b41:     CarbonDataProcessorUtil.createLocations(parameters.getTempFileLocation());
1:a734add:     this.dataSorterAndWriterExecutorService = Executors
1:a734add:         .newFixedThreadPool(parameters.getNumberOfCores(),
1:a734add:             new CarbonThreadFactory("UnsafeSortDataRowPool:" + parameters.getTableName()));
1:013db60:     semaphore = new Semaphore(parameters.getNumberOfCores());
22:f1f9348:   }
1:f1f9348: 
1:b439b00:   private UnsafeCarbonRowPage createUnsafeRowPage()
1:b439b00:       throws MemoryException, CarbonSortKeyAndGroupByException {
1:a161841:     MemoryBlock baseBlock =
1:a161841:         UnsafeMemoryManager.allocateMemoryWithRetry(this.taskId, inMemoryChunkSize);
1:a161841:     boolean isMemoryAvailable =
1:a161841:         UnsafeSortMemoryManager.INSTANCE.isMemoryAvailable(baseBlock.size());
1:a161841:     if (isMemoryAvailable) {
1:a161841:       UnsafeSortMemoryManager.INSTANCE.allocateDummyMemory(baseBlock.size());
1:b439b00:     } else {
1:b439b00:       // merge and spill in-memory pages to disk if memory is not enough
1:b439b00:       unsafeInMemoryIntermediateFileMerger.tryTriggerInmemoryMerging(true);
1:a161841:     }
1:a161841:     return new UnsafeCarbonRowPage(tableFieldStat, baseBlock, !isMemoryAvailable, taskId);
1:a161841:   }
1:a161841: 
1:b13ead9:   public boolean canAdd() {
1:b13ead9:     return bytesAdded < maxSizeAllowed;
1:df22368:   }
1:b13ead9: 
1:f1f9348:   /**
1:f82b10b:    * This method will be used to add new row
1:f1f9348:    *
1:f1f9348:    * @param rowBatch new rowBatch
1:f1f9348:    * @throws CarbonSortKeyAndGroupByException problem while writing
1:f82b10b:    */
1:f1f9348:   public void addRowBatch(Object[][] rowBatch, int size) throws CarbonSortKeyAndGroupByException {
1:f1f9348:     // if record holder list size is equal to sort buffer size then it will
1:f1f9348:     // sort the list and then write current list data to file
1:f1f9348:     synchronized (addRowsLock) {
1:408de86:       addBatch(rowBatch, size);
1:408de86:     }
1:408de86:   }
1:f1f9348: 
1:408de86:   /**
1:408de86:    * This method will be used to add new row
1:408de86:    *
1:408de86:    * @param rowBatch new rowBatch
1:408de86:    * @param size
1:408de86:    * @throws CarbonSortKeyAndGroupByException problem while writing
1:408de86:    */
1:408de86:   public void addRowBatchWithOutSync(Object[][] rowBatch, int size)
1:408de86:       throws CarbonSortKeyAndGroupByException {
1:408de86:     // if record holder list size is equal to sort buffer size then it will
1:408de86:     // sort the list and then write current list data to file
1:408de86:     addBatch(rowBatch, size);
1:408de86:   }
1:408de86: 
1:408de86:   private void addBatch(Object[][] rowBatch, int size) throws CarbonSortKeyAndGroupByException {
1:2576727:     if (rowPage == null) {
1:2576727:       return;
1:2576727:     }
1:408de86:     for (int i = 0; i < size; i++) {
1:408de86:       if (rowPage.canAdd()) {
1:2b41f14:         bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
1:408de86:       } else {
1:408de86:         try {
1:b439b00:           handlePreviousPage();
1:2576727:           try {
1:2576727:             rowPage = createUnsafeRowPage();
1:2576727:           } catch (Exception ex) {
1:2576727:             // row page has freed in handlePreviousPage(), so other iterator may try to access it.
1:2576727:             rowPage = null;
1:2576727:             LOGGER.error(
1:2576727:                 "exception occurred while trying to acquire a semaphore lock: " + ex.getMessage());
1:2576727:             throw new CarbonSortKeyAndGroupByException(ex);
1:2576727:           }
1:2b41f14:           bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
1:408de86:         } catch (Exception e) {
1:2576727:           LOGGER.error(
1:408de86:                   "exception occurred while trying to acquire a semaphore lock: " + e.getMessage());
1:408de86:           throw new CarbonSortKeyAndGroupByException(e);
1:2576727:         }
1:f1f9348: 
1:408de86:       }
1:b13ead9:     }
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:f1f9348:    * This method will be used to add new row
1:f1f9348:    */
1:f82b10b:   public void addRow(Object[] row) throws CarbonSortKeyAndGroupByException {
1:2576727:     if (rowPage == null) {
1:2576727:       return;
1:2576727:     }
1:f82b10b:     // if record holder list size is equal to sort buffer size then it will
1:f82b10b:     // sort the list and then write current list data to file
1:f82b10b:     if (rowPage.canAdd()) {
1:2b41f14:       rowPage.addRow(row, rowBuffer.get());
1:f82b10b:     } else {
1:2576727:       try {
1:b439b00:         handlePreviousPage();
1:f82b10b:         try {
1:2576727:           rowPage = createUnsafeRowPage();
1:2576727:         } catch (Exception ex) {
1:2576727:           rowPage = null;
1:408de86:           LOGGER.error(
1:2576727:               "exception occurred while trying to acquire a semaphore lock: " + ex.getMessage());
1:2576727:           throw new CarbonSortKeyAndGroupByException(ex);
1:f82b10b:         }
1:2b41f14:         rowPage.addRow(row, rowBuffer.get());
1:f82b10b:       } catch (Exception e) {
1:f82b10b:         LOGGER.error(
1:f82b10b:             "exception occurred while trying to acquire a semaphore lock: " + e.getMessage());
1:f82b10b:         throw new CarbonSortKeyAndGroupByException(e);
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348:   }
1:f1f9348: 
1:f1f9348:   /**
1:b439b00:    * Below method will be used to start sorting process. This method will get
1:b439b00:    * all the temp unsafe pages in memory and all the temp files and try to merge them if possible.
1:b439b00:    * Also, it will spill the pages to disk or add it to unsafe sort memory.
1:f1f9348:    *
1:b439b00:    * @throws CarbonSortKeyAndGroupByException if error occurs during in-memory merge
1:b439b00:    * @throws InterruptedException if error occurs during data sort and write
1:f1f9348:    */
1:b439b00:   public void startSorting() throws CarbonSortKeyAndGroupByException, InterruptedException {
1:f1f9348:     LOGGER.info("Unsafe based sorting will be used");
1:f1f9348:     if (this.rowPage.getUsedSize() > 0) {
1:b439b00:       handlePreviousPage();
5:f1f9348:     } else {
1:f1f9348:       rowPage.freeMemory();
1:f1f9348:     }
1:f1f9348:     startFileBasedMerge();
1:f1f9348:   }
1:f1f9348: 
1:c100251:   /**
1:b439b00:    * Deal with the previous pages added to sort-memory. Carbondata will merge the in-memory pages
1:b439b00:    * or merge the sort temp files if possible. After that, carbondata will add current page to
1:b439b00:    * sort memory or just spill them.
1:b439b00:    */
1:b439b00:   private void handlePreviousPage()
1:b439b00:       throws CarbonSortKeyAndGroupByException, InterruptedException {
1:b439b00:     if (enableInMemoryIntermediateMerge) {
1:b439b00:       unsafeInMemoryIntermediateFileMerger.startInmemoryMergingIfPossible();
1:b439b00:     }
1:b439b00:     unsafeInMemoryIntermediateFileMerger.startFileMergingIfPossible();
1:b439b00:     semaphore.acquire();
1:b439b00:     dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(rowPage));
1:b439b00:   }
1:b439b00: 
1:b439b00:   /**
1:c100251:    * write a page to sort temp file
1:c100251:    * @param rowPage page
1:c100251:    * @param file file
1:c100251:    * @throws CarbonSortKeyAndGroupByException
1:c100251:    */
1:c100251:   private void writeDataToFile(UnsafeCarbonRowPage rowPage, File file)
2:f1f9348:       throws CarbonSortKeyAndGroupByException {
1:f1f9348:     DataOutputStream stream = null;
5:f1f9348:     try {
1:f1f9348:       // open stream
1:c100251:       stream = FileFactory.getDataOutputStream(file.getPath(), FileFactory.FileType.LOCAL,
1:c100251:           parameters.getFileWriteBufferSize(), parameters.getSortTempCompressorName());
1:f1f9348:       int actualSize = rowPage.getBuffer().getActualSize();
1:f1f9348:       // write number of entries to the file
1:f1f9348:       stream.writeInt(actualSize);
1:f1f9348:       for (int i = 0; i < actualSize; i++) {
1:2b41f14:         rowPage.writeRow(
1:2b41f14:             rowPage.getBuffer().get(i) + rowPage.getDataBlock().getBaseOffset(), stream);
1:df22368:       }
1:f1f9348:     } catch (IOException e) {
1:f1f9348:       throw new CarbonSortKeyAndGroupByException("Problem while writing the file", e);
2:f1f9348:     } finally {
1:f1f9348:       // close streams
1:f1f9348:       CarbonUtil.closeStreams(stream);
1:df22368:     }
1:f82b10b:   }
1:8d8b589: 
1:f82b10b:   /**
1:f1f9348:    * This method will be used to delete sort temp location is it is exites
1:f1f9348:    */
1:eaadc88:   public void deleteSortLocationIfExists() {
1:f1f9348:     CarbonDataProcessorUtil.deleteSortLocationIfExists(parameters.getTempFileLocation());
1:f82b10b:   }
1:408de86: 
1:f1f9348:   /**
1:f1f9348:    * Below method will be used to start file based merge
1:f1f9348:    *
1:eaadc88:    * @throws InterruptedException
1:f1f9348:    */
1:eaadc88:   private void startFileBasedMerge() throws InterruptedException {
1:eaadc88:     dataSorterAndWriterExecutorService.shutdown();
1:eaadc88:     dataSorterAndWriterExecutorService.awaitTermination(2, TimeUnit.DAYS);
1:f82b10b:   }
1:f82b10b: 
1:f1f9348:   /**
1:f1f9348:    * Observer class for thread execution
1:f1f9348:    * In case of any failure we need stop all the running thread
1:f1f9348:    */
1:f1f9348:   private class ThreadStatusObserver {
1:f1f9348:     /**
1:f1f9348:      * Below method will be called if any thread fails during execution
1:f1f9348:      *
1:f1f9348:      * @param exception
4:f1f9348:      * @throws CarbonSortKeyAndGroupByException
1:f1f9348:      */
1:f1f9348:     public void notifyFailed(Throwable exception) throws CarbonSortKeyAndGroupByException {
1:3f33276:       semaphore.release();
1:f1f9348:       dataSorterAndWriterExecutorService.shutdownNow();
1:f1f9348:       unsafeInMemoryIntermediateFileMerger.close();
1:f1f9348:       parameters.getObserver().setFailed(true);
1:f1f9348:       LOGGER.error(exception);
1:f1f9348:       throw new CarbonSortKeyAndGroupByException(exception);
1:f1f9348:     }
1:f1f9348:   }
1:f82b10b: 
1:f1f9348:   /**
1:f1f9348:    * This class is responsible for sorting and writing the object
1:f1f9348:    * array which holds the records equal to given array size
1:f1f9348:    */
1:06b0d08:   private class DataSorterAndWriter implements Runnable {
1:f1f9348:     private UnsafeCarbonRowPage page;
1:f1f9348: 
1:f1f9348:     public DataSorterAndWriter(UnsafeCarbonRowPage rowPage) {
1:f1f9348:       this.page = rowPage;
1:f1f9348:     }
1:f1f9348: 
1:06b0d08:     @Override
1:06b0d08:     public void run() {
1:f1f9348:       try {
1:f1f9348:         long startTime = System.currentTimeMillis();
2:f1f9348:         TimSort<UnsafeCarbonRow, IntPointerBuffer> timSort = new TimSort<>(
1:f1f9348:             new UnsafeIntSortDataFormat(page));
1:9f94529:         // if sort_columns is not none, sort by sort_columns
1:9f94529:         if (parameters.getNumberOfNoDictSortColumns() > 0) {
1:f1f9348:           timSort.sort(page.getBuffer(), 0, page.getBuffer().getActualSize(),
1:f1f9348:               new UnsafeRowComparator(page));
1:f1f9348:         } else {
1:f1f9348:           timSort.sort(page.getBuffer(), 0, page.getBuffer().getActualSize(),
1:2b41f14:               new UnsafeRowComparatorForNormalDims(page));
1:f1f9348:         }
1:df22368:         if (page.isSaveToDisk()) {
1:f1f9348:           // create a new file every time
1:ded8b41:           // create a new file and pick a temp directory randomly every time
1:ded8b41:           String tmpDir = parameters.getTempFileLocation()[
1:ded8b41:               new Random().nextInt(parameters.getTempFileLocation().length)];
1:d5396b1:           File sortTempFile = new File(tmpDir + File.separator + parameters.getTableName()
1:d5396b1:               + '_' + parameters.getRangeId() + '_' + System.nanoTime()
1:d5396b1:               + CarbonCommonConstants.SORT_TEMP_FILE_EXT);
1:c100251:           writeDataToFile(page, sortTempFile);
1:f1f9348:           LOGGER.info("Time taken to sort row page with size" + page.getBuffer().getActualSize()
1:a734add:               + " and write is: " + (System.currentTimeMillis() - startTime) + ": location:"
1:2b41f14:               + sortTempFile + ", sort temp file size in MB is "
1:2b41f14:               + sortTempFile.length() * 0.1 * 10 / 1024 / 1024);
1:f1f9348:           page.freeMemory();
1:f1f9348:           // add sort temp filename to and arrayList. When the list size reaches 20 then
1:f1f9348:           // intermediate merging of sort temp files will be triggered
1:f1f9348:           unsafeInMemoryIntermediateFileMerger.addFileToMerge(sortTempFile);
1:f1f9348:         } else {
1:df22368:           // creating a new memory block as size is already allocated
1:df22368:           // so calling lazy memory allocator
1:df22368:           MemoryBlock newMemoryBlock = UnsafeSortMemoryManager.INSTANCE
1:df22368:               .allocateMemoryLazy(taskId, page.getDataBlock().size());
1:df22368:           // copying data from working memory manager to sortmemory manager
1:500654e:           CarbonUnsafe.getUnsafe()
1:df22368:               .copyMemory(page.getDataBlock().getBaseObject(), page.getDataBlock().getBaseOffset(),
1:df22368:                   newMemoryBlock.getBaseObject(), newMemoryBlock.getBaseOffset(),
1:df22368:                   page.getDataBlock().size());
1:df22368:           // free unsafememory manager
1:df22368:           page.freeMemory();
1:df22368:           page.setNewDataBlock(newMemoryBlock);
1:f1f9348:           // add sort temp filename to and arrayList. When the list size reaches 20 then
1:f1f9348:           // intermediate merging of sort temp files will be triggered
1:b051184:           page.getBuffer().loadToUnsafe();
1:f1f9348:           unsafeInMemoryIntermediateFileMerger.addDataChunkToMerge(page);
1:f1f9348:           LOGGER.info(
1:a734add:               "Time taken to sort row page with size: " + page.getBuffer().getActualSize() + "is: "
1:f1f9348:                   + (System.currentTimeMillis() - startTime));
1:f1f9348:         }
1:f1f9348:       } catch (Throwable e) {
1:06b0d08:         try {
1:06b0d08:           threadStatusObserver.notifyFailed(e);
1:06b0d08:         } catch (CarbonSortKeyAndGroupByException ex) {
1:06b0d08:           LOGGER.error(e);
1:06b0d08:         }
1:013db60:       } finally {
1:013db60:         semaphore.release();
1:f1f9348:       }
1:f1f9348:     }
1:f1f9348:   }
1:f1f9348: }
1:f1f9348: 
============================================================================
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:2576727
/////////////////////////////////////////////////////////////////////////
1:     if (rowPage == null) {
1:       return;
1:     }
1:           try {
1:             rowPage = createUnsafeRowPage();
1:           } catch (Exception ex) {
1:             // row page has freed in handlePreviousPage(), so other iterator may try to access it.
1:             rowPage = null;
1:             LOGGER.error(
1:                 "exception occurred while trying to acquire a semaphore lock: " + ex.getMessage());
1:             throw new CarbonSortKeyAndGroupByException(ex);
1:           }
/////////////////////////////////////////////////////////////////////////
1:     if (rowPage == null) {
1:       return;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:           rowPage = createUnsafeRowPage();
1:         } catch (Exception ex) {
1:           rowPage = null;
1:           LOGGER.error(
1:               "exception occurred while trying to acquire a semaphore lock: " + ex.getMessage());
1:           throw new CarbonSortKeyAndGroupByException(ex);
1:         }
author:ndwangsen
-------------------------------------------------------------------------------
commit:c3bc1ba
/////////////////////////////////////////////////////////////////////////
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       this.maxSizeAllowed = this.maxSizeAllowed * 1024L * 1024L;
commit:06b0d08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     this.inMemoryChunkSize = inMemoryChunkSize * 1024L * 1024L;
/////////////////////////////////////////////////////////////////////////
0:           dataSorterAndWriterExecutorService.execute(new DataSorterAndWriter(rowPage));
/////////////////////////////////////////////////////////////////////////
1:   private class DataSorterAndWriter implements Runnable {
1:     @Override
1:     public void run() {
/////////////////////////////////////////////////////////////////////////
1:         try {
1:           threadStatusObserver.notifyFailed(e);
1:         } catch (CarbonSortKeyAndGroupByException ex) {
1:           LOGGER.error(e);
1:         }
author:BJangir
-------------------------------------------------------------------------------
commit:3f33276
/////////////////////////////////////////////////////////////////////////
1:       semaphore.release();
author:xuchuanyin
-------------------------------------------------------------------------------
commit:b439b00
/////////////////////////////////////////////////////////////////////////
1:   public void initialize() throws MemoryException, CarbonSortKeyAndGroupByException {
/////////////////////////////////////////////////////////////////////////
1:   private UnsafeCarbonRowPage createUnsafeRowPage()
1:       throws MemoryException, CarbonSortKeyAndGroupByException {
1:     } else {
0:       LOGGER.info("trigger in-memory merge and spill for table " + parameters.getTableName());
1:       // merge and spill in-memory pages to disk if memory is not enough
1:       unsafeInMemoryIntermediateFileMerger.tryTriggerInmemoryMerging(true);
/////////////////////////////////////////////////////////////////////////
1:           handlePreviousPage();
/////////////////////////////////////////////////////////////////////////
1:         handlePreviousPage();
/////////////////////////////////////////////////////////////////////////
1:    * Below method will be used to start sorting process. This method will get
1:    * all the temp unsafe pages in memory and all the temp files and try to merge them if possible.
1:    * Also, it will spill the pages to disk or add it to unsafe sort memory.
1:    * @throws CarbonSortKeyAndGroupByException if error occurs during in-memory merge
1:    * @throws InterruptedException if error occurs during data sort and write
1:   public void startSorting() throws CarbonSortKeyAndGroupByException, InterruptedException {
1:       handlePreviousPage();
/////////////////////////////////////////////////////////////////////////
1:    * Deal with the previous pages added to sort-memory. Carbondata will merge the in-memory pages
1:    * or merge the sort temp files if possible. After that, carbondata will add current page to
1:    * sort memory or just spill them.
1:    */
1:   private void handlePreviousPage()
1:       throws CarbonSortKeyAndGroupByException, InterruptedException {
1:     if (enableInMemoryIntermediateMerge) {
1:       unsafeInMemoryIntermediateFileMerger.startInmemoryMergingIfPossible();
1:     }
1:     unsafeInMemoryIntermediateFileMerger.startFileMergingIfPossible();
1:     semaphore.acquire();
1:     dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(rowPage));
1:   }
1: 
1:   /**
commit:a161841
/////////////////////////////////////////////////////////////////////////
1:     this.rowPage = createUnsafeRowPage();
/////////////////////////////////////////////////////////////////////////
0:   private UnsafeCarbonRowPage createUnsafeRowPage() throws MemoryException {
1:     MemoryBlock baseBlock =
1:         UnsafeMemoryManager.allocateMemoryWithRetry(this.taskId, inMemoryChunkSize);
1:     boolean isMemoryAvailable =
1:         UnsafeSortMemoryManager.INSTANCE.isMemoryAvailable(baseBlock.size());
1:     if (isMemoryAvailable) {
1:       UnsafeSortMemoryManager.INSTANCE.allocateDummyMemory(baseBlock.size());
1:     }
1:     return new UnsafeCarbonRowPage(tableFieldStat, baseBlock, !isMemoryAvailable, taskId);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:           rowPage = createUnsafeRowPage();
/////////////////////////////////////////////////////////////////////////
0:         rowPage = createUnsafeRowPage();
commit:d5396b1
/////////////////////////////////////////////////////////////////////////
1:           File sortTempFile = new File(tmpDir + File.separator + parameters.getTableName()
1:               + '_' + parameters.getRangeId() + '_' + System.nanoTime()
1:               + CarbonCommonConstants.SORT_TEMP_FILE_EXT);
commit:2b41f14
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparatorForNormalDims;
1: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
/////////////////////////////////////////////////////////////////////////
1:   private TableFieldStat tableFieldStat;
1:   private ThreadLocal<ByteBuffer> rowBuffer;
/////////////////////////////////////////////////////////////////////////
1:     this.tableFieldStat = new TableFieldStat(parameters);
1:     this.rowBuffer = new ThreadLocal<ByteBuffer>() {
1:       @Override protected ByteBuffer initialValue() {
1:         byte[] backedArray = new byte[2 * 1024 * 1024];
1:         return ByteBuffer.wrap(backedArray);
1:       }
1:     };
/////////////////////////////////////////////////////////////////////////
0:     this.rowPage = new UnsafeCarbonRowPage(tableFieldStat, baseBlock, !isMemoryAvailable, taskId);
/////////////////////////////////////////////////////////////////////////
1:         bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:           rowPage = new UnsafeCarbonRowPage(tableFieldStat, memoryBlock, saveToDisk, taskId);
1:           bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
1:       rowPage.addRow(row, rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:         rowPage = new UnsafeCarbonRowPage(tableFieldStat, memoryBlock, saveToDisk, taskId);
1:         rowPage.addRow(row, rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:             new UnsafeRowComparatorForNormalDims(rowPage));
/////////////////////////////////////////////////////////////////////////
1:         rowPage.writeRow(
1:             rowPage.getBuffer().get(i) + rowPage.getDataBlock().getBaseOffset(), stream);
/////////////////////////////////////////////////////////////////////////
1:               new UnsafeRowComparatorForNormalDims(page));
/////////////////////////////////////////////////////////////////////////
1:               + sortTempFile + ", sort temp file size in MB is "
1:               + sortTempFile.length() * 0.1 * 10 / 1024 / 1024);
commit:8d8b589
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparatorForNormalDIms;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     this.rowPage = new UnsafeCarbonRowPage(parameters.getNoDictionaryDimnesionColumn(),
0:         parameters.getNoDictionarySortColumn(),
0:         parameters.getDimColCount() + parameters.getComplexDimColCount(),
0:         parameters.getMeasureColCount(), parameters.getMeasureDataType(), baseBlock,
0:         !isMemoryAvailable, taskId);
/////////////////////////////////////////////////////////////////////////
0:         bytesAdded += rowPage.addRow(rowBatch[i]);
/////////////////////////////////////////////////////////////////////////
0:           rowPage = new UnsafeCarbonRowPage(
0:                   parameters.getNoDictionaryDimnesionColumn(),
0:                   parameters.getNoDictionarySortColumn(),
0:                   parameters.getDimColCount() + parameters.getComplexDimColCount(),
0:                   parameters.getMeasureColCount(),
0:                   parameters.getMeasureDataType(),
0:                   memoryBlock,
0:                   saveToDisk, taskId);
0:           bytesAdded += rowPage.addRow(rowBatch[i]);
/////////////////////////////////////////////////////////////////////////
0:       rowPage.addRow(row);
/////////////////////////////////////////////////////////////////////////
0:         rowPage = new UnsafeCarbonRowPage(
0:             parameters.getNoDictionaryDimnesionColumn(),
0:             parameters.getNoDictionarySortColumn(),
0:             parameters.getDimColCount(), parameters.getMeasureColCount(),
0:             parameters.getMeasureDataType(), memoryBlock,
0:             saveToDisk, taskId);
0:         rowPage.addRow(row);
/////////////////////////////////////////////////////////////////////////
0:             new UnsafeRowComparatorForNormalDIms(rowPage));
/////////////////////////////////////////////////////////////////////////
0:         rowPage.fillRow(rowPage.getBuffer().get(i) + rowPage.getDataBlock().getBaseOffset(),
0:             stream);
1: 
/////////////////////////////////////////////////////////////////////////
0:               new UnsafeRowComparatorForNormalDIms(page));
/////////////////////////////////////////////////////////////////////////
0:               + sortTempFile);
commit:21704cf
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparatorForNormalDims;
0: import org.apache.carbondata.processing.sort.sortdata.TableFieldStat;
/////////////////////////////////////////////////////////////////////////
0:   private TableFieldStat tableFieldStat;
0:   private ThreadLocal<ByteBuffer> rowBuffer;
/////////////////////////////////////////////////////////////////////////
0:     this.tableFieldStat = new TableFieldStat(parameters);
0:     this.rowBuffer = new ThreadLocal<ByteBuffer>() {
0:       @Override protected ByteBuffer initialValue() {
0:         byte[] backedArray = new byte[2 * 1024 * 1024];
0:         return ByteBuffer.wrap(backedArray);
1:       }
0:     };
/////////////////////////////////////////////////////////////////////////
0:     this.rowPage = new UnsafeCarbonRowPage(tableFieldStat, baseBlock, !isMemoryAvailable, taskId);
/////////////////////////////////////////////////////////////////////////
0:         bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:           rowPage = new UnsafeCarbonRowPage(tableFieldStat, memoryBlock, saveToDisk, taskId);
0:           bytesAdded += rowPage.addRow(rowBatch[i], rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:       rowPage.addRow(row, rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:         rowPage = new UnsafeCarbonRowPage(tableFieldStat, memoryBlock, saveToDisk, taskId);
0:         rowPage.addRow(row, rowBuffer.get());
/////////////////////////////////////////////////////////////////////////
0:             new UnsafeRowComparatorForNormalDims(rowPage));
/////////////////////////////////////////////////////////////////////////
0:         rowPage.writeRow(
0:             rowPage.getBuffer().get(i) + rowPage.getDataBlock().getBaseOffset(), stream);
/////////////////////////////////////////////////////////////////////////
0:               new UnsafeRowComparatorForNormalDims(page));
/////////////////////////////////////////////////////////////////////////
0:               + sortTempFile + ", sort temp file size in MB is "
0:               + sortTempFile.length() * 0.1 * 10 / 1024 / 1024);
commit:c100251
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * write a page to sort temp file
1:    * @param rowPage page
1:    * @param file file
1:    * @throws CarbonSortKeyAndGroupByException
1:    */
1:   private void writeDataToFile(UnsafeCarbonRowPage rowPage, File file)
1:       stream = FileFactory.getDataOutputStream(file.getPath(), FileFactory.FileType.LOCAL,
1:           parameters.getFileWriteBufferSize(), parameters.getSortTempCompressorName());
/////////////////////////////////////////////////////////////////////////
1:           writeDataToFile(page, sortTempFile);
commit:ded8b41
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
1:     CarbonDataProcessorUtil.createLocations(parameters.getTempFileLocation());
/////////////////////////////////////////////////////////////////////////
1:           // create a new file and pick a temp directory randomly every time
1:           String tmpDir = parameters.getTempFileLocation()[
1:               new Random().nextInt(parameters.getTempFileLocation().length)];
0:               tmpDir + File.separator + parameters.getTableName()
0:                   + System.nanoTime() + CarbonCommonConstants.SORT_TEMP_FILE_EXT);
author:kumarvishal
-------------------------------------------------------------------------------
commit:a734add
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.CarbonThreadFactory;
/////////////////////////////////////////////////////////////////////////
1:     this.dataSorterAndWriterExecutorService = Executors
1:         .newFixedThreadPool(parameters.getNumberOfCores(),
1:             new CarbonThreadFactory("UnsafeSortDataRowPool:" + parameters.getTableName()));
/////////////////////////////////////////////////////////////////////////
1:               + " and write is: " + (System.currentTimeMillis() - startTime) + ": location:"
0:               + sortTempFile);
/////////////////////////////////////////////////////////////////////////
1:               "Time taken to sort row page with size: " + page.getBuffer().getActualSize() + "is: "
commit:df22368
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.CarbonUnsafe;
1: import org.apache.carbondata.core.memory.UnsafeSortMemoryManager;
1: import org.apache.carbondata.core.util.ThreadLocalTaskInfo;
/////////////////////////////////////////////////////////////////////////
1:   private final long taskId;
1: 
/////////////////////////////////////////////////////////////////////////
1:     this.taskId = ThreadLocalTaskInfo.getCarbonTaskInfo().getTaskId();
0:     this.inMemoryChunkSize = inMemoryChunkSize * 1024 * 1024;
/////////////////////////////////////////////////////////////////////////
0:     MemoryBlock baseBlock =
0:         UnsafeMemoryManager.allocateMemoryWithRetry(this.taskId, inMemoryChunkSize);
0:     boolean isMemoryAvailable =
0:         UnsafeSortMemoryManager.INSTANCE.isMemoryAvailable(baseBlock.size());
0:     if (isMemoryAvailable) {
0:       UnsafeSortMemoryManager.INSTANCE.allocateDummyMemory(baseBlock.size());
1:     }
0:         !isMemoryAvailable, taskId);
/////////////////////////////////////////////////////////////////////////
0:           MemoryBlock memoryBlock =
0:               UnsafeMemoryManager.allocateMemoryWithRetry(this.taskId, inMemoryChunkSize);
0:           boolean saveToDisk =
0:               UnsafeSortMemoryManager.INSTANCE.isMemoryAvailable(memoryBlock.size());
0:           if (!saveToDisk) {
0:             UnsafeSortMemoryManager.INSTANCE.allocateDummyMemory(memoryBlock.size());
1:           }
/////////////////////////////////////////////////////////////////////////
0:                   saveToDisk, taskId);
/////////////////////////////////////////////////////////////////////////
0:         MemoryBlock memoryBlock =
0:             UnsafeMemoryManager.allocateMemoryWithRetry(this.taskId, inMemoryChunkSize);
0:         boolean saveToDisk = UnsafeSortMemoryManager.INSTANCE.isMemoryAvailable(memoryBlock.size());
0:         if (!saveToDisk) {
0:           UnsafeSortMemoryManager.INSTANCE.allocateDummyMemory(memoryBlock.size());
1:         }
0:             saveToDisk, taskId);
/////////////////////////////////////////////////////////////////////////
1:         if (page.isSaveToDisk()) {
/////////////////////////////////////////////////////////////////////////
1:           // creating a new memory block as size is already allocated
1:           // so calling lazy memory allocator
1:           MemoryBlock newMemoryBlock = UnsafeSortMemoryManager.INSTANCE
1:               .allocateMemoryLazy(taskId, page.getDataBlock().size());
1:           // copying data from working memory manager to sortmemory manager
0:           CarbonUnsafe.unsafe
1:               .copyMemory(page.getDataBlock().getBaseObject(), page.getDataBlock().getBaseOffset(),
1:                   newMemoryBlock.getBaseObject(), newMemoryBlock.getBaseOffset(),
1:                   page.getDataBlock().size());
1:           // free unsafememory manager
1:           page.freeMemory();
1:           page.setNewDataBlock(newMemoryBlock);
author:Jacky Li
-------------------------------------------------------------------------------
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading.sort.unsafe;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparator;
0: import org.apache.carbondata.processing.loading.sort.unsafe.comparator.UnsafeRowComparatorForNormalDIms;
1: import org.apache.carbondata.processing.loading.sort.unsafe.holder.UnsafeCarbonRow;
1: import org.apache.carbondata.processing.loading.sort.unsafe.merger.UnsafeIntermediateMerger;
1: import org.apache.carbondata.processing.loading.sort.unsafe.sort.TimSort;
1: import org.apache.carbondata.processing.loading.sort.unsafe.sort.UnsafeIntSortDataFormat;
1: import org.apache.carbondata.processing.sort.exception.CarbonSortKeyAndGroupByException;
1: import org.apache.carbondata.processing.sort.sortdata.SortParameters;
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
1:           CarbonUnsafe.getUnsafe()
author:jackylk
-------------------------------------------------------------------------------
commit:edda248
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.memory.IntPointerBuffer;
1: import org.apache.carbondata.core.memory.MemoryException;
1: import org.apache.carbondata.core.memory.UnsafeMemoryManager;
/////////////////////////////////////////////////////////////////////////
0:   public void initialize() throws MemoryException {
0:     MemoryBlock baseBlock = UnsafeMemoryManager.allocateMemoryWithRetry(inMemoryChunkSize);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           MemoryBlock memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(inMemoryChunkSize);
/////////////////////////////////////////////////////////////////////////
0:         MemoryBlock memoryBlock = UnsafeMemoryManager.allocateMemoryWithRetry(inMemoryChunkSize);
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
0:     while (tries < 100) {
commit:98df130
/////////////////////////////////////////////////////////////////////////
0:         parameters.getMeasureColCount(), parameters.getMeasureDataType(), baseBlock,
/////////////////////////////////////////////////////////////////////////
0:             rowPage = new UnsafeCarbonRowPage(
0:                 parameters.getNoDictionaryDimnesionColumn(),
0:                 parameters.getMeasureColCount(),
0:                 parameters.getMeasureDataType(),
0:                 memoryBlock,
0:                 saveToDisk);
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
1:    * @throws InterruptedException
0:   public void startSorting() throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:   public void deleteSortLocationIfExists() {
0:    * @throws InterruptedException
1:   private void startFileBasedMerge() throws InterruptedException {
1:     dataSorterAndWriterExecutorService.shutdown();
1:     dataSorterAndWriterExecutorService.awaitTermination(2, TimeUnit.DAYS);
commit:3fe6903
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:dhatchayani
-------------------------------------------------------------------------------
commit:408de86
/////////////////////////////////////////////////////////////////////////
1:       addBatch(rowBatch, size);
1:     }
1:   }
1:   /**
1:    * This method will be used to add new row
1:    *
1:    * @param rowBatch new rowBatch
1:    * @param size
1:    * @throws CarbonSortKeyAndGroupByException problem while writing
1:    */
1:   public void addRowBatchWithOutSync(Object[][] rowBatch, int size)
1:       throws CarbonSortKeyAndGroupByException {
1:     // if record holder list size is equal to sort buffer size then it will
1:     // sort the list and then write current list data to file
1:     addBatch(rowBatch, size);
1:   }
1: 
1:   private void addBatch(Object[][] rowBatch, int size) throws CarbonSortKeyAndGroupByException {
1:     for (int i = 0; i < size; i++) {
1:       if (rowPage.canAdd()) {
0:         bytesAdded += rowPage.addRow(rowBatch[i]);
1:       } else {
1:         try {
0:           if (enableInMemoryIntermediateMerge) {
0:             unsafeInMemoryIntermediateFileMerger.startInmemoryMergingIfPossible();
1:           }
0:           unsafeInMemoryIntermediateFileMerger.startFileMergingIfPossible();
0:           semaphore.acquire();
0:           dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(rowPage));
0:           MemoryBlock memoryBlock = getMemoryBlock(inMemoryChunkSize);
0:           boolean saveToDisk = !UnsafeMemoryManager.INSTANCE.isMemoryAvailable();
0:           rowPage = new UnsafeCarbonRowPage(
0:                   parameters.getNoDictionaryDimnesionColumn(),
0:                   parameters.getNoDictionarySortColumn(),
0:                   parameters.getDimColCount() + parameters.getComplexDimColCount(),
0:                   parameters.getMeasureColCount(),
0:                   parameters.getMeasureDataType(),
0:                   memoryBlock,
0:                   saveToDisk);
0:           bytesAdded += rowPage.addRow(rowBatch[i]);
1:         } catch (Exception e) {
1:           LOGGER.error(
1:                   "exception occurred while trying to acquire a semaphore lock: " + e.getMessage());
1:           throw new CarbonSortKeyAndGroupByException(e);
1: 
author:ravipesala
-------------------------------------------------------------------------------
commit:3807b2f
/////////////////////////////////////////////////////////////////////////
1:     this.maxSizeAllowed = parameters.getBatchSortSizeinMb();
1:       // If user does not input any memory size, then take half the size of usable memory configured
1:       // in sort memory size.
commit:f82b10b
/////////////////////////////////////////////////////////////////////////
1:       UnsafeIntermediateMerger unsafeInMemoryIntermediateFileMerger, int inMemoryChunkSize) {
/////////////////////////////////////////////////////////////////////////
0:     this.inMemoryChunkSize = inMemoryChunkSize;
/////////////////////////////////////////////////////////////////////////
1:    * This method will be used to add new row
1:    */
1:   public void addRow(Object[] row) throws CarbonSortKeyAndGroupByException {
1:     // if record holder list size is equal to sort buffer size then it will
1:     // sort the list and then write current list data to file
1:     if (rowPage.canAdd()) {
0:       rowPage.addRow(row);
1:     } else {
1:       try {
0:         if (enableInMemoryIntermediateMerge) {
0:           unsafeInMemoryIntermediateFileMerger.startInmemoryMergingIfPossible();
1:         }
0:         unsafeInMemoryIntermediateFileMerger.startFileMergingIfPossible();
0:         semaphore.acquire();
0:         dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(rowPage));
0:         MemoryBlock memoryBlock = getMemoryBlock(inMemoryChunkSize);
0:         boolean saveToDisk = !UnsafeMemoryManager.INSTANCE.isMemoryAvailable();
0:         rowPage = new UnsafeCarbonRowPage(parameters.getNoDictionaryDimnesionColumn(),
0:             parameters.getDimColCount(), parameters.getMeasureColCount(),
0:             parameters.getAggType(), memoryBlock,
0:             saveToDisk);
0:         rowPage.addRow(row);
1:       } catch (Exception e) {
1:         LOGGER.error(
1:             "exception occurred while trying to acquire a semaphore lock: " + e.getMessage());
1:         throw new CarbonSortKeyAndGroupByException(e);
1:       }
1: 
1:     }
1:   }
1: 
1:   /**
commit:b051184
/////////////////////////////////////////////////////////////////////////
1:           page.getBuffer().loadToUnsafe();
commit:013db60
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Semaphore;
/////////////////////////////////////////////////////////////////////////
1:   private long inMemoryChunkSize;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * semaphore which will used for managing sorted data object arrays
1:    */
1:   private Semaphore semaphore;
1: 
/////////////////////////////////////////////////////////////////////////
0:     this.inMemoryChunkSize = CarbonProperties.getInstance().getSortMemoryChunkSizeInMB();
0:     this.inMemoryChunkSize = this.inMemoryChunkSize * 1024 * 1024;
/////////////////////////////////////////////////////////////////////////
0:     MemoryBlock baseBlock = getMemoryBlock(inMemoryChunkSize);
/////////////////////////////////////////////////////////////////////////
1:     semaphore = new Semaphore(parameters.getNumberOfCores());
/////////////////////////////////////////////////////////////////////////
0:             semaphore.acquire();
0:             MemoryBlock memoryBlock = getMemoryBlock(inMemoryChunkSize);
/////////////////////////////////////////////////////////////////////////
1:       } finally {
1:         semaphore.release();
commit:b13ead9
/////////////////////////////////////////////////////////////////////////
1:   private int bytesAdded;
1: 
1:   private long maxSizeAllowed;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     this.maxSizeAllowed = Integer.parseInt(CarbonProperties.getInstance()
0:         .getProperty(CarbonCommonConstants.LOAD_BATCH_SORT_SIZE_INMB, "0"));
1:     if (maxSizeAllowed <= 0) {
1:       this.maxSizeAllowed = UnsafeMemoryManager.INSTANCE.getUsableMemory() / 2;
1:     } else {
0:       this.maxSizeAllowed = this.maxSizeAllowed * 1024 * 1024;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         parameters.getDimColCount() + parameters.getComplexDimColCount(),
0:         parameters.getMeasureColCount(), parameters.getAggType(), baseBlock,
0:         !UnsafeMemoryManager.INSTANCE.isMemoryAvailable());
/////////////////////////////////////////////////////////////////////////
1:   public boolean canAdd() {
1:     return bytesAdded < maxSizeAllowed;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:           bytesAdded += rowPage.addRow(rowBatch[i]);
/////////////////////////////////////////////////////////////////////////
0:                 parameters.getDimColCount() + parameters.getComplexDimColCount(),
0:                 parameters.getMeasureColCount(), parameters.getAggType(), memoryBlock, saveToDisk);
0:             bytesAdded += rowPage.addRow(rowBatch[i]);
commit:f1f9348
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
0: package org.apache.carbondata.processing.newflow.sort.unsafe;
1: 
0: import java.io.BufferedOutputStream;
1: import java.io.DataOutputStream;
1: import java.io.File;
0: import java.io.FileOutputStream;
1: import java.io.IOException;
0: import java.util.concurrent.Callable;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.memory.MemoryBlock;
1: import org.apache.carbondata.core.util.CarbonProperties;
1: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.comparator.UnsafeRowComparator;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.comparator.UnsafeRowComparatorForNormalDIms;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.holder.UnsafeCarbonRow;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.merger.UnsafeIntermediateMerger;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.sort.TimSort;
0: import org.apache.carbondata.processing.newflow.sort.unsafe.sort.UnsafeIntSortDataFormat;
0: import org.apache.carbondata.processing.sortandgroupby.exception.CarbonSortKeyAndGroupByException;
0: import org.apache.carbondata.processing.sortandgroupby.sortdata.SortParameters;
0: import org.apache.carbondata.processing.sortandgroupby.sortdata.SortTempFileChunkWriter;
0: import org.apache.carbondata.processing.sortandgroupby.sortdata.TempSortFileWriter;
0: import org.apache.carbondata.processing.sortandgroupby.sortdata.TempSortFileWriterFactory;
1: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1: 
1: public class UnsafeSortDataRows {
1:   /**
1:    * LOGGER
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(UnsafeSortDataRows.class.getName());
1:   /**
1:    * threadStatusObserver
1:    */
1:   private ThreadStatusObserver threadStatusObserver;
1:   /**
1:    * executor service for data sort holder
1:    */
1:   private ExecutorService dataSorterAndWriterExecutorService;
1:   /**
1:    * semaphore which will used for managing sorted data object arrays
1:    */
1: 
1:   private SortParameters parameters;
1: 
1:   private UnsafeIntermediateMerger unsafeInMemoryIntermediateFileMerger;
1: 
1:   private UnsafeCarbonRowPage rowPage;
1: 
1:   private final Object addRowsLock = new Object();
1: 
0:   private int inMemoryChunkSizeInMB;
1: 
1:   private boolean enableInMemoryIntermediateMerge;
1: 
1:   public UnsafeSortDataRows(SortParameters parameters,
0:       UnsafeIntermediateMerger unsafeInMemoryIntermediateFileMerger) {
1:     this.parameters = parameters;
1: 
1:     this.unsafeInMemoryIntermediateFileMerger = unsafeInMemoryIntermediateFileMerger;
1: 
1:     // observer of writing file in thread
1:     this.threadStatusObserver = new ThreadStatusObserver();
1: 
0:     this.inMemoryChunkSizeInMB = Integer.parseInt(CarbonProperties.getInstance()
0:         .getProperty(CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB,
0:             CarbonCommonConstants.OFFHEAP_SORT_CHUNK_SIZE_IN_MB_DEFAULT));
1:     enableInMemoryIntermediateMerge = Boolean.parseBoolean(CarbonProperties.getInstance()
1:         .getProperty(CarbonCommonConstants.ENABLE_INMEMORY_MERGE_SORT,
1:             CarbonCommonConstants.ENABLE_INMEMORY_MERGE_SORT_DEFAULT));
1:   }
1: 
1:   /**
1:    * This method will be used to initialize
1:    */
0:   public void initialize() throws CarbonSortKeyAndGroupByException {
0:     MemoryBlock baseBlock = getMemoryBlock(inMemoryChunkSizeInMB * 1024 * 1024);
0:     this.rowPage = new UnsafeCarbonRowPage(parameters.getNoDictionaryDimnesionColumn(),
0:         parameters.getDimColCount(), parameters.getMeasureColCount(), parameters.getAggType(),
0:         baseBlock, !UnsafeMemoryManager.INSTANCE.isMemoryAvailable());
1:     // Delete if any older file exists in sort temp folder
1:     deleteSortLocationIfExists();
1: 
1:     // create new sort temp directory
0:     if (!new File(parameters.getTempFileLocation()).mkdirs()) {
0:       LOGGER.info("Sort Temp Location Already Exists");
1:     }
0:     this.dataSorterAndWriterExecutorService =
0:         Executors.newFixedThreadPool(parameters.getNumberOfCores());
1:   }
1: 
0:   public static MemoryBlock getMemoryBlock(long size) throws CarbonSortKeyAndGroupByException {
0:     MemoryBlock baseBlock = null;
0:     int tries = 0;
0:     while (true && tries < 100) {
0:       baseBlock = UnsafeMemoryManager.INSTANCE.allocateMemory(size);
0:       if (baseBlock == null) {
1:         try {
0:           Thread.sleep(50);
0:         } catch (InterruptedException e) {
0:           throw new CarbonSortKeyAndGroupByException(e);
1:         }
1:       } else {
0:         break;
1:       }
0:       tries++;
1:     }
0:     if (baseBlock == null) {
0:       throw new CarbonSortKeyAndGroupByException("Not enough memory to create page");
1:     }
0:     return baseBlock;
1:   }
1: 
1:   /**
1:    * This method will be used to add new row
1:    *
1:    * @param rowBatch new rowBatch
1:    * @throws CarbonSortKeyAndGroupByException problem while writing
1:    */
1:   public void addRowBatch(Object[][] rowBatch, int size) throws CarbonSortKeyAndGroupByException {
1:     // if record holder list size is equal to sort buffer size then it will
1:     // sort the list and then write current list data to file
1:     synchronized (addRowsLock) {
0:       for (int i = 0; i < size; i++) {
0:         if (rowPage.canAdd()) {
0:           rowPage.addRow(rowBatch[i]);
1:         } else {
1:           try {
0:             if (enableInMemoryIntermediateMerge) {
0:               unsafeInMemoryIntermediateFileMerger.startInmemoryMergingIfPossible();
1:             }
0:             unsafeInMemoryIntermediateFileMerger.startFileMergingIfPossible();
0:             dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(rowPage));
0:             MemoryBlock memoryBlock = getMemoryBlock(inMemoryChunkSizeInMB * 1024 * 1024);
0:             boolean saveToDisk = !UnsafeMemoryManager.INSTANCE.isMemoryAvailable();
0:             rowPage = new UnsafeCarbonRowPage(parameters.getNoDictionaryDimnesionColumn(),
0:                 parameters.getDimColCount(), parameters.getMeasureColCount(),
0:                 parameters.getAggType(), memoryBlock,
0:                 saveToDisk);
0:             rowPage.addRow(rowBatch[i]);
0:           } catch (Exception e) {
0:             LOGGER.error(
0:                 "exception occurred while trying to acquire a semaphore lock: " + e.getMessage());
0:             throw new CarbonSortKeyAndGroupByException(e);
1:           }
1: 
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
0:    * Below method will be used to start storing process This method will get
0:    * all the temp files present in sort temp folder then it will create the
0:    * record holder heap and then it will read first record from each file and
0:    * initialize the heap
1:    *
1:    * @throws CarbonSortKeyAndGroupByException
1:    */
0:   public void startSorting() throws CarbonSortKeyAndGroupByException {
1:     LOGGER.info("Unsafe based sorting will be used");
1:     if (this.rowPage.getUsedSize() > 0) {
1:       TimSort<UnsafeCarbonRow, IntPointerBuffer> timSort = new TimSort<>(
0:           new UnsafeIntSortDataFormat(rowPage));
0:       if (parameters.getNoDictionaryCount() > 0) {
0:         timSort.sort(rowPage.getBuffer(), 0, rowPage.getBuffer().getActualSize(),
0:             new UnsafeRowComparator(rowPage));
1:       } else {
0:         timSort.sort(rowPage.getBuffer(), 0, rowPage.getBuffer().getActualSize(),
0:             new UnsafeRowComparatorForNormalDIms(parameters.getDimColCount(), rowPage));
1:       }
0:       unsafeInMemoryIntermediateFileMerger.addDataChunkToMerge(rowPage);
1:     } else {
1:       rowPage.freeMemory();
1:     }
1:     startFileBasedMerge();
1:   }
1: 
0:   private void writeSortTempFile(Object[][] recordHolderList, int entryCountLocal, File file)
1:       throws CarbonSortKeyAndGroupByException {
0:     TempSortFileWriter writer = null;
1: 
1:     try {
0:       writer = getWriter();
0:       writer.initiaize(file, entryCountLocal);
0:       writer.writeSortTempFile(recordHolderList);
0:     } catch (CarbonSortKeyAndGroupByException e) {
0:       LOGGER.error(e, "Problem while writing the sort temp file");
0:       throw e;
1:     } finally {
0:       if (writer != null) {
0:         writer.finish();
1:       }
1:     }
1:   }
1: 
0:   private void writeData(UnsafeCarbonRowPage rowPage, File file)
1:       throws CarbonSortKeyAndGroupByException {
1:     DataOutputStream stream = null;
1:     try {
1:       // open stream
0:       stream = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file),
0:           parameters.getFileWriteBufferSize()));
1:       int actualSize = rowPage.getBuffer().getActualSize();
1:       // write number of entries to the file
1:       stream.writeInt(actualSize);
1:       for (int i = 0; i < actualSize; i++) {
0:         rowPage.fillRow(rowPage.getBuffer().get(i) + rowPage.getDataBlock().getBaseOffset(),
0:             stream);
1:       }
1: 
1:     } catch (IOException e) {
1:       throw new CarbonSortKeyAndGroupByException("Problem while writing the file", e);
1:     } finally {
1:       // close streams
1:       CarbonUtil.closeStreams(stream);
1:     }
1:   }
1: 
0:   private TempSortFileWriter getWriter() {
0:     TempSortFileWriter chunkWriter = null;
0:     TempSortFileWriter writer = TempSortFileWriterFactory.getInstance()
0:         .getTempSortFileWriter(parameters.isSortFileCompressionEnabled(),
0:             parameters.getDimColCount(), parameters.getComplexDimColCount(),
0:             parameters.getMeasureColCount(), parameters.getNoDictionaryCount(),
0:             parameters.getFileWriteBufferSize());
1: 
0:     if (parameters.isPrefetch() && !parameters.isSortFileCompressionEnabled()) {
0:       chunkWriter = new SortTempFileChunkWriter(writer, parameters.getBufferSize());
1:     } else {
0:       chunkWriter =
0:           new SortTempFileChunkWriter(writer, parameters.getSortTempFileNoOFRecordsInCompression());
1:     }
1: 
0:     return chunkWriter;
1:   }
1: 
1:   /**
1:    * This method will be used to delete sort temp location is it is exites
1:    *
1:    * @throws CarbonSortKeyAndGroupByException
1:    */
0:   public void deleteSortLocationIfExists() throws CarbonSortKeyAndGroupByException {
1:     CarbonDataProcessorUtil.deleteSortLocationIfExists(parameters.getTempFileLocation());
1:   }
1: 
1:   /**
1:    * Below method will be used to start file based merge
1:    *
1:    * @throws CarbonSortKeyAndGroupByException
1:    */
0:   private void startFileBasedMerge() throws CarbonSortKeyAndGroupByException {
1:     try {
0:       dataSorterAndWriterExecutorService.shutdown();
0:       dataSorterAndWriterExecutorService.awaitTermination(2, TimeUnit.DAYS);
0:     } catch (InterruptedException e) {
0:       throw new CarbonSortKeyAndGroupByException("Problem while shutdown the server ", e);
1:     }
1:   }
1: 
1:   /**
1:    * Observer class for thread execution
1:    * In case of any failure we need stop all the running thread
1:    */
1:   private class ThreadStatusObserver {
1:     /**
1:      * Below method will be called if any thread fails during execution
1:      *
1:      * @param exception
1:      * @throws CarbonSortKeyAndGroupByException
1:      */
1:     public void notifyFailed(Throwable exception) throws CarbonSortKeyAndGroupByException {
1:       dataSorterAndWriterExecutorService.shutdownNow();
1:       unsafeInMemoryIntermediateFileMerger.close();
1:       parameters.getObserver().setFailed(true);
1:       LOGGER.error(exception);
1:       throw new CarbonSortKeyAndGroupByException(exception);
1:     }
1:   }
1: 
1:   /**
1:    * This class is responsible for sorting and writing the object
1:    * array which holds the records equal to given array size
1:    */
0:   private class DataSorterAndWriter implements Callable<Void> {
1:     private UnsafeCarbonRowPage page;
1: 
1:     public DataSorterAndWriter(UnsafeCarbonRowPage rowPage) {
1:       this.page = rowPage;
1:     }
1: 
0:     @Override public Void call() throws Exception {
1:       try {
1:         long startTime = System.currentTimeMillis();
1:         TimSort<UnsafeCarbonRow, IntPointerBuffer> timSort = new TimSort<>(
1:             new UnsafeIntSortDataFormat(page));
0:         if (parameters.getNoDictionaryCount() > 0) {
1:           timSort.sort(page.getBuffer(), 0, page.getBuffer().getActualSize(),
1:               new UnsafeRowComparator(page));
1:         } else {
1:           timSort.sort(page.getBuffer(), 0, page.getBuffer().getActualSize(),
0:               new UnsafeRowComparatorForNormalDIms(parameters.getDimColCount(), page));
1:         }
0:         if (rowPage.isSaveToDisk()) {
1:           // create a new file every time
0:           File sortTempFile = new File(
0:               parameters.getTempFileLocation() + File.separator + parameters.getTableName() + System
0:                   .nanoTime() + CarbonCommonConstants.SORT_TEMP_FILE_EXT);
0:           writeData(page, sortTempFile);
1:           LOGGER.info("Time taken to sort row page with size" + page.getBuffer().getActualSize()
0:               + " and write is: " + (System.currentTimeMillis() - startTime));
1:           page.freeMemory();
1:           // add sort temp filename to and arrayList. When the list size reaches 20 then
1:           // intermediate merging of sort temp files will be triggered
1:           unsafeInMemoryIntermediateFileMerger.addFileToMerge(sortTempFile);
1:         } else {
1:           // add sort temp filename to and arrayList. When the list size reaches 20 then
1:           // intermediate merging of sort temp files will be triggered
1:           unsafeInMemoryIntermediateFileMerger.addDataChunkToMerge(page);
1:           LOGGER.info(
0:               "Time taken to sort row page with size" + page.getBuffer().getActualSize() + "is: "
1:                   + (System.currentTimeMillis() - startTime));
1:         }
1:       } catch (Throwable e) {
0:         threadStatusObserver.notifyFailed(e);
1:       }
0:       return null;
1:     }
1:   }
1: }
1: 
author:QiangCai
-------------------------------------------------------------------------------
commit:fa08ab4
/////////////////////////////////////////////////////////////////////////
0:         rowPage = new UnsafeCarbonRowPage(
0:             parameters.getNoDictionaryDimnesionColumn(),
0:             parameters.getNoDictionarySortColumn(),
0:             parameters.getMeasureDataType(), memoryBlock,
commit:9f94529
/////////////////////////////////////////////////////////////////////////
0:         parameters.getNoDictionarySortColumn(),
/////////////////////////////////////////////////////////////////////////
0:                 parameters.getNoDictionarySortColumn(),
/////////////////////////////////////////////////////////////////////////
1:       if (parameters.getNumberOfNoDictSortColumns() > 0) {
0:             new UnsafeRowComparatorForNormalDIms(rowPage));
/////////////////////////////////////////////////////////////////////////
1:         // if sort_columns is not none, sort by sort_columns
0:         if (parameters.getNumberOfNoDictSortColumns() > 0) {
0:               new UnsafeRowComparatorForNormalDIms(page));
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
============================================================================