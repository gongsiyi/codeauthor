1:bc3e684: /*
1:bc3e684:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:bc3e684:  * contributor license agreements.  See the NOTICE file distributed with
1:bc3e684:  * this work for additional information regarding copyright ownership.
1:bc3e684:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:bc3e684:  * (the "License"); you may not use this file except in compliance with
1:bc3e684:  * the License.  You may obtain a copy of the License at
1:bc3e684:  *
1:bc3e684:  *    http://www.apache.org/licenses/LICENSE-2.0
1:bc3e684:  *
1:bc3e684:  * Unless required by applicable law or agreed to in writing, software
1:bc3e684:  * distributed under the License is distributed on an "AS IS" BASIS,
1:bc3e684:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bc3e684:  * See the License for the specific language governing permissions and
1:bc3e684:  * limitations under the License.
1:bc3e684:  */
5:bc3e684: 
1:bc3e684: package org.apache.carbondata.core.datastore.page.statistics;
1:bc3e684: 
1:bc3e684: import java.math.BigDecimal;
1:bc3e684: 
1:e6a4f64: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
1:6abdd97: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
1:bc3e684: import org.apache.carbondata.core.metadata.ValueEncoderMeta;
1:bc3e684: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:bc3e684: 
1:6abdd97: import static org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert.FALSE_VALUE;
1:6abdd97: import static org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert.TRUE_VALUE;
1:6abdd97: 
1:bc3e684: /** statics for primitive column page */
1:bc3e684: public class PrimitivePageStatsCollector implements ColumnPageStatsCollector, SimpleStatsResult {
1:bc3e684:   private DataType dataType;
1:bc3e684:   private byte minByte, maxByte;
1:bc3e684:   private short minShort, maxShort;
1:bc3e684:   private int minInt, maxInt;
1:bc3e684:   private long minLong, maxLong;
1:bc3e684:   private double minDouble, maxDouble;
1:4e83509:   private BigDecimal minDecimal, maxDecimal;
1:bc3e684: 
1:4f7487d:   // scale of the double value, apply adaptive encoding if this is positive
1:bc3e684:   private int decimal;
1:bc3e684: 
1:438b442:   // scale of the double value, only for complex primitive.
1:438b442:   private int decimalCountForComplexPrimitive;
1:438b442: 
1:4e83509:   private boolean isFirst = true;
1:4e83509:   private BigDecimal zeroDecimal;
1:4e83509: 
1:bc3e684:   // this is for encode flow
1:f209e8e:   public static PrimitivePageStatsCollector newInstance(DataType dataType) {
1:f209e8e:     return new PrimitivePageStatsCollector(dataType);
7:bc3e684:   }
1:7422690: 
1:e6a4f64:   // this is for decode flow, create stats from encoder meta in carbondata file
1:e6a4f64:   public static PrimitivePageStatsCollector newInstance(ColumnPageEncoderMeta meta) {
1:f209e8e:     PrimitivePageStatsCollector instance =
1:f209e8e:         new PrimitivePageStatsCollector(meta.getSchemaDataType());
1:bc3e684:     // set min max from meta
1:956833e:     DataType dataType = meta.getSchemaDataType();
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:       instance.minByte = (byte) meta.getMinValue();
1:956833e:       instance.maxByte = (byte) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       instance.minShort = (short) meta.getMinValue();
1:956833e:       instance.maxShort = (short) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       instance.minInt = (int) meta.getMinValue();
1:956833e:       instance.maxInt = (int) meta.getMaxValue();
1:438b442:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:956833e:       instance.minLong = (long) meta.getMinValue();
1:956833e:       instance.maxLong = (long) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       instance.minDouble = (double) meta.getMinValue();
1:956833e:       instance.maxDouble = (double) meta.getMaxValue();
1:956833e:       instance.decimal = meta.getDecimal();
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       instance.minDecimal = (BigDecimal) meta.getMinValue();
1:956833e:       instance.maxDecimal = (BigDecimal) meta.getMaxValue();
1:956833e:       instance.decimal = meta.getDecimal();
1:956833e:     } else {
1:956833e:       throw new UnsupportedOperationException(
1:956833e:           "unsupported data type for stats collection: " + meta.getSchemaDataType());
1:7422690:     }
1:bc3e684:     return instance;
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   public static PrimitivePageStatsCollector newInstance(ValueEncoderMeta meta) {
2:bc3e684:     PrimitivePageStatsCollector instance =
1:f209e8e:         new PrimitivePageStatsCollector(DataType.getDataType(meta.getType()));
1:bc3e684:     // set min max from meta
1:956833e:     DataType dataType = DataType.getDataType(meta.getType());
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:       instance.minByte = (byte) meta.getMinValue();
1:956833e:       instance.maxByte = (byte) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       instance.minShort = (short) meta.getMinValue();
1:956833e:       instance.maxShort = (short) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       instance.minInt = (int) meta.getMinValue();
1:956833e:       instance.maxInt = (int) meta.getMaxValue();
1:438b442:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG
1:438b442:         || dataType == DataTypes.TIMESTAMP) {
1:956833e:       instance.minLong = (long) meta.getMinValue();
1:956833e:       instance.maxLong = (long) meta.getMaxValue();
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       instance.minDouble = (double) meta.getMinValue();
1:956833e:       instance.maxDouble = (double) meta.getMaxValue();
1:956833e:       instance.decimal = meta.getDecimal();
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       instance.minDecimal = (BigDecimal) meta.getMinValue();
1:956833e:       instance.maxDecimal = (BigDecimal) meta.getMaxValue();
1:956833e:       instance.decimal = meta.getDecimal();
1:956833e:     } else {
1:956833e:       throw new UnsupportedOperationException(
1:956833e:           "unsupported data type for Stats collection: " + meta.getType());
1:bc3e684:     }
1:bc3e684:     return instance;
1:bc3e684:   }
1:bc3e684: 
1:f209e8e:   private PrimitivePageStatsCollector(DataType dataType) {
1:bc3e684:     this.dataType = dataType;
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       minByte = TRUE_VALUE;
1:6abdd97:       maxByte = FALSE_VALUE;
1:6abdd97:     } else if (dataType == DataTypes.BYTE) {
1:956833e:       minByte = Byte.MAX_VALUE;
1:956833e:       maxByte = Byte.MIN_VALUE;
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       minShort = Short.MAX_VALUE;
1:956833e:       maxShort = Short.MIN_VALUE;
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       minInt = Integer.MAX_VALUE;
1:956833e:       maxInt = Integer.MIN_VALUE;
1:438b442:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG
1:438b442:         || dataType == DataTypes.TIMESTAMP) {
1:956833e:       minLong = Long.MAX_VALUE;
1:956833e:       maxLong = Long.MIN_VALUE;
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       minDouble = Double.POSITIVE_INFINITY;
1:956833e:       maxDouble = Double.NEGATIVE_INFINITY;
1:956833e:       decimal = 0;
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       this.zeroDecimal = BigDecimal.ZERO;
1:f209e8e:       decimal = 0;
1:956833e:     } else {
1:956833e:       throw new UnsupportedOperationException(
1:956833e:           "unsupported data type for Stats collection: " + dataType);
1:bc3e684:     }
1:bc3e684:   }
1:bc3e684: 
1:956833e:   @Override
1:bc3e684:   public void updateNull(int rowId) {
1:bc3e684:     long value = 0;
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:       update((byte) value);
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       update((short) value);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       update((int) value);
1:438b442:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:956833e:       update(value);
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       update(0d);
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       if (isFirst) {
1:956833e:         maxDecimal = zeroDecimal;
1:956833e:         minDecimal = zeroDecimal;
1:956833e:         isFirst = false;
1:956833e:       } else {
1:956833e:         maxDecimal = (maxDecimal.compareTo(zeroDecimal) > 0) ? maxDecimal : zeroDecimal;
1:956833e:         minDecimal = (minDecimal.compareTo(zeroDecimal) < 0) ? minDecimal : zeroDecimal;
1:956833e:       }
1:956833e:     } else {
1:956833e:       throw new UnsupportedOperationException(
1:956833e:           "unsupported data type for Stats collection: " + dataType);
1:4e83509:     }
1:bc3e684:   }
1:bc3e684: 
1:956833e:   @Override
1:bc3e684:   public void update(byte value) {
1:bc3e684:     if (minByte > value) {
1:bc3e684:       minByte = value;
1:bc3e684:     }
1:bc3e684:     if (maxByte < value) {
1:bc3e684:       maxByte = value;
1:bc3e684:     }
1:bc3e684:   }
1:bc3e684: 
4:bc3e684:   @Override
1:bc3e684:   public void update(short value) {
1:bc3e684:     if (minShort > value) {
1:bc3e684:       minShort = value;
1:bc3e684:     }
1:bc3e684:     if (maxShort < value) {
1:bc3e684:       maxShort = value;
1:bc3e684:     }
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public void update(int value) {
1:bc3e684:     if (minInt > value) {
1:bc3e684:       minInt = value;
1:bc3e684:     }
1:bc3e684:     if (maxInt < value) {
1:bc3e684:       maxInt = value;
1:bc3e684:     }
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public void update(long value) {
1:bc3e684:     if (minLong > value) {
1:bc3e684:       minLong = value;
1:bc3e684:     }
1:bc3e684:     if (maxLong < value) {
1:bc3e684:       maxLong = value;
1:bc3e684:     }
1:bc3e684:   }
1:bc3e684: 
1:4f7487d:   /**
1:4f7487d:    * Return number of digit after decimal point
1:4f7487d:    * TODO: it operation is costly, optimize for performance
1:4f7487d:    */
1:4f7487d:   private int getDecimalCount(double value) {
1:4f7487d:     int decimalPlaces = 0;
1:de0f545:     try {
1:de0f545:       String strValue = BigDecimal.valueOf(Math.abs(value)).toPlainString();
1:de0f545:       int integerPlaces = strValue.indexOf('.');
1:de0f545:       if (-1 != integerPlaces) {
1:de0f545:         decimalPlaces = strValue.length() - integerPlaces - 1;
1:de0f545:       }
1:de0f545:     } catch (NumberFormatException e) {
1:de0f545:       if (!Double.isInfinite(value)) {
1:de0f545:         throw e;
1:de0f545:       }
1:4f7487d:     }
1:4f7487d:     return decimalPlaces;
1:4f7487d:   }
1:4f7487d: 
1:bc3e684:   @Override
1:bc3e684:   public void update(double value) {
1:bc3e684:     if (minDouble > value) {
1:bc3e684:       minDouble = value;
1:bc3e684:     }
1:bc3e684:     if (maxDouble < value) {
1:bc3e684:       maxDouble = value;
1:bc3e684:     }
1:4f7487d:     if (decimal >= 0) {
1:4f7487d:       int decimalCount = getDecimalCount(value);
1:438b442:       decimalCountForComplexPrimitive = decimalCount;
1:4f7487d:       if (decimalCount > 5) {
1:4f7487d:         // If deciaml count is too big, we do not do adaptive encoding.
1:4f7487d:         // So set decimal to negative value
1:4f7487d:         decimal = -1;
1:4f7487d:       } else if (decimalCount > decimal) {
1:4f7487d:         this.decimal = decimalCount;
1:4f7487d:       }
1:4f7487d:     }
1:bc3e684:   }
1:bc3e684: 
1:438b442:   public int getDecimalForComplexPrimitive() {
1:438b442:     decimal = decimalCountForComplexPrimitive;
1:438b442:     return decimalCountForComplexPrimitive;
1:438b442:   }
1:438b442: 
1:bc3e684:   @Override
1:4e83509:   public void update(BigDecimal decimalValue) {
1:4e83509:     if (isFirst) {
1:4e83509:       maxDecimal = decimalValue;
1:4e83509:       minDecimal = decimalValue;
1:4e83509:       isFirst = false;
1:4e83509:     } else {
1:4e83509:       maxDecimal = (decimalValue.compareTo(maxDecimal) > 0) ? decimalValue : maxDecimal;
1:d2e70a4:       minDecimal = (decimalValue.compareTo(minDecimal) < 0) ? decimalValue : minDecimal;
1:4e83509:     }
1:4e83509:   }
1:4e83509: 
1:4e83509:   @Override
1:bc3e684:   public void update(byte[] value) {
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:e6a4f64:   public SimpleStatsResult getPageStats() {
1:bc3e684:     return this;
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public String toString() {
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       return String.format("min: %s, max: %s ", BooleanConvert.byte2Boolean(minByte),
1:6abdd97:               BooleanConvert.byte2Boolean(minByte));
1:6abdd97:     } else if (dataType == DataTypes.BYTE) {
1:956833e:       return String.format("min: %s, max: %s, decimal: %s ", minByte, maxByte, decimal);
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return String.format("min: %s, max: %s, decimal: %s ", minShort, maxShort, decimal);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return String.format("min: %s, max: %s, decimal: %s ", minInt, maxInt, decimal);
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       return String.format("min: %s, max: %s, decimal: %s ", minLong, maxLong, decimal);
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       return String.format("min: %s, max: %s, decimal: %s ", minDouble, maxDouble, decimal);
1:bc3e684:     }
1:bc3e684:     return super.toString();
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public Object getMin() {
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:       return minByte;
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return minShort;
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return minInt;
1:438b442:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:956833e:       return minLong;
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       return minDouble;
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       return minDecimal;
1:bc3e684:     }
1:bc3e684:     return null;
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public Object getMax() {
1:6abdd97:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
1:956833e:       return maxByte;
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return maxShort;
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return maxInt;
1:438b442:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
1:956833e:       return maxLong;
1:956833e:     } else if (dataType == DataTypes.DOUBLE) {
1:956833e:       return maxDouble;
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       return maxDecimal;
1:bc3e684:     }
1:bc3e684:     return null;
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:4f7487d:   public int getDecimalCount() {
1:bc3e684:     return decimal;
1:bc3e684:   }
1:bc3e684: 
1:bc3e684:   @Override
1:bc3e684:   public DataType getDataType() {
1:bc3e684:     return dataType;
1:7422690:   }
1:7422690: 
1:bc3e684: }
============================================================================
author:ravipesala
-------------------------------------------------------------------------------
commit:de0f545
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       String strValue = BigDecimal.valueOf(Math.abs(value)).toPlainString();
1:       int integerPlaces = strValue.indexOf('.');
1:       if (-1 != integerPlaces) {
1:         decimalPlaces = strValue.length() - integerPlaces - 1;
1:       }
1:     } catch (NumberFormatException e) {
1:       if (!Double.isInfinite(value)) {
1:         throw e;
1:       }
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:438b442
/////////////////////////////////////////////////////////////////////////
1:   // scale of the double value, only for complex primitive.
1:   private int decimalCountForComplexPrimitive;
1: 
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG
1:         || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG
1:         || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:       decimalCountForComplexPrimitive = decimalCount;
/////////////////////////////////////////////////////////////////////////
1:   public int getDecimalForComplexPrimitive() {
1:     decimal = decimalCountForComplexPrimitive;
1:     return decimalCountForComplexPrimitive;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (dataType == DataTypes.LONG || dataType == DataTypes.TIMESTAMP) {
author:Jacky Li
-------------------------------------------------------------------------------
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public static PrimitivePageStatsCollector newInstance(DataType dataType) {
1:     return new PrimitivePageStatsCollector(dataType);
1:     PrimitivePageStatsCollector instance =
1:         new PrimitivePageStatsCollector(meta.getSchemaDataType());
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:         new PrimitivePageStatsCollector(DataType.getDataType(meta.getType()));
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:   private PrimitivePageStatsCollector(DataType dataType) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
1:       decimal = 0;
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:     return new PrimitivePageStatsCollector(dataType, scale, precision);
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = meta.getSchemaDataType();
0:     if (dataType == DataTypes.BYTE) {
1:       instance.minByte = (byte) meta.getMinValue();
1:       instance.maxByte = (byte) meta.getMaxValue();
1:     } else if (dataType == DataTypes.SHORT) {
1:       instance.minShort = (short) meta.getMinValue();
1:       instance.maxShort = (short) meta.getMaxValue();
1:     } else if (dataType == DataTypes.INT) {
1:       instance.minInt = (int) meta.getMinValue();
1:       instance.maxInt = (int) meta.getMaxValue();
1:     } else if (dataType == DataTypes.LONG) {
1:       instance.minLong = (long) meta.getMinValue();
1:       instance.maxLong = (long) meta.getMaxValue();
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       instance.minDouble = (double) meta.getMinValue();
1:       instance.maxDouble = (double) meta.getMaxValue();
1:       instance.decimal = meta.getDecimal();
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       instance.minDecimal = (BigDecimal) meta.getMinValue();
1:       instance.maxDecimal = (BigDecimal) meta.getMaxValue();
1:       instance.decimal = meta.getDecimal();
0:       instance.scale = meta.getScale();
0:       instance.precision = meta.getPrecision();
1:     } else {
1:       throw new UnsupportedOperationException(
1:           "unsupported data type for stats collection: " + meta.getSchemaDataType());
/////////////////////////////////////////////////////////////////////////
1:     DataType dataType = DataType.getDataType(meta.getType());
0:     if (dataType == DataTypes.BYTE) {
1:       instance.minByte = (byte) meta.getMinValue();
1:       instance.maxByte = (byte) meta.getMaxValue();
1:     } else if (dataType == DataTypes.SHORT) {
1:       instance.minShort = (short) meta.getMinValue();
1:       instance.maxShort = (short) meta.getMaxValue();
1:     } else if (dataType == DataTypes.INT) {
1:       instance.minInt = (int) meta.getMinValue();
1:       instance.maxInt = (int) meta.getMaxValue();
0:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG) {
1:       instance.minLong = (long) meta.getMinValue();
1:       instance.maxLong = (long) meta.getMaxValue();
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       instance.minDouble = (double) meta.getMinValue();
1:       instance.maxDouble = (double) meta.getMaxValue();
1:       instance.decimal = meta.getDecimal();
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       instance.minDecimal = (BigDecimal) meta.getMinValue();
1:       instance.maxDecimal = (BigDecimal) meta.getMaxValue();
1:       instance.decimal = meta.getDecimal();
0:       instance.scale = -1;
0:       instance.precision = -1;
1:     } else {
1:       throw new UnsupportedOperationException(
1:           "unsupported data type for Stats collection: " + meta.getType());
0:     if (dataType == DataTypes.BYTE) {
1:       minByte = Byte.MAX_VALUE;
1:       maxByte = Byte.MIN_VALUE;
1:     } else if (dataType == DataTypes.SHORT) {
1:       minShort = Short.MAX_VALUE;
1:       maxShort = Short.MIN_VALUE;
1:     } else if (dataType == DataTypes.INT) {
1:       minInt = Integer.MAX_VALUE;
1:       maxInt = Integer.MIN_VALUE;
0:     } else if (dataType == DataTypes.LEGACY_LONG || dataType == DataTypes.LONG) {
1:       minLong = Long.MAX_VALUE;
1:       maxLong = Long.MIN_VALUE;
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       minDouble = Double.POSITIVE_INFINITY;
1:       maxDouble = Double.NEGATIVE_INFINITY;
1:       decimal = 0;
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       this.zeroDecimal = BigDecimal.ZERO;
0:       decimal = scale;
0:       this.scale = scale;
0:       this.precision = precision;
1:     } else {
1:       throw new UnsupportedOperationException(
1:           "unsupported data type for Stats collection: " + dataType);
0:     if (dataType == DataTypes.BYTE) {
1:       update((byte) value);
1:     } else if (dataType == DataTypes.SHORT) {
1:       update((short) value);
1:     } else if (dataType == DataTypes.INT) {
1:       update((int) value);
0:     } else if (dataType == DataTypes.LONG) {
1:       update(value);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       update(0d);
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       if (isFirst) {
1:         maxDecimal = zeroDecimal;
1:         minDecimal = zeroDecimal;
1:         isFirst = false;
1:       } else {
1:         maxDecimal = (maxDecimal.compareTo(zeroDecimal) > 0) ? maxDecimal : zeroDecimal;
1:         minDecimal = (minDecimal.compareTo(zeroDecimal) < 0) ? minDecimal : zeroDecimal;
1:       }
1:     } else {
1:       throw new UnsupportedOperationException(
1:           "unsupported data type for Stats collection: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BYTE) {
1:       return String.format("min: %s, max: %s, decimal: %s ", minByte, maxByte, decimal);
1:     } else if (dataType == DataTypes.SHORT) {
1:       return String.format("min: %s, max: %s, decimal: %s ", minShort, maxShort, decimal);
1:     } else if (dataType == DataTypes.INT) {
1:       return String.format("min: %s, max: %s, decimal: %s ", minInt, maxInt, decimal);
0:     } else if (dataType == DataTypes.LONG) {
1:       return String.format("min: %s, max: %s, decimal: %s ", minLong, maxLong, decimal);
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       return String.format("min: %s, max: %s, decimal: %s ", minDouble, maxDouble, decimal);
0:     if (dataType == DataTypes.BYTE) {
1:       return minByte;
1:     } else if (dataType == DataTypes.SHORT) {
1:       return minShort;
1:     } else if (dataType == DataTypes.INT) {
1:       return minInt;
0:     } else if (dataType == DataTypes.LONG) {
1:       return minLong;
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       return minDouble;
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       return minDecimal;
0:     if (dataType == DataTypes.BYTE) {
1:       return maxByte;
1:     } else if (dataType == DataTypes.SHORT) {
1:       return maxShort;
1:     } else if (dataType == DataTypes.INT) {
1:       return maxInt;
0:     } else if (dataType == DataTypes.LONG) {
1:       return maxLong;
1:     } else if (dataType == DataTypes.DOUBLE) {
1:       return maxDouble;
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       return maxDecimal;
/////////////////////////////////////////////////////////////////////////
1:   @Override
0:   public int getScale() {
1:   @Override
0:   public int getPrecision() {
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
0:     PrimitivePageStatsCollector instance = new PrimitivePageStatsCollector(meta.getSchemaDataType(),
0:         meta.getScale(), meta.getPrecision());
0:     switch (meta.getSchemaDataType()) {
/////////////////////////////////////////////////////////////////////////
0:             "unsupported data type for stats collection: " + meta.getSchemaDataType());
commit:4f7487d
/////////////////////////////////////////////////////////////////////////
1:   // scale of the double value, apply adaptive encoding if this is positive
/////////////////////////////////////////////////////////////////////////
0:         minDouble = Double.POSITIVE_INFINITY;
0:         maxDouble = Double.NEGATIVE_INFINITY;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Return number of digit after decimal point
1:    * TODO: it operation is costly, optimize for performance
1:    */
1:   private int getDecimalCount(double value) {
0:     String strValue = BigDecimal.valueOf(Math.abs(value)).toPlainString();
0:     int integerPlaces = strValue.indexOf('.');
1:     int decimalPlaces = 0;
0:     if (-1 != integerPlaces) {
0:       decimalPlaces = strValue.length() - integerPlaces - 1;
1:     }
1:     return decimalPlaces;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     if (decimal >= 0) {
1:       int decimalCount = getDecimalCount(value);
1:       if (decimalCount > 5) {
1:         // If deciaml count is too big, we do not do adaptive encoding.
1:         // So set decimal to negative value
1:         decimal = -1;
1:       } else if (decimalCount > decimal) {
1:         this.decimal = decimalCount;
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
1:   public int getDecimalCount() {
commit:e6a4f64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.ColumnPageEncoderMeta;
/////////////////////////////////////////////////////////////////////////
0:   public static PrimitivePageStatsCollector newInstance(DataType dataType,
0:       int scale, int precision) {
0:         return new PrimitivePageStatsCollector(dataType, scale, precision);
1:   // this is for decode flow, create stats from encoder meta in carbondata file
1:   public static PrimitivePageStatsCollector newInstance(ColumnPageEncoderMeta meta) {
0:         new PrimitivePageStatsCollector(meta.getDataType(), meta.getScale(), meta.getPrecision());
0:     switch (meta.getDataType()) {
/////////////////////////////////////////////////////////////////////////
0:             "unsupported data type for stats collection: " + meta.getDataType());
0:         new PrimitivePageStatsCollector(meta.getType(), -1, -1);
/////////////////////////////////////////////////////////////////////////
0:   private PrimitivePageStatsCollector(DataType dataType, int scale, int precision) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   public SimpleStatsResult getPageStats() {
/////////////////////////////////////////////////////////////////////////
author:xubo245
-------------------------------------------------------------------------------
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
1: import static org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert.FALSE_VALUE;
1: import static org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert.TRUE_VALUE;
1: 
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
1:       minByte = TRUE_VALUE;
1:       maxByte = FALSE_VALUE;
1:     } else if (dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
1:       return String.format("min: %s, max: %s ", BooleanConvert.byte2Boolean(minByte),
1:               BooleanConvert.byte2Boolean(minByte));
1:     } else if (dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN || dataType == DataTypes.BYTE) {
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:133b303
/////////////////////////////////////////////////////////////////////////
0:         new PrimitivePageStatsCollector(DataType.getDataType(meta.getType()), -1, -1);
0:     switch (DataType.getDataType(meta.getType())) {
/////////////////////////////////////////////////////////////////////////
0:       case LEGACY_LONG:
/////////////////////////////////////////////////////////////////////////
0:       case LEGACY_LONG:
commit:d2e70a4
/////////////////////////////////////////////////////////////////////////
1:       minDecimal = (decimalValue.compareTo(minDecimal) < 0) ? decimalValue : minDecimal;
commit:4e83509
/////////////////////////////////////////////////////////////////////////
1:   private BigDecimal minDecimal, maxDecimal;
/////////////////////////////////////////////////////////////////////////
1:   private boolean isFirst = true;
1:   private BigDecimal zeroDecimal;
1: 
/////////////////////////////////////////////////////////////////////////
0:         instance.minDecimal = (BigDecimal) meta.getMinValue();
0:         instance.maxDecimal = (BigDecimal) meta.getMaxValue();
/////////////////////////////////////////////////////////////////////////
0:         new PrimitivePageStatsCollector(meta.getType(), 0, -1, -1);
/////////////////////////////////////////////////////////////////////////
0:         instance.minDecimal = (BigDecimal) meta.getMinValue();
0:         instance.maxDecimal = (BigDecimal) meta.getMaxValue();
0:         instance.scale = -1;
0:         instance.precision = -1;
/////////////////////////////////////////////////////////////////////////
0:         this.zeroDecimal = BigDecimal.ZERO;
/////////////////////////////////////////////////////////////////////////
0:       case DECIMAL:
1:         if (isFirst) {
0:           maxDecimal = zeroDecimal;
0:           minDecimal = zeroDecimal;
1:           isFirst = false;
1:         } else {
0:           maxDecimal = (maxDecimal.compareTo(zeroDecimal) > 0) ? maxDecimal : zeroDecimal;
0:           minDecimal = (minDecimal.compareTo(zeroDecimal) < 0) ? minDecimal : zeroDecimal;
1:         }
0:         break;
/////////////////////////////////////////////////////////////////////////
1:   public void update(BigDecimal decimalValue) {
0:     if (isFirst) {
1:       maxDecimal = decimalValue;
1:       minDecimal = decimalValue;
0:       isFirst = false;
0:     } else {
1:       maxDecimal = (decimalValue.compareTo(maxDecimal) > 0) ? decimalValue : maxDecimal;
0:       minDecimal = (decimalValue.compareTo(maxDecimal) < 0) ? decimalValue : minDecimal;
1:     }
1:   }
1: 
1:   @Override
/////////////////////////////////////////////////////////////////////////
0:         return minDecimal;
/////////////////////////////////////////////////////////////////////////
0:         return maxDecimal;
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:       default:
0:         throw new UnsupportedOperationException(
0:             "unsupported data type for stats collection: " + meta.getSrcDataType());
/////////////////////////////////////////////////////////////////////////
0:       default:
0:         throw new UnsupportedOperationException(
0:             "unsupported data type for Stats collection: " + meta.getType());
/////////////////////////////////////////////////////////////////////////
0:         break;
0:       default:
0:         throw new UnsupportedOperationException(
0:             "unsupported data type for Stats collection: " + dataType);
/////////////////////////////////////////////////////////////////////////
0:       default:
0:         throw new UnsupportedOperationException(
0:             "unsupported data type for Stats collection: " + dataType);
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7422690
/////////////////////////////////////////////////////////////////////////
0:   private int scale, precision;
/////////////////////////////////////////////////////////////////////////
0:   public static PrimitivePageStatsCollector newInstance(DataType dataType, int pageSize, int
0:       scale, int precision) {
0:         return new PrimitivePageStatsCollector(dataType, pageSize, scale, precision);
0:         new PrimitivePageStatsCollector(meta.getSrcDataType(), 0, meta.getScale(),
0:             meta.getPrecision());
/////////////////////////////////////////////////////////////////////////
0:       case DECIMAL:
0:         instance.minLong = (long) meta.getMinValue();
0:         instance.maxLong = (long) meta.getMaxValue();
0:         instance.decimal = meta.getDecimal();
0:         instance.scale = meta.getScale();
0:         instance.precision = meta.getPrecision();
0:         break;
0:         new PrimitivePageStatsCollector(meta.getType(), 0, meta.getScale(), meta.getPrecision());
/////////////////////////////////////////////////////////////////////////
0:       case DECIMAL:
0:         instance.minDouble = (double) meta.getMinValue();
0:         instance.maxDouble = (double) meta.getMaxValue();
0:         instance.decimal = meta.getDecimal();
0:         instance.scale = meta.getScale();
0:         instance.precision = meta.getPrecision();
0:         break;
0:   private PrimitivePageStatsCollector(DataType dataType, int pageSize, int scale, int precision) {
/////////////////////////////////////////////////////////////////////////
0:         minLong = Long.MAX_VALUE;
0:         maxLong = Long.MIN_VALUE;
0:         decimal = scale;
0:         this.scale = scale;
0:         this.precision = precision;
/////////////////////////////////////////////////////////////////////////
0:       case DECIMAL:
0:         return minLong;
/////////////////////////////////////////////////////////////////////////
0:       case DECIMAL:
0:         return maxLong;
/////////////////////////////////////////////////////////////////////////
0:   @Override public int getScale() {
0:     return scale;
1:   }
1: 
0:   @Override public int getPrecision() {
0:     return precision;
1:   }
1: 
author:jackylk
-------------------------------------------------------------------------------
commit:bc3e684
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.carbondata.core.datastore.page.statistics;
1: 
1: import java.math.BigDecimal;
0: import java.util.BitSet;
1: 
0: import org.apache.carbondata.core.metadata.ColumnPageCodecMeta;
1: import org.apache.carbondata.core.metadata.ValueEncoderMeta;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: 
1: /** statics for primitive column page */
1: public class PrimitivePageStatsCollector implements ColumnPageStatsCollector, SimpleStatsResult {
1:   private DataType dataType;
1:   private byte minByte, maxByte;
1:   private short minShort, maxShort;
1:   private int minInt, maxInt;
1:   private long minLong, maxLong;
1:   private double minDouble, maxDouble;
1: 
0:   // scale of the double value
1:   private int decimal;
1: 
0:   // The index of the rowId whose value is null, will be set to 1
0:   private BitSet nullBitSet;
1: 
1:   // this is for encode flow
0:   public static PrimitivePageStatsCollector newInstance(DataType dataType, int pageSize) {
0:     switch (dataType) {
0:       default:
0:         return new PrimitivePageStatsCollector(dataType, pageSize);
1:     }
1:   }
1: 
0:   // this is for decode flow, we do not need to create nullBits, so passing 0 as pageSize
0:   public static PrimitivePageStatsCollector newInstance(ColumnPageCodecMeta meta) {
1:     PrimitivePageStatsCollector instance =
0:         new PrimitivePageStatsCollector(meta.getSrcDataType(), 0);
1:     // set min max from meta
0:     switch (meta.getSrcDataType()) {
0:       case BYTE:
0:         instance.minByte = (byte) meta.getMinValue();
0:         instance.maxByte = (byte) meta.getMaxValue();
0:         break;
0:       case SHORT:
0:         instance.minShort = (short) meta.getMinValue();
0:         instance.maxShort = (short) meta.getMaxValue();
0:         break;
0:       case INT:
0:         instance.minInt = (int) meta.getMinValue();
0:         instance.maxInt = (int) meta.getMaxValue();
0:         break;
0:       case LONG:
0:         instance.minLong = (long) meta.getMinValue();
0:         instance.maxLong = (long) meta.getMaxValue();
0:         break;
0:       case DOUBLE:
0:         instance.minDouble = (double) meta.getMinValue();
0:         instance.maxDouble = (double) meta.getMaxValue();
0:         instance.decimal = meta.getDecimal();
0:         break;
1:     }
1:     return instance;
1:   }
1: 
1:   public static PrimitivePageStatsCollector newInstance(ValueEncoderMeta meta) {
1:     PrimitivePageStatsCollector instance =
0:         new PrimitivePageStatsCollector(meta.getType(), 0);
1:     // set min max from meta
0:     switch (meta.getType()) {
0:       case BYTE:
0:         instance.minByte = (byte) meta.getMinValue();
0:         instance.maxByte = (byte) meta.getMaxValue();
0:         break;
0:       case SHORT:
0:         instance.minShort = (short) meta.getMinValue();
0:         instance.maxShort = (short) meta.getMaxValue();
0:         break;
0:       case INT:
0:         instance.minInt = (int) meta.getMinValue();
0:         instance.maxInt = (int) meta.getMaxValue();
0:         break;
0:       case LONG:
0:         instance.minLong = (long) meta.getMinValue();
0:         instance.maxLong = (long) meta.getMaxValue();
0:         break;
0:       case DOUBLE:
0:         instance.minDouble = (double) meta.getMinValue();
0:         instance.maxDouble = (double) meta.getMaxValue();
0:         instance.decimal = meta.getDecimal();
0:         break;
1:     }
1:     return instance;
1:   }
1: 
0:   private PrimitivePageStatsCollector(DataType dataType, int pageSize) {
1:     this.dataType = dataType;
0:     this.nullBitSet = new BitSet(pageSize);
0:     switch (dataType) {
0:       case BYTE:
0:         minByte = Byte.MAX_VALUE;
0:         maxByte = Byte.MIN_VALUE;
0:         break;
0:       case SHORT:
0:         minShort = Short.MAX_VALUE;
0:         maxShort = Short.MIN_VALUE;
0:         break;
0:       case INT:
0:         minInt = Integer.MAX_VALUE;
0:         maxInt = Integer.MIN_VALUE;
0:         break;
0:       case LONG:
0:         minLong = Long.MAX_VALUE;
0:         maxLong = Long.MIN_VALUE;
0:         break;
0:       case DOUBLE:
0:         minDouble = Double.MAX_VALUE;
0:         maxDouble = Double.MIN_VALUE;
0:         decimal = 0;
0:         break;
0:       case DECIMAL:
1:     }
1:   }
1: 
1:   @Override
1:   public void updateNull(int rowId) {
0:     nullBitSet.set(rowId);
1:     long value = 0;
0:     switch (dataType) {
0:       case BYTE:
0:         update((byte) value);
0:         break;
0:       case SHORT:
0:         update((short) value);
0:         break;
0:       case INT:
0:         update((int) value);
0:         break;
0:       case LONG:
0:         update(value);
0:         break;
0:       case DOUBLE:
0:         update(0d);
0:         break;
1:     }
1:   }
1: 
1:   @Override
1:   public void update(byte value) {
1:     if (minByte > value) {
1:       minByte = value;
1:     }
1:     if (maxByte < value) {
1:       maxByte = value;
1:     }
1:   }
1: 
1:   @Override
1:   public void update(short value) {
1:     if (minShort > value) {
1:       minShort = value;
1:     }
1:     if (maxShort < value) {
1:       maxShort = value;
1:     }
1:   }
1: 
1:   @Override
1:   public void update(int value) {
1:     if (minInt > value) {
1:       minInt = value;
1:     }
1:     if (maxInt < value) {
1:       maxInt = value;
1:     }
1:   }
1: 
1:   @Override
1:   public void update(long value) {
1:     if (minLong > value) {
1:       minLong = value;
1:     }
1:     if (maxLong < value) {
1:       maxLong = value;
1:     }
1:   }
1: 
1:   @Override
1:   public void update(double value) {
1:     if (minDouble > value) {
1:       minDouble = value;
1:     }
1:     if (maxDouble < value) {
1:       maxDouble = value;
1:     }
0:     int scale = BigDecimal.valueOf(value).scale();
0:     if (scale < 0) {
0:       decimal = scale;
0:     } else {
0:       decimal = Math.max(decimal, scale);
1:     }
1:   }
1: 
1:   @Override
1:   public void update(byte[] value) {
1:   }
1: 
1:   @Override
0:   public Object getPageStats() {
1:     return this;
1:   }
1: 
1:   @Override
1:   public String toString() {
0:     switch (dataType) {
0:       case BYTE:
0:         return String.format("min: %s, max: %s, decimal: %s ", minByte, maxByte, decimal);
0:       case SHORT:
0:         return String.format("min: %s, max: %s, decimal: %s ", minShort, maxShort, decimal);
0:       case INT:
0:         return String.format("min: %s, max: %s, decimal: %s ", minInt, maxInt, decimal);
0:       case LONG:
0:         return String.format("min: %s, max: %s, decimal: %s ", minLong, maxLong, decimal);
0:       case DOUBLE:
0:         return String.format("min: %s, max: %s, decimal: %s ", minDouble, maxDouble, decimal);
1:     }
1:     return super.toString();
1:   }
1: 
1:   @Override
1:   public Object getMin() {
0:     switch (dataType) {
0:       case BYTE:
0:         return minByte;
0:       case SHORT:
0:         return minShort;
0:       case INT:
0:         return minInt;
0:       case LONG:
0:         return minLong;
0:       case DOUBLE:
0:         return minDouble;
1:     }
1:     return null;
1:   }
1: 
1:   @Override
1:   public Object getMax() {
0:     switch (dataType) {
0:       case BYTE:
0:         return maxByte;
0:       case SHORT:
0:         return maxShort;
0:       case INT:
0:         return maxInt;
0:       case LONG:
0:         return maxLong;
0:       case DOUBLE:
0:         return maxDouble;
1:     }
1:     return null;
1:   }
1: 
1:   @Override
0:   public BitSet getNullBits() {
0:     return nullBitSet;
1:   }
1: 
1:   @Override
0:   public int getDecimalPoint() {
1:     return decimal;
1:   }
1: 
1:   @Override
1:   public DataType getDataType() {
1:     return dataType;
1:   }
1: 
1: }
============================================================================