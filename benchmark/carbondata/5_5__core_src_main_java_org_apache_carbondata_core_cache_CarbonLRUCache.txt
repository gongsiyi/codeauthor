1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
3:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
4:cd6a4ff:  */
4:cd6a4ff: 
1:cd6a4ff: package org.apache.carbondata.core.cache;
1:cd6a4ff: 
1:cd6a4ff: import java.util.ArrayList;
1:cd6a4ff: import java.util.LinkedHashMap;
1:cd6a4ff: import java.util.List;
1:cd6a4ff: import java.util.Map;
1:cd6a4ff: import java.util.Map.Entry;
1:cd6a4ff: 
1:cd6a4ff: import org.apache.carbondata.common.logging.LogService;
1:cd6a4ff: import org.apache.carbondata.common.logging.LogServiceFactory;
1:cd6a4ff: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:cd6a4ff: import org.apache.carbondata.core.util.CarbonProperties;
1:cd6a4ff: 
4:cd6a4ff: /**
1:cd6a4ff:  * class which manages the lru cache
1:cd6a4ff:  */
1:cd6a4ff: public final class CarbonLRUCache {
1:cd6a4ff:   /**
1:cd6a4ff:    * constant for converting MB into bytes
1:cd6a4ff:    */
1:cd6a4ff:   private static final int BYTE_CONVERSION_CONSTANT = 1024 * 1024;
1:cd6a4ff:   /**
1:cd6a4ff:    * Attribute for Carbon LOGGER
1:cd6a4ff:    */
1:cd6a4ff:   private static final LogService LOGGER =
1:cd6a4ff:       LogServiceFactory.getLogService(CarbonLRUCache.class.getName());
1:cd6a4ff:   /**
1:cd6a4ff:    * Map that will contain key as table unique name and value as cache Holder
1:cd6a4ff:    * object
1:cd6a4ff:    */
1:cd6a4ff:   private Map<String, Cacheable> lruCacheMap;
1:cd6a4ff:   /**
1:cd6a4ff:    * lruCacheSize
1:cd6a4ff:    */
1:cd6a4ff:   private long lruCacheMemorySize;
1:cd6a4ff:   /**
1:cd6a4ff:    * totalSize size of the cache
1:cd6a4ff:    */
1:cd6a4ff:   private long currentSize;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * @param propertyName        property name to take the size configured
1:cd6a4ff:    * @param defaultPropertyName default property in case size is not configured
1:cd6a4ff:    */
1:cd6a4ff:   public CarbonLRUCache(String propertyName, String defaultPropertyName) {
1:cd6a4ff:     try {
1:cd6a4ff:       lruCacheMemorySize = Integer
1:cd6a4ff:           .parseInt(CarbonProperties.getInstance().getProperty(propertyName, defaultPropertyName));
1:cd6a4ff:     } catch (NumberFormatException e) {
1:cd6a4ff:       lruCacheMemorySize = Integer.parseInt(defaultPropertyName);
18:cd6a4ff:     }
1:cd6a4ff:     initCache();
2:cd6a4ff:     if (lruCacheMemorySize > 0) {
1:b6ab4ef:       LOGGER.info("Configured LRU cache size is " + lruCacheMemorySize + " MB");
1:cd6a4ff:       // convert in bytes
1:cd6a4ff:       lruCacheMemorySize = lruCacheMemorySize * BYTE_CONVERSION_CONSTANT;
1:b6ab4ef:     } else {
1:b6ab4ef:       LOGGER.info("LRU cache size not configured. Therefore default behavior will be "
1:cd6a4ff:               + "considered and no LRU based eviction of columns will be done");
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * initialize lru cache
1:cd6a4ff:    */
1:cd6a4ff:   private void initCache() {
1:cd6a4ff:     lruCacheMap =
1:cd6a4ff:         new LinkedHashMap<String, Cacheable>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE, 1.0f,
1:cd6a4ff:             true);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will give the list of all the keys that can be deleted from
1:cd6a4ff:    * the level LRU cache
1:cd6a4ff:    */
1:cd6a4ff:   private List<String> getKeysToBeRemoved(long size) {
1:cd6a4ff:     List<String> toBeDeletedKeys =
1:cd6a4ff:         new ArrayList<String>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:cd6a4ff:     long removedSize = 0;
1:cd6a4ff:     for (Entry<String, Cacheable> entry : lruCacheMap.entrySet()) {
1:cd6a4ff:       String key = entry.getKey();
1:cd6a4ff:       Cacheable cacheInfo = entry.getValue();
1:cd6a4ff:       long memorySize = cacheInfo.getMemorySize();
1:cd6a4ff:       if (canBeRemoved(cacheInfo)) {
1:cd6a4ff:         removedSize = removedSize + memorySize;
1:cd6a4ff:         toBeDeletedKeys.add(key);
1:cd6a4ff:         // check if after removing the current file size, required
1:cd6a4ff:         // size when added to current size is sufficient to load a
1:cd6a4ff:         // level or not
1:cd6a4ff:         if (lruCacheMemorySize >= (currentSize - memorySize + size)) {
1:cd6a4ff:           toBeDeletedKeys.clear();
1:cd6a4ff:           toBeDeletedKeys.add(key);
1:cd6a4ff:           removedSize = memorySize;
1:cd6a4ff:           break;
1:cd6a4ff:         }
1:cd6a4ff:         // check if after removing the added size/removed size,
1:cd6a4ff:         // required size when added to current size is sufficient to
1:cd6a4ff:         // load a level or not
1:cd6a4ff:         else if (lruCacheMemorySize >= (currentSize - removedSize + size)) {
1:cd6a4ff:           break;
1:cd6a4ff:         }
1:cd6a4ff:       }
1:cd6a4ff:     }
1:cd6a4ff:     // this case will come when iteration is complete over the keys but
1:cd6a4ff:     // still size is not sufficient for level file to be loaded, then we
1:cd6a4ff:     // will not delete any of the keys
1:cd6a4ff:     if ((currentSize - removedSize + size) > lruCacheMemorySize) {
1:cd6a4ff:       toBeDeletedKeys.clear();
1:cd6a4ff:     }
1:cd6a4ff:     return toBeDeletedKeys;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
2:cd6a4ff:    * @param cacheInfo
1:377dee9:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   private boolean canBeRemoved(Cacheable cacheInfo) {
1:cd6a4ff:     if (cacheInfo.getAccessCount() > 0) {
1:cd6a4ff:       return false;
1:cd6a4ff:     }
1:cd6a4ff:     return true;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * @param key
1:cd6a4ff:    */
1:cd6a4ff:   public void remove(String key) {
1:b6ab4ef:     synchronized (lruCacheMap) {
1:cd6a4ff:       removeKey(key);
1:b6ab4ef:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will remove the key from lru cache
1:cd6a4ff:    *
1:cd6a4ff:    * @param key
1:cd6a4ff:    */
1:cd6a4ff:   private void removeKey(String key) {
1:cd6a4ff:     Cacheable cacheable = lruCacheMap.get(key);
1:cd6a4ff:     if (null != cacheable) {
1:54dcd8d:       long memorySize = cacheable.getMemorySize();
1:54dcd8d:       cacheable.invalidate();
1:54dcd8d:       lruCacheMap.remove(key);
1:54dcd8d:       currentSize = currentSize - memorySize;
1:b6ab4ef:       LOGGER.info("Removed entry from InMemory lru cache :: " + key);
1:b6ab4ef:     }
1:b6ab4ef:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will check if required size is available in the memory and then add
1:cd6a4ff:    * the given cacheable to object to lru cache
1:cd6a4ff:    *
1:377dee9:    * @param columnIdentifier
1:b6ab4ef:    * @param cacheInfo
1:377dee9:    */
1:cd6a4ff:   public boolean put(String columnIdentifier, Cacheable cacheInfo, long requiredSize) {
1:377dee9:     if (LOGGER.isDebugEnabled()) {
1:4a79a86:       LOGGER.debug("Required size for entry " + columnIdentifier + " :: " + requiredSize
1:377dee9:           + " Current cache size :: " + currentSize);
1:377dee9:     }
1:cd6a4ff:     boolean columnKeyAddedSuccessfully = false;
1:377dee9:     if (isLRUCacheSizeConfigured()) {
1:377dee9:       synchronized (lruCacheMap) {
1:377dee9:         if (freeMemorySizeForAddingCache(requiredSize)) {
1:b6ab4ef:           currentSize = currentSize + requiredSize;
1:b6ab4ef:           addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
1:b6ab4ef:           columnKeyAddedSuccessfully = true;
1:377dee9:         } else {
1:377dee9:           LOGGER.error(
1:b6ab4ef:               "Size not available. Entry cannot be added to lru cache :: " + columnIdentifier
1:b6ab4ef:                   + " .Required Size = " + requiredSize + " Size available " + (lruCacheMemorySize
1:b6ab4ef:                   - currentSize));
1:4a79a86:         }
1:b6ab4ef:       }
1:b6ab4ef:     } else {
1:b6ab4ef:       synchronized (lruCacheMap) {
1:b6ab4ef:         addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
1:b6ab4ef:       }
1:b6ab4ef:       columnKeyAddedSuccessfully = true;
1:4a79a86:     }
1:cd6a4ff:     return columnKeyAddedSuccessfully;
1:b6ab4ef:   }
1:b6ab4ef: 
1:b6ab4ef:   /**
1:377dee9:    * This method will check if required size is available in the memory
1:377dee9:    * @param columnIdentifier
1:377dee9:    * @param requiredSize
1:377dee9:    * @return
1:377dee9:    */
1:377dee9:   public boolean tryPut(String columnIdentifier, long requiredSize) {
1:377dee9:     if (LOGGER.isDebugEnabled()) {
1:377dee9:       LOGGER.debug("checking Required size for entry " + columnIdentifier + " :: " + requiredSize
1:377dee9:           + " Current cache size :: " + currentSize);
1:377dee9:     }
1:377dee9:     boolean columnKeyCanBeAdded = false;
1:377dee9:     if (isLRUCacheSizeConfigured()) {
1:377dee9:       synchronized (lruCacheMap) {
1:377dee9:         if (freeMemorySizeForAddingCache(requiredSize)) {
1:377dee9:           columnKeyCanBeAdded = true;
1:377dee9:         } else {
1:377dee9:           LOGGER.error(
1:377dee9:               "Size check failed.Size not available. Entry cannot be added to lru cache :: "
1:377dee9:                   + columnIdentifier + " .Required Size = " + requiredSize + " Size available " + (
1:377dee9:                   lruCacheMemorySize - currentSize));
1:377dee9:         }
1:377dee9:       }
1:377dee9:     } else {
1:377dee9:       columnKeyCanBeAdded = true;
1:377dee9:     }
1:377dee9:     return columnKeyCanBeAdded;
1:377dee9:   }
1:377dee9: 
1:377dee9:   /**
1:b6ab4ef:    * The method will add the cache entry to LRU cache map
1:b6ab4ef:    *
1:b6ab4ef:    * @param columnIdentifier
1:b6ab4ef:    * @param cacheInfo
1:b6ab4ef:    */
1:b6ab4ef:   private void addEntryToLRUCacheMap(String columnIdentifier, Cacheable cacheInfo) {
1:b6ab4ef:     if (null == lruCacheMap.get(columnIdentifier)) {
1:b6ab4ef:       lruCacheMap.put(columnIdentifier, cacheInfo);
1:377dee9:     }
1:4a79a86:     if (LOGGER.isDebugEnabled()) {
1:4a79a86:       LOGGER.debug("Added entry to InMemory lru cache :: " + columnIdentifier);
1:377dee9:     }
1:377dee9:   }
1:377dee9: 
1:377dee9:   /**
1:b6ab4ef:    * this will check whether the LRU cache size is configured
1:b6ab4ef:    *
1:b6ab4ef:    * @return <Boolean> value
1:b6ab4ef:    */
1:b6ab4ef:   private boolean isLRUCacheSizeConfigured() {
1:b6ab4ef:     return lruCacheMemorySize > 0;
1:377dee9:   }
1:b6ab4ef: 
1:b6ab4ef:   /**
1:cd6a4ff:    * This method will check a required column can be loaded into memory or not. If required
1:cd6a4ff:    * this method will call for eviction of existing data from memory
1:b6ab4ef:    *
1:377dee9:    * @param requiredSize
2:cd6a4ff:    * @return
1:b6ab4ef:    */
1:cd6a4ff:   private boolean freeMemorySizeForAddingCache(long requiredSize) {
1:cd6a4ff:     boolean memoryAvailable = false;
1:b6ab4ef:     if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
1:b6ab4ef:       memoryAvailable = true;
1:377dee9:     } else {
1:b6ab4ef:       // get the keys that can be removed from memory
1:b6ab4ef:       List<String> keysToBeRemoved = getKeysToBeRemoved(requiredSize);
1:b6ab4ef:       for (String cacheKey : keysToBeRemoved) {
1:b6ab4ef:         removeKey(cacheKey);
1:4a79a86:       }
1:b6ab4ef:       // after removing the keys check again if required size is available
1:b6ab4ef:       if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
1:b6ab4ef:         memoryAvailable = true;
1:b6ab4ef:       }
1:b6ab4ef:     }
1:cd6a4ff:     return memoryAvailable;
1:4a79a86:   }
1:b6ab4ef: 
1:b6ab4ef:   /**
1:cd6a4ff:    * This method will check if size is available to laod dictionary into memory
1:b6ab4ef:    *
2:cd6a4ff:    * @param requiredSize
1:cd6a4ff:    * @return
1:b6ab4ef:    */
1:cd6a4ff:   private boolean isSizeAvailableToLoadColumnDictionary(long requiredSize) {
1:cd6a4ff:     return lruCacheMemorySize >= (currentSize + requiredSize);
1:b6ab4ef:   }
1:b6ab4ef: 
1:b6ab4ef:   /**
1:cd6a4ff:    * @param key
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public Cacheable get(String key) {
4:cd6a4ff:     synchronized (lruCacheMap) {
1:cd6a4ff:       return lruCacheMap.get(key);
1:b6ab4ef:     }
1:b6ab4ef:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will empty the level cache
1:cd6a4ff:    */
1:cd6a4ff:   public void clear() {
1:cd6a4ff:     synchronized (lruCacheMap) {
1:cd6a4ff:       lruCacheMap.clear();
1:b6ab4ef:     }
1:cd6a4ff:   }
1:cd6a4ff: }
============================================================================
author:manishgupta88
-------------------------------------------------------------------------------
commit:54dcd8d
/////////////////////////////////////////////////////////////////////////
1:       long memorySize = cacheable.getMemorySize();
1:       cacheable.invalidate();
1:       lruCacheMap.remove(key);
1:       currentSize = currentSize - memorySize;
commit:54dcd8d
/////////////////////////////////////////////////////////////////////////
0:       long memorySize = cacheable.getMemorySize();
0:       cacheable.invalidate();
0:       lruCacheMap.remove(key);
0:       currentSize = currentSize - memorySize;
author:Raghunandan S
-------------------------------------------------------------------------------
commit:377dee9
/////////////////////////////////////////////////////////////////////////
1:    * This method will check if required size is available in the memory
1:    * @param columnIdentifier
1:    * @param requiredSize
1:    * @return
1:    */
1:   public boolean tryPut(String columnIdentifier, long requiredSize) {
1:     if (LOGGER.isDebugEnabled()) {
1:       LOGGER.debug("checking Required size for entry " + columnIdentifier + " :: " + requiredSize
1:           + " Current cache size :: " + currentSize);
1:     }
1:     boolean columnKeyCanBeAdded = false;
1:     if (isLRUCacheSizeConfigured()) {
1:       synchronized (lruCacheMap) {
1:         if (freeMemorySizeForAddingCache(requiredSize)) {
1:           columnKeyCanBeAdded = true;
1:         } else {
1:           LOGGER.error(
1:               "Size check failed.Size not available. Entry cannot be added to lru cache :: "
1:                   + columnIdentifier + " .Required Size = " + requiredSize + " Size available " + (
1:                   lruCacheMemorySize - currentSize));
1:         }
1:       }
1:     } else {
1:       columnKeyCanBeAdded = true;
1:     }
1:     return columnKeyCanBeAdded;
1:   }
1: 
1:   /**
commit:377dee9
/////////////////////////////////////////////////////////////////////////
0:    * This method will check if required size is available in the memory
1:    * @param columnIdentifier
1:    * @param requiredSize
1:    * @return
1:    */
0:   public boolean tryPut(String columnIdentifier, long requiredSize) {
1:     if (LOGGER.isDebugEnabled()) {
0:       LOGGER.debug("checking Required size for entry " + columnIdentifier + " :: " + requiredSize
1:           + " Current cache size :: " + currentSize);
1:     }
0:     boolean columnKeyCanBeAdded = false;
1:     if (isLRUCacheSizeConfigured()) {
1:       synchronized (lruCacheMap) {
1:         if (freeMemorySizeForAddingCache(requiredSize)) {
0:           columnKeyCanBeAdded = true;
1:         } else {
1:           LOGGER.error(
0:               "Size check failed.Size not available. Entry cannot be added to lru cache :: "
0:                   + columnIdentifier + " .Required Size = " + requiredSize + " Size available " + (
0:                   lruCacheMemorySize - currentSize));
1:         }
1:       }
1:     } else {
0:       columnKeyCanBeAdded = true;
1:     }
0:     return columnKeyCanBeAdded;
1:   }
1: 
1:   /**
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:4a79a86
/////////////////////////////////////////////////////////////////////////
1:     if (LOGGER.isDebugEnabled()) {
1:       LOGGER.debug("Required size for entry " + columnIdentifier + " :: " + requiredSize
0:           + " Current cache size :: " + currentSize);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     if (LOGGER.isDebugEnabled()) {
1:       LOGGER.debug("Added entry to InMemory lru cache :: " + columnIdentifier);
1:     }
commit:b6ab4ef
/////////////////////////////////////////////////////////////////////////
1:       LOGGER.info("Configured LRU cache size is " + lruCacheMemorySize + " MB");
1:       LOGGER.info("LRU cache size not configured. Therefore default behavior will be "
/////////////////////////////////////////////////////////////////////////
0:     Cacheable remove = lruCacheMap.remove(key);
0:     if(null != remove) {
1:       LOGGER.info("Removed entry from InMemory lru cache :: " + key);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug("Required size for entry " + columnIdentifier + " :: " + requiredSize
0:         + " Current cache size :: " + currentSize);
0:     if (isLRUCacheSizeConfigured()) {
0:         if (freeMemorySizeForAddingCache(requiredSize)) {
1:           currentSize = currentSize + requiredSize;
1:           addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
1:           columnKeyAddedSuccessfully = true;
1:         } else {
0:           LOGGER.error(
1:               "Size not available. Entry cannot be added to lru cache :: " + columnIdentifier
1:                   + " .Required Size = " + requiredSize + " Size available " + (lruCacheMemorySize
1:                   - currentSize));
1:       synchronized (lruCacheMap) {
1:         addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
1:       }
1:       columnKeyAddedSuccessfully = true;
1:    * The method will add the cache entry to LRU cache map
1:    *
1:    * @param columnIdentifier
1:    * @param cacheInfo
1:    */
1:   private void addEntryToLRUCacheMap(String columnIdentifier, Cacheable cacheInfo) {
1:     if (null == lruCacheMap.get(columnIdentifier)) {
1:       lruCacheMap.put(columnIdentifier, cacheInfo);
1:     }
0:     LOGGER.debug("Added entry to InMemory lru cache :: " + columnIdentifier);
1:   }
1: 
1:   /**
1:    * this will check whether the LRU cache size is configured
1:    *
1:    * @return <Boolean> value
1:    */
1:   private boolean isLRUCacheSizeConfigured() {
1:     return lruCacheMemorySize > 0;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
1:       memoryAvailable = true;
1:     } else {
1:       // get the keys that can be removed from memory
1:       List<String> keysToBeRemoved = getKeysToBeRemoved(requiredSize);
1:       for (String cacheKey : keysToBeRemoved) {
1:         removeKey(cacheKey);
1:       }
1:       // after removing the keys check again if required size is available
commit:4a79a86
/////////////////////////////////////////////////////////////////////////
0:     if (LOGGER.isDebugEnabled()) {
0:       LOGGER.debug("Required size for entry " + columnIdentifier + " :: " + requiredSize
0:           + " Current cache size :: " + currentSize);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     if (LOGGER.isDebugEnabled()) {
0:       LOGGER.debug("Added entry to InMemory lru cache :: " + columnIdentifier);
1:     }
commit:b6ab4ef
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.info("Configured LRU cache size is " + lruCacheMemorySize + " MB");
0:       LOGGER.info("LRU cache size not configured. Therefore default behavior will be "
/////////////////////////////////////////////////////////////////////////
0:     Cacheable remove = lruCacheMap.remove(key);
0:     if(null != remove) {
0:       LOGGER.info("Removed entry from InMemory lru cache :: " + key);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug("Required size for entry " + columnIdentifier + " :: " + requiredSize
0:         + " Current cache size :: " + currentSize);
0:     if (isLRUCacheSizeConfigured()) {
0:         if (freeMemorySizeForAddingCache(requiredSize)) {
0:           currentSize = currentSize + requiredSize;
0:           addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
0:           columnKeyAddedSuccessfully = true;
0:         } else {
0:           LOGGER.error(
0:               "Size not available. Entry cannot be added to lru cache :: " + columnIdentifier
0:                   + " .Required Size = " + requiredSize + " Size available " + (lruCacheMemorySize
0:                   - currentSize));
1:       synchronized (lruCacheMap) {
0:         addEntryToLRUCacheMap(columnIdentifier, cacheInfo);
1:       }
0:       columnKeyAddedSuccessfully = true;
0:    * The method will add the cache entry to LRU cache map
1:    *
0:    * @param columnIdentifier
1:    * @param cacheInfo
1:    */
0:   private void addEntryToLRUCacheMap(String columnIdentifier, Cacheable cacheInfo) {
0:     if (null == lruCacheMap.get(columnIdentifier)) {
0:       lruCacheMap.put(columnIdentifier, cacheInfo);
1:     }
0:     LOGGER.debug("Added entry to InMemory lru cache :: " + columnIdentifier);
1:   }
1: 
1:   /**
0:    * this will check whether the LRU cache size is configured
1:    *
0:    * @return <Boolean> value
1:    */
0:   private boolean isLRUCacheSizeConfigured() {
0:     return lruCacheMemorySize > 0;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:     if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
1:       memoryAvailable = true;
0:     } else {
0:       // get the keys that can be removed from memory
0:       List<String> keysToBeRemoved = getKeysToBeRemoved(requiredSize);
0:       for (String cacheKey : keysToBeRemoved) {
0:         removeKey(cacheKey);
1:       }
0:       // after removing the keys check again if required size is available
author:QiangCai
-------------------------------------------------------------------------------
commit:256dbed
/////////////////////////////////////////////////////////////////////////
0:     if (null != remove) {
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:256dbed
/////////////////////////////////////////////////////////////////////////
0:     if (null != remove) {
commit:41347d8
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
author:ravipesala
-------------------------------------------------------------------------------
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.cache;
1: 
1: import java.util.ArrayList;
1: import java.util.LinkedHashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.util.CarbonProperties;
1: 
1: /**
1:  * class which manages the lru cache
1:  */
1: public final class CarbonLRUCache {
1:   /**
1:    * constant for converting MB into bytes
1:    */
1:   private static final int BYTE_CONVERSION_CONSTANT = 1024 * 1024;
1:   /**
1:    * Attribute for Carbon LOGGER
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(CarbonLRUCache.class.getName());
1:   /**
1:    * Map that will contain key as table unique name and value as cache Holder
1:    * object
1:    */
1:   private Map<String, Cacheable> lruCacheMap;
1:   /**
1:    * lruCacheSize
1:    */
1:   private long lruCacheMemorySize;
1:   /**
1:    * totalSize size of the cache
1:    */
1:   private long currentSize;
1: 
1:   /**
1:    * @param propertyName        property name to take the size configured
1:    * @param defaultPropertyName default property in case size is not configured
1:    */
1:   public CarbonLRUCache(String propertyName, String defaultPropertyName) {
1:     try {
1:       lruCacheMemorySize = Integer
1:           .parseInt(CarbonProperties.getInstance().getProperty(propertyName, defaultPropertyName));
1:     } catch (NumberFormatException e) {
1:       lruCacheMemorySize = Integer.parseInt(defaultPropertyName);
1:     }
1:     initCache();
1:     if (lruCacheMemorySize > 0) {
0:       LOGGER.info("Configured level cahce size is " + lruCacheMemorySize + " MB");
1:       // convert in bytes
1:       lruCacheMemorySize = lruCacheMemorySize * BYTE_CONVERSION_CONSTANT;
0:     } else {
0:       LOGGER.info("Column cache size not configured. Therefore default behavior will be "
1:               + "considered and no LRU based eviction of columns will be done");
1:     }
1:   }
1: 
1:   /**
1:    * initialize lru cache
1:    */
1:   private void initCache() {
1:     lruCacheMap =
1:         new LinkedHashMap<String, Cacheable>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE, 1.0f,
1:             true);
1:   }
1: 
1:   /**
1:    * This method will give the list of all the keys that can be deleted from
1:    * the level LRU cache
1:    */
1:   private List<String> getKeysToBeRemoved(long size) {
1:     List<String> toBeDeletedKeys =
1:         new ArrayList<String>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:     long removedSize = 0;
1:     for (Entry<String, Cacheable> entry : lruCacheMap.entrySet()) {
1:       String key = entry.getKey();
1:       Cacheable cacheInfo = entry.getValue();
1:       long memorySize = cacheInfo.getMemorySize();
1:       if (canBeRemoved(cacheInfo)) {
1:         removedSize = removedSize + memorySize;
1:         toBeDeletedKeys.add(key);
1:         // check if after removing the current file size, required
1:         // size when added to current size is sufficient to load a
1:         // level or not
1:         if (lruCacheMemorySize >= (currentSize - memorySize + size)) {
1:           toBeDeletedKeys.clear();
1:           toBeDeletedKeys.add(key);
1:           removedSize = memorySize;
1:           break;
1:         }
1:         // check if after removing the added size/removed size,
1:         // required size when added to current size is sufficient to
1:         // load a level or not
1:         else if (lruCacheMemorySize >= (currentSize - removedSize + size)) {
1:           break;
1:         }
1:       }
1:     }
1:     // this case will come when iteration is complete over the keys but
1:     // still size is not sufficient for level file to be loaded, then we
1:     // will not delete any of the keys
1:     if ((currentSize - removedSize + size) > lruCacheMemorySize) {
1:       toBeDeletedKeys.clear();
1:     }
1:     return toBeDeletedKeys;
1:   }
1: 
1:   /**
1:    * @param cacheInfo
1:    * @return
1:    */
1:   private boolean canBeRemoved(Cacheable cacheInfo) {
1:     if (cacheInfo.getAccessCount() > 0) {
1:       return false;
1:     }
1:     return true;
1:   }
1: 
1:   /**
1:    * @param key
1:    */
1:   public void remove(String key) {
1:     synchronized (lruCacheMap) {
1:       removeKey(key);
1:     }
1:   }
1: 
1:   /**
1:    * This method will remove the key from lru cache
1:    *
1:    * @param key
1:    */
1:   private void removeKey(String key) {
1:     Cacheable cacheable = lruCacheMap.get(key);
1:     if (null != cacheable) {
0:       currentSize = currentSize - cacheable.getMemorySize();
1:     }
0:     lruCacheMap.remove(key);
0:     LOGGER.info("Removed level entry from InMemory level lru cache :: " + key);
1:   }
1: 
1:   /**
1:    * This method will check if required size is available in the memory and then add
1:    * the given cacheable to object to lru cache
1:    *
0:    * @param columnIdentifier
1:    * @param cacheInfo
1:    */
1:   public boolean put(String columnIdentifier, Cacheable cacheInfo, long requiredSize) {
1:     boolean columnKeyAddedSuccessfully = false;
0:     if (freeMemorySizeForAddingCache(requiredSize)) {
1:       synchronized (lruCacheMap) {
0:         currentSize = currentSize + requiredSize;
0:         if (null == lruCacheMap.get(columnIdentifier)) {
0:           lruCacheMap.put(columnIdentifier, cacheInfo);
1:         }
0:         columnKeyAddedSuccessfully = true;
1:       }
0:       LOGGER.debug("Added level entry to InMemory level lru cache :: " + columnIdentifier);
0:     } else {
0:       LOGGER.error("Size not available. Column cannot be added to level lru cache :: "
0:           + columnIdentifier + " .Required Size = " + requiredSize + " Size available "
0:           + (lruCacheMemorySize - currentSize));
1:     }
1:     return columnKeyAddedSuccessfully;
1:   }
1: 
1:   /**
1:    * This method will check a required column can be loaded into memory or not. If required
1:    * this method will call for eviction of existing data from memory
1:    *
1:    * @param requiredSize
1:    * @return
1:    */
1:   private boolean freeMemorySizeForAddingCache(long requiredSize) {
1:     boolean memoryAvailable = false;
1:     if (lruCacheMemorySize > 0) {
0:       if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
0:         memoryAvailable = true;
0:       } else {
1:         synchronized (lruCacheMap) {
0:           // get the keys that can be removed from memory
0:           List<String> keysToBeRemoved = getKeysToBeRemoved(requiredSize);
0:           for (String cacheKey : keysToBeRemoved) {
0:             removeKey(cacheKey);
1:           }
0:           // after removing the keys check again if required size is available
0:           if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
0:             memoryAvailable = true;
1:           }
1:         }
1:       }
0:     } else {
0:       memoryAvailable = true;
1:     }
1:     return memoryAvailable;
1:   }
1: 
1:   /**
1:    * This method will check if size is available to laod dictionary into memory
1:    *
1:    * @param requiredSize
1:    * @return
1:    */
1:   private boolean isSizeAvailableToLoadColumnDictionary(long requiredSize) {
1:     return lruCacheMemorySize >= (currentSize + requiredSize);
1:   }
1: 
1:   /**
1:    * @param key
1:    * @return
1:    */
1:   public Cacheable get(String key) {
1:     synchronized (lruCacheMap) {
1:       return lruCacheMap.get(key);
1:     }
1:   }
1: 
1:   /**
1:    * This method will empty the level cache
1:    */
1:   public void clear() {
1:     synchronized (lruCacheMap) {
1:       lruCacheMap.clear();
1:     }
1:   }
1: }
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.carbondata.core.cache;
0: 
0: import java.util.ArrayList;
0: import java.util.LinkedHashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Map.Entry;
0: 
0: import org.apache.carbondata.common.logging.LogService;
0: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.util.CarbonProperties;
0: 
0: /**
0:  * class which manages the lru cache
0:  */
0: public final class CarbonLRUCache {
0:   /**
0:    * constant for converting MB into bytes
0:    */
0:   private static final int BYTE_CONVERSION_CONSTANT = 1024 * 1024;
0:   /**
0:    * Attribute for Carbon LOGGER
0:    */
0:   private static final LogService LOGGER =
0:       LogServiceFactory.getLogService(CarbonLRUCache.class.getName());
0:   /**
0:    * Map that will contain key as table unique name and value as cache Holder
0:    * object
0:    */
0:   private Map<String, Cacheable> lruCacheMap;
0:   /**
0:    * lruCacheSize
0:    */
0:   private long lruCacheMemorySize;
0:   /**
0:    * totalSize size of the cache
0:    */
0:   private long currentSize;
0: 
0:   /**
0:    * @param propertyName        property name to take the size configured
0:    * @param defaultPropertyName default property in case size is not configured
0:    */
0:   public CarbonLRUCache(String propertyName, String defaultPropertyName) {
0:     try {
0:       lruCacheMemorySize = Integer
0:           .parseInt(CarbonProperties.getInstance().getProperty(propertyName, defaultPropertyName));
0:     } catch (NumberFormatException e) {
0:       lruCacheMemorySize = Integer.parseInt(defaultPropertyName);
0:     }
0:     initCache();
0:     if (lruCacheMemorySize > 0) {
0:       LOGGER.info("Configured level cahce size is " + lruCacheMemorySize + " MB");
0:       // convert in bytes
0:       lruCacheMemorySize = lruCacheMemorySize * BYTE_CONVERSION_CONSTANT;
0:     } else {
0:       LOGGER.info("Column cache size not configured. Therefore default behavior will be "
0:               + "considered and no LRU based eviction of columns will be done");
0:     }
0:   }
0: 
0:   /**
0:    * initialize lru cache
0:    */
0:   private void initCache() {
0:     lruCacheMap =
0:         new LinkedHashMap<String, Cacheable>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE, 1.0f,
0:             true);
0:   }
0: 
0:   /**
0:    * This method will give the list of all the keys that can be deleted from
0:    * the level LRU cache
0:    */
0:   private List<String> getKeysToBeRemoved(long size) {
0:     List<String> toBeDeletedKeys =
0:         new ArrayList<String>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
0:     long removedSize = 0;
0:     for (Entry<String, Cacheable> entry : lruCacheMap.entrySet()) {
0:       String key = entry.getKey();
0:       Cacheable cacheInfo = entry.getValue();
0:       long memorySize = cacheInfo.getMemorySize();
0:       if (canBeRemoved(cacheInfo)) {
0:         removedSize = removedSize + memorySize;
0:         toBeDeletedKeys.add(key);
0:         // check if after removing the current file size, required
0:         // size when added to current size is sufficient to load a
0:         // level or not
0:         if (lruCacheMemorySize >= (currentSize - memorySize + size)) {
0:           toBeDeletedKeys.clear();
0:           toBeDeletedKeys.add(key);
0:           removedSize = memorySize;
0:           break;
0:         }
0:         // check if after removing the added size/removed size,
0:         // required size when added to current size is sufficient to
0:         // load a level or not
0:         else if (lruCacheMemorySize >= (currentSize - removedSize + size)) {
0:           break;
0:         }
0:       }
0:     }
0:     // this case will come when iteration is complete over the keys but
0:     // still size is not sufficient for level file to be loaded, then we
0:     // will not delete any of the keys
0:     if ((currentSize - removedSize + size) > lruCacheMemorySize) {
0:       toBeDeletedKeys.clear();
0:     }
0:     return toBeDeletedKeys;
0:   }
0: 
0:   /**
0:    * @param cacheInfo
0:    * @return
0:    */
0:   private boolean canBeRemoved(Cacheable cacheInfo) {
0:     if (cacheInfo.getAccessCount() > 0) {
0:       return false;
0:     }
0:     return true;
0:   }
0: 
0:   /**
0:    * @param key
0:    */
0:   public void remove(String key) {
0:     synchronized (lruCacheMap) {
0:       removeKey(key);
0:     }
0:   }
0: 
0:   /**
0:    * This method will remove the key from lru cache
0:    *
0:    * @param key
0:    */
0:   private void removeKey(String key) {
0:     Cacheable cacheable = lruCacheMap.get(key);
0:     if (null != cacheable) {
0:       currentSize = currentSize - cacheable.getMemorySize();
0:     }
0:     lruCacheMap.remove(key);
0:     LOGGER.info("Removed level entry from InMemory level lru cache :: " + key);
0:   }
0: 
0:   /**
0:    * This method will check if required size is available in the memory and then add
0:    * the given cacheable to object to lru cache
0:    *
0:    * @param columnIdentifier
0:    * @param cacheInfo
0:    */
0:   public boolean put(String columnIdentifier, Cacheable cacheInfo, long requiredSize) {
0:     boolean columnKeyAddedSuccessfully = false;
0:     if (freeMemorySizeForAddingCache(requiredSize)) {
0:       synchronized (lruCacheMap) {
0:         currentSize = currentSize + requiredSize;
0:         if (null == lruCacheMap.get(columnIdentifier)) {
0:           lruCacheMap.put(columnIdentifier, cacheInfo);
0:         }
0:         columnKeyAddedSuccessfully = true;
0:       }
0:       LOGGER.debug("Added level entry to InMemory level lru cache :: " + columnIdentifier);
0:     } else {
0:       LOGGER.error("Size not available. Column cannot be added to level lru cache :: "
0:           + columnIdentifier + " .Required Size = " + requiredSize + " Size available "
0:           + (lruCacheMemorySize - currentSize));
0:     }
0:     return columnKeyAddedSuccessfully;
0:   }
0: 
0:   /**
0:    * This method will check a required column can be loaded into memory or not. If required
0:    * this method will call for eviction of existing data from memory
0:    *
0:    * @param requiredSize
0:    * @return
0:    */
0:   private boolean freeMemorySizeForAddingCache(long requiredSize) {
0:     boolean memoryAvailable = false;
0:     if (lruCacheMemorySize > 0) {
0:       if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
0:         memoryAvailable = true;
0:       } else {
0:         synchronized (lruCacheMap) {
0:           // get the keys that can be removed from memory
0:           List<String> keysToBeRemoved = getKeysToBeRemoved(requiredSize);
0:           for (String cacheKey : keysToBeRemoved) {
0:             removeKey(cacheKey);
0:           }
0:           // after removing the keys check again if required size is available
0:           if (isSizeAvailableToLoadColumnDictionary(requiredSize)) {
0:             memoryAvailable = true;
0:           }
0:         }
0:       }
0:     } else {
0:       memoryAvailable = true;
0:     }
0:     return memoryAvailable;
0:   }
0: 
0:   /**
0:    * This method will check if size is available to laod dictionary into memory
0:    *
0:    * @param requiredSize
0:    * @return
0:    */
0:   private boolean isSizeAvailableToLoadColumnDictionary(long requiredSize) {
0:     return lruCacheMemorySize >= (currentSize + requiredSize);
0:   }
0: 
0:   /**
0:    * @param key
0:    * @return
0:    */
0:   public Cacheable get(String key) {
0:     synchronized (lruCacheMap) {
0:       return lruCacheMap.get(key);
0:     }
0:   }
0: 
0:   /**
0:    * This method will empty the level cache
0:    */
0:   public void clear() {
0:     synchronized (lruCacheMap) {
0:       lruCacheMap.clear();
0:     }
0:   }
0: }
============================================================================