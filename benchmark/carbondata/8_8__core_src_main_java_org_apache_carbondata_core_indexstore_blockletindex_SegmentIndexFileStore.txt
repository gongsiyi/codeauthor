1:0586146: /*
1:0586146:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0586146:  * contributor license agreements.  See the NOTICE file distributed with
1:0586146:  * this work for additional information regarding copyright ownership.
1:0586146:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:0586146:  * (the "License"); you may not use this file except in compliance with
1:0586146:  * the License.  You may obtain a copy of the License at
1:0586146:  *
1:0586146:  *    http://www.apache.org/licenses/LICENSE-2.0
1:0586146:  *
1:0586146:  * Unless required by applicable law or agreed to in writing, software
1:0586146:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0586146:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0586146:  * See the License for the specific language governing permissions and
1:0586146:  * limitations under the License.
1:0586146:  */
1:0586146: package org.apache.carbondata.core.indexstore.blockletindex;
1:0586146: 
1:0586146: import java.io.DataInputStream;
1:0586146: import java.io.IOException;
1:0586146: import java.nio.ByteBuffer;
1:daa6465: import java.util.ArrayList;
1:daa6465: import java.util.HashMap;
1:daa6465: import java.util.HashSet;
1:daa6465: import java.util.List;
1:daa6465: import java.util.Map;
1:daa6465: import java.util.Set;
1:a20f22e: import java.util.TreeMap;
1:0586146: 
1:e820006: import org.apache.carbondata.common.logging.LogService;
1:e820006: import org.apache.carbondata.common.logging.LogServiceFactory;
1:e820006: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:e820006: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
1:0586146: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
1:0586146: import org.apache.carbondata.core.datastore.filesystem.CarbonFileFilter;
1:0586146: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:8d3c774: import org.apache.carbondata.core.metadata.SegmentFileStore;
1:e820006: import org.apache.carbondata.core.metadata.blocklet.BlockletInfo;
1:e820006: import org.apache.carbondata.core.metadata.blocklet.DataFileFooter;
1:e820006: import org.apache.carbondata.core.reader.CarbonIndexFileReader;
1:0586146: import org.apache.carbondata.core.reader.ThriftReader;
1:8d3c774: import org.apache.carbondata.core.statusmanager.SegmentStatus;
1:e820006: import org.apache.carbondata.core.util.CarbonMetadataUtil;
1:e820006: import org.apache.carbondata.core.util.CarbonUtil;
1:e820006: import org.apache.carbondata.core.util.DataFileFooterConverter;
1:0586146: import org.apache.carbondata.core.util.path.CarbonTablePath;
1:e820006: import org.apache.carbondata.format.BlockIndex;
1:0586146: import org.apache.carbondata.format.MergedBlockIndex;
1:0586146: import org.apache.carbondata.format.MergedBlockIndexHeader;
1:0586146: 
1:8f1a029: import org.apache.hadoop.conf.Configuration;
1:0586146: import org.apache.thrift.TBase;
1:0586146: 
1:0586146: /**
1:0586146:  * This class manages reading of index files with in the segment. The files it read can be
1:0586146:  * carbonindex or carbonindexmerge files.
1:0586146:  */
1:0586146: public class SegmentIndexFileStore {
1:0586146: 
1:0586146:   /**
1:e820006:    * Logger constant
1:e820006:    */
1:e820006:   private static final LogService LOGGER =
1:e820006:       LogServiceFactory.getLogService(SegmentIndexFileStore.class.getName());
1:e820006:   /**
1:0586146:    * Stores the indexfile name and related binary file data in it.
1:0586146:    */
1:0586146:   private Map<String, byte[]> carbonIndexMap;
1:0586146: 
1:8d3c774:   /**
1:8d3c774:    * Stores the indexfile name and related binary file data in it.
1:8d3c774:    */
1:8d3c774:   private Map<String, byte[]> carbonIndexMapWithFullPath;
1:8d3c774: 
1:531ecdf:   /**
1:531ecdf:    * Stores the list of index files in a merge file
1:531ecdf:    */
1:531ecdf:   private Map<String, List<String>> carbonMergeFileToIndexFilesMap;
1:531ecdf: 
1:8f1a029:   private Configuration configuration;
1:8f1a029: 
1:9659edc:   public SegmentIndexFileStore() {
1:0586146:     carbonIndexMap = new HashMap<>();
1:a20f22e:     carbonIndexMapWithFullPath = new TreeMap<>();
1:531ecdf:     carbonMergeFileToIndexFilesMap = new HashMap<>();
1:8f1a029:     configuration = FileFactory.getConfiguration();
1:8f1a029:   }
1:8f1a029: 
1:8f1a029:   public SegmentIndexFileStore(Configuration configuration) {
1:8f1a029:     carbonIndexMap = new HashMap<>();
1:8f1a029:     carbonIndexMapWithFullPath = new TreeMap<>();
1:8f1a029:     carbonMergeFileToIndexFilesMap = new HashMap<>();
1:8f1a029:     this.configuration = configuration;
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:8d3c774:    * Read all index files and keep the cache in it.
1:8d3c774:    *
1:0586146:    * @param segmentPath
1:8d3c774:    * @throws IOException
1:8d3c774:    */
1:0586146:   public void readAllIIndexOfSegment(String segmentPath) throws IOException {
1:8f1a029:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath, configuration);
1:0586146:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:0586146:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:0586146:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:0586146:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:0586146:         readIndexFile(carbonIndexFiles[i]);
1:0586146:       }
1:0586146:     }
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:41b0074:    * Read all index files and keep the cache in it.
1:41b0074:    *
1:7bfe4af:    * @param segmentFile
1:0586146:    * @throws IOException
1:0586146:    */
1:7bfe4af:   public void readAllIIndexOfSegment(SegmentFileStore.SegmentFile segmentFile, String tablePath,
1:7bfe4af:       SegmentStatus status, boolean ignoreStatus) throws IOException {
1:8d3c774:     List<CarbonFile> carbonIndexFiles = new ArrayList<>();
1:74f5d67:     Set<String> indexFiles = new HashSet<>();
1:7bfe4af:     if (segmentFile == null) {
1:8d3c774:       return;
1:8d3c774:     }
1:7bfe4af:     for (Map.Entry<String, SegmentFileStore.FolderDetails> locations : segmentFile
1:8d3c774:         .getLocationMap().entrySet()) {
1:8d3c774:       String location = locations.getKey();
1:8d3c774: 
1:8d3c774:       if (locations.getValue().getStatus().equals(status.getMessage()) || ignoreStatus) {
1:8d3c774:         if (locations.getValue().isRelative()) {
1:7bfe4af:           location = tablePath + CarbonCommonConstants.FILE_SEPARATOR + location;
1:8d3c774:         }
1:74f5d67:         String mergeFileName = locations.getValue().getMergeFileName();
1:74f5d67:         if (mergeFileName != null) {
1:74f5d67:           CarbonFile mergeFile = FileFactory
1:74f5d67:               .getCarbonFile(location + CarbonCommonConstants.FILE_SEPARATOR + mergeFileName);
1:74f5d67:           if (mergeFile.exists() && !indexFiles.contains(mergeFile.getAbsolutePath())) {
1:74f5d67:             carbonIndexFiles.add(mergeFile);
1:74f5d67:             indexFiles.add(mergeFile.getAbsolutePath());
1:74f5d67:           }
1:74f5d67:         }
1:8d3c774:         for (String indexFile : locations.getValue().getFiles()) {
1:8d3c774:           CarbonFile carbonFile = FileFactory
1:8d3c774:               .getCarbonFile(location + CarbonCommonConstants.FILE_SEPARATOR + indexFile);
1:74f5d67:           if (carbonFile.exists() && !indexFiles.contains(carbonFile.getAbsolutePath())) {
1:8d3c774:             carbonIndexFiles.add(carbonFile);
1:74f5d67:             indexFiles.add(carbonFile.getAbsolutePath());
1:8d3c774:           }
1:8d3c774:         }
1:8d3c774:       }
1:8d3c774:     }
1:8d3c774:     for (int i = 0; i < carbonIndexFiles.size(); i++) {
1:8d3c774:       if (carbonIndexFiles.get(i).getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:8d3c774:         readMergeFile(carbonIndexFiles.get(i).getCanonicalPath());
1:8d3c774:       } else if (carbonIndexFiles.get(i).getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:8d3c774:         readIndexFile(carbonIndexFiles.get(i));
1:8d3c774:       }
1:8d3c774:     }
1:8d3c774:   }
1:8d3c774: 
1:8d3c774:   /**
1:e820006:    * read index file and fill the blocklet information
1:0586146:    *
1:e820006:    * @param segmentPath
1:e820006:    * @throws IOException
1:e820006:    */
1:e820006:   public void readAllIndexAndFillBolckletInfo(String segmentPath) throws IOException {
1:8f1a029:     CarbonFile[] carbonIndexFiles =
1:8f1a029:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
1:e820006:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:e820006:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:e820006:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:e820006:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:e820006:         readIndexAndFillBlockletInfo(carbonIndexFiles[i]);
1:e820006:       }
1:e820006:     }
1:e820006:   }
1:e820006: 
1:e820006:   /**
1:0586146:    * Read all index files and keep the cache in it.
1:e820006:    *
1:41b0074:    * @param carbonFiles
1:41b0074:    * @throws IOException
1:41b0074:    */
1:41b0074:   public void readAllIIndexOfSegment(CarbonFile[] carbonFiles) throws IOException {
1:41b0074:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(carbonFiles);
1:41b0074:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:41b0074:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:41b0074:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:41b0074:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:41b0074:         readIndexFile(carbonIndexFiles[i]);
1:41b0074:       }
1:41b0074:     }
1:41b0074:   }
1:41b0074: 
1:41b0074:   /**
1:0586146:    * Read all index file names of the segment
1:0586146:    *
1:0586146:    * @param segmentPath
1:0586146:    * @return
1:0586146:    * @throws IOException
1:0586146:    */
1:8d3c774:   public Map<String, String> getIndexFilesFromSegment(String segmentPath) throws IOException {
1:8f1a029:     CarbonFile[] carbonIndexFiles =
1:8f1a029:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
1:8d3c774:     Map<String, String> indexFiles = new HashMap<>();
1:0586146:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:0586146:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:8d3c774:         List<String> indexFilesFromMergeFile =
1:8d3c774:             getIndexFilesFromMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:8d3c774:         for (String file: indexFilesFromMergeFile) {
1:8d3c774:           indexFiles.put(carbonIndexFiles[i].getParentFile().getAbsolutePath()
1:8d3c774:               + CarbonCommonConstants.FILE_SEPARATOR + file, carbonIndexFiles[i].getName());
1:8d3c774:         }
1:0586146:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:8d3c774:         indexFiles.put(carbonIndexFiles[i].getAbsolutePath(), null);
1:0586146:       }
1:0586146:     }
1:8d3c774:     return indexFiles;
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:531ecdf:    * Read all index file names of the segment
1:531ecdf:    *
1:531ecdf:    * @param segmentPath
1:5f68a79:    * @return
1:531ecdf:    * @throws IOException
1:5f68a79:    */
1:531ecdf:   public Map<String, String> getMergeOrIndexFilesFromSegment(String segmentPath)
1:531ecdf:       throws IOException {
1:8f1a029:     CarbonFile[] carbonIndexFiles =
1:8f1a029:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
1:531ecdf:     Map<String, String> indexFiles = new HashMap<>();
1:531ecdf:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:531ecdf:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:531ecdf:         indexFiles
1:531ecdf:             .put(carbonIndexFiles[i].getAbsolutePath(), carbonIndexFiles[i].getAbsolutePath());
1:531ecdf:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:531ecdf:         indexFiles.put(carbonIndexFiles[i].getAbsolutePath(), null);
1:531ecdf:       }
1:531ecdf:     }
1:0586146:     return indexFiles;
1:531ecdf:   }
1:531ecdf: 
1:531ecdf:   /**
1:0586146:    * List all the index files inside merge file.
1:0586146:    * @param mergeFile
1:0586146:    * @return
1:0586146:    * @throws IOException
1:0586146:    */
1:0586146:   public List<String> getIndexFilesFromMergeFile(String mergeFile) throws IOException {
1:0586146:     ThriftReader thriftReader = new ThriftReader(mergeFile);
2:0586146:     thriftReader.open();
2:0586146:     MergedBlockIndexHeader indexHeader = readMergeBlockIndexHeader(thriftReader);
1:910d496:     List<String> fileNames = indexHeader.getFile_names();
2:0586146:     thriftReader.close();
1:910d496:     return fileNames;
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:0586146:    * Read carbonindexmerge file and update the map
1:0586146:    *
1:0586146:    * @param mergeFilePath
1:0586146:    * @throws IOException
1:0586146:    */
1:531ecdf:   public void readMergeFile(String mergeFilePath) throws IOException {
1:8f1a029:     ThriftReader thriftReader = new ThriftReader(mergeFilePath, configuration);
1:8d3c774:     try {
1:8d3c774:       thriftReader.open();
1:8d3c774:       MergedBlockIndexHeader indexHeader = readMergeBlockIndexHeader(thriftReader);
1:8d3c774:       MergedBlockIndex mergedBlockIndex = readMergeBlockIndex(thriftReader);
1:8d3c774:       List<String> file_names = indexHeader.getFile_names();
1:531ecdf:       carbonMergeFileToIndexFilesMap.put(mergeFilePath, file_names);
1:8d3c774:       List<ByteBuffer> fileData = mergedBlockIndex.getFileData();
1:8f1a029:       CarbonFile mergeFile = FileFactory.getCarbonFile(mergeFilePath, configuration);
1:a20f22e:       String mergeFileAbsolutePath = mergeFile.getParentFile().getAbsolutePath();
1:8d3c774:       assert (file_names.size() == fileData.size());
1:8d3c774:       for (int i = 0; i < file_names.size(); i++) {
1:a20f22e:         byte[] data = fileData.get(i).array();
1:a20f22e:         carbonIndexMap.put(file_names.get(i), data);
1:a20f22e:         carbonIndexMapWithFullPath
1:a20f22e:             .put(mergeFileAbsolutePath + CarbonCommonConstants.FILE_SEPARATOR + file_names.get(i),
1:a20f22e:                 data);
1:8d3c774:       }
1:8d3c774:     } finally {
1:8d3c774:       thriftReader.close();
1:0586146:     }
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:0586146:    * Read carbonindex file and convert to stream and add to map
1:0586146:    *
1:0586146:    * @param indexFile
1:0586146:    * @throws IOException
1:0586146:    */
1:0586146:   private void readIndexFile(CarbonFile indexFile) throws IOException {
1:0586146:     String indexFilePath = indexFile.getCanonicalPath();
1:8f1a029:     DataInputStream dataInputStream = FileFactory
1:8f1a029:         .getDataInputStream(indexFilePath, FileFactory.getFileType(indexFilePath), configuration);
1:0586146:     byte[] bytes = new byte[(int) indexFile.getSize()];
1:7ef9164:     try {
1:0586146:       dataInputStream.readFully(bytes);
1:0586146:       carbonIndexMap.put(indexFile.getName(), bytes);
1:8d3c774:       carbonIndexMapWithFullPath.put(
1:8d3c774:           indexFile.getParentFile().getAbsolutePath() + CarbonCommonConstants.FILE_SEPARATOR
1:8d3c774:               + indexFile.getName(), bytes);
1:7ef9164:     } finally {
1:17d0731:       dataInputStream.close();
1:0586146:     }
1:7ef9164:   }
1:0586146: 
1:0586146:   private MergedBlockIndexHeader readMergeBlockIndexHeader(ThriftReader thriftReader)
1:0586146:       throws IOException {
1:0586146:     return (MergedBlockIndexHeader) thriftReader.read(new ThriftReader.TBaseCreator() {
1:0586146:       @Override public TBase create() {
1:0586146:         return new MergedBlockIndexHeader();
1:0586146:       }
1:0586146:     });
1:0586146:   }
1:0586146: 
1:0586146:   private MergedBlockIndex readMergeBlockIndex(ThriftReader thriftReader) throws IOException {
1:0586146:     return (MergedBlockIndex) thriftReader.read(new ThriftReader.TBaseCreator() {
1:0586146:       @Override public TBase create() {
1:0586146:         return new MergedBlockIndex();
1:0586146:       }
1:0586146:     });
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:0586146:    * Get the carbonindex file content
1:0586146:    *
1:0586146:    * @param fileName
1:0586146:    * @return
1:0586146:    */
1:0586146:   public byte[] getFileData(String fileName) {
1:0586146:     return carbonIndexMap.get(fileName);
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:41b0074:    * List all the index files of the segment.
1:41b0074:    *
1:70fe514:    * @param carbonFile directory
1:41b0074:    * @return
1:70fe514:    */
1:5f68a79:   public static CarbonFile[] getCarbonIndexFiles(CarbonFile carbonFile) {
1:0586146:     return carbonFile.listFiles(new CarbonFileFilter() {
1:0586146:       @Override public boolean accept(CarbonFile file) {
1:5f68a79:         return ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:5f68a79:             .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0);
1:0586146:       }
1:0586146:     });
1:0586146:   }
1:0586146: 
1:0586146:   /**
1:0586146:    * List all the index files of the segment.
1:0586146:    *
1:5f68a79:    * @param carbonFile directory
1:41b0074:    */
1:70fe514:   public static void getCarbonIndexFilesRecursively(CarbonFile carbonFile,
1:70fe514:       List<CarbonFile> indexFiles) {
1:70fe514:     CarbonFile[] carbonFiles = carbonFile.listFiles();
1:70fe514:     for (CarbonFile file : carbonFiles) {
1:70fe514:       if (file.isDirectory()) {
1:70fe514:         getCarbonIndexFilesRecursively(file, indexFiles);
1:70fe514:       } else if ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:70fe514:           .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0) {
1:70fe514:         indexFiles.add(file);
1:70fe514:       }
1:70fe514:     }
1:70fe514:   }
1:70fe514: 
1:70fe514:   /**
1:70fe514:    * List all the index files of the segment.
1:70fe514:    *
1:0586146:    * @param segmentPath
1:0586146:    * @return
1:0586146:    */
1:8f1a029:   public static CarbonFile[] getCarbonIndexFiles(String segmentPath, Configuration configuration) {
1:8f1a029:     CarbonFile carbonFile = FileFactory.getCarbonFile(segmentPath, configuration);
1:5f68a79:     return carbonFile.listFiles(new CarbonFileFilter() {
1:5f68a79:       @Override public boolean accept(CarbonFile file) {
1:531ecdf:         return ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:531ecdf:             .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0);
1:5f68a79:       }
1:5f68a79:     });
1:5f68a79:   }
1:5f68a79: 
1:5f68a79:   /**
1:5f68a79:    * List all the index files of the segment.
1:5f68a79:    *
1:41b0074:    * @param carbonFiles
1:531ecdf:    * @return
1:531ecdf:    */
1:41b0074:   public static CarbonFile[] getCarbonIndexFiles(CarbonFile[] carbonFiles) {
1:41b0074:     List<CarbonFile> indexFiles = new ArrayList<>();
1:41b0074:     for (CarbonFile file: carbonFiles) {
1:41b0074:       if (file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) ||
1:41b0074:           file.getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:41b0074:         indexFiles.add(file);
1:41b0074:       }
1:41b0074:     }
1:41b0074:     return indexFiles.toArray(new CarbonFile[indexFiles.size()]);
1:41b0074:   }
1:41b0074: 
1:41b0074:   /**
1:0586146:    * Return the map that contain index file name and content of the file.
1:0586146:    *
1:0586146:    * @return
1:0586146:    */
1:0586146:   public Map<String, byte[]> getCarbonIndexMap() {
1:0586146:     return carbonIndexMap;
1:0586146:   }
1:e820006: 
1:8d3c774:   public Map<String, byte[]> getCarbonIndexMapWithFullPath() {
1:8d3c774:     return carbonIndexMapWithFullPath;
1:8d3c774:   }
1:8d3c774: 
1:e820006:   /**
1:e820006:    * This method will read the index information from carbon index file
1:e820006:    *
1:e820006:    * @param indexFile
1:e820006:    * @return
1:e820006:    * @throws IOException
1:e820006:    */
1:e820006:   private void readIndexAndFillBlockletInfo(CarbonFile indexFile) throws IOException {
1:e820006:     // flag to take decision whether carbondata file footer reading is required.
1:e820006:     // If the index file does not contain the file footer then carbondata file footer
1:e820006:     // read is required else not required
1:e820006:     boolean isCarbonDataFileFooterReadRequired = true;
1:e820006:     List<BlockletInfo> blockletInfoList = null;
1:e820006:     List<BlockIndex> blockIndexThrift =
1:e820006:         new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:e820006:     CarbonIndexFileReader indexReader = new CarbonIndexFileReader();
1:e820006:     try {
1:e820006:       indexReader.openThriftReader(indexFile.getCanonicalPath());
1:e820006:       // get the index header
1:e820006:       org.apache.carbondata.format.IndexHeader indexHeader = indexReader.readIndexHeader();
1:8f1a029:       DataFileFooterConverter fileFooterConverter =
1:8f1a029:           new DataFileFooterConverter(FileFactory.getConfiguration());
1:625a2ef:       String filePath = FileFactory.getUpdatedFilePath(indexFile.getCanonicalPath());
1:e820006:       String parentPath =
1:e820006:           filePath.substring(0, filePath.lastIndexOf(CarbonCommonConstants.FILE_SEPARATOR));
1:e820006:       while (indexReader.hasNext()) {
1:e820006:         BlockIndex blockIndex = indexReader.readBlockIndexInfo();
1:e820006:         if (blockIndex.isSetBlocklet_info()) {
1:e820006:           // this case will come in case segment index compaction property is set to false from the
1:e820006:           // application and alter table segment index compaction is run manually. In that case
1:e820006:           // blocklet info will be present in the index but read carbon data file footer property
1:e820006:           // will be true
1:e820006:           isCarbonDataFileFooterReadRequired = false;
1:e820006:           break;
1:e820006:         } else {
1:e820006:           TableBlockInfo blockInfo =
1:e820006:               fileFooterConverter.getTableBlockInfo(blockIndex, indexHeader, parentPath);
1:e820006:           blockletInfoList = getBlockletInfoFromIndexInfo(blockInfo);
1:0586146:         }
1:e820006:         // old store which does not have the blocklet info will have 1 count per part file but in
1:e820006:         // the current code, the number of entries in the index file is equal to the total number
1:e820006:         // of blocklets in all part files for 1 task. So to make it compatible with new structure,
1:e820006:         // the same entry with different blocklet info need to be repeated
1:e820006:         for (int i = 0; i < blockletInfoList.size(); i++) {
1:e820006:           BlockIndex blockIndexReplica = blockIndex.deepCopy();
1:e820006:           BlockletInfo blockletInfo = blockletInfoList.get(i);
1:e820006:           blockIndexReplica
1:e820006:               .setBlock_index(CarbonMetadataUtil.getBlockletIndex(blockletInfo.getBlockletIndex()));
1:e820006:           blockIndexReplica
1:e820006:               .setBlocklet_info(CarbonMetadataUtil.getBlocletInfo3(blockletInfo));
1:e820006:           blockIndexThrift.add(blockIndexReplica);
1:e820006:         }
1:e820006:       }
1:e820006:       // read complete file at once
1:e820006:       if (!isCarbonDataFileFooterReadRequired) {
1:e820006:         readIndexFile(indexFile);
1:e820006:       } else {
1:e820006:         int totalSize = 0;
1:e820006:         List<byte[]> blockIndexByteArrayList =
1:e820006:             new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:e820006:         byte[] indexHeaderBytes = CarbonUtil.getByteArray(indexHeader);
1:e820006:         totalSize += indexHeaderBytes.length;
1:e820006:         blockIndexByteArrayList.add(indexHeaderBytes);
1:e820006:         for (BlockIndex blockIndex : blockIndexThrift) {
1:e820006:           byte[] indexInfoBytes = CarbonUtil.getByteArray(blockIndex);
1:e820006:           totalSize += indexInfoBytes.length;
1:e820006:           blockIndexByteArrayList.add(indexInfoBytes);
1:e820006:         }
1:e820006:         ByteBuffer byteBuffer = ByteBuffer.allocate(totalSize);
1:e820006:         for (byte[] blockIndexBytes : blockIndexByteArrayList) {
1:e820006:           byteBuffer.put(blockIndexBytes);
1:e820006:         }
1:e820006:         carbonIndexMap.put(indexFile.getName(), byteBuffer.array());
1:e820006:       }
1:e820006:     } finally {
1:e820006:       indexReader.closeThriftReader();
1:e820006:     }
1:e820006:   }
1:e820006: 
1:e820006:   /**
1:e820006:    * This method will read the blocklet info from carbon data file and fill it to index info
1:e820006:    *
1:e820006:    * @param blockInfo
1:e820006:    * @return
1:e820006:    * @throws IOException
1:e820006:    */
1:e820006:   private List<BlockletInfo> getBlockletInfoFromIndexInfo(TableBlockInfo blockInfo)
1:e820006:       throws IOException {
1:e820006:     long startTime = System.currentTimeMillis();
1:e820006:     DataFileFooter carbondataFileFooter = CarbonUtil.readMetadatFile(blockInfo);
1:e820006:     LOGGER.info(
1:e820006:         "Time taken to read carbondata file footer to get blocklet info " + blockInfo.getFilePath()
1:e820006:             + " is " + (System.currentTimeMillis() - startTime));
1:e820006:     return carbondataFileFooter.getBlockletList();
1:e820006:   }
1:531ecdf: 
1:531ecdf:   public Map<String, List<String>> getCarbonMergeFileToIndexFilesMap() {
1:531ecdf:     return carbonMergeFileToIndexFilesMap;
1:e820006:   }
1:531ecdf: }
============================================================================
author:kunal642
-------------------------------------------------------------------------------
commit:8f1a029
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.conf.Configuration;
/////////////////////////////////////////////////////////////////////////
1:   private Configuration configuration;
1: 
1:     configuration = FileFactory.getConfiguration();
1:   }
1: 
1:   public SegmentIndexFileStore(Configuration configuration) {
1:     carbonIndexMap = new HashMap<>();
1:     carbonIndexMapWithFullPath = new TreeMap<>();
1:     carbonMergeFileToIndexFilesMap = new HashMap<>();
1:     this.configuration = configuration;
/////////////////////////////////////////////////////////////////////////
1:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath, configuration);
/////////////////////////////////////////////////////////////////////////
1:     CarbonFile[] carbonIndexFiles =
1:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
/////////////////////////////////////////////////////////////////////////
1:     CarbonFile[] carbonIndexFiles =
1:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
/////////////////////////////////////////////////////////////////////////
1:     CarbonFile[] carbonIndexFiles =
1:         getCarbonIndexFiles(segmentPath, FileFactory.getConfiguration());
/////////////////////////////////////////////////////////////////////////
1:     ThriftReader thriftReader = new ThriftReader(mergeFilePath, configuration);
/////////////////////////////////////////////////////////////////////////
1:       CarbonFile mergeFile = FileFactory.getCarbonFile(mergeFilePath, configuration);
/////////////////////////////////////////////////////////////////////////
1:     DataInputStream dataInputStream = FileFactory
1:         .getDataInputStream(indexFilePath, FileFactory.getFileType(indexFilePath), configuration);
/////////////////////////////////////////////////////////////////////////
1:   public static CarbonFile[] getCarbonIndexFiles(String segmentPath, Configuration configuration) {
1:     CarbonFile carbonFile = FileFactory.getCarbonFile(segmentPath, configuration);
/////////////////////////////////////////////////////////////////////////
1:       DataFileFooterConverter fileFooterConverter =
1:           new DataFileFooterConverter(FileFactory.getConfiguration());
author:ravipesala
-------------------------------------------------------------------------------
commit:70fe514
/////////////////////////////////////////////////////////////////////////
1:    * @param carbonFile directory
1:    */
1:   public static void getCarbonIndexFilesRecursively(CarbonFile carbonFile,
1:       List<CarbonFile> indexFiles) {
1:     CarbonFile[] carbonFiles = carbonFile.listFiles();
1:     for (CarbonFile file : carbonFiles) {
1:       if (file.isDirectory()) {
1:         getCarbonIndexFilesRecursively(file, indexFiles);
1:       } else if ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:           .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0) {
1:         indexFiles.add(file);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * List all the index files of the segment.
1:    *
commit:74f5d67
/////////////////////////////////////////////////////////////////////////
1:     Set<String> indexFiles = new HashSet<>();
/////////////////////////////////////////////////////////////////////////
1:         String mergeFileName = locations.getValue().getMergeFileName();
1:         if (mergeFileName != null) {
1:           CarbonFile mergeFile = FileFactory
1:               .getCarbonFile(location + CarbonCommonConstants.FILE_SEPARATOR + mergeFileName);
1:           if (mergeFile.exists() && !indexFiles.contains(mergeFile.getAbsolutePath())) {
1:             carbonIndexFiles.add(mergeFile);
1:             indexFiles.add(mergeFile.getAbsolutePath());
1:           }
1:         }
1:           if (carbonFile.exists() && !indexFiles.contains(carbonFile.getAbsolutePath())) {
1:             indexFiles.add(carbonFile.getAbsolutePath());
commit:7bfe4af
/////////////////////////////////////////////////////////////////////////
1:    * @param segmentFile
1:   public void readAllIIndexOfSegment(SegmentFileStore.SegmentFile segmentFile, String tablePath,
1:       SegmentStatus status, boolean ignoreStatus) throws IOException {
1:     if (segmentFile == null) {
1:     for (Map.Entry<String, SegmentFileStore.FolderDetails> locations : segmentFile
1:           location = tablePath + CarbonCommonConstants.FILE_SEPARATOR + location;
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.SegmentFileStore;
1: import org.apache.carbondata.core.statusmanager.SegmentStatus;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Stores the indexfile name and related binary file data in it.
1:    */
1:   private Map<String, byte[]> carbonIndexMapWithFullPath;
1: 
0:     carbonIndexMapWithFullPath = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:    * Read all index files and keep the cache in it.
1:    *
0:    * @param segmentFileStore
1:    * @throws IOException
1:    */
0:   public void readAllIIndexOfSegment(SegmentFileStore segmentFileStore, SegmentStatus status,
0:       boolean ignoreStatus) throws IOException {
1:     List<CarbonFile> carbonIndexFiles = new ArrayList<>();
0:     if (segmentFileStore.getLocationMap() == null) {
1:       return;
1:     }
0:     for (Map.Entry<String, SegmentFileStore.FolderDetails> locations : segmentFileStore
1:         .getLocationMap().entrySet()) {
1:       String location = locations.getKey();
1: 
1:       if (locations.getValue().getStatus().equals(status.getMessage()) || ignoreStatus) {
1:         if (locations.getValue().isRelative()) {
0:           location =
0:               segmentFileStore.getTablePath() + CarbonCommonConstants.FILE_SEPARATOR + location;
1:         }
1:         for (String indexFile : locations.getValue().getFiles()) {
1:           CarbonFile carbonFile = FileFactory
1:               .getCarbonFile(location + CarbonCommonConstants.FILE_SEPARATOR + indexFile);
0:           if (carbonFile.exists()) {
1:             carbonIndexFiles.add(carbonFile);
1:           }
1:         }
1:       }
1:     }
1:     for (int i = 0; i < carbonIndexFiles.size(); i++) {
1:       if (carbonIndexFiles.get(i).getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         readMergeFile(carbonIndexFiles.get(i).getCanonicalPath());
1:       } else if (carbonIndexFiles.get(i).getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:         readIndexFile(carbonIndexFiles.get(i));
1:       }
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   public Map<String, String> getIndexFilesFromSegment(String segmentPath) throws IOException {
1:     Map<String, String> indexFiles = new HashMap<>();
1:         List<String> indexFilesFromMergeFile =
1:             getIndexFilesFromMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:         for (String file: indexFilesFromMergeFile) {
1:           indexFiles.put(carbonIndexFiles[i].getParentFile().getAbsolutePath()
1:               + CarbonCommonConstants.FILE_SEPARATOR + file, carbonIndexFiles[i].getName());
1:         }
1:         indexFiles.put(carbonIndexFiles[i].getAbsolutePath(), null);
1:     return indexFiles;
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       thriftReader.open();
1:       MergedBlockIndexHeader indexHeader = readMergeBlockIndexHeader(thriftReader);
1:       MergedBlockIndex mergedBlockIndex = readMergeBlockIndex(thriftReader);
1:       List<String> file_names = indexHeader.getFile_names();
1:       List<ByteBuffer> fileData = mergedBlockIndex.getFileData();
0:       CarbonFile mergeFile = FileFactory.getCarbonFile(mergeFilePath);
1:       assert (file_names.size() == fileData.size());
1:       for (int i = 0; i < file_names.size(); i++) {
0:         carbonIndexMap.put(file_names.get(i), fileData.get(i).array());
1:         carbonIndexMapWithFullPath.put(
0:             mergeFile.getParentFile().getAbsolutePath() + CarbonCommonConstants.FILE_SEPARATOR
0:                 + file_names.get(i), fileData.get(i).array());
1:       }
1:     } finally {
1:       thriftReader.close();
/////////////////////////////////////////////////////////////////////////
0:     carbonIndexMapWithFullPath.put(
1:         indexFile.getParentFile().getAbsolutePath() + CarbonCommonConstants.FILE_SEPARATOR
1:             + indexFile.getName(), bytes);
/////////////////////////////////////////////////////////////////////////
1:   public Map<String, byte[]> getCarbonIndexMapWithFullPath() {
1:     return carbonIndexMapWithFullPath;
1:   }
1: 
commit:41b0074
/////////////////////////////////////////////////////////////////////////
1:    * Read all index files and keep the cache in it.
1:    *
1:    * @param carbonFiles
1:    * @throws IOException
1:    */
1:   public void readAllIIndexOfSegment(CarbonFile[] carbonFiles) throws IOException {
1:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(carbonFiles);
1:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:         readIndexFile(carbonIndexFiles[i]);
1:       }
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * List all the index files of the segment.
1:    *
1:    * @param carbonFiles
1:    * @return
1:    */
1:   public static CarbonFile[] getCarbonIndexFiles(CarbonFile[] carbonFiles) {
1:     List<CarbonFile> indexFiles = new ArrayList<>();
1:     for (CarbonFile file: carbonFiles) {
1:       if (file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) ||
1:           file.getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         indexFiles.add(file);
1:       }
1:     }
1:     return indexFiles.toArray(new CarbonFile[indexFiles.size()]);
1:   }
1: 
1:   /**
commit:9659edc
/////////////////////////////////////////////////////////////////////////
1:   public SegmentIndexFileStore() {
commit:17d0731
/////////////////////////////////////////////////////////////////////////
1:     dataInputStream.close();
commit:0586146
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.indexstore.blockletindex;
1: 
1: import java.io.DataInputStream;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
0: import java.util.*;
1: 
1: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
1: import org.apache.carbondata.core.datastore.filesystem.CarbonFileFilter;
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
1: import org.apache.carbondata.core.reader.ThriftReader;
1: import org.apache.carbondata.core.util.path.CarbonTablePath;
1: import org.apache.carbondata.format.MergedBlockIndex;
1: import org.apache.carbondata.format.MergedBlockIndexHeader;
1: 
1: import org.apache.thrift.TBase;
1: 
1: /**
1:  * This class manages reading of index files with in the segment. The files it read can be
1:  * carbonindex or carbonindexmerge files.
1:  */
1: public class SegmentIndexFileStore {
1: 
1:   /**
1:    * Stores the indexfile name and related binary file data in it.
1:    */
1:   private Map<String, byte[]> carbonIndexMap;
1: 
0:   public SegmentIndexFileStore() throws IOException {
1:     carbonIndexMap = new HashMap<>();
1:   }
1: 
1:   /**
1:    * Read all index files and keep the cache in it.
1:    *
1:    * @param segmentPath
1:    * @throws IOException
1:    */
1:   public void readAllIIndexOfSegment(String segmentPath) throws IOException {
0:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath);
1:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:         readIndexFile(carbonIndexFiles[i]);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Read all index file names of the segment
1:    *
1:    * @param segmentPath
1:    * @return
1:    * @throws IOException
1:    */
0:   public List<String> getIndexFilesFromSegment(String segmentPath) throws IOException {
0:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath);
0:     Set<String> indexFiles = new HashSet<>();
1:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
0:         indexFiles.addAll(getIndexFilesFromMergeFile(carbonIndexFiles[i].getCanonicalPath()));
1:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
0:         indexFiles.add(carbonIndexFiles[i].getName());
1:       }
1:     }
0:     return new ArrayList<>(indexFiles);
1:   }
1: 
1:   /**
1:    * List all the index files inside merge file.
1:    * @param mergeFile
1:    * @return
1:    * @throws IOException
1:    */
1:   public List<String> getIndexFilesFromMergeFile(String mergeFile) throws IOException {
0:     List<String> indexFiles = new ArrayList<>();
1:     ThriftReader thriftReader = new ThriftReader(mergeFile);
1:     thriftReader.open();
1:     MergedBlockIndexHeader indexHeader = readMergeBlockIndexHeader(thriftReader);
0:     List<String> file_names = indexHeader.getFile_names();
0:     indexFiles.addAll(file_names);
1:     thriftReader.close();
1:     return indexFiles;
1:   }
1: 
1:   /**
1:    * Read carbonindexmerge file and update the map
1:    *
1:    * @param mergeFilePath
1:    * @throws IOException
1:    */
0:   private void readMergeFile(String mergeFilePath) throws IOException {
0:     ThriftReader thriftReader = new ThriftReader(mergeFilePath);
1:     thriftReader.open();
1:     MergedBlockIndexHeader indexHeader = readMergeBlockIndexHeader(thriftReader);
0:     MergedBlockIndex mergedBlockIndex = readMergeBlockIndex(thriftReader);
0:     List<String> file_names = indexHeader.getFile_names();
0:     List<ByteBuffer> fileData = mergedBlockIndex.getFileData();
0:     assert (file_names.size() == fileData.size());
0:     for (int i = 0; i < file_names.size(); i++) {
0:       carbonIndexMap.put(file_names.get(i), fileData.get(i).array());
1:     }
1:     thriftReader.close();
1:   }
1: 
1:   /**
1:    * Read carbonindex file and convert to stream and add to map
1:    *
1:    * @param indexFile
1:    * @throws IOException
1:    */
1:   private void readIndexFile(CarbonFile indexFile) throws IOException {
1:     String indexFilePath = indexFile.getCanonicalPath();
0:     DataInputStream dataInputStream =
0:         FileFactory.getDataInputStream(indexFilePath, FileFactory.getFileType(indexFilePath));
1:     byte[] bytes = new byte[(int) indexFile.getSize()];
1:     dataInputStream.readFully(bytes);
1:     carbonIndexMap.put(indexFile.getName(), bytes);
1:   }
1: 
1:   private MergedBlockIndexHeader readMergeBlockIndexHeader(ThriftReader thriftReader)
1:       throws IOException {
1:     return (MergedBlockIndexHeader) thriftReader.read(new ThriftReader.TBaseCreator() {
1:       @Override public TBase create() {
1:         return new MergedBlockIndexHeader();
1:       }
1:     });
1:   }
1: 
1:   private MergedBlockIndex readMergeBlockIndex(ThriftReader thriftReader) throws IOException {
1:     return (MergedBlockIndex) thriftReader.read(new ThriftReader.TBaseCreator() {
1:       @Override public TBase create() {
1:         return new MergedBlockIndex();
1:       }
1:     });
1:   }
1: 
1:   /**
1:    * Get the carbonindex file content
1:    *
1:    * @param fileName
1:    * @return
1:    */
1:   public byte[] getFileData(String fileName) {
1:     return carbonIndexMap.get(fileName);
1:   }
1: 
1:   /**
1:    * List all the index files of the segment.
1:    *
1:    * @param segmentPath
1:    * @return
1:    */
0:   public static CarbonFile[] getCarbonIndexFiles(String segmentPath) {
0:     CarbonFile carbonFile = FileFactory.getCarbonFile(segmentPath);
1:     return carbonFile.listFiles(new CarbonFileFilter() {
1:       @Override public boolean accept(CarbonFile file) {
0:         return file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
0:             .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT);
1:       }
1:     });
1:   }
1: 
1:   /**
1:    * Return the map that contain index file name and content of the file.
1:    *
1:    * @return
1:    */
1:   public Map<String, byte[]> getCarbonIndexMap() {
1:     return carbonIndexMap;
1:   }
1: }
author:manishgupta88
-------------------------------------------------------------------------------
commit:625a2ef
/////////////////////////////////////////////////////////////////////////
1:       String filePath = FileFactory.getUpdatedFilePath(indexFile.getCanonicalPath());
commit:a20f22e
/////////////////////////////////////////////////////////////////////////
1: import java.util.TreeMap;
/////////////////////////////////////////////////////////////////////////
1:     carbonIndexMapWithFullPath = new TreeMap<>();
/////////////////////////////////////////////////////////////////////////
1:       String mergeFileAbsolutePath = mergeFile.getParentFile().getAbsolutePath();
1:         byte[] data = fileData.get(i).array();
1:         carbonIndexMap.put(file_names.get(i), data);
1:         carbonIndexMapWithFullPath
1:             .put(mergeFileAbsolutePath + CarbonCommonConstants.FILE_SEPARATOR + file_names.get(i),
1:                 data);
commit:e820006
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
1: import org.apache.carbondata.core.metadata.blocklet.BlockletInfo;
1: import org.apache.carbondata.core.metadata.blocklet.DataFileFooter;
1: import org.apache.carbondata.core.reader.CarbonIndexFileReader;
1: import org.apache.carbondata.core.util.CarbonMetadataUtil;
1: import org.apache.carbondata.core.util.CarbonUtil;
1: import org.apache.carbondata.core.util.DataFileFooterConverter;
1: import org.apache.carbondata.format.BlockIndex;
/////////////////////////////////////////////////////////////////////////
1:    * Logger constant
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(SegmentIndexFileStore.class.getName());
1:   /**
/////////////////////////////////////////////////////////////////////////
1:    * read index file and fill the blocklet information
1:    *
1:    * @param segmentPath
1:    * @throws IOException
1:    */
1:   public void readAllIndexAndFillBolckletInfo(String segmentPath) throws IOException {
0:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath);
1:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         readMergeFile(carbonIndexFiles[i].getCanonicalPath());
1:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:         readIndexAndFillBlockletInfo(carbonIndexFiles[i]);
1:       }
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * This method will read the index information from carbon index file
1:    *
1:    * @param indexFile
1:    * @return
1:    * @throws IOException
1:    */
1:   private void readIndexAndFillBlockletInfo(CarbonFile indexFile) throws IOException {
1:     // flag to take decision whether carbondata file footer reading is required.
1:     // If the index file does not contain the file footer then carbondata file footer
1:     // read is required else not required
1:     boolean isCarbonDataFileFooterReadRequired = true;
1:     List<BlockletInfo> blockletInfoList = null;
1:     List<BlockIndex> blockIndexThrift =
1:         new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:     CarbonIndexFileReader indexReader = new CarbonIndexFileReader();
1:     try {
1:       indexReader.openThriftReader(indexFile.getCanonicalPath());
1:       // get the index header
1:       org.apache.carbondata.format.IndexHeader indexHeader = indexReader.readIndexHeader();
0:       DataFileFooterConverter fileFooterConverter = new DataFileFooterConverter();
0:       String filePath = indexFile.getCanonicalPath();
1:       String parentPath =
1:           filePath.substring(0, filePath.lastIndexOf(CarbonCommonConstants.FILE_SEPARATOR));
1:       while (indexReader.hasNext()) {
1:         BlockIndex blockIndex = indexReader.readBlockIndexInfo();
1:         if (blockIndex.isSetBlocklet_info()) {
1:           // this case will come in case segment index compaction property is set to false from the
1:           // application and alter table segment index compaction is run manually. In that case
1:           // blocklet info will be present in the index but read carbon data file footer property
1:           // will be true
1:           isCarbonDataFileFooterReadRequired = false;
1:           break;
1:         } else {
1:           TableBlockInfo blockInfo =
1:               fileFooterConverter.getTableBlockInfo(blockIndex, indexHeader, parentPath);
1:           blockletInfoList = getBlockletInfoFromIndexInfo(blockInfo);
1:         }
1:         // old store which does not have the blocklet info will have 1 count per part file but in
1:         // the current code, the number of entries in the index file is equal to the total number
1:         // of blocklets in all part files for 1 task. So to make it compatible with new structure,
1:         // the same entry with different blocklet info need to be repeated
1:         for (int i = 0; i < blockletInfoList.size(); i++) {
1:           BlockIndex blockIndexReplica = blockIndex.deepCopy();
1:           BlockletInfo blockletInfo = blockletInfoList.get(i);
1:           blockIndexReplica
1:               .setBlock_index(CarbonMetadataUtil.getBlockletIndex(blockletInfo.getBlockletIndex()));
1:           blockIndexReplica
1:               .setBlocklet_info(CarbonMetadataUtil.getBlocletInfo3(blockletInfo));
1:           blockIndexThrift.add(blockIndexReplica);
1:         }
1:       }
1:       // read complete file at once
1:       if (!isCarbonDataFileFooterReadRequired) {
1:         readIndexFile(indexFile);
1:       } else {
1:         int totalSize = 0;
1:         List<byte[]> blockIndexByteArrayList =
1:             new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:         byte[] indexHeaderBytes = CarbonUtil.getByteArray(indexHeader);
1:         totalSize += indexHeaderBytes.length;
1:         blockIndexByteArrayList.add(indexHeaderBytes);
1:         for (BlockIndex blockIndex : blockIndexThrift) {
1:           byte[] indexInfoBytes = CarbonUtil.getByteArray(blockIndex);
1:           totalSize += indexInfoBytes.length;
1:           blockIndexByteArrayList.add(indexInfoBytes);
1:         }
1:         ByteBuffer byteBuffer = ByteBuffer.allocate(totalSize);
1:         for (byte[] blockIndexBytes : blockIndexByteArrayList) {
1:           byteBuffer.put(blockIndexBytes);
1:         }
1:         carbonIndexMap.put(indexFile.getName(), byteBuffer.array());
1:       }
1:     } finally {
1:       indexReader.closeThriftReader();
1:     }
1:   }
1: 
1:   /**
1:    * This method will read the blocklet info from carbon data file and fill it to index info
1:    *
1:    * @param blockInfo
1:    * @return
1:    * @throws IOException
1:    */
1:   private List<BlockletInfo> getBlockletInfoFromIndexInfo(TableBlockInfo blockInfo)
1:       throws IOException {
1:     long startTime = System.currentTimeMillis();
1:     DataFileFooter carbondataFileFooter = CarbonUtil.readMetadatFile(blockInfo);
1:     LOGGER.info(
1:         "Time taken to read carbondata file footer to get blocklet info " + blockInfo.getFilePath()
1:             + " is " + (System.currentTimeMillis() - startTime));
1:     return carbondataFileFooter.getBlockletList();
1:   }
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:5f68a79
/////////////////////////////////////////////////////////////////////////
1:    * @param carbonFile directory
1:    * @return
1:    */
1:   public static CarbonFile[] getCarbonIndexFiles(CarbonFile carbonFile) {
1:     return carbonFile.listFiles(new CarbonFileFilter() {
1:       @Override public boolean accept(CarbonFile file) {
1:         return ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:             .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0);
1:       }
1:     });
1:   }
1: 
1:   /**
1:    * List all the index files of the segment.
1:    *
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:     try {
0:       dataInputStream.readFully(bytes);
0:       carbonIndexMap.put(indexFile.getName(), bytes);
0:       carbonIndexMapWithFullPath.put(
0:           indexFile.getParentFile().getAbsolutePath() + CarbonCommonConstants.FILE_SEPARATOR
0:               + indexFile.getName(), bytes);
1:     } finally {
0:       dataInputStream.close();
1:     }
author:dhatchayani
-------------------------------------------------------------------------------
commit:531ecdf
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Stores the list of index files in a merge file
1:    */
1:   private Map<String, List<String>> carbonMergeFileToIndexFilesMap;
1: 
1:     carbonMergeFileToIndexFilesMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:    * Read all index file names of the segment
1:    *
1:    * @param segmentPath
1:    * @return
1:    * @throws IOException
1:    */
1:   public Map<String, String> getMergeOrIndexFilesFromSegment(String segmentPath)
1:       throws IOException {
0:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentPath);
1:     Map<String, String> indexFiles = new HashMap<>();
1:     for (int i = 0; i < carbonIndexFiles.length; i++) {
1:       if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:         indexFiles
1:             .put(carbonIndexFiles[i].getAbsolutePath(), carbonIndexFiles[i].getAbsolutePath());
1:       } else if (carbonIndexFiles[i].getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:         indexFiles.put(carbonIndexFiles[i].getAbsolutePath(), null);
1:       }
1:     }
0:     return indexFiles;
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1:   public void readMergeFile(String mergeFilePath) throws IOException {
1:       carbonMergeFileToIndexFilesMap.put(mergeFilePath, file_names);
/////////////////////////////////////////////////////////////////////////
1:         return ((file.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT) || file.getName()
1:             .endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) && file.getSize() > 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:   public Map<String, List<String>> getCarbonMergeFileToIndexFilesMap() {
1:     return carbonMergeFileToIndexFilesMap;
1:   }
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
author:xuchuanyin
-------------------------------------------------------------------------------
commit:910d496
/////////////////////////////////////////////////////////////////////////
1:     List<String> fileNames = indexHeader.getFile_names();
1:     return fileNames;
============================================================================