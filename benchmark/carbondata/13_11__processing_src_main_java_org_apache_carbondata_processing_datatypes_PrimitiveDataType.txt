4:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
2:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
6:cd6a4ff:  */
8:cd6a4ff: 
1:cd6a4ff: package org.apache.carbondata.processing.datatypes;
1:cd6a4ff: 
1:cd6a4ff: import java.io.DataOutputStream;
1:cd6a4ff: import java.io.IOException;
1:cd6a4ff: import java.nio.ByteBuffer;
1:3202cf5: import java.nio.charset.Charset;
1:06d38ff: import java.text.ParseException;
1:06d38ff: import java.text.SimpleDateFormat;
1:cd6a4ff: import java.util.ArrayList;
1:cd6a4ff: import java.util.List;
1:05b2654: import java.util.Map;
1:cd6a4ff: 
1:ee5f65f: import org.apache.carbondata.common.logging.LogService;
1:ee5f65f: import org.apache.carbondata.common.logging.LogServiceFactory;
1:496cde4: import org.apache.carbondata.core.cache.Cache;
1:ff5166e: import org.apache.carbondata.core.cache.CacheProvider;
1:ff5166e: import org.apache.carbondata.core.cache.CacheType;
1:496cde4: import org.apache.carbondata.core.cache.dictionary.Dictionary;
1:496cde4: import org.apache.carbondata.core.cache.dictionary.DictionaryColumnUniqueIdentifier;
1:cd6a4ff: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:6297ea0: import org.apache.carbondata.core.datastore.ColumnType;
1:438b442: import org.apache.carbondata.core.datastore.row.ComplexColumnInfo;
1:496cde4: import org.apache.carbondata.core.devapi.BiDictionary;
1:496cde4: import org.apache.carbondata.core.devapi.DictionaryGenerationException;
1:05b2654: import org.apache.carbondata.core.dictionary.client.DictionaryClient;
1:87dade7: import org.apache.carbondata.core.dictionary.generator.key.DictionaryMessage;
1:87dade7: import org.apache.carbondata.core.dictionary.generator.key.DictionaryMessageType;
1:cd6a4ff: import org.apache.carbondata.core.keygenerator.KeyGenException;
1:cd6a4ff: import org.apache.carbondata.core.keygenerator.KeyGenerator;
1:496cde4: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1:1155d4d: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:438b442: import org.apache.carbondata.core.metadata.datatype.DataType;
1:3202cf5: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:ce09aaa: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:3202cf5: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:d85fb72: import org.apache.carbondata.core.util.ByteUtil;
1:05b2654: import org.apache.carbondata.core.util.CarbonUtil;
1:cd6a4ff: import org.apache.carbondata.core.util.DataTypeUtil;
1:6b70b7e: import org.apache.carbondata.processing.loading.converter.BadRecordLogHolder;
1:349c59c: import org.apache.carbondata.processing.loading.dictionary.DictionaryServerClientDictionary;
1:349c59c: import org.apache.carbondata.processing.loading.dictionary.DirectDictionary;
1:349c59c: import org.apache.carbondata.processing.loading.dictionary.PreCreatedDictionary;
1:3202cf5: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
1:6b70b7e: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1:cd6a4ff: 
1:496cde4: /**
1:cd6a4ff:  * Primitive DataType stateless object used in data loading
1:cd6a4ff:  */
1:496cde4: public class PrimitiveDataType implements GenericDataType<Object> {
1:cd6a4ff: 
1:ee5f65f:   private static final LogService LOGGER =
1:ee5f65f:       LogServiceFactory.getLogService(PrimitiveDataType.class.getName());
1:ee5f65f: 
2:cd6a4ff:   /**
1:cd6a4ff:    * surrogate index
1:cd6a4ff:    */
1:cd6a4ff:   private int index;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * column name
1:cd6a4ff:    */
1:cd6a4ff:   private String name;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * column parent name
1:cd6a4ff:    */
1:cd6a4ff:   private String parentname;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * column unique id
1:cd6a4ff:    */
1:cd6a4ff:   private String columnId;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * key size
1:cd6a4ff:    */
1:cd6a4ff:   private int keySize;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * array index
1:cd6a4ff:    */
1:cd6a4ff:   private int outputArrayIndex;
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * data counter
1:cd6a4ff:    */
1:cd6a4ff:   private int dataCounter;
1:cd6a4ff: 
1:496cde4:   private BiDictionary<Integer, Object> dictionaryGenerator;
1:496cde4: 
1:496cde4:   private CarbonDimension carbonDimension;
1:496cde4: 
1:3202cf5:   private boolean isDictionary;
1:3202cf5: 
1:3202cf5:   private boolean isEmptyBadRecord;
1:3202cf5: 
1:3202cf5:   private String nullformat;
1:3202cf5: 
1:d85fb72:   private boolean isDirectDictionary;
1:3202cf5: 
1:438b442:   private DataType dataType;
1:438b442: 
1:8c1ddbf:   private PrimitiveDataType(int outputArrayIndex, int dataCounter) {
1:8c1ddbf:     this.outputArrayIndex = outputArrayIndex;
1:8c1ddbf:     this.dataCounter = dataCounter;
1:8c1ddbf:   }
1:8c1ddbf: 
1:06d38ff:   /**
1:496cde4:    * constructor
1:496cde4:    *
1:496cde4:    * @param name
1:438b442:    * @param parentName
1:496cde4:    * @param columnId
1:3202cf5:    * @param isDictionary
1:496cde4:    */
1:438b442:   public PrimitiveDataType(String name, DataType dataType, String parentName, String columnId,
1:438b442:       boolean isDictionary, String nullFormat, boolean isEmptyBadRecord) {
1:496cde4:     this.name = name;
1:438b442:     this.parentname = parentName;
1:496cde4:     this.columnId = columnId;
1:3202cf5:     this.isDictionary = isDictionary;
1:438b442:     this.nullformat = nullFormat;
1:3202cf5:     this.isEmptyBadRecord = isEmptyBadRecord;
1:438b442:     this.dataType = dataType;
9:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:3202cf5:    * Constructor
1:3202cf5:    * @param carbonColumn
1:438b442:    * @param parentName
1:cd6a4ff:    * @param columnId
1:3202cf5:    * @param carbonDimension
1:3202cf5:    * @param absoluteTableIdentifier
1:3202cf5:    * @param client
1:3202cf5:    * @param useOnePass
1:3202cf5:    * @param localCache
1:3202cf5:    * @param nullFormat
1:3202cf5:    * @param isEmptyBadRecords
1:cd6a4ff:    */
1:438b442:   public PrimitiveDataType(CarbonColumn carbonColumn, String parentName, String columnId,
1:ff5166e:       CarbonDimension carbonDimension, AbsoluteTableIdentifier absoluteTableIdentifier,
1:ff5166e:       DictionaryClient client, Boolean useOnePass, Map<Object, Integer> localCache,
1:ff5166e:       String nullFormat, Boolean isEmptyBadRecords) {
1:3202cf5:     this.name = carbonColumn.getColName();
1:438b442:     this.parentname = parentName;
1:cd6a4ff:     this.columnId = columnId;
1:496cde4:     this.carbonDimension = carbonDimension;
1:3202cf5:     this.isDictionary = isDictionaryDimension(carbonDimension);
1:3202cf5:     this.nullformat = nullFormat;
1:3202cf5:     this.isEmptyBadRecord = isEmptyBadRecords;
1:438b442:     this.dataType = carbonColumn.getDataType();
1:3202cf5: 
1:496cde4:     DictionaryColumnUniqueIdentifier identifier =
1:1155d4d:         new DictionaryColumnUniqueIdentifier(absoluteTableIdentifier,
1:29dc302:             carbonDimension.getColumnIdentifier(), carbonDimension.getDataType());
1:05b2654:     try {
1:d85fb72:       if (carbonDimension.hasEncoding(Encoding.DIRECT_DICTIONARY)
1:d85fb72:           || carbonColumn.getDataType() == DataTypes.DATE) {
1:496cde4:         dictionaryGenerator = new DirectDictionary(DirectDictionaryKeyGeneratorFactory
1:06d38ff:             .getDirectDictionaryGenerator(carbonDimension.getDataType(),
1:06d38ff:                 getDateFormat(carbonDimension)));
1:d85fb72:         isDirectDictionary = true;
1:3202cf5:       } else if (carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:ff5166e:         CacheProvider cacheProvider = CacheProvider.getInstance();
1:ff5166e:         Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache =
1:ff5166e:             cacheProvider.createCache(CacheType.REVERSE_DICTIONARY);
1:05b2654:         Dictionary dictionary = null;
1:05b2654:         if (useOnePass) {
1:1155d4d:           if (CarbonUtil.isFileExistsForGivenColumn(identifier)) {
1:eaadc88:             dictionary = cache.get(identifier);
1:87dade7:           }
1:87dade7:           DictionaryMessage dictionaryMessage = new DictionaryMessage();
1:87dade7:           dictionaryMessage.setColumnName(carbonDimension.getColName());
1:05b2654:           // for table initialization
1:1155d4d:           dictionaryMessage
1:1155d4d:               .setTableUniqueId(absoluteTableIdentifier.getCarbonTableIdentifier().getTableId());
1:87dade7:           dictionaryMessage.setData("0");
1:05b2654:           // for generate dictionary
1:87dade7:           dictionaryMessage.setType(DictionaryMessageType.DICT_GENERATION);
1:05b2654:           dictionaryGenerator = new DictionaryServerClientDictionary(dictionary, client,
1:87dade7:               dictionaryMessage, localCache);
1:05b2654:         } else {
2:05b2654:           dictionary = cache.get(identifier);
1:05b2654:           dictionaryGenerator = new PreCreatedDictionary(dictionary);
1:05b2654:         }
1:05b2654:       }
1:eaadc88:     } catch (IOException e) {
1:05b2654:       throw new RuntimeException(e);
1:05b2654:     }
1:496cde4:   }
1:3202cf5: 
1:cd6a4ff:   /**
1:06d38ff:    * get dateformat
1:06d38ff:    * @param carbonDimension
1:06d38ff:    * @return
1:06d38ff:    */
1:06d38ff:   private String getDateFormat(CarbonDimension carbonDimension) {
1:06d38ff:     String format;
1:06d38ff:     String dateFormat = null;
1:06d38ff:     if (this.carbonDimension.getDataType() == DataTypes.DATE) {
1:06d38ff:       dateFormat = carbonDimension.getDateFormat();
1:06d38ff:     }
1:06d38ff:     if (dateFormat != null && !dateFormat.trim().isEmpty()) {
1:06d38ff:       format = dateFormat;
1:06d38ff:     } else {
1:06d38ff:       format = CarbonUtil.getFormatFromProperty(dataType);
1:06d38ff:     }
1:06d38ff:     return format;
1:06d38ff:   }
1:06d38ff: 
1:3202cf5:   private boolean isDictionaryDimension(CarbonDimension carbonDimension) {
1:3202cf5:     if (carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:3202cf5:       return true;
1:3202cf5:     } else {
1:3202cf5:       return false;
1:3202cf5:     }
1:3202cf5:   }
1:3202cf5: 
1:cd6a4ff:   /*
1:cd6a4ff:    * primitive column will not have any child column
1:cd6a4ff:    */
5:cd6a4ff:   @Override
1:cd6a4ff:   public void addChildren(GenericDataType children) {
1:3202cf5: 
1:496cde4:   }
1:496cde4: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get column name
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public String getName() {
1:cd6a4ff:     return name;
1:496cde4:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get column parent name
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public String getParentname() {
1:cd6a4ff:     return parentname;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get column unique id
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:e710339:   public String getColumnNames() {
1:cd6a4ff:     return columnId;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * primitive column will not have any children
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public void getAllPrimitiveChildren(List<GenericDataType> primitiveChild) {
1:cd6a4ff: 
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get surrogate index
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public int getSurrogateIndex() {
1:cd6a4ff:     return index;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * set surrogate index
1:cd6a4ff:    */
1:3202cf5:   @Override public void setSurrogateIndex(int surrIndex) {
1:3202cf5:     if (this.carbonDimension != null && !this.carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:3202cf5:       index = 0;
1:3202cf5:     } else if (this.carbonDimension == null && isDictionary == false) {
1:3202cf5:       index = 0;
1:3202cf5:     } else {
1:3202cf5:       index = surrIndex;
1:3202cf5:     }
1:3202cf5:   }
1:3202cf5: 
1:3202cf5:   @Override public boolean getIsColumnDictionary() {
1:3202cf5:     return isDictionary;
1:cd6a4ff:   }
1:3202cf5: 
1:6b70b7e:   @Override public void writeByteArray(Object input, DataOutputStream dataOutputStream,
1:6b70b7e:       BadRecordLogHolder logHolder) throws IOException, DictionaryGenerationException {
1:496cde4:     String parsedValue =
1:496cde4:         input == null ? null : DataTypeUtil.parseValue(input.toString(), carbonDimension);
1:6b70b7e:     String message = logHolder.getColumnMessageMap().get(carbonDimension.getColName());
1:3202cf5:     if (this.isDictionary) {
1:3202cf5:       Integer surrogateKey;
1:3202cf5:       if (null == parsedValue) {
2:496cde4:         surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:6b70b7e:         if (null == message) {
1:6b70b7e:           message = CarbonDataProcessorUtil
1:6b70b7e:               .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:6b70b7e:           logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:6b70b7e:           logHolder.setReason(message);
1:6b70b7e:         }
1:3202cf5:       } else {
1:2f23486:         if (dictionaryGenerator instanceof DirectDictionary && input instanceof Long) {
1:2f23486:           surrogateKey = ((DirectDictionary) dictionaryGenerator).generateKey((long) input);
1:2f23486:         } else {
1:2f23486:           surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:2f23486:         }
1:3202cf5:         if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
1:3202cf5:           surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:6b70b7e:           message = CarbonDataProcessorUtil
1:6b70b7e:               .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:6b70b7e:           logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:6b70b7e:           logHolder.setReason(message);
1:3202cf5:         }
1:3202cf5:       }
1:3202cf5:       dataOutputStream.writeInt(surrogateKey);
1:3202cf5:     } else {
1:3202cf5:       // Transform into ByteArray for No Dictionary.
1:3202cf5:       // TODO have to refactor and place all the cases present in NonDictionaryFieldConverterImpl
1:3202cf5:       if (null == parsedValue && this.carbonDimension.getDataType() != DataTypes.STRING) {
1:6b70b7e:         updateNullValue(dataOutputStream, logHolder);
1:3202cf5:       } else if (null == parsedValue || parsedValue.equals(nullformat)) {
1:6b70b7e:         updateNullValue(dataOutputStream, logHolder);
1:3202cf5:       } else {
1:3202cf5:         String dateFormat = null;
1:3202cf5:         if (this.carbonDimension.getDataType() == DataTypes.DATE) {
1:6b70b7e:           dateFormat = carbonDimension.getDateFormat();
1:3202cf5:         } else if (this.carbonDimension.getDataType() == DataTypes.TIMESTAMP) {
1:6b70b7e:           dateFormat = carbonDimension.getTimestampFormat();
1:3202cf5:         }
1:3202cf5:         try {
1:3202cf5:           if (!this.carbonDimension.getUseActualData()) {
1:d85fb72:             byte[] value = null;
1:d85fb72:             if (isDirectDictionary) {
1:2f23486:               int surrogateKey;
1:06d38ff:               if (!(input instanceof Long)) {
1:06d38ff:                 SimpleDateFormat parser = new SimpleDateFormat(getDateFormat(carbonDimension));
1:06d38ff:                 parser.parse(parsedValue);
1:06d38ff:               }
1:2f23486:               // If the input is a long value then this means that logical type was provided by
1:2f23486:               // the user using AvroCarbonWriter. In this case directly generate surrogate key
1:2f23486:               // using dictionaryGenerator.
1:2f23486:               if (dictionaryGenerator instanceof DirectDictionary && input instanceof Long) {
1:2f23486:                 surrogateKey = ((DirectDictionary) dictionaryGenerator).generateKey((long) input);
1:2f23486:               } else {
1:2f23486:                 surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:2f23486:               }
1:d85fb72:               if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
1:d85fb72:                 value = new byte[0];
1:d85fb72:               } else {
1:f012f5b:                 value = ByteUtil.toXorBytes(surrogateKey);
1:d85fb72:               }
1:d85fb72:             } else {
1:2f23486:               // If the input is a long value then this means that logical type was provided by
1:2f23486:               // the user using AvroCarbonWriter. In this case directly generate Bytes from value.
1:2f23486:               if (this.carbonDimension.getDataType().equals(DataTypes.DATE)
1:2f23486:                   || this.carbonDimension.getDataType().equals(DataTypes.TIMESTAMP)
1:2f23486:                   && input instanceof Long) {
1:2f23486:                 if (dictionaryGenerator != null) {
1:f012f5b:                   value = ByteUtil.toXorBytes(((DirectDictionary) dictionaryGenerator)
1:2f23486:                       .generateKey((long) input));
1:2f23486:                 } else {
1:f012f5b:                   value = ByteUtil.toXorBytes(Long.parseLong(parsedValue));
1:2f23486:                 }
1:2f23486:               } else {
1:d85fb72:                 value = DataTypeUtil.getBytesBasedOnDataTypeForNoDictionaryColumn(parsedValue,
1:d85fb72:                     this.carbonDimension.getDataType(), dateFormat);
1:2f23486:               }
1:d85fb72:               if (this.carbonDimension.getDataType() == DataTypes.STRING
1:d85fb72:                   && value.length > CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT) {
1:d85fb72:                 throw new CarbonDataLoadingException("Dataload failed, String size cannot exceed "
1:d85fb72:                     + CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT + " bytes");
1:d85fb72:               }
1:3202cf5:             }
1:3202cf5:             updateValueToByteStream(dataOutputStream, value);
1:3202cf5:           } else {
1:2f23486:             Object value;
1:2f23486:             if (dictionaryGenerator instanceof DirectDictionary
1:2f23486:                 && input instanceof Long) {
1:f012f5b:               value = ByteUtil.toXorBytes(
1:2f23486:                   ((DirectDictionary) dictionaryGenerator).generateKey((long) input));
1:2f23486:             } else {
1:2f23486:               value = DataTypeUtil.getDataDataTypeForNoDictionaryColumn(parsedValue,
1:2f23486:                   this.carbonDimension.getDataType(), dateFormat);
1:2f23486:             }
2:3202cf5:             if (this.carbonDimension.getDataType() == DataTypes.STRING
1:3202cf5:                 && value.toString().length() > CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT) {
2:3202cf5:               throw new CarbonDataLoadingException("Dataload failed, String size cannot exceed "
2:3202cf5:                   + CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT + " bytes");
1:3202cf5:             }
1:3202cf5:             if (parsedValue.length() > 0) {
1:3202cf5:               updateValueToByteStream(dataOutputStream,
1:3202cf5:                   parsedValue.getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET)));
1:3202cf5:             } else {
1:6b70b7e:               updateNullValue(dataOutputStream, logHolder);
1:3202cf5:             }
1:3202cf5:           }
1:6b70b7e:         } catch (NumberFormatException e) {
1:6b70b7e:           // Update logHolder for bad record and put null in dataOutputStream.
1:6b70b7e:           updateNullValue(dataOutputStream, logHolder);
1:3202cf5:         } catch (CarbonDataLoadingException e) {
1:3202cf5:           throw e;
1:06d38ff:         } catch (ParseException ex) {
1:06d38ff:           updateNullValue(dataOutputStream, logHolder);
1:3202cf5:         } catch (Throwable ex) {
1:3202cf5:           // TODO have to implemented the Bad Records LogHolder.
1:3202cf5:           // Same like NonDictionaryFieldConverterImpl.
1:3202cf5:           throw ex;
1:3202cf5:         }
1:496cde4:       }
1:496cde4:     }
1:496cde4:   }
1:496cde4: 
1:3202cf5:   private void updateValueToByteStream(DataOutputStream dataOutputStream, byte[] value)
1:3202cf5:       throws IOException {
1:6297ea0:     dataOutputStream.writeShort(value.length);
1:3202cf5:     dataOutputStream.write(value);
1:3202cf5:   }
1:3202cf5: 
1:6b70b7e:   private void updateNullValue(DataOutputStream dataOutputStream, BadRecordLogHolder logHolder)
1:6b70b7e:       throws IOException {
1:3202cf5:     if (this.carbonDimension.getDataType() == DataTypes.STRING) {
1:6297ea0:       dataOutputStream.writeShort(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY.length);
1:3202cf5:       dataOutputStream.write(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY);
1:3202cf5:     } else {
1:6297ea0:       dataOutputStream.writeShort(CarbonCommonConstants.EMPTY_BYTE_ARRAY.length);
1:3202cf5:       dataOutputStream.write(CarbonCommonConstants.EMPTY_BYTE_ARRAY);
1:6b70b7e:     }
1:6b70b7e:     String message = logHolder.getColumnMessageMap().get(carbonDimension.getColName());
1:6b70b7e:     if (null == message) {
1:6b70b7e:       message = CarbonDataProcessorUtil
1:6b70b7e:           .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:6b70b7e:       logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:6b70b7e:       logHolder.setReason(message);
1:3202cf5:     }
1:3202cf5:   }
1:3202cf5: 
1:3202cf5:   @Override public void fillCardinality(List<Integer> dimCardWithComplex) {
1:3202cf5:     if (!this.carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:3202cf5:       return;
1:3202cf5:     }
1:496cde4:     dimCardWithComplex.add(dictionaryGenerator.size());
1:496cde4:   }
1:496cde4: 
1:496cde4:   @Override
1:3202cf5:   public void parseComplexValue(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream,
1:3202cf5:       KeyGenerator[] generator)
1:3202cf5:       throws IOException, KeyGenException {
1:3202cf5:     if (!this.isDictionary) {
1:6297ea0:       int sizeOfData = byteArrayInput.getShort();
1:6297ea0:       dataOutputStream.writeShort(sizeOfData);
1:3202cf5:       byte[] bb = new byte[sizeOfData];
1:3202cf5:       byteArrayInput.get(bb, 0, sizeOfData);
1:3202cf5:       dataOutputStream.write(bb);
1:3202cf5:     } else {
1:3202cf5:       int data = byteArrayInput.getInt();
1:3202cf5:       byte[] v = generator[index].generateKey(new int[] { data });
1:3202cf5:       dataOutputStream.write(v);
1:3202cf5:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get all columns count
1:496cde4:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public int getColsCount() {
1:cd6a4ff:     return 1;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * set outputarray
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public void setOutputArrayIndex(int outputArrayIndex) {
1:cd6a4ff:     this.outputArrayIndex = outputArrayIndex;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * get output array
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public int getMaxOutputArrayIndex() {
1:cd6a4ff:     return outputArrayIndex;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * split column and return metadata and primitive column
1:cd6a4ff:    */
1:7292869:   @Override public void getColumnarDataForComplexType(List<ArrayList<byte[]>> columnsArray,
1:cd6a4ff:       ByteBuffer inputArray) {
1:7292869:     if (!isDictionary) {
1:6297ea0:       byte[] key = new byte[inputArray.getShort()];
1:7292869:       inputArray.get(key);
1:7292869:       columnsArray.get(outputArrayIndex).add(key);
1:7292869:     } else {
1:7292869:       byte[] key = new byte[keySize];
1:7292869:       inputArray.get(key);
1:7292869:       columnsArray.get(outputArrayIndex).add(key);
1:7292869:     }
1:cd6a4ff:     dataCounter++;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * return datacounter
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public int getDataCounter() {
1:cd6a4ff:     return this.dataCounter;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * set key size
1:cd6a4ff:    * @param keySize
1:cd6a4ff:    */
1:cd6a4ff:   public void setKeySize(int keySize) {
1:cd6a4ff:     this.keySize = keySize;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * fill agg key block
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock) {
1:cd6a4ff:     aggKeyBlockWithComplex.add(aggKeyBlock[index]);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * fill block key size
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize) {
1:cd6a4ff:     blockKeySizeWithComplex.add(primitiveBlockKeySize[index]);
1:cd6a4ff:     this.keySize = primitiveBlockKeySize[index];
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /*
1:cd6a4ff:    * fill cardinality
1:cd6a4ff:    */
1:cd6a4ff:   @Override
1:cd6a4ff:   public void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex,
1:cd6a4ff:       int[] maxSurrogateKeyArray) {
1:cd6a4ff:     dimCardWithComplex.add(maxSurrogateKeyArray[index]);
1:8c1ddbf:   }
1:8c1ddbf: 
1:8c1ddbf:   @Override
1:8c1ddbf:   public GenericDataType<Object> deepCopy() {
1:8c1ddbf:     PrimitiveDataType dataType = new PrimitiveDataType(this.outputArrayIndex, 0);
1:3202cf5:     dataType.carbonDimension = this.carbonDimension;
1:3202cf5:     dataType.isDictionary = this.isDictionary;
1:3202cf5:     dataType.parentname = this.parentname;
1:3202cf5:     dataType.columnId = this.columnId;
1:3202cf5:     dataType.dictionaryGenerator = this.dictionaryGenerator;
1:3202cf5:     dataType.isEmptyBadRecord = this.isEmptyBadRecord;
1:3202cf5:     dataType.nullformat = this.nullformat;
1:8c1ddbf:     dataType.setKeySize(this.keySize);
1:8c1ddbf:     dataType.setSurrogateIndex(this.index);
1:e710339:     dataType.name = this.name;
1:438b442:     dataType.dataType = this.dataType;
1:8c1ddbf:     return dataType;
1:e710339:   }
1:e710339: 
1:438b442:   @Override
1:438b442:   public void getComplexColumnInfo(List<ComplexColumnInfo> columnInfoList) {
1:438b442:     columnInfoList.add(
1:438b442:         new ComplexColumnInfo(ColumnType.COMPLEX_PRIMITIVE, dataType,
1:438b442:             name, !isDictionary));
1:6297ea0:   }
1:6297ea0: 
1:7292869: }
============================================================================
author:QiangCai
-------------------------------------------------------------------------------
commit:f012f5b
/////////////////////////////////////////////////////////////////////////
1:                 value = ByteUtil.toXorBytes(surrogateKey);
/////////////////////////////////////////////////////////////////////////
1:                   value = ByteUtil.toXorBytes(((DirectDictionary) dictionaryGenerator)
1:                   value = ByteUtil.toXorBytes(Long.parseLong(parsedValue));
/////////////////////////////////////////////////////////////////////////
1:               value = ByteUtil.toXorBytes(
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:Indhumathi27
-------------------------------------------------------------------------------
commit:06d38ff
/////////////////////////////////////////////////////////////////////////
1: import java.text.ParseException;
1: import java.text.SimpleDateFormat;
/////////////////////////////////////////////////////////////////////////
1:             .getDirectDictionaryGenerator(carbonDimension.getDataType(),
1:                 getDateFormat(carbonDimension)));
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * get dateformat
1:    * @param carbonDimension
1:    * @return
1:    */
1:   private String getDateFormat(CarbonDimension carbonDimension) {
1:     String format;
1:     String dateFormat = null;
1:     if (this.carbonDimension.getDataType() == DataTypes.DATE) {
1:       dateFormat = carbonDimension.getDateFormat();
1:     }
1:     if (dateFormat != null && !dateFormat.trim().isEmpty()) {
1:       format = dateFormat;
1:     } else {
1:       format = CarbonUtil.getFormatFromProperty(dataType);
1:     }
1:     return format;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:               if (!(input instanceof Long)) {
1:                 SimpleDateFormat parser = new SimpleDateFormat(getDateFormat(carbonDimension));
1:                 parser.parse(parsedValue);
1:               }
/////////////////////////////////////////////////////////////////////////
1:         } catch (ParseException ex) {
1:           updateNullValue(dataOutputStream, logHolder);
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:438b442
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.row.ComplexColumnInfo;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
1:   private DataType dataType;
1: 
/////////////////////////////////////////////////////////////////////////
1:    * @param parentName
1:   public PrimitiveDataType(String name, DataType dataType, String parentName, String columnId,
1:       boolean isDictionary, String nullFormat, boolean isEmptyBadRecord) {
1:     this.parentname = parentName;
1:     this.nullformat = nullFormat;
1:     this.dataType = dataType;
1:    * @param parentName
/////////////////////////////////////////////////////////////////////////
1:   public PrimitiveDataType(CarbonColumn carbonColumn, String parentName, String columnId,
1:     this.parentname = parentName;
1:     this.dataType = carbonColumn.getDataType();
/////////////////////////////////////////////////////////////////////////
1:     dataType.dataType = this.dataType;
1:   @Override
1:   public void getComplexColumnInfo(List<ComplexColumnInfo> columnInfoList) {
1:     columnInfoList.add(
1:         new ComplexColumnInfo(ColumnType.COMPLEX_PRIMITIVE, dataType,
1:             name, !isDictionary));
commit:ff5166e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.cache.CacheProvider;
1: import org.apache.carbondata.core.cache.CacheType;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       CarbonDimension carbonDimension, AbsoluteTableIdentifier absoluteTableIdentifier,
1:       DictionaryClient client, Boolean useOnePass, Map<Object, Integer> localCache,
1:       String nullFormat, Boolean isEmptyBadRecords) {
/////////////////////////////////////////////////////////////////////////
1:         CacheProvider cacheProvider = CacheProvider.getInstance();
1:         Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache =
1:             cacheProvider.createCache(CacheType.REVERSE_DICTIONARY);
author:kumarvishal09
-------------------------------------------------------------------------------
commit:e710339
/////////////////////////////////////////////////////////////////////////
1:   public String getColumnNames() {
/////////////////////////////////////////////////////////////////////////
1:     dataType.name = this.name;
1: 
0:   @Override public void getColumnNames(List<String> columnNameList) {
0:     columnNameList.add(name);
1:   }
commit:6297ea0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.ColumnType;
/////////////////////////////////////////////////////////////////////////
1:     dataOutputStream.writeShort(value.length);
1:       dataOutputStream.writeShort(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY.length);
1:       dataOutputStream.writeShort(CarbonCommonConstants.EMPTY_BYTE_ARRAY.length);
/////////////////////////////////////////////////////////////////////////
1:       int sizeOfData = byteArrayInput.getShort();
1:       dataOutputStream.writeShort(sizeOfData);
/////////////////////////////////////////////////////////////////////////
1:       byte[] key = new byte[inputArray.getShort()];
/////////////////////////////////////////////////////////////////////////
1: 
0:   public void getChildrenType(List<ColumnType> type) {
0:     type.add(ColumnType.COMPLEX_PRIMITIVE);
1:   }
commit:d85fb72
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.ByteUtil;
/////////////////////////////////////////////////////////////////////////
1:   private boolean isDirectDictionary;
/////////////////////////////////////////////////////////////////////////
1:       if (carbonDimension.hasEncoding(Encoding.DIRECT_DICTIONARY)
1:           || carbonColumn.getDataType() == DataTypes.DATE) {
1:         isDirectDictionary = true;
/////////////////////////////////////////////////////////////////////////
1:             byte[] value = null;
1:             if (isDirectDictionary) {
0:               int surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:               if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
1:                 value = new byte[0];
1:               } else {
0:                 value = ByteUtil.toBytes(surrogateKey);
1:               }
1:             } else {
1:               value = DataTypeUtil.getBytesBasedOnDataTypeForNoDictionaryColumn(parsedValue,
1:                   this.carbonDimension.getDataType(), dateFormat);
1:               if (this.carbonDimension.getDataType() == DataTypes.STRING
1:                   && value.length > CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT) {
1:                 throw new CarbonDataLoadingException("Dataload failed, String size cannot exceed "
1:                     + CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT + " bytes");
1:               }
commit:7292869
/////////////////////////////////////////////////////////////////////////
0:       dataOutputStream.writeInt(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY.length);
0:       dataOutputStream.writeInt(CarbonCommonConstants.EMPTY_BYTE_ARRAY.length);
/////////////////////////////////////////////////////////////////////////
1:   @Override public void getColumnarDataForComplexType(List<ArrayList<byte[]>> columnsArray,
1:     if (!isDictionary) {
0:       byte[] key = new byte[inputArray.getInt()];
1:       inputArray.get(key);
1:       columnsArray.get(outputArrayIndex).add(key);
1:     } else {
1:       byte[] key = new byte[keySize];
1:       inputArray.get(key);
1:       columnsArray.get(outputArrayIndex).add(key);
1:     }
/////////////////////////////////////////////////////////////////////////
1: }
author:kunal642
-------------------------------------------------------------------------------
commit:2f23486
/////////////////////////////////////////////////////////////////////////
1:         if (dictionaryGenerator instanceof DirectDictionary && input instanceof Long) {
1:           surrogateKey = ((DirectDictionary) dictionaryGenerator).generateKey((long) input);
1:         } else {
1:           surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:         }
/////////////////////////////////////////////////////////////////////////
1:               int surrogateKey;
1:               // If the input is a long value then this means that logical type was provided by
1:               // the user using AvroCarbonWriter. In this case directly generate surrogate key
1:               // using dictionaryGenerator.
1:               if (dictionaryGenerator instanceof DirectDictionary && input instanceof Long) {
1:                 surrogateKey = ((DirectDictionary) dictionaryGenerator).generateKey((long) input);
1:               } else {
1:                 surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:               }
1:               // If the input is a long value then this means that logical type was provided by
1:               // the user using AvroCarbonWriter. In this case directly generate Bytes from value.
1:               if (this.carbonDimension.getDataType().equals(DataTypes.DATE)
1:                   || this.carbonDimension.getDataType().equals(DataTypes.TIMESTAMP)
1:                   && input instanceof Long) {
1:                 if (dictionaryGenerator != null) {
0:                   value = ByteUtil.toBytes(((DirectDictionary) dictionaryGenerator)
1:                       .generateKey((long) input));
1:                 } else {
0:                   value = ByteUtil.toBytes(Long.parseLong(parsedValue));
1:                 }
1:               } else {
0:                 value = DataTypeUtil.getBytesBasedOnDataTypeForNoDictionaryColumn(parsedValue,
1:                     this.carbonDimension.getDataType(), dateFormat);
1:               }
/////////////////////////////////////////////////////////////////////////
1:             Object value;
1:             if (dictionaryGenerator instanceof DirectDictionary
1:                 && input instanceof Long) {
0:               value = ByteUtil.toBytes(
1:                   ((DirectDictionary) dictionaryGenerator).generateKey((long) input));
1:             } else {
1:               value = DataTypeUtil.getDataDataTypeForNoDictionaryColumn(parsedValue,
0:                   this.carbonDimension.getDataType(), dateFormat);
1:             }
commit:6b70b7e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.converter.BadRecordLogHolder;
1: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
/////////////////////////////////////////////////////////////////////////
1:   @Override public void writeByteArray(Object input, DataOutputStream dataOutputStream,
1:       BadRecordLogHolder logHolder) throws IOException, DictionaryGenerationException {
1:     String message = logHolder.getColumnMessageMap().get(carbonDimension.getColName());
1:         if (null == message) {
1:           message = CarbonDataProcessorUtil
1:               .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:           logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:           logHolder.setReason(message);
1:         }
1:           message = CarbonDataProcessorUtil
1:               .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:           logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:           logHolder.setReason(message);
/////////////////////////////////////////////////////////////////////////
1:         updateNullValue(dataOutputStream, logHolder);
1:         updateNullValue(dataOutputStream, logHolder);
1:           dateFormat = carbonDimension.getDateFormat();
1:           dateFormat = carbonDimension.getTimestampFormat();
/////////////////////////////////////////////////////////////////////////
1:               updateNullValue(dataOutputStream, logHolder);
1:         } catch (NumberFormatException e) {
1:           // Update logHolder for bad record and put null in dataOutputStream.
1:           updateNullValue(dataOutputStream, logHolder);
/////////////////////////////////////////////////////////////////////////
1:   private void updateNullValue(DataOutputStream dataOutputStream, BadRecordLogHolder logHolder)
1:       throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     String message = logHolder.getColumnMessageMap().get(carbonDimension.getColName());
1:     if (null == message) {
1:       message = CarbonDataProcessorUtil
1:           .prepareFailureReason(carbonDimension.getColName(), carbonDimension.getDataType());
1:       logHolder.getColumnMessageMap().put(carbonDimension.getColName(), message);
1:       logHolder.setReason(message);
1:     }
commit:ee5f65f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
/////////////////////////////////////////////////////////////////////////
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(PrimitiveDataType.class.getName());
1: 
/////////////////////////////////////////////////////////////////////////
0:       String storePath, Map<Object, Integer> localCache) {
/////////////////////////////////////////////////////////////////////////
0:           dictionaryMessage.setTableUniqueId(carbonTableIdentifier.getTableId());
author:sounakr
-------------------------------------------------------------------------------
commit:3202cf5
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonColumn;
1: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
/////////////////////////////////////////////////////////////////////////
1:   private boolean isDictionary;
1: 
1:   private boolean isEmptyBadRecord;
1: 
1:   private String nullformat;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:    * @param dimensionOrdinal
1:    * @param isDictionary
0:   public PrimitiveDataType(String name, String parentname, String columnId, int dimensionOrdinal,
0:       boolean isDictionary, String nullformat, boolean isEmptyBadRecord) {
1:     this.isDictionary = isDictionary;
0:     this.nullformat = nullformat;
1:     this.isEmptyBadRecord = isEmptyBadRecord;
1:    * Constructor
1:    * @param carbonColumn
1:    * @param carbonDimension
0:    * @param cache
1:    * @param absoluteTableIdentifier
1:    * @param client
1:    * @param useOnePass
1:    * @param localCache
1:    * @param nullFormat
1:    * @param isEmptyBadRecords
0:   public PrimitiveDataType(CarbonColumn carbonColumn, String parentname, String columnId,
0:       Map<Object, Integer> localCache, String nullFormat, Boolean isEmptyBadRecords) {
1:     this.name = carbonColumn.getColName();
1:     this.isDictionary = isDictionaryDimension(carbonDimension);
1:     this.nullformat = nullFormat;
1:     this.isEmptyBadRecord = isEmptyBadRecords;
1: 
/////////////////////////////////////////////////////////////////////////
1:       } else if (carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
/////////////////////////////////////////////////////////////////////////
1:   private boolean isDictionaryDimension(CarbonDimension carbonDimension) {
1:     if (carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:       return true;
1:     } else {
1:       return false;
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   @Override public void setSurrogateIndex(int surrIndex) {
1:     if (this.carbonDimension != null && !this.carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:       index = 0;
1:     } else if (this.carbonDimension == null && isDictionary == false) {
1:       index = 0;
1:     } else {
1:       index = surrIndex;
1:     }
1:   }
1: 
1:   @Override public boolean getIsColumnDictionary() {
1:     return isDictionary;
1: 
1:     if (this.isDictionary) {
1:       Integer surrogateKey;
1:       if (null == parsedValue) {
1:       } else {
0:         surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
1:         if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
1:           surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:         }
1:       }
1:       dataOutputStream.writeInt(surrogateKey);
1:     } else {
1:       // Transform into ByteArray for No Dictionary.
1:       // TODO have to refactor and place all the cases present in NonDictionaryFieldConverterImpl
1:       if (null == parsedValue && this.carbonDimension.getDataType() != DataTypes.STRING) {
0:         updateNullValue(dataOutputStream);
1:       } else if (null == parsedValue || parsedValue.equals(nullformat)) {
0:         updateNullValue(dataOutputStream);
1:       } else {
1:         String dateFormat = null;
1:         if (this.carbonDimension.getDataType() == DataTypes.DATE) {
0:           dateFormat = this.carbonDimension.getDateFormat();
1:         } else if (this.carbonDimension.getDataType() == DataTypes.TIMESTAMP) {
0:           dateFormat = this.carbonDimension.getTimestampFormat();
1:         }
1: 
1:         try {
1:           if (!this.carbonDimension.getUseActualData()) {
0:             byte[] value = DataTypeUtil.getBytesBasedOnDataTypeForNoDictionaryColumn(parsedValue,
0:                 this.carbonDimension.getDataType(), dateFormat);
1:             if (this.carbonDimension.getDataType() == DataTypes.STRING
0:                 && value.length > CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT) {
1:               throw new CarbonDataLoadingException("Dataload failed, String size cannot exceed "
1:                   + CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT + " bytes");
1:             }
1:             updateValueToByteStream(dataOutputStream, value);
1:           } else {
0:             Object value = DataTypeUtil.getDataDataTypeForNoDictionaryColumn(parsedValue,
0:                 this.carbonDimension.getDataType(), dateFormat);
1:             if (this.carbonDimension.getDataType() == DataTypes.STRING
1:                 && value.toString().length() > CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT) {
1:               throw new CarbonDataLoadingException("Dataload failed, String size cannot exceed "
1:                   + CarbonCommonConstants.MAX_CHARS_PER_COLUMN_DEFAULT + " bytes");
1:             }
1:             if (parsedValue.length() > 0) {
1:               updateValueToByteStream(dataOutputStream,
1:                   parsedValue.getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET)));
1:             } else {
0:               updateNullValue(dataOutputStream);
1:             }
1:           }
1:         } catch (CarbonDataLoadingException e) {
1:           throw e;
1:         } catch (Throwable ex) {
1:           // TODO have to implemented the Bad Records LogHolder.
1:           // Same like NonDictionaryFieldConverterImpl.
1:           throw ex;
1:         }
1:   private void updateValueToByteStream(DataOutputStream dataOutputStream, byte[] value)
1:       throws IOException {
0:     dataOutputStream.writeInt(value.length);
1:     dataOutputStream.write(value);
1:   }
1: 
0:   private void updateNullValue(DataOutputStream dataOutputStream) throws IOException {
1:     if (this.carbonDimension.getDataType() == DataTypes.STRING) {
1:       dataOutputStream.write(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY);
1:     } else {
1:       dataOutputStream.write(CarbonCommonConstants.EMPTY_BYTE_ARRAY);
1:     }
1:   }
1: 
1:   @Override public void fillCardinality(List<Integer> dimCardWithComplex) {
1:     if (!this.carbonDimension.hasEncoding(Encoding.DICTIONARY)) {
1:       return;
1:     }
1:   public void parseComplexValue(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream,
1:       KeyGenerator[] generator)
1:       throws IOException, KeyGenException {
1:     if (!this.isDictionary) {
0:       int sizeOfData = byteArrayInput.getInt();
0:       dataOutputStream.writeInt(sizeOfData);
1:       byte[] bb = new byte[sizeOfData];
1:       byteArrayInput.get(bb, 0, sizeOfData);
1:       dataOutputStream.write(bb);
1:     } else {
1:       int data = byteArrayInput.getInt();
1:       byte[] v = generator[index].generateKey(new int[] { data });
1:       dataOutputStream.write(v);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     dataType.carbonDimension = this.carbonDimension;
1:     dataType.isDictionary = this.isDictionary;
1:     dataType.parentname = this.parentname;
1:     dataType.columnId = this.columnId;
1:     dataType.dictionaryGenerator = this.dictionaryGenerator;
1:     dataType.isEmptyBadRecord = this.isEmptyBadRecord;
1:     dataType.nullformat = this.nullformat;
1: 
author:manishgupta88
-------------------------------------------------------------------------------
commit:29dc302
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             carbonDimension.getColumnIdentifier(), carbonDimension.getDataType());
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
/////////////////////////////////////////////////////////////////////////
0:       AbsoluteTableIdentifier absoluteTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       Map<Object, Integer> localCache) {
1:         new DictionaryColumnUniqueIdentifier(absoluteTableIdentifier,
0:             CarbonStorePath.getCarbonTablePath(absoluteTableIdentifier));
/////////////////////////////////////////////////////////////////////////
1:           if (CarbonUtil.isFileExistsForGivenColumn(identifier)) {
1:           dictionaryMessage
1:               .setTableUniqueId(absoluteTableIdentifier.getCarbonTableIdentifier().getTableId());
author:Jacky Li
-------------------------------------------------------------------------------
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.dictionary.DictionaryServerClientDictionary;
1: import org.apache.carbondata.processing.loading.dictionary.DirectDictionary;
1: import org.apache.carbondata.processing.loading.dictionary.PreCreatedDictionary;
commit:8c1ddbf
/////////////////////////////////////////////////////////////////////////
1:   private PrimitiveDataType(int outputArrayIndex, int dataCounter) {
1:     this.outputArrayIndex = outputArrayIndex;
1:     this.dataCounter = dataCounter;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:     byte[] v = generator[index].generateKey(new int[] { data });
0:     dataOutputStream.write(v);
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override
1:   public GenericDataType<Object> deepCopy() {
1:     PrimitiveDataType dataType = new PrimitiveDataType(this.outputArrayIndex, 0);
1:     dataType.setKeySize(this.keySize);
1:     dataType.setSurrogateIndex(this.index);
1:     return dataType;
1:   }
commit:f089287
/////////////////////////////////////////////////////////////////////////
author:dhatchayani
-------------------------------------------------------------------------------
commit:d3a09e2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.util.path.CarbonStorePath;
/////////////////////////////////////////////////////////////////////////
0:             carbonDimension.getColumnIdentifier(), carbonDimension.getDataType(),
0:             CarbonStorePath.getCarbonTablePath(storePath, carbonTableIdentifier));
author:Raghunandan S
-------------------------------------------------------------------------------
commit:06b0d08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:jackylk
-------------------------------------------------------------------------------
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastore.GenericDataType;
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.CarbonTableIdentifier;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             dictionary = cache.get(identifier);
/////////////////////////////////////////////////////////////////////////
1:     } catch (IOException e) {
commit:3fe6903
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:ravipesala
-------------------------------------------------------------------------------
commit:e6b6090
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:87dade7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.dictionary.generator.key.DictionaryMessage;
1: import org.apache.carbondata.core.dictionary.generator.key.DictionaryMessageType;
/////////////////////////////////////////////////////////////////////////
0:       CarbonDimension carbonDimension, Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:       CarbonTableIdentifier carbonTableIdentifier, DictionaryClient client, Boolean useOnePass,
0:       String storePath, boolean tableInitialize, Map<Object, Integer> localCache) {
/////////////////////////////////////////////////////////////////////////
1:           DictionaryMessage dictionaryMessage = new DictionaryMessage();
1:           dictionaryMessage.setColumnName(carbonDimension.getColName());
0:           dictionaryMessage.setTableUniqueName(carbonTableIdentifier.getTableUniqueName());
0:           dictionaryMessage.setType(DictionaryMessageType.TABLE_INTIALIZATION);
1:           dictionaryMessage.setData("0");
0:           if (tableInitialize) {
0:             client.getDictionary(dictionaryMessage);
1:           }
1:           dictionaryMessage.setType(DictionaryMessageType.DICT_GENERATION);
1:               dictionaryMessage, localCache);
commit:05b2654
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.dictionary.client.DictionaryClient;
0: import org.apache.carbondata.core.dictionary.generator.key.DictionaryKey;
1: import org.apache.carbondata.core.util.CarbonUtil;
0: import org.apache.carbondata.processing.newflow.dictionary.DictionaryServerClientDictionary;
/////////////////////////////////////////////////////////////////////////
0:                            CarbonDimension carbonDimension,
0:                            Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:                            CarbonTableIdentifier carbonTableIdentifier,
0:                            DictionaryClient client, Boolean useOnePass, String storePath) {
/////////////////////////////////////////////////////////////////////////
1:         Dictionary dictionary = null;
1:         if (useOnePass) {
0:           if (CarbonUtil.isFileExistsForGivenColumn(storePath, identifier)) {
1:             try {
1:               dictionary = cache.get(identifier);
0:             } catch (CarbonUtilException e) {
1:               throw new RuntimeException(e);
1:             }
1:           }
0:           String threadNo = "initial";
0:           DictionaryKey dictionaryKey = new DictionaryKey();
0:           dictionaryKey.setColumnName(carbonDimension.getColName());
0:           dictionaryKey.setTableUniqueName(carbonTableIdentifier.getTableUniqueName());
0:           dictionaryKey.setThreadNo(threadNo);
1:           // for table initialization
0:           dictionaryKey.setType("TABLE_INTIALIZATION");
0:           dictionaryKey.setData("0");
0:           client.getDictionary(dictionaryKey);
0:           Map<Object, Integer> localCache = new HashMap<>();
1:           // for generate dictionary
0:           dictionaryKey.setType("DICTIONARY_GENERATION");
1:           dictionaryGenerator = new DictionaryServerClientDictionary(dictionary, client,
0:                   dictionaryKey, localCache);
1:         } else {
1:           dictionary = cache.get(identifier);
1:           dictionaryGenerator = new PreCreatedDictionary(dictionary);
1:         }
commit:496cde4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.cache.Cache;
1: import org.apache.carbondata.core.cache.dictionary.Dictionary;
1: import org.apache.carbondata.core.cache.dictionary.DictionaryColumnUniqueIdentifier;
0: import org.apache.carbondata.core.carbon.CarbonTableIdentifier;
0: import org.apache.carbondata.core.carbon.metadata.encoder.Encoding;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.devapi.BiDictionary;
1: import org.apache.carbondata.core.devapi.DictionaryGenerationException;
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
0: import org.apache.carbondata.core.util.CarbonUtilException;
0: import org.apache.carbondata.processing.newflow.dictionary.DirectDictionary;
0: import org.apache.carbondata.processing.newflow.dictionary.PreCreatedDictionary;
/////////////////////////////////////////////////////////////////////////
1: public class PrimitiveDataType implements GenericDataType<Object> {
/////////////////////////////////////////////////////////////////////////
1:   private BiDictionary<Integer, Object> dictionaryGenerator;
1: 
1:   private CarbonDimension carbonDimension;
1: 
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * constructor
1:    *
1:    * @param name
0:    * @param parentname
1:    * @param columnId
1:    */
0:   public PrimitiveDataType(String name, String parentname, String columnId,
0:       CarbonDimension carbonDimension, Cache<DictionaryColumnUniqueIdentifier, Dictionary> cache,
0:       CarbonTableIdentifier carbonTableIdentifier) {
1:     this.name = name;
0:     this.parentname = parentname;
1:     this.columnId = columnId;
1:     this.carbonDimension = carbonDimension;
1:     DictionaryColumnUniqueIdentifier identifier =
0:         new DictionaryColumnUniqueIdentifier(carbonTableIdentifier,
0:             carbonDimension.getColumnIdentifier(), carbonDimension.getDataType());
0:     try {
0:       if (carbonDimension.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:         dictionaryGenerator = new DirectDictionary(DirectDictionaryKeyGeneratorFactory
0:             .getDirectDictionaryGenerator(carbonDimension.getDataType()));
0:       } else {
0:         Dictionary dictionary = cache.get(identifier);
0:         dictionaryGenerator = new PreCreatedDictionary(dictionary);
1:       }
0:     } catch (CarbonUtilException e) {
0:       throw new RuntimeException(e);
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
0:   @Override public void writeByteArray(Object input, DataOutputStream dataOutputStream)
0:       throws IOException, DictionaryGenerationException {
1:     String parsedValue =
1:         input == null ? null : DataTypeUtil.parseValue(input.toString(), carbonDimension);
0:     Integer surrogateKey;
0:     if (null == parsedValue) {
1:       surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
0:     } else {
0:       surrogateKey = dictionaryGenerator.getOrGenerateKey(parsedValue);
0:       if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
1:         surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:       }
1:     }
0:     dataOutputStream.writeInt(surrogateKey);
1:   }
1: 
1:   @Override
0:   public void fillCardinality(List<Integer> dimCardWithComplex) {
1:     dimCardWithComplex.add(dictionaryGenerator.size());
1:   }
1: 
0:        * parse bytearray and bit pack
1:        */
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.processing.datatypes;
1: 
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.keygenerator.KeyGenException;
1: import org.apache.carbondata.core.keygenerator.KeyGenerator;
1: import org.apache.carbondata.core.util.DataTypeUtil;
0: import org.apache.carbondata.processing.surrogatekeysgenerator.csvbased.CarbonCSVBasedDimSurrogateKeyGen;
1: 
0: import org.pentaho.di.core.exception.KettleException;
1: 
1: /**
1:  * Primitive DataType stateless object used in data loading
1:  */
0: public class PrimitiveDataType implements GenericDataType {
1: 
1:   /**
1:    * surrogate index
1:    */
1:   private int index;
1: 
1:   /**
1:    * column name
1:    */
1:   private String name;
1: 
1:   /**
1:    * column parent name
1:    */
1:   private String parentname;
1: 
1:   /**
1:    * column unique id
1:    */
1:   private String columnId;
1: 
1:   /**
0:    * dimension ordinal of primitive type column
1:    */
0:   private int dimensionOrdinal;
1: 
1:   /**
1:    * key size
1:    */
1:   private int keySize;
1: 
1:   /**
1:    * array index
1:    */
1:   private int outputArrayIndex;
1: 
1:   /**
1:    * data counter
1:    */
1:   private int dataCounter;
1: 
1:   /**
0:    * constructor
1:    *
0:    * @param name
0:    * @param parentname
1:    * @param columnId
1:    */
0:   public PrimitiveDataType(String name, String parentname, String columnId, int dimensionOrdinal) {
0:     this.name = name;
0:     this.parentname = parentname;
1:     this.columnId = columnId;
0:     this.dimensionOrdinal = dimensionOrdinal;
1:   }
1: 
1:   /*
1:    * primitive column will not have any child column
1:    */
1:   @Override
1:   public void addChildren(GenericDataType children) {
1: 
1:   }
1: 
1:   /*
1:    * get column name
1:    */
1:   @Override
1:   public String getName() {
1:     return name;
1:   }
1: 
1:   /*
0:    * set column name
1:    */
1:   @Override
0:   public void setName(String name) {
0:     this.name = name;
1:   }
1: 
1:   /*
1:    * get column parent name
1:    */
1:   @Override
1:   public String getParentname() {
1:     return parentname;
1:   }
1: 
1:   /*
1:    * get column unique id
1:    */
1:   @Override
0:   public String getColumnId() {
1:     return columnId;
1:   }
1: 
1:   /*
1:    * primitive column will not have any children
1:    */
1:   @Override
1:   public void getAllPrimitiveChildren(List<GenericDataType> primitiveChild) {
1: 
1:   }
1: 
1:   /*
1:    * get surrogate index
1:    */
1:   @Override
1:   public int getSurrogateIndex() {
1:     return index;
1:   }
1: 
1:   /*
1:    * set surrogate index
1:    */
1:   @Override
0:   public void setSurrogateIndex(int surrIndex) {
0:     index = surrIndex;
1:   }
1: 
1:   /*
0:    * parse string and generate surrogate
1:    */
0:   @Override public void parseStringAndWriteByteArray(String tableName, String inputString,
0:       String[] delimiter, int delimiterIndex, DataOutputStream dataOutputStream,
0:       CarbonCSVBasedDimSurrogateKeyGen surrogateKeyGen) throws KettleException, IOException {
0:     String parsedValue = DataTypeUtil.parseValue(inputString,
0:         surrogateKeyGen.getDimensionOrdinalToDimensionMapping()[dimensionOrdinal]);
0:     Integer surrogateKey = null;
0:     if (null == parsedValue) {
0:       surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
0:     } else {
0:       surrogateKey = surrogateKeyGen
0:           .generateSurrogateKeys(parsedValue, tableName + CarbonCommonConstants.UNDERSCORE + name,
0:               this.getColumnId());
0:       if (surrogateKey == CarbonCommonConstants.INVALID_SURROGATE_KEY) {
0:         surrogateKey = CarbonCommonConstants.MEMBER_DEFAULT_VAL_SURROGATE_KEY;
1:       }
1:     }
0:     dataOutputStream.writeInt(surrogateKey);
1:   }
1: 
1:   /*
0:    * parse bytearray and bit pack
1:    */
1:   @Override
0:   public void parseAndBitPack(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream,
0:       KeyGenerator[] generator) throws IOException, KeyGenException {
0:     int data = byteArrayInput.getInt();
0:     dataOutputStream.write(generator[index].generateKey(new int[] { data }));
1:   }
1: 
1:   /*
1:    * get all columns count
1:    */
1:   @Override
1:   public int getColsCount() {
1:     return 1;
1:   }
1: 
1:   /*
1:    * set outputarray
1:    */
1:   @Override
1:   public void setOutputArrayIndex(int outputArrayIndex) {
1:     this.outputArrayIndex = outputArrayIndex;
1:   }
1: 
1:   /*
1:    * get output array
1:    */
1:   @Override
1:   public int getMaxOutputArrayIndex() {
1:     return outputArrayIndex;
1:   }
1: 
1:   /*
1:    * split column and return metadata and primitive column
1:    */
1:   @Override
0:   public void getColumnarDataForComplexType(List<ArrayList<byte[]>> columnsArray,
1:       ByteBuffer inputArray) {
0:     byte[] key = new byte[keySize];
0:     inputArray.get(key);
0:     columnsArray.get(outputArrayIndex).add(key);
1:     dataCounter++;
1:   }
1: 
1:   /*
1:    * return datacounter
1:    */
1:   @Override
1:   public int getDataCounter() {
1:     return this.dataCounter;
1:   }
1: 
1:   /**
1:    * set key size
1:    * @param keySize
1:    */
1:   public void setKeySize(int keySize) {
1:     this.keySize = keySize;
1:   }
1: 
1:   /*
1:    * fill agg key block
1:    */
1:   @Override
1:   public void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock) {
1:     aggKeyBlockWithComplex.add(aggKeyBlock[index]);
1:   }
1: 
1:   /*
1:    * fill block key size
1:    */
1:   @Override
1:   public void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize) {
1:     blockKeySizeWithComplex.add(primitiveBlockKeySize[index]);
1:     this.keySize = primitiveBlockKeySize[index];
1:   }
1: 
1:   /*
1:    * fill cardinality
1:    */
1:   @Override
1:   public void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex,
1:       int[] maxSurrogateKeyArray) {
1:     dimCardWithComplex.add(maxSurrogateKeyArray[index]);
1:   }
1: }
============================================================================