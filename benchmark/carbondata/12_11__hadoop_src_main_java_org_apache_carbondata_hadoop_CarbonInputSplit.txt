1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:cd6a4ff:  */
1:cd6a4ff: package org.apache.carbondata.hadoop;
1:cd6a4ff: 
1:cd6a4ff: import java.io.DataInput;
1:cd6a4ff: import java.io.DataOutput;
1:cd6a4ff: import java.io.IOException;
1:cd6a4ff: import java.io.Serializable;
1:2b66476: import java.nio.charset.Charset;
1:5f6a56c: import java.util.ArrayList;
1:427b202: import java.util.HashMap;
1:edb02ab: import java.util.List;
1:427b202: import java.util.Map;
1:cd6a4ff: 
1:d54dc64: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:8d3c774: import org.apache.carbondata.core.datamap.Segment;
1:ce09aaa: import org.apache.carbondata.core.datastore.block.BlockletInfos;
1:ce09aaa: import org.apache.carbondata.core.datastore.block.Distributable;
1:ce09aaa: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
1:3ff574d: import org.apache.carbondata.core.indexstore.Blocklet;
1:b681244: import org.apache.carbondata.core.indexstore.BlockletDetailInfo;
1:ce09aaa: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
1:ce09aaa: import org.apache.carbondata.core.mutate.UpdateVO;
1:d7393da: import org.apache.carbondata.core.statusmanager.FileFormat;
1:3807b2f: import org.apache.carbondata.core.util.ByteUtil;
1:0ef3fb8: import org.apache.carbondata.core.util.CarbonProperties;
1:ce09aaa: import org.apache.carbondata.core.util.path.CarbonTablePath;
1:edb02ab: import org.apache.carbondata.hadoop.internal.index.Block;
1:988ccd8: 
1:cd6a4ff: import org.apache.hadoop.fs.Path;
1:cd6a4ff: import org.apache.hadoop.io.Writable;
1:cd6a4ff: import org.apache.hadoop.mapreduce.lib.input.FileSplit;
1:cd6a4ff: 
1:cd6a4ff: /**
1:a324e5d:  * Carbon input split to allow distributed read of CarbonTableInputFormat.
1:cd6a4ff:  */
1:d54dc64: public class CarbonInputSplit extends FileSplit
1:d54dc64:     implements Distributable, Serializable, Writable, Block {
1:cd6a4ff: 
1:cd6a4ff:   private static final long serialVersionUID = 3520344046772190207L;
1:5f6a56c:   public String taskId;
1:cbf8797: 
1:60dfdd3:   private Segment segment;
1:cbf8797: 
1:cbf8797:   private String bucketId;
1:cd6a4ff: 
1:0c8fa59:   private String blockletId;
1:5f6a56c:   /*
1:5f6a56c:    * Invalid segments that need to be removed in task side index
1:5f6a56c:    */
1:5f6a56c:   private List<String> invalidSegments;
1:0c8fa59: 
1:5f6a56c:   /*
1:fe1b0f0:    * Number of BlockLets in a block
1:fe1b0f0:    */
1:5f6a56c:   private int numberOfBlocklets;
1:d54dc64: 
1:0ef3fb8:   private ColumnarFormatVersion version;
1:d54dc64: 
1:427b202:   /**
1:427b202:    * map of blocklocation and storage id
1:427b202:    */
1:427b202:   private Map<String, String> blockStorageIdMap =
1:0c8fa59:       new HashMap<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1:5f6a56c: 
1:d0b4a98:   private List<UpdateVO> invalidTimestampsList;
1:5f6a56c: 
1:8a5ed81:   /**
1:8a5ed81:    * list of delete delta files for split
1:8a5ed81:    */
1:8a5ed81:   private String[] deleteDeltaFiles;
1:8a5ed81: 
1:b681244:   private BlockletDetailInfo detailInfo;
1:b681244: 
1:ee71610:   private FileFormat fileFormat = FileFormat.COLUMNAR_V3;
1:d7393da: 
1:d35fbaf:   private String dataMapWritePath;
1:d35fbaf: 
1:cd6a4ff:   public CarbonInputSplit() {
1:60dfdd3:     segment = null;
1:5f6a56c:     taskId = "0";
1:cbf8797:     bucketId = "0";
1:0c8fa59:     blockletId = "0";
1:5f6a56c:     numberOfBlocklets = 0;
1:5f6a56c:     invalidSegments = new ArrayList<>();
1:0ef3fb8:     version = CarbonProperties.getInstance().getFormatVersion();
1:cd6a4ff:   }
1:cbf8797: 
1:0c8fa59:   private CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
1:d35fbaf:       String[] locations, ColumnarFormatVersion version, String[] deleteDeltaFiles,
1:d35fbaf:       String dataMapWritePath) {
1:cd6a4ff:     super(path, start, length, locations);
1:60dfdd3:     this.segment = Segment.toSegment(segmentId);
1:3807b2f:     String taskNo = CarbonTablePath.DataFileUtil.getTaskNo(path.getName());
1:3807b2f:     if (taskNo.contains("_")) {
1:3807b2f:       taskNo = taskNo.split("_")[0];
1:3807b2f:     }
1:3807b2f:     this.taskId = taskNo;
1:cbf8797:     this.bucketId = CarbonTablePath.DataFileUtil.getBucketNo(path.getName());
1:0c8fa59:     this.blockletId = blockletId;
1:5f6a56c:     this.invalidSegments = new ArrayList<>();
1:d54dc64:     this.version = version;
1:8a5ed81:     this.deleteDeltaFiles = deleteDeltaFiles;
1:d35fbaf:     this.dataMapWritePath = dataMapWritePath;
1:cd6a4ff:   }
1:cd6a4ff: 
1:0c8fa59:   public CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
1:0c8fa59:       String[] locations, int numberOfBlocklets, ColumnarFormatVersion version,
1:0c8fa59:       String[] deleteDeltaFiles) {
1:d35fbaf:     this(segmentId, blockletId, path, start, length, locations, version, deleteDeltaFiles, null);
1:fe1b0f0:     this.numberOfBlocklets = numberOfBlocklets;
1:cd6a4ff:   }
1:cd6a4ff: 
1:d7393da:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
1:d7393da:       FileFormat fileFormat) {
1:d7393da:     super(path, start, length, locations);
1:60dfdd3:     this.segment = Segment.toSegment(segmentId);
1:d7393da:     this.fileFormat = fileFormat;
1:d7393da:     taskId = "0";
1:d7393da:     bucketId = "0";
1:0c8fa59:     blockletId = "0";
1:d7393da:     numberOfBlocklets = 0;
1:d7393da:     invalidSegments = new ArrayList<>();
1:d7393da:     version = CarbonProperties.getInstance().getFormatVersion();
1:d7393da:   }
1:cd6a4ff: 
1:d7393da:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
1:d7393da:       String[] inMemoryHosts, FileFormat fileFormat) {
1:d7393da:     super(path, start, length, locations, inMemoryHosts);
1:60dfdd3:     this.segment = Segment.toSegment(segmentId);
1:d7393da:     this.fileFormat = fileFormat;
1:d7393da:     taskId = "0";
1:d7393da:     bucketId = "0";
1:0c8fa59:     blockletId = "0";
1:d7393da:     numberOfBlocklets = 0;
1:d7393da:     invalidSegments = new ArrayList<>();
1:d7393da:     version = CarbonProperties.getInstance().getFormatVersion();
1:d7393da:   }
1:cd6a4ff: 
1:427b202:   /**
1:427b202:    * Constructor to initialize the CarbonInputSplit with blockStorageIdMap
1:427b202:    * @param segmentId
1:427b202:    * @param path
1:427b202:    * @param start
1:427b202:    * @param length
1:427b202:    * @param locations
1:427b202:    * @param numberOfBlocklets
1:427b202:    * @param version
1:427b202:    * @param blockStorageIdMap
1:427b202:    */
1:0c8fa59:   public CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
1:0c8fa59:       String[] locations, int numberOfBlocklets, ColumnarFormatVersion version,
1:0c8fa59:       Map<String, String> blockStorageIdMap, String[] deleteDeltaFiles) {
1:0c8fa59:     this(segmentId, blockletId, path, start, length, locations, numberOfBlocklets, version,
1:0c8fa59:         deleteDeltaFiles);
1:427b202:     this.blockStorageIdMap = blockStorageIdMap;
1:d54dc64:   }
1:d7393da: 
1:0c8fa59:   public static CarbonInputSplit from(String segmentId, String blockletId, FileSplit split,
1:d35fbaf:       ColumnarFormatVersion version, String dataMapWritePath) throws IOException {
1:0c8fa59:     return new CarbonInputSplit(segmentId, blockletId, split.getPath(), split.getStart(),
1:d35fbaf:         split.getLength(), split.getLocations(), version, null, dataMapWritePath);
1:5f6a56c:   }
1:d7393da: 
1:d54dc64:   public static List<TableBlockInfo> createBlocks(List<CarbonInputSplit> splitList) {
1:d54dc64:     List<TableBlockInfo> tableBlockInfoList = new ArrayList<>();
1:d54dc64:     for (CarbonInputSplit split : splitList) {
1:d54dc64:       BlockletInfos blockletInfos =
1:d54dc64:           new BlockletInfos(split.getNumberOfBlocklets(), 0, split.getNumberOfBlocklets());
1:d54dc64:       try {
1:b681244:         TableBlockInfo blockInfo =
1:0c8fa59:             new TableBlockInfo(split.getPath().toString(), split.blockletId, split.getStart(),
1:60dfdd3:                 split.getSegment().toString(), split.getLocations(), split.getLength(),
1:60dfdd3:                 blockletInfos, split.getVersion(), split.getDeleteDeltaFiles());
1:b681244:         blockInfo.setDetailInfo(split.getDetailInfo());
1:d35fbaf:         blockInfo.setDataMapWriterPath(split.dataMapWritePath);
1:7ed144c:         blockInfo.setBlockOffset(split.getDetailInfo().getBlockFooterOffset());
1:b681244:         tableBlockInfoList.add(blockInfo);
1:d54dc64:       } catch (IOException e) {
1:d54dc64:         throw new RuntimeException("fail to get location of split: " + split, e);
1:d54dc64:       }
1:d54dc64:     }
1:d54dc64:     return tableBlockInfoList;
1:d54dc64:   }
1:d54dc64: 
1:d54dc64:   public static TableBlockInfo getTableBlockInfo(CarbonInputSplit inputSplit) {
1:d54dc64:     BlockletInfos blockletInfos =
1:d54dc64:         new BlockletInfos(inputSplit.getNumberOfBlocklets(), 0, inputSplit.getNumberOfBlocklets());
1:d54dc64:     try {
1:b681244:       TableBlockInfo blockInfo =
1:0c8fa59:           new TableBlockInfo(inputSplit.getPath().toString(), inputSplit.blockletId,
1:60dfdd3:               inputSplit.getStart(), inputSplit.getSegment().toString(), inputSplit.getLocations(),
1:0c8fa59:               inputSplit.getLength(), blockletInfos, inputSplit.getVersion(),
1:0c8fa59:               inputSplit.getDeleteDeltaFiles());
1:b681244:       blockInfo.setDetailInfo(inputSplit.getDetailInfo());
1:7ed144c:       blockInfo.setBlockOffset(inputSplit.getDetailInfo().getBlockFooterOffset());
1:b681244:       return blockInfo;
1:d54dc64:     } catch (IOException e) {
1:d54dc64:       throw new RuntimeException("fail to get location of split: " + inputSplit, e);
1:d54dc64:     }
1:d0b4a98:   }
1:d0b4a98: 
1:cd6a4ff:   public String getSegmentId() {
1:60dfdd3:     if (segment != null) {
1:60dfdd3:       return segment.getSegmentNo();
1:60dfdd3:     } else {
1:60dfdd3:       return null;
1:60dfdd3:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:60dfdd3:   public Segment getSegment() {
1:60dfdd3:     return segment;
1:60dfdd3:   }
1:60dfdd3: 
1:60dfdd3: 
1:cd6a4ff:   @Override public void readFields(DataInput in) throws IOException {
1:cd6a4ff:     super.readFields(in);
1:60dfdd3:     this.segment = Segment.toSegment(in.readUTF());
1:0ef3fb8:     this.version = ColumnarFormatVersion.valueOf(in.readShort());
1:cbf8797:     this.bucketId = in.readUTF();
1:0c8fa59:     this.blockletId = in.readUTF();
1:5f6a56c:     int numInvalidSegment = in.readInt();
1:5f6a56c:     invalidSegments = new ArrayList<>(numInvalidSegment);
1:5f6a56c:     for (int i = 0; i < numInvalidSegment; i++) {
1:5f6a56c:       invalidSegments.add(in.readUTF());
1:cd6a4ff:     }
1:8a5ed81:     int numberOfDeleteDeltaFiles = in.readInt();
1:8a5ed81:     deleteDeltaFiles = new String[numberOfDeleteDeltaFiles];
1:8a5ed81:     for (int i = 0; i < numberOfDeleteDeltaFiles; i++) {
1:8a5ed81:       deleteDeltaFiles[i] = in.readUTF();
1:8a5ed81:     }
1:b681244:     boolean detailInfoExists = in.readBoolean();
1:b681244:     if (detailInfoExists) {
1:b681244:       detailInfo = new BlockletDetailInfo();
1:b681244:       detailInfo.readFields(in);
1:b681244:     }
1:d35fbaf:     boolean dataMapWriterPathExists = in.readBoolean();
1:d35fbaf:     if (dataMapWriterPathExists) {
1:d35fbaf:       dataMapWritePath = in.readUTF();
1:d35fbaf:     }
1:5f6a56c:   }
1:cd6a4ff: 
1:cd6a4ff:   @Override public void write(DataOutput out) throws IOException {
1:cd6a4ff:     super.write(out);
1:60dfdd3:     out.writeUTF(segment.toString());
1:0ef3fb8:     out.writeShort(version.number());
1:cbf8797:     out.writeUTF(bucketId);
1:0c8fa59:     out.writeUTF(blockletId);
1:5f6a56c:     out.writeInt(invalidSegments.size());
1:d54dc64:     for (String invalidSegment : invalidSegments) {
1:5f6a56c:       out.writeUTF(invalidSegment);
1:cd6a4ff:     }
1:8a5ed81:     out.writeInt(null != deleteDeltaFiles ? deleteDeltaFiles.length : 0);
1:8a5ed81:     if (null != deleteDeltaFiles) {
1:8a5ed81:       for (int i = 0; i < deleteDeltaFiles.length; i++) {
1:8a5ed81:         out.writeUTF(deleteDeltaFiles[i]);
1:cd6a4ff:       }
1:8a5ed81:     }
1:b681244:     out.writeBoolean(detailInfo != null);
1:b681244:     if (detailInfo != null) {
1:b681244:       detailInfo.write(out);
1:b681244:     }
1:d35fbaf:     out.writeBoolean(dataMapWritePath != null);
1:d35fbaf:     if (dataMapWritePath != null) {
1:d35fbaf:       out.writeUTF(dataMapWritePath);
1:d35fbaf:     }
1:8a5ed81:   }
1:cd6a4ff: 
1:d54dc64:   public List<String> getInvalidSegments() {
1:5f6a56c:     return invalidSegments;
1:5f6a56c:   }
1:cd6a4ff: 
1:8d3c774:   public void setInvalidSegments(List<Segment> invalidSegments) {
1:8d3c774:     List<String> invalidSegmentIds = new ArrayList<>();
1:8d3c774:     for (Segment segment: invalidSegments) {
1:8d3c774:       invalidSegmentIds.add(segment.getSegmentNo());
1:8d3c774:     }
1:8d3c774:     this.invalidSegments = invalidSegmentIds;
1:5f6a56c:   }
1:5f6a56c: 
1:d0b4a98:   public void setInvalidTimestampRange(List<UpdateVO> invalidTimestamps) {
1:d0b4a98:     invalidTimestampsList = invalidTimestamps;
1:5f6a56c:   }
1:5f6a56c: 
1:d0b4a98:   public List<UpdateVO> getInvalidTimestampRange() {
1:d0b4a98:     return invalidTimestampsList;
1:d0b4a98:   }
1:d0b4a98: 
1:fe1b0f0:   /**
1:fe1b0f0:    * returns the number of blocklets
1:d54dc64:    *
1:fe1b0f0:    * @return
1:fe1b0f0:    */
1:fe1b0f0:   public int getNumberOfBlocklets() {
1:fe1b0f0:     return numberOfBlocklets;
1:d54dc64:   }
1:d54dc64: 
1:0ef3fb8:   public ColumnarFormatVersion getVersion() {
1:d54dc64:     return version;
1:d54dc64:   }
1:d54dc64: 
1:0ef3fb8:   public void setVersion(ColumnarFormatVersion version) {
1:d54dc64:     this.version = version;
1:edb02ab:   }
1:edb02ab: 
1:cbf8797:   public String getBucketId() {
1:cbf8797:     return bucketId;
1:cbf8797:   }
1:cbf8797: 
1:0c8fa59:   public String getBlockletId() { return blockletId; }
1:0c8fa59: 
1:d54dc64:   @Override public int compareTo(Distributable o) {
1:18cfba8:     if (o == null) {
1:18cfba8:       return -1;
1:18cfba8:     }
1:d54dc64:     CarbonInputSplit other = (CarbonInputSplit) o;
1:5f6a56c:     int compareResult = 0;
1:5f6a56c:     // get the segment id
1:5f6a56c:     // converr seg ID to double.
1:5f6a56c: 
1:60dfdd3:     double seg1 = Double.parseDouble(segment.getSegmentNo());
1:5f6a56c:     double seg2 = Double.parseDouble(other.getSegmentId());
1:5f6a56c:     if (seg1 - seg2 < 0) {
1:5f6a56c:       return -1;
1:edb02ab:     }
1:5f6a56c:     if (seg1 - seg2 > 0) {
1:5f6a56c:       return 1;
1:5f6a56c:     }
1:5f6a56c: 
1:5f6a56c:     // Comparing the time task id of the file to other
1:5f6a56c:     // if both the task id of the file is same then we need to compare the
1:5f6a56c:     // offset of
1:5f6a56c:     // the file
1:5f6a56c:     String filePath1 = this.getPath().getName();
1:5f6a56c:     String filePath2 = other.getPath().getName();
1:5f6a56c:     if (CarbonTablePath.isCarbonDataFile(filePath1)) {
1:2b66476:       byte[] firstTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath1)
1:2b66476:           .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:2b66476:       byte[] otherTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath2)
1:2b66476:           .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:3807b2f:       int compare = ByteUtil.compare(firstTaskId, otherTaskId);
1:3807b2f:       if (compare != 0) {
1:3807b2f:         return compare;
1:5f6a56c:       }
1:d0b4a98: 
1:cbf8797:       int firstBucketNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getBucketNo(filePath1));
1:cbf8797:       int otherBucketNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getBucketNo(filePath2));
1:cbf8797:       if (firstBucketNo != otherBucketNo) {
1:cbf8797:         return firstBucketNo - otherBucketNo;
1:cbf8797:       }
1:cbf8797: 
1:5f6a56c:       // compare the part no of both block info
1:5f6a56c:       int firstPartNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getPartNo(filePath1));
1:5f6a56c:       int SecondPartNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getPartNo(filePath2));
1:5f6a56c:       compareResult = firstPartNo - SecondPartNo;
1:5f6a56c:     } else {
1:5f6a56c:       compareResult = filePath1.compareTo(filePath2);
1:5f6a56c:     }
1:5f6a56c:     if (compareResult != 0) {
1:5f6a56c:       return compareResult;
1:5f6a56c:     }
1:5f6a56c:     return 0;
1:5f6a56c:   }
1:5f6a56c: 
1:1be0778:   @Override public boolean equals(Object obj) {
1:1be0778:     if (this == obj) {
1:1be0778:       return true;
1:1be0778:     }
1:1be0778: 
1:1be0778:     if (!(obj instanceof CarbonInputSplit)) {
1:1be0778:       return false;
1:1be0778:     }
1:1be0778:     CarbonInputSplit other = (CarbonInputSplit) obj;
1:1be0778:     return 0 == this.compareTo(other);
1:1be0778:   }
1:1be0778: 
1:1be0778:   @Override public int hashCode() {
1:1be0778:     int result = taskId.hashCode();
1:60dfdd3:     result = 31 * result + segment.hashCode();
1:1be0778:     result = 31 * result + bucketId.hashCode();
1:1be0778:     result = 31 * result + invalidSegments.hashCode();
1:1be0778:     result = 31 * result + numberOfBlocklets;
1:1be0778:     return result;
1:1be0778:   }
1:1be0778: 
1:d54dc64:   @Override public String getBlockPath() {
1:edb02ab:     return getPath().getName();
1:5f6a56c:   }
1:5f6a56c: 
1:d54dc64:   @Override public List<Long> getMatchedBlocklets() {
1:edb02ab:     return null;
1:5f6a56c:   }
1:edb02ab: 
1:d54dc64:   @Override public boolean fullScan() {
1:edb02ab:     return true;
1:5f6a56c:   }
1:427b202: 
1:427b202:   /**
1:427b202:    * returns map of blocklocation and storage id
1:427b202:    * @return
1:427b202:    */
1:427b202:   public Map<String, String> getBlockStorageIdMap() {
1:427b202:     return blockStorageIdMap;
1:edb02ab:   }
1:8a5ed81: 
1:8a5ed81:   public String[] getDeleteDeltaFiles() {
1:8a5ed81:     return deleteDeltaFiles;
1:8a5ed81:   }
1:b681244: 
1:b681244:   public void setDeleteDeltaFiles(String[] deleteDeltaFiles) {
1:b681244:     this.deleteDeltaFiles = deleteDeltaFiles;
1:b681244:   }
1:b681244: 
1:b681244:   public BlockletDetailInfo getDetailInfo() {
1:b681244:     return detailInfo;
1:b681244:   }
1:b681244: 
1:b681244:   public void setDetailInfo(BlockletDetailInfo detailInfo) {
1:b681244:     this.detailInfo = detailInfo;
1:b681244:   }
1:d7393da: 
1:d7393da:   public FileFormat getFileFormat() {
1:d7393da:     return fileFormat;
1:d7393da:   }
1:d7393da: 
1:d7393da:   public void setFormat(FileFormat fileFormat) {
1:d7393da:     this.fileFormat = fileFormat;
1:d7393da:   }
1:3ff574d: 
1:3ff574d:   public Blocklet makeBlocklet() {
1:3ff574d:     return new Blocklet(getPath().getName(), blockletId);
1:3ff574d:   }
1:427b202: }
============================================================================
author:ravipesala
-------------------------------------------------------------------------------
commit:60dfdd3
/////////////////////////////////////////////////////////////////////////
1:   private Segment segment;
/////////////////////////////////////////////////////////////////////////
1:     segment = null;
/////////////////////////////////////////////////////////////////////////
1:     this.segment = Segment.toSegment(segmentId);
/////////////////////////////////////////////////////////////////////////
1:     this.segment = Segment.toSegment(segmentId);
/////////////////////////////////////////////////////////////////////////
1:     this.segment = Segment.toSegment(segmentId);
/////////////////////////////////////////////////////////////////////////
1:                 split.getSegment().toString(), split.getLocations(), split.getLength(),
1:                 blockletInfos, split.getVersion(), split.getDeleteDeltaFiles());
/////////////////////////////////////////////////////////////////////////
1:               inputSplit.getStart(), inputSplit.getSegment().toString(), inputSplit.getLocations(),
/////////////////////////////////////////////////////////////////////////
1:     if (segment != null) {
1:       return segment.getSegmentNo();
1:     } else {
1:       return null;
1:     }
1:   public Segment getSegment() {
1:     return segment;
1:   }
1: 
1: 
1:     this.segment = Segment.toSegment(in.readUTF());
/////////////////////////////////////////////////////////////////////////
1:     out.writeUTF(segment.toString());
/////////////////////////////////////////////////////////////////////////
1:     double seg1 = Double.parseDouble(segment.getSegmentNo());
/////////////////////////////////////////////////////////////////////////
1:     result = 31 * result + segment.hashCode();
commit:d35fbaf
/////////////////////////////////////////////////////////////////////////
1:   private String dataMapWritePath;
1: 
/////////////////////////////////////////////////////////////////////////
1:       String[] locations, ColumnarFormatVersion version, String[] deleteDeltaFiles,
1:       String dataMapWritePath) {
/////////////////////////////////////////////////////////////////////////
1:     this.dataMapWritePath = dataMapWritePath;
1:     this(segmentId, blockletId, path, start, length, locations, version, deleteDeltaFiles, null);
/////////////////////////////////////////////////////////////////////////
1:       ColumnarFormatVersion version, String dataMapWritePath) throws IOException {
1:         split.getLength(), split.getLocations(), version, null, dataMapWritePath);
/////////////////////////////////////////////////////////////////////////
1:         blockInfo.setDataMapWriterPath(split.dataMapWritePath);
/////////////////////////////////////////////////////////////////////////
1:     boolean dataMapWriterPathExists = in.readBoolean();
1:     if (dataMapWriterPathExists) {
1:       dataMapWritePath = in.readUTF();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     out.writeBoolean(dataMapWritePath != null);
1:     if (dataMapWritePath != null) {
1:       out.writeUTF(dataMapWritePath);
1:     }
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.Segment;
/////////////////////////////////////////////////////////////////////////
1:   public void setInvalidSegments(List<Segment> invalidSegments) {
1:     List<String> invalidSegmentIds = new ArrayList<>();
1:     for (Segment segment: invalidSegments) {
1:       invalidSegmentIds.add(segment.getSegmentNo());
1:     }
1:     this.invalidSegments = invalidSegmentIds;
commit:b681244
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.BlockletDetailInfo;
/////////////////////////////////////////////////////////////////////////
1:   private BlockletDetailInfo detailInfo;
1: 
/////////////////////////////////////////////////////////////////////////
1:         TableBlockInfo blockInfo =
0:                 split.getDeleteDeltaFiles());
1:         blockInfo.setDetailInfo(split.getDetailInfo());
1:         tableBlockInfoList.add(blockInfo);
/////////////////////////////////////////////////////////////////////////
1:       TableBlockInfo blockInfo =
0:           new TableBlockInfo(inputSplit.getPath().toString(), inputSplit.getStart(),
0:               inputSplit.getSegmentId(), inputSplit.getLocations(), inputSplit.getLength(),
0:               blockletInfos, inputSplit.getVersion(), inputSplit.getDeleteDeltaFiles());
1:       blockInfo.setDetailInfo(inputSplit.getDetailInfo());
1:       return blockInfo;
/////////////////////////////////////////////////////////////////////////
1:     boolean detailInfoExists = in.readBoolean();
1:     if (detailInfoExists) {
1:       detailInfo = new BlockletDetailInfo();
1:       detailInfo.readFields(in);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     out.writeBoolean(detailInfo != null);
1:     if (detailInfo != null) {
1:       detailInfo.write(out);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:   public void setDeleteDeltaFiles(String[] deleteDeltaFiles) {
1:     this.deleteDeltaFiles = deleteDeltaFiles;
1:   }
1: 
1:   public BlockletDetailInfo getDetailInfo() {
1:     return detailInfo;
1:   }
1: 
1:   public void setDetailInfo(BlockletDetailInfo detailInfo) {
1:     this.detailInfo = detailInfo;
1:   }
commit:3807b2f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.ByteUtil;
/////////////////////////////////////////////////////////////////////////
1:     String taskNo = CarbonTablePath.DataFileUtil.getTaskNo(path.getName());
1:     if (taskNo.contains("_")) {
1:       taskNo = taskNo.split("_")[0];
1:     }
1:     this.taskId = taskNo;
/////////////////////////////////////////////////////////////////////////
0:       byte[] firstTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath1).getBytes();
0:       byte[] otherTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath2).getBytes();
1:       int compare = ByteUtil.compare(firstTaskId, otherTaskId);
1:       if (compare != 0) {
1:         return compare;
commit:cbf8797
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:   private String bucketId;
/////////////////////////////////////////////////////////////////////////
1:     bucketId = "0";
/////////////////////////////////////////////////////////////////////////
1:     this.bucketId = CarbonTablePath.DataFileUtil.getBucketNo(path.getName());
/////////////////////////////////////////////////////////////////////////
1:     this.bucketId = in.readUTF();
/////////////////////////////////////////////////////////////////////////
1:     out.writeUTF(bucketId);
/////////////////////////////////////////////////////////////////////////
1:   public String getBucketId() {
1:     return bucketId;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:       int firstBucketNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getBucketNo(filePath1));
1:       int otherBucketNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getBucketNo(filePath2));
1:       if (firstBucketNo != otherBucketNo) {
1:         return firstBucketNo - otherBucketNo;
1:       }
1: 
commit:988ccd8
/////////////////////////////////////////////////////////////////////////
1: 
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.carbondata.hadoop;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.Serializable;
1: 
1: import org.apache.hadoop.fs.Path;
1: import org.apache.hadoop.io.Writable;
1: import org.apache.hadoop.mapreduce.lib.input.FileSplit;
1: 
1: /**
0:  * Carbon input split to allow distributed read of CarbonInputFormat.
1:  */
0: public class CarbonInputSplit extends FileSplit implements Serializable, Writable {
1: 
1:   private static final long serialVersionUID = 3520344046772190207L;
0:   private String segmentId;
1: 
1:   public CarbonInputSplit() {
0:     super(null, 0, 0, new String[0]);
1:   }
1: 
0:   public CarbonInputSplit(String segmentId, Path path, long start, long length,
0:       String[] locations) {
1:     super(path, start, length, locations);
0:     this.segmentId = segmentId;
1:   }
1: 
0:   public static CarbonInputSplit from(String segmentId, FileSplit split) throws IOException {
0:     return new CarbonInputSplit(segmentId, split.getPath(), split.getStart(), split.getLength(),
0:         split.getLocations());
1:   }
1: 
1:   public String getSegmentId() {
0:     return segmentId;
1:   }
1: 
1:   @Override public void readFields(DataInput in) throws IOException {
1: 
1:     super.readFields(in);
0:     this.segmentId = in.readUTF();
1: 
1:   }
1: 
1:   @Override public void write(DataOutput out) throws IOException {
1:     super.write(out);
0:     out.writeUTF(segmentId);
1:   }
1: 
1: }
author:Jacky Li
-------------------------------------------------------------------------------
commit:3ff574d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.Blocklet;
/////////////////////////////////////////////////////////////////////////
1: 
1:   public Blocklet makeBlocklet() {
1:     return new Blocklet(getPath().getName(), blockletId);
1:   }
commit:a324e5d
/////////////////////////////////////////////////////////////////////////
1:  * Carbon input split to allow distributed read of CarbonTableInputFormat.
commit:ee71610
/////////////////////////////////////////////////////////////////////////
1:   private FileFormat fileFormat = FileFormat.COLUMNAR_V3;
author:manishgupta88
-------------------------------------------------------------------------------
commit:7ed144c
/////////////////////////////////////////////////////////////////////////
1:         blockInfo.setBlockOffset(split.getDetailInfo().getBlockFooterOffset());
/////////////////////////////////////////////////////////////////////////
1:       blockInfo.setBlockOffset(inputSplit.getDetailInfo().getBlockFooterOffset());
commit:2b66476
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:       byte[] firstTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath1)
1:           .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       byte[] otherTaskId = CarbonTablePath.DataFileUtil.getTaskNo(filePath2)
1:           .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
author:anubhav100
-------------------------------------------------------------------------------
commit:0c8fa59
/////////////////////////////////////////////////////////////////////////
1: 
1:   private String blockletId;
/////////////////////////////////////////////////////////////////////////
1:       new HashMap<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
/////////////////////////////////////////////////////////////////////////
1:     blockletId = "0";
1:   private CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
0:       String[] locations, ColumnarFormatVersion version, String[] deleteDeltaFiles) {
/////////////////////////////////////////////////////////////////////////
1:     this.blockletId = blockletId;
1:   public CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
1:       String[] locations, int numberOfBlocklets, ColumnarFormatVersion version,
1:       String[] deleteDeltaFiles) {
0:     this(segmentId, blockletId, path, start, length, locations, version, deleteDeltaFiles);
/////////////////////////////////////////////////////////////////////////
1:     blockletId = "0";
/////////////////////////////////////////////////////////////////////////
1:     blockletId = "0";
/////////////////////////////////////////////////////////////////////////
1:   public CarbonInputSplit(String segmentId, String blockletId, Path path, long start, long length,
1:       String[] locations, int numberOfBlocklets, ColumnarFormatVersion version,
1:       Map<String, String> blockStorageIdMap, String[] deleteDeltaFiles) {
1:     this(segmentId, blockletId, path, start, length, locations, numberOfBlocklets, version,
1:         deleteDeltaFiles);
1:   public static CarbonInputSplit from(String segmentId, String blockletId, FileSplit split,
0:       ColumnarFormatVersion version) throws IOException {
1:     return new CarbonInputSplit(segmentId, blockletId, split.getPath(), split.getStart(),
0:         split.getLength(), split.getLocations(), version, null);
/////////////////////////////////////////////////////////////////////////
1:             new TableBlockInfo(split.getPath().toString(), split.blockletId, split.getStart(),
0:                 split.getSegmentId(), split.getLocations(), split.getLength(), blockletInfos,
0:                 split.getVersion(), split.getDeleteDeltaFiles());
/////////////////////////////////////////////////////////////////////////
1:           new TableBlockInfo(inputSplit.getPath().toString(), inputSplit.blockletId,
0:               inputSplit.getStart(), inputSplit.getSegmentId(), inputSplit.getLocations(),
1:               inputSplit.getLength(), blockletInfos, inputSplit.getVersion(),
1:               inputSplit.getDeleteDeltaFiles());
/////////////////////////////////////////////////////////////////////////
1:     this.blockletId = in.readUTF();
/////////////////////////////////////////////////////////////////////////
1:     out.writeUTF(blockletId);
/////////////////////////////////////////////////////////////////////////
1:   public String getBlockletId() { return blockletId; }
1: 
author:QiangCai
-------------------------------------------------------------------------------
commit:d7393da
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.statusmanager.FileFormat;
/////////////////////////////////////////////////////////////////////////
0:   private FileFormat fileFormat = FileFormat.carbondata;
1: 
/////////////////////////////////////////////////////////////////////////
1:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
1:       FileFormat fileFormat) {
1:     super(path, start, length, locations);
0:     this.segmentId = segmentId;
1:     this.fileFormat = fileFormat;
1:     taskId = "0";
1:     bucketId = "0";
1:     numberOfBlocklets = 0;
1:     invalidSegments = new ArrayList<>();
1:     version = CarbonProperties.getInstance().getFormatVersion();
1:   }
1: 
1:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
1:       String[] inMemoryHosts, FileFormat fileFormat) {
1:     super(path, start, length, locations, inMemoryHosts);
0:     this.segmentId = segmentId;
1:     this.fileFormat = fileFormat;
1:     taskId = "0";
1:     bucketId = "0";
1:     numberOfBlocklets = 0;
1:     invalidSegments = new ArrayList<>();
1:     version = CarbonProperties.getInstance().getFormatVersion();
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   public FileFormat getFileFormat() {
1:     return fileFormat;
1:   }
1: 
1:   public void setFormat(FileFormat fileFormat) {
1:     this.fileFormat = fileFormat;
1:   }
commit:b6b93f0
/////////////////////////////////////////////////////////////////////////
0:       int firstTaskId =
0:           Integer.parseInt(CarbonTablePath.DataFileUtil.getTaskNo(filePath1).split("_")[0]);
0:       int otherTaskId =
0:           Integer.parseInt(CarbonTablePath.DataFileUtil.getTaskNo(filePath2).split("_")[0]);
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:Raghunandan S
-------------------------------------------------------------------------------
commit:1be0778
/////////////////////////////////////////////////////////////////////////
1:   @Override public boolean equals(Object obj) {
1:     if (this == obj) {
1:       return true;
1:     }
1: 
1:     if (!(obj instanceof CarbonInputSplit)) {
1:       return false;
1:     }
1:     CarbonInputSplit other = (CarbonInputSplit) obj;
1:     return 0 == this.compareTo(other);
1:   }
1: 
1:   @Override public int hashCode() {
1:     int result = taskId.hashCode();
0:     result = 31 * result + segmentId.hashCode();
1:     result = 31 * result + bucketId.hashCode();
1:     result = 31 * result + invalidSegments.hashCode();
1:     result = 31 * result + numberOfBlocklets;
1:     return result;
1:   }
1: 
author:kumarvishal
-------------------------------------------------------------------------------
commit:8a5ed81
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * list of delete delta files for split
1:    */
1:   private String[] deleteDeltaFiles;
1: 
/////////////////////////////////////////////////////////////////////////
0:       ColumnarFormatVersion version, String[] deleteDeltaFiles) {
/////////////////////////////////////////////////////////////////////////
1:     this.deleteDeltaFiles = deleteDeltaFiles;
0:       int numberOfBlocklets, ColumnarFormatVersion version, String[] deleteDeltaFiles) {
0:     this(segmentId, path, start, length, locations, version, deleteDeltaFiles);
/////////////////////////////////////////////////////////////////////////
0:       int numberOfBlocklets, ColumnarFormatVersion version, Map<String, String> blockStorageIdMap,
0:       String[] deleteDeltaFiles) {
0:     this(segmentId, path, start, length, locations, numberOfBlocklets, version, deleteDeltaFiles);
/////////////////////////////////////////////////////////////////////////
0:         split.getLocations(), version, null);
/////////////////////////////////////////////////////////////////////////
0:                 split.getLocations(), split.getLength(), blockletInfos, split.getVersion(),
0:                 split.getDeleteDeltaFiles()));
/////////////////////////////////////////////////////////////////////////
0:           blockletInfos, inputSplit.getVersion(), inputSplit.getDeleteDeltaFiles());
/////////////////////////////////////////////////////////////////////////
1:     int numberOfDeleteDeltaFiles = in.readInt();
1:     deleteDeltaFiles = new String[numberOfDeleteDeltaFiles];
1:     for (int i = 0; i < numberOfDeleteDeltaFiles; i++) {
1:       deleteDeltaFiles[i] = in.readUTF();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     out.writeInt(null != deleteDeltaFiles ? deleteDeltaFiles.length : 0);
1:     if (null != deleteDeltaFiles) {
1:       for (int i = 0; i < deleteDeltaFiles.length; i++) {
1:         out.writeUTF(deleteDeltaFiles[i]);
1:       }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:   public String[] getDeleteDeltaFiles() {
1:     return deleteDeltaFiles;
1:   }
commit:d54dc64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
/////////////////////////////////////////////////////////////////////////
1: public class CarbonInputSplit extends FileSplit
1:     implements Distributable, Serializable, Writable, Block {
0:   private String segmentId;
/////////////////////////////////////////////////////////////////////////
0:   private short version = CarbonCommonConstants.CARBON_DATA_FILE_DEFAULT_VERSION;
1: 
0:   public CarbonInputSplit() {
0:   private CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
0:       short version) {
1:     this.version = version;
0:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
0:       int numberOfBlocklets, short version) {
0:     this(segmentId, path, start, length, locations, version);
0:   public static CarbonInputSplit from(String segmentId, FileSplit split, short version)
0:       throws IOException {
0:         split.getLocations(), version);
1:   }
1: 
1:   public static List<TableBlockInfo> createBlocks(List<CarbonInputSplit> splitList) {
1:     List<TableBlockInfo> tableBlockInfoList = new ArrayList<>();
1:     for (CarbonInputSplit split : splitList) {
1:       BlockletInfos blockletInfos =
1:           new BlockletInfos(split.getNumberOfBlocklets(), 0, split.getNumberOfBlocklets());
1:       try {
0:         tableBlockInfoList.add(
0:             new TableBlockInfo(split.getPath().toString(), split.getStart(), split.getSegmentId(),
0:                 split.getLocations(), split.getLength(), blockletInfos, split.getVersion()));
1:       } catch (IOException e) {
1:         throw new RuntimeException("fail to get location of split: " + split, e);
1:       }
1:     }
1:     return tableBlockInfoList;
1:   }
1: 
1:   public static TableBlockInfo getTableBlockInfo(CarbonInputSplit inputSplit) {
1:     BlockletInfos blockletInfos =
1:         new BlockletInfos(inputSplit.getNumberOfBlocklets(), 0, inputSplit.getNumberOfBlocklets());
1:     try {
0:       return new TableBlockInfo(inputSplit.getPath().toString(), inputSplit.getStart(),
0:           inputSplit.getSegmentId(), inputSplit.getLocations(), inputSplit.getLength(),
0:           blockletInfos, inputSplit.getVersion());
1:     } catch (IOException e) {
1:       throw new RuntimeException("fail to get location of split: " + inputSplit, e);
1:     }
0:   @Override public void readFields(DataInput in) throws IOException {
0:     this.version = in.readShort();
/////////////////////////////////////////////////////////////////////////
0:   @Override public void write(DataOutput out) throws IOException {
0:     out.writeShort(version);
1:     for (String invalidSegment : invalidSegments) {
1:   public List<String> getInvalidSegments() {
/////////////////////////////////////////////////////////////////////////
1:    *
0:   public short getVersion() {
1:     return version;
1:   }
1: 
0:   public void setVersion(short version) {
1:     this.version = version;
1:   }
1: 
1:   @Override public int compareTo(Distributable o) {
1:     CarbonInputSplit other = (CarbonInputSplit) o;
/////////////////////////////////////////////////////////////////////////
1:   @Override public String getBlockPath() {
1:   @Override public List<Long> getMatchedBlocklets() {
1:   @Override public boolean fullScan() {
author:jackylk
-------------------------------------------------------------------------------
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.block.BlockletInfos;
1: import org.apache.carbondata.core.datastore.block.Distributable;
1: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
1: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
1: import org.apache.carbondata.core.mutate.UpdateVO;
1: import org.apache.carbondata.core.util.path.CarbonTablePath;
commit:18cfba8
/////////////////////////////////////////////////////////////////////////
1:     if (o == null) {
1:       return -1;
1:     }
commit:0ef3fb8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.carbon.ColumnarFormatVersion;
1: import org.apache.carbondata.core.util.CarbonProperties;
/////////////////////////////////////////////////////////////////////////
1:   private ColumnarFormatVersion version;
1:     version = CarbonProperties.getInstance().getFormatVersion();
0:       ColumnarFormatVersion version) {
/////////////////////////////////////////////////////////////////////////
0:       int numberOfBlocklets, ColumnarFormatVersion version) {
0:   public static CarbonInputSplit from(String segmentId, FileSplit split,
0:       ColumnarFormatVersion version)
/////////////////////////////////////////////////////////////////////////
1:     this.version = ColumnarFormatVersion.valueOf(in.readShort());
/////////////////////////////////////////////////////////////////////////
1:     out.writeShort(version.number());
/////////////////////////////////////////////////////////////////////////
1:   public ColumnarFormatVersion getVersion() {
1:   public void setVersion(ColumnarFormatVersion version) {
commit:5f6a56c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import org.apache.carbondata.core.carbon.datastore.block.BlockletInfos;
0: import org.apache.carbondata.core.carbon.datastore.block.Distributable;
0: import org.apache.carbondata.core.carbon.datastore.block.TableBlockInfo;
0: import org.apache.carbondata.core.carbon.path.CarbonTablePath;
/////////////////////////////////////////////////////////////////////////
0: public class CarbonInputSplit extends FileSplit implements Distributable, Serializable, Writable,
0:     Block {
1:   public String taskId;
1: 
1:   /*
1:    * Invalid segments that need to be removed in task side index
1:    */
1:   private List<String> invalidSegments;
1: 
1:   /*
1:   private int numberOfBlocklets;
0:   public  CarbonInputSplit() {
0:     segmentId = null;
1:     taskId = "0";
1:     numberOfBlocklets = 0;
1:     invalidSegments = new ArrayList<>();
0:   private CarbonInputSplit(String segmentId, Path path, long start, long length,
0:     this.taskId = CarbonTablePath.DataFileUtil.getTaskNo(path.getName());
1:     this.invalidSegments = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:   @Override
0:   public void readFields(DataInput in) throws IOException {
1:     int numInvalidSegment = in.readInt();
1:     invalidSegments = new ArrayList<>(numInvalidSegment);
1:     for (int i = 0; i < numInvalidSegment; i++) {
1:       invalidSegments.add(in.readUTF());
1:     }
0:   @Override
0:   public void write(DataOutput out) throws IOException {
1:     out.writeInt(invalidSegments.size());
0:     for (String invalidSegment: invalidSegments) {
1:       out.writeUTF(invalidSegment);
1:     }
1:   }
1: 
0:   public List<String> getInvalidSegments(){
1:     return invalidSegments;
1:   }
1: 
0:   public void setInvalidSegments(List<String> invalidSegments) {
0:     this.invalidSegments = invalidSegments;
/////////////////////////////////////////////////////////////////////////
0:   public int compareTo(Distributable o) {
0:     CarbonInputSplit other = (CarbonInputSplit)o;
1:     int compareResult = 0;
1:     // get the segment id
1:     // converr seg ID to double.
1: 
0:     double seg1 = Double.parseDouble(segmentId);
1:     double seg2 = Double.parseDouble(other.getSegmentId());
1:     if (seg1 - seg2 < 0) {
1:       return -1;
1:     }
1:     if (seg1 - seg2 > 0) {
1:       return 1;
1:     }
1: 
1:     // Comparing the time task id of the file to other
1:     // if both the task id of the file is same then we need to compare the
1:     // offset of
1:     // the file
1:     String filePath1 = this.getPath().getName();
1:     String filePath2 = other.getPath().getName();
1:     if (CarbonTablePath.isCarbonDataFile(filePath1)) {
0:       int firstTaskId = Integer.parseInt(CarbonTablePath.DataFileUtil.getTaskNo(filePath1));
0:       int otherTaskId = Integer.parseInt(CarbonTablePath.DataFileUtil.getTaskNo(filePath2));
0:       if (firstTaskId != otherTaskId) {
0:         return firstTaskId - otherTaskId;
1:       }
1:       // compare the part no of both block info
1:       int firstPartNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getPartNo(filePath1));
1:       int SecondPartNo = Integer.parseInt(CarbonTablePath.DataFileUtil.getPartNo(filePath2));
1:       compareResult = firstPartNo - SecondPartNo;
1:     } else {
1:       compareResult = filePath1.compareTo(filePath2);
1:     }
1:     if (compareResult != 0) {
1:       return compareResult;
1:     }
1:     return 0;
1:   }
1: 
0:   public static List<TableBlockInfo> createBlocks(List<CarbonInputSplit> splitList) {
0:     List<TableBlockInfo> tableBlockInfoList = new ArrayList<>();
0:     for (CarbonInputSplit split : splitList) {
0:       BlockletInfos blockletInfos = new BlockletInfos(split.getNumberOfBlocklets(), 0,
0:           split.getNumberOfBlocklets());
0:       try {
0:         tableBlockInfoList.add(
0:             new TableBlockInfo(split.getPath().toString(), split.getStart(), split.getSegmentId(),
0:                 split.getLocations(), split.getLength(), blockletInfos));
0:       } catch (IOException e) {
0:         throw new RuntimeException("fail to get location of split: " + split, e);
1:       }
1:     }
0:     return tableBlockInfoList;
1:   }
1: 
0:   @Override
commit:edb02ab
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.carbondata.hadoop.internal.index.Block;
/////////////////////////////////////////////////////////////////////////
0: public class CarbonInputSplit extends FileSplit implements Serializable, Writable, Block {
/////////////////////////////////////////////////////////////////////////
0:   @Override
0:   public String getBlockPath() {
1:     return getPath().getName();
1:   }
1: 
0:   @Override
0:   public List<Long> getMatchedBlocklets() {
1:     return null;
1:   }
1: 
0:   @Override
0:   public boolean fullScan() {
1:     return true;
1:   }
author:sraghunandan
-------------------------------------------------------------------------------
commit:002279e
/////////////////////////////////////////////////////////////////////////
0:       int numberOfBlocklets, ColumnarFormatVersion version, Map<String, String> blockStorageIdMap) {
author:Venkata Ramana G
-------------------------------------------------------------------------------
commit:d0b4a98
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.update.UpdateVO;
/////////////////////////////////////////////////////////////////////////
1:   private List<UpdateVO> invalidTimestampsList;
1: 
/////////////////////////////////////////////////////////////////////////
1:   public void setInvalidTimestampRange(List<UpdateVO> invalidTimestamps) {
1:     invalidTimestampsList = invalidTimestamps;
1:   }
1: 
1:   public List<UpdateVO> getInvalidTimestampRange() {
1:     return invalidTimestampsList;
1:   }
1: 
author:sujith71955
-------------------------------------------------------------------------------
commit:427b202
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * map of blocklocation and storage id
1:    */
1:   private Map<String, String> blockStorageIdMap =
0:           new HashMap<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);
1: 
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Constructor to initialize the CarbonInputSplit with blockStorageIdMap
1:    * @param segmentId
1:    * @param path
1:    * @param start
1:    * @param length
1:    * @param locations
1:    * @param numberOfBlocklets
1:    * @param version
1:    * @param blockStorageIdMap
1:    */
0:   public CarbonInputSplit(String segmentId, Path path, long start, long length, String[] locations,
0:                           int numberOfBlocklets, ColumnarFormatVersion version, Map<String, String> blockStorageIdMap) {
0:     this(segmentId, path, start, length, locations, numberOfBlocklets, version);
1:     this.blockStorageIdMap = blockStorageIdMap;
1:   }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:   /**
1:    * returns map of blocklocation and storage id
1:    * @return
1:    */
1:   public Map<String, String> getBlockStorageIdMap() {
1:     return blockStorageIdMap;
0:   }
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:fe1b0f0
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Number of BlockLets in a block
1:    */
0:   private int numberOfBlocklets = 0;
/////////////////////////////////////////////////////////////////////////
0:   public CarbonInputSplit(String segmentId, Path path, long start, long length,
0:       String[] locations, int numberOfBlocklets) {
0:     this(segmentId, path, start, length, locations);
1:     this.numberOfBlocklets = numberOfBlocklets;
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
0:   /**
1:    * returns the number of blocklets
1:    * @return
1:    */
1:   public int getNumberOfBlocklets() {
1:     return numberOfBlocklets;
0:   }
0: 
============================================================================