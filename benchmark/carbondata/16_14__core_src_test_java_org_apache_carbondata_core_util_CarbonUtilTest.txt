1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:cd6a4ff:  */
1:cd6a4ff: package org.apache.carbondata.core.util;
1:cd6a4ff: 
1:e6b6090: import java.io.BufferedReader;
1:e6b6090: import java.io.DataInputStream;
1:e6b6090: import java.io.File;
1:e6b6090: import java.io.FileNotFoundException;
1:e6b6090: import java.io.FileReader;
1:e6b6090: import java.io.FileWriter;
1:e6b6090: import java.io.IOException;
1:71965db: import java.nio.ByteBuffer;
1:71965db: import java.util.ArrayList;
1:71965db: import java.util.Arrays;
1:71965db: import java.util.List;
1:baca6f9: import java.util.Map;
1:cd6a4ff: 
1:8d3c774: import org.apache.carbondata.core.datamap.Segment;
1:ce09aaa: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
1:daa6465: import org.apache.carbondata.core.datastore.chunk.impl.FixedLengthDimensionColumnPage;
1:e6b6090: import org.apache.carbondata.core.datastore.filesystem.LocalCarbonFile;
1:e6b6090: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:e6b6090: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
1:71965db: import org.apache.carbondata.core.metadata.ValueEncoderMeta;
1:ce09aaa: import org.apache.carbondata.core.metadata.blocklet.DataFileFooter;
1:ce09aaa: import org.apache.carbondata.core.metadata.blocklet.datachunk.DataChunk;
1:ce09aaa: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:ce09aaa: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:daa6465: import org.apache.carbondata.core.scan.model.ProjectionDimension;
1:c671c5b: 
1:71965db: import mockit.Mock;
1:71965db: import mockit.MockUp;
1:71965db: import org.apache.hadoop.security.UserGroupInformation;
1:71965db: import org.junit.AfterClass;
1:29be1d0: import org.junit.Assert;
1:71965db: import org.junit.BeforeClass;
1:cd6a4ff: import org.junit.Test;
1:cd6a4ff: 
1:e6b6090: import static junit.framework.TestCase.assertEquals;
1:e6b6090: import static junit.framework.TestCase.assertTrue;
1:71965db: import static org.hamcrest.CoreMatchers.equalTo;
1:71965db: import static org.hamcrest.CoreMatchers.is;
1:71965db: import static org.hamcrest.MatcherAssert.assertThat;
1:71965db: 
1:71965db: public class CarbonUtilTest {
1:71965db: 
1:71965db:   @BeforeClass public static void setUp() throws Exception {
1:71965db:     new File("../core/src/test/resources/testFile.txt").createNewFile();
1:71965db:     new File("../core/src/test/resources/testDatabase").mkdirs();
1:71965db:   }
1:71965db: 
1:cd6a4ff:   @Test public void testGetBitLengthForDimensionGiveProperValue() {
1:71965db:     int[] cardinality = { 200, 1, 10000, 1, 10, 3 };
1:cd6a4ff:     int[] dimensionBitLength =
1:cd6a4ff:         CarbonUtil.getDimensionBitLength(cardinality, new int[] { 1, 1, 3, 1 });
1:cd6a4ff:     int[] expectedOutPut = { 8, 8, 14, 2, 8, 8 };
1:cd6a4ff:     for (int i = 0; i < dimensionBitLength.length; i++) {
1:cd6a4ff:       assertEquals(expectedOutPut[i], dimensionBitLength[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test(expected = IOException.class) public void testCloseStreams() throws IOException {
1:71965db:     FileReader stream = new FileReader("../core/src/test/resources/testFile.txt");
1:71965db:     BufferedReader br = new BufferedReader(stream);
1:71965db:     CarbonUtil.closeStreams(br);
1:71965db:     br.ready();
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetCardinalityForPerIncrLessThan0() {
1:71965db:     int result = CarbonUtil.getIncrementedCardinality(6);
1:71965db:     assertEquals(result, 3);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetCardinality() {
1:71965db:     int result = CarbonUtil.getIncrementedCardinality(10);
2:71965db:     assertEquals(result, 4);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetCardinalityForArray() {
1:71965db:     int[] cardinality = { 10, 20, 0, 6 };
1:71965db:     int[] actualResult = CarbonUtil.getIncrementedCardinality(cardinality);
1:71965db:     int[] expectedResult = { 4, 5, 1, 3 };
2:71965db:     for (int i = 0; i < cardinality.length; i++) {
1:71965db:       assertEquals(actualResult[i], expectedResult[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetIncrementedCardinalityFullyFilled() {
1:71965db:     int[] cardinality = { 200, 20, 0, 10 };
1:71965db:     int[] actualResult = CarbonUtil.getIncrementedCardinalityFullyFilled(cardinality);
1:71965db:     int[] expectedResult = { 8, 8, 64, 8 };
1:71965db:     for (int i = 0; i < cardinality.length; i++) {
1:71965db:       assertEquals(actualResult[i], expectedResult[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToDeleteFolderForValidPath()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     File testDir = new File("../core/src/test/resources/testDir");
1:71965db:     testDir.mkdirs();
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:     assertTrue(!testDir.isDirectory());
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class) public void testToDeleteFolderWithIOException()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     File testDir = new File("../core/src/test/resources/testDir");
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = InterruptedException.class)
1:71965db:   public void testToDeleteFolderWithInterruptedException()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     File testDir = new File("../core/src/test/resources/testDir");
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws InterruptedException {
1:71965db:         throw new InterruptedException();
1:71965db:       }
1:71965db:     };
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToDeleteFileForValidPath()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     File testDir = new File("../core/src/test/resources/testDir/testFile.csv");
1:71965db:     testDir.mkdirs();
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:     assertTrue(!testDir.isFile());
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToDeleteFoldersAndFilesForValidFolder()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     String folderPath = "../core/src/test/resources/testDir/carbonDir";
1:71965db:     new File(folderPath).mkdirs();
1:71965db:     LocalCarbonFile testDir = new LocalCarbonFile(folderPath);
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:     assertTrue(!testDir.exists());
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class) public void testToDeleteFoldersAndFilesWithIOException()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir/carbonDir");
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = InterruptedException.class) public void testToDeleteFoldersAndFilesWithInterruptedException()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir/carbonDir");
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws InterruptedException {
1:71965db:         throw new InterruptedException();
1:71965db:       }
1:71965db:     };
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToDeleteFoldersAndFilesForValidCarbonFile()
1:eaadc88:       throws InterruptedException, IOException {
1:71965db:     LocalCarbonFile testDir =
1:71965db:         new LocalCarbonFile("../core/src/test/resources/testDir/testCarbonFile");
1:71965db:     testDir.createNewFile();
1:71965db:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:71965db:     assertTrue(!testDir.exists());
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToDeleteFoldersAndFilesForCarbonFileSilently()
1:eaadc88:       throws IOException, InterruptedException {
1:71965db:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir");
1:71965db:     testDir.createNewFile();
1:71965db:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:71965db:     assertTrue(!testDir.exists());
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class)
1:71965db:   public void testToDeleteFoldersAndFilesSintlyWithIOException()
1:eaadc88:       throws IOException, InterruptedException {
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     LocalCarbonFile testDir =
1:71965db:         new LocalCarbonFile("../unibi-solutions/system/carbon/badRecords/badLogPath");
1:71965db:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = InterruptedException.class)
1:71965db:   public void testToDeleteFoldersAndFilesSintlyWithInterruptedException()
1:eaadc88:       throws IOException, InterruptedException {
1:71965db:     new MockUp<UserGroupInformation>() {
1:71965db:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:71965db:           throws InterruptedException {
1:71965db:         throw new InterruptedException();
1:71965db:       }
1:71965db:     };
1:71965db:     LocalCarbonFile testDir =
1:71965db:         new LocalCarbonFile("../unibi-solutions/system/carbon/badRecords/badLogPath");
1:71965db:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test public void testToDeleteFiles() throws IOException {
1:71965db:     String baseDirectory = "../core/src/test/resources/";
1:71965db:     File file1 = new File(baseDirectory + "File1.txt");
1:71965db:     File file2 = new File(baseDirectory + "File2.txt");
1:71965db:     file1.createNewFile();
1:71965db:     file2.createNewFile();
1:71965db:     File[] files = { file1, file2 };
1:71965db:     CarbonUtil.deleteFiles(files);
1:71965db:     assertTrue(!file1.exists());
1:71965db:     assertTrue(!file2.exists());
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetNextLesserValue() {
1:8d9babe:     byte[] dataChunks = { 5, 6, 7, 8, 9 };
1:8d9babe:     byte[] compareValues = { 7 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
1:8d9babe:     int result = CarbonUtil.nextLesserValueToTarget(2, fixedLengthDataChunk, compareValues);
1:8d9babe:     assertEquals(result, 1);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetNextLesserValueToTarget() {
1:8d9babe:     byte[] dataChunks = { 7, 7, 7, 8, 9 };
1:8d9babe:     byte[] compareValues = { 7 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
1:8d9babe:     int result = CarbonUtil.nextLesserValueToTarget(2, fixedLengthDataChunk, compareValues);
1:71965db:     assertEquals(result, -1);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetnextGreaterValue() {
1:8d9babe:     byte[] dataChunks = { 5, 6, 7, 8, 9 };
1:8d9babe:     byte[] compareValues = { 7 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
1:8d9babe:     int result = CarbonUtil.nextGreaterValueToTarget(2, fixedLengthDataChunk, compareValues, 5);
1:8d9babe:     assertEquals(result, 3);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToConvertToIntegerList() {
1:71965db:     int[] integerArray = { 10, 20, 30, 40 };
1:71965db:     List<Integer> integerList = CarbonUtil.convertToIntegerList(integerArray);
1:71965db:     for (int i = 0; i < integerArray.length; i++) {
1:71965db:       assertEquals(integerArray[i], (int) integerList.get(i));
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetnextGreaterValueToTarget() {
1:8d9babe:     byte[] dataChunks = { 5, 6, 7, 7, 7 };
1:8d9babe:     byte[] compareValues = { 7 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
1:8d9babe:     int result = CarbonUtil.nextGreaterValueToTarget(2, fixedLengthDataChunk, compareValues, 5);
1:8d9babe:     assertEquals(result, 5);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToUnescapeChar() {
1:71965db:     String[] input = { "\\001", "\\t", "\\r", "\\b", "\\n", "\\f" };
1:71965db:     String[] output = { "\001", "\t", "\r", "\b", "\n", "\f" };
1:71965db:     for (int i = 0; i < input.length; i++) {
1:71965db:       assertEquals(CarbonUtil.unescapeChar(input[i]), output[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testForDelimiterConverter() {
1:71965db:     String[] input =
1:71965db:         { "|", "*", ".", ":", "^", "\\", "$", "+", "?", "(", ")", "{", "}", "[", "]", "'" };
1:71965db:     String[] expectedResult =
1:71965db:         { "\\|", "\\*", "\\.", "\\:", "\\^", "\\\\", "\\$", "\\+", "\\?", "\\(", "\\)", "\\{",
1:71965db:             "\\}", "\\[", "\\]", "'" };
1:71965db:     for (int i = 0; i < input.length; i++) {
1:71965db:       assertEquals(CarbonUtil.delimiterConverter(input[i]), expectedResult[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToCheckAndAppendHDFSUrlWithNoBlackSlash() {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:71965db:         return FileFactory.FileType.LOCAL;
1:71965db:       }
1:71965db:     };
1:71965db:     new MockUp<CarbonProperties>() {
1:71965db:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:71965db:         return "BASE_URL";
1:71965db:       }
1:71965db:     };
1:71965db:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "file:///BASE_URL/../core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToCheckAndAppendHDFSUrlWithBlackSlash() {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:71965db:         return FileFactory.FileType.LOCAL;
1:71965db:       }
1:71965db:     };
1:71965db:     new MockUp<CarbonProperties>() {
1:71965db:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:71965db:         return "BASE_URL/";
1:71965db:       }
1:71965db:     };
1:71965db:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "file:///BASE_URL/../core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToCheckAndAppendHDFSUrlWithNull() {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:71965db:         return FileFactory.FileType.LOCAL;
1:71965db:       }
1:71965db:     };
1:71965db:     new MockUp<CarbonProperties>() {
1:71965db:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:71965db:         return null;
1:71965db:       }
1:71965db:     };
1:71965db:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
1:47a05a8:     assertEquals(hdfsURL, "file:////../core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithHdfs() {
1:c671c5b:     new MockUp<FileFactory>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:c671c5b:         return FileFactory.FileType.HDFS;
1:71965db:       }
1:71965db:     };
1:c671c5b:     new MockUp<org.apache.hadoop.conf.Configuration>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public String get(String name) {
1:c671c5b:         return "hdfs://";
1:71965db:       }
1:71965db:     };
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("hdfs://ha/core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "hdfs://ha/core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithDoubleSlashLocal() {
1:c671c5b:     new MockUp<FileFactory>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:c671c5b:         return FileFactory.FileType.LOCAL;
1:71965db:       }
1:71965db:     };
1:71965db:     new MockUp<CarbonProperties>() {
1:71965db:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:c671c5b:         return "/opt/";
1:71965db:       }
1:71965db:     };
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "file:////opt/core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithDoubleSlashHDFS() {
1:c671c5b:     new MockUp<FileFactory>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:c671c5b:         return FileFactory.FileType.HDFS;
1:71965db:       }
1:71965db:     };
1:c671c5b:     new MockUp<org.apache.hadoop.conf.Configuration>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public String get(String name) {
1:c671c5b:         return "hdfs://";
1:71965db:       }
1:71965db:     };
2:c671c5b:     new MockUp<CarbonProperties>() {
2:c671c5b:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:c671c5b:         return "/opt/";
1:71965db:       }
1:71965db:     };
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "hdfs:///opt/core/src/test/resources/testDatabase");
1:71965db:   }
1:71965db: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithBaseURLPrefix() {
1:c671c5b:     new MockUp<FileFactory>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:c671c5b:         return FileFactory.FileType.HDFS;
1:cd6a4ff:       }
1:71965db:     };
1:c671c5b:     new MockUp<CarbonProperties>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:c671c5b:         return "hdfs://ha/opt/";
1:cd6a4ff:       }
1:71965db:     };
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "hdfs://ha/opt/core/src/test/resources/testDatabase");
1:cd6a4ff:   }
1:71965db: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithBaseURLFile() {
1:c671c5b:     new MockUp<FileFactory>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:c671c5b:         return FileFactory.FileType.HDFS;
1:33de599:       }
10:c671c5b:     };
1:c671c5b:     new MockUp<CarbonProperties>() {
1:c671c5b:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:c671c5b:         return "file:///";
11:c671c5b:       }
1:c671c5b:     };
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "file:///core/src/test/resources/testDatabase");
1:c671c5b:   }
1:baca6f9: 
1:c671c5b:   @Test public void testToCheckAndAppendHDFSUrlWithFilepathPrefix() {
1:c671c5b:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("file:///core/src/test/resources/testDatabase");
1:c671c5b:     assertEquals(hdfsURL, "file:///core/src/test/resources/testDatabase");
1:c671c5b:   }
1:c671c5b: 
1:71965db:   @Test public void testForisFileExists() {
1:71965db:     assertTrue(CarbonUtil.isFileExists("../core/src/test/resources/testFile.txt"));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testForisFileExistsWithException() {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path)
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     assertTrue(!CarbonUtil.isFileExists("../core/src/test/resources/testFile.txt"));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToCheckAndCreateFolder() {
1:71965db:     boolean exists = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/testDatabase");
1:71965db:     boolean created = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/newDatabase");
1:71965db:     assertTrue(exists);
1:71965db:     assertTrue(created);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToCheckAndCreateFolderWithException() {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path)
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     boolean exists = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/testDatabase1");
1:71965db:     assertTrue(!exists);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFileSize() {
1:71965db:     assertEquals(CarbonUtil.getFileSize("../core/src/test/resources/testFile.txt"), 0);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testForHasEncoding() {
1:71965db:     List<Encoding> encodingList = new ArrayList<>();
1:71965db:     encodingList.add(Encoding.INVERTED_INDEX);
1:71965db:     encodingList.add(Encoding.DICTIONARY);
1:71965db:     encodingList.add(Encoding.DELTA);
1:71965db:     assertTrue(CarbonUtil.hasEncoding(encodingList, Encoding.DICTIONARY));
1:71965db:     assertTrue(!CarbonUtil.hasEncoding(encodingList, Encoding.BIT_PACKED));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testForHasDataTypes() {
1:f209e8e:     DataType[] dataTypes = {DataTypes.createDefaultDecimalType(), DataTypes.BOOLEAN, DataTypes.INT };
1:956833e:     assertTrue(CarbonUtil.hasDataType(DataTypes.BOOLEAN, dataTypes));
1:956833e:     assertTrue(!CarbonUtil.hasDataType(DataTypes.DATE, dataTypes));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testForHasComplexDataTypes() {
1:933e30c:     assertTrue(DataTypes.createDefaultArrayType().isComplexType());
1:956833e:     assertTrue(!DataTypes.DATE.isComplexType());
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetDictionaryEncodingArray() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:71965db:     List<Encoding> encoding = new ArrayList<>();
1:71965db:     encoding.add(Encoding.DICTIONARY);
1:71965db:     column1Schema.setEncodingList(encoding);
1:daa6465:     ProjectionDimension
1:f911403:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:71965db: 
1:71965db:     column2Schema.setColumnName("Column2");
1:71965db:     List<Encoding> encoding2 = new ArrayList<>();
1:71965db:     encoding2.add(Encoding.DELTA);
1:71965db:     column2Schema.setEncodingList(encoding2);
1:daa6465:     ProjectionDimension
1:f911403:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
1:71965db: 
1:daa6465:     ProjectionDimension[] queryDimensions = { column1, column2 };
1:71965db: 
1:71965db:     boolean[] dictionaryEncoding = CarbonUtil.getDictionaryEncodingArray(queryDimensions);
1:71965db:     boolean[] expectedDictionaryEncoding = { true, false };
1:71965db:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:71965db:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetDirectDictionaryEncodingArray() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:71965db:     List<Encoding> encoding = new ArrayList<>();
1:71965db:     encoding.add(Encoding.DIRECT_DICTIONARY);
1:71965db:     column1Schema.setEncodingList(encoding);
1:daa6465:     ProjectionDimension
1:f911403:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:71965db: 
1:71965db:     column2Schema.setColumnName("Column2");
1:71965db:     List<Encoding> encoding2 = new ArrayList<>();
1:71965db:     encoding2.add(Encoding.DELTA);
1:71965db:     column2Schema.setEncodingList(encoding2);
1:daa6465:     ProjectionDimension
1:f911403:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
1:71965db: 
1:daa6465:     ProjectionDimension[] queryDimensions = { column1, column2 };
1:71965db: 
1:71965db:     boolean[] dictionaryEncoding = CarbonUtil.getDirectDictionaryEncodingArray(queryDimensions);
1:71965db:     boolean[] expectedDictionaryEncoding = { true, false };
1:71965db:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:71965db:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetComplexDataTypeArray() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:956833e:     column1Schema.setDataType(DataTypes.DATE);
1:daa6465:     ProjectionDimension
1:f911403:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:71965db: 
1:71965db:     column2Schema.setColumnName("Column2");
1:933e30c:     column2Schema.setDataType(DataTypes.createDefaultArrayType());
1:daa6465:     ProjectionDimension
1:f911403:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
1:71965db: 
1:daa6465:     ProjectionDimension[] queryDimensions = { column1, column2 };
1:71965db: 
1:71965db:     boolean[] dictionaryEncoding = CarbonUtil.getComplexDataTypeArray(queryDimensions);
1:71965db:     boolean[] expectedDictionaryEncoding = { false, true };
1:71965db:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:71965db:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:71965db:     }
1:71965db:   }
1:c671c5b: 
1:eaadc88:   @Test public void testToReadMetadatFile() throws IOException {
1:71965db:     new MockUp<DataFileFooterConverter>() {
5:71965db:       @SuppressWarnings("unused") @Mock
1:d54dc64:       public DataFileFooter readDataFileFooter(TableBlockInfo info) {
1:71965db:         DataFileFooter fileFooter = new DataFileFooter();
1:0ef3fb8:         fileFooter.setVersionId(ColumnarFormatVersion.V1);
1:71965db:         return fileFooter;
1:71965db:       }
1:71965db:     };
1:8d9babe:     TableBlockInfo info =
1:8a5ed81:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1, null);
1:71965db: 
1:0ef3fb8:     assertEquals(CarbonUtil.readMetadatFile(info).getVersionId().number(), 1);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class)
1:eaadc88:   public void testToReadMetadatFileWithException()
1:71965db:       throws Exception {
1:8d9babe:     TableBlockInfo info =
1:8a5ed81:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1, null);
1:d54dc64:     CarbonUtil.readMetadatFile(info);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToFindDimension() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:71965db:     column2Schema.setColumnName("Column2");
1:71965db:     List<CarbonDimension> carbonDimension = new ArrayList<>();
1:f911403:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1));
1:f911403:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 1, 1));
1:71965db:     assertEquals(CarbonUtil.findDimension(carbonDimension, "Column1"),
1:f911403:         new CarbonDimension(column1Schema, 1, 1, 1));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFormattedCardinality() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     List<Encoding> encoding = new ArrayList<>();
1:71965db:     encoding.add(Encoding.DICTIONARY);
1:71965db:     List<Encoding> encoding2 = new ArrayList<>();
1:71965db:     encoding2.add(Encoding.DIRECT_DICTIONARY);
1:71965db:     column1Schema.setEncodingList(encoding);
1:71965db:     column2Schema.setEncodingList(encoding2);
1:71965db:     List<ColumnSchema> columnSchemas = new ArrayList<>();
1:71965db:     columnSchemas.add(column1Schema);
1:71965db:     columnSchemas.add(column2Schema);
1:71965db:     int[] columnCardinality = { 1, 5 };
1:71965db:     int[] result = CarbonUtil.getFormattedCardinality(columnCardinality, columnSchemas);
1:71965db:     int[] expectedResult = { 1, 5 };
1:71965db:     for (int i = 0; i < result.length; i++) {
1:71965db:       assertEquals(result[i], expectedResult[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetColumnSchemaList() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:71965db:     column2Schema.setColumnName("Column2");
1:71965db:     List<CarbonDimension> carbonDimension = new ArrayList<>();
1:f911403:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1));
1:f911403:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 2, 1));
1:71965db: 
1:71965db:     List<CarbonMeasure> carbonMeasure = new ArrayList<>();
1:71965db:     carbonMeasure.add(new CarbonMeasure(column1Schema, 1));
1:71965db:     carbonMeasure.add(new CarbonMeasure(column2Schema, 2));
1:71965db: 
1:71965db:     List<ColumnSchema> columnSchema =
1:71965db:         CarbonUtil.getColumnSchemaList(carbonDimension, carbonMeasure);
1:71965db:     for (int i = 0; i < carbonMeasure.size(); i++) {
1:71965db:       assertEquals(columnSchema.get(i), carbonMeasure.get(i).getColumnSchema());
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToReadHeader() throws IOException {
1:71965db:     File file = new File("../core/src/test/resources/sampleCSV.csv");
1:71965db:     FileWriter writer = new FileWriter(file);
1:71965db:     writer.write("id,name");
1:71965db:     writer.flush();
1:71965db:     String headers = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV.csv");
1:71965db:     assertEquals(headers, "id,name");
1:71965db:     file.deleteOnExit();
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class)
1:eaadc88:   public void testToReadHeaderWithFileNotFoundException() throws IOException {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock
1:71965db:       public DataInputStream getDataInputStream(String path, FileFactory.FileType fileType)
1:71965db:           throws FileNotFoundException {
1:71965db:         throw new FileNotFoundException();
1:71965db:       }
1:71965db:     };
1:71965db:     String result = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV");
1:71965db:     assertEquals(null, result);
1:71965db:   }
1:71965db: 
1:eaadc88:   @Test(expected = IOException.class)
1:eaadc88:   public void testToReadHeaderWithIOException() throws IOException {
1:71965db:     new MockUp<FileFactory>() {
1:71965db:       @SuppressWarnings("unused") @Mock
1:71965db:       public DataInputStream getDataInputStream(String path, FileFactory.FileType fileType)
1:71965db:           throws IOException {
1:71965db:         throw new IOException();
1:71965db:       }
1:71965db:     };
1:71965db:     String result = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV.csv");
1:71965db:     assertEquals(null, result);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToPrintLine() {
1:71965db:     String line = CarbonUtil.printLine("*", 2);
1:71965db:     assertEquals(line, "**");
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetSegmentString() {
1:8d3c774:     List<Segment> list = new ArrayList<>();
1:8f1a029:     list.add(new Segment("1", null, null));
1:8f1a029:     list.add(new Segment("2", null, null));
1:b8a02f3:     String segments = CarbonUtil.convertToString(list);
1:71965db:     assertEquals(segments, "1,2");
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetSegmentStringWithEmptySegmentList() {
1:8d3c774:     List<Segment> list = new ArrayList<>();
1:b8a02f3:     String segments = CarbonUtil.convertToString(list);
1:71965db:     assertEquals(segments, "");
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetSurrogateKey() {
1:71965db:     byte[] data = { 1, 1 };
1:71965db:     ByteBuffer byteBuffer = ByteBuffer.allocate(8);
1:71965db:     int a = CarbonUtil.getSurrogateKey(data, byteBuffer);
1:71965db:     assertEquals(a, 257);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetValueCompressionModel() {
1:71965db:     List<DataChunk> dataChunkList = new ArrayList<>();
1:71965db:     DataChunk dataChunk = new DataChunk();
1:71965db: 
1:71965db:     List<Encoding> encodingList = new ArrayList<>();
1:71965db:     encodingList.add(Encoding.DELTA);
1:eaadc88:     dataChunk.setEncodingList(encodingList);
1:71965db: 
1:71965db:     List<ValueEncoderMeta> valueEncoderMetas = new ArrayList<>();
1:71965db:     ValueEncoderMeta valueEncoderMeta = new ValueEncoderMeta();
1:71965db:     valueEncoderMeta.setMaxValue(5.0);
1:71965db:     valueEncoderMeta.setMinValue(1.0);
1:71965db:     valueEncoderMeta.setUniqueValue(2.0);
1:71965db:     valueEncoderMeta.setType('n');
1:71965db:     valueEncoderMeta.setDataTypeSelected((byte) 'v');
1:71965db:     valueEncoderMetas.add(valueEncoderMeta);
1:71965db:     dataChunk.setValueEncoderMeta(valueEncoderMetas);
1:71965db:     dataChunkList.add(dataChunk);
1:dc83b2a:     assertEquals(1, dataChunkList.get(0).getValueEncoderMeta().size());
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetDictionaryChunkSize() {
1:71965db:     new MockUp<CarbonProperties>() {
1:71965db:       @SuppressWarnings("unused") @Mock public CarbonProperties getInstance()
1:71965db:           throws NumberFormatException {
1:71965db:         throw new NumberFormatException();
1:71965db:       }
1:71965db:     };
1:71965db:     int expectedResult = CarbonUtil.getDictionaryChunkSize();
1:71965db:     assertEquals(expectedResult, 10000);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToPackByteBufferIntoSingleByteArrayWithNull() {
1:71965db:     byte[] byteArray = CarbonUtil.packByteBufferIntoSingleByteArray(null);
1:71965db:     assertEquals(null, byteArray);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToPackByteBufferIntoSingleByteArray() {
1:71965db:     ByteBuffer[] byteBuffers = { ByteBuffer.allocate(1), ByteBuffer.allocate(2) };
1:71965db:     byte[] byteArray = CarbonUtil.packByteBufferIntoSingleByteArray(byteBuffers);
1:71965db:     byte[] expectedResult = { 0, 4, 0, 5, 0, 0, 0, 0 };
1:71965db:     for (int i = 0; i < byteArray.length; i++) {
1:71965db:       assertEquals(expectedResult[i], byteArray[i]);
1:71965db:     }
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToIdentifyDimensionType() {
1:71965db:     ColumnSchema column1Schema = new ColumnSchema();
1:71965db:     ColumnSchema column2Schema = new ColumnSchema();
1:71965db:     ColumnSchema column3Schema = new ColumnSchema();
1:71965db:     column1Schema.setColumnName("Column1");
1:71965db:     column1Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.DICTIONARY));
1:71965db:     column2Schema.setColumnName("Column2");
1:71965db:     column2Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.DICTIONARY));
1:71965db:     column3Schema.setColumnName("Column3");
1:71965db:     column3Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.INVERTED_INDEX));
1:f911403:     CarbonDimension carbonDimension = new CarbonDimension(column1Schema, 1, 1, 1);
1:f911403:     CarbonDimension carbonDimension2 = new CarbonDimension(column2Schema, 2, 2, 2);
1:f911403:     CarbonDimension carbonDimension3 = new CarbonDimension(column3Schema, 3, 3, 3);
1:8d9babe:     List<CarbonDimension> carbonDimensions =
1:8d9babe:         Arrays.asList(carbonDimension, carbonDimension2, carbonDimension3);
1:71965db:     boolean[] result = CarbonUtil.identifyDimensionType(carbonDimensions);
1:8d9babe:     assertThat(result, is(equalTo(new boolean[] { true, true, false })));
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareTo1() {
1:8d9babe:     byte[] dataChunks = { 10, 20, 30, 40, 50, 60 };
1:8d9babe:     byte[] compareValue = { 5 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
1:8d9babe:     int result = CarbonUtil
1:8d9babe:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:71965db:     assertEquals(-2, result);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareToLessThan0() {
1:8d9babe:     byte[] dataChunks = { 10, 20, 30, 40, 50, 60 };
1:8d9babe:     byte[] compareValue = { 30 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
1:8d9babe:     int result = CarbonUtil
1:8d9babe:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:8d9babe:     assertEquals(2, result);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareTo0() {
1:8d9babe:     byte[] dataChunks = { 10, 10, 10, 40, 50, 60 };
1:8d9babe:     byte[] compareValue = { 10 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
1:8d9babe:     int result = CarbonUtil
1:8d9babe:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:71965db:     assertEquals(0, result);
1:71965db:   }
1:71965db: 
1:71965db:   @Test public void testToGetFirstIndexUsingBinarySearchWithMatchUpLimitTrue() {
1:8d9babe:     byte[] dataChunks = { 10, 10, 10, 40, 50, 60 };
1:8d9babe:     byte[] compareValue = { 10 };
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:daa6465:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
1:8d9babe:     int result = CarbonUtil
1:8d9babe:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, true);
1:8d9babe:     assertEquals(2, result);
1:71965db:   }
1:71965db:   
1:baca6f9:   @Test
1:bedaa59:   public void testBinaryRangeSearch() {
1:c671c5b: 
1:bedaa59:     byte[] dataChunk = new byte[10];
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:bedaa59:     byte[] keyWord = new byte[1];
1:bedaa59:     int[] range;
1:c671c5b: 
1:bedaa59:     dataChunk = "abbcccddddeffgggh".getBytes();
1:bedaa59:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:c671c5b: 
1:bedaa59:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:bedaa59:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
1:71965db:     }
1:8d9babe: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     int[] expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 0;
1:bedaa59:     expectRangeIndex[1] = 0;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:8d9babe: 
1:bedaa59:     keyWord[0] = Byte.valueOf("104");
1:bedaa59:     expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 16;
1:bedaa59:     expectRangeIndex[1] = 16;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:d54dc64: 
1:bedaa59:     keyWord[0] = Byte.valueOf("101");
1:bedaa59:     expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 10;
1:bedaa59:     expectRangeIndex[1] = 10;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:d54dc64: 
1:bedaa59:     keyWord[0] = Byte.valueOf("99");
1:bedaa59:     expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 3;
1:bedaa59:     expectRangeIndex[1] = 5;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:d54dc64: 
1:bedaa59:     dataChunk = "ab".getBytes();
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:d54dc64: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(0, range[0]);
1:bedaa59:     assertEquals(0, range[1]);
10:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("98");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(1, range[0]);
1:bedaa59:     assertEquals(1, range[1]);
1:bedaa59: 
1:bedaa59:     dataChunk = "aabb".getBytes();
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(0, range[0]);
1:bedaa59:     assertEquals(1, range[1]);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("98");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(2, range[0]);
1:bedaa59:     assertEquals(3, range[1]);
1:bedaa59: 
1:bedaa59:     dataChunk = "a".getBytes();
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(0, range[0]);
1:bedaa59:     assertEquals(0, range[1]);
1:bedaa59: 
1:bedaa59:     dataChunk = "aa".getBytes();
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(0, range[0]);
1:bedaa59:     assertEquals(1, range[1]);
1:bedaa59: 
1:bedaa59:     dataChunk = "aabbbbbbbbbbcc".getBytes();
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59:     keyWord[0] = Byte.valueOf("98");
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:bedaa59:     assertEquals(2, range[0]);
1:bedaa59:     assertEquals(11, range[1]);
1:bedaa59: 
1:71965db:   }
1:bedaa59: 
1:baca6f9:   @Test
1:bedaa59:   public void IndexUsingBinarySearchLengthTwo() {
1:bedaa59: 
1:bedaa59:     byte[] dataChunk = new byte[10];
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:bedaa59: 
1:bedaa59:     byte[] keyWord = new byte[2];
1:bedaa59: 
1:bedaa59:     dataChunk = "aabbbbbbbbbbcc".getBytes();
1:bedaa59:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
1:bedaa59: 
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59: 
1:bedaa59:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:bedaa59:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
1:71965db:     }
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("98");
1:bedaa59:     keyWord[1] = Byte.valueOf("98");
1:bedaa59:     int[] expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 1;
1:bedaa59:     expectRangeIndex[1] = 5;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("97");
1:bedaa59:     keyWord[1] = Byte.valueOf("97");
1:bedaa59: 
1:bedaa59:     expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 0;
1:bedaa59:     expectRangeIndex[1] = 0;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("99");
1:bedaa59:     keyWord[1] = Byte.valueOf("99");
1:bedaa59:     expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 6;
1:bedaa59:     expectRangeIndex[1] = 6;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:bedaa59: 
1:71965db:   }
1:bedaa59: 
1:bedaa59:   @Test
1:bedaa59:   public void IndexUsingBinarySearchLengthThree() {
1:bedaa59: 
1:bedaa59:     byte[] dataChunk = new byte[10];
1:daa6465:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:bedaa59: 
1:bedaa59:     byte[] keyWord = new byte[3];
1:bedaa59: 
1:bedaa59:     dataChunk = "aaabbbbbbbbbccc".getBytes();
1:bedaa59:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
1:bedaa59: 
1:daa6465:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
1:bedaa59:         dataChunk.length / keyWord.length, keyWord.length);
1:bedaa59: 
1:bedaa59:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:bedaa59:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
1:c671c5b:     }
1:bedaa59: 
1:bedaa59:     keyWord[0] = Byte.valueOf("98");
1:bedaa59:     keyWord[1] = Byte.valueOf("98");
1:bedaa59:     keyWord[2] = Byte.valueOf("98");
1:bedaa59:     int[] expectRangeIndex = new int[2];
1:bedaa59:     expectRangeIndex[0] = 1;
1:bedaa59:     expectRangeIndex[1] = 3;
1:bedaa59:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1:bedaa59: 
1:c671c5b:   }
1:bedaa59: 
1:bedaa59:   @Test
1:baca6f9:   public void testSplitSchemaStringToMapWithLessThanSplitLen() {
1:baca6f9:     String schema = generateString(399);
1:baca6f9:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
1:29be1d0:     Assert.assertTrue(map.size() == 2);
1:baca6f9:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
1:29be1d0:     Assert.assertTrue(schemaString.length() > schema.length());
1:baca6f9:   }
1:baca6f9: 
1:1248bd4:   @Test
1:baca6f9:   public void testSplitSchemaStringToMapWithEqualThanSplitLen() {
1:baca6f9:     String schema = generateString(4000);
1:baca6f9:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
1:29be1d0:     Assert.assertTrue(map.size() == 2);
1:baca6f9:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
1:29be1d0:     Assert.assertTrue(schemaString.length() > schema.length());
1:baca6f9:   }
1:baca6f9: 
1:baca6f9:   @Test
1:baca6f9:   public void testSplitSchemaStringToMapWithMoreThanSplitLen() {
1:baca6f9:     String schema = generateString(7999);
1:baca6f9:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
1:29be1d0:     Assert.assertTrue(map.size() == 3);
1:baca6f9:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
1:29be1d0:     Assert.assertTrue(schemaString.length() > schema.length());
1:baca6f9:   }
1:baca6f9: 
1:baca6f9:   @Test
1:baca6f9:   public void testSplitSchemaStringToMapWithMultiplesOfSplitLen() {
1:baca6f9:     String schema = generateString(12000);
1:baca6f9:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
1:29be1d0:     Assert.assertTrue(map.size() == 4);
1:baca6f9:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
1:29be1d0:     Assert.assertTrue(schemaString.length() > schema.length());
1:baca6f9:   }
1:baca6f9: 
1:bedaa59:   @Test
1:1248bd4:   public void testUpdateMinMaxValues() {
1:1248bd4:     // create dimension and measure column schema
1:1248bd4:     ColumnSchema dimensionColumnSchema = createColumnSchema(DataTypes.STRING, true);
1:1248bd4:     ColumnSchema measureColumnSchema = createColumnSchema(DataTypes.DOUBLE, false);
1:1248bd4:     List<ColumnSchema> columnSchemas = new ArrayList<>(2);
1:1248bd4:     columnSchemas.add(dimensionColumnSchema);
1:1248bd4:     columnSchemas.add(measureColumnSchema);
1:1248bd4:     // create data file footer object
1:1248bd4:     DataFileFooter fileFooter = new DataFileFooter();
1:1248bd4:     fileFooter.setColumnInTable(columnSchemas);
1:1248bd4:     // initialise the expected values
1:1248bd4:     int expectedMaxValue = 5;
1:1248bd4:     int expectedMinValue = 2;
1:1248bd4:     double expectedMeasureMaxValue = 28.74;
1:1248bd4:     double expectedMeasureMinValue = -21.46;
1:1248bd4:     // initialise the minValues
1:1248bd4:     byte[][] minValues = new byte[2][];
1:1248bd4:     minValues[0] = new byte[] { 2 };
1:1248bd4:     ByteBuffer buffer = ByteBuffer.allocate(8);
1:1248bd4:     minValues[1] = (byte[]) buffer.putDouble(28.74).flip().array();
1:1248bd4:     buffer = ByteBuffer.allocate(8);
1:1248bd4:     // initialise the maxValues
1:1248bd4:     byte[][] maxValues = new byte[2][];
1:1248bd4:     maxValues[0] = new byte[] { 5 };
1:1248bd4:     maxValues[1] = (byte[]) buffer.putDouble(-21.46).flip().array();
1:1248bd4:     byte[][] updateMaxValues =
1:1248bd4:         CarbonUtil.updateMinMaxValues(fileFooter, maxValues, minValues, false);
1:1248bd4:     byte[][] updateMinValues =
1:1248bd4:         CarbonUtil.updateMinMaxValues(fileFooter, maxValues, minValues, true);
1:1248bd4:     // compare max values
1:1248bd4:     assert (expectedMaxValue == ByteBuffer.wrap(updateMaxValues[0]).get());
1:1248bd4:     assert (expectedMeasureMaxValue == ByteBuffer.wrap(updateMaxValues[1]).getDouble());
1:1248bd4: 
1:1248bd4:     // compare min values
1:1248bd4:     assert (expectedMinValue == ByteBuffer.wrap(updateMinValues[0]).get());
1:1248bd4:     assert (expectedMeasureMinValue == ByteBuffer.wrap(updateMinValues[1]).getDouble());
1:1248bd4:   }
1:1248bd4: 
1:1248bd4:   private ColumnSchema createColumnSchema(DataType dataType, boolean isDimensionColumn) {
1:1248bd4:     ColumnSchema columnSchema = new ColumnSchema();
1:1248bd4:     columnSchema.setDataType(dataType);
1:1248bd4:     columnSchema.setDimensionColumn(isDimensionColumn);
1:1248bd4:     return columnSchema;
1:1248bd4:   }
1:1248bd4: 
1:baca6f9:   private String generateString(int length) {
1:baca6f9:     StringBuilder builder = new StringBuilder();
1:baca6f9:     for (int i = 0; i < length; i++) {
1:baca6f9:       builder.append("a");
1:baca6f9:     }
1:baca6f9:     return builder.toString();
1:baca6f9:   }
1:baca6f9: 
1:bedaa59:   private void assertRangeIndex(byte[][] dataArr, byte[] dataChunk,
1:daa6465:       FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk, byte[] keyWord, int[] expectRangeIndex) {
1:bedaa59:     int[] range;
1:bedaa59:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0,
1:bedaa59:         (dataChunk.length - 1) / keyWord.length, keyWord);
1:bedaa59:     assertEquals(expectRangeIndex[0], range[0]);
1:bedaa59:     assertEquals(expectRangeIndex[1], range[1]);
1:bedaa59: 
1:4935cb1: //    int index = CarbonUtil.binarySearch(dataArr, 0, dataChunk.length / keyWord.length - 1, keyWord);
1:4935cb1: //    assertTrue(expectRangeIndex[0] <= index && index <= range[1]);
1:c671c5b:   }
1:bedaa59: 
1:bedaa59:  	
1:71965db:   @AfterClass public static void testcleanUp() {
1:71965db:     new File("../core/src/test/resources/testFile.txt").deleteOnExit();
1:71965db:     new File("../core/src/test/resources/testDatabase/levelmetadata_testTable.metadata")
1:71965db:         .deleteOnExit();
1:71965db:     new File("../core/src/test/resources/testDatabase").delete();
1:71965db:     new File("../core/src/test/resources/newDatabase").deleteOnExit();
1:71965db:   }
1:71965db: 
1:c671c5b: }
============================================================================
author:kunal642
-------------------------------------------------------------------------------
commit:8f1a029
/////////////////////////////////////////////////////////////////////////
1:     list.add(new Segment("1", null, null));
1:     list.add(new Segment("2", null, null));
commit:7a1d12a
/////////////////////////////////////////////////////////////////////////
commit:71965db
/////////////////////////////////////////////////////////////////////////
1: import mockit.Mock;
1: import mockit.MockUp;
0: import org.apache.carbondata.core.carbon.datastore.chunk.DimensionChunkAttributes;
0: import org.apache.carbondata.core.carbon.datastore.chunk.impl.FixedLengthDimensionDataChunk;
0: import org.apache.carbondata.core.carbon.metadata.blocklet.DataFileFooter;
0: import org.apache.carbondata.core.carbon.metadata.blocklet.datachunk.DataChunk;
0: import org.apache.carbondata.core.carbon.metadata.datatype.DataType;
0: import org.apache.carbondata.core.carbon.metadata.encoder.Encoding;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonMeasure;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.ColumnSchema;
0: import org.apache.carbondata.core.datastorage.store.columnar.ColumnGroupModel;
0: import org.apache.carbondata.core.datastorage.store.compression.ValueCompressionModel;
0: import org.apache.carbondata.core.datastorage.store.filesystem.LocalCarbonFile;
0: import org.apache.carbondata.core.datastorage.store.impl.FileFactory;
1: import org.apache.carbondata.core.metadata.ValueEncoderMeta;
0: import org.apache.carbondata.scan.executor.infos.KeyStructureInfo;
0: import org.apache.carbondata.scan.model.QueryDimension;
1: import org.apache.hadoop.security.UserGroupInformation;
1: import org.junit.AfterClass;
1: import org.junit.BeforeClass;
0: import org.pentaho.di.core.exception.KettleException;
0: import java.io.*;
1: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.List;
1: import static org.hamcrest.MatcherAssert.assertThat;
0: import static junit.framework.TestCase.*;
1: import static org.hamcrest.CoreMatchers.equalTo;
1: import static org.hamcrest.CoreMatchers.is;
1: public class CarbonUtilTest {
1: 
0:   private static DimensionChunkAttributes chunkAttribute;
1: 
1:   @BeforeClass public static void setUp() throws Exception {
1:     new File("../core/src/test/resources/testFile.txt").createNewFile();
1:     new File("../core/src/test/resources/testDatabase").mkdirs();
0:     chunkAttribute = new DimensionChunkAttributes();
1:   }
1:     int[] cardinality = { 200, 1, 10000, 1, 10, 3 };
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Test(expected = IOException.class) public void testCloseStreams() throws IOException {
1:     FileReader stream = new FileReader("../core/src/test/resources/testFile.txt");
1:     BufferedReader br = new BufferedReader(stream);
1:     CarbonUtil.closeStreams(br);
1:     br.ready();
1:   }
1: 
1:   @Test public void testToGetCardinalityForPerIncrLessThan0() {
1:     int result = CarbonUtil.getIncrementedCardinality(6);
1:     assertEquals(result, 3);
1:   }
1: 
1:   @Test public void testToGetCardinality() {
1:     int result = CarbonUtil.getIncrementedCardinality(10);
1:     assertEquals(result, 4);
1:   }
1: 
1:   @Test public void testToGetCardinalityForArray() {
1:     int[] cardinality = { 10, 20, 0, 6 };
1:     int[] actualResult = CarbonUtil.getIncrementedCardinality(cardinality);
1:     int[] expectedResult = { 4, 5, 1, 3 };
1:     for (int i = 0; i < cardinality.length; i++) {
1:       assertEquals(actualResult[i], expectedResult[i]);
1:     }
1:   }
1: 
0:   @Test public void testToGetColGroupModel() {
0:     int[][] cardinality = { { 10, 20, 30 }, { 20, 30 }, {} };
0:     ColumnGroupModel actualResult = CarbonUtil.getColGroupModel(cardinality);
0:     assertEquals(actualResult.getNoOfColumnStore(), 3);
0:     int[] expectedResult = { 3, 2, 0 };
0:     for (int i = 0; i < actualResult.getColumnSplit().length; i++) {
0:       assertEquals(actualResult.getColumnSplit()[i], expectedResult[i]);
1:     }
1:   }
1: 
1:   @Test public void testToGetIncrementedCardinalityFullyFilled() {
1:     int[] cardinality = { 200, 20, 0, 10 };
1:     int[] actualResult = CarbonUtil.getIncrementedCardinalityFullyFilled(cardinality);
1:     int[] expectedResult = { 8, 8, 64, 8 };
1:     for (int i = 0; i < cardinality.length; i++) {
1:       assertEquals(actualResult[i], expectedResult[i]);
1:     }
1:   }
1: 
1:   @Test public void testToDeleteFolderForValidPath()
0:       throws CarbonUtilException, InterruptedException {
1:     File testDir = new File("../core/src/test/resources/testDir");
1:     testDir.mkdirs();
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:     assertTrue(!testDir.isDirectory());
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class) public void testToDeleteFolderWithIOException()
0:       throws CarbonUtilException, InterruptedException {
1:     File testDir = new File("../core/src/test/resources/testDir");
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class)
1:   public void testToDeleteFolderWithInterruptedException()
0:       throws CarbonUtilException, InterruptedException {
1:     File testDir = new File("../core/src/test/resources/testDir");
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws InterruptedException {
1:         throw new InterruptedException();
1:       }
1:     };
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:   }
1: 
1:   @Test public void testToDeleteFileForValidPath()
0:       throws CarbonUtilException, InterruptedException {
1:     File testDir = new File("../core/src/test/resources/testDir/testFile.csv");
1:     testDir.mkdirs();
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:     assertTrue(!testDir.isFile());
1:   }
1: 
1:   @Test public void testToDeleteFoldersAndFilesForValidFolder()
0:       throws CarbonUtilException, InterruptedException {
1:     String folderPath = "../core/src/test/resources/testDir/carbonDir";
1:     new File(folderPath).mkdirs();
1:     LocalCarbonFile testDir = new LocalCarbonFile(folderPath);
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:     assertTrue(!testDir.exists());
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class) public void testToDeleteFoldersAndFilesWithIOException()
0:       throws CarbonUtilException, InterruptedException {
1:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir/carbonDir");
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class) public void testToDeleteFoldersAndFilesWithInterruptedException()
0:       throws CarbonUtilException, InterruptedException {
1:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir/carbonDir");
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws InterruptedException {
1:         throw new InterruptedException();
1:       }
1:     };
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:   }
1: 
1:   @Test public void testToDeleteFoldersAndFilesForValidCarbonFile()
0:       throws CarbonUtilException, InterruptedException {
1:     LocalCarbonFile testDir =
1:         new LocalCarbonFile("../core/src/test/resources/testDir/testCarbonFile");
1:     testDir.createNewFile();
1:     CarbonUtil.deleteFoldersAndFiles(testDir);
1:     assertTrue(!testDir.exists());
1:   }
1: 
0:   @Test public void testToGetBadLogPath() throws CarbonUtilException, InterruptedException {
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
0:         return "../unibi-solutions/system/carbon/badRecords";
1:       }
1:     };
0:     String badLogStoreLocation = CarbonUtil.getBadLogPath("badLogPath");
0:     assertEquals(badLogStoreLocation, "../unibi-solutions/system/carbon/badRecords/badLogPath");
1:   }
1: 
1:   @Test public void testToDeleteFoldersAndFilesForCarbonFileSilently()
0:       throws CarbonUtilException, InterruptedException {
1:     LocalCarbonFile testDir = new LocalCarbonFile("../core/src/test/resources/testDir");
1:     testDir.createNewFile();
1:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:     assertTrue(!testDir.exists());
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class)
1:   public void testToDeleteFoldersAndFilesSintlyWithIOException()
0:       throws CarbonUtilException, IOException {
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     LocalCarbonFile testDir =
1:         new LocalCarbonFile("../unibi-solutions/system/carbon/badRecords/badLogPath");
1:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class)
1:   public void testToDeleteFoldersAndFilesSintlyWithInterruptedException()
0:       throws CarbonUtilException, IOException {
1:     new MockUp<UserGroupInformation>() {
1:       @SuppressWarnings("unused") @Mock public UserGroupInformation getLoginUser()
1:           throws InterruptedException {
1:         throw new InterruptedException();
1:       }
1:     };
1:     LocalCarbonFile testDir =
1:         new LocalCarbonFile("../unibi-solutions/system/carbon/badRecords/badLogPath");
1:     CarbonUtil.deleteFoldersAndFilesSilent(testDir);
1:   }
1: 
0:   @Test public void testToDeleteFiles() throws IOException, CarbonUtilException {
1:     String baseDirectory = "../core/src/test/resources/";
1:     File file1 = new File(baseDirectory + "File1.txt");
1:     File file2 = new File(baseDirectory + "File2.txt");
1:     file1.createNewFile();
1:     file2.createNewFile();
1:     File[] files = { file1, file2 };
1:     CarbonUtil.deleteFiles(files);
1:     assertTrue(!file1.exists());
1:     assertTrue(!file2.exists());
1:   }
1: 
1:   @Test public void testToGetNextLesserValue() {
0:     byte[] dataChunks = { new Byte("5"), new Byte("15"), new Byte("30"), new Byte("50") };
0:     byte[] compareValues = { new Byte("5"), new Byte("15"), new Byte("30") };
0:     new MockUp<ByteUtil.UnsafeComparer>() {
1:       @SuppressWarnings("unused") @Mock
0:       public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return -1;
1:       }
1:     };
0:     FixedLengthDimensionDataChunk fixedLengthDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, chunkAttribute);
0:     int result = CarbonUtil.nextLesserValueToTarget(1, fixedLengthDataChunk, compareValues);
0:     assertEquals(result, 0);
1:   }
1: 
1:   @Test public void testToGetNextLesserValueToTarget() {
0:     byte[] dataChunks = { new Byte("5"), new Byte("15"), new Byte("30"), new Byte("50") };
0:     byte[] compareValues = { new Byte("5"), new Byte("15"), new Byte("30") };
0:     new MockUp<ByteUtil.UnsafeComparer>() {
1:       @SuppressWarnings("unused") @Mock
0:       public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 1;
1:       }
1:     };
0:     FixedLengthDimensionDataChunk fixedLengthDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, chunkAttribute);
0:     int result = CarbonUtil.nextLesserValueToTarget(1, fixedLengthDataChunk, compareValues);
1:     assertEquals(result, -1);
1:   }
1: 
1:   @Test public void testToGetnextGreaterValue() {
0:     byte[] dataChunks = { new Byte("5"), new Byte("15"), new Byte("30"), new Byte("50") };
0:     byte[] compareValues = { new Byte("5"), new Byte("15"), new Byte("30") };
0:     new MockUp<ByteUtil.UnsafeComparer>() {
1:       @SuppressWarnings("unused") @Mock
0:       public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 1;
1:       }
1:     };
0:     FixedLengthDimensionDataChunk fixedLengthDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, chunkAttribute);
0:     int result = CarbonUtil.nextGreaterValueToTarget(1, fixedLengthDataChunk, compareValues, 4);
0:     assertEquals(result, 2);
1:   }
1: 
1:   @Test public void testToConvertToIntegerList() {
1:     int[] integerArray = { 10, 20, 30, 40 };
1:     List<Integer> integerList = CarbonUtil.convertToIntegerList(integerArray);
1:     for (int i = 0; i < integerArray.length; i++) {
1:       assertEquals(integerArray[i], (int) integerList.get(i));
1:     }
1:   }
1: 
1:   @Test public void testToGetnextGreaterValueToTarget() {
0:     byte[] dataChunks = { new Byte("5"), new Byte("15"), new Byte("30"), new Byte("50") };
0:     byte[] compareValues = { new Byte("5"), new Byte("15"), new Byte("30") };
0:     new MockUp<ByteUtil.UnsafeComparer>() {
1:       @SuppressWarnings("unused") @Mock
0:       public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 0;
1:       }
1:     };
0:     FixedLengthDimensionDataChunk fixedLengthDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, chunkAttribute);
0:     int result = CarbonUtil.nextGreaterValueToTarget(1, fixedLengthDataChunk, compareValues, 4);
1:     assertEquals(result, 4);
1:   }
1: 
0:   @Test public void testToWriteLevelCardinalityFile() throws KettleException {
0:     int[] dimCardinality = { 10, 20, 30, 40 };
0:     CarbonUtil.writeLevelCardinalityFile("../core/src/test/resources/testDatabase", "testTable",
0:         dimCardinality);
0:     assertTrue(new File("../core/src/test/resources/testDatabase/levelmetadata_testTable.metadata")
0:         .exists());
1:   }
1: 
0:   @Test public void testToGetCardinalityFromLevelMetadataFile() throws CarbonUtilException {
0:     int[] cardinality = CarbonUtil.getCardinalityFromLevelMetadataFile(
0:         "../core/src/test/resources/testDatabase/levelmetadata_testTable.metadata");
0:     int[] expectedCardinality = { 10, 20, 30, 40 };
1:     for (int i = 0; i < cardinality.length; i++) {
0:       assertEquals(cardinality[i], expectedCardinality[i]);
1:     }
1:   }
1: 
0:   @Test public void testToGetCardinalityFromLevelMetadataFileForInvalidPath()
0:       throws CarbonUtilException {
0:     int[] cardinality = CarbonUtil.getCardinalityFromLevelMetadataFile("");
0:     assertEquals(cardinality, null);
1:   }
1: 
1:   @Test public void testToUnescapeChar() {
1:     String[] input = { "\\001", "\\t", "\\r", "\\b", "\\n", "\\f" };
1:     String[] output = { "\001", "\t", "\r", "\b", "\n", "\f" };
1:     for (int i = 0; i < input.length; i++) {
1:       assertEquals(CarbonUtil.unescapeChar(input[i]), output[i]);
1:     }
1:   }
1: 
1:   @Test public void testForDelimiterConverter() {
1:     String[] input =
1:         { "|", "*", ".", ":", "^", "\\", "$", "+", "?", "(", ")", "{", "}", "[", "]", "'" };
1:     String[] expectedResult =
1:         { "\\|", "\\*", "\\.", "\\:", "\\^", "\\\\", "\\$", "\\+", "\\?", "\\(", "\\)", "\\{",
1:             "\\}", "\\[", "\\]", "'" };
1:     for (int i = 0; i < input.length; i++) {
1:       assertEquals(CarbonUtil.delimiterConverter(input[i]), expectedResult[i]);
1:     }
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithNoBlackSlash() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.LOCAL;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "BASE_URL";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
0:     assertEquals(hdfsURL, "BASE_URL/../core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithBlackSlash() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.LOCAL;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "BASE_URL/";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
0:     assertEquals(hdfsURL, "BASE_URL/../core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithNull() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.LOCAL;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return null;
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("../core/src/test/resources/testDatabase");
0:     assertEquals(hdfsURL, "../core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testForisFileExists() {
1:     assertTrue(CarbonUtil.isFileExists("../core/src/test/resources/testFile.txt"));
1:   }
1: 
1:   @Test public void testForisFileExistsWithException() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path)
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     assertTrue(!CarbonUtil.isFileExists("../core/src/test/resources/testFile.txt"));
1:   }
1: 
1:   @Test public void testToCheckAndCreateFolder() {
1:     boolean exists = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/testDatabase");
1:     boolean created = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/newDatabase");
1:     assertTrue(exists);
1:     assertTrue(created);
1:   }
1: 
1:   @Test public void testToCheckAndCreateFolderWithException() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path)
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     boolean exists = CarbonUtil.checkAndCreateFolder("../core/src/test/resources/testDatabase1");
1:     assertTrue(!exists);
1:   }
1: 
1:   @Test public void testToGetFileSize() {
1:     assertEquals(CarbonUtil.getFileSize("../core/src/test/resources/testFile.txt"), 0);
1:   }
1: 
1:   @Test public void testForHasEncoding() {
1:     List<Encoding> encodingList = new ArrayList<>();
1:     encodingList.add(Encoding.INVERTED_INDEX);
1:     encodingList.add(Encoding.DICTIONARY);
1:     encodingList.add(Encoding.DELTA);
1:     assertTrue(CarbonUtil.hasEncoding(encodingList, Encoding.DICTIONARY));
1:     assertTrue(!CarbonUtil.hasEncoding(encodingList, Encoding.BIT_PACKED));
1:   }
1: 
1:   @Test public void testForHasDataTypes() {
0:     DataType[] dataTypes = { DataType.DECIMAL, DataType.BOOLEAN, DataType.INT };
0:     assertTrue(CarbonUtil.hasDataType(DataType.BOOLEAN, dataTypes));
0:     assertTrue(!CarbonUtil.hasDataType(DataType.DATE, dataTypes));
1:   }
1: 
1:   @Test public void testForHasComplexDataTypes() {
0:     assertTrue(CarbonUtil.hasComplexDataType(DataType.ARRAY));
0:     assertTrue(!CarbonUtil.hasComplexDataType(DataType.DATE));
1:   }
1: 
1:   @Test public void testToGetDictionaryEncodingArray() {
0:     QueryDimension column1 = new QueryDimension("Column1");
0:     QueryDimension column2 = new QueryDimension("Column2");
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
1:     List<Encoding> encoding = new ArrayList<>();
1:     encoding.add(Encoding.DICTIONARY);
1:     column1Schema.setEncodingList(encoding);
0:     column1.setDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1: 
1:     column2Schema.setColumnName("Column2");
1:     List<Encoding> encoding2 = new ArrayList<>();
1:     encoding2.add(Encoding.DELTA);
1:     column2Schema.setEncodingList(encoding2);
0:     column2.setDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1: 
0:     QueryDimension[] queryDimensions = { column1, column2 };
1: 
1:     boolean[] dictionaryEncoding = CarbonUtil.getDictionaryEncodingArray(queryDimensions);
1:     boolean[] expectedDictionaryEncoding = { true, false };
1:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:     }
1:   }
1: 
1:   @Test public void testToGetDirectDictionaryEncodingArray() {
0:     QueryDimension column1 = new QueryDimension("Column1");
0:     QueryDimension column2 = new QueryDimension("Column2");
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
1:     List<Encoding> encoding = new ArrayList<>();
1:     encoding.add(Encoding.DIRECT_DICTIONARY);
1:     column1Schema.setEncodingList(encoding);
0:     column1.setDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1: 
1:     column2Schema.setColumnName("Column2");
1:     List<Encoding> encoding2 = new ArrayList<>();
1:     encoding2.add(Encoding.DELTA);
1:     column2Schema.setEncodingList(encoding2);
0:     column2.setDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1: 
0:     QueryDimension[] queryDimensions = { column1, column2 };
1: 
1:     boolean[] dictionaryEncoding = CarbonUtil.getDirectDictionaryEncodingArray(queryDimensions);
1:     boolean[] expectedDictionaryEncoding = { true, false };
1:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:     }
1:   }
1: 
1:   @Test public void testToGetComplexDataTypeArray() {
0:     QueryDimension column1 = new QueryDimension("Column1");
0:     QueryDimension column2 = new QueryDimension("Column2");
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
0:     column1Schema.setDataType(DataType.DATE);
0:     column1.setDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1: 
1:     column2Schema.setColumnName("Column2");
0:     column2Schema.setDataType(DataType.ARRAY);
0:     column2.setDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1: 
0:     QueryDimension[] queryDimensions = { column1, column2 };
1: 
1:     boolean[] dictionaryEncoding = CarbonUtil.getComplexDataTypeArray(queryDimensions);
1:     boolean[] expectedDictionaryEncoding = { false, true };
1:     for (int i = 0; i < dictionaryEncoding.length; i++) {
1:       assertEquals(dictionaryEncoding[i], expectedDictionaryEncoding[i]);
1:     }
1:   }
1: 
0:   @Test public void testToReadMetadatFile() throws CarbonUtilException {
1:     new MockUp<DataFileFooterConverter>() {
1:       @SuppressWarnings("unused") @Mock
0:       public DataFileFooter readDataFileFooter(String filePath, long blockOffset,
0:           long blockLength) {
1:         DataFileFooter fileFooter = new DataFileFooter();
0:         fileFooter.setVersionId(1);
1:         return fileFooter;
1:       }
1:     };
0:     assertEquals(CarbonUtil.readMetadatFile("", 1L, 1L).getVersionId(), 1);
1:   }
1: 
0:   @Test(expected = CarbonUtilException.class) public void testToReadMetadatFileWithException()
1:       throws Exception {
0:     CarbonUtil.readMetadatFile("", 1L, 1L);
1:   }
1: 
1:   @Test public void testToFindDimension() {
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
1:     column2Schema.setColumnName("Column2");
1:     List<CarbonDimension> carbonDimension = new ArrayList<>();
0:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1, 1));
0:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 1, 2, 1));
1:     assertEquals(CarbonUtil.findDimension(carbonDimension, "Column1"),
0:         new CarbonDimension(column1Schema, 1, 1, 1, 1));
1:   }
1: 
1:   @Test public void testToGetFormattedCardinality() {
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     List<Encoding> encoding = new ArrayList<>();
1:     encoding.add(Encoding.DICTIONARY);
1:     List<Encoding> encoding2 = new ArrayList<>();
1:     encoding2.add(Encoding.DIRECT_DICTIONARY);
1:     column1Schema.setEncodingList(encoding);
1:     column2Schema.setEncodingList(encoding2);
1:     List<ColumnSchema> columnSchemas = new ArrayList<>();
1:     columnSchemas.add(column1Schema);
1:     columnSchemas.add(column2Schema);
1:     int[] columnCardinality = { 1, 5 };
1:     int[] result = CarbonUtil.getFormattedCardinality(columnCardinality, columnSchemas);
1:     int[] expectedResult = { 1, 5 };
1:     for (int i = 0; i < result.length; i++) {
1:       assertEquals(result[i], expectedResult[i]);
1:     }
1:   }
1: 
1:   @Test public void testToGetColumnSchemaList() {
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
1:     column2Schema.setColumnName("Column2");
1:     List<CarbonDimension> carbonDimension = new ArrayList<>();
0:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1, 1));
0:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 2, 2, 1));
1: 
1:     List<CarbonMeasure> carbonMeasure = new ArrayList<>();
1:     carbonMeasure.add(new CarbonMeasure(column1Schema, 1));
1:     carbonMeasure.add(new CarbonMeasure(column2Schema, 2));
1: 
1:     List<ColumnSchema> columnSchema =
1:         CarbonUtil.getColumnSchemaList(carbonDimension, carbonMeasure);
1:     for (int i = 0; i < carbonMeasure.size(); i++) {
1:       assertEquals(columnSchema.get(i), carbonMeasure.get(i).getColumnSchema());
1:     }
1:   }
1: 
1:   @Test public void testToReadHeader() throws IOException {
1:     File file = new File("../core/src/test/resources/sampleCSV.csv");
1:     FileWriter writer = new FileWriter(file);
1:     writer.write("id,name");
1:     writer.flush();
1:     String headers = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV.csv");
1:     assertEquals(headers, "id,name");
1:     file.deleteOnExit();
1:   }
1: 
0:   @Test public void testToReadHeaderWithFileNotFoundException() throws IOException {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock
1:       public DataInputStream getDataInputStream(String path, FileFactory.FileType fileType)
1:           throws FileNotFoundException {
1:         throw new FileNotFoundException();
1:       }
1:     };
1:     String result = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV");
1:     assertEquals(null, result);
1:   }
1: 
0:   @Test public void testToReadHeaderWithIOException() throws IOException {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock
1:       public DataInputStream getDataInputStream(String path, FileFactory.FileType fileType)
1:           throws IOException {
1:         throw new IOException();
1:       }
1:     };
1:     String result = CarbonUtil.readHeader("../core/src/test/resources/sampleCSV.csv");
1:     assertEquals(null, result);
1:   }
1: 
1:   @Test public void testToPrintLine() {
1:     String line = CarbonUtil.printLine("*", 2);
1:     assertEquals(line, "**");
1:   }
1: 
1:   @Test public void testToGetSegmentString() {
0:     List<String> list = new ArrayList<>();
0:     list.add("1");
0:     list.add("2");
0:     String segments = CarbonUtil.getSegmentString(list);
1:     assertEquals(segments, "1,2");
1:   }
1: 
1:   @Test public void testToGetSegmentStringWithEmptySegmentList() {
0:     List<String> list = new ArrayList<>();
0:     String segments = CarbonUtil.getSegmentString(list);
1:     assertEquals(segments, "");
1:   }
1: 
1:   @Test public void testToGetSurrogateKey() {
1:     byte[] data = { 1, 1 };
1:     ByteBuffer byteBuffer = ByteBuffer.allocate(8);
1:     int a = CarbonUtil.getSurrogateKey(data, byteBuffer);
1:     assertEquals(a, 257);
1:   }
1: 
1:   @Test public void testToGetValueCompressionModel() {
1:     List<DataChunk> dataChunkList = new ArrayList<>();
1:     DataChunk dataChunk = new DataChunk();
1: 
1:     List<Encoding> encodingList = new ArrayList<>();
1:     encodingList.add(Encoding.DELTA);
0:     dataChunk.setEncoderList(encodingList);
1: 
1:     List<ValueEncoderMeta> valueEncoderMetas = new ArrayList<>();
1:     ValueEncoderMeta valueEncoderMeta = new ValueEncoderMeta();
1:     valueEncoderMeta.setMaxValue(5.0);
1:     valueEncoderMeta.setMinValue(1.0);
1:     valueEncoderMeta.setUniqueValue(2.0);
1:     valueEncoderMeta.setType('n');
1:     valueEncoderMeta.setDataTypeSelected((byte) 'v');
1:     valueEncoderMetas.add(valueEncoderMeta);
1:     dataChunk.setValueEncoderMeta(valueEncoderMetas);
1:     dataChunkList.add(dataChunk);
0:     ValueCompressionModel valueCompressionModel =
0:         CarbonUtil.getValueCompressionModel(dataChunkList);
0:     assertEquals(1, valueCompressionModel.getMaxValue().length);
1:   }
1: 
1:   @Test public void testToGetDictionaryChunkSize() {
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public CarbonProperties getInstance()
1:           throws NumberFormatException {
1:         throw new NumberFormatException();
1:       }
1:     };
1:     int expectedResult = CarbonUtil.getDictionaryChunkSize();
1:     assertEquals(expectedResult, 10000);
1:   }
1: 
1:   @Test public void testToPackByteBufferIntoSingleByteArrayWithNull() {
1:     byte[] byteArray = CarbonUtil.packByteBufferIntoSingleByteArray(null);
1:     assertEquals(null, byteArray);
1:   }
1: 
1:   @Test public void testToPackByteBufferIntoSingleByteArray() {
1:     ByteBuffer[] byteBuffers = { ByteBuffer.allocate(1), ByteBuffer.allocate(2) };
1:     byte[] byteArray = CarbonUtil.packByteBufferIntoSingleByteArray(byteBuffers);
1:     byte[] expectedResult = { 0, 4, 0, 5, 0, 0, 0, 0 };
1:     for (int i = 0; i < byteArray.length; i++) {
1:       assertEquals(expectedResult[i], byteArray[i]);
1:     }
1:   }
1: 
1:   @Test public void testToIdentifyDimensionType() {
1:     ColumnSchema column1Schema = new ColumnSchema();
1:     ColumnSchema column2Schema = new ColumnSchema();
1:     ColumnSchema column3Schema = new ColumnSchema();
1:     column1Schema.setColumnName("Column1");
0:     column1Schema.setColumnar(true);
1:     column1Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.DICTIONARY));
1:     column2Schema.setColumnName("Column2");
0:     column2Schema.setColumnar(false);
1:     column2Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.DICTIONARY));
1:     column3Schema.setColumnName("Column3");
0:     column3Schema.setColumnar(true);
1:     column3Schema.setEncodingList(Arrays.asList(Encoding.DELTA, Encoding.INVERTED_INDEX));
0:     CarbonDimension carbonDimension = new CarbonDimension(column1Schema,1,1,1,1);
0:     CarbonDimension carbonDimension2 = new CarbonDimension(column2Schema,2,2,2,2);
0:     CarbonDimension carbonDimension3 = new CarbonDimension(column3Schema,3,3,3,3);
0:     List<CarbonDimension> carbonDimensions = Arrays.asList(carbonDimension, carbonDimension2, carbonDimension3);
1:     boolean[] result = CarbonUtil.identifyDimensionType(carbonDimensions);
0:     assertThat(result, is(equalTo(new boolean[]{true, true, false})));
1:   }
1: 
1:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareTo1() {
0:     DimensionChunkAttributes dimensionChunkAttributes = new DimensionChunkAttributes();
0:     new MockUp<ByteUtil.UnsafeComparer>() {
0:       @SuppressWarnings("unused") @Mock public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 1;
1:       }
1:     };
0:     byte[] dataChunks = {10,20,30};
0:     byte[] compareValue = {1,20,30};
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunks, dimensionChunkAttributes);
0:     int result = CarbonUtil.getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk,1, 3, compareValue, false);
1:     assertEquals(-2, result);
1:   }
1: 
1:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareToLessThan0() {
0:     DimensionChunkAttributes dimensionChunkAttributes = new DimensionChunkAttributes();
0:     new MockUp<ByteUtil.UnsafeComparer>() {
0:       @SuppressWarnings("unused") @Mock public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return -1;
1:       }
1:     };
0:     byte[] dataChunks = {10,20,30};
0:     byte[] compareValue = {1,20,30};
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunks, dimensionChunkAttributes);
0:     int result = CarbonUtil.getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk,1, 3, compareValue, false);
0:     assertEquals(-5, result);
1:   }
1: 
1:   @Test public void testToGetFirstIndexUsingBinarySearchWithCompareTo0() {
0:     DimensionChunkAttributes dimensionChunkAttributes = new DimensionChunkAttributes();
0:     new MockUp<ByteUtil.UnsafeComparer>() {
0:       @SuppressWarnings("unused") @Mock public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 0;
1:       }
1:     };
0:     byte[] dataChunks = {10,20,30};
0:     byte[] compareValue = {1,20,30};
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunks, dimensionChunkAttributes);
0:     int result = CarbonUtil.getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk,1, 3, compareValue, false);
1:     assertEquals(0, result);
1:   }
1: 
1:   @Test public void testToGetFirstIndexUsingBinarySearchWithMatchUpLimitTrue() {
0:     DimensionChunkAttributes dimensionChunkAttributes = new DimensionChunkAttributes();
0:     new MockUp<ByteUtil.UnsafeComparer>() {
0:       @SuppressWarnings("unused") @Mock public int compareTo(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2,
0:           int length2) {
0:         return 0;
1:       }
1:     };
0:     byte[] dataChunks = {10,20,30};
0:     byte[] compareValue = {1,20,30};
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunks, dimensionChunkAttributes);
0:     int result = CarbonUtil.getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk,1, 3, compareValue, true);
0:     assertEquals(3, result);
1:   }
1: 
1:   @AfterClass public static void testcleanUp() {
1:     new File("../core/src/test/resources/testFile.txt").deleteOnExit();
1:     new File("../core/src/test/resources/testDatabase/levelmetadata_testTable.metadata")
1:         .deleteOnExit();
1:     new File("../core/src/test/resources/testDatabase").delete();
1:     new File("../core/src/test/resources/newDatabase").deleteOnExit();
1:   }
1: 
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
/////////////////////////////////////////////////////////////////////////
1:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
/////////////////////////////////////////////////////////////////////////
1:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1));
1:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1));
/////////////////////////////////////////////////////////////////////////
1:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1));
1:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 1, 1));
1:         new CarbonDimension(column1Schema, 1, 1, 1));
/////////////////////////////////////////////////////////////////////////
1:     carbonDimension.add(new CarbonDimension(column1Schema, 1, 1, 1));
1:     carbonDimension.add(new CarbonDimension(column2Schema, 2, 2, 1));
/////////////////////////////////////////////////////////////////////////
1:     CarbonDimension carbonDimension = new CarbonDimension(column1Schema, 1, 1, 1);
1:     CarbonDimension carbonDimension2 = new CarbonDimension(column2Schema, 2, 2, 2);
1:     CarbonDimension carbonDimension3 = new CarbonDimension(column3Schema, 3, 3, 3);
author:akashrn5
-------------------------------------------------------------------------------
commit:4935cb1
/////////////////////////////////////////////////////////////////////////
1: //    int index = CarbonUtil.binarySearch(dataArr, 0, dataChunk.length / keyWord.length - 1, keyWord);
1: //    assertTrue(expectRangeIndex[0] <= index && index <= range[1]);
author:Jacky Li
-------------------------------------------------------------------------------
commit:daa6465
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.chunk.impl.FixedLengthDimensionColumnPage;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.model.ProjectionDimension;
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 5, 1);
/////////////////////////////////////////////////////////////////////////
1:     ProjectionDimension
0:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1:     ProjectionDimension
0:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1:     ProjectionDimension[] queryDimensions = { column1, column2 };
/////////////////////////////////////////////////////////////////////////
1:     ProjectionDimension
0:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1:     ProjectionDimension
0:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1:     ProjectionDimension[] queryDimensions = { column1, column2 };
/////////////////////////////////////////////////////////////////////////
1:     ProjectionDimension
0:         column1 = new ProjectionDimension(new CarbonDimension(column1Schema, 1, 1, 1, 1));
1:     ProjectionDimension
0:         column2 = new ProjectionDimension(new CarbonDimension(column2Schema, 1, 1, 1, 1));
1:     ProjectionDimension[] queryDimensions = { column1, column2 };
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk =
1:         new FixedLengthDimensionColumnPage(dataChunks, null, null, 6, 1);
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:     FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk;
1:     fixedLengthDimensionDataChunk = new FixedLengthDimensionColumnPage(dataChunk, null, null,
/////////////////////////////////////////////////////////////////////////
1:       FixedLengthDimensionColumnPage fixedLengthDimensionDataChunk, byte[] keyWord, int[] expectRangeIndex) {
commit:933e30c
/////////////////////////////////////////////////////////////////////////
1:     assertTrue(DataTypes.createDefaultArrayType().isComplexType());
/////////////////////////////////////////////////////////////////////////
1:     column2Schema.setDataType(DataTypes.createDefaultArrayType());
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.datatype.DecimalType;
/////////////////////////////////////////////////////////////////////////
1:     DataType[] dataTypes = {DataTypes.createDefaultDecimalType(), DataTypes.BOOLEAN, DataTypes.INT };
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:     DataType[] dataTypes = { DataTypes.DECIMAL, DataTypes.BOOLEAN, DataTypes.INT };
1:     assertTrue(CarbonUtil.hasDataType(DataTypes.BOOLEAN, dataTypes));
1:     assertTrue(!CarbonUtil.hasDataType(DataTypes.DATE, dataTypes));
0:     assertTrue(DataTypes.ARRAY.isComplexType());
1:     assertTrue(!DataTypes.DATE.isComplexType());
/////////////////////////////////////////////////////////////////////////
1:     column1Schema.setDataType(DataTypes.DATE);
0:     column2Schema.setDataType(DataTypes.ARRAY);
author:ravipesala
-------------------------------------------------------------------------------
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.Segment;
/////////////////////////////////////////////////////////////////////////
1:     List<Segment> list = new ArrayList<>();
0:     list.add(new Segment("1", null));
0:     list.add(new Segment("2", null));
1:     List<Segment> list = new ArrayList<>();
commit:b8a02f3
/////////////////////////////////////////////////////////////////////////
1:     String segments = CarbonUtil.convertToString(list);
1:     String segments = CarbonUtil.convertToString(list);
commit:e6b6090
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.DataInputStream;
1: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.FileReader;
1: import java.io.FileWriter;
1: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.List;
0: import org.apache.carbondata.core.datastore.columnar.ColumnGroupModel;
0: import org.apache.carbondata.core.datastore.compression.WriterCompressModel;
1: import org.apache.carbondata.core.datastore.filesystem.LocalCarbonFile;
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
1: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
0: import org.apache.carbondata.core.metadata.ValueEncoderMeta;
/////////////////////////////////////////////////////////////////////////
0: import mockit.Mock;
0: import mockit.MockUp;
1: import static junit.framework.TestCase.assertEquals;
1: import static junit.framework.TestCase.assertTrue;
0: import static org.hamcrest.MatcherAssert.assertThat;
/////////////////////////////////////////////////////////////////////////
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.carbondata.core.util;
1: 
0: import junit.framework.TestCase;
1: import org.junit.Test;
1: 
0: public class CarbonUtilTest extends TestCase {
1: 
1:   @Test public void testGetBitLengthForDimensionGiveProperValue() {
0:     int[] cardinality = { 10, 1, 10000, 1, 2, 3 };
1:     int[] dimensionBitLength =
1:         CarbonUtil.getDimensionBitLength(cardinality, new int[] { 1, 1, 3, 1 });
1:     int[] expectedOutPut = { 8, 8, 14, 2, 8, 8 };
1:     for (int i = 0; i < dimensionBitLength.length; i++) {
1:       assertEquals(expectedOutPut[i], dimensionBitLength[i]);
1:     }
1:   }
1: }
author:manishgupta88
-------------------------------------------------------------------------------
commit:1248bd4
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testUpdateMinMaxValues() {
1:     // create dimension and measure column schema
1:     ColumnSchema dimensionColumnSchema = createColumnSchema(DataTypes.STRING, true);
1:     ColumnSchema measureColumnSchema = createColumnSchema(DataTypes.DOUBLE, false);
1:     List<ColumnSchema> columnSchemas = new ArrayList<>(2);
1:     columnSchemas.add(dimensionColumnSchema);
1:     columnSchemas.add(measureColumnSchema);
1:     // create data file footer object
1:     DataFileFooter fileFooter = new DataFileFooter();
1:     fileFooter.setColumnInTable(columnSchemas);
1:     // initialise the expected values
1:     int expectedMaxValue = 5;
1:     int expectedMinValue = 2;
1:     double expectedMeasureMaxValue = 28.74;
1:     double expectedMeasureMinValue = -21.46;
1:     // initialise the minValues
1:     byte[][] minValues = new byte[2][];
1:     minValues[0] = new byte[] { 2 };
1:     ByteBuffer buffer = ByteBuffer.allocate(8);
1:     minValues[1] = (byte[]) buffer.putDouble(28.74).flip().array();
1:     buffer = ByteBuffer.allocate(8);
1:     // initialise the maxValues
1:     byte[][] maxValues = new byte[2][];
1:     maxValues[0] = new byte[] { 5 };
1:     maxValues[1] = (byte[]) buffer.putDouble(-21.46).flip().array();
1:     byte[][] updateMaxValues =
1:         CarbonUtil.updateMinMaxValues(fileFooter, maxValues, minValues, false);
1:     byte[][] updateMinValues =
1:         CarbonUtil.updateMinMaxValues(fileFooter, maxValues, minValues, true);
1:     // compare max values
1:     assert (expectedMaxValue == ByteBuffer.wrap(updateMaxValues[0]).get());
1:     assert (expectedMeasureMaxValue == ByteBuffer.wrap(updateMaxValues[1]).getDouble());
1: 
1:     // compare min values
1:     assert (expectedMinValue == ByteBuffer.wrap(updateMinValues[0]).get());
1:     assert (expectedMeasureMinValue == ByteBuffer.wrap(updateMinValues[1]).getDouble());
1:   }
1: 
1:   private ColumnSchema createColumnSchema(DataType dataType, boolean isDimensionColumn) {
1:     ColumnSchema columnSchema = new ColumnSchema();
1:     columnSchema.setDataType(dataType);
1:     columnSchema.setDimensionColumn(isDimensionColumn);
1:     return columnSchema;
1:   }
1: 
author:xuchuanyin
-------------------------------------------------------------------------------
commit:29be1d0
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Assert;
/////////////////////////////////////////////////////////////////////////
1:     Assert.assertTrue(map.size() == 2);
1:     Assert.assertTrue(schemaString.length() > schema.length());
1:     Assert.assertTrue(map.size() == 2);
1:     Assert.assertTrue(schemaString.length() > schema.length());
1:     Assert.assertTrue(map.size() == 3);
1:     Assert.assertTrue(schemaString.length() > schema.length());
1:     Assert.assertTrue(map.size() == 4);
1:     Assert.assertTrue(schemaString.length() > schema.length());
author:xubo245
-------------------------------------------------------------------------------
commit:e2a2d99
/////////////////////////////////////////////////////////////////////////
author:Manohar
-------------------------------------------------------------------------------
commit:33de599
/////////////////////////////////////////////////////////////////////////
0:     try {
0:       int[] cardinality = CarbonUtil.getCardinalityFromLevelMetadataFile("");
0:       assertTrue(false);
0:     } catch (Exception e) {
0:       assertTrue(true);
1:     }
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:baca6f9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testSplitSchemaStringToMapWithLessThanSplitLen() {
1:     String schema = generateString(399);
1:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
0:     assert (map.size() == 2);
1:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
0:     assert (schemaString.length() > schema.length());
1:   }
1: 
1:   @Test
1:   public void testSplitSchemaStringToMapWithEqualThanSplitLen() {
1:     String schema = generateString(4000);
1:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
0:     assert (map.size() == 2);
1:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
0:     assert (schemaString.length() > schema.length());
1:   }
1: 
1:   @Test
1:   public void testSplitSchemaStringToMapWithMoreThanSplitLen() {
1:     String schema = generateString(7999);
1:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
0:     assert (map.size() == 3);
1:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
0:     assert (schemaString.length() > schema.length());
1:   }
1: 
1:   @Test
1:   public void testSplitSchemaStringToMapWithMultiplesOfSplitLen() {
1:     String schema = generateString(12000);
1:     Map<String, String> map = CarbonUtil.splitSchemaStringToMap(schema);
0:     assert (map.size() == 4);
1:     String schemaString = CarbonUtil.splitSchemaStringToMultiString(" ", "'", ",", schema);
0:     assert (schemaString.length() > schema.length());
1:   }
1: 
1:   private String generateString(int length) {
1:     StringBuilder builder = new StringBuilder();
1:     for (int i = 0; i < length; i++) {
1:       builder.append("a");
1:     }
1:     return builder.toString();
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:dhatchayani
-------------------------------------------------------------------------------
commit:c671c5b
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(hdfsURL, "file:///BASE_URL/../core/src/test/resources/testDatabase");
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(hdfsURL, "file:///BASE_URL/../core/src/test/resources/testDatabase");
/////////////////////////////////////////////////////////////////////////
1:   @Test public void testToCheckAndAppendHDFSUrlWithHdfs() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.HDFS;
1:       }
1:     };
1:     new MockUp<org.apache.hadoop.conf.Configuration>() {
1:       @SuppressWarnings("unused") @Mock public String get(String name) {
1:         return "hdfs://";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("hdfs://ha/core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "hdfs://ha/core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithDoubleSlashLocal() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.LOCAL;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "/opt/";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "file:////opt/core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithDoubleSlashHDFS() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.HDFS;
1:       }
1:     };
1:     new MockUp<org.apache.hadoop.conf.Configuration>() {
1:       @SuppressWarnings("unused") @Mock public String get(String name) {
1:         return "hdfs://";
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "/opt/";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "hdfs:///opt/core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithBaseURLPrefix() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.HDFS;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "hdfs://ha/opt/";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "hdfs://ha/opt/core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithBaseURLFile() {
1:     new MockUp<FileFactory>() {
1:       @SuppressWarnings("unused") @Mock public FileFactory.FileType getFileType(String path) {
1:         return FileFactory.FileType.HDFS;
1:       }
1:     };
1:     new MockUp<CarbonProperties>() {
1:       @SuppressWarnings("unused") @Mock public String getProperty(String key) {
1:         return "file:///";
1:       }
1:     };
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("/core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "file:///core/src/test/resources/testDatabase");
1:   }
1: 
1:   @Test public void testToCheckAndAppendHDFSUrlWithFilepathPrefix() {
1:     String hdfsURL = CarbonUtil.checkAndAppendHDFSUrl("file:///core/src/test/resources/testDatabase");
1:     assertEquals(hdfsURL, "file:///core/src/test/resources/testDatabase");
1:   }
1: 
commit:47a05a8
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(hdfsURL, "/BASE_URL/../core/src/test/resources/testDatabase");
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(hdfsURL, "/BASE_URL/../core/src/test/resources/testDatabase");
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(hdfsURL, "file:////../core/src/test/resources/testDatabase");
author:kumarvishal
-------------------------------------------------------------------------------
commit:8a5ed81
/////////////////////////////////////////////////////////////////////////
1:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1, null);
/////////////////////////////////////////////////////////////////////////
1:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1, null);
commit:8d9babe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     byte[] dataChunks = { 5, 6, 7, 8, 9 };
1:     byte[] compareValues = { 7 };
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 5, 1);
1:     int result = CarbonUtil.nextLesserValueToTarget(2, fixedLengthDataChunk, compareValues);
1:     assertEquals(result, 1);
1:     byte[] dataChunks = { 7, 7, 7, 8, 9 };
1:     byte[] compareValues = { 7 };
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 5, 1);
1:     int result = CarbonUtil.nextLesserValueToTarget(2, fixedLengthDataChunk, compareValues);
1:     byte[] dataChunks = { 5, 6, 7, 8, 9 };
1:     byte[] compareValues = { 7 };
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 5, 1);
1:     int result = CarbonUtil.nextGreaterValueToTarget(2, fixedLengthDataChunk, compareValues, 5);
1:     assertEquals(result, 3);
/////////////////////////////////////////////////////////////////////////
1:     byte[] dataChunks = { 5, 6, 7, 7, 7 };
1:     byte[] compareValues = { 7 };
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 5, 1);
1:     int result = CarbonUtil.nextGreaterValueToTarget(2, fixedLengthDataChunk, compareValues, 5);
1:     assertEquals(result, 5);
/////////////////////////////////////////////////////////////////////////
1:     TableBlockInfo info =
0:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1);
1: 
1:     TableBlockInfo info =
0:         new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1);
/////////////////////////////////////////////////////////////////////////
0:     CarbonDimension carbonDimension = new CarbonDimension(column1Schema, 1, 1, 1, 1);
0:     CarbonDimension carbonDimension2 = new CarbonDimension(column2Schema, 2, 2, 2, 2);
0:     CarbonDimension carbonDimension3 = new CarbonDimension(column3Schema, 3, 3, 3, 3);
1:     List<CarbonDimension> carbonDimensions =
1:         Arrays.asList(carbonDimension, carbonDimension2, carbonDimension3);
1:     assertThat(result, is(equalTo(new boolean[] { true, true, false })));
1:     byte[] dataChunks = { 10, 20, 30, 40, 50, 60 };
1:     byte[] compareValue = { 5 };
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 6, 1);
1:     int result = CarbonUtil
1:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:     byte[] dataChunks = { 10, 20, 30, 40, 50, 60 };
1:     byte[] compareValue = { 30 };
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 6, 1);
1:     int result = CarbonUtil
1:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:     assertEquals(2, result);
1:     byte[] dataChunks = { 10, 10, 10, 40, 50, 60 };
1:     byte[] compareValue = { 10 };
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 6, 1);
1:     int result = CarbonUtil
1:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, false);
1:     byte[] dataChunks = { 10, 10, 10, 40, 50, 60 };
1:     byte[] compareValue = { 10 };
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk =
0:         new FixedLengthDimensionDataChunk(dataChunks, null, null, 6, 1);
1:     int result = CarbonUtil
1:         .getFirstIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 1, 3, compareValue, true);
1:     assertEquals(2, result);
commit:d54dc64
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.carbondata.core.carbon.datastore.block.TableBlockInfo;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:       public DataFileFooter readDataFileFooter(TableBlockInfo info) {
0:         fileFooter.setVersionId((short)1);
0:     TableBlockInfo info = new TableBlockInfo("file:/", 1, "0", new String[0], 1, (short)1);
1:     
0:     assertEquals(CarbonUtil.readMetadatFile(info).getVersionId(), 1);
0: 	TableBlockInfo info = new TableBlockInfo("file:/", 1, "0", new String[0], 1, (short)1);
1:     CarbonUtil.readMetadatFile(info);
/////////////////////////////////////////////////////////////////////////
0:         CarbonUtil.getValueCompressionModel(dataChunkList.get(0).getValueEncoderMeta());
author:jackylk
-------------------------------------------------------------------------------
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(1, dataChunkList.get(0).getValueEncoderMeta().size());
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.ColumnarFormatVersion;
1: import org.apache.carbondata.core.datastore.block.TableBlockInfo;
0: import org.apache.carbondata.core.datastore.chunk.impl.FixedLengthDimensionDataChunk;
1: import org.apache.carbondata.core.metadata.blocklet.DataFileFooter;
1: import org.apache.carbondata.core.metadata.blocklet.datachunk.DataChunk;
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
0: import org.apache.carbondata.core.datastore.columnar.ColumnGroupModel;
0: import org.apache.carbondata.core.datastore.compression.WriterCompressModel;
0: import org.apache.carbondata.core.datastore.filesystem.LocalCarbonFile;
0: import org.apache.carbondata.core.datastore.impl.FileFactory;
0: import org.apache.carbondata.core.scan.model.QueryDimension;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
1:       throws InterruptedException, IOException {
1:   @Test(expected = IOException.class) public void testToDeleteFolderWithIOException()
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = InterruptedException.class)
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = IOException.class) public void testToDeleteFoldersAndFilesWithIOException()
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = InterruptedException.class) public void testToDeleteFoldersAndFilesWithInterruptedException()
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:       throws InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
0:   @Test public void testToGetBadLogPath() throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:       throws IOException, InterruptedException {
1:   @Test(expected = IOException.class)
1:       throws IOException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = InterruptedException.class)
1:       throws IOException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:   @Test public void testToDeleteFiles() throws IOException {
/////////////////////////////////////////////////////////////////////////
0:   @Test public void testToGetCardinalityFromLevelMetadataFile()
0:       throws IOException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:       throws IOException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:   @Test public void testToReadMetadatFile() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = IOException.class)
1:   public void testToReadMetadatFileWithException()
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = IOException.class)
1:   public void testToReadHeaderWithFileNotFoundException() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:   @Test(expected = IOException.class)
1:   public void testToReadHeaderWithIOException() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     dataChunk.setEncodingList(encodingList);
commit:360edc8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datastorage.store.compression.WriterCompressModel;
/////////////////////////////////////////////////////////////////////////
0:     WriterCompressModel writerCompressModel =
0:     assertEquals(1, writerCompressModel.getMaxValue().length);
commit:0ef3fb8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.carbon.ColumnarFormatVersion;
/////////////////////////////////////////////////////////////////////////
1:         fileFooter.setVersionId(ColumnarFormatVersion.V1);
0:     TableBlockInfo info = new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1);
1:     assertEquals(CarbonUtil.readMetadatFile(info).getVersionId().number(), 1);
0: 	TableBlockInfo info = new TableBlockInfo("file:/", 1, "0", new String[0], 1, ColumnarFormatVersion.V1);
author:mayun
-------------------------------------------------------------------------------
commit:bedaa59
/////////////////////////////////////////////////////////////////////////
1:   
1:   @Test
1:   public void testBinaryRangeSearch() {
1:     byte[] dataChunk = new byte[10];
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk;
1:     byte[] keyWord = new byte[1];
1:     int[] range;
1: 
1:     dataChunk = "abbcccddddeffgggh".getBytes();
1:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
0:     }
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     int[] expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 0;
1:     expectRangeIndex[1] = 0;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     keyWord[0] = Byte.valueOf("104");
1:     expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 16;
1:     expectRangeIndex[1] = 16;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     keyWord[0] = Byte.valueOf("101");
1:     expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 10;
1:     expectRangeIndex[1] = 10;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     keyWord[0] = Byte.valueOf("99");
1:     expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 3;
1:     expectRangeIndex[1] = 5;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     dataChunk = "ab".getBytes();
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(0, range[0]);
1:     assertEquals(0, range[1]);
1: 
1:     keyWord[0] = Byte.valueOf("98");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(1, range[0]);
1:     assertEquals(1, range[1]);
1: 
1:     dataChunk = "aabb".getBytes();
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(0, range[0]);
1:     assertEquals(1, range[1]);
1: 
1:     keyWord[0] = Byte.valueOf("98");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(2, range[0]);
1:     assertEquals(3, range[1]);
1: 
1:     dataChunk = "a".getBytes();
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(0, range[0]);
1:     assertEquals(0, range[1]);
1: 
1:     dataChunk = "aa".getBytes();
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(0, range[0]);
1:     assertEquals(1, range[1]);
1: 
1:     dataChunk = "aabbbbbbbbbbcc".getBytes();
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1:     keyWord[0] = Byte.valueOf("98");
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0, dataChunk.length - 1, keyWord);
1:     assertEquals(2, range[0]);
1:     assertEquals(11, range[1]);
1: 
0:   }
1: 
1:   @Test
1:   public void IndexUsingBinarySearchLengthTwo() {
1: 
1:     byte[] dataChunk = new byte[10];
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk;
1: 
1:     byte[] keyWord = new byte[2];
1: 
1:     dataChunk = "aabbbbbbbbbbcc".getBytes();
1:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
1: 
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
0:     }
1: 
1:     keyWord[0] = Byte.valueOf("98");
1:     keyWord[1] = Byte.valueOf("98");
1:     int[] expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 1;
1:     expectRangeIndex[1] = 5;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     keyWord[0] = Byte.valueOf("97");
1:     keyWord[1] = Byte.valueOf("97");
1: 
1:     expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 0;
1:     expectRangeIndex[1] = 0;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
1:     keyWord[0] = Byte.valueOf("99");
1:     keyWord[1] = Byte.valueOf("99");
1:     expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 6;
1:     expectRangeIndex[1] = 6;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
0:   }
1: 
1:   @Test
1:   public void IndexUsingBinarySearchLengthThree() {
1: 
1:     byte[] dataChunk = new byte[10];
0:     FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk;
1: 
1:     byte[] keyWord = new byte[3];
1: 
1:     dataChunk = "aaabbbbbbbbbccc".getBytes();
1:     byte[][] dataArr = new byte[dataChunk.length / keyWord.length][keyWord.length];
1: 
0:     fixedLengthDimensionDataChunk = new FixedLengthDimensionDataChunk(dataChunk, null, null,
1:         dataChunk.length / keyWord.length, keyWord.length);
1: 
1:     for (int ii = 0; ii < dataChunk.length / keyWord.length; ii++) {
1:       dataArr[ii] = fixedLengthDimensionDataChunk.getChunkData(ii);
0:     }
1: 
1:     keyWord[0] = Byte.valueOf("98");
1:     keyWord[1] = Byte.valueOf("98");
1:     keyWord[2] = Byte.valueOf("98");
1:     int[] expectRangeIndex = new int[2];
1:     expectRangeIndex[0] = 1;
1:     expectRangeIndex[1] = 3;
1:     assertRangeIndex(dataArr, dataChunk, fixedLengthDimensionDataChunk, keyWord, expectRangeIndex);
1: 
0:   }
1: 
1:   private void assertRangeIndex(byte[][] dataArr, byte[] dataChunk,
0:       FixedLengthDimensionDataChunk fixedLengthDimensionDataChunk, byte[] keyWord, int[] expectRangeIndex) {
1:     int[] range;
1:     range = CarbonUtil.getRangeIndexUsingBinarySearch(fixedLengthDimensionDataChunk, 0,
1:         (dataChunk.length - 1) / keyWord.length, keyWord);
1:     assertEquals(expectRangeIndex[0], range[0]);
1:     assertEquals(expectRangeIndex[1], range[1]);
1: 
0:     int index = CarbonUtil.binarySearch(dataArr, 0, dataChunk.length / keyWord.length - 1, keyWord);
0:     assertTrue(expectRangeIndex[0] <= index && index <= range[1]);
0:   }
1:  	
1:  	
author:QiangCai
-------------------------------------------------------------------------------
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:b6ab4ef
/////////////////////////////////////////////////////////////////////////
0:     assertEquals(badLogStoreLocation.replace("\\", "/"), "../unibi-solutions/system/carbon/badRecords/badLogPath");
============================================================================