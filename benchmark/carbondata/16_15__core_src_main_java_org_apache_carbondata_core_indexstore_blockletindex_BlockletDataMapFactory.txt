1:b681244: /*
1:b681244:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b681244:  * contributor license agreements.  See the NOTICE file distributed with
1:b681244:  * this work for additional information regarding copyright ownership.
1:b681244:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b681244:  * (the "License"); you may not use this file except in compliance with
1:b681244:  * the License.  You may obtain a copy of the License at
1:b681244:  *
1:b681244:  *    http://www.apache.org/licenses/LICENSE-2.0
1:b681244:  *
1:b681244:  * Unless required by applicable law or agreed to in writing, software
1:b681244:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b681244:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b681244:  * See the License for the specific language governing permissions and
1:b681244:  * limitations under the License.
1:b681244:  */
1:b681244: package org.apache.carbondata.core.indexstore.blockletindex;
1:b681244: 
1:b681244: import java.io.IOException;
1:7ef9164: import java.util.*;
1:77a1110: import java.util.concurrent.ConcurrentHashMap;
1:b681244: 
1:b681244: import org.apache.carbondata.core.cache.Cache;
1:b681244: import org.apache.carbondata.core.cache.CacheProvider;
1:b681244: import org.apache.carbondata.core.cache.CacheType;
1:531ecdf: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:f089287: import org.apache.carbondata.core.datamap.DataMapDistributable;
1:f089287: import org.apache.carbondata.core.datamap.DataMapMeta;
1:8d3c774: import org.apache.carbondata.core.datamap.Segment;
1:531ecdf: import org.apache.carbondata.core.datamap.dev.CacheableDataMap;
1:fc2a7eb: import org.apache.carbondata.core.datamap.dev.DataMap;
1:747be9b: import org.apache.carbondata.core.datamap.dev.DataMapBuilder;
1:fc2a7eb: import org.apache.carbondata.core.datamap.dev.DataMapWriter;
1:fc2a7eb: import org.apache.carbondata.core.datamap.dev.cgdatamap.CoarseGrainDataMap;
1:fc2a7eb: import org.apache.carbondata.core.datamap.dev.cgdatamap.CoarseGrainDataMapFactory;
1:ca7e2e3: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1:b681244: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
1:b681244: import org.apache.carbondata.core.datastore.impl.FileFactory;
1:5229443: import org.apache.carbondata.core.features.TableOperation;
1:28f78b2: import org.apache.carbondata.core.indexstore.Blocklet;
1:531ecdf: import org.apache.carbondata.core.indexstore.BlockletDataMapIndexWrapper;
1:28f78b2: import org.apache.carbondata.core.indexstore.BlockletDetailsFetcher;
1:28f78b2: import org.apache.carbondata.core.indexstore.ExtendedBlocklet;
1:d35fbaf: import org.apache.carbondata.core.indexstore.PartitionSpec;
1:ca7e2e3: import org.apache.carbondata.core.indexstore.SegmentPropertiesFetcher;
1:b681244: import org.apache.carbondata.core.indexstore.TableBlockIndexUniqueIdentifier;
1:5f68a79: import org.apache.carbondata.core.indexstore.TableBlockIndexUniqueIdentifierWrapper;
1:531ecdf: import org.apache.carbondata.core.memory.MemoryException;
1:b681244: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1:860e144: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
1:56330ae: import org.apache.carbondata.core.metadata.schema.table.DataMapSchema;
1:3894e1d: import org.apache.carbondata.core.scan.filter.resolver.FilterResolverIntf;
1:531ecdf: import org.apache.carbondata.core.util.BlockletDataMapUtil;
1:28f78b2: import org.apache.carbondata.core.util.path.CarbonTablePath;
1:4aa0f49: import org.apache.carbondata.events.Event;
1:b681244: 
1:2f79e14: import org.apache.commons.logging.Log;
1:2f79e14: import org.apache.commons.logging.LogFactory;
1:1e21cd1: import org.apache.hadoop.fs.FileSystem;
1:1e21cd1: import org.apache.hadoop.fs.LocatedFileStatus;
1:1e21cd1: import org.apache.hadoop.fs.Path;
1:1e21cd1: import org.apache.hadoop.fs.RemoteIterator;
1:ca7e2e3: 
1:b681244: /**
1:b681244:  * Table map for blocklet
1:b681244:  */
1:fc2a7eb: public class BlockletDataMapFactory extends CoarseGrainDataMapFactory
1:531ecdf:     implements BlockletDetailsFetcher, SegmentPropertiesFetcher, CacheableDataMap {
1:b681244: 
1:2f79e14:   private static final Log LOG = LogFactory.getLog(BlockletDataMapFactory.class);
1:56330ae:   private static final String NAME = "clustered.btree.blocklet";
1:6118711:   /**
1:6118711:    * variable for cache level BLOCKLET
1:6118711:    */
1:1cea4d3:   public static final String CACHE_LEVEL_BLOCKLET = "BLOCKLET";
1:ca7e2e3: 
1:56330ae:   public static final DataMapSchema DATA_MAP_SCHEMA =
1:fc2a7eb:       new DataMapSchema(NAME, BlockletDataMapFactory.class.getName());
2:56330ae: 
1:b681244:   private AbsoluteTableIdentifier identifier;
1:b681244: 
1:f089287:   // segmentId -> list of index file
1:77a1110:   private Map<String, Set<TableBlockIndexUniqueIdentifier>> segmentMap = new ConcurrentHashMap<>();
1:b681244: 
1:5f68a79:   private Cache<TableBlockIndexUniqueIdentifierWrapper, BlockletDataMapIndexWrapper> cache;
1:b681244: 
1:9db662a:   public BlockletDataMapFactory(CarbonTable carbonTable, DataMapSchema dataMapSchema) {
1:9db662a:     super(carbonTable, dataMapSchema);
1:860e144:     this.identifier = carbonTable.getAbsoluteTableIdentifier();
1:b681244:     cache = CacheProvider.getInstance()
1:1155d4d:         .createCache(CacheType.DRIVER_BLOCKLET_DATAMAP);
1:b681244:   }
1:b681244: 
1:6118711:   /**
1:6118711:    * create dataMap based on cache level
1:6118711:    *
1:6118711:    * @param carbonTable
1:6118711:    * @return
1:6118711:    */
1:6118711:   public static DataMap createDataMap(CarbonTable carbonTable) {
1:3cbabcd:     boolean cacheLevelBlock = BlockletDataMapUtil.isCacheLevelBlock(carbonTable);
1:6118711:     if (cacheLevelBlock) {
1:6118711:       // case1: when CACHE_LEVEL = BLOCK
1:6118711:       return new BlockDataMap();
1:8d3c774:     } else {
1:6118711:       // case2: when CACHE_LEVEL = BLOCKLET
1:6118711:       return new BlockletDataMap();
1:b681244:     }
1:6118711:   }
1:b681244: 
1:f089287:   @Override
1:cd7c210:   public DataMapWriter createWriter(Segment segment, String shardName,
1:cd7c210:       SegmentProperties segmentProperties) throws IOException {
1:9db662a:     throw new UnsupportedOperationException("not implemented");
1:8d3c774:   }
1:8d3c774: 
1:9db662a:   @Override
1:cd7c210:   public DataMapBuilder createBuilder(Segment segment, String shardName,
1:cd7c210:       SegmentProperties segmentProperties) throws IOException {
1:f089287:     throw new UnsupportedOperationException("not implemented");
1:d8562e5:   }
1:d8562e5: 
1:e580d64:   /**
1:e580d64:    * Get the datamap for all segments
1:e580d64:    */
1:e580d64:   public Map<Segment, List<CoarseGrainDataMap>> getDataMaps(List<Segment> segments)
1:d35fbaf:       throws IOException {
1:e580d64:     List<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:e580d64:         new ArrayList<>();
1:e580d64:     Map<Segment, List<CoarseGrainDataMap>> dataMaps = new HashMap<>();
1:e580d64:     Map<String, Segment> segmentMap = new HashMap<>();
1:e580d64:     for (Segment segment : segments) {
1:e580d64:       segmentMap.put(segment.getSegmentNo(), segment);
1:e580d64:       Set<TableBlockIndexUniqueIdentifier> identifiers =
1:8d3c774:           getTableBlockIndexUniqueIdentifiers(segment);
1:e580d64: 
1:e580d64:       for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:e580d64:         tableBlockIndexUniqueIdentifierWrappers.add(
1:e580d64:             new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:8f1a029:                 this.getCarbonTable(), segment.getConfiguration()));
1:e580d64:       }
1:e580d64:     }
1:e580d64:     List<BlockletDataMapIndexWrapper> blockletDataMapIndexWrappers =
1:e580d64:         cache.getAll(tableBlockIndexUniqueIdentifierWrappers);
1:e580d64:     for (BlockletDataMapIndexWrapper wrapper : blockletDataMapIndexWrappers) {
1:e580d64:       Segment segment = segmentMap.get(wrapper.getSegmentId());
1:e580d64:       List<CoarseGrainDataMap> datamapList = dataMaps.get(segment);
1:e580d64:       if (null == datamapList) {
1:e580d64:         datamapList = new ArrayList<CoarseGrainDataMap>();
1:e580d64:       }
1:e580d64:       datamapList.addAll(wrapper.getDataMaps());
1:e580d64:       dataMaps.put(segment, datamapList);
1:e580d64:     }
1:e580d64:     return dataMaps;
1:e580d64:   }
1:e580d64: 
1:c58eb43:   @Override public List<CoarseGrainDataMap> getDataMaps(Segment segment) throws IOException {
1:531ecdf:     List<CoarseGrainDataMap> dataMaps = new ArrayList<>();
1:531ecdf:     Set<TableBlockIndexUniqueIdentifier> identifiers =
1:e580d64:         getTableBlockIndexUniqueIdentifiers(segment);
1:5f68a79:     List<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:531ecdf:         new ArrayList<>(identifiers.size());
1:5f68a79:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:5f68a79:       tableBlockIndexUniqueIdentifierWrappers.add(
1:5f68a79:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:e580d64:               this.getCarbonTable()));
1:6118711:     }
1:531ecdf:     List<BlockletDataMapIndexWrapper> blockletDataMapIndexWrappers =
1:5f68a79:         cache.getAll(tableBlockIndexUniqueIdentifierWrappers);
1:531ecdf:     for (BlockletDataMapIndexWrapper wrapper : blockletDataMapIndexWrappers) {
1:531ecdf:       dataMaps.addAll(wrapper.getDataMaps());
1:5f68a79:     }
1:531ecdf:     return dataMaps;
1:2f79e14:   }
1:6118711: 
1:531ecdf:   private Set<TableBlockIndexUniqueIdentifier> getTableBlockIndexUniqueIdentifiers(Segment segment)
1:e580d64:       throws IOException {
1:531ecdf:     Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:8d3c774:         segmentMap.get(segment.getSegmentNo());
1:b681244:     if (tableBlockIndexUniqueIdentifiers == null) {
1:531ecdf:       tableBlockIndexUniqueIdentifiers =
1:531ecdf:           BlockletDataMapUtil.getTableBlockUniqueIdentifiers(segment);
1:60dfdd3:       if (tableBlockIndexUniqueIdentifiers.size() > 0) {
1:60dfdd3:         segmentMap.put(segment.getSegmentNo(), tableBlockIndexUniqueIdentifiers);
1:60dfdd3:       }
1:8d3c774:     }
1:28f78b2:     return tableBlockIndexUniqueIdentifiers;
1:b681244:   }
1:b681244: 
1:28f78b2:   /**
1:28f78b2:    * Get the blocklet detail information based on blockletid, blockid and segmentid. This method is
1:fc2a7eb:    * exclusively for BlockletDataMapFactory as detail information is only available in this
1:89a12af:    * default datamap.
1:28f78b2:    */
1:f089287:   @Override
1:8d3c774:   public List<ExtendedBlocklet> getExtendedBlocklets(List<Blocklet> blocklets, Segment segment)
1:2f79e14:       throws IOException {
1:28f78b2:     List<ExtendedBlocklet> detailedBlocklets = new ArrayList<>();
1:28f78b2:     // If it is already detailed blocklet then type cast and return same
1:28f78b2:     if (blocklets.size() > 0 && blocklets.get(0) instanceof ExtendedBlocklet) {
1:28f78b2:       for (Blocklet blocklet : blocklets) {
1:28f78b2:         detailedBlocklets.add((ExtendedBlocklet) blocklet);
1:b681244:       }
1:28f78b2:       return detailedBlocklets;
1:b681244:     }
1:531ecdf:     Set<TableBlockIndexUniqueIdentifier> identifiers =
1:8d3c774:         getTableBlockIndexUniqueIdentifiers(segment);
1:5f68a79:     Set<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:5f68a79:         new HashSet<>(identifiers.size());
1:5f68a79:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:5f68a79:       tableBlockIndexUniqueIdentifierWrappers.add(
1:5f68a79:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:5f68a79:               this.getCarbonTable()));
1:5f68a79:     }
1:28f78b2:     // Retrieve each blocklets detail information from blocklet datamap
1:28f78b2:     for (Blocklet blocklet : blocklets) {
1:5f68a79:       detailedBlocklets.add(getExtendedBlocklet(tableBlockIndexUniqueIdentifierWrappers, blocklet));
1:2f79e14:     }
1:28f78b2:     return detailedBlocklets;
1:2f79e14:   }
1:2f79e14: 
1:f089287:   @Override
1:8d3c774:   public ExtendedBlocklet getExtendedBlocklet(Blocklet blocklet, Segment segment)
1:c58eb43:       throws IOException {
1:28f78b2:     if (blocklet instanceof ExtendedBlocklet) {
1:28f78b2:       return (ExtendedBlocklet) blocklet;
1:5f68a79:     }
1:5f68a79:     Set<TableBlockIndexUniqueIdentifier> identifiers =
1:8d3c774:         getTableBlockIndexUniqueIdentifiers(segment);
1:5f68a79: 
1:5f68a79:     Set<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:5f68a79:         new HashSet<>(identifiers.size());
1:5f68a79:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:5f68a79:       tableBlockIndexUniqueIdentifierWrappers.add(
1:5f68a79:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:5f68a79:               this.getCarbonTable()));
1:2f79e14:     }
1:5f68a79:     return getExtendedBlocklet(tableBlockIndexUniqueIdentifierWrappers, blocklet);
1:2f79e14:   }
1:9db662a: 
1:5f68a79:   private ExtendedBlocklet getExtendedBlocklet(
1:5f68a79:       Set<TableBlockIndexUniqueIdentifierWrapper> identifiersWrapper, Blocklet blocklet)
1:5f68a79:       throws IOException {
1:5f68a79:     for (TableBlockIndexUniqueIdentifierWrapper identifierWrapper : identifiersWrapper) {
1:5f68a79:       BlockletDataMapIndexWrapper wrapper = cache.get(identifierWrapper);
1:6118711:       List<BlockDataMap> dataMaps = wrapper.getDataMaps();
1:531ecdf:       for (DataMap dataMap : dataMaps) {
1:f4a58c5:         if (((BlockDataMap) dataMap)
1:f4a58c5:             .getTableTaskInfo(BlockletDataMapRowIndexes.SUMMARY_INDEX_FILE_NAME)
1:f4a58c5:             .startsWith(blocklet.getFilePath())) {
1:6118711:           return ((BlockDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
1:2f79e14:         }
1:280a400:       }
1:9db662a:     }
1:d35fbaf:     throw new IOException("Blocklet with blockid " + blocklet.getBlockletId() + " not found ");
1:531ecdf:   }
1:d35fbaf: 
1:f089287: 
1:f089287:   @Override
1:8d3c774:   public List<DataMapDistributable> toDistributable(Segment segment) {
1:1e21cd1:     List<DataMapDistributable> distributables = new ArrayList<>();
1:8d3c774:     try {
1:531ecdf:       Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:5f68a79:           getTableBlockIndexUniqueIdentifiers(segment);
1:531ecdf:       CarbonFile[] carbonIndexFiles = new CarbonFile[tableBlockIndexUniqueIdentifiers.size()];
1:531ecdf:       int identifierCounter = 0;
1:531ecdf:       for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier :
1:531ecdf:           tableBlockIndexUniqueIdentifiers) {
1:531ecdf:         String indexFilePath = tableBlockIndexUniqueIdentifier.getIndexFilePath();
1:531ecdf:         String fileName = tableBlockIndexUniqueIdentifier.getIndexFileName();
1:531ecdf:         carbonIndexFiles[identifierCounter++] = FileFactory
1:531ecdf:             .getCarbonFile(indexFilePath + CarbonCommonConstants.FILE_SEPARATOR + fileName);
1:8d3c774:       }
1:8d3c774:       for (int i = 0; i < carbonIndexFiles.length; i++) {
1:8d3c774:         Path path = new Path(carbonIndexFiles[i].getPath());
1:1e21cd1:         FileSystem fs = path.getFileSystem(FileFactory.getConfiguration());
1:1e21cd1:         RemoteIterator<LocatedFileStatus> iter = fs.listLocatedStatus(path);
1:1e21cd1:         LocatedFileStatus fileStatus = iter.next();
1:1e21cd1:         String[] location = fileStatus.getBlockLocations()[0].getHosts();
1:1e21cd1:         BlockletDataMapDistributable distributable =
1:8d3c774:             new BlockletDataMapDistributable(path.toString());
1:1e21cd1:         distributable.setLocations(location);
1:1e21cd1:         distributables.add(distributable);
1:531ecdf:       }
1:8d3c774:     } catch (IOException e) {
1:8d3c774:       throw new RuntimeException(e);
1:b681244:     }
1:1e21cd1:     return distributables;
1:b681244:   }
1:8d3c774: 
1:8d3c774:   @Override
1:8d3c774:   public void fireEvent(Event event) {
1:b681244: 
1:b681244:   }
1:b681244: 
1:f089287:   @Override
1:8d3c774:   public void clear(Segment segment) {
1:531ecdf:     Set<TableBlockIndexUniqueIdentifier> blockIndexes = segmentMap.remove(segment.getSegmentNo());
1:b681244:     if (blockIndexes != null) {
1:b681244:       for (TableBlockIndexUniqueIdentifier blockIndex : blockIndexes) {
1:5f68a79:         TableBlockIndexUniqueIdentifierWrapper blockIndexWrapper =
1:5f68a79:             new TableBlockIndexUniqueIdentifierWrapper(blockIndex, this.getCarbonTable());
1:5f68a79:         BlockletDataMapIndexWrapper wrapper = cache.getIfPresent(blockIndexWrapper);
1:531ecdf:         if (null != wrapper) {
1:6118711:           List<BlockDataMap> dataMaps = wrapper.getDataMaps();
1:531ecdf:           for (DataMap dataMap : dataMaps) {
1:fc2a7eb:             if (dataMap != null) {
1:5f68a79:               cache.invalidate(blockIndexWrapper);
1:b681244:               dataMap.clear();
1:b681244:             }
1:b681244:           }
1:b681244:         }
1:b681244:       }
1:b681244:     }
1:531ecdf:   }
1:b681244: 
1:f089287:   @Override
1:77a1110:   public synchronized void clear() {
1:2018048:     if (segmentMap.size() > 0) {
1:2018048:       for (String segmentId : segmentMap.keySet().toArray(new String[segmentMap.size()])) {
1:2018048:         clear(new Segment(segmentId, null, null));
1:2018048:       }
1:531ecdf:     }
1:531ecdf:   }
1:b681244: 
1:f089287:   @Override
1:fc2a7eb:   public List<CoarseGrainDataMap> getDataMaps(DataMapDistributable distributable)
1:c58eb43:       throws IOException {
1:1e21cd1:     BlockletDataMapDistributable mapDistributable = (BlockletDataMapDistributable) distributable;
1:5f68a79:     List<TableBlockIndexUniqueIdentifierWrapper> identifiersWrapper = new ArrayList<>();
1:8d3c774:     Path indexPath = new Path(mapDistributable.getFilePath());
1:8d3c774:     String segmentNo = mapDistributable.getSegment().getSegmentNo();
1:8d3c774:     if (indexPath.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:8d3c774:       String parent = indexPath.getParent().toString();
1:5f68a79:       identifiersWrapper.add(new TableBlockIndexUniqueIdentifierWrapper(
1:5f68a79:           new TableBlockIndexUniqueIdentifier(parent, indexPath.getName(), null, segmentNo),
1:5f68a79:           this.getCarbonTable()));
1:8d3c774:     } else if (indexPath.getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:0586146:       SegmentIndexFileStore fileStore = new SegmentIndexFileStore();
1:8d3c774:       CarbonFile carbonFile = FileFactory.getCarbonFile(indexPath.toString());
1:8d3c774:       String parentPath = carbonFile.getParentFile().getAbsolutePath();
1:8d3c774:       List<String> indexFiles = fileStore.getIndexFilesFromMergeFile(carbonFile.getAbsolutePath());
1:0586146:       for (String indexFile : indexFiles) {
1:5f68a79:         identifiersWrapper.add(new TableBlockIndexUniqueIdentifierWrapper(
1:8d3c774:             new TableBlockIndexUniqueIdentifier(parentPath, indexFile, carbonFile.getName(),
1:5f68a79:                 segmentNo), this.getCarbonTable()));
1:0586146:       }
1:0586146:     }
1:531ecdf:     List<CoarseGrainDataMap> dataMaps = new ArrayList<>();
1:b681244:     try {
1:5f68a79:       List<BlockletDataMapIndexWrapper> wrappers = cache.getAll(identifiersWrapper);
1:531ecdf:       for (BlockletDataMapIndexWrapper wrapper : wrappers) {
1:531ecdf:         dataMaps.addAll(wrapper.getDataMaps());
1:531ecdf:       }
1:b681244:     } catch (IOException e) {
1:b681244:       throw new RuntimeException(e);
3:ca7e2e3:     }
1:0586146:     return dataMaps;
1:ca7e2e3:   }
1:531ecdf: 
1:f089287:   @Override
1:f089287:   public DataMapMeta getMeta() {
1:f089287:     // TODO: pass SORT_COLUMNS into this class
2:b681244:     return null;
1:b681244:   }
1:b681244: 
1:d8562e5:   @Override
1:1fd3703:   public void deleteDatamapData(Segment segment) throws IOException {
1:b681244: 
1:b681244:   }
1:d8562e5: 
1:860e144:   @Override public void deleteDatamapData() {
1:860e144: 
1:b681244:   }
1:860e144: 
1:d35fbaf:   @Override public SegmentProperties getSegmentProperties(Segment segment) throws IOException {
1:fc2a7eb:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
1:d35fbaf:     assert (dataMaps.size() > 0);
1:fc2a7eb:     CoarseGrainDataMap coarseGrainDataMap = dataMaps.get(0);
1:6118711:     assert (coarseGrainDataMap instanceof BlockDataMap);
1:6118711:     BlockDataMap dataMap = (BlockDataMap) coarseGrainDataMap;
1:d35fbaf:     return dataMap.getSegmentProperties();
1:d35fbaf:   }
1:d35fbaf: 
1:d35fbaf:   @Override public List<Blocklet> getAllBlocklets(Segment segment, List<PartitionSpec> partitions)
1:d35fbaf:       throws IOException {
1:d35fbaf:     List<Blocklet> blocklets = new ArrayList<>();
1:fc2a7eb:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
1:fc2a7eb:     for (CoarseGrainDataMap dataMap : dataMaps) {
1:280a400:       blocklets.addAll(
1:3894e1d:           dataMap.prune((FilterResolverIntf) null, getSegmentProperties(segment), partitions));
1:860e144:     }
1:d35fbaf:     return blocklets;
1:f089287:   }
1:5229443: 
1:5229443:   @Override public boolean willBecomeStale(TableOperation operation) {
2:2f79e14:     return false;
1:2f79e14:   }
1:2f79e14: 
1:5f68a79:   @Override
1:5f68a79:   public void cache(TableBlockIndexUniqueIdentifierWrapper tableBlockIndexUniqueIdentifierWrapper,
1:531ecdf:       BlockletDataMapIndexWrapper blockletDataMapIndexWrapper) throws IOException, MemoryException {
1:5f68a79:     cache.put(tableBlockIndexUniqueIdentifierWrapper, blockletDataMapIndexWrapper);
1:7ef9164:   }
1:5229443: 
1:531ecdf:   @Override
1:531ecdf:   public List<DataMapDistributable> getAllUncachedDistributables(
1:531ecdf:       List<DataMapDistributable> distributables) throws IOException {
1:531ecdf:     List<DataMapDistributable> distributablesToBeLoaded = new ArrayList<>(distributables.size());
1:531ecdf:     for (DataMapDistributable distributable : distributables) {
1:531ecdf:       Segment segment = distributable.getSegment();
1:531ecdf:       Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:531ecdf:           getTableBlockIndexUniqueIdentifiers(segment);
1:531ecdf:       // filter out the tableBlockIndexUniqueIdentifiers based on distributable
1:531ecdf:       TableBlockIndexUniqueIdentifier validIdentifier = BlockletDataMapUtil
1:531ecdf:           .filterIdentifiersBasedOnDistributable(tableBlockIndexUniqueIdentifiers,
1:531ecdf:               (BlockletDataMapDistributable) distributable);
1:5f68a79:       if (null == cache.getIfPresent(
1:5f68a79:           new TableBlockIndexUniqueIdentifierWrapper(validIdentifier, this.getCarbonTable()))) {
1:531ecdf:         ((BlockletDataMapDistributable) distributable)
1:531ecdf:             .setTableBlockIndexUniqueIdentifier(validIdentifier);
1:531ecdf:         distributablesToBeLoaded.add(distributable);
1:5229443:       }
1:531ecdf:     }
1:531ecdf:     return distributablesToBeLoaded;
1:531ecdf:   }
1:531ecdf: }
============================================================================
author:kunal642
-------------------------------------------------------------------------------
commit:8f1a029
/////////////////////////////////////////////////////////////////////////
1:                 this.getCarbonTable(), segment.getConfiguration()));
author:ravipesala
-------------------------------------------------------------------------------
commit:3894e1d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.scan.filter.resolver.FilterResolverIntf;
/////////////////////////////////////////////////////////////////////////
1:           dataMap.prune((FilterResolverIntf) null, getSegmentProperties(segment), partitions));
commit:60dfdd3
/////////////////////////////////////////////////////////////////////////
1:       if (tableBlockIndexUniqueIdentifiers.size() > 0) {
1:         segmentMap.put(segment.getSegmentNo(), tableBlockIndexUniqueIdentifiers);
1:       }
commit:77a1110
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, Set<TableBlockIndexUniqueIdentifier>> segmentMap = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:   public synchronized void clear() {
commit:8b33ab2
/////////////////////////////////////////////////////////////////////////
0:       if (identifier.getIndexFileName().startsWith(blocklet.getTaskName())) {
commit:d35fbaf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datamap.dev.AbstractDataMapWriter;
0: import org.apache.carbondata.core.datamap.dev.cgdatamap.AbstractCoarseGrainDataMap;
0: import org.apache.carbondata.core.datamap.dev.cgdatamap.AbstractCoarseGrainDataMapFactory;
1: import org.apache.carbondata.core.indexstore.PartitionSpec;
/////////////////////////////////////////////////////////////////////////
0: public class BlockletDataMapFactory extends AbstractCoarseGrainDataMapFactory
0:     implements BlockletDetailsFetcher, SegmentPropertiesFetcher {
0:   private Cache<TableBlockIndexUniqueIdentifier, AbstractCoarseGrainDataMap> cache;
/////////////////////////////////////////////////////////////////////////
0:   public AbstractDataMapWriter createWriter(Segment segment) {
0:   public List<AbstractCoarseGrainDataMap> getDataMaps(Segment segment) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     String carbonIndexFileName = CarbonTablePath.getCarbonIndexFileName(blocklet.getBlockId());
1:     throw new IOException("Blocklet with blockid " + blocklet.getBlockletId() + " not found ");
1: 
/////////////////////////////////////////////////////////////////////////
0:   public List<AbstractCoarseGrainDataMap> getDataMaps(DataMapDistributable distributable)
1:       throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     List<AbstractCoarseGrainDataMap> dataMaps;
/////////////////////////////////////////////////////////////////////////
1:   @Override public SegmentProperties getSegmentProperties(Segment segment) throws IOException {
0:     List<AbstractCoarseGrainDataMap> dataMaps = getDataMaps(segment);
1:     assert (dataMaps.size() > 0);
0:     AbstractCoarseGrainDataMap coarseGrainDataMap = dataMaps.get(0);
0:     assert (coarseGrainDataMap instanceof BlockletDataMap);
0:     BlockletDataMap dataMap = (BlockletDataMap) coarseGrainDataMap;
1:     return dataMap.getSegmentProperties();
1:   }
1: 
1:   @Override public List<Blocklet> getAllBlocklets(Segment segment, List<PartitionSpec> partitions)
1:       throws IOException {
1:     List<Blocklet> blocklets = new ArrayList<>();
0:     List<AbstractCoarseGrainDataMap> dataMaps = getDataMaps(segment);
0:     for (AbstractCoarseGrainDataMap dataMap : dataMaps) {
0:       blocklets.addAll(dataMap.prune(null, getSegmentProperties(segment), partitions));
1:     return blocklets;
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.Segment;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.SegmentFileStore;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapWriter createWriter(Segment segment) {
0:   public List<DataMap> getDataMaps(Segment segment) throws IOException {
1:         getTableBlockIndexUniqueIdentifiers(segment);
0:       Segment segment) throws IOException {
1:         segmentMap.get(segment.getSegmentNo());
0:       Map<String, String> indexFiles;
0:       if (segment.getSegmentFileName() == null) {
0:         String path =
0:             CarbonTablePath.getSegmentPath(identifier.getTablePath(), segment.getSegmentNo());
0:         indexFiles = new SegmentIndexFileStore().getIndexFilesFromSegment(path);
1:       } else {
0:         SegmentFileStore fileStore =
0:             new SegmentFileStore(identifier.getTablePath(), segment.getSegmentFileName());
0:         indexFiles = fileStore.getIndexFiles();
0:       for (Map.Entry<String, String> indexFileEntry: indexFiles.entrySet()) {
0:         Path indexFile = new Path(indexFileEntry.getKey());
0:         tableBlockIndexUniqueIdentifiers.add(
0:             new TableBlockIndexUniqueIdentifier(indexFile.getParent().toString(),
0:                 indexFile.getName(), indexFileEntry.getValue(), segment.getSegmentNo()));
1:       }
0:       segmentMap.put(segment.getSegmentNo(), tableBlockIndexUniqueIdentifiers);
/////////////////////////////////////////////////////////////////////////
1:   public List<ExtendedBlocklet> getExtendedBlocklets(List<Blocklet> blocklets, Segment segment)
/////////////////////////////////////////////////////////////////////////
1:         getTableBlockIndexUniqueIdentifiers(segment);
/////////////////////////////////////////////////////////////////////////
1:   public ExtendedBlocklet getExtendedBlocklet(Blocklet blocklet, Segment segment)
1:         getTableBlockIndexUniqueIdentifiers(segment);
/////////////////////////////////////////////////////////////////////////
0:       if (identifier.getIndexFilePath().equals(carbonIndexFileName)) {
/////////////////////////////////////////////////////////////////////////
1:   public List<DataMapDistributable> toDistributable(Segment segment) {
1:     try {
0:       CarbonFile[] carbonIndexFiles;
0:       if (segment.getSegmentFileName() == null) {
0:         carbonIndexFiles = SegmentIndexFileStore.getCarbonIndexFiles(
0:             CarbonTablePath.getSegmentPath(identifier.getTablePath(), segment.getSegmentNo()));
0:       } else {
0:         SegmentFileStore fileStore =
0:             new SegmentFileStore(identifier.getTablePath(), segment.getSegmentFileName());
0:         Map<String, String> indexFiles = fileStore.getIndexFiles();
0:         carbonIndexFiles = new CarbonFile[indexFiles.size()];
0:         int i = 0;
0:         for (String indexFile : indexFiles.keySet()) {
0:           carbonIndexFiles[i++] = FileFactory.getCarbonFile(indexFile);
1:         }
1:       }
1:       for (int i = 0; i < carbonIndexFiles.length; i++) {
1:         Path path = new Path(carbonIndexFiles[i].getPath());
1: 
1:             new BlockletDataMapDistributable(path.toString());
1: 
1:     } catch (IOException e) {
1:       throw new RuntimeException(e);
1:   @Override
1:   public void fireEvent(Event event) {
1:   public void clear(Segment segment) {
0:     List<TableBlockIndexUniqueIdentifier> blockIndexes = segmentMap.remove(segment.getSegmentNo());
/////////////////////////////////////////////////////////////////////////
0:       clear(new Segment(segmentId, null));
/////////////////////////////////////////////////////////////////////////
1:     Path indexPath = new Path(mapDistributable.getFilePath());
1:     String segmentNo = mapDistributable.getSegment().getSegmentNo();
1:     if (indexPath.getName().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
1:       String parent = indexPath.getParent().toString();
0:       identifiers
0:           .add(new TableBlockIndexUniqueIdentifier(parent, indexPath.getName(), null, segmentNo));
1:     } else if (indexPath.getName().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:       CarbonFile carbonFile = FileFactory.getCarbonFile(indexPath.toString());
1:       String parentPath = carbonFile.getParentFile().getAbsolutePath();
1:       List<String> indexFiles = fileStore.getIndexFilesFromMergeFile(carbonFile.getAbsolutePath());
1:             new TableBlockIndexUniqueIdentifier(parentPath, indexFile, carbonFile.getName(),
0:                 segmentNo));
commit:0586146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       String segmentId) throws IOException {
0:       String path = CarbonTablePath.getSegmentPath(identifier.getTablePath(), segmentId);
0:       List<String> indexFiles = new SegmentIndexFileStore().getIndexFilesFromSegment(path);
0:       for (int i = 0; i < indexFiles.size(); i++) {
0:             new TableBlockIndexUniqueIdentifier(identifier, segmentId, indexFiles.get(i)));
/////////////////////////////////////////////////////////////////////////
0:     CarbonFile[] carbonIndexFiles = SegmentIndexFileStore.getCarbonIndexFiles(segmentId);
/////////////////////////////////////////////////////////////////////////
0:   public List<DataMap> getDataMaps(DataMapDistributable distributable) throws IOException {
0:     List<TableBlockIndexUniqueIdentifier> identifiers = new ArrayList<>();
0:     if (mapDistributable.getFilePath().endsWith(CarbonTablePath.INDEX_FILE_EXT)) {
0:       identifiers.add(new TableBlockIndexUniqueIdentifier(identifier, distributable.getSegmentId(),
0:           mapDistributable.getFilePath()));
0:     } else if (mapDistributable.getFilePath().endsWith(CarbonTablePath.MERGE_INDEX_FILE_EXT)) {
1:       SegmentIndexFileStore fileStore = new SegmentIndexFileStore();
0:       List<String> indexFiles = fileStore.getIndexFilesFromMergeFile(
0:           CarbonTablePath.getSegmentPath(identifier.getTablePath(), mapDistributable.getSegmentId())
0:               + "/" + mapDistributable.getFilePath());
1:       for (String indexFile : indexFiles) {
0:         identifiers.add(
0:             new TableBlockIndexUniqueIdentifier(identifier, distributable.getSegmentId(),
0:                 indexFile));
1:       }
1:     }
0:     List<DataMap> dataMaps;
0:       dataMaps = cache.getAll(identifiers);
1:     return dataMaps;
commit:b681244
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.carbondata.core.indexstore.blockletindex;
1: 
1: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
1: 
1: import org.apache.carbondata.core.cache.Cache;
1: import org.apache.carbondata.core.cache.CacheProvider;
1: import org.apache.carbondata.core.cache.CacheType;
1: import org.apache.carbondata.core.datastore.filesystem.CarbonFile;
0: import org.apache.carbondata.core.datastore.filesystem.CarbonFileFilter;
1: import org.apache.carbondata.core.datastore.impl.FileFactory;
0: import org.apache.carbondata.core.events.ChangeEvent;
0: import org.apache.carbondata.core.indexstore.DataMap;
0: import org.apache.carbondata.core.indexstore.DataMapDistributable;
0: import org.apache.carbondata.core.indexstore.DataMapFactory;
0: import org.apache.carbondata.core.indexstore.DataMapWriter;
1: import org.apache.carbondata.core.indexstore.TableBlockIndexUniqueIdentifier;
0: import org.apache.carbondata.core.indexstore.schema.FilterType;
1: import org.apache.carbondata.core.metadata.AbsoluteTableIdentifier;
1: 
1: /**
1:  * Table map for blocklet
1:  */
0: public class BlockletDataMapFactory implements DataMapFactory {
1: 
1:   private AbsoluteTableIdentifier identifier;
1: 
0:   private Map<String, List<TableBlockIndexUniqueIdentifier>> segmentMap = new HashMap<>();
1: 
0:   private Cache<TableBlockIndexUniqueIdentifier, DataMap> cache;
1: 
0:   public void init(AbsoluteTableIdentifier identifier, String dataMapName) {
0:     this.identifier = identifier;
1:     cache = CacheProvider.getInstance()
0:         .createCache(CacheType.DRIVER_BLOCKLET_DATAMAP, identifier.getStorePath());
1:   }
1: 
0:   public DataMapWriter getDataMapWriter(AbsoluteTableIdentifier identifier, String segmentId) {
1:     return null;
1:   }
1: 
0:   public List<DataMap> getDataMaps(String segmentId) {
0:     List<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
0:         segmentMap.get(segmentId);
1:     if (tableBlockIndexUniqueIdentifiers == null) {
0:       tableBlockIndexUniqueIdentifiers = new ArrayList<>();
0:       String path = identifier.getTablePath() + "/Fact/Part0/Segment_" + segmentId;
0:       FileFactory.FileType fileType = FileFactory.getFileType(path);
0:       CarbonFile carbonFile = FileFactory.getCarbonFile(path, fileType);
0:       CarbonFile[] listFiles = carbonFile.listFiles(new CarbonFileFilter() {
0:         @Override public boolean accept(CarbonFile file) {
0:           return file.getName().endsWith(".carbonindex");
1:         }
0:       });
0:       for (int i = 0; i < listFiles.length; i++) {
0:         tableBlockIndexUniqueIdentifiers.add(
0:             new TableBlockIndexUniqueIdentifier(identifier, segmentId, listFiles[i].getName()));
1:       }
1:     }
1: 
1:     try {
0:       return cache.getAll(tableBlockIndexUniqueIdentifiers);
1:     } catch (IOException e) {
1:       throw new RuntimeException(e);
1:     }
1:   }
1: 
0:   @Override public boolean isFiltersSupported(FilterType filterType) {
0:     return true;
1:   }
1: 
0:   public void clear(String segmentId) {
0:     List<TableBlockIndexUniqueIdentifier> blockIndexes = segmentMap.remove(segmentId);
1:     if (blockIndexes != null) {
1:       for (TableBlockIndexUniqueIdentifier blockIndex : blockIndexes) {
0:         DataMap dataMap = cache.getIfPresent(blockIndex);
1:         dataMap.clear();
0:         cache.invalidate(blockIndex);
1:       }
1:     }
1:   }
1: 
0:   @Override public void clear() {
0:     for (String segmentId: segmentMap.keySet()) {
0:       clear(segmentId);
1:     }
1:   }
1: 
0:   @Override public DataMap getDataMap(DataMapDistributable distributable) {
1:     return null;
1:   }
1: 
0:   @Override public void fireEvent(ChangeEvent event) {
1: 
1:   }
1: }
author:Manhua
-------------------------------------------------------------------------------
commit:3cbabcd
/////////////////////////////////////////////////////////////////////////
1:     boolean cacheLevelBlock = BlockletDataMapUtil.isCacheLevelBlock(carbonTable);
author:rahul
-------------------------------------------------------------------------------
commit:e580d64
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Get the datamap for all segments
1:    */
1:   public Map<Segment, List<CoarseGrainDataMap>> getDataMaps(List<Segment> segments)
1:       throws IOException {
1:     List<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:         new ArrayList<>();
1:     Map<Segment, List<CoarseGrainDataMap>> dataMaps = new HashMap<>();
1:     Map<String, Segment> segmentMap = new HashMap<>();
1:     for (Segment segment : segments) {
1:       segmentMap.put(segment.getSegmentNo(), segment);
1:       Set<TableBlockIndexUniqueIdentifier> identifiers =
1:           getTableBlockIndexUniqueIdentifiers(segment);
1: 
1:       for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:         tableBlockIndexUniqueIdentifierWrappers.add(
1:             new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:                 this.getCarbonTable()));
1:       }
1:     }
1:     List<BlockletDataMapIndexWrapper> blockletDataMapIndexWrappers =
1:         cache.getAll(tableBlockIndexUniqueIdentifierWrappers);
1:     for (BlockletDataMapIndexWrapper wrapper : blockletDataMapIndexWrappers) {
1:       Segment segment = segmentMap.get(wrapper.getSegmentId());
1:       List<CoarseGrainDataMap> datamapList = dataMaps.get(segment);
1:       if (null == datamapList) {
1:         datamapList = new ArrayList<CoarseGrainDataMap>();
1:       }
1:       datamapList.addAll(wrapper.getDataMaps());
1:       dataMaps.put(segment, datamapList);
1:     }
1:     return dataMaps;
1:   }
1: 
author:xuchuanyin
-------------------------------------------------------------------------------
commit:1cea4d3
/////////////////////////////////////////////////////////////////////////
1:   public static final String CACHE_LEVEL_BLOCKLET = "BLOCKLET";
commit:1fd3703
/////////////////////////////////////////////////////////////////////////
1:   public void deleteDatamapData(Segment segment) throws IOException {
commit:d8562e5
/////////////////////////////////////////////////////////////////////////
1:   @Override
0:   public void deleteDatamapData(Segment segment) {
1: 
1:   }
1: 
commit:cd7c210
/////////////////////////////////////////////////////////////////////////
1:   public DataMapWriter createWriter(Segment segment, String shardName,
1:       SegmentProperties segmentProperties) throws IOException {
1:   public DataMapBuilder createBuilder(Segment segment, String shardName,
1:       SegmentProperties segmentProperties) throws IOException {
commit:8d8b589
/////////////////////////////////////////////////////////////////////////
0:   public AbstractDataMapWriter createWriter(Segment segment, String writeDirectoryPath) {
author:manishgupta88
-------------------------------------------------------------------------------
commit:f4a58c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (((BlockDataMap) dataMap)
1:             .getTableTaskInfo(BlockletDataMapRowIndexes.SUMMARY_INDEX_FILE_NAME)
1:             .startsWith(blocklet.getFilePath())) {
commit:6118711
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * variable for cache level BLOCKLET
1:    */
0:   private static final String CACHE_LEVEL_BLOCKLET = "BLOCKLET";
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * create dataMap based on cache level
1:    *
1:    * @param carbonTable
1:    * @return
1:    */
1:   public static DataMap createDataMap(CarbonTable carbonTable) {
0:     boolean cacheLevelBlock =
0:         BlockletDataMapUtil.isCacheLevelBlock(carbonTable, CACHE_LEVEL_BLOCKLET);
0:     cacheLevelBlock = false;
1:     if (cacheLevelBlock) {
1:       // case1: when CACHE_LEVEL = BLOCK
1:       return new BlockDataMap();
0:     } else {
1:       // case2: when CACHE_LEVEL = BLOCKLET
1:       return new BlockletDataMap();
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:       List<BlockDataMap> dataMaps = wrapper.getDataMaps();
0:         if (((BlockDataMap) dataMap).getIndexFileName().startsWith(blocklet.getFilePath())) {
1:           return ((BlockDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
/////////////////////////////////////////////////////////////////////////
1:           List<BlockDataMap> dataMaps = wrapper.getDataMaps();
/////////////////////////////////////////////////////////////////////////
1:     assert (coarseGrainDataMap instanceof BlockDataMap);
1:     BlockDataMap dataMap = (BlockDataMap) coarseGrainDataMap;
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:5f68a79
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.TableBlockIndexUniqueIdentifierWrapper;
/////////////////////////////////////////////////////////////////////////
1:   private Cache<TableBlockIndexUniqueIdentifierWrapper, BlockletDataMapIndexWrapper> cache;
/////////////////////////////////////////////////////////////////////////
1:     List<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:       tableBlockIndexUniqueIdentifierWrappers.add(
1:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:               this.getCarbonTable()));
1:     }
1:         cache.getAll(tableBlockIndexUniqueIdentifierWrappers);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Set<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:         new HashSet<>(identifiers.size());
1:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:       tableBlockIndexUniqueIdentifierWrappers.add(
1:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:               this.getCarbonTable()));
1:     }
1:       detailedBlocklets.add(getExtendedBlocklet(tableBlockIndexUniqueIdentifierWrappers, blocklet));
/////////////////////////////////////////////////////////////////////////
1:     Set<TableBlockIndexUniqueIdentifier> identifiers =
1:         getTableBlockIndexUniqueIdentifiers(segment);
1: 
1:     Set<TableBlockIndexUniqueIdentifierWrapper> tableBlockIndexUniqueIdentifierWrappers =
1:         new HashSet<>(identifiers.size());
1:     for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier : identifiers) {
1:       tableBlockIndexUniqueIdentifierWrappers.add(
1:           new TableBlockIndexUniqueIdentifierWrapper(tableBlockIndexUniqueIdentifier,
1:               this.getCarbonTable()));
1:     }
1:     return getExtendedBlocklet(tableBlockIndexUniqueIdentifierWrappers, blocklet);
1:   private ExtendedBlocklet getExtendedBlocklet(
1:       Set<TableBlockIndexUniqueIdentifierWrapper> identifiersWrapper, Blocklet blocklet)
1:       throws IOException {
1:     for (TableBlockIndexUniqueIdentifierWrapper identifierWrapper : identifiersWrapper) {
1:       BlockletDataMapIndexWrapper wrapper = cache.get(identifierWrapper);
/////////////////////////////////////////////////////////////////////////
1:         TableBlockIndexUniqueIdentifierWrapper blockIndexWrapper =
1:             new TableBlockIndexUniqueIdentifierWrapper(blockIndex, this.getCarbonTable());
1:         BlockletDataMapIndexWrapper wrapper = cache.getIfPresent(blockIndexWrapper);
1:               cache.invalidate(blockIndexWrapper);
/////////////////////////////////////////////////////////////////////////
1:     List<TableBlockIndexUniqueIdentifierWrapper> identifiersWrapper = new ArrayList<>();
1:       identifiersWrapper.add(new TableBlockIndexUniqueIdentifierWrapper(
1:           new TableBlockIndexUniqueIdentifier(parent, indexPath.getName(), null, segmentNo),
0:           this.getCarbonTable()));
1:         identifiersWrapper.add(new TableBlockIndexUniqueIdentifierWrapper(
1:                 segmentNo), this.getCarbonTable()));
1:       List<BlockletDataMapIndexWrapper> wrappers = cache.getAll(identifiersWrapper);
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:   public void cache(TableBlockIndexUniqueIdentifierWrapper tableBlockIndexUniqueIdentifierWrapper,
1:     cache.put(tableBlockIndexUniqueIdentifierWrapper, blockletDataMapIndexWrapper);
/////////////////////////////////////////////////////////////////////////
1:       if (null == cache.getIfPresent(
1:           new TableBlockIndexUniqueIdentifierWrapper(validIdentifier, this.getCarbonTable()))) {
commit:2f79e14
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.metadata.converter.SchemaConverter;
0: import org.apache.carbondata.core.metadata.converter.ThriftWrapperSchemaConverterImpl;
0: import org.apache.carbondata.core.metadata.schema.table.TableInfo;
0: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
0: import org.apache.carbondata.core.util.CarbonUtil;
1: import org.apache.commons.logging.Log;
1: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
1:   private static final Log LOG = LogFactory.getLog(BlockletDataMapFactory.class);
/////////////////////////////////////////////////////////////////////////
0:       CarbonTable carbonTable = this.getCarbonTable();
0:       if (!carbonTable.getTableInfo().isTransactionalTable()) {
0:         // For NonTransactional table, compare the schema of all index files with inferred schema.
0:         // If there is a mismatch throw exception. As all files must be of same schema.
0:         validateSchemaForNewTranscationalTableFiles(segment, carbonTable);
1:       }
/////////////////////////////////////////////////////////////////////////
0:   private void validateSchemaForNewTranscationalTableFiles(Segment segment, CarbonTable carbonTable)
1:       throws IOException {
0:     SchemaConverter schemaConverter = new ThriftWrapperSchemaConverterImpl();
0:     Map<String, String> indexFiles = segment.getCommittedIndexFile();
0:     for (Map.Entry<String, String> indexFileEntry : indexFiles.entrySet()) {
0:       Path indexFile = new Path(indexFileEntry.getKey());
0:       org.apache.carbondata.format.TableInfo tableInfo = CarbonUtil.inferSchemaFromIndexFile(
0:           indexFile.toString(), carbonTable.getTableName());
0:       TableInfo wrapperTableInfo = schemaConverter.fromExternalToWrapperTableInfo(
0:           tableInfo, identifier.getDatabaseName(),
0:           identifier.getTableName(),
0:           identifier.getTablePath());
0:       List<ColumnSchema> indexFileColumnList =
0:           wrapperTableInfo.getFactTable().getListOfColumns();
0:       List<ColumnSchema> tableColumnList =
0:           carbonTable.getTableInfo().getFactTable().getListOfColumns();
0:       if (!isSameColumnSchemaList(indexFileColumnList, tableColumnList)) {
0:         LOG.error("Schema of " + indexFile.getName()
0:             + " doesn't match with the table's schema");
0:         throw new IOException("All the files doesn't have same schema. "
0:             + "Unsupported operation on nonTransactional table. Check logs.");
1:       }
1:     }
1:   }
1: 
0:   private boolean isSameColumnSchemaList(List<ColumnSchema> indexFileColumnList,
0:       List<ColumnSchema> tableColumnList) {
0:     if (indexFileColumnList.size() != tableColumnList.size()) {
0:       LOG.error("Index file's column size is " + indexFileColumnList.size()
0:           + " but table's column size is " + tableColumnList.size());
1:       return false;
1:     }
0:     for (int i = 0; i < tableColumnList.size(); i++) {
0:       return indexFileColumnList.get(i).equalsWithStrictCheck(tableColumnList.get(i));
1:     }
1:     return false;
1:   }
1: 
commit:280a400
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.readcommitter.ReadCommittedScope;
/////////////////////////////////////////////////////////////////////////
0:   @Override public List<CoarseGrainDataMap> getDataMaps(Segment segment,
0:       ReadCommittedScope readCommittedScope) throws IOException {
0:         getTableBlockIndexUniqueIdentifiers(segment, readCommittedScope);
0:   private List<TableBlockIndexUniqueIdentifier> getTableBlockIndexUniqueIdentifiers(Segment segment,
0:       ReadCommittedScope readCommittedScope) throws IOException {
0:     if (readCommittedScope == null) {
0:       throw new IOException("readCommittedScope is null. Internal error");
1:     }
0:       Map<String, String> indexFiles = readCommittedScope.getCommittedIndexFile(segment);
/////////////////////////////////////////////////////////////////////////
0:   public List<ExtendedBlocklet> getExtendedBlocklets(List<Blocklet> blocklets, Segment segment,
0:       ReadCommittedScope readCommittedScope)
/////////////////////////////////////////////////////////////////////////
0:         getTableBlockIndexUniqueIdentifiers(segment, readCommittedScope);
/////////////////////////////////////////////////////////////////////////
0:   public ExtendedBlocklet getExtendedBlocklet(Blocklet blocklet, Segment segment,
0:       ReadCommittedScope readCommittedScope)
0:         getTableBlockIndexUniqueIdentifiers(segment, readCommittedScope);
/////////////////////////////////////////////////////////////////////////
0:   public List<CoarseGrainDataMap> getDataMaps(DataMapDistributable distributable,
0:       ReadCommittedScope readCommittedScope)
/////////////////////////////////////////////////////////////////////////
0:   @Override public SegmentProperties getSegmentProperties(Segment segment,
0:       ReadCommittedScope readCommittedScope) throws IOException {
0:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment, readCommittedScope);
/////////////////////////////////////////////////////////////////////////
0:   @Override public List<Blocklet> getAllBlocklets(Segment segment, List<PartitionSpec> partitions,
0:       ReadCommittedScope readCommittedScope) throws IOException {
0:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment, readCommittedScope);
1:       blocklets.addAll(
0:           dataMap.prune(null, getSegmentProperties(segment, readCommittedScope), partitions));
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:       if (!indexFileColumnList.get(i).equalsWithStrictCheck(tableColumnList.get(i))) {
0:         return false;
1:       }
0:     return true;
author:akashrn5
-------------------------------------------------------------------------------
commit:2018048
/////////////////////////////////////////////////////////////////////////
1:     if (segmentMap.size() > 0) {
1:       for (String segmentId : segmentMap.keySet().toArray(new String[segmentMap.size()])) {
1:         clear(new Segment(segmentId, null, null));
1:       }
commit:5229443
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.features.TableOperation;
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override public boolean willBecomeStale(TableOperation operation) {
0:     return false;
1:   }
1: 
commit:860e144
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.schema.table.CarbonTable;
/////////////////////////////////////////////////////////////////////////
0:   public void init(CarbonTable carbonTable, DataMapSchema dataMapSchema) {
1:     this.identifier = carbonTable.getAbsoluteTableIdentifier();
/////////////////////////////////////////////////////////////////////////
1:   @Override public void deleteDatamapData() {
1: 
1:   }
1: 
author:Jacky Li
-------------------------------------------------------------------------------
commit:747be9b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.dev.DataMapBuilder;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapBuilder createBuilder(Segment segment, String shardName) {
commit:9db662a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datamap.dev.DataMapRefresher;
/////////////////////////////////////////////////////////////////////////
1:   public BlockletDataMapFactory(CarbonTable carbonTable, DataMapSchema dataMapSchema) {
1:     super(carbonTable, dataMapSchema);
0:   public DataMapWriter createWriter(Segment segment, String shardName) {
1:     throw new UnsupportedOperationException("not implemented");
1:   }
1: 
1:   @Override
0:   public DataMapRefresher createRefresher(Segment segment, String shardName) {
/////////////////////////////////////////////////////////////////////////
0:       if (identifier.getIndexFileName().startsWith(blocklet.getFilePath())) {
commit:fc2a7eb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.dev.DataMap;
1: import org.apache.carbondata.core.datamap.dev.DataMapWriter;
1: import org.apache.carbondata.core.datamap.dev.cgdatamap.CoarseGrainDataMap;
1: import org.apache.carbondata.core.datamap.dev.cgdatamap.CoarseGrainDataMapFactory;
/////////////////////////////////////////////////////////////////////////
1: public class BlockletDataMapFactory extends CoarseGrainDataMapFactory
1:       new DataMapSchema(NAME, BlockletDataMapFactory.class.getName());
0:   private Cache<TableBlockIndexUniqueIdentifier, CoarseGrainDataMap> cache;
/////////////////////////////////////////////////////////////////////////
0:   public DataMapWriter createWriter(Segment segment, String writeDirectoryPath) {
0:   public List<CoarseGrainDataMap> getDataMaps(Segment segment) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:    * exclusively for BlockletDataMapFactory as detail information is only available in this
/////////////////////////////////////////////////////////////////////////
0:         DataMap dataMap = cache.get(identifier);
0:         return ((BlockletDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
/////////////////////////////////////////////////////////////////////////
0:         DataMap dataMap = cache.getIfPresent(blockIndex);
1:         if (dataMap != null) {
0:           dataMap.clear();
/////////////////////////////////////////////////////////////////////////
1:   public List<CoarseGrainDataMap> getDataMaps(DataMapDistributable distributable)
/////////////////////////////////////////////////////////////////////////
0:     List<CoarseGrainDataMap> dataMaps;
/////////////////////////////////////////////////////////////////////////
1:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
1:     CoarseGrainDataMap coarseGrainDataMap = dataMaps.get(0);
0:     assert (coarseGrainDataMap instanceof BlockletDataMap);
0:     BlockletDataMap dataMap = (BlockletDataMap) coarseGrainDataMap;
1:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
1:     for (CoarseGrainDataMap dataMap : dataMaps) {
commit:89a12af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.core.datamap.dev.IndexDataMap;
0: import org.apache.carbondata.core.datamap.dev.cgdatamap.AbstractCoarseGrainIndexDataMap;
0: import org.apache.carbondata.core.datamap.dev.cgdatamap.AbstractCoarseGrainIndexDataMapFactory;
/////////////////////////////////////////////////////////////////////////
0: public class BlockletIndexDataMapFactory extends AbstractCoarseGrainIndexDataMapFactory
0:       new DataMapSchema(NAME, BlockletIndexDataMapFactory.class.getName());
0:   private Cache<TableBlockIndexUniqueIdentifier, AbstractCoarseGrainIndexDataMap> cache;
/////////////////////////////////////////////////////////////////////////
0:   public List<AbstractCoarseGrainIndexDataMap> getDataMaps(Segment segment) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:    * exclusively for BlockletIndexDataMapFactory as detail information is only available in this
1:    * default datamap.
/////////////////////////////////////////////////////////////////////////
0:         IndexDataMap dataMap = cache.get(identifier);
0:         return ((BlockletIndexDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
/////////////////////////////////////////////////////////////////////////
0:         IndexDataMap indexDataMap = cache.getIfPresent(blockIndex);
0:         if (indexDataMap != null) {
0:           indexDataMap.clear();
/////////////////////////////////////////////////////////////////////////
0:   public List<AbstractCoarseGrainIndexDataMap> getDataMaps(DataMapDistributable distributable)
/////////////////////////////////////////////////////////////////////////
0:     List<AbstractCoarseGrainIndexDataMap> dataMaps;
/////////////////////////////////////////////////////////////////////////
0:     List<AbstractCoarseGrainIndexDataMap> dataMaps = getDataMaps(segment);
0:     AbstractCoarseGrainIndexDataMap coarseGrainDataMap = dataMaps.get(0);
0:     assert (coarseGrainDataMap instanceof BlockletIndexDataMap);
0:     BlockletIndexDataMap dataMap = (BlockletIndexDataMap) coarseGrainDataMap;
0:     List<AbstractCoarseGrainIndexDataMap> dataMaps = getDataMaps(segment);
0:     for (AbstractCoarseGrainIndexDataMap dataMap : dataMaps) {
commit:f089287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datamap.DataMapDistributable;
1: import org.apache.carbondata.core.datamap.DataMapMeta;
0: import org.apache.carbondata.core.datamap.dev.DataMap;
0: import org.apache.carbondata.core.datamap.dev.DataMapFactory;
0: import org.apache.carbondata.core.datamap.dev.DataMapWriter;
/////////////////////////////////////////////////////////////////////////
1:   // segmentId -> list of index file
1:   @Override
1:   @Override
0:   public DataMapWriter createWriter(String segmentId) {
1:     throw new UnsupportedOperationException("not implemented");
1:   @Override
0:   public List<DataMap> getDataMaps(String segmentId) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     return cache.getAll(tableBlockIndexUniqueIdentifiers);
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   @Override
0:   public void clear() {
1:   @Override
0:   public DataMap getDataMap(DataMapDistributable distributable) {
1:   @Override
0:   public void fireEvent(ChangeEvent event) {
1: 
1:   @Override
1:   public DataMapMeta getMeta() {
1:     // TODO: pass SORT_COLUMNS into this class
0:     return null;
1:   }
author:dhatchayani
-------------------------------------------------------------------------------
commit:531ecdf
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: import org.apache.carbondata.core.datamap.dev.CacheableDataMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.BlockletDataMapIndexWrapper;
1: import org.apache.carbondata.core.memory.MemoryException;
1: import org.apache.carbondata.core.util.BlockletDataMapUtil;
/////////////////////////////////////////////////////////////////////////
1:     implements BlockletDetailsFetcher, SegmentPropertiesFetcher, CacheableDataMap {
/////////////////////////////////////////////////////////////////////////
0:   private Map<String, Set<TableBlockIndexUniqueIdentifier>> segmentMap = new HashMap<>();
0:   private Cache<TableBlockIndexUniqueIdentifier, BlockletDataMapIndexWrapper> cache;
/////////////////////////////////////////////////////////////////////////
1:     List<CoarseGrainDataMap> dataMaps = new ArrayList<>();
1:     Set<TableBlockIndexUniqueIdentifier> identifiers =
0:     List<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:         new ArrayList<>(identifiers.size());
0:     tableBlockIndexUniqueIdentifiers.addAll(identifiers);
1:     List<BlockletDataMapIndexWrapper> blockletDataMapIndexWrappers =
0:         cache.getAll(tableBlockIndexUniqueIdentifiers);
1:     for (BlockletDataMapIndexWrapper wrapper : blockletDataMapIndexWrappers) {
1:       dataMaps.addAll(wrapper.getDataMaps());
1:     }
1:     return dataMaps;
1:   private Set<TableBlockIndexUniqueIdentifier> getTableBlockIndexUniqueIdentifiers(Segment segment)
1:     Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:       tableBlockIndexUniqueIdentifiers =
1:           BlockletDataMapUtil.getTableBlockUniqueIdentifiers(segment);
/////////////////////////////////////////////////////////////////////////
1:     Set<TableBlockIndexUniqueIdentifier> identifiers =
/////////////////////////////////////////////////////////////////////////
0:     Set<TableBlockIndexUniqueIdentifier> identifiers = getTableBlockIndexUniqueIdentifiers(segment);
0:   private ExtendedBlocklet getExtendedBlocklet(Set<TableBlockIndexUniqueIdentifier> identifiers,
0:       BlockletDataMapIndexWrapper wrapper = cache.get(identifier);
0:       List<BlockletDataMap> dataMaps = wrapper.getDataMaps();
1:       for (DataMap dataMap : dataMaps) {
0:         if (((BlockletDataMap) dataMap).getIndexFileName().startsWith(blocklet.getFilePath())) {
0:           return ((BlockletDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
1:         }
/////////////////////////////////////////////////////////////////////////
1:       Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
1:           getTableBlockIndexUniqueIdentifiers(segment);
1:       CarbonFile[] carbonIndexFiles = new CarbonFile[tableBlockIndexUniqueIdentifiers.size()];
1:       int identifierCounter = 0;
1:       for (TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier :
1:           tableBlockIndexUniqueIdentifiers) {
1:         String indexFilePath = tableBlockIndexUniqueIdentifier.getIndexFilePath();
1:         String fileName = tableBlockIndexUniqueIdentifier.getIndexFileName();
1:         carbonIndexFiles[identifierCounter++] = FileFactory
1:             .getCarbonFile(indexFilePath + CarbonCommonConstants.FILE_SEPARATOR + fileName);
/////////////////////////////////////////////////////////////////////////
1:     Set<TableBlockIndexUniqueIdentifier> blockIndexes = segmentMap.remove(segment.getSegmentNo());
0:         BlockletDataMapIndexWrapper wrapper = cache.getIfPresent(blockIndex);
1:         if (null != wrapper) {
0:           List<BlockletDataMap> dataMaps = wrapper.getDataMaps();
1:           for (DataMap dataMap : dataMaps) {
0:             if (dataMap != null) {
0:               cache.invalidate(blockIndex);
0:               dataMap.clear();
1:             }
1:           }
/////////////////////////////////////////////////////////////////////////
1:     List<CoarseGrainDataMap> dataMaps = new ArrayList<>();
0:       List<BlockletDataMapIndexWrapper> wrappers = cache.getAll(identifiers);
1:       for (BlockletDataMapIndexWrapper wrapper : wrappers) {
1:         dataMaps.addAll(wrapper.getDataMaps());
1:       }
/////////////////////////////////////////////////////////////////////////
0:   @Override public void cache(TableBlockIndexUniqueIdentifier tableBlockIndexUniqueIdentifier,
1:       BlockletDataMapIndexWrapper blockletDataMapIndexWrapper) throws IOException, MemoryException {
0:     cache.put(tableBlockIndexUniqueIdentifier, blockletDataMapIndexWrapper);
1:   }
1: 
1:   @Override
1:   public List<DataMapDistributable> getAllUncachedDistributables(
1:       List<DataMapDistributable> distributables) throws IOException {
1:     List<DataMapDistributable> distributablesToBeLoaded = new ArrayList<>(distributables.size());
1:     for (DataMapDistributable distributable : distributables) {
1:       Segment segment = distributable.getSegment();
1:       Set<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
0:           getTableBlockIndexUniqueIdentifiers(segment);
1:       // filter out the tableBlockIndexUniqueIdentifiers based on distributable
1:       TableBlockIndexUniqueIdentifier validIdentifier = BlockletDataMapUtil
1:           .filterIdentifiersBasedOnDistributable(tableBlockIndexUniqueIdentifiers,
1:               (BlockletDataMapDistributable) distributable);
0:       if (null == cache.getIfPresent(validIdentifier)) {
1:         ((BlockletDataMapDistributable) distributable)
1:             .setTableBlockIndexUniqueIdentifier(validIdentifier);
1:         distributablesToBeLoaded.add(distributable);
1:       }
1:     }
1:     return distributablesToBeLoaded;
1:   }
author:sounakr
-------------------------------------------------------------------------------
commit:c58eb43
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   @Override public List<CoarseGrainDataMap> getDataMaps(Segment segment) throws IOException {
0:         getTableBlockIndexUniqueIdentifiers(segment);
0:   private List<TableBlockIndexUniqueIdentifier> getTableBlockIndexUniqueIdentifiers(Segment segment)
1:       throws IOException {
0:       Map<String, String> indexFiles = segment.getCommittedIndexFile();
0:       for (Map.Entry<String, String> indexFileEntry : indexFiles.entrySet()) {
/////////////////////////////////////////////////////////////////////////
0:   public List<ExtendedBlocklet> getExtendedBlocklets(List<Blocklet> blocklets, Segment segment)
/////////////////////////////////////////////////////////////////////////
0:         getTableBlockIndexUniqueIdentifiers(segment);
/////////////////////////////////////////////////////////////////////////
0:   public ExtendedBlocklet getExtendedBlocklet(Blocklet blocklet, Segment segment)
0:         getTableBlockIndexUniqueIdentifiers(segment);
/////////////////////////////////////////////////////////////////////////
0:       clear(new Segment(segmentId, null, null));
0:   public List<CoarseGrainDataMap> getDataMaps(DataMapDistributable distributable)
/////////////////////////////////////////////////////////////////////////
0:   @Override public SegmentProperties getSegmentProperties(Segment segment) throws IOException {
0:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
/////////////////////////////////////////////////////////////////////////
0:   @Override public List<Blocklet> getAllBlocklets(Segment segment, List<PartitionSpec> partitions)
1:       throws IOException {
0:     List<CoarseGrainDataMap> dataMaps = getDataMaps(segment);
0:           dataMap.prune(null, getSegmentProperties(segment), partitions));
commit:ca7e2e3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1: import org.apache.carbondata.core.indexstore.SegmentPropertiesFetcher;
0: import org.apache.carbondata.core.metadata.blocklet.DataFileFooter;
0: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
0: import org.apache.carbondata.core.util.DataFileFooterConverter;
/////////////////////////////////////////////////////////////////////////
0: public class BlockletDataMapFactory implements DataMapFactory, BlockletDetailsFetcher,
0:     SegmentPropertiesFetcher {
0:   // segmentId -> SegmentProperties.
0:   private Map<String, SegmentProperties> segmentPropertiesMap = new HashMap<>();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:   @Override public SegmentProperties getSegmentProperties(String segmentId) throws IOException {
0:     SegmentProperties segmentProperties = segmentPropertiesMap.get(segmentId);
0:     if (segmentProperties == null) {
0:       int[] columnCardinality;
0:       List<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
0:           getTableBlockIndexUniqueIdentifiers(segmentId);
0:       DataFileFooterConverter fileFooterConverter = new DataFileFooterConverter();
0:       List<DataFileFooter> indexInfo =
0:           fileFooterConverter.getIndexInfo(tableBlockIndexUniqueIdentifiers.get(0).getFilePath());
0:       for (DataFileFooter fileFooter : indexInfo) {
0:         List<ColumnSchema> columnInTable = fileFooter.getColumnInTable();
0:         if (segmentProperties == null) {
0:           columnCardinality = fileFooter.getSegmentInfo().getColumnCardinality();
0:           segmentProperties = new SegmentProperties(columnInTable, columnCardinality);
1:         }
1:       }
0:       segmentPropertiesMap.put(segmentId, segmentProperties);
1:     }
0:     return segmentProperties;
1:   }
author:QiangCai
-------------------------------------------------------------------------------
commit:d23f7fa
/////////////////////////////////////////////////////////////////////////
0:       if (identifier.getIndexFileName().equals(carbonIndexFileName)) {
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:56330ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.schema.table.DataMapSchema;
/////////////////////////////////////////////////////////////////////////
1:   private static final String NAME = "clustered.btree.blocklet";
1: 
1:   public static final DataMapSchema DATA_MAP_SCHEMA =
0:       new DataMapSchema(NAME, BlockletDataMapFactory.class.getName());
1: 
/////////////////////////////////////////////////////////////////////////
0:   public void init(AbsoluteTableIdentifier identifier, DataMapSchema dataMapSchema) {
/////////////////////////////////////////////////////////////////////////
commit:28f78b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.indexstore.Blocklet;
1: import org.apache.carbondata.core.indexstore.BlockletDetailsFetcher;
1: import org.apache.carbondata.core.indexstore.ExtendedBlocklet;
1: import org.apache.carbondata.core.util.path.CarbonTablePath;
/////////////////////////////////////////////////////////////////////////
0: public class BlockletDataMapFactory implements DataMapFactory, BlockletDetailsFetcher {
/////////////////////////////////////////////////////////////////////////
0:         getTableBlockIndexUniqueIdentifiers(segmentId);
0:     return cache.getAll(tableBlockIndexUniqueIdentifiers);
0:   }
0: 
0:   private List<TableBlockIndexUniqueIdentifier> getTableBlockIndexUniqueIdentifiers(
0:       String segmentId) {
0:     List<TableBlockIndexUniqueIdentifier> tableBlockIndexUniqueIdentifiers =
/////////////////////////////////////////////////////////////////////////
1:     return tableBlockIndexUniqueIdentifiers;
0:   }
1:   /**
1:    * Get the blocklet detail information based on blockletid, blockid and segmentid. This method is
0:    * exclusively for BlockletDataMapFactory as detail information is only available in this default
0:    * datamap.
1:    */
0:   @Override
0:   public List<ExtendedBlocklet> getExtendedBlocklets(List<Blocklet> blocklets, String segmentId)
0:       throws IOException {
1:     List<ExtendedBlocklet> detailedBlocklets = new ArrayList<>();
1:     // If it is already detailed blocklet then type cast and return same
1:     if (blocklets.size() > 0 && blocklets.get(0) instanceof ExtendedBlocklet) {
1:       for (Blocklet blocklet : blocklets) {
1:         detailedBlocklets.add((ExtendedBlocklet) blocklet);
0:       }
1:       return detailedBlocklets;
0:     }
0:     List<TableBlockIndexUniqueIdentifier> identifiers =
0:         getTableBlockIndexUniqueIdentifiers(segmentId);
1:     // Retrieve each blocklets detail information from blocklet datamap
1:     for (Blocklet blocklet : blocklets) {
0:       detailedBlocklets.add(getExtendedBlocklet(identifiers, blocklet));
0:     }
1:     return detailedBlocklets;
0:   }
0: 
0:   @Override
0:   public ExtendedBlocklet getExtendedBlocklet(Blocklet blocklet, String segmentId)
0:       throws IOException {
1:     if (blocklet instanceof ExtendedBlocklet) {
1:       return (ExtendedBlocklet) blocklet;
0:     }
0:     List<TableBlockIndexUniqueIdentifier> identifiers =
0:         getTableBlockIndexUniqueIdentifiers(segmentId);
0:     return getExtendedBlocklet(identifiers, blocklet);
0:   }
0: 
0:   private ExtendedBlocklet getExtendedBlocklet(List<TableBlockIndexUniqueIdentifier> identifiers,
0:       Blocklet blocklet) throws IOException {
0:     String carbonIndexFileName = CarbonTablePath.getCarbonIndexFileName(blocklet.getPath());
0:     for (TableBlockIndexUniqueIdentifier identifier : identifiers) {
0:       if (identifier.getCarbonIndexFileName().equals(carbonIndexFileName)) {
0:         DataMap dataMap = cache.get(identifier);
0:         return ((BlockletDataMap) dataMap).getDetailedBlocklet(blocklet.getBlockletId());
0:       }
0:     }
0:     throw new IOException("Blocklet with blockid " + blocklet.getPath() + " not found ");
/////////////////////////////////////////////////////////////////////////
0:     for (String segmentId : segmentMap.keySet().toArray(new String[segmentMap.size()])) {
commit:eb771f5
/////////////////////////////////////////////////////////////////////////
0:       segmentMap.put(segmentId, tableBlockIndexUniqueIdentifiers);
/////////////////////////////////////////////////////////////////////////
0:         if (dataMap != null) {
0:           cache.invalidate(blockIndex);
0:           dataMap.clear();
0:         }
0:     for (String segmentId: segmentMap.keySet().toArray(new String[segmentMap.size()])) {
commit:1e21cd1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.LocatedFileStatus;
1: import org.apache.hadoop.fs.Path;
1: import org.apache.hadoop.fs.RemoteIterator;
0: 
/////////////////////////////////////////////////////////////////////////
0:       CarbonFile[] listFiles = getCarbonIndexFiles(segmentId);
/////////////////////////////////////////////////////////////////////////
0:   private CarbonFile[] getCarbonIndexFiles(String segmentId) {
0:     String path = identifier.getTablePath() + "/Fact/Part0/Segment_" + segmentId;
0:     CarbonFile carbonFile = FileFactory.getCarbonFile(path);
0:     return carbonFile.listFiles(new CarbonFileFilter() {
0:       @Override public boolean accept(CarbonFile file) {
0:         return file.getName().endsWith(".carbonindex");
0:       }
0:     });
0:   }
0: 
0:   @Override
0:   public List<DataMapDistributable> toDistributable(String segmentId) {
0:     CarbonFile[] carbonIndexFiles = getCarbonIndexFiles(segmentId);
1:     List<DataMapDistributable> distributables = new ArrayList<>();
0:     for (int i = 0; i < carbonIndexFiles.length; i++) {
0:       Path path = new Path(carbonIndexFiles[i].getPath());
0:       try {
1:         FileSystem fs = path.getFileSystem(FileFactory.getConfiguration());
1:         RemoteIterator<LocatedFileStatus> iter = fs.listLocatedStatus(path);
1:         LocatedFileStatus fileStatus = iter.next();
1:         String[] location = fileStatus.getBlockLocations()[0].getHosts();
1:         BlockletDataMapDistributable distributable =
0:             new BlockletDataMapDistributable(path.getName());
1:         distributable.setLocations(location);
1:         distributables.add(distributable);
0:       } catch (IOException e) {
0:         throw new RuntimeException(e);
0:       }
0:     }
1:     return distributables;
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
1:     BlockletDataMapDistributable mapDistributable = (BlockletDataMapDistributable) distributable;
0:     TableBlockIndexUniqueIdentifier uniqueIdentifier =
0:         new TableBlockIndexUniqueIdentifier(identifier, distributable.getSegmentId(),
0:             mapDistributable.getFilePath());
0:     DataMap dataMap;
0:     try {
0:       dataMap = cache.get(uniqueIdentifier);
0:     } catch (IOException e) {
0:       throw new RuntimeException(e);
0:     }
0:     return dataMap;
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:1155d4d
/////////////////////////////////////////////////////////////////////////
1:         .createCache(CacheType.DRIVER_BLOCKLET_DATAMAP);
author:rahulforallp
-------------------------------------------------------------------------------
commit:4aa0f49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.events.Event;
/////////////////////////////////////////////////////////////////////////
0:   @Override public void fireEvent(Event event) {
0: 
0:   }
0: 
/////////////////////////////////////////////////////////////////////////
============================================================================