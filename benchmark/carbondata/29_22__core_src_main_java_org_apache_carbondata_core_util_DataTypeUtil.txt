1:cd6a4ff: /*
1:41347d8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:41347d8:  * contributor license agreements.  See the NOTICE file distributed with
1:41347d8:  * this work for additional information regarding copyright ownership.
1:41347d8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:41347d8:  * (the "License"); you may not use this file except in compliance with
1:41347d8:  * the License.  You may obtain a copy of the License at
1:cd6a4ff:  *
1:cd6a4ff:  *    http://www.apache.org/licenses/LICENSE-2.0
1:cd6a4ff:  *
1:41347d8:  * Unless required by applicable law or agreed to in writing, software
1:41347d8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:41347d8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:41347d8:  * See the License for the specific language governing permissions and
1:41347d8:  * limitations under the License.
1:cd6a4ff:  */
1:cd6a4ff: 
1:cd6a4ff: package org.apache.carbondata.core.util;
1:cd6a4ff: 
1:cd6a4ff: import java.math.BigDecimal;
1:cd6a4ff: import java.math.BigInteger;
1:cd6a4ff: import java.math.RoundingMode;
1:266c473: import java.nio.ByteBuffer;
1:70256e7: import java.nio.charset.Charset;
1:dc57aec: import java.text.DateFormat;
1:cd6a4ff: import java.text.ParseException;
1:cd6a4ff: import java.text.SimpleDateFormat;
1:72cb415: import java.util.Arrays;
1:cd6a4ff: import java.util.Date;
1:cd6a4ff: 
1:cd6a4ff: import org.apache.carbondata.common.logging.LogService;
1:cd6a4ff: import org.apache.carbondata.common.logging.LogServiceFactory;
1:cd6a4ff: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1:266c473: import org.apache.carbondata.core.datastore.page.ColumnPage;
1:6abdd97: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
1:70256e7: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryGenerator;
1:70256e7: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1:ce09aaa: import org.apache.carbondata.core.metadata.datatype.DataType;
1:956833e: import org.apache.carbondata.core.metadata.datatype.DataTypes;
1:36ceb59: import org.apache.carbondata.core.metadata.encoder.Encoding;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1:ce09aaa: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
1:70256e7: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
1:cd6a4ff: 
1:cd6a4ff: public final class DataTypeUtil {
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * LOGGER
1:cd6a4ff:    */
1:cd6a4ff:   private static final LogService LOGGER =
1:cd6a4ff:       LogServiceFactory.getLogService(DataTypeUtil.class.getName());
1:cd6a4ff: 
1:ea04fce:   private static final ThreadLocal<DateFormat> timeStampformatter = new ThreadLocal<DateFormat>() {
1:70256e7:     @Override protected DateFormat initialValue() {
1:36ceb59:       DateFormat dateFormat = new SimpleDateFormat(CarbonProperties.getInstance()
2:cd6a4ff:           .getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
2:cd6a4ff:               CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT));
1:36ceb59:       dateFormat.setLenient(false);
1:36ceb59:       return dateFormat;
1:cd6a4ff:     }
1:dc57aec:   };
1:cd6a4ff: 
1:ea04fce:   private static final ThreadLocal<DateFormat> dateformatter = new ThreadLocal<DateFormat>() {
1:70256e7:     @Override protected DateFormat initialValue() {
2:70256e7:       return new SimpleDateFormat(CarbonProperties.getInstance()
1:70256e7:           .getProperty(CarbonCommonConstants.CARBON_DATE_FORMAT,
1:ea04fce:               CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT));
1:cd6a4ff:     }
1:ea04fce:   };
1:70256e7: 
1:afcaecf:   /**
1:09f7cdd:    * DataType converter for different computing engines
1:cd6a4ff:    */
1:09f7cdd:   private static DataTypeConverter converter;
2:70256e7: 
1:dded5d5:   /**
1:dded5d5:    * This method will convert a given value to its specific type
1:dded5d5:    *
1:dded5d5:    * @param msrValue
1:dded5d5:    * @param dataType
1:dded5d5:    * @param carbonMeasure
1:dded5d5:    * @return
1:afcaecf:    */
1:8d3c774:   public static Object getMeasureValueBasedOnDataType(String msrValue, DataType dataType,
1:dded5d5:       CarbonMeasure carbonMeasure) {
1:8d3c774:     return getMeasureValueBasedOnDataType(msrValue, dataType,carbonMeasure, false);
1:cd6a4ff:   }
1:cd6a4ff: 
1:72cb415:   /**
1:cd6a4ff:    * This method will convert a given value to its specific type
1:cd6a4ff:    *
1:cd6a4ff:    * @param msrValue
2:cd6a4ff:    * @param dataType
1:cd6a4ff:    * @param carbonMeasure
1:cd6a4ff:    * @return
1:dded5d5:    */
1:cd6a4ff:   public static Object getMeasureValueBasedOnDataType(String msrValue, DataType dataType,
1:8d3c774:       CarbonMeasure carbonMeasure, boolean useConverter) {
1:dded5d5:     if (dataType == DataTypes.BOOLEAN) {
1:dded5d5:       return BooleanConvert.parseBoolean(msrValue);
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       BigDecimal bigDecimal =
1:956833e:           new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
1:8d3c774:       BigDecimal decimal = normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision());
1:8d3c774:       if (useConverter) {
1:982d03f:         return converter.convertFromBigDecimalToDecimal(decimal);
1:8d3c774:       } else {
1:8d3c774:         return decimal;
1:8d3c774:       }
1:956833e:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return Short.parseShort(msrValue);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return Integer.parseInt(msrValue);
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       return Long.valueOf(msrValue);
1:956833e:     } else {
1:956833e:       Double parsedValue = Double.valueOf(msrValue);
1:956833e:       if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
1:956833e:         return null;
1:956833e:       }
1:956833e:       return parsedValue;
1:dded5d5:     }
1:dded5d5:   }
1:dded5d5: 
1:266c473:   public static Object getMeasureObjectFromDataType(byte[] data, DataType dataType) {
1:4e83509:     if (data == null || data.length == 0) {
1:dded5d5:       return null;
1:dded5d5:     }
1:266c473:     ByteBuffer bb = ByteBuffer.wrap(data);
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       return BooleanConvert.byte2Boolean(bb.get());
1:dded5d5:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return (short) bb.getLong();
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return (int) bb.getLong();
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       return bb.getLong();
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       return byteToBigDecimal(data);
1:956833e:     } else {
1:956833e:       return bb.getDouble();
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:266c473:   public static Object getMeasureObjectBasedOnDataType(ColumnPage measurePage, int index,
2:266c473:       DataType dataType, CarbonMeasure carbonMeasure) {
1:6abdd97:     if (dataType == DataTypes.BOOLEAN) {
1:6abdd97:       return measurePage.getBoolean(index);
1:6abdd97:     } else if (dataType == DataTypes.SHORT) {
1:956833e:       return (short) measurePage.getLong(index);
1:956833e:     } else if (dataType == DataTypes.INT) {
1:956833e:       return (int) measurePage.getLong(index);
1:956833e:     } else if (dataType == DataTypes.LONG) {
1:956833e:       return measurePage.getLong(index);
1:f209e8e:     } else if (DataTypes.isDecimal(dataType)) {
1:956833e:       BigDecimal bigDecimalMsrValue = measurePage.getDecimal(index);
1:956833e:       if (null != bigDecimalMsrValue && carbonMeasure.getScale() > bigDecimalMsrValue.scale()) {
1:956833e:         bigDecimalMsrValue =
1:956833e:             bigDecimalMsrValue.setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
1:956833e:       }
1:956833e:       if (null != bigDecimalMsrValue) {
1:956833e:         return normalizeDecimalValue(bigDecimalMsrValue, carbonMeasure.getPrecision());
1:956833e:       } else {
1:f209e8e:         return null;
1:956833e:       }
1:956833e:     } else {
1:956833e:       return measurePage.getDouble(index);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will check the digits before dot with the max precision allowed
1:cd6a4ff:    *
1:cd6a4ff:    * @param bigDecimal
1:cd6a4ff:    * @param allowedPrecision precision configured by the user
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   private static BigDecimal normalizeDecimalValue(BigDecimal bigDecimal, int allowedPrecision) {
1:cd6a4ff:     if (bigDecimal.precision() > allowedPrecision) {
8:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:     return bigDecimal;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will convert a big decimal value to bytes
1:cd6a4ff:    *
1:cd6a4ff:    * @param num
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public static byte[] bigDecimalToByte(BigDecimal num) {
1:cd6a4ff:     BigInteger sig = new BigInteger(num.unscaledValue().toString());
1:cd6a4ff:     int scale = num.scale();
1:eaadc88:     byte[] bscale = { (byte) (scale) };
1:cd6a4ff:     byte[] buff = sig.toByteArray();
1:cd6a4ff:     byte[] completeArr = new byte[buff.length + bscale.length];
1:cd6a4ff:     System.arraycopy(bscale, 0, completeArr, 0, bscale.length);
1:cd6a4ff:     System.arraycopy(buff, 0, completeArr, bscale.length, buff.length);
1:cd6a4ff:     return completeArr;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will convert a byte value back to big decimal value
1:cd6a4ff:    *
1:cd6a4ff:    * @param raw
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public static BigDecimal byteToBigDecimal(byte[] raw) {
1:cd6a4ff:     int scale = (raw[0] & 0xFF);
1:cd6a4ff:     byte[] unscale = new byte[raw.length - 1];
1:cd6a4ff:     System.arraycopy(raw, 1, unscale, 0, unscale.length);
1:cd6a4ff:     BigInteger sig = new BigInteger(unscale);
1:cd6a4ff:     return new BigDecimal(sig, scale);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:9e24a3d:    * This method will convert a byte value back to big decimal value
1:cd6a4ff:    *
1:9e24a3d:    * @param raw
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:9e24a3d:   public static BigDecimal byteToBigDecimal(byte[] raw, int offset, int length) {
1:9e24a3d:     int scale = (raw[offset] & 0xFF);
1:9e24a3d:     byte[] unscale = new byte[length - 1];
1:256dbed:     System.arraycopy(raw, offset + 1, unscale, 0, unscale.length);
1:9e24a3d:     BigInteger sig = new BigInteger(unscale);
1:9e24a3d:     return new BigDecimal(sig, scale);
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:72cb415:    * Below method will be used to convert the data passed to its actual data
1:72cb415:    * type
1:72cb415:    *
1:cd6a4ff:    * @param data           data
1:9f94529:    * @param actualDataType actual data type
1:72cb415:    * @return actual data after conversion
1:72cb415:    */
1:cd6a4ff:   public static Object getDataBasedOnDataType(String data, DataType actualDataType) {
1:4e83509:     return getDataBasedOnDataType(data, actualDataType, getDataTypeConverter());
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * Below method will be used to convert the data passed to its actual data
1:cd6a4ff:    * type
1:cd6a4ff:    *
1:4e83509:    * @param data           data
1:72cb415:    * @param actualDataType actual data type
1:cd6a4ff:    * @return actual data after conversion
1:cd6a4ff:    */
1:4e83509:   public static Object getDataBasedOnDataType(String data, DataType actualDataType,
1:4e83509:       DataTypeConverter converter) {
1:cd6a4ff:     if (null == data || CarbonCommonConstants.MEMBER_DEFAULT_VAL.equals(data)) {
1:cd6a4ff:       return null;
1:cd6a4ff:     }
5:cd6a4ff:     try {
1:6abdd97:       if (actualDataType == DataTypes.BOOLEAN) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:6abdd97:         return BooleanConvert.parseBoolean(data);
1:6abdd97:       } else if (actualDataType == DataTypes.INT) {
7:cd6a4ff:         if (data.isEmpty()) {
1:cd6a4ff:           return null;
1:cd6a4ff:         }
1:956833e:         return Integer.parseInt(data);
1:956833e:       } else if (actualDataType == DataTypes.SHORT) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Short.parseShort(data);
1:956833e:       } else if (actualDataType == DataTypes.FLOAT) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Float.parseFloat(data);
1:d85fb72:       } else if (actualDataType == DataTypes.DOUBLE) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Double.parseDouble(data);
1:956833e:       } else if (actualDataType == DataTypes.LONG) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Long.parseLong(data);
1:956833e:       } else if (actualDataType == DataTypes.DATE) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         try {
1:956833e:           Date dateToStr = dateformatter.get().parse(data);
1:956833e:           return dateToStr.getTime() * 1000;
1:956833e:         } catch (ParseException e) {
1:956833e:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:956833e:           return null;
1:956833e:         }
1:956833e:       } else if (actualDataType == DataTypes.TIMESTAMP) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         try {
1:956833e:           Date dateToStr = timeStampformatter.get().parse(data);
1:956833e:           return dateToStr.getTime() * 1000;
1:956833e:         } catch (ParseException e) {
1:956833e:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:956833e:           return null;
1:956833e:         }
1:d85fb72:       } else if (DataTypes.isDecimal(actualDataType)) {
1:956833e:         if (data.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:982d03f:         return converter.convertFromStringToDecimal(data);
1:956833e:       } else {
1:956833e:         return converter.convertFromStringToUTF8String(data);
1:cd6a4ff:       }
2:cd6a4ff:     } catch (NumberFormatException ex) {
1:cd6a4ff:       LOGGER.error("Problem while converting data type" + data);
1:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:9f94529:   public static byte[] getBytesBasedOnDataTypeForNoDictionaryColumn(String dimensionValue,
1:36ceb59:       DataType actualDataType, String dateFormat) {
1:6abdd97:     if (actualDataType == DataTypes.BOOLEAN) {
1:6abdd97:       return ByteUtil.toBytes(BooleanConvert.parseBoolean(dimensionValue));
1:956833e:     } else if (actualDataType == DataTypes.SHORT) {
1:f012f5b:       return ByteUtil.toXorBytes(Short.parseShort(dimensionValue));
1:956833e:     } else if (actualDataType == DataTypes.INT) {
1:f012f5b:       return ByteUtil.toXorBytes(Integer.parseInt(dimensionValue));
1:956833e:     } else if (actualDataType == DataTypes.LONG) {
1:f012f5b:       return ByteUtil.toXorBytes(Long.parseLong(dimensionValue));
1:d85fb72:     } else if (actualDataType == DataTypes.DOUBLE) {
1:f012f5b:       return ByteUtil.toXorBytes(Double.parseDouble(dimensionValue));
1:f209e8e:     } else if (DataTypes.isDecimal(actualDataType)) {
1:d85fb72:       return bigDecimalToByte(new BigDecimal(dimensionValue));
1:956833e:     } else if (actualDataType == DataTypes.TIMESTAMP) {
1:956833e:       Date dateToStr = null;
1:956833e:       DateFormat dateFormatter = null;
1:956833e:       try {
1:85dc4ff:         if (null != dateFormat && !dateFormat.trim().isEmpty()) {
1:956833e:           dateFormatter = new SimpleDateFormat(dateFormat);
1:cf666c1:           dateFormatter.setLenient(false);
1:956833e:         } else {
1:956833e:           dateFormatter = timeStampformatter.get();
1:cd6a4ff:         }
1:956833e:         dateToStr = dateFormatter.parse(dimensionValue);
1:f012f5b:         return ByteUtil.toXorBytes(dateToStr.getTime());
1:956833e:       } catch (ParseException e) {
1:956833e:         throw new NumberFormatException(e.getMessage());
1:cd6a4ff:       }
1:dded5d5:     } else {
1:3e88858:       // Default action for String/Varchar
2:9f94529:       return ByteUtil.toBytes(dimensionValue);
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:dded5d5:   public static Object getDataDataTypeForNoDictionaryColumn(String dimensionValue,
1:dded5d5:       DataType actualDataType, String dateFormat) {
1:dded5d5:     if (actualDataType == DataTypes.BOOLEAN) {
1:dded5d5:       return BooleanConvert.parseBoolean(dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.SHORT) {
1:dded5d5:       return Short.parseShort(dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.INT) {
1:dded5d5:       return Integer.parseInt(dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.LONG) {
1:dded5d5:       return Long.parseLong(dimensionValue);
1:d85fb72:     } else if (actualDataType == DataTypes.DOUBLE) {
1:d85fb72:       return Double.parseDouble(dimensionValue);
1:d85fb72:     } else if (DataTypes.isDecimal(actualDataType)) {
1:d85fb72:       return new BigDecimal(dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.TIMESTAMP) {
1:dded5d5:       Date dateToStr = null;
1:dded5d5:       DateFormat dateFormatter = null;
1:dded5d5:       try {
1:dded5d5:         if (null != dateFormat && !dateFormat.trim().isEmpty()) {
1:dded5d5:           dateFormatter = new SimpleDateFormat(dateFormat);
1:cf666c1:           dateFormatter.setLenient(false);
1:dded5d5:         } else {
1:dded5d5:           dateFormatter = timeStampformatter.get();
1:dded5d5:         }
1:dded5d5:         dateToStr = dateFormatter.parse(dimensionValue);
1:dded5d5:         return dateToStr.getTime();
1:dded5d5:       } catch (ParseException e) {
1:dded5d5:         throw new NumberFormatException(e.getMessage());
1:dded5d5:       }
1:dded5d5:     } else {
1:3e88858:       // Default action for String/Varchar
2:dded5d5:       return converter.convertFromStringToUTF8String(dimensionValue);
1:dded5d5:     }
1:dded5d5:   }
1:9f94529: 
1:dded5d5:   public static byte[] getBytesDataDataTypeForNoDictionaryColumn(Object dimensionValue,
1:f5c6f28:       DataType actualDataType) {
1:dded5d5:     if (dimensionValue == null) {
1:956833e:       if (actualDataType == DataTypes.STRING) {
1:dded5d5:         return CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY;
1:956833e:       } else {
1:dded5d5:         return new byte[0];
1:956833e:       }
1:dded5d5:     }
1:dded5d5:     if (actualDataType == DataTypes.BOOLEAN) {
1:dded5d5:       return ByteUtil.toBytes((Boolean) dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.SHORT) {
1:f012f5b:       return ByteUtil.toXorBytes((Short) dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.INT) {
1:f012f5b:       return ByteUtil.toXorBytes((Integer) dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.LONG) {
1:f012f5b:       return ByteUtil.toXorBytes((Long) dimensionValue);
1:dded5d5:     } else if (actualDataType == DataTypes.TIMESTAMP) {
1:f012f5b:       return ByteUtil.toXorBytes((Long)dimensionValue);
1:dded5d5:     } else {
1:3e88858:       // Default action for String/Varchar
2:dded5d5:       return ByteUtil.toBytes(dimensionValue.toString());
1:dded5d5:     }
1:dded5d5:   }
1:dded5d5: 
1:9f94529:   /**
1:afcaecf:    * Returns true for fixed length DataTypes.
1:afcaecf:    * @param dataType
1:afcaecf:    * @return
1:9f94529:    */
1:afcaecf:   public static boolean isFixedSizeDataType(DataType dataType) {
1:3e88858:     if (dataType == DataTypes.STRING ||
1:3e88858:         dataType == DataTypes.VARCHAR ||
1:3e88858:         DataTypes.isDecimal(dataType)) {
1:afcaecf:       return false;
1:afcaecf:     } else {
1:afcaecf:       return true;
1:afcaecf:     }
1:afcaecf:   }
1:dded5d5: 
1:cd6a4ff:   /**
1:438b442:    * Wrapper for actual getDataBasedOnDataTypeForNoDictionaryColumn.
1:9f94529:    *
1:438b442:    * @param dataInBytes
1:438b442:    * @param actualDataType
1:438b442:    * @return
1:cd6a4ff:    */
1:9f94529:   public static Object getDataBasedOnDataTypeForNoDictionaryColumn(byte[] dataInBytes,
1:9f94529:       DataType actualDataType) {
1:438b442:     return getDataBasedOnDataTypeForNoDictionaryColumn(dataInBytes, actualDataType, true);
1:438b442:   }
1:438b442: 
1:438b442:   /**
1:9f94529:    * Below method will be used to convert the data passed to its actual data
1:9f94529:    * type
1:438b442:    *
1:438b442:    * @param dataInBytes           data
1:438b442:    * @param actualDataType        actual data type
1:438b442:    * @param isTimeStampConversion
1:9f94529:    * @return actual data after conversion
1:438b442:    */
1:438b442:   public static Object getDataBasedOnDataTypeForNoDictionaryColumn(byte[] dataInBytes,
1:438b442:       DataType actualDataType, boolean isTimeStampConversion) {
1:9f94529:     if (null == dataInBytes || Arrays
1:9f94529:         .equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY, dataInBytes)) {
1:9f94529:       return null;
1:9f94529:     }
1:9f94529:     try {
1:6abdd97:       if (actualDataType == DataTypes.BOOLEAN) {
1:9f94529:         return ByteUtil.toBoolean(dataInBytes);
1:956833e:       } else if (actualDataType == DataTypes.SHORT) {
1:a86c54b:         // for non string type no dictionary column empty byte array is empty value
1:a86c54b:         // so no need to parse
1:d85fb72:         if (isEmptyByteArray(dataInBytes)) {
1:d85fb72:           return null;
1:9f94529:         }
1:f012f5b:         return ByteUtil.toXorShort(dataInBytes, 0, dataInBytes.length);
1:956833e:       } else if (actualDataType == DataTypes.INT) {
1:d85fb72:         if (isEmptyByteArray(dataInBytes)) {
1:d85fb72:           return null;
1:d85fb72:         }
1:f012f5b:         return ByteUtil.toXorInt(dataInBytes, 0, dataInBytes.length);
1:956833e:       } else if (actualDataType == DataTypes.LONG) {
1:a86c54b:         if (isEmptyByteArray(dataInBytes)) {
1:72cb415:           return null;
1:d85fb72:         }
1:f012f5b:         return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length);
1:956833e:       } else if (actualDataType == DataTypes.TIMESTAMP) {
1:a86c54b:         if (isEmptyByteArray(dataInBytes)) {
1:72cb415:           return null;
1:dded5d5:         }
1:438b442:         if (isTimeStampConversion) {
1:f012f5b:           return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length) * 1000L;
1:438b442:         } else {
1:f012f5b:           return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length);
1:438b442:         }
1:956833e:       } else if (actualDataType == DataTypes.DOUBLE) {
1:a86c54b:         if (isEmptyByteArray(dataInBytes)) {
1:72cb415:           return null;
1:72cb415:         }
1:f012f5b:         return ByteUtil.toXorDouble(dataInBytes, 0, dataInBytes.length);
1:d85fb72:       } else if (DataTypes.isDecimal(actualDataType)) {
1:a86c54b:         if (isEmptyByteArray(dataInBytes)) {
1:72cb415:           return null;
1:72cb415:         }
1:3e88858:         return getDataTypeConverter().convertFromBigDecimalToDecimal(byteToBigDecimal(dataInBytes));
1:956833e:       } else {
1:3e88858:         // Default action for String/Varchar
1:3e88858:         return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
1:72cb415:       }
1:9f94529:     } catch (Throwable ex) {
1:9f94529:       String data = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:9f94529:       LOGGER.error("Cannot convert" + data + " to " + actualDataType.getName() + " type value" + ex
1:9f94529:           .getMessage());
1:9f94529:       LOGGER.error("Problem while converting data type" + data);
1:9f94529:       return null;
1:9f94529:     }
1:9f94529:   }
1:9f94529: 
1:cd6a4ff:   /**
1:a86c54b:    * Method to check if byte array is empty
1:cd6a4ff:    *
1:a86c54b:    * @param dataInBytes
1:a86c54b:    * @return
1:cd6a4ff:    */
1:a86c54b:   private static boolean isEmptyByteArray(byte[] dataInBytes) {
1:a86c54b:     return dataInBytes.length == 0;
1:72cb415:   }
1:9f94529: 
1:cd6a4ff: 
1:cd6a4ff:   /**
1:438b442:    * Below method will be used to convert the data passed to its actual data
1:438b442:    * type
1:a86c54b:    *
1:71fe32a:    * @param dataInBytes data
1:6b3b16c:    * @param dimension
1:438b442:    * @return actual data after conversion
1:a86c54b:    */
1:6b3b16c:   public static Object getDataBasedOnDataType(byte[] dataInBytes, CarbonDimension dimension) {
1:72cb415:     if (null == dataInBytes || Arrays
1:72cb415:         .equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY, dataInBytes)) {
1:72cb415:       return null;
1:72cb415:     }
1:72cb415:     try {
1:956833e:       DataType dataType = dimension.getDataType();
1:956833e:       if (dataType == DataTypes.INT) {
1:956833e:         String data1 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data1.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Integer.parseInt(data1);
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:956833e:         String data2 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data2.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Short.parseShort(data2);
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:956833e:         String data3 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data3.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Double.parseDouble(data3);
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         String data4 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data4.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         return Long.parseLong(data4);
1:956833e:       } else if (dataType == DataTypes.DATE) {
1:956833e:         String data5 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data5.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         try {
1:956833e:           Date dateToStr = dateformatter.get().parse(data5);
1:956833e:           return dateToStr.getTime() * 1000;
1:956833e:         } catch (ParseException e) {
1:956833e:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:956833e:           return null;
1:956833e:         }
1:956833e:       } else if (dataType == DataTypes.TIMESTAMP) {
1:956833e:         String data6 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data6.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         try {
1:956833e:           Date dateToStr = timeStampformatter.get().parse(data6);
1:956833e:           return dateToStr.getTime() * 1000;
1:956833e:         } catch (ParseException e) {
1:956833e:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:956833e:           return null;
1:956833e:         }
1:f209e8e:       } else if (DataTypes.isDecimal(dataType)) {
1:956833e:         String data7 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:956833e:         if (data7.isEmpty()) {
1:956833e:           return null;
1:956833e:         }
1:956833e:         java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data7);
1:956833e:         if (dimension.getColumnSchema().getScale() > javaDecVal.scale()) {
1:956833e:           javaDecVal = javaDecVal.setScale(dimension.getColumnSchema().getScale());
1:956833e:         }
1:982d03f:         return getDataTypeConverter().convertFromBigDecimalToDecimal(javaDecVal);
1:956833e:       } else {
1:956833e:         return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
1:72cb415:       }
1:72cb415:     } catch (NumberFormatException ex) {
1:72cb415:       String data = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:72cb415:       LOGGER.error("Problem while converting data type" + data);
1:72cb415:       return null;
1:72cb415:     }
1:72cb415:   }
1:72cb415: 
1:1f54c47:   /**
1:cd6a4ff:    * Below method will be used to basically to know whether any non parseable
1:cd6a4ff:    * data is present or not. if present then return null so that system can
1:cd6a4ff:    * process to default null member value.
1:cd6a4ff:    *
1:cd6a4ff:    * @param data           data
2:cd6a4ff:    * @param actualDataType actual data type
1:cd6a4ff:    * @return actual data after conversion
1:cd6a4ff:    */
1:cd6a4ff:   public static Object normalizeIntAndLongValues(String data, DataType actualDataType) {
2:cd6a4ff:     if (null == data) {
1:72cb415:       return null;
1:72cb415:     }
1:72cb415:     try {
1:956833e:       if (actualDataType == DataTypes.SHORT) {
1:7ef9164:         Short.parseShort(data);
1:956833e:       } else if (actualDataType == DataTypes.INT) {
1:7ef9164:         Integer.parseInt(data);
1:956833e:       } else if (actualDataType == DataTypes.LONG) {
1:7ef9164:         Long.parseLong(data);
1:956833e:       } else {
1:956833e:         return data;
1:72cb415:       }
1:7ef9164:       return data;
1:cd6a4ff:     } catch (NumberFormatException ex) {
1:72cb415:       return null;
1:72cb415:     }
1:72cb415:   }
1:72cb415: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will parse a given string value corresponding to its data type
1:cd6a4ff:    *
1:cd6a4ff:    * @param value     value to parse
1:cd6a4ff:    * @param dimension dimension to get data type and precision and scale in case of decimal
1:cd6a4ff:    *                  data type
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public static String normalizeColumnValueForItsDataType(String value, CarbonDimension dimension) {
1:72cb415:     try {
1:cd6a4ff:       Object parsedValue = null;
1:cd6a4ff:       // validation will not be done for timestamp datatype as for timestamp direct dictionary
1:cd6a4ff:       // is generated. No dictionary file is created for timestamp datatype column
1:956833e:       DataType dataType = dimension.getDataType();
1:f209e8e:       if (DataTypes.isDecimal(dataType)) {
1:956833e:         return parseStringToBigDecimal(value, dimension);
1:956833e:       } else if (dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:956833e:           dataType == DataTypes.LONG) {
1:956833e:         parsedValue = normalizeIntAndLongValues(value, dimension.getDataType());
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:956833e:         parsedValue = Double.parseDouble(value);
1:956833e:       } else {
1:956833e:         return value;
1:72cb415:       }
1:256dbed:       if (null != parsedValue) {
1:cd6a4ff:         return value;
1:cd6a4ff:       }
1:72cb415:       return null;
1:cd6a4ff:     } catch (Exception e) {
1:72cb415:       return null;
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   /**
1:cd6a4ff:    * This method will parse a value to its datatype if datatype is decimal else will return
1:cd6a4ff:    * the value passed
1:cd6a4ff:    *
1:cd6a4ff:    * @param value     value to be parsed
1:cd6a4ff:    * @param dimension
1:cd6a4ff:    * @return
1:cd6a4ff:    */
1:cd6a4ff:   public static String parseValue(String value, CarbonDimension dimension) {
1:71fe32a:     if (null == value) {
1:72cb415:       return null;
1:cd6a4ff:     }
1:cd6a4ff:     try {
1:956833e:       DataType dataType = dimension.getDataType();
1:f209e8e:       if (DataTypes.isDecimal(dataType)) {
1:956833e:         return parseStringToBigDecimal(value, dimension);
1:956833e:       } else if (dataType == DataTypes.INT) {
1:956833e:         Integer.parseInt(value);
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:956833e:         Double.parseDouble(value);
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         Long.parseLong(value);
1:956833e:       } else if (dataType == DataTypes.FLOAT) {
1:956833e:         Float.parseFloat(value);
1:956833e:       } else {
1:956833e:         // do nothing
1:cd6a4ff:       }
1:f1f4581:     } catch (NumberFormatException e) {
1:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:     return value;
1:cd6a4ff:   }
1:cd6a4ff: 
1:cd6a4ff:   private static String parseStringToBigDecimal(String value, CarbonDimension dimension) {
1:cd6a4ff:     BigDecimal bigDecimal = new BigDecimal(value)
1:cd6a4ff:         .setScale(dimension.getColumnSchema().getScale(), RoundingMode.HALF_UP);
1:cd6a4ff:     BigDecimal normalizedValue =
1:cd6a4ff:         normalizeDecimalValue(bigDecimal, dimension.getColumnSchema().getPrecision());
1:cd6a4ff:     if (null != normalizedValue) {
1:cd6a4ff:       return normalizedValue.toString();
1:cd6a4ff:     }
1:cd6a4ff:     return null;
1:cd6a4ff:   }
1:cd6a4ff: 
1:a86c54b:   /**
1:b9db4ac:    * This method will compare double values it will preserve
1:b9db4ac:    * the -0.0 and 0.0 equality as per == ,also preserve NaN equality check as per
1:b9db4ac:    * java.lang.Double.equals()
1:70256e7:    *
1:b9db4ac:    * @param d1 double value for equality check
1:b9db4ac:    * @param d2 double value for equality check
1:b9db4ac:    * @return boolean after comparing two double values.
1:70256e7:    */
1:b9db4ac:   public static int compareDoubleWithNan(Double d1, Double d2) {
1:b9db4ac:     if ((d1.doubleValue() == d2.doubleValue()) || (Double.isNaN(d1) && Double.isNaN(d2))) {
1:b9db4ac:       return 0;
1:b9db4ac:     } else if (d1 < d2) {
1:b9db4ac:       return -1;
1:cd6a4ff:     }
1:b9db4ac:     return 1;
1:cd6a4ff:   }
1:cd6a4ff: 
1:70256e7:   /**
1:70256e7:    * Below method will be used to convert the data into byte[]
1:70256e7:    *
1:70256e7:    * @param data
1:086b06d:    * @param columnSchema
1:70256e7:    * @return actual data in byte[]
1:70256e7:    */
1:2a4f09b:   public static byte[] convertDataToBytesBasedOnDataType(String data, ColumnSchema columnSchema) {
1:cd6a4ff:     if (null == data) {
1:cd6a4ff:       return null;
1:70256e7:     } else if (CarbonCommonConstants.MEMBER_DEFAULT_VAL.equals(data)) {
1:70256e7:       LOGGER.error("Default value should not be carbon specific null value : " + data);
1:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:     try {
1:70256e7:       long parsedIntVal = 0;
1:956833e:       DataType dataType = columnSchema.getDataType();
1:956833e:       if (dataType == DataTypes.INT) {
1:956833e:         parsedIntVal = (long) Integer.parseInt(data);
1:956833e:         return String.valueOf(parsedIntVal)
1:956833e:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:       } else if (dataType == DataTypes.SHORT) {
1:956833e:         parsedIntVal = (long) Short.parseShort(data);
1:956833e:         return String.valueOf(parsedIntVal)
1:956833e:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:956833e:         return String.valueOf(Double.parseDouble(data))
1:956833e:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:       } else if (dataType == DataTypes.LONG) {
1:956833e:         return String.valueOf(Long.parseLong(data))
1:956833e:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:       } else if (dataType == DataTypes.DATE) {
1:2a4f09b:         DirectDictionaryGenerator directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:2a4f09b:             .getDirectDictionaryGenerator(columnSchema.getDataType());
1:956833e:         int value = directDictionaryGenerator.generateDirectSurrogateKey(data);
1:956833e:         return String.valueOf(value)
1:956833e:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:       } else if (dataType == DataTypes.TIMESTAMP) {
1:956833e:         if (columnSchema.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:956833e:           DirectDictionaryGenerator directDictionaryGenerator1 = DirectDictionaryKeyGeneratorFactory
1:956833e:               .getDirectDictionaryGenerator(columnSchema.getDataType());
1:956833e:           int value1 = directDictionaryGenerator1.generateDirectSurrogateKey(data);
1:956833e:           return String.valueOf(value1)
5:70256e7:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:956833e:         } else {
1:956833e:           try {
1:b52f157:             timeStampformatter.remove();
1:956833e:             Date dateToStr = timeStampformatter.get().parse(data);
1:f012f5b:             return ByteUtil.toXorBytes(dateToStr.getTime());
1:956833e:           } catch (ParseException e) {
1:956833e:             LOGGER.error(
1:956833e:                 "Cannot convert value to Time/Long type value. Value is considered as null" + e
1:956833e:                     .getMessage());
1:956833e:             return null;
1:956833e:           }
1:956833e:         }
1:f209e8e:       } else if (DataTypes.isDecimal(dataType)) {
1:2a4f09b:         String parsedValue = parseStringToBigDecimal(data, columnSchema);
1:2a4f09b:         if (null == parsedValue) {
1:2a4f09b:           return null;
1:2a4f09b:         }
1:2a4f09b:         java.math.BigDecimal javaDecVal = new java.math.BigDecimal(parsedValue);
1:956833e:         return bigDecimalToByte(javaDecVal);
1:956833e:       } else {
1:956833e:         return getDataTypeConverter().convertFromStringToByte(data);
1:cd6a4ff:       }
1:cd6a4ff:     } catch (NumberFormatException ex) {
1:cd6a4ff:       LOGGER.error("Problem while converting data type" + data);
1:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:70256e7:   /**
1:70256e7:    * This method will parse a given string value corresponding to its data type
1:70256e7:    *
1:71fe32a:    * @param value        value to parse
1:70256e7:    * @param columnSchema dimension to get data type and precision and scale in case of decimal
1:71fe32a:    *                     data type
1:70256e7:    * @return
1:70256e7:    */
1:70256e7:   public static String normalizeColumnValueForItsDataType(String value, ColumnSchema columnSchema) {
1:cd6a4ff:     try {
1:cd6a4ff:       Object parsedValue = null;
1:956833e:       DataType dataType = columnSchema.getDataType();
1:f209e8e:       if (DataTypes.isDecimal(dataType)) {
1:956833e:         return parseStringToBigDecimal(value, columnSchema);
1:956833e:       } else if (dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:956833e:           dataType == DataTypes.LONG) {
1:956833e:         parsedValue = normalizeIntAndLongValues(value, columnSchema.getDataType());
1:956833e:       } else if (dataType == DataTypes.DOUBLE) {
1:956833e:         parsedValue = Double.parseDouble(value);
1:956833e:       } else {
1:956833e:         return value;
1:cd6a4ff:       }
1:cd6a4ff:       if (null != parsedValue) {
1:cd6a4ff:         return value;
1:cd6a4ff:       }
1:cd6a4ff:       return null;
1:cd6a4ff:     } catch (Exception e) {
1:cd6a4ff:       return null;
1:cd6a4ff:     }
1:cd6a4ff:   }
1:cd6a4ff: 
1:70256e7:   private static String parseStringToBigDecimal(String value, ColumnSchema columnSchema) {
1:dded5d5:     BigDecimal bigDecimal =
1:71fe32a:         new BigDecimal(value).setScale(columnSchema.getScale(), RoundingMode.HALF_UP);
1:71fe32a:     BigDecimal normalizedValue = normalizeDecimalValue(bigDecimal, columnSchema.getPrecision());
1:70256e7:     if (null != normalizedValue) {
1:70256e7:       return normalizedValue.toString();
1:cd6a4ff:     }
1:cd6a4ff:     return null;
1:cd6a4ff:   }
1:a86c54b: 
1:70256e7:   /**
1:09f7cdd:    * set the data type converter as per computing engine
1:09f7cdd:    * @param converterLocal
1:03ddcc8:    */
1:09f7cdd:   public static void setDataTypeConverter(DataTypeConverter converterLocal) {
1:cfb8ed9:     if (converterLocal != null) {
1:cfb8ed9:       converter = converterLocal;
1:cfb8ed9:       timeStampformatter.remove();
1:cfb8ed9:       dateformatter.remove();
1:cfb8ed9:     }
1:cd6a4ff:   }
1:70256e7: 
1:09f7cdd:   public static DataTypeConverter getDataTypeConverter() {
1:09f7cdd:     if (converter == null) {
1:09f7cdd:       converter = new DataTypeConverterImpl();
1:cd6a4ff:     }
1:09f7cdd:     return converter;
1:cd6a4ff:   }
1:70256e7: 
1:03ddcc8:   public static DataType valueOf(String name) {
1:03ddcc8:     if (DataTypes.STRING.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.STRING;
1:03ddcc8:     } else if (DataTypes.DATE.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.DATE;
1:03ddcc8:     } else if (DataTypes.TIMESTAMP.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.TIMESTAMP;
1:03ddcc8:     } else if (DataTypes.BOOLEAN.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.BOOLEAN;
1:03ddcc8:     } else if (DataTypes.BYTE.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.BYTE;
1:03ddcc8:     } else if (DataTypes.SHORT.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.SHORT;
1:03ddcc8:     } else if (DataTypes.SHORT_INT.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.SHORT_INT;
1:03ddcc8:     } else if (DataTypes.INT.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.INT;
1:03ddcc8:     } else if (DataTypes.LONG.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.LONG;
1:03ddcc8:     } else if (DataTypes.LEGACY_LONG.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.LEGACY_LONG;
1:03ddcc8:     } else if (DataTypes.FLOAT.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.FLOAT;
1:03ddcc8:     } else if (DataTypes.DOUBLE.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.DOUBLE;
1:dc53dee:     } else if (DataTypes.VARCHAR.getName().equalsIgnoreCase(name)) {
1:dc53dee:       return DataTypes.VARCHAR;
1:03ddcc8:     } else if (DataTypes.NULL.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.NULL;
1:03ddcc8:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.BYTE_ARRAY;
1:03ddcc8:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(name)) {
1:03ddcc8:       return DataTypes.BYTE_ARRAY;
1:df27831:     } else if (name.equalsIgnoreCase("decimal")) {
1:df27831:       return DataTypes.createDefaultDecimalType();
1:df27831:     } else if (name.equalsIgnoreCase("array")) {
1:df27831:       return DataTypes.createDefaultArrayType();
1:df27831:     } else if (name.equalsIgnoreCase("struct")) {
1:df27831:       return DataTypes.createDefaultStructType();
1:df27831:     } else if (name.equalsIgnoreCase("map")) {
1:df27831:       return DataTypes.createDefaultMapType();
1:dded5d5:     } else {
1:03ddcc8:       throw new RuntimeException("create DataType with invalid name: " + name);
1:cd6a4ff:     }
1:cd6a4ff:   }
1:70256e7: 
1:03ddcc8:   /**
1:df27831:    * @param dataType extracted from the json data
1:df27831:    * @return returns the datatype based on the input string from json to deserialize the tableInfo
1:df27831:    */
1:df27831:   public static DataType valueOf(DataType dataType, int precision, int scale) {
1:df27831:     if (DataTypes.STRING.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.STRING;
1:df27831:     } else if (DataTypes.DATE.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.DATE;
1:df27831:     } else if (DataTypes.TIMESTAMP.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.TIMESTAMP;
1:df27831:     } else if (DataTypes.BOOLEAN.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.BOOLEAN;
1:df27831:     } else if (DataTypes.BYTE.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.BYTE;
1:df27831:     } else if (DataTypes.SHORT.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.SHORT;
1:df27831:     } else if (DataTypes.SHORT_INT.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.SHORT_INT;
1:df27831:     } else if (DataTypes.INT.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.INT;
1:df27831:     } else if (DataTypes.LONG.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.LONG;
1:df27831:     } else if (DataTypes.LEGACY_LONG.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.LEGACY_LONG;
1:df27831:     } else if (DataTypes.FLOAT.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.FLOAT;
1:df27831:     } else if (DataTypes.DOUBLE.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.DOUBLE;
1:dc53dee:     } else if (DataTypes.VARCHAR.getName().equalsIgnoreCase(dataType.getName())) {
1:dc53dee:       return DataTypes.VARCHAR;
1:df27831:     } else if (DataTypes.NULL.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.NULL;
1:df27831:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.BYTE_ARRAY;
1:df27831:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(dataType.getName())) {
1:df27831:       return DataTypes.BYTE_ARRAY;
1:df27831:     } else if (dataType.getName().equalsIgnoreCase("decimal")) {
1:df27831:       return DataTypes.createDecimalType(precision, scale);
1:df27831:     } else if (dataType.getName().equalsIgnoreCase("array")) {
1:df27831:       return DataTypes.createDefaultArrayType();
1:df27831:     } else if (dataType.getName().equalsIgnoreCase("struct")) {
1:df27831:       return DataTypes.createDefaultStructType();
1:df27831:     } else if (dataType.getName().equalsIgnoreCase("map")) {
1:df27831:       return DataTypes.createDefaultMapType();
1:df27831:     } else {
1:df27831:       throw new RuntimeException(
1:df27831:           "create DataType with invalid dataType.getName(): " + dataType.getName());
1:df27831:     }
1:df27831:   }
1:df27831: 
1:df27831:   /**
1:1f54c47:    * Method to type case the data based on modified data type. This method will used for
1:1f54c47:    * retrieving the data after change in data type restructure operation
1:1f54c47:    *
1:1f54c47:    * @param data
1:1f54c47:    * @param restructuredDataType
1:1f54c47:    * @param currentDataOffset
1:1f54c47:    * @param length
1:1f54c47:    * @return
1:1f54c47:    */
1:1f54c47:   public static long getDataBasedOnRestructuredDataType(byte[] data, DataType restructuredDataType,
1:1f54c47:       int currentDataOffset, int length) {
1:1f54c47:     long value = 0L;
1:1f54c47:     if (restructuredDataType == DataTypes.INT) {
1:f012f5b:       value = ByteUtil.toXorInt(data, currentDataOffset, length);
1:1f54c47:     } else if (restructuredDataType == DataTypes.LONG) {
1:f012f5b:       value = ByteUtil.toXorLong(data, currentDataOffset, length);
1:1f54c47:     }
1:1f54c47:     return value;
1:1f54c47:   }
1:1f54c47: 
1:1f54c47: }
============================================================================
author:QiangCai
-------------------------------------------------------------------------------
commit:f012f5b
/////////////////////////////////////////////////////////////////////////
1:       return ByteUtil.toXorBytes(Short.parseShort(dimensionValue));
1:       return ByteUtil.toXorBytes(Integer.parseInt(dimensionValue));
1:       return ByteUtil.toXorBytes(Long.parseLong(dimensionValue));
1:       return ByteUtil.toXorBytes(Double.parseDouble(dimensionValue));
/////////////////////////////////////////////////////////////////////////
1:         return ByteUtil.toXorBytes(dateToStr.getTime());
/////////////////////////////////////////////////////////////////////////
1:       return ByteUtil.toXorBytes((Short) dimensionValue);
1:       return ByteUtil.toXorBytes((Integer) dimensionValue);
1:       return ByteUtil.toXorBytes((Long) dimensionValue);
1:       return ByteUtil.toXorBytes((Long)dimensionValue);
/////////////////////////////////////////////////////////////////////////
1:         return ByteUtil.toXorShort(dataInBytes, 0, dataInBytes.length);
1:         return ByteUtil.toXorInt(dataInBytes, 0, dataInBytes.length);
1:         return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length);
1:           return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length) * 1000L;
1:           return ByteUtil.toXorLong(dataInBytes, 0, dataInBytes.length);
1:         return ByteUtil.toXorDouble(dataInBytes, 0, dataInBytes.length);
/////////////////////////////////////////////////////////////////////////
1:             return ByteUtil.toXorBytes(dateToStr.getTime());
/////////////////////////////////////////////////////////////////////////
1:       value = ByteUtil.toXorInt(data, currentDataOffset, length);
1:       value = ByteUtil.toXorLong(data, currentDataOffset, length);
commit:5f9741e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f5c6f28
/////////////////////////////////////////////////////////////////////////
1:       DataType actualDataType) {
commit:9f94529
/////////////////////////////////////////////////////////////////////////
1:   public static byte[] getBytesBasedOnDataTypeForNoDictionaryColumn(String dimensionValue,
0:       DataType actualDataType) throws Throwable {
0:     switch (actualDataType) {
0:       case STRING:
1:         return ByteUtil.toBytes(dimensionValue);
0:       case BOOLEAN:
0:         return ByteUtil.toBytes(Boolean.parseBoolean(dimensionValue));
0:       case SHORT:
0:         return ByteUtil.toBytes(Short.parseShort(dimensionValue));
0:       case INT:
0:         return ByteUtil.toBytes(Integer.parseInt(dimensionValue));
0:       case FLOAT:
0:         return ByteUtil.toBytes(Float.parseFloat(dimensionValue));
0:       case LONG:
0:         return ByteUtil.toBytes(Long.parseLong(dimensionValue));
0:       case DOUBLE:
0:         return ByteUtil.toBytes(Double.parseDouble(dimensionValue));
0:       case DECIMAL:
0:         return ByteUtil.toBytes(new BigDecimal(dimensionValue));
0:       default:
1:         return ByteUtil.toBytes(dimensionValue);
1:     }
1:   }
1: 
1: 
1:   /**
1:    * Below method will be used to convert the data passed to its actual data
1:    * type
1:    *
0:    * @param dataInBytes    data
1:    * @param actualDataType actual data type
1:    * @return actual data after conversion
1:    */
1:   public static Object getDataBasedOnDataTypeForNoDictionaryColumn(byte[] dataInBytes,
1:       DataType actualDataType) {
1:     if (null == dataInBytes || Arrays
1:         .equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY, dataInBytes)) {
1:       return null;
1:     }
1:     try {
0:       switch (actualDataType) {
0:         case STRING:
0:           return UTF8String.fromBytes(dataInBytes);
0:         case BOOLEAN:
1:           return ByteUtil.toBoolean(dataInBytes);
0:         case SHORT:
0:           return ByteUtil.toShort(dataInBytes, 0, dataInBytes.length);
0:         case INT:
0:           return ByteUtil.toInt(dataInBytes, 0, dataInBytes.length);
0:         case FLOAT:
0:           return ByteUtil.toFloat(dataInBytes, 0);
0:         case LONG:
0:           return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length);
0:         case DOUBLE:
0:           return ByteUtil.toDouble(dataInBytes, 0);
0:         case DECIMAL:
0:           return ByteUtil.toBigDecimal(dataInBytes, 0, dataInBytes.length);
0:         default:
0:           return ByteUtil.toString(dataInBytes, 0, dataInBytes.length);
1:       }
1:     } catch (Throwable ex) {
1:       String data = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:       LOGGER.error("Cannot convert" + data + " to " + actualDataType.getName() + " type value" + ex
1:           .getMessage());
1:       LOGGER.error("Problem while converting data type" + data);
1:       return null;
1:     }
1:   }
1: 
1: 
commit:086b06d
/////////////////////////////////////////////////////////////////////////
1:    * @param columnSchema
commit:256dbed
/////////////////////////////////////////////////////////////////////////
1:     System.arraycopy(raw, offset + 1, unscale, 0, unscale.length);
/////////////////////////////////////////////////////////////////////////
1:       if (null != parsedValue) {
commit:41347d8
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:d73f4bf
/////////////////////////////////////////////////////////////////////////
0:     dataTypeDisplayNames.put(DataType.DATE.toString(), DataType.DATE.getName());
/////////////////////////////////////////////////////////////////////////
0:       case "DATE":
0:         dataType = DataType.DATE;
0:         break;
/////////////////////////////////////////////////////////////////////////
0:         case DATE:
author:ajantha-bhat
-------------------------------------------------------------------------------
commit:438b442
/////////////////////////////////////////////////////////////////////////
1:    * Wrapper for actual getDataBasedOnDataTypeForNoDictionaryColumn.
1:    * @param dataInBytes
1:    * @param actualDataType
1:    * @return
1:     return getDataBasedOnDataTypeForNoDictionaryColumn(dataInBytes, actualDataType, true);
1:   }
1: 
1:   /**
1:    * Below method will be used to convert the data passed to its actual data
1:    * type
1:    *
1:    * @param dataInBytes           data
1:    * @param actualDataType        actual data type
1:    * @param isTimeStampConversion
1:    * @return actual data after conversion
1:    */
1:   public static Object getDataBasedOnDataTypeForNoDictionaryColumn(byte[] dataInBytes,
1:       DataType actualDataType, boolean isTimeStampConversion) {
/////////////////////////////////////////////////////////////////////////
1:         if (isTimeStampConversion) {
0:           return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length) * 1000L;
1:         } else {
0:           return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length);
1:         }
author:Manhua
-------------------------------------------------------------------------------
commit:3e88858
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       // Default action for String/Varchar
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       // Default action for String/Varchar
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       // Default action for String/Varchar
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.STRING ||
1:         dataType == DataTypes.VARCHAR ||
1:         DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return getDataTypeConverter().convertFromBigDecimalToDecimal(byteToBigDecimal(dataInBytes));
1:         // Default action for String/Varchar
1:         return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
author:Indhumathi27
-------------------------------------------------------------------------------
commit:afcaecf
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Returns true for fixed length DataTypes.
1:    * @param dataType
1:    * @return
1:    */
1:   public static boolean isFixedSizeDataType(DataType dataType) {
0:     if (dataType == DataTypes.STRING || DataTypes.isDecimal(dataType)) {
1:       return false;
1:     } else {
1:       return true;
1:     }
1:   }
author:xuchuanyin
-------------------------------------------------------------------------------
commit:dc53dee
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.VARCHAR.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.VARCHAR;
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.VARCHAR.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.VARCHAR;
author:kunal642
-------------------------------------------------------------------------------
commit:cf666c1
/////////////////////////////////////////////////////////////////////////
1:           dateFormatter.setLenient(false);
/////////////////////////////////////////////////////////////////////////
1:           dateFormatter.setLenient(false);
commit:df27831
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     } else if (name.equalsIgnoreCase("decimal")) {
1:       return DataTypes.createDefaultDecimalType();
1:     } else if (name.equalsIgnoreCase("array")) {
1:       return DataTypes.createDefaultArrayType();
1:     } else if (name.equalsIgnoreCase("struct")) {
1:       return DataTypes.createDefaultStructType();
1:     } else if (name.equalsIgnoreCase("map")) {
1:       return DataTypes.createDefaultMapType();
1:    * @param dataType extracted from the json data
1:    * @return returns the datatype based on the input string from json to deserialize the tableInfo
1:    */
1:   public static DataType valueOf(DataType dataType, int precision, int scale) {
1:     if (DataTypes.STRING.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.STRING;
1:     } else if (DataTypes.DATE.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.DATE;
1:     } else if (DataTypes.TIMESTAMP.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.TIMESTAMP;
1:     } else if (DataTypes.BOOLEAN.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.BOOLEAN;
1:     } else if (DataTypes.BYTE.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.BYTE;
1:     } else if (DataTypes.SHORT.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.SHORT;
1:     } else if (DataTypes.SHORT_INT.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.SHORT_INT;
1:     } else if (DataTypes.INT.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.INT;
1:     } else if (DataTypes.LONG.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.LONG;
1:     } else if (DataTypes.LEGACY_LONG.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.LEGACY_LONG;
1:     } else if (DataTypes.FLOAT.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.FLOAT;
1:     } else if (DataTypes.DOUBLE.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.DOUBLE;
1:     } else if (DataTypes.NULL.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.NULL;
1:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.BYTE_ARRAY;
1:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(dataType.getName())) {
1:       return DataTypes.BYTE_ARRAY;
1:     } else if (dataType.getName().equalsIgnoreCase("decimal")) {
1:       return DataTypes.createDecimalType(precision, scale);
1:     } else if (dataType.getName().equalsIgnoreCase("array")) {
1:       return DataTypes.createDefaultArrayType();
1:     } else if (dataType.getName().equalsIgnoreCase("struct")) {
1:       return DataTypes.createDefaultStructType();
1:     } else if (dataType.getName().equalsIgnoreCase("map")) {
1:       return DataTypes.createDefaultMapType();
1:     } else {
1:       throw new RuntimeException(
1:           "create DataType with invalid dataType.getName(): " + dataType.getName());
1:     }
1:   }
1: 
1:   /**
commit:2a4f09b
/////////////////////////////////////////////////////////////////////////
0:    * @param ColumnSchema
1:   public static byte[] convertDataToBytesBasedOnDataType(String data, ColumnSchema columnSchema) {
/////////////////////////////////////////////////////////////////////////
0:       switch (columnSchema.getDataType()) {
/////////////////////////////////////////////////////////////////////////
1:           DirectDictionaryGenerator directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:               .getDirectDictionaryGenerator(columnSchema.getDataType());
1:           String parsedValue = parseStringToBigDecimal(data, columnSchema);
1:           if (null == parsedValue) {
1:             return null;
1:           }
1:           java.math.BigDecimal javaDecVal = new java.math.BigDecimal(parsedValue);
author:Raghunandan S
-------------------------------------------------------------------------------
commit:7ef9164
/////////////////////////////////////////////////////////////////////////
1:         Short.parseShort(data);
1:         Integer.parseInt(data);
1:         Long.parseLong(data);
1:       return data;
author:kumarvishal09
-------------------------------------------------------------------------------
commit:d85fb72
/////////////////////////////////////////////////////////////////////////
1:     } else if (actualDataType == DataTypes.DOUBLE) {
0:       return ByteUtil.toBytes(Double.parseDouble(dimensionValue));
1:     } else if (DataTypes.isDecimal(actualDataType)) {
1:       return bigDecimalToByte(new BigDecimal(dimensionValue));
/////////////////////////////////////////////////////////////////////////
1:     } else if (actualDataType == DataTypes.DOUBLE) {
1:       return Double.parseDouble(dimensionValue);
1:     } else if (DataTypes.isDecimal(actualDataType)) {
1:       return new BigDecimal(dimensionValue);
/////////////////////////////////////////////////////////////////////////
1:       } else if (actualDataType == DataTypes.DOUBLE) {
1:         if (isEmptyByteArray(dataInBytes)) {
1:           return null;
1:         }
0:         return ByteUtil.toDouble(dataInBytes, 0, dataInBytes.length);
1:       } else if (DataTypes.isDecimal(actualDataType)) {
1:         if (isEmptyByteArray(dataInBytes)) {
1:           return null;
1:         }
0:         return converter.convertFromBigDecimalToDecimal(byteToBigDecimal(dataInBytes));
author:Jacky Li
-------------------------------------------------------------------------------
commit:cfb8ed9
/////////////////////////////////////////////////////////////////////////
1:     if (converterLocal != null) {
1:       converter = converterLocal;
1:       timeStampformatter.remove();
1:       dateformatter.remove();
1:     }
commit:982d03f
/////////////////////////////////////////////////////////////////////////
1:         return converter.convertFromBigDecimalToDecimal(decimal);
/////////////////////////////////////////////////////////////////////////
1:         return converter.convertFromStringToDecimal(data);
/////////////////////////////////////////////////////////////////////////
1:         return getDataTypeConverter().convertFromBigDecimalToDecimal(javaDecVal);
commit:f209e8e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:     } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:         return null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       } else if (DataTypes.isDecimal(actualDataType)) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       } else if (DataTypes.isDecimal(dataType)) {
/////////////////////////////////////////////////////////////////////////
1:       if (DataTypes.isDecimal(dataType)) {
commit:956833e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataTypes;
/////////////////////////////////////////////////////////////////////////
0:     dataTypeDisplayNames.put(DataTypes.DATE.toString(), DataTypes.DATE.getName());
0:     dataTypeDisplayNames.put(DataTypes.LONG.toString(), DataTypes.LONG.getName());
0:     dataTypeDisplayNames.put(DataTypes.INT.toString(), DataTypes.INT.getName());
0:     dataTypeDisplayNames.put(DataTypes.FLOAT.toString(), DataTypes.FLOAT.getName());
0:     dataTypeDisplayNames.put(DataTypes.BOOLEAN.toString(), DataTypes.BOOLEAN.getName());
0:     dataTypeDisplayNames.put(DataTypes.NULL.toString(), DataTypes.NULL.getName());
0:     dataTypeDisplayNames.put(DataTypes.DECIMAL.toString(), DataTypes.DECIMAL.getName());
0:     dataTypeDisplayNames.put(DataTypes.ARRAY.toString(), DataTypes.ARRAY.getName());
0:     dataTypeDisplayNames.put(DataTypes.STRUCT.toString(), DataTypes.STRUCT.getName());
0:     dataTypeDisplayNames.put(DataTypes.TIMESTAMP.toString(), DataTypes.TIMESTAMP.getName());
0:     dataTypeDisplayNames.put(DataTypes.DATE.toString(), DataTypes.DATE.getName());
0:     dataTypeDisplayNames.put(DataTypes.SHORT.toString(), DataTypes.SHORT.getName());
0:     dataTypeDisplayNames.put(DataTypes.STRING.toString(), DataTypes.STRING.getName());
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.DECIMAL) {
1:       BigDecimal bigDecimal =
1:           new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:       return normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision());
1:     } else if (dataType == DataTypes.SHORT) {
1:       return Short.parseShort(msrValue);
1:     } else if (dataType == DataTypes.INT) {
1:       return Integer.parseInt(msrValue);
1:     } else if (dataType == DataTypes.LONG) {
1:       return Long.valueOf(msrValue);
1:     } else {
1:       Double parsedValue = Double.valueOf(msrValue);
1:       if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
1:         return null;
1:       }
1:       return parsedValue;
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.SHORT) {
1:       return (short) bb.getLong();
1:     } else if (dataType == DataTypes.INT) {
1:       return (int) bb.getLong();
1:     } else if (dataType == DataTypes.LONG) {
1:       return bb.getLong();
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       return byteToBigDecimal(data);
1:     } else {
1:       return bb.getDouble();
0:     if (dataType == DataTypes.SHORT) {
1:       return (short) measurePage.getLong(index);
1:     } else if (dataType == DataTypes.INT) {
1:       return (int) measurePage.getLong(index);
1:     } else if (dataType == DataTypes.LONG) {
1:       return measurePage.getLong(index);
0:     } else if (dataType == DataTypes.DECIMAL) {
1:       BigDecimal bigDecimalMsrValue = measurePage.getDecimal(index);
1:       if (null != bigDecimalMsrValue && carbonMeasure.getScale() > bigDecimalMsrValue.scale()) {
1:         bigDecimalMsrValue =
1:             bigDecimalMsrValue.setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
1:       }
1:       if (null != bigDecimalMsrValue) {
1:         return normalizeDecimalValue(bigDecimalMsrValue, carbonMeasure.getPrecision());
1:       } else {
0:         return bigDecimalMsrValue;
1:       }
1:     } else {
1:       return measurePage.getDouble(index);
/////////////////////////////////////////////////////////////////////////
0:         dataType = DataTypes.DATE;
0:         dataType = DataTypes.TIMESTAMP;
0:         dataType = DataTypes.STRING;
0:         dataType = DataTypes.INT;
0:         dataType = DataTypes.SHORT;
0:         dataType = DataTypes.LONG;
0:         dataType = DataTypes.DOUBLE;
0:         dataType = DataTypes.DECIMAL;
0:         dataType = DataTypes.ARRAY;
0:         dataType = DataTypes.STRUCT;
0:         dataType = DataTypes.STRING;
/////////////////////////////////////////////////////////////////////////
0:       if (actualDataType == DataTypes.INT) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         return Integer.parseInt(data);
1:       } else if (actualDataType == DataTypes.SHORT) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         return Short.parseShort(data);
1:       } else if (actualDataType == DataTypes.FLOAT) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         return Float.parseFloat(data);
1:       } else if (actualDataType == DataTypes.DOUBLE) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         return Double.parseDouble(data);
1:       } else if (actualDataType == DataTypes.LONG) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         return Long.parseLong(data);
1:       } else if (actualDataType == DataTypes.DATE) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         try {
1:           Date dateToStr = dateformatter.get().parse(data);
1:           return dateToStr.getTime() * 1000;
1:         } catch (ParseException e) {
1:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:           return null;
1:         }
1:       } else if (actualDataType == DataTypes.TIMESTAMP) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
1:         try {
1:           Date dateToStr = timeStampformatter.get().parse(data);
1:           return dateToStr.getTime() * 1000;
1:         } catch (ParseException e) {
1:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:           return null;
1:         }
0:       } else if (actualDataType == DataTypes.DECIMAL) {
1:         if (data.isEmpty()) {
1:           return null;
1:         }
0:         return converter.convertToDecimal(data);
1:       } else {
1:         return converter.convertFromStringToUTF8String(data);
/////////////////////////////////////////////////////////////////////////
1:     if (actualDataType == DataTypes.STRING) {
0:       return ByteUtil.toBytes(dimensionValue);
0:     } else if (actualDataType == DataTypes.BOOLEAN) {
0:       return ByteUtil.toBytes(Boolean.parseBoolean(dimensionValue));
1:     } else if (actualDataType == DataTypes.SHORT) {
0:       return ByteUtil.toBytes(Short.parseShort(dimensionValue));
1:     } else if (actualDataType == DataTypes.INT) {
0:       return ByteUtil.toBytes(Integer.parseInt(dimensionValue));
1:     } else if (actualDataType == DataTypes.LONG) {
0:       return ByteUtil.toBytes(Long.parseLong(dimensionValue));
1:     } else if (actualDataType == DataTypes.TIMESTAMP) {
1:       Date dateToStr = null;
1:       DateFormat dateFormatter = null;
1:       try {
0:         if (null != dateFormat) {
1:           dateFormatter = new SimpleDateFormat(dateFormat);
1:         } else {
1:           dateFormatter = timeStampformatter.get();
1:         dateToStr = dateFormatter.parse(dimensionValue);
0:         return ByteUtil.toBytes(dateToStr.getTime());
1:       } catch (ParseException e) {
1:         throw new NumberFormatException(e.getMessage());
1:       }
1:     } else {
0:       return ByteUtil.toBytes(dimensionValue);
/////////////////////////////////////////////////////////////////////////
0:       if (actualDataType == DataTypes.STRING) {
1:         return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
0:       } else if (actualDataType == DataTypes.BOOLEAN) {
0:         return ByteUtil.toBoolean(dataInBytes);
1:       } else if (actualDataType == DataTypes.SHORT) {
0:         return ByteUtil.toShort(dataInBytes, 0, dataInBytes.length);
1:       } else if (actualDataType == DataTypes.INT) {
0:         return ByteUtil.toInt(dataInBytes, 0, dataInBytes.length);
1:       } else if (actualDataType == DataTypes.LONG) {
0:         return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length);
1:       } else if (actualDataType == DataTypes.TIMESTAMP) {
0:         return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length) * 1000L;
1:       } else {
0:         return ByteUtil.toString(dataInBytes, 0, dataInBytes.length);
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = dimension.getDataType();
1:       if (dataType == DataTypes.INT) {
1:         String data1 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data1.isEmpty()) {
1:           return null;
1:         }
1:         return Integer.parseInt(data1);
1:       } else if (dataType == DataTypes.SHORT) {
1:         String data2 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data2.isEmpty()) {
1:           return null;
1:         }
1:         return Short.parseShort(data2);
1:       } else if (dataType == DataTypes.DOUBLE) {
1:         String data3 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data3.isEmpty()) {
1:           return null;
1:         }
1:         return Double.parseDouble(data3);
1:       } else if (dataType == DataTypes.LONG) {
1:         String data4 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data4.isEmpty()) {
1:           return null;
1:         }
1:         return Long.parseLong(data4);
1:       } else if (dataType == DataTypes.DATE) {
1:         String data5 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data5.isEmpty()) {
1:           return null;
1:         }
1:         try {
1:           Date dateToStr = dateformatter.get().parse(data5);
1:           return dateToStr.getTime() * 1000;
1:         } catch (ParseException e) {
1:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:           return null;
1:         }
1:       } else if (dataType == DataTypes.TIMESTAMP) {
1:         String data6 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data6.isEmpty()) {
1:           return null;
1:         }
1:         try {
1:           Date dateToStr = timeStampformatter.get().parse(data6);
1:           return dateToStr.getTime() * 1000;
1:         } catch (ParseException e) {
1:           LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
1:           return null;
1:         }
0:       } else if (dataType == DataTypes.DECIMAL) {
1:         String data7 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:         if (data7.isEmpty()) {
1:           return null;
1:         }
1:         java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data7);
1:         if (dimension.getColumnSchema().getScale() > javaDecVal.scale()) {
1:           javaDecVal = javaDecVal.setScale(dimension.getColumnSchema().getScale());
1:         }
0:         return getDataTypeConverter().convertToDecimal(javaDecVal);
1:       } else {
0:         return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
/////////////////////////////////////////////////////////////////////////
1:       if (actualDataType == DataTypes.SHORT) {
0:         parsedValue = Short.parseShort(data);
1:       } else if (actualDataType == DataTypes.INT) {
0:         parsedValue = Integer.parseInt(data);
1:       } else if (actualDataType == DataTypes.LONG) {
0:         parsedValue = Long.parseLong(data);
1:       } else {
1:         return data;
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = dimension.getDataType();
0:       if (dataType == DataTypes.DECIMAL) {
1:         return parseStringToBigDecimal(value, dimension);
1:       } else if (dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:           dataType == DataTypes.LONG) {
1:         parsedValue = normalizeIntAndLongValues(value, dimension.getDataType());
1:       } else if (dataType == DataTypes.DOUBLE) {
1:         parsedValue = Double.parseDouble(value);
1:       } else {
1:         return value;
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = dimension.getDataType();
0:       if (dataType == DataTypes.DECIMAL) {
1:         return parseStringToBigDecimal(value, dimension);
1:       } else if (dataType == DataTypes.INT) {
1:         Integer.parseInt(value);
1:       } else if (dataType == DataTypes.DOUBLE) {
1:         Double.parseDouble(value);
1:       } else if (dataType == DataTypes.LONG) {
1:         Long.parseLong(value);
1:       } else if (dataType == DataTypes.FLOAT) {
1:         Float.parseFloat(value);
1:       } else {
1:         // do nothing
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = columnSchema.getDataType();
1:       if (dataType == DataTypes.INT) {
1:         parsedIntVal = (long) Integer.parseInt(data);
1:         return String.valueOf(parsedIntVal)
1:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       } else if (dataType == DataTypes.SHORT) {
1:         parsedIntVal = (long) Short.parseShort(data);
1:         return String.valueOf(parsedIntVal)
1:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       } else if (dataType == DataTypes.DOUBLE) {
1:         return String.valueOf(Double.parseDouble(data))
1:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       } else if (dataType == DataTypes.LONG) {
1:         return String.valueOf(Long.parseLong(data))
1:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       } else if (dataType == DataTypes.DATE) {
0:         DirectDictionaryGenerator directDictionaryGenerator = DirectDictionaryKeyGeneratorFactory
1:             .getDirectDictionaryGenerator(columnSchema.getDataType());
1:         int value = directDictionaryGenerator.generateDirectSurrogateKey(data);
1:         return String.valueOf(value)
1:             .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
1:       } else if (dataType == DataTypes.TIMESTAMP) {
1:         if (columnSchema.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
1:           DirectDictionaryGenerator directDictionaryGenerator1 = DirectDictionaryKeyGeneratorFactory
1:           int value1 = directDictionaryGenerator1.generateDirectSurrogateKey(data);
1:           return String.valueOf(value1)
1:         } else {
1:           try {
1:             Date dateToStr = timeStampformatter.get().parse(data);
0:             return ByteUtil.toBytes(dateToStr.getTime());
1:           } catch (ParseException e) {
1:             LOGGER.error(
1:                 "Cannot convert value to Time/Long type value. Value is considered as null" + e
1:                     .getMessage());
1:         }
0:       } else if (dataType == DataTypes.DECIMAL) {
0:         String parsedValue = parseStringToBigDecimal(data, columnSchema);
0:         if (null == parsedValue) {
1:           return null;
1:         }
0:         java.math.BigDecimal javaDecVal = new java.math.BigDecimal(parsedValue);
1:         return bigDecimalToByte(javaDecVal);
1:       } else {
1:         return getDataTypeConverter().convertFromStringToByte(data);
/////////////////////////////////////////////////////////////////////////
1:       DataType dataType = columnSchema.getDataType();
0:       if (dataType == DataTypes.DECIMAL) {
1:         return parseStringToBigDecimal(value, columnSchema);
1:       } else if (dataType == DataTypes.SHORT || dataType == DataTypes.INT ||
1:           dataType == DataTypes.LONG) {
1:         parsedValue = normalizeIntAndLongValues(value, columnSchema.getDataType());
1:       } else if (dataType == DataTypes.DOUBLE) {
1:         parsedValue = Double.parseDouble(value);
1:       } else {
1:         return value;
author:Jatin
-------------------------------------------------------------------------------
commit:b52f157
/////////////////////////////////////////////////////////////////////////
1:             timeStampformatter.remove();
author:ravipesala
-------------------------------------------------------------------------------
commit:8d3c774
/////////////////////////////////////////////////////////////////////////
1:     return getMeasureValueBasedOnDataType(msrValue, dataType,carbonMeasure, false);
/////////////////////////////////////////////////////////////////////////
1:   public static Object getMeasureValueBasedOnDataType(String msrValue, DataType dataType,
1:       CarbonMeasure carbonMeasure, boolean useConverter) {
1:       BigDecimal decimal = normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision());
1:       if (useConverter) {
0:         return converter.convertToDecimal(decimal);
1:       } else {
1:         return decimal;
1:       }
/////////////////////////////////////////////////////////////////////////
0:     timeStampformatter.remove();
0:     dateformatter.remove();
commit:dded5d5
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * This method will convert a given value to its specific type
1:    *
1:    * @param msrValue
1:    * @param dataType
1:    * @param carbonMeasure
1:    * @return
1:    */
0:   public static Object getConvertedMeasureValueBasedOnDataType(String msrValue, DataType dataType,
1:       CarbonMeasure carbonMeasure) {
1:     if (dataType == DataTypes.BOOLEAN) {
1:       return BooleanConvert.parseBoolean(msrValue);
0:     } else if (DataTypes.isDecimal(dataType)) {
1:       BigDecimal bigDecimal =
0:           new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:       return converter
0:           .convertToDecimal(normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision()));
1:     } else if (dataType == DataTypes.SHORT) {
0:       return Short.parseShort(msrValue);
0:     } else if (dataType == DataTypes.INT) {
0:       return Integer.parseInt(msrValue);
0:     } else if (dataType == DataTypes.LONG) {
0:       return Long.valueOf(msrValue);
1:     } else {
0:       Double parsedValue = Double.valueOf(msrValue);
0:       if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
1:         return null;
1:       }
0:       return parsedValue;
1:     }
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   public static Object getDataDataTypeForNoDictionaryColumn(String dimensionValue,
1:       DataType actualDataType, String dateFormat) {
1:     if (actualDataType == DataTypes.BOOLEAN) {
1:       return BooleanConvert.parseBoolean(dimensionValue);
0:     } else if (actualDataType == DataTypes.STRING) {
1:       return converter.convertFromStringToUTF8String(dimensionValue);
1:     } else if (actualDataType == DataTypes.SHORT) {
1:       return Short.parseShort(dimensionValue);
1:     } else if (actualDataType == DataTypes.INT) {
1:       return Integer.parseInt(dimensionValue);
1:     } else if (actualDataType == DataTypes.LONG) {
1:       return Long.parseLong(dimensionValue);
1:     } else if (actualDataType == DataTypes.TIMESTAMP) {
1:       Date dateToStr = null;
1:       DateFormat dateFormatter = null;
1:       try {
1:         if (null != dateFormat && !dateFormat.trim().isEmpty()) {
1:           dateFormatter = new SimpleDateFormat(dateFormat);
1:         } else {
1:           dateFormatter = timeStampformatter.get();
1:         }
1:         dateToStr = dateFormatter.parse(dimensionValue);
1:         return dateToStr.getTime();
1:       } catch (ParseException e) {
1:         throw new NumberFormatException(e.getMessage());
1:       }
1:     } else {
1:       return converter.convertFromStringToUTF8String(dimensionValue);
1:     }
1:   }
1: 
1:   public static byte[] getBytesDataDataTypeForNoDictionaryColumn(Object dimensionValue,
0:       DataType actualDataType) {
1:     if (dimensionValue == null) {
0:       if (actualDataType == DataTypes.STRING) {
1:         return CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY;
1:       } else {
1:         return new byte[0];
1:       }
1:     }
1:     if (actualDataType == DataTypes.BOOLEAN) {
1:       return ByteUtil.toBytes((Boolean) dimensionValue);
0:     } else if (actualDataType == DataTypes.STRING) {
1:       return ByteUtil.toBytes(dimensionValue.toString());
1:     } else if (actualDataType == DataTypes.SHORT) {
0:       return ByteUtil.toBytes((Short) dimensionValue);
1:     } else if (actualDataType == DataTypes.INT) {
0:       return ByteUtil.toBytes((Integer) dimensionValue);
1:     } else if (actualDataType == DataTypes.LONG) {
0:       return ByteUtil.toBytes((Long) dimensionValue);
1:     } else if (actualDataType == DataTypes.TIMESTAMP) {
0:       return ByteUtil.toBytes((Long)dimensionValue);
1:     } else {
1:       return ByteUtil.toBytes(dimensionValue.toString());
1:     }
1:   }
1: 
commit:8b3fa7f
/////////////////////////////////////////////////////////////////////////
0:         return Short.parseShort(msrValue);
0:         return Integer.parseInt(msrValue);
commit:72cb415
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Below method will be used to convert the data passed to its actual data
1:    * type
1:    *
0:    * @param dataInBytes    data
1:    * @param actualDataType actual data type
1:    * @return actual data after conversion
1:    */
0:   public static Object getDataBasedOnDataType(byte[] dataInBytes, DataType actualDataType) {
1:     if (null == dataInBytes || Arrays
1:         .equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY, dataInBytes)) {
1:       return null;
1:     }
1:     try {
0:       switch (actualDataType) {
0:         case INT:
0:           String data1 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data1.isEmpty()) {
1:             return null;
1:           }
0:           return Integer.parseInt(data1);
0:         case SHORT:
0:           String data2 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data2.isEmpty()) {
1:             return null;
1:           }
0:           return Short.parseShort(data2);
0:         case DOUBLE:
0:           String data3 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data3.isEmpty()) {
1:             return null;
1:           }
0:           return Double.parseDouble(data3);
0:         case LONG:
0:           String data4 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data4.isEmpty()) {
1:             return null;
1:           }
0:           return Long.parseLong(data4);
0:         case DATE:
0:           String data5 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data5.isEmpty()) {
1:             return null;
1:           }
1:           try {
0:             Date dateToStr = dateformatter.get().parse(data5);
0:             return dateToStr.getTime() * 1000;
0:           } catch (ParseException e) {
0:             LOGGER.error("Cannot convert" + data5 + " to Time/Long type value" + e.getMessage());
1:             return null;
1:           }
1: 
0:         case TIMESTAMP:
0:           String data6 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data6.isEmpty()) {
1:             return null;
1:           }
1:           try {
0:             Date dateToStr = timeStampformatter.get().parse(data6);
0:             return dateToStr.getTime() * 1000;
0:           } catch (ParseException e) {
0:             LOGGER.error("Cannot convert" + data6 + " to Time/Long type value" + e.getMessage());
1:             return null;
1:           }
0:         case DECIMAL:
0:           String data7 = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:           if (data7.isEmpty()) {
1:             return null;
1:           }
0:           java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data7);
0:           return org.apache.spark.sql.types.Decimal.apply(javaDecVal);
0:         default:
0:           return UTF8String.fromBytes(dataInBytes);
1:       }
1:     } catch (NumberFormatException ex) {
1:       String data = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
1:       LOGGER.error("Problem while converting data type" + data);
1:       return null;
1:     }
1:   }
1: 
commit:cd6a4ff
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: 
1: package org.apache.carbondata.core.util;
1: 
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
1: import java.math.RoundingMode;
1: import java.text.ParseException;
1: import java.text.SimpleDateFormat;
1: import java.util.Date;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.carbon.metadata.datatype.DataType;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
0: import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonMeasure;
1: import org.apache.carbondata.core.constants.CarbonCommonConstants;
1: 
0: import org.apache.commons.lang.NumberUtils;
0: import org.apache.spark.unsafe.types.UTF8String;
1: 
1: public final class DataTypeUtil {
1: 
1:   /**
1:    * LOGGER
1:    */
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(DataTypeUtil.class.getName());
1: 
1:   /**
1:    * This method will convert a given value to its specific type
1:    *
1:    * @param msrValue
1:    * @param dataType
1:    * @param carbonMeasure
1:    * @return
1:    */
1:   public static Object getMeasureValueBasedOnDataType(String msrValue, DataType dataType,
0:       CarbonMeasure carbonMeasure) {
0:     switch (dataType) {
0:       case DECIMAL:
0:         BigDecimal bigDecimal =
0:             new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:         return normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision());
0:       case INT:
0:         return Double.valueOf(msrValue).longValue();
0:       case LONG:
0:         return Long.valueOf(msrValue);
0:       default:
0:         return Double.valueOf(msrValue);
1:     }
1:   }
1: 
1:   /**
1:    * This method will check the digits before dot with the max precision allowed
1:    *
1:    * @param bigDecimal
1:    * @param allowedPrecision precision configured by the user
1:    * @return
1:    */
1:   private static BigDecimal normalizeDecimalValue(BigDecimal bigDecimal, int allowedPrecision) {
1:     if (bigDecimal.precision() > allowedPrecision) {
1:       return null;
1:     }
1:     return bigDecimal;
1:   }
1: 
1:   /**
0:    * This method will return the type of measure based on its data type
1:    *
1:    * @param dataType
1:    * @return
1:    */
0:   public static char getAggType(DataType dataType) {
0:     switch (dataType) {
0:       case DECIMAL:
0:         return CarbonCommonConstants.BIG_DECIMAL_MEASURE;
0:       case INT:
0:       case LONG:
0:         return CarbonCommonConstants.BIG_INT_MEASURE;
0:       default:
0:         return CarbonCommonConstants.SUM_COUNT_VALUE_MEASURE;
1:     }
1:   }
1: 
1:   /**
1:    * This method will convert a big decimal value to bytes
1:    *
1:    * @param num
1:    * @return
1:    */
1:   public static byte[] bigDecimalToByte(BigDecimal num) {
1:     BigInteger sig = new BigInteger(num.unscaledValue().toString());
1:     int scale = num.scale();
0:     byte[] bscale = new byte[] { (byte) (scale) };
1:     byte[] buff = sig.toByteArray();
1:     byte[] completeArr = new byte[buff.length + bscale.length];
1:     System.arraycopy(bscale, 0, completeArr, 0, bscale.length);
1:     System.arraycopy(buff, 0, completeArr, bscale.length, buff.length);
1:     return completeArr;
1:   }
1: 
1:   /**
1:    * This method will convert a byte value back to big decimal value
1:    *
1:    * @param raw
1:    * @return
1:    */
1:   public static BigDecimal byteToBigDecimal(byte[] raw) {
1:     int scale = (raw[0] & 0xFF);
1:     byte[] unscale = new byte[raw.length - 1];
1:     System.arraycopy(raw, 1, unscale, 0, unscale.length);
1:     BigInteger sig = new BigInteger(unscale);
1:     return new BigDecimal(sig, scale);
1:   }
1: 
1:   /**
0:    * returns the SqlStatement.Type of corresponding string value
1:    *
0:    * @param dataTypeStr
0:    * @return return the SqlStatement.Type
1:    */
0:   public static DataType getDataType(String dataTypeStr) {
0:     DataType dataType = null;
0:     switch (dataTypeStr) {
0:       case "TIMESTAMP":
0:         dataType = DataType.TIMESTAMP;
0:         break;
0:       case "STRING":
0:         dataType = DataType.STRING;
0:         break;
0:       case "INT":
0:         dataType = DataType.INT;
0:         break;
0:       case "SHORT":
0:         dataType = DataType.SHORT;
0:         break;
0:       case "LONG":
0:         dataType = DataType.LONG;
0:         break;
0:       case "DOUBLE":
0:         dataType = DataType.DOUBLE;
0:         break;
0:       case "DECIMAL":
0:         dataType = DataType.DECIMAL;
0:         break;
0:       case "ARRAY":
0:         dataType = DataType.ARRAY;
0:         break;
0:       case "STRUCT":
0:         dataType = DataType.STRUCT;
0:         break;
0:       case "MAP":
0:       default:
0:         dataType = DataType.STRING;
1:     }
0:     return dataType;
1:   }
1: 
1:   /**
0:    * Below method will be used to basically to know whether the input data is valid string of
0:    * giving data type. If there is any non parseable string is present return false.
1:    */
0:   public static boolean isValidData(String data, DataType actualDataType) {
1:     if (null == data) {
0:       return false;
1:     }
1:     try {
0:       switch (actualDataType) {
0:         case SHORT:
0:         case INT:
0:         case LONG:
0:         case DOUBLE:
0:         case DECIMAL:
0:           return NumberUtils.isNumber(data);
0:         case TIMESTAMP:
1:           if (data.isEmpty()) {
0:             return false;
1:           }
0:           SimpleDateFormat parser = new SimpleDateFormat(CarbonProperties.getInstance()
1:               .getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:                   CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT));
1:           try {
0:             parser.parse(data);
0:             return true;
0:           } catch (ParseException e) {
0:             return false;
1:           }
0:         default:
0:           return true;
1:       }
1:     } catch (NumberFormatException ex) {
0:       return false;
1:     }
1:   }
1: 
1:   /**
1:    * Below method will be used to convert the data passed to its actual data
1:    * type
1:    *
1:    * @param data           data
1:    * @param actualDataType actual data type
1:    * @return actual data after conversion
1:    */
1:   public static Object getDataBasedOnDataType(String data, DataType actualDataType) {
1: 
1:     if (null == data || CarbonCommonConstants.MEMBER_DEFAULT_VAL.equals(data)) {
1:       return null;
1:     }
1:     try {
0:       switch (actualDataType) {
0:         case INT:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           return Integer.parseInt(data);
0:         case SHORT:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           return Short.parseShort(data);
0:         case DOUBLE:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           return Double.parseDouble(data);
0:         case LONG:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           return Long.parseLong(data);
0:         case TIMESTAMP:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           SimpleDateFormat parser = new SimpleDateFormat(CarbonProperties.getInstance()
1:               .getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:                   CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT));
0:           Date dateToStr = null;
1:           try {
0:             dateToStr = parser.parse(data);
0:             return dateToStr.getTime() * 1000;
0:           } catch (ParseException e) {
0:             LOGGER.error("Cannot convert" + data + " to Time/Long type value" + e.getMessage());
1:             return null;
1:           }
0:         case DECIMAL:
1:           if (data.isEmpty()) {
1:             return null;
1:           }
0:           java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data);
0:           scala.math.BigDecimal scalaDecVal = new scala.math.BigDecimal(javaDecVal);
0:           org.apache.spark.sql.types.Decimal decConverter =
0:               new org.apache.spark.sql.types.Decimal();
0:           return decConverter.set(scalaDecVal);
0:         default:
0:           return UTF8String.fromString(data);
1:       }
1:     } catch (NumberFormatException ex) {
1:       LOGGER.error("Problem while converting data type" + data);
1:       return null;
1:     }
1: 
1:   }
1: 
0:   public static Object getMeasureDataBasedOnDataType(Object data, DataType dataType) {
1: 
1:     if (null == data) {
1:       return null;
1:     }
1:     try {
0:       switch (dataType) {
0:         case DOUBLE:
0:           return data;
0:         case LONG:
0:           return data;
0:         case DECIMAL:
0:           java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data.toString());
0:           scala.math.BigDecimal scalaDecVal = new scala.math.BigDecimal(javaDecVal);
0:           org.apache.spark.sql.types.Decimal decConverter =
0:               new org.apache.spark.sql.types.Decimal();
0:           return decConverter.set(scalaDecVal);
0:         default:
0:           return data;
1:       }
1:     } catch (NumberFormatException ex) {
1:       LOGGER.error("Problem while converting data type" + data);
1:       return null;
1:     }
1: 
1:   }
1: 
1:   /**
1:    * Below method will be used to basically to know whether any non parseable
1:    * data is present or not. if present then return null so that system can
1:    * process to default null member value.
1:    *
1:    * @param data           data
1:    * @param actualDataType actual data type
1:    * @return actual data after conversion
1:    */
1:   public static Object normalizeIntAndLongValues(String data, DataType actualDataType) {
1:     if (null == data) {
1:       return null;
1:     }
1:     try {
1:       Object parsedValue = null;
0:       switch (actualDataType) {
0:         case INT:
0:           parsedValue = Integer.parseInt(data);
0:           break;
0:         case LONG:
0:           parsedValue = Long.parseLong(data);
0:           break;
0:         default:
0:           return data;
1:       }
0:       if(null != parsedValue) {
0:         return data;
1:       }
1:       return null;
1:     } catch (NumberFormatException ex) {
1:       return null;
1:     }
1:   }
1: 
1:   /**
1:    * This method will parse a given string value corresponding to its data type
1:    *
1:    * @param value     value to parse
1:    * @param dimension dimension to get data type and precision and scale in case of decimal
1:    *                  data type
1:    * @return
1:    */
1:   public static String normalizeColumnValueForItsDataType(String value, CarbonDimension dimension) {
1:     try {
1:       Object parsedValue = null;
1:       // validation will not be done for timestamp datatype as for timestamp direct dictionary
1:       // is generated. No dictionary file is created for timestamp datatype column
0:       switch (dimension.getDataType()) {
0:         case DECIMAL:
0:           return parseStringToBigDecimal(value, dimension);
0:         case INT:
0:         case LONG:
0:           parsedValue = normalizeIntAndLongValues(value, dimension.getDataType());
0:           break;
0:         case DOUBLE:
0:           parsedValue = Double.parseDouble(value);
0:           break;
0:         default:
1:           return value;
1:       }
1:       if (null != parsedValue) {
1:         return value;
1:       }
1:       return null;
1:     } catch (Exception e) {
1:       return null;
1:     }
1:   }
1: 
1:   /**
1:    * This method will parse a value to its datatype if datatype is decimal else will return
1:    * the value passed
1:    *
1:    * @param value     value to be parsed
1:    * @param dimension
1:    * @return
1:    */
1:   public static String parseValue(String value, CarbonDimension dimension) {
1:     try {
0:       switch (dimension.getDataType()) {
0:         case DECIMAL:
0:           return parseStringToBigDecimal(value, dimension);
0:         default:
1:           return value;
1:       }
1:     } catch (Exception e) {
1:       return null;
1:     }
1:   }
1: 
1:   private static String parseStringToBigDecimal(String value, CarbonDimension dimension) {
1:     BigDecimal bigDecimal = new BigDecimal(value)
1:         .setScale(dimension.getColumnSchema().getScale(), RoundingMode.HALF_UP);
1:     BigDecimal normalizedValue =
1:         normalizeDecimalValue(bigDecimal, dimension.getColumnSchema().getPrecision());
1:     if (null != normalizedValue) {
1:       return normalizedValue.toString();
1:     }
1:     return null;
1:   }
1: }
author:manishgupta88
-------------------------------------------------------------------------------
commit:1f54c47
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Method to type case the data based on modified data type. This method will used for
1:    * retrieving the data after change in data type restructure operation
1:    *
1:    * @param data
1:    * @param restructuredDataType
1:    * @param currentDataOffset
1:    * @param length
1:    * @return
1:    */
1:   public static long getDataBasedOnRestructuredDataType(byte[] data, DataType restructuredDataType,
1:       int currentDataOffset, int length) {
1:     long value = 0L;
1:     if (restructuredDataType == DataTypes.INT) {
0:       value = ByteUtil.toInt(data, currentDataOffset, length);
1:     } else if (restructuredDataType == DataTypes.LONG) {
0:       value = ByteUtil.toLong(data, currentDataOffset, length);
1:     }
1:     return value;
1:   }
1: 
1: }
commit:a86c54b
/////////////////////////////////////////////////////////////////////////
1:         // for non string type no dictionary column empty byte array is empty value
1:         // so no need to parse
1:         if (isEmptyByteArray(dataInBytes)) {
0:           return null;
0:         }
1:         if (isEmptyByteArray(dataInBytes)) {
0:           return null;
0:         }
1:         if (isEmptyByteArray(dataInBytes)) {
0:           return null;
0:         }
1:         if (isEmptyByteArray(dataInBytes)) {
0:           return null;
0:         }
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Method to check if byte array is empty
1:    *
1:    * @param dataInBytes
1:    * @return
1:    */
1:   private static boolean isEmptyByteArray(byte[] dataInBytes) {
1:     return dataInBytes.length == 0;
0:   }
1: 
commit:6b3b16c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    * @param dimension
1:   public static Object getDataBasedOnDataType(byte[] dataInBytes, CarbonDimension dimension) {
0:       switch (dimension.getDataType()) {
/////////////////////////////////////////////////////////////////////////
0:           if (dimension.getColumnSchema().getScale() > javaDecVal.scale()) {
0:             javaDecVal =
0:                 javaDecVal.setScale(dimension.getColumnSchema().getScale());
0:           }
commit:70256e7
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryGenerator;
1: import org.apache.carbondata.core.keygenerator.directdictionary.DirectDictionaryKeyGeneratorFactory;
1: import org.apache.carbondata.core.metadata.schema.table.column.ColumnSchema;
/////////////////////////////////////////////////////////////////////////
1:     @Override protected DateFormat initialValue() {
1:       return new SimpleDateFormat(CarbonProperties.getInstance()
0:           .getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
1:     @Override protected DateFormat initialValue() {
1:       return new SimpleDateFormat(CarbonProperties.getInstance()
1:           .getProperty(CarbonCommonConstants.CARBON_DATE_FORMAT,
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:    * This method will convert the data according to its data type and perform a
0:    * special handling for decimal data types
1:    *
0:    * @param dataInBytes
0:    * @param dimension
1:    * @return
1:    */
0:   public static Object getDataBasedOnDataType(byte[] dataInBytes, CarbonDimension dimension) {
0:     if (null == dataInBytes || Arrays
0:         .equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL_ARRAY, dataInBytes)) {
0:       return null;
0:     }
0:     switch (dimension.getDataType()) {
0:       case DECIMAL:
0:         String data = new String(dataInBytes, CarbonCommonConstants.DEFAULT_CHARSET_CLASS);
0:         if (data.isEmpty()) {
0:           return null;
0:         }
0:         java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data);
0:         if (dimension.getColumnSchema().getScale() > javaDecVal.scale()) {
0:           javaDecVal =
0:               javaDecVal.setScale(dimension.getColumnSchema().getScale(), RoundingMode.HALF_UP);
0:         }
0:         return org.apache.spark.sql.types.Decimal.apply(javaDecVal);
0:       default:
0:         return getDataBasedOnDataType(dataInBytes, dimension.getDataType());
0:     }
0:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * Below method will be used to convert the data into byte[]
1:    *
1:    * @param data
0:    * @param actualDataType actual data type
1:    * @return actual data in byte[]
1:    */
0:   public static byte[] convertDataToBytesBasedOnDataType(String data, DataType actualDataType) {
0:     if (null == data) {
0:       return null;
1:     } else if (CarbonCommonConstants.MEMBER_DEFAULT_VAL.equals(data)) {
1:       LOGGER.error("Default value should not be carbon specific null value : " + data);
0:       return null;
0:     }
0:     try {
1:       long parsedIntVal = 0;
0:       switch (actualDataType) {
0:         case INT:
0:           parsedIntVal = (long) Integer.parseInt(data);
0:           return String.valueOf(parsedIntVal)
1:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:         case SHORT:
0:           parsedIntVal = (long) Short.parseShort(data);
0:           return String.valueOf(parsedIntVal)
1:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:         case DOUBLE:
0:           return String.valueOf(Double.parseDouble(data))
1:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:         case LONG:
0:           return String.valueOf(Long.parseLong(data))
1:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:         case DATE:
0:         case TIMESTAMP:
0:           DirectDictionaryGenerator directDictionaryGenerator =
0:               DirectDictionaryKeyGeneratorFactory.getDirectDictionaryGenerator(actualDataType);
0:           int value = directDictionaryGenerator.generateDirectSurrogateKey(data);
0:           return String.valueOf(value)
1:               .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:         case DECIMAL:
0:           java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data);
0:           return bigDecimalToByte(javaDecVal);
0:         default:
0:           return UTF8String.fromString(data).getBytes();
0:       }
0:     } catch (NumberFormatException ex) {
0:       LOGGER.error("Problem while converting data type" + data);
0:       return null;
0:     }
0:   }
1: 
1:   /**
1:    * This method will parse a given string value corresponding to its data type
1:    *
0:    * @param value     value to parse
1:    * @param columnSchema dimension to get data type and precision and scale in case of decimal
0:    *                  data type
0:    * @return
1:    */
1:   public static String normalizeColumnValueForItsDataType(String value, ColumnSchema columnSchema) {
0:     try {
0:       Object parsedValue = null;
0:       switch (columnSchema.getDataType()) {
0:         case DECIMAL:
0:           return parseStringToBigDecimal(value, columnSchema);
0:         case SHORT:
0:         case INT:
0:         case LONG:
0:           parsedValue = normalizeIntAndLongValues(value, columnSchema.getDataType());
0:           break;
0:         case DOUBLE:
0:           parsedValue = Double.parseDouble(value);
0:           break;
0:         default:
0:           return value;
0:       }
0:       if (null != parsedValue) {
0:         return value;
0:       }
0:       return null;
0:     } catch (Exception e) {
0:       return null;
0:     }
0:   }
1: 
1:   private static String parseStringToBigDecimal(String value, ColumnSchema columnSchema) {
0:     BigDecimal bigDecimal = new BigDecimal(value)
0:         .setScale(columnSchema.getScale(), RoundingMode.HALF_UP);
0:     BigDecimal normalizedValue =
0:         normalizeDecimalValue(bigDecimal, columnSchema.getPrecision());
1:     if (null != normalizedValue) {
1:       return normalizedValue.toString();
0:     }
0:     return null;
0:   }
commit:0f73016
/////////////////////////////////////////////////////////////////////////
0:         Double parsedValue = Double.valueOf(msrValue);
0:         if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
0:           return null;
0:         }
0:         return parsedValue;
author:akashrn5
-------------------------------------------------------------------------------
commit:03ddcc8
/////////////////////////////////////////////////////////////////////////
1:   /**
0:    * @param name datatype string extracted from the json data
0:    * @return returns the datatype based on the input string from json to deserialize the tableInfo
1:    */
1:   public static DataType valueOf(String name) {
1:     if (DataTypes.STRING.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.STRING;
1:     } else if (DataTypes.DATE.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.DATE;
1:     } else if (DataTypes.TIMESTAMP.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.TIMESTAMP;
1:     } else if (DataTypes.BOOLEAN.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.BOOLEAN;
1:     } else if (DataTypes.BYTE.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.BYTE;
1:     } else if (DataTypes.SHORT.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.SHORT;
1:     } else if (DataTypes.SHORT_INT.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.SHORT_INT;
1:     } else if (DataTypes.INT.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.INT;
1:     } else if (DataTypes.LONG.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.LONG;
1:     } else if (DataTypes.LEGACY_LONG.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.LEGACY_LONG;
1:     } else if (DataTypes.FLOAT.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.FLOAT;
1:     } else if (DataTypes.DOUBLE.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.DOUBLE;
1:     } else if (DataTypes.NULL.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.NULL;
1:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.BYTE_ARRAY;
1:     } else if (DataTypes.BYTE_ARRAY.getName().equalsIgnoreCase(name)) {
1:       return DataTypes.BYTE_ARRAY;
0:     } else {
1:       throw new RuntimeException("create DataType with invalid name: " + name);
0:     }
0:   }
0: 
commit:85dc4ff
/////////////////////////////////////////////////////////////////////////
1:         if (null != dateFormat && !dateFormat.trim().isEmpty()) {
author:xubo245
-------------------------------------------------------------------------------
commit:c252897
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6abdd97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.encoding.bool.BooleanConvert;
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
0:       return BooleanConvert.parseBoolean(msrValue);
0:     } else if (dataType == DataTypes.DECIMAL) {
/////////////////////////////////////////////////////////////////////////
1:     if (dataType == DataTypes.BOOLEAN) {
1:       return BooleanConvert.byte2Boolean(bb.get());
1:     } else if (dataType == DataTypes.SHORT) {
/////////////////////////////////////////////////////////////////////////
0:     if (dataType == DataTypes.BOOLEAN) {
1:       return measurePage.getBoolean(index);
0:     } else if (dataType == DataTypes.SHORT) {
/////////////////////////////////////////////////////////////////////////
0:       case "BOOLEAN":
0:         dataType = DataTypes.BOOLEAN;
0:         break;
/////////////////////////////////////////////////////////////////////////
1:       if (actualDataType == DataTypes.BOOLEAN) {
0:         if (data.isEmpty()) {
0:           return null;
0:         }
1:         return BooleanConvert.parseBoolean(data);
1:       } else if (actualDataType == DataTypes.INT) {
/////////////////////////////////////////////////////////////////////////
1:     if (actualDataType == DataTypes.BOOLEAN) {
1:       return ByteUtil.toBytes(BooleanConvert.parseBoolean(dimensionValue));
0:     } else if (actualDataType == DataTypes.STRING) {
/////////////////////////////////////////////////////////////////////////
1:       if (actualDataType == DataTypes.BOOLEAN) {
0:         return ByteUtil.toBoolean(dataInBytes);
0:       } else if (actualDataType == DataTypes.STRING) {
author:dhatchayani
-------------------------------------------------------------------------------
commit:36ceb59
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.encoder.Encoding;
/////////////////////////////////////////////////////////////////////////
1:       DateFormat dateFormat = new SimpleDateFormat(CarbonProperties.getInstance()
1:       dateFormat.setLenient(false);
1:       return dateFormat;
/////////////////////////////////////////////////////////////////////////
1:       DataType actualDataType, String dateFormat) {
/////////////////////////////////////////////////////////////////////////
0:       case TIMESTAMP:
0:         Date dateToStr = null;
0:         DateFormat dateFormatter = null;
0:         try {
0:           if (null != dateFormat) {
0:             dateFormatter = new SimpleDateFormat(dateFormat);
0:           } else {
0:             dateFormatter = timeStampformatter.get();
0:           }
0:           dateToStr = dateFormatter.parse(dimensionValue);
0:           return ByteUtil.toBytes(dateToStr.getTime());
0:         } catch (ParseException e) {
0:           throw new NumberFormatException(e.getMessage());
0:         }
/////////////////////////////////////////////////////////////////////////
0:         case TIMESTAMP:
0:           return ByteUtil.toLong(dataInBytes, 0, dataInBytes.length) * 1000L;
/////////////////////////////////////////////////////////////////////////
0:         case TIMESTAMP:
0:           if (columnSchema.hasEncoding(Encoding.DIRECT_DICTIONARY)) {
0:             DirectDictionaryGenerator directDictionaryGenerator1 =
0:                 DirectDictionaryKeyGeneratorFactory
0:                     .getDirectDictionaryGenerator(columnSchema.getDataType());
0:             int value1 = directDictionaryGenerator1.generateDirectSurrogateKey(data);
0:             return String.valueOf(value1)
0:                 .getBytes(Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));
0:           } else {
0:             try {
0:               Date dateToStr = timeStampformatter.get().parse(data);
0:               return ByteUtil.toBytes(dateToStr.getTime());
0:             } catch (ParseException e) {
0:               LOGGER.error(
0:                   "Cannot convert value to Time/Long type value. Value is considered as null" + e
0:                       .getMessage());
0:               return null;
0:             }
0:           }
author:sraghunandan
-------------------------------------------------------------------------------
commit:500654e
/////////////////////////////////////////////////////////////////////////
0:         if (null != bigDecimalMsrValue) {
0:           return normalizeDecimalValue(bigDecimalMsrValue, carbonMeasure.getPrecision());
0:         } else {
0:           return bigDecimalMsrValue;
0:         }
author:Ravindra Pesala
-------------------------------------------------------------------------------
commit:4e83509
/////////////////////////////////////////////////////////////////////////
1:     if (data == null || data.length == 0) {
0:       return null;
0:     }
0:         return (short)bb.getLong();
0:         return (int)bb.getLong();
/////////////////////////////////////////////////////////////////////////
0:         return (short)measurePage.getLong(index);
0:         return (int)measurePage.getLong(index);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return getDataBasedOnDataType(data, actualDataType, getDataTypeConverter());
0:   }
0: 
0:   /**
0:    * Below method will be used to convert the data passed to its actual data
0:    * type
0:    *
1:    * @param data           data
0:    * @param actualDataType actual data type
0:    * @return actual data after conversion
0:    */
1:   public static Object getDataBasedOnDataType(String data, DataType actualDataType,
1:       DataTypeConverter converter) {
/////////////////////////////////////////////////////////////////////////
0:           return converter.convertToDecimal(data);
0:           return converter.convertFromStringToUTF8String(data);
author:sounakr
-------------------------------------------------------------------------------
commit:266c473
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.page.ColumnPage;
/////////////////////////////////////////////////////////////////////////
1:   public static Object getMeasureObjectFromDataType(byte[] data, DataType dataType) {
1:     ByteBuffer bb = ByteBuffer.wrap(data);
0:     switch (dataType) {
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:         return bb.getLong();
0:       case DECIMAL:
0:         return byteToBigDecimal(data);
0:       default:
0:         return bb.getDouble();
0:     }
0:   }
0: 
0:   /**
0:    * This method will convert a given ByteArray to its specific type
0:    *
0:    * @param msrValue
0:    * @param dataType
0:    * @param carbonMeasure
0:    * @return
0:    */
0:   //  public static byte[] getMeasureByteArrayBasedOnDataType(String msrValue, DataType dataType,
0:   //      CarbonMeasure carbonMeasure) {
0:   //    switch (dataType) {
0:   //      case DECIMAL:
0:   //        BigDecimal bigDecimal =
0:   //            new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:   //       return ByteUtil.toBytes(normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision()));
0:   //      case SHORT:
0:   //        return ByteUtil.toBytes((Short.parseShort(msrValue)));
0:   //      case INT:
0:   //        return ByteUtil.toBytes(Integer.parseInt(msrValue));
0:   //      case LONG:
0:   //        return ByteUtil.toBytes(Long.valueOf(msrValue));
0:   //      default:
0:   //        Double parsedValue = Double.valueOf(msrValue);
0:   //        if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
0:   //          return null;
0:   //        }
0:   //        return ByteUtil.toBytes(parsedValue);
0:   //    }
0:   //  }
0:   public static byte[] getMeasureByteArrayBasedOnDataTypes(String msrValue, DataType dataType,
0:       CarbonMeasure carbonMeasure) {
0:     ByteBuffer b;
0:     switch (dataType) {
0:       case BYTE:
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:         b = ByteBuffer.allocate(8);
0:         b.putLong(Long.valueOf(msrValue));
0:         b.flip();
0:         return b.array();
0:       case DOUBLE:
0:         b = ByteBuffer.allocate(8);
0:         b.putDouble(Double.valueOf(msrValue));
0:         b.flip();
0:         return b.array();
0:       case DECIMAL:
0:         BigDecimal bigDecimal =
0:             new BigDecimal(msrValue).setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:         return DataTypeUtil
0:             .bigDecimalToByte(normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision()));
0:       default:
0:         throw new IllegalArgumentException("Invalid data type: " + dataType);
0:     }
0:   }
0: 
0:   /**
0:    * This method will convert a given ByteArray to its specific type
0:    *
0:    * @param msrValue
0:    * @param dataType
0:    * @param carbonMeasure
0:    * @return
0:    */
0:   public static byte[] getMeasureByteArrayBasedOnDataType(ColumnPage measurePage, int index,
1:       DataType dataType, CarbonMeasure carbonMeasure) {
0:     switch (dataType) {
0:       case DECIMAL:
0:         BigDecimal bigDecimal = new BigDecimal(measurePage.getDouble(index))
0:             .setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:         return ByteUtil.toBytes(normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision()));
0:       case SHORT:
0:         return ByteUtil.toBytes(measurePage.getShort(index));
0:       case INT:
0:         return ByteUtil.toBytes(measurePage.getInt(index));
0:       case LONG:
0:         return ByteUtil.toBytes(measurePage.getLong(index));
0:       default:
0:         Double parsedValue = Double.valueOf(measurePage.getDouble(index));
0:         if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
0:           return null;
0:         }
0:         return ByteUtil.toBytes(parsedValue);
0:     }
0:   }
0: 
1:   public static Object getMeasureObjectBasedOnDataType(ColumnPage measurePage, int index,
1:       DataType dataType, CarbonMeasure carbonMeasure) {
0:     //    switch (dataType) {
0:     //      case DECIMAL:
0:     //        BigDecimal bigDecimal = new BigDecimal(measurePage.getDouble(index))
0:     //            .setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:     //        return normalizeDecimalValue(bigDecimal, carbonMeasure.getPrecision());
0:     //      case SHORT:
0:     //      case INT:
0:     //      case LONG:
0:     //        return measurePage.getLong(index);
0:     //      default:
0:     //        Double parsedValue = Double.valueOf(measurePage.getDouble(index));
0:     //        if (Double.isInfinite(parsedValue) || Double.isNaN(parsedValue)) {
0:     //          return null;
0:     //        }
0:     //        return parsedValue;
0:     //    }
0:     switch (dataType) {
0:       case SHORT:
0:       case INT:
0:       case LONG:
0:         return measurePage.getLong(index);
0:       case DECIMAL:
0:         BigDecimal bigDecimalMsrValue = measurePage.getDecimal(index);
0:         if (null != bigDecimalMsrValue && carbonMeasure.getScale() > bigDecimalMsrValue.scale()) {
0:           bigDecimalMsrValue =
0:               bigDecimalMsrValue.setScale(carbonMeasure.getScale(), RoundingMode.HALF_UP);
0:         }
0:         //return org.apache.spark.sql.types.Decimal.apply(bigDecimalMsrValue);
0:         return normalizeDecimalValue(bigDecimalMsrValue, carbonMeasure.getPrecision());
0:       default:
0:         return measurePage.getDouble(index);
0:     }
0:   }
0: 
0: 
author:chenliang613
-------------------------------------------------------------------------------
commit:09f7cdd
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:    * DataType converter for different computing engines
0:    */
1:   private static DataTypeConverter converter;
0: 
0:   /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           return getDataTypeConverter().convertToDecimal(data);
0:           return getDataTypeConverter().convertFromStringToUTF8String(data);
/////////////////////////////////////////////////////////////////////////
0:           return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
/////////////////////////////////////////////////////////////////////////
0:           return getDataTypeConverter().convertToDecimal(javaDecVal);
0:           return getDataTypeConverter().convertFromByteToUTF8String(dataInBytes);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           return getDataTypeConverter().convertFromStringToByte(data);
/////////////////////////////////////////////////////////////////////////
0: 
0:   /**
1:    * set the data type converter as per computing engine
1:    * @param converterLocal
0:    */
1:   public static void setDataTypeConverter(DataTypeConverter converterLocal) {
0:     converter = converterLocal;
0:   }
0: 
1:   public static DataTypeConverter getDataTypeConverter() {
1:     if (converter == null) {
1:       converter = new DataTypeConverterImpl();
0:     }
1:     return converter;
0:   }
0: 
author:jackylk
-------------------------------------------------------------------------------
commit:bc3e684
/////////////////////////////////////////////////////////////////////////
commit:98df130
/////////////////////////////////////////////////////////////////////////
commit:8cca0af
/////////////////////////////////////////////////////////////////////////
0:         return CarbonCommonConstants.DOUBLE_MEASURE;
0:   // bytes of 0 in BigDecimal
0:   public static final byte[] zeroBigDecimalBytes = bigDecimalToByte(BigDecimal.valueOf(0));
0: 
commit:ce09aaa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataType;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonDimension;
1: import org.apache.carbondata.core.metadata.schema.table.column.CarbonMeasure;
commit:eaadc88
/////////////////////////////////////////////////////////////////////////
1:     byte[] bscale = { (byte) (scale) };
commit:dc57aec
/////////////////////////////////////////////////////////////////////////
1: import java.text.DateFormat;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   private static final ThreadLocal<DateFormat> formatter = new ThreadLocal<DateFormat>() {
0:     @Override
0:     protected DateFormat initialValue() {
0:       return new SimpleDateFormat(
0:           CarbonProperties.getInstance().getProperty(CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT,
0:               CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT));
0:     }
1:   };
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Date dateToStr = formatter.get().parse(data);
author:chenerlu
-------------------------------------------------------------------------------
commit:ef77313
/////////////////////////////////////////////////////////////////////////
0:         case FLOAT:
0:           if (data.isEmpty()) {
0:             return null;
0:           }
0:           return Float.parseFloat(data);
author:mohammadshahidkhan
-------------------------------------------------------------------------------
commit:4a79a86
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("Cannot convert value to Time/Long type value" + e.getMessage());
author:kumarvishal
-------------------------------------------------------------------------------
commit:71fe32a
/////////////////////////////////////////////////////////////////////////
1:    * @param dataInBytes data
/////////////////////////////////////////////////////////////////////////
0:             javaDecVal = javaDecVal.setScale(dimension.getColumnSchema().getScale());
/////////////////////////////////////////////////////////////////////////
1:     if (null == value) {
0:       return null;
0:     }
/////////////////////////////////////////////////////////////////////////
1:    * @param value        value to parse
1:    *                     data type
/////////////////////////////////////////////////////////////////////////
0:     BigDecimal bigDecimal =
1:         new BigDecimal(value).setScale(columnSchema.getScale(), RoundingMode.HALF_UP);
1:     BigDecimal normalizedValue = normalizeDecimalValue(bigDecimal, columnSchema.getPrecision());
commit:f1f4581
/////////////////////////////////////////////////////////////////////////
0:         case INT:
0:           Integer.parseInt(value);
0:           break;
0:         case DOUBLE:
0:           Double.parseDouble(value);
0:           break;
0:         case LONG:
0:           Long.parseLong(value);
0:           break;
0:         case FLOAT:
0:           Float.parseFloat(value);
0:           break;
0:           // do nothing
1:     } catch (NumberFormatException e) {
0:     return value;
commit:ea04fce
/////////////////////////////////////////////////////////////////////////
1:   private static final ThreadLocal<DateFormat> timeStampformatter = new ThreadLocal<DateFormat>() {
/////////////////////////////////////////////////////////////////////////
1:   private static final ThreadLocal<DateFormat> dateformatter = new ThreadLocal<DateFormat>() {
0:     @Override
0:     protected DateFormat initialValue() {
0:       return new SimpleDateFormat(
0:           CarbonProperties.getInstance().getProperty(CarbonCommonConstants.CARBON_DATE_FORMAT,
1:               CarbonCommonConstants.CARBON_DATE_DEFAULT_FORMAT));
0:     }
1:   };
0: 
/////////////////////////////////////////////////////////////////////////
0:           if (data.isEmpty()) {
0:             return null;
0:           }
0:           try {
0:             Date dateToStr = dateformatter.get().parse(data);
0:             return dateToStr.getTime() * 1000;
0:           } catch (ParseException e) {
0:             LOGGER.error("Cannot convert" + data + " to Time/Long type value" + e.getMessage());
0:             return null;
0:           }
0: 
0:             Date dateToStr = timeStampformatter.get().parse(data);
author:ashok.blend
-------------------------------------------------------------------------------
commit:9e24a3d
/////////////////////////////////////////////////////////////////////////
1:    * This method will convert a byte value back to big decimal value
0:    *
1:    * @param raw
0:    * @return
0:    */
1:   public static BigDecimal byteToBigDecimal(byte[] raw, int offset, int length) {
1:     int scale = (raw[offset] & 0xFF);
1:     byte[] unscale = new byte[length - 1];
0:     System.arraycopy(raw, offset+1, unscale, 0, unscale.length);
1:     BigInteger sig = new BigInteger(unscale);
1:     return new BigDecimal(sig, scale);
0:   }
0:   /**
author:Anurag
-------------------------------------------------------------------------------
commit:e7ff938
/////////////////////////////////////////////////////////////////////////
0:         Short shortValue = Short.parseShort(msrValue);
0:         return shortValue.longValue();
0:         Integer intValue = Integer.parseInt(msrValue);
0:         return intValue.longValue();
/////////////////////////////////////////////////////////////////////////
0:         case SHORT:
0:           parsedValue = Short.parseShort(data);
0:           break;
/////////////////////////////////////////////////////////////////////////
0:         case SHORT:
/////////////////////////////////////////////////////////////////////////
0: }
author:sujith71955
-------------------------------------------------------------------------------
commit:b9db4ac
/////////////////////////////////////////////////////////////////////////
0:   /**
1:    * This method will compare double values it will preserve
1:    * the -0.0 and 0.0 equality as per == ,also preserve NaN equality check as per
1:    * java.lang.Double.equals()
0:    *
1:    * @param d1 double value for equality check
1:    * @param d2 double value for equality check
1:    * @return boolean after comparing two double values.
0:    */
1:   public static int compareDoubleWithNan(Double d1, Double d2) {
1:     if ((d1.doubleValue() == d2.doubleValue()) || (Double.isNaN(d1) && Double.isNaN(d2))) {
1:       return 0;
1:     } else if (d1 < d2) {
1:       return -1;
0:     }
1:     return 1;
0:   }
commit:274b8db
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:   private static final Map<String, String> dataTypeDisplayNames;
0: 
0:   static {
0:     dataTypeDisplayNames = new HashMap<String, String>(16);
0:     dataTypeDisplayNames.put(DataType.DATE.toString(), DataType.DATE.getName());
0:     dataTypeDisplayNames.put(DataType.LONG.toString(), DataType.LONG.getName());
0:     dataTypeDisplayNames.put(DataType.INT.toString(), DataType.INT.getName());
0:     dataTypeDisplayNames.put(DataType.FLOAT.toString(), DataType.FLOAT.getName());
0:     dataTypeDisplayNames.put(DataType.BOOLEAN.toString(), DataType.BOOLEAN.getName());
0:     dataTypeDisplayNames.put(DataType.NULL.toString(), DataType.NULL.getName());
0:     dataTypeDisplayNames.put(DataType.DECIMAL.toString(), DataType.DECIMAL.getName());
0:     dataTypeDisplayNames.put(DataType.ARRAY.toString(), DataType.ARRAY.getName());
0:     dataTypeDisplayNames.put(DataType.STRUCT.toString(), DataType.STRUCT.getName());
0:     dataTypeDisplayNames.put(DataType.TIMESTAMP.toString(), DataType.TIMESTAMP.getName());
0:     dataTypeDisplayNames.put(DataType.SHORT.toString(), DataType.SHORT.getName());
0:     dataTypeDisplayNames.put(DataType.STRING.toString(), DataType.STRING.getName());
0:   }
/////////////////////////////////////////////////////////////////////////
0:    * @param dataType
0:    * @return
0:    */
0:   public static String getColumnDataTypeDisplayName(String dataType) {
0:     return dataTypeDisplayNames.get(dataType);
0:   }
0: 
0:   /**
author:piaoyats
-------------------------------------------------------------------------------
commit:f853998
/////////////////////////////////////////////////////////////////////////
0:           return org.apache.spark.sql.types.Decimal.apply(javaDecVal);
/////////////////////////////////////////////////////////////////////////
0:           return org.apache.spark.sql.types.Decimal.apply((java.math.BigDecimal) data);
author:cenyuhai
-------------------------------------------------------------------------------
commit:e5ee02c
/////////////////////////////////////////////////////////////////////////
0:       case SHORT:
/////////////////////////////////////////////////////////////////////////
0:       case SHORT:
/////////////////////////////////////////////////////////////////////////
0:       case "SMALLINT":
author:aniket
-------------------------------------------------------------------------------
commit:5b51d48
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.math.NumberUtils;
============================================================================