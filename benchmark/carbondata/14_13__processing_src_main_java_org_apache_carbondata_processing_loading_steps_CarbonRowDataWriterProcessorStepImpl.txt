1:4827315: /*
1:4827315:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:4827315:  * contributor license agreements.  See the NOTICE file distributed with
1:4827315:  * this work for additional information regarding copyright ownership.
1:4827315:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:4827315:  * (the "License"); you may not use this file except in compliance with
1:4827315:  * the License.  You may obtain a copy of the License at
1:4827315:  *
1:4827315:  *    http://www.apache.org/licenses/LICENSE-2.0
1:4827315:  *
1:4827315:  * Unless required by applicable law or agreed to in writing, software
1:4827315:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4827315:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4827315:  * See the License for the specific language governing permissions and
1:4827315:  * limitations under the License.
1:4827315:  */
1:349c59c: package org.apache.carbondata.processing.loading.steps;
7:4827315: 
1:4827315: import java.io.IOException;
1:4827315: import java.util.Iterator;
1:7158d52: import java.util.List;
1:334e647: import java.util.Map;
1:7158d52: import java.util.concurrent.CopyOnWriteArrayList;
1:4827315: import java.util.concurrent.ExecutorService;
1:4827315: import java.util.concurrent.Executors;
1:4827315: import java.util.concurrent.Future;
1:4827315: 
1:4827315: import org.apache.carbondata.common.logging.LogService;
1:4827315: import org.apache.carbondata.common.logging.LogServiceFactory;
1:dc83b2a: import org.apache.carbondata.core.datastore.exception.CarbonDataWriterException;
1:dc83b2a: import org.apache.carbondata.core.datastore.row.CarbonRow;
1:dc83b2a: import org.apache.carbondata.core.datastore.row.WriteStepRowUtil;
1:4827315: import org.apache.carbondata.core.keygenerator.KeyGenException;
1:334e647: import org.apache.carbondata.core.localdictionary.generator.LocalDictionaryGenerator;
1:4827315: import org.apache.carbondata.core.metadata.CarbonTableIdentifier;
1:98df130: import org.apache.carbondata.core.metadata.datatype.DataType;
1:b491609: import org.apache.carbondata.core.util.CarbonThreadFactory;
1:4827315: import org.apache.carbondata.core.util.CarbonTimeStatisticsFactory;
1:334e647: import org.apache.carbondata.core.util.CarbonUtil;
1:5bedd77: import org.apache.carbondata.core.util.path.CarbonTablePath;
1:7f4bd3d: import org.apache.carbondata.processing.datamap.DataMapWriterListener;
1:349c59c: import org.apache.carbondata.processing.loading.AbstractDataLoadProcessorStep;
1:349c59c: import org.apache.carbondata.processing.loading.CarbonDataLoadConfiguration;
1:349c59c: import org.apache.carbondata.processing.loading.exception.BadRecordFoundException;
1:349c59c: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
1:349c59c: import org.apache.carbondata.processing.loading.row.CarbonRowBatch;
1:4827315: import org.apache.carbondata.processing.store.CarbonFactDataHandlerModel;
1:4827315: import org.apache.carbondata.processing.store.CarbonFactHandler;
1:4827315: import org.apache.carbondata.processing.store.CarbonFactHandlerFactory;
1:4827315: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1:4827315: 
1:4827315: /**
1:4827315:  * It reads data from sorted files which are generated in previous sort step.
1:4827315:  * And it writes data to carbondata file. It also generates mdk key while writing to carbondata file
1:4827315:  */
1:4827315: public class CarbonRowDataWriterProcessorStepImpl extends AbstractDataLoadProcessorStep {
1:4827315: 
1:4827315:   private static final LogService LOGGER =
1:4827315:       LogServiceFactory.getLogService(CarbonRowDataWriterProcessorStepImpl.class.getName());
1:4827315: 
1:4827315:   private int dimensionWithComplexCount;
1:4827315: 
1:4827315:   private int noDictWithComplextCount;
1:4827315: 
1:4827315:   private boolean[] isNoDictionaryDimensionColumn;
1:4827315: 
1:98df130:   private DataType[] measureDataType;
1:4827315: 
1:4827315:   private int dimensionCount;
1:4827315: 
1:4827315:   private int measureCount;
1:4827315: 
1:4827315:   private long[] readCounter;
1:4827315: 
1:4827315:   private long[] writeCounter;
1:4827315: 
1:4827315:   private int outputLength;
1:4827315: 
1:4827315:   private CarbonTableIdentifier tableIdentifier;
1:4827315: 
1:4827315:   private String tableName;
1:4827315: 
1:334e647:   private Map<String, LocalDictionaryGenerator> localDictionaryGeneratorMap;
1:334e647: 
1:7158d52:   private List<CarbonFactHandler> carbonFactHandlers;
1:7158d52: 
1:7158d52:   private ExecutorService executorService = null;
1:7158d52: 
1:4827315:   public CarbonRowDataWriterProcessorStepImpl(CarbonDataLoadConfiguration configuration,
1:4827315:       AbstractDataLoadProcessorStep child) {
1:4827315:     super(configuration, child);
1:334e647:     this.localDictionaryGeneratorMap =
1:334e647:         CarbonUtil.getLocalDictionaryModel(configuration.getTableSpec().getCarbonTable());
1:7158d52:     this.carbonFactHandlers = new CopyOnWriteArrayList<>();
7:4827315:   }
1:7158d52: 
1:4827315:   @Override public void initialize() throws IOException {
1:2b66476:     super.initialize();
1:4827315:     child.initialize();
1:4827315:   }
1:4827315: 
1:5bedd77:   private String[] getStoreLocation(CarbonTableIdentifier tableIdentifier) {
1:5bedd77:     String[] storeLocation = CarbonDataProcessorUtil.getLocalDataFolderLocation(
1:5bedd77:         tableIdentifier.getDatabaseName(),
1:5bedd77:         tableIdentifier.getTableName(),
1:5bedd77:         String.valueOf(configuration.getTaskNo()), configuration.getSegmentId(),
1:5bedd77:         false,
1:5bedd77:         false);
1:ded8b41:     CarbonDataProcessorUtil.createLocations(storeLocation);
1:4827315:     return storeLocation;
1:4827315:   }
1:4827315: 
1:4827315:   @Override public Iterator<CarbonRowBatch>[] execute() throws CarbonDataLoadingException {
1:4827315:     final Iterator<CarbonRowBatch>[] iterators = child.execute();
1:4827315:     tableIdentifier = configuration.getTableIdentifier().getCarbonTableIdentifier();
1:4827315:     tableName = tableIdentifier.getTableName();
1:4827315:     try {
1:4827315:       readCounter = new long[iterators.length];
1:4827315:       writeCounter = new long[iterators.length];
1:4827315:       dimensionWithComplexCount = configuration.getDimensionCount();
1:4827315:       noDictWithComplextCount =
1:3202cf5:           configuration.getNoDictionaryCount() + configuration.getComplexDictionaryColumnCount()
1:3202cf5:               + configuration.getComplexNonDictionaryColumnCount();
1:4827315:       dimensionCount = configuration.getDimensionCount() - noDictWithComplextCount;
1:4827315:       isNoDictionaryDimensionColumn =
1:4827315:           CarbonDataProcessorUtil.getNoDictionaryMapping(configuration.getDataFields());
1:353272e:       measureDataType = configuration.getMeasureDataType();
1:deabeff:       measureCount = configuration.getMeasureCount();
1:4827315:       outputLength = measureCount + (this.noDictWithComplextCount > 0 ? 1 : 0) + 1;
1:4827315:       CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
1:5bedd77:           .recordDictionaryValue2MdkAdd2FileTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:4827315:               System.currentTimeMillis());
1:4827315: 
1:4827315:       if (iterators.length == 1) {
1:5bedd77:         doExecute(iterators[0], 0);
3:4827315:       } else {
1:b491609:         executorService = Executors.newFixedThreadPool(iterators.length,
1:b491609:             new CarbonThreadFactory("NoSortDataWriterPool:" + configuration.getTableIdentifier()
1:b491609:                 .getCarbonTableIdentifier().getTableName()));
1:4827315:         Future[] futures = new Future[iterators.length];
1:4827315:         for (int i = 0; i < iterators.length; i++) {
1:4827315:           futures[i] = executorService.submit(new DataWriterRunnable(iterators[i], i));
1:4827315:         }
1:4827315:         for (Future future : futures) {
1:4827315:           future.get();
1:4827315:         }
1:4827315:       }
1:4827315:     } catch (CarbonDataWriterException e) {
1:4827315:       LOGGER.error(e, "Failed for table: " + tableName + " in DataWriterProcessorStepImpl");
1:4827315:       throw new CarbonDataLoadingException(
1:4827315:           "Error while initializing data handler : " + e.getMessage());
1:4827315:     } catch (Exception e) {
1:4827315:       LOGGER.error(e, "Failed for table: " + tableName + " in DataWriterProcessorStepImpl");
1:b6545c5:       if (e instanceof BadRecordFoundException) {
1:b6545c5:         throw new BadRecordFoundException(e.getMessage(), e);
1:b6545c5:       }
1:4827315:       throw new CarbonDataLoadingException("There is an unexpected error: " + e.getMessage(), e);
1:b491609:     }
2:4827315:     return null;
1:4827315:   }
1:4827315: 
1:9db662a:   private void doExecute(Iterator<CarbonRowBatch> iterator, int iteratorIndex) throws IOException {
1:5bedd77:     String[] storeLocation = getStoreLocation(tableIdentifier);
1:7f4bd3d:     DataMapWriterListener listener = getDataMapWriterListener(0);
1:5bedd77:     CarbonFactDataHandlerModel model = CarbonFactDataHandlerModel.createCarbonFactDataHandlerModel(
1:7f4bd3d:         configuration, storeLocation, 0, iteratorIndex, listener);
1:334e647:     model.setColumnLocalDictGenMap(localDictionaryGeneratorMap);
1:4827315:     CarbonFactHandler dataHandler = null;
1:4827315:     boolean rowsNotExist = true;
1:4827315:     while (iterator.hasNext()) {
1:4827315:       if (rowsNotExist) {
1:4827315:         rowsNotExist = false;
1:f911403:         dataHandler = CarbonFactHandlerFactory.createCarbonFactHandler(model);
1:7158d52:         this.carbonFactHandlers.add(dataHandler);
1:4827315:         dataHandler.initialise();
1:4827315:       }
1:4827315:       processBatch(iterator.next(), dataHandler, iteratorIndex);
1:4827315:     }
1:7158d52:     try {
1:7158d52:       if (!rowsNotExist) {
1:7158d52:         finish(dataHandler, iteratorIndex);
1:7158d52:       }
1:7158d52:     } finally {
1:7158d52:       carbonFactHandlers.remove(dataHandler);
1:4827315:     }
1:7158d52: 
1:7158d52: 
1:4827315:   }
1:4827315: 
1:4827315:   @Override protected String getStepName() {
1:4827315:     return "Data Writer";
1:4827315:   }
1:4827315: 
1:4827315:   private void finish(CarbonFactHandler dataHandler, int iteratorIndex) {
1:7158d52:     CarbonDataWriterException exception = null;
1:4827315:     try {
1:4827315:       dataHandler.finish();
1:4827315:     } catch (Exception e) {
1:7158d52:       // if throw exception from here dataHandler will not be closed.
1:7158d52:       // so just holding exception and later throwing exception
1:4827315:       LOGGER.error(e, "Failed for table: " + tableName + " in  finishing data handler");
1:7158d52:       exception = new CarbonDataWriterException(
1:7158d52:           "Failed for table: " + tableName + " in  finishing data handler", e);
1:4827315:     }
1:4827315:     LOGGER.info("Record Processed For table: " + tableName);
1:4827315:     String logMessage =
1:4827315:         "Finished Carbon DataWriterProcessorStepImpl: Read: " + readCounter[iteratorIndex]
1:4827315:             + ": Write: " + readCounter[iteratorIndex];
1:4827315:     LOGGER.info(logMessage);
1:4827315:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordTotalRecords(rowCounter.get());
1:7158d52:     try {
1:7158d52:       processingComplete(dataHandler);
1:7158d52:     } catch (CarbonDataLoadingException e) {
1:7158d52:       exception = new CarbonDataWriterException(e.getMessage(), e);
1:7158d52:     }
1:4827315:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
1:5bedd77:         .recordDictionaryValue2MdkAdd2FileTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:4827315:             System.currentTimeMillis());
1:4827315:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
1:5bedd77:         .recordMdkGenerateTotalTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:5bedd77:             System.currentTimeMillis());
1:7158d52:     if (null != exception) {
1:7158d52:       throw exception;
1:7158d52:     }
1:4827315:   }
1:4827315: 
1:4827315:   private void processingComplete(CarbonFactHandler dataHandler) throws CarbonDataLoadingException {
1:4827315:     if (null != dataHandler) {
1:4827315:       try {
1:4827315:         dataHandler.closeHandler();
1:4827315:       } catch (CarbonDataWriterException e) {
1:4827315:         LOGGER.error(e, e.getMessage());
1:4827315:         throw new CarbonDataLoadingException(e.getMessage());
1:4827315:       } catch (Exception e) {
1:4827315:         LOGGER.error(e, e.getMessage());
1:4827315:         throw new CarbonDataLoadingException("There is an unexpected error: " + e.getMessage());
1:4827315:       }
1:4827315:     }
1:4827315:   }
1:4827315: 
1:4827315:   /**
1:4827315:    * convert input CarbonRow to output CarbonRow
1:4827315:    * e.g. There is a table as following,
1:4827315:    * the number of dictionary dimensions is a,
1:4827315:    * the number of no-dictionary dimensions is b,
1:4827315:    * the number of complex dimensions is c,
1:4827315:    * the number of measures is d.
1:4827315:    * input CarbonRow format:  the length of Object[] data is a+b+c+d, the number of all columns.
1:4827315:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:4827315:    * | Part                     | Object item                    | describe                 |
1:4827315:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:4827315:    * | Object[0 ~ a+b-1]        | Integer, byte[], Integer, ...  | dict + no dict dimensions|
1:4827315:    * ----------------------------------------------------------------------------------------
1:4827315:    * | Object[a+b ~ a+b+c-1]    | byte[], byte[], ...            | complex dimensions       |
1:4827315:    * ----------------------------------------------------------------------------------------
1:4827315:    * | Object[a+b+c ~ a+b+c+d-1]| int, byte[], ...               | measures                 |
1:4827315:    * ----------------------------------------------------------------------------------------
1:4827315:    * output CarbonRow format: the length of object[] data is d + (b+c>0?1:0) + 1.
1:4827315:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:4827315:    * | Part                     | Object item                    | describe                 |
1:4827315:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:353272e:    * | Object[d+1]              | byte[]                         | mdkey                    |
1:4827315:    * ----------------------------------------------------------------------------------------
1:4827315:    * | Object[d]                | byte[b+c][]                    | no dict + complex dim    |
1:4827315:    * ----------------------------------------------------------------------------------------
1:353272e:    * | Object[0 ~ d-1]          | int, byte[], ...               | measures                 |
1:4827315:    * ----------------------------------------------------------------------------------------
1:4827315:    *
1:4827315:    * @param row
1:4827315:    * @return
1:4827315:    */
1:353272e:   private CarbonRow convertRow(CarbonRow row) throws KeyGenException {
1:4827315:     int dictIndex = 0;
1:4827315:     int nonDicIndex = 0;
1:4827315:     int[] dim = new int[this.dimensionCount];
1:4827315:     byte[][] nonDicArray = new byte[this.noDictWithComplextCount][];
1:4827315:     // read dimension values
1:4827315:     int dimCount = 0;
1:4827315:     for (; dimCount < isNoDictionaryDimensionColumn.length; dimCount++) {
1:4827315:       if (isNoDictionaryDimensionColumn[dimCount]) {
1:4827315:         nonDicArray[nonDicIndex++] = (byte[]) row.getObject(dimCount);
1:4827315:       } else {
1:4827315:         dim[dictIndex++] = (int) row.getObject(dimCount);
1:4827315:       }
1:4827315:     }
1:4827315: 
1:4827315:     for (; dimCount < this.dimensionWithComplexCount; dimCount++) {
1:4827315:       nonDicArray[nonDicIndex++] = (byte[]) row.getObject(dimCount);
1:4827315:     }
1:4827315: 
1:d4eabbe:     Object[] measures = new Object[measureCount];
1:353272e:     for (int i = 0; i < this.measureCount; i++) {
1:9e064ee:       measures[i] = row.getObject(i + this.dimensionWithComplexCount);
1:4827315:     }
1:4827315: 
1:353272e:     return WriteStepRowUtil.fromColumnCategory(dim, nonDicArray, measures);
1:4827315:   }
1:4827315: 
1:4827315:   private void processBatch(CarbonRowBatch batch, CarbonFactHandler dataHandler, int iteratorIndex)
1:4827315:       throws CarbonDataLoadingException {
1:4827315:     try {
1:4827315:       while (batch.hasNext()) {
1:353272e:         CarbonRow row = batch.next();
1:353272e:         CarbonRow converted = convertRow(row);
1:353272e:         dataHandler.addDataToStore(converted);
1:4827315:         readCounter[iteratorIndex]++;
1:4827315:       }
1:4827315:       writeCounter[iteratorIndex] += batch.getSize();
1:4827315:     } catch (Exception e) {
1:4827315:       throw new CarbonDataLoadingException("unable to generate the mdkey", e);
1:4827315:     }
1:4827315:     rowCounter.getAndAdd(batch.getSize());
1:4827315:   }
1:4827315: 
1:4827315:   class DataWriterRunnable implements Runnable {
1:4827315: 
1:4827315:     private Iterator<CarbonRowBatch> iterator;
1:4827315:     private int iteratorIndex = 0;
1:4827315: 
1:4827315:     DataWriterRunnable(Iterator<CarbonRowBatch> iterator, int iteratorIndex) {
1:4827315:       this.iterator = iterator;
1:4827315:       this.iteratorIndex = iteratorIndex;
1:4827315:     }
1:4827315: 
1:4827315:     @Override public void run() {
1:9db662a:       try {
1:9db662a:         doExecute(this.iterator, iteratorIndex);
1:9db662a:       } catch (IOException e) {
1:9db662a:         LOGGER.error(e);
1:9db662a:         throw new RuntimeException(e);
1:9db662a:       }
1:4827315:     }
1:4827315:   }
1:4827315: 
1:7158d52:   @Override public void close() {
1:7158d52:     if (!closed) {
1:7158d52:       super.close();
1:7158d52:       if (null != executorService) {
1:7158d52:         executorService.shutdownNow();
1:7158d52:       }
1:7158d52:       if (null != this.carbonFactHandlers && !this.carbonFactHandlers.isEmpty()) {
1:7158d52:         for (CarbonFactHandler carbonFactHandler : this.carbonFactHandlers) {
1:7158d52:           carbonFactHandler.finish();
1:7158d52:           carbonFactHandler.closeHandler();
1:7158d52:         }
1:7158d52:       }
1:7158d52:     }
1:7158d52:   }
1:4827315: }
============================================================================
author:BJangir
-------------------------------------------------------------------------------
commit:7158d52
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
1:   private List<CarbonFactHandler> carbonFactHandlers;
1: 
1:   private ExecutorService executorService = null;
1: 
1:     this.carbonFactHandlers = new CopyOnWriteArrayList<>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         this.carbonFactHandlers.add(dataHandler);
1:     try {
1:       if (!rowsNotExist) {
1:         finish(dataHandler, iteratorIndex);
1:       }
1:     } finally {
1:       carbonFactHandlers.remove(dataHandler);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     CarbonDataWriterException exception = null;
1:       // if throw exception from here dataHandler will not be closed.
1:       // so just holding exception and later throwing exception
1:       exception = new CarbonDataWriterException(
1:           "Failed for table: " + tableName + " in  finishing data handler", e);
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       processingComplete(dataHandler);
1:     } catch (CarbonDataLoadingException e) {
1:       exception = new CarbonDataWriterException(e.getMessage(), e);
1:     }
1:     if (null != exception) {
1:       throw exception;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Override public void close() {
1:     if (!closed) {
1:       super.close();
1:       if (null != executorService) {
1:         executorService.shutdownNow();
1:       }
1:       if (null != this.carbonFactHandlers && !this.carbonFactHandlers.isEmpty()) {
1:         for (CarbonFactHandler carbonFactHandler : this.carbonFactHandlers) {
1:           carbonFactHandler.finish();
1:           carbonFactHandler.closeHandler();
1:         }
1:       }
1:     }
1:   }
author:sraghunandan
-------------------------------------------------------------------------------
commit:f911403
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         dataHandler = CarbonFactHandlerFactory.createCarbonFactHandler(model);
/////////////////////////////////////////////////////////////////////////
author:kumarvishal09
-------------------------------------------------------------------------------
commit:334e647
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.localdictionary.generator.LocalDictionaryGenerator;
1: import org.apache.carbondata.core.util.CarbonUtil;
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, LocalDictionaryGenerator> localDictionaryGeneratorMap;
1: 
1:     this.localDictionaryGeneratorMap =
1:         CarbonUtil.getLocalDictionaryModel(configuration.getTableSpec().getCarbonTable());
/////////////////////////////////////////////////////////////////////////
1:     model.setColumnLocalDictGenMap(localDictionaryGeneratorMap);
author:akashrn5
-------------------------------------------------------------------------------
commit:7f4bd3d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.datamap.DataMapWriterListener;
/////////////////////////////////////////////////////////////////////////
1:     DataMapWriterListener listener = getDataMapWriterListener(0);
1:         configuration, storeLocation, 0, iteratorIndex, listener);
author:Jacky Li
-------------------------------------------------------------------------------
commit:9db662a
/////////////////////////////////////////////////////////////////////////
1:   private void doExecute(Iterator<CarbonRowBatch> iterator, int iteratorIndex) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:       try {
1:         doExecute(this.iterator, iteratorIndex);
1:       } catch (IOException e) {
1:         LOGGER.error(e);
1:         throw new RuntimeException(e);
1:       }
commit:5bedd77
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.path.CarbonTablePath;
/////////////////////////////////////////////////////////////////////////
1:   private String[] getStoreLocation(CarbonTableIdentifier tableIdentifier) {
1:     String[] storeLocation = CarbonDataProcessorUtil.getLocalDataFolderLocation(
1:         tableIdentifier.getDatabaseName(),
1:         tableIdentifier.getTableName(),
1:         String.valueOf(configuration.getTaskNo()), configuration.getSegmentId(),
1:         false,
1:         false);
/////////////////////////////////////////////////////////////////////////
1:           .recordDictionaryValue2MdkAdd2FileTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:         doExecute(iterators[0], 0);
/////////////////////////////////////////////////////////////////////////
0:   private void doExecute(Iterator<CarbonRowBatch> iterator, int iteratorIndex) {
1:     String[] storeLocation = getStoreLocation(tableIdentifier);
1:     CarbonFactDataHandlerModel model = CarbonFactDataHandlerModel.createCarbonFactDataHandlerModel(
0:         configuration, storeLocation, 0, iteratorIndex);
/////////////////////////////////////////////////////////////////////////
1:         .recordDictionaryValue2MdkAdd2FileTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:         .recordMdkGenerateTotalTime(CarbonTablePath.DEPRECATED_PATITION_ID,
1:             System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:       doExecute(this.iterator, iteratorIndex);
commit:deabeff
/////////////////////////////////////////////////////////////////////////
1:       measureCount = configuration.getMeasureCount();
commit:349c59c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.carbondata.processing.loading.steps;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.processing.loading.AbstractDataLoadProcessorStep;
1: import org.apache.carbondata.processing.loading.CarbonDataLoadConfiguration;
0: import org.apache.carbondata.processing.loading.DataField;
1: import org.apache.carbondata.processing.loading.exception.BadRecordFoundException;
1: import org.apache.carbondata.processing.loading.exception.CarbonDataLoadingException;
1: import org.apache.carbondata.processing.loading.row.CarbonRowBatch;
author:sounakr
-------------------------------------------------------------------------------
commit:3202cf5
/////////////////////////////////////////////////////////////////////////
1:           configuration.getNoDictionaryCount() + configuration.getComplexDictionaryColumnCount()
1:               + configuration.getComplexNonDictionaryColumnCount();
author:kumarvishal
-------------------------------------------------------------------------------
commit:b491609
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.util.CarbonThreadFactory;
/////////////////////////////////////////////////////////////////////////
0:     ExecutorService executorService = null;
/////////////////////////////////////////////////////////////////////////
1:         executorService = Executors.newFixedThreadPool(iterators.length,
1:             new CarbonThreadFactory("NoSortDataWriterPool:" + configuration.getTableIdentifier()
1:                 .getCarbonTableIdentifier().getTableName()));
/////////////////////////////////////////////////////////////////////////
0:     } finally {
0:       if (null != executorService && executorService.isShutdown()) {
0:         executorService.shutdownNow();
1:       }
author:kunal642
-------------------------------------------------------------------------------
commit:d4eabbe
/////////////////////////////////////////////////////////////////////////
1:     Object[] measures = new Object[measureCount];
author:lionelcao
-------------------------------------------------------------------------------
commit:874764f
/////////////////////////////////////////////////////////////////////////
0:             configuration.getSegmentId() + "", false, false);
author:xuchuanyin
-------------------------------------------------------------------------------
commit:ded8b41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   private String[] getStoreLocation(CarbonTableIdentifier tableIdentifier, String partitionId) {
0:     String[] storeLocation = CarbonDataProcessorUtil
1:     CarbonDataProcessorUtil.createLocations(storeLocation);
/////////////////////////////////////////////////////////////////////////
0:     String[] storeLocation = getStoreLocation(tableIdentifier, String.valueOf(partitionId));
0:         .createCarbonFactDataHandlerModel(configuration, storeLocation, partitionId,
0:             iteratorIndex);
author:manishgupta88
-------------------------------------------------------------------------------
commit:2b66476
/////////////////////////////////////////////////////////////////////////
1:     super.initialize();
commit:b6545c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.exception.BadRecordFoundException;
/////////////////////////////////////////////////////////////////////////
1:       if (e instanceof BadRecordFoundException) {
1:         throw new BadRecordFoundException(e.getMessage(), e);
1:       }
author:ravipesala
-------------------------------------------------------------------------------
commit:9e064ee
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       measures[i] = row.getObject(i + this.dimensionWithComplexCount);
author:jackylk
-------------------------------------------------------------------------------
commit:dc83b2a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.datastore.exception.CarbonDataWriterException;
1: import org.apache.carbondata.core.datastore.row.CarbonRow;
1: import org.apache.carbondata.core.datastore.row.WriteStepRowUtil;
/////////////////////////////////////////////////////////////////////////
commit:353272e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.carbondata.processing.newflow.row.WriteStepRowUtil;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           configuration.getNoDictionaryCount() + configuration.getComplexColumnCount();
1:       measureDataType = configuration.getMeasureDataType();
/////////////////////////////////////////////////////////////////////////
1:    * | Object[d+1]              | byte[]                         | mdkey                    |
1:    * | Object[0 ~ d-1]          | int, byte[], ...               | measures                 |
1:   private CarbonRow convertRow(CarbonRow row) throws KeyGenException {
/////////////////////////////////////////////////////////////////////////
0:     Object[] measures = new Object[outputLength];
1:     for (int i = 0; i < this.measureCount; i++) {
0:       Object value = row.getObject(i + this.dimensionWithComplexCount);
0:         if (measureDataType[i] == DataType.DECIMAL) {
0:           measures[i] = DataTypeUtil.bigDecimalToByte(val);
0:           measures[i] = value;
0:         measures[i] = null;
1:     return WriteStepRowUtil.fromColumnCategory(dim, nonDicArray, measures);
1:         CarbonRow row = batch.next();
1:         CarbonRow converted = convertRow(row);
1:         dataHandler.addDataToStore(converted);
commit:98df130
/////////////////////////////////////////////////////////////////////////
1: import org.apache.carbondata.core.metadata.datatype.DataType;
/////////////////////////////////////////////////////////////////////////
1:   private DataType[] measureDataType;
/////////////////////////////////////////////////////////////////////////
0:       measureDataType = CarbonDataProcessorUtil
0:           .getMeasureDataType(configuration.getMeasureCount(), configuration.getMeasureFields());
/////////////////////////////////////////////////////////////////////////
0:         if (measureDataType[l] == DataType.DECIMAL) {
author:QiangCai
-------------------------------------------------------------------------------
commit:f5c6f28
/////////////////////////////////////////////////////////////////////////
0:         .createCarbonFactDataHandlerModel(configuration, storeLocation, partitionId, iteratorIndex);
commit:4827315
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.carbondata.processing.newflow.steps;
1: 
0: import java.io.File;
1: import java.io.IOException;
0: import java.math.BigDecimal;
1: import java.util.Iterator;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: 
1: import org.apache.carbondata.common.logging.LogService;
1: import org.apache.carbondata.common.logging.LogServiceFactory;
0: import org.apache.carbondata.core.constants.CarbonCommonConstants;
0: import org.apache.carbondata.core.datastore.block.SegmentProperties;
1: import org.apache.carbondata.core.keygenerator.KeyGenException;
0: import org.apache.carbondata.core.keygenerator.KeyGenerator;
1: import org.apache.carbondata.core.metadata.CarbonTableIdentifier;
1: import org.apache.carbondata.core.util.CarbonTimeStatisticsFactory;
0: import org.apache.carbondata.core.util.DataTypeUtil;
0: import org.apache.carbondata.processing.newflow.AbstractDataLoadProcessorStep;
0: import org.apache.carbondata.processing.newflow.CarbonDataLoadConfiguration;
0: import org.apache.carbondata.processing.newflow.DataField;
0: import org.apache.carbondata.processing.newflow.exception.CarbonDataLoadingException;
0: import org.apache.carbondata.processing.newflow.row.CarbonRow;
0: import org.apache.carbondata.processing.newflow.row.CarbonRowBatch;
1: import org.apache.carbondata.processing.store.CarbonFactDataHandlerModel;
1: import org.apache.carbondata.processing.store.CarbonFactHandler;
1: import org.apache.carbondata.processing.store.CarbonFactHandlerFactory;
0: import org.apache.carbondata.processing.store.writer.exception.CarbonDataWriterException;
1: import org.apache.carbondata.processing.util.CarbonDataProcessorUtil;
1: 
1: /**
1:  * It reads data from sorted files which are generated in previous sort step.
1:  * And it writes data to carbondata file. It also generates mdk key while writing to carbondata file
1:  */
1: public class CarbonRowDataWriterProcessorStepImpl extends AbstractDataLoadProcessorStep {
1: 
1:   private static final LogService LOGGER =
1:       LogServiceFactory.getLogService(CarbonRowDataWriterProcessorStepImpl.class.getName());
1: 
0:   private SegmentProperties segmentProperties;
1: 
0:   private KeyGenerator keyGenerator;
1: 
1:   private int dimensionWithComplexCount;
1: 
1:   private int noDictWithComplextCount;
1: 
1:   private boolean[] isNoDictionaryDimensionColumn;
1: 
0:   private char[] aggType;
1: 
1:   private int dimensionCount;
1: 
1:   private int measureCount;
1: 
1:   private long[] readCounter;
1: 
1:   private long[] writeCounter;
1: 
1:   private int outputLength;
1: 
1:   private CarbonTableIdentifier tableIdentifier;
1: 
1:   private String tableName;
1: 
1:   public CarbonRowDataWriterProcessorStepImpl(CarbonDataLoadConfiguration configuration,
1:       AbstractDataLoadProcessorStep child) {
1:     super(configuration, child);
1:   }
1: 
0:   @Override public DataField[] getOutput() {
0:     return child.getOutput();
1:   }
1: 
1:   @Override public void initialize() throws IOException {
1:     child.initialize();
1:   }
1: 
0:   private String getStoreLocation(CarbonTableIdentifier tableIdentifier, String partitionId) {
0:     String storeLocation = CarbonDataProcessorUtil
0:         .getLocalDataFolderLocation(tableIdentifier.getDatabaseName(),
0:             tableIdentifier.getTableName(), String.valueOf(configuration.getTaskNo()), partitionId,
0:             configuration.getSegmentId() + "", false);
0:     new File(storeLocation).mkdirs();
1:     return storeLocation;
1:   }
1: 
1:   @Override public Iterator<CarbonRowBatch>[] execute() throws CarbonDataLoadingException {
1:     final Iterator<CarbonRowBatch>[] iterators = child.execute();
1:     tableIdentifier = configuration.getTableIdentifier().getCarbonTableIdentifier();
1:     tableName = tableIdentifier.getTableName();
1:     try {
1:       readCounter = new long[iterators.length];
1:       writeCounter = new long[iterators.length];
1:       dimensionWithComplexCount = configuration.getDimensionCount();
1:       noDictWithComplextCount =
0:           configuration.getNoDictionaryCount() + configuration.getComplexDimensionCount();
1:       dimensionCount = configuration.getDimensionCount() - noDictWithComplextCount;
1:       isNoDictionaryDimensionColumn =
1:           CarbonDataProcessorUtil.getNoDictionaryMapping(configuration.getDataFields());
0:       aggType = CarbonDataProcessorUtil
0:           .getAggType(configuration.getMeasureCount(), configuration.getMeasureFields());
1: 
0:       CarbonFactDataHandlerModel dataHandlerModel = CarbonFactDataHandlerModel
0:           .createCarbonFactDataHandlerModel(configuration,
0:               getStoreLocation(tableIdentifier, String.valueOf(0)), 0, 0);
0:       measureCount = dataHandlerModel.getMeasureCount();
1:       outputLength = measureCount + (this.noDictWithComplextCount > 0 ? 1 : 0) + 1;
0:       segmentProperties = dataHandlerModel.getSegmentProperties();
0:       keyGenerator = segmentProperties.getDimensionKeyGenerator();
1: 
1:       CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
0:           .recordDictionaryValue2MdkAdd2FileTime(configuration.getPartitionId(),
1:               System.currentTimeMillis());
1: 
1:       if (iterators.length == 1) {
0:         doExecute(iterators[0], 0, 0);
1:       } else {
0:         ExecutorService executorService = Executors.newFixedThreadPool(iterators.length);
1:         Future[] futures = new Future[iterators.length];
1:         for (int i = 0; i < iterators.length; i++) {
1:           futures[i] = executorService.submit(new DataWriterRunnable(iterators[i], i));
1:         }
1:         for (Future future : futures) {
1:           future.get();
1:         }
1:       }
1:     } catch (CarbonDataWriterException e) {
1:       LOGGER.error(e, "Failed for table: " + tableName + " in DataWriterProcessorStepImpl");
1:       throw new CarbonDataLoadingException(
1:           "Error while initializing data handler : " + e.getMessage());
1:     } catch (Exception e) {
1:       LOGGER.error(e, "Failed for table: " + tableName + " in DataWriterProcessorStepImpl");
1:       throw new CarbonDataLoadingException("There is an unexpected error: " + e.getMessage(), e);
1:     }
1:     return null;
1:   }
1: 
0:   private void doExecute(Iterator<CarbonRowBatch> iterator, int partitionId, int iteratorIndex) {
0:     String storeLocation = getStoreLocation(tableIdentifier, String.valueOf(partitionId));
0:     CarbonFactDataHandlerModel model = CarbonFactDataHandlerModel
0:         .createCarbonFactDataHandlerModel(configuration, storeLocation, partitionId, 0);
0:     model.getCarbonDataFileAttributes()
0:         .setFactTimeStamp(model.getCarbonDataFileAttributes().getFactTimeStamp() + iteratorIndex);
1:     CarbonFactHandler dataHandler = null;
1:     boolean rowsNotExist = true;
1:     while (iterator.hasNext()) {
1:       if (rowsNotExist) {
1:         rowsNotExist = false;
0:         dataHandler = CarbonFactHandlerFactory
0:             .createCarbonFactHandler(model, CarbonFactHandlerFactory.FactHandlerType.COLUMNAR);
1:         dataHandler.initialise();
1:       }
1:       processBatch(iterator.next(), dataHandler, iteratorIndex);
1:     }
0:     if (!rowsNotExist) {
0:       finish(dataHandler, iteratorIndex);
1:     }
1:   }
1: 
1:   @Override protected String getStepName() {
1:     return "Data Writer";
1:   }
1: 
1:   private void finish(CarbonFactHandler dataHandler, int iteratorIndex) {
1:     try {
1:       dataHandler.finish();
1:     } catch (Exception e) {
1:       LOGGER.error(e, "Failed for table: " + tableName + " in  finishing data handler");
1:     }
1:     LOGGER.info("Record Processed For table: " + tableName);
1:     String logMessage =
1:         "Finished Carbon DataWriterProcessorStepImpl: Read: " + readCounter[iteratorIndex]
1:             + ": Write: " + readCounter[iteratorIndex];
1:     LOGGER.info(logMessage);
1:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordTotalRecords(rowCounter.get());
0:     processingComplete(dataHandler);
1:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
0:         .recordDictionaryValue2MdkAdd2FileTime(configuration.getPartitionId(),
1:             System.currentTimeMillis());
1:     CarbonTimeStatisticsFactory.getLoadStatisticsInstance()
0:         .recordMdkGenerateTotalTime(configuration.getPartitionId(), System.currentTimeMillis());
1:   }
1: 
1:   private void processingComplete(CarbonFactHandler dataHandler) throws CarbonDataLoadingException {
1:     if (null != dataHandler) {
1:       try {
1:         dataHandler.closeHandler();
1:       } catch (CarbonDataWriterException e) {
1:         LOGGER.error(e, e.getMessage());
1:         throw new CarbonDataLoadingException(e.getMessage());
1:       } catch (Exception e) {
1:         LOGGER.error(e, e.getMessage());
1:         throw new CarbonDataLoadingException("There is an unexpected error: " + e.getMessage());
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * convert input CarbonRow to output CarbonRow
1:    * e.g. There is a table as following,
1:    * the number of dictionary dimensions is a,
1:    * the number of no-dictionary dimensions is b,
1:    * the number of complex dimensions is c,
1:    * the number of measures is d.
1:    * input CarbonRow format:  the length of Object[] data is a+b+c+d, the number of all columns.
1:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:    * | Part                     | Object item                    | describe                 |
1:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:    * | Object[0 ~ a+b-1]        | Integer, byte[], Integer, ...  | dict + no dict dimensions|
1:    * ----------------------------------------------------------------------------------------
1:    * | Object[a+b ~ a+b+c-1]    | byte[], byte[], ...            | complex dimensions       |
1:    * ----------------------------------------------------------------------------------------
1:    * | Object[a+b+c ~ a+b+c+d-1]| int, byte[], ...               | measures                 |
1:    * ----------------------------------------------------------------------------------------
1:    * output CarbonRow format: the length of object[] data is d + (b+c>0?1:0) + 1.
1:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1:    * | Part                     | Object item                    | describe                 |
1:    * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0:    * | Object[0 ~ d-1]          | int, byte[], ...               | measures                 |
1:    * ----------------------------------------------------------------------------------------
1:    * | Object[d]                | byte[b+c][]                    | no dict + complex dim    |
1:    * ----------------------------------------------------------------------------------------
0:    * | Object[d+1]              | byte[]                         | mdkey                    |
1:    * ----------------------------------------------------------------------------------------
1:    *
1:    * @param row
1:    * @return
1:    */
0:   private Object[] convertRow(CarbonRow row) throws KeyGenException {
1:     int dictIndex = 0;
1:     int nonDicIndex = 0;
1:     int[] dim = new int[this.dimensionCount];
1:     byte[][] nonDicArray = new byte[this.noDictWithComplextCount][];
1:     // read dimension values
1:     int dimCount = 0;
1:     for (; dimCount < isNoDictionaryDimensionColumn.length; dimCount++) {
1:       if (isNoDictionaryDimensionColumn[dimCount]) {
1:         nonDicArray[nonDicIndex++] = (byte[]) row.getObject(dimCount);
1:       } else {
1:         dim[dictIndex++] = (int) row.getObject(dimCount);
1:       }
1:     }
1: 
1:     for (; dimCount < this.dimensionWithComplexCount; dimCount++) {
1:       nonDicArray[nonDicIndex++] = (byte[]) row.getObject(dimCount);
1:     }
1: 
0:     int l = 0;
0:     Object[] outputRow = new Object[outputLength];
0:     for (; l < this.measureCount; l++) {
0:       Object value = row.getObject(l + this.dimensionWithComplexCount);
0:       if (null != value) {
0:         if (aggType[l] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {
0:           BigDecimal val = (BigDecimal) value;
0:           outputRow[l] = DataTypeUtil.bigDecimalToByte(val);
1:         } else {
0:           outputRow[l] = value;
1:         }
1:       } else {
0:         outputRow[l] = null;
1:       }
1:     }
1: 
0:     if (this.noDictWithComplextCount > 0) {
0:       outputRow[l++] = nonDicArray;
1:     }
0:     outputRow[l] = keyGenerator.generateKey(dim);
0:     return outputRow;
1:   }
1: 
1:   private void processBatch(CarbonRowBatch batch, CarbonFactHandler dataHandler, int iteratorIndex)
1:       throws CarbonDataLoadingException {
1:     try {
1:       while (batch.hasNext()) {
0:         dataHandler.addDataToStore(convertRow(batch.next()));
1:         readCounter[iteratorIndex]++;
1:       }
1:       writeCounter[iteratorIndex] += batch.getSize();
1:     } catch (Exception e) {
1:       throw new CarbonDataLoadingException("unable to generate the mdkey", e);
1:     }
1:     rowCounter.getAndAdd(batch.getSize());
1:   }
1: 
0:   @Override protected CarbonRow processRow(CarbonRow row) {
1:     return null;
1:   }
1: 
1:   class DataWriterRunnable implements Runnable {
1: 
1:     private Iterator<CarbonRowBatch> iterator;
1:     private int iteratorIndex = 0;
1: 
1:     DataWriterRunnable(Iterator<CarbonRowBatch> iterator, int iteratorIndex) {
1:       this.iterator = iterator;
1:       this.iteratorIndex = iteratorIndex;
1:     }
1: 
1:     @Override public void run() {
0:       doExecute(this.iterator, 0, iteratorIndex);
1:     }
1:   }
1: }
============================================================================