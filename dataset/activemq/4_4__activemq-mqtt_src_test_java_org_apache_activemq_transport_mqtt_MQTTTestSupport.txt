1:3653f81: /**
1:3653f81:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3653f81:  * contributor license agreements.  See the NOTICE file distributed with
1:3653f81:  * this work for additional information regarding copyright ownership.
1:3653f81:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3653f81:  * (the "License"); you may not use this file except in compliance with
1:3653f81:  * the License.  You may obtain a copy of the License at
1:3653f81:  *
1:3653f81:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3653f81:  *
1:3653f81:  * Unless required by applicable law or agreed to in writing, software
1:3653f81:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3653f81:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3653f81:  * See the License for the specific language governing permissions and
1:3653f81:  * limitations under the License.
1:3653f81:  */
20:3653f81: 
1:3653f81: package org.apache.activemq.transport.mqtt;
1:3653f81: 
1:3653f81: import java.io.File;
1:3653f81: import java.io.IOException;
1:c99e2d8: import java.net.URI;
1:3653f81: import java.security.ProtectionDomain;
1:3653f81: import java.util.ArrayList;
1:3653f81: import java.util.LinkedList;
1:619864d: import java.util.List;
1:3653f81: import java.util.concurrent.TimeUnit;
1:3653f81: 
1:3653f81: import javax.jms.JMSException;
1:3653f81: import javax.management.MalformedObjectNameException;
1:3653f81: import javax.management.ObjectName;
1:3653f81: 
1:3653f81: import org.apache.activemq.ActiveMQConnectionFactory;
1:3653f81: import org.apache.activemq.broker.BrokerPlugin;
1:3653f81: import org.apache.activemq.broker.BrokerService;
1:3653f81: import org.apache.activemq.broker.TransportConnector;
1:3653f81: import org.apache.activemq.broker.jmx.BrokerViewMBean;
1:3653f81: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:3653f81: import org.apache.activemq.broker.jmx.TopicViewMBean;
1:455f1ca: import org.apache.activemq.store.kahadb.KahaDBStore;
1:3653f81: import org.apache.activemq.transport.mqtt.util.ResourceLoadingSslContext;
1:3653f81: import org.fusesource.mqtt.client.MQTT;
1:3653f81: import org.fusesource.mqtt.client.Tracer;
1:3653f81: import org.fusesource.mqtt.codec.MQTTFrame;
1:3653f81: import org.junit.After;
1:3653f81: import org.junit.Before;
1:3653f81: import org.junit.Rule;
1:3653f81: import org.junit.rules.TestName;
1:3653f81: import org.slf4j.Logger;
1:3653f81: import org.slf4j.LoggerFactory;
1:3653f81: 
1:3653f81: public class MQTTTestSupport {
1:3653f81: 
1:3653f81:     private static final Logger LOG = LoggerFactory.getLogger(MQTTTestSupport.class);
1:3653f81: 
1:455f1ca:     public static final String KAHADB_DIRECTORY = "target/activemq-data/";
1:455f1ca: 
1:3653f81:     protected BrokerService brokerService;
1:3653f81:     protected int port;
1:3653f81:     protected String jmsUri = "vm://localhost";
1:3653f81:     protected ActiveMQConnectionFactory cf;
1:3653f81:     protected LinkedList<Throwable> exceptions = new LinkedList<Throwable>();
1:fb569e3:     protected boolean persistent;
1:fb569e3:     protected String protocolConfig;
1:829a186:     protected String protocolScheme;
1:829a186:     protected boolean useSSL;
1:fb569e3: 
1:3653f81:     public static final int AT_MOST_ONCE = 0;
1:3653f81:     public static final int AT_LEAST_ONCE = 1;
1:3653f81:     public static final int EXACTLY_ONCE = 2;
1:fb569e3: 
1:3653f81:     @Rule public TestName name = new TestName();
1:3653f81: 
1:3653f81:     public File basedir() throws IOException {
1:3653f81:         ProtectionDomain protectionDomain = getClass().getProtectionDomain();
1:3653f81:         return new File(new File(protectionDomain.getCodeSource().getLocation().getPath()), "../..").getCanonicalFile();
8:3653f81:     }
1:fb569e3: 
1:fb569e3:     public MQTTTestSupport() {
1:fb569e3:         this.protocolScheme = "mqtt";
1:fb569e3:         this.useSSL = false;
1:fb569e3:     }
1:fb569e3: 
1:829a186:     public MQTTTestSupport(String connectorScheme, boolean useSSL) {
1:fb569e3:         this.protocolScheme = connectorScheme;
1:829a186:         this.useSSL = useSSL;
1:fb569e3:     }
1:fb569e3: 
1:455f1ca:     public String getTestName() {
1:3653f81:         return name.getMethodName();
1:3653f81:     }
1:3653f81: 
1:3653f81:     @Before
1:3653f81:     public void setUp() throws Exception {
1:fb569e3: 
1:fb569e3:         String basedir = basedir().getPath();
1:fb569e3:         System.setProperty("javax.net.ssl.trustStore", basedir + "/src/test/resources/client.keystore");
1:fb569e3:         System.setProperty("javax.net.ssl.trustStorePassword", "password");
1:fb569e3:         System.setProperty("javax.net.ssl.trustStoreType", "jks");
1:fb569e3:         System.setProperty("javax.net.ssl.keyStore", basedir + "/src/test/resources/server.keystore");
1:fb569e3:         System.setProperty("javax.net.ssl.keyStorePassword", "password");
1:fb569e3:         System.setProperty("javax.net.ssl.keyStoreType", "jks");
1:fb569e3: 
1:3653f81:         exceptions.clear();
1:3653f81:         startBroker();
1:3653f81:     }
1:3653f81: 
1:3653f81:     @After
1:3653f81:     public void tearDown() throws Exception {
1:3653f81:         stopBroker();
1:3653f81:     }
1:3653f81: 
1:3653f81:     public void startBroker() throws Exception {
1:fd2805f:         brokerService = createBroker(true);
1:3653f81: 
1:fd2805f:         configureBroker(brokerService);
1:3653f81: 
1:fd2805f:         brokerService.start();
1:fd2805f:         brokerService.waitUntilStarted();
1:fd2805f:         port = brokerService.getTransportConnectorByName("mqtt").getConnectUri().getPort();
1:fd2805f:         jmsUri = brokerService.getTransportConnectorByName("openwire").getPublishableConnectString();
1:fd2805f:         cf = new ActiveMQConnectionFactory(jmsUri);
1:fd2805f:     }
1:fd2805f: 
1:fd2805f:     public void restartBroker() throws Exception {
1:fd2805f:         stopBroker();
1:fd2805f: 
1:fd2805f:         brokerService = createBroker(false);
1:fd2805f: 
1:fd2805f:         configureBroker(brokerService);
1:fd2805f: 
1:fd2805f:         brokerService.start();
1:fd2805f:         brokerService.waitUntilStarted();
1:fd2805f:         port = brokerService.getTransportConnectorByName("mqtt").getConnectUri().getPort();
1:fd2805f:         jmsUri = brokerService.getTransportConnectorByName("openwire").getPublishableConnectString();
1:fd2805f:         cf = new ActiveMQConnectionFactory(jmsUri);
1:fd2805f:     }
1:fd2805f: 
1:fd2805f:     protected BrokerService createBroker(boolean deleteAllMessages) throws Exception {
1:fd2805f:         BrokerService brokerService = new BrokerService();
1:fd2805f:         brokerService.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:fd2805f:         brokerService.setPersistent(isPersistent());
1:455f1ca:         if (isPersistent()) {
1:455f1ca:             KahaDBStore kaha = new KahaDBStore();
1:455f1ca:             kaha.setDirectory(new File(KAHADB_DIRECTORY + getTestName()));
1:455f1ca:             brokerService.setPersistenceAdapter(kaha);
1:455f1ca:         }
1:fd2805f:         brokerService.setAdvisorySupport(false);
1:fd2805f:         brokerService.setUseJmx(true);
1:fd2805f:         brokerService.getManagementContext().setCreateConnector(false);
1:fd2805f:         brokerService.setSchedulerSupport(isSchedulerSupportEnabled());
1:fd2805f:         brokerService.setPopulateJMSXUserID(true);
1:fd2805f: 
1:fd2805f:         return brokerService;
1:fd2805f:     }
1:fd2805f: 
1:fd2805f:     protected void configureBroker(BrokerService brokerService) throws Exception {
1:fd2805f:         applyBrokerPolicies(brokerService);
1:fd2805f:         applyMemoryLimitPolicy(brokerService);
1:3653f81: 
1:3653f81:         // Setup SSL context...
1:3653f81:         File keyStore = new File(basedir(), "src/test/resources/server.keystore");
1:3653f81:         File trustStore = new File(basedir(), "src/test/resources/client.keystore");
1:3653f81: 
1:3653f81:         final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:3653f81:         sslContext.setKeyStore(keyStore.getCanonicalPath());
1:3653f81:         sslContext.setKeyStorePassword("password");
1:3653f81:         sslContext.setTrustStore(trustStore.getCanonicalPath());
1:3653f81:         sslContext.setTrustStorePassword("password");
1:3653f81:         sslContext.afterPropertiesSet();
1:3653f81:         brokerService.setSslContext(sslContext);
1:3653f81: 
1:fd2805f:         addMQTTConnector(brokerService);
1:fd2805f:         addOpenWireConnector(brokerService);
1:3653f81: 
1:619864d:         ArrayList<BrokerPlugin> plugins = new ArrayList<BrokerPlugin>();
1:619864d:         createPlugins(plugins);
1:619864d: 
1:3653f81:         BrokerPlugin authenticationPlugin = configureAuthentication();
1:3653f81:         if (authenticationPlugin != null) {
1:3653f81:             plugins.add(configureAuthorization());
1:3653f81:         }
1:3653f81: 
1:3653f81:         BrokerPlugin authorizationPlugin = configureAuthorization();
1:3653f81:         if (authorizationPlugin != null) {
1:3653f81:             plugins.add(configureAuthentication());
1:3653f81:         }
1:3653f81: 
1:3653f81:         if (!plugins.isEmpty()) {
1:3653f81:             BrokerPlugin[] array = new BrokerPlugin[plugins.size()];
1:3653f81:             brokerService.setPlugins(plugins.toArray(array));
1:3653f81:         }
1:3653f81:     }
1:3653f81: 
1:619864d:     /**
1:619864d:      * Allows a subclass to add additional broker plugins during the broker startup
1:619864d:      * process.  This method should not add Authorization or Authentication plugins
1:619864d:      * as those are handled by the configureAuthentication and configureAuthorization
1:619864d:      * methods later.
1:619864d:      *
1:619864d:      * @param plugins
1:619864d:      *        The List object to add Plugins for installation into the new Broker.
1:619864d:      *
1:619864d:      * @throws Exception if an error occurs during the plugin creation process.
1:619864d:      */
1:619864d:     protected void createPlugins(List<BrokerPlugin> plugins) throws Exception {
1:619864d:         // NOOP
1:619864d:     }
1:619864d: 
1:3653f81:     protected BrokerPlugin configureAuthentication() throws Exception {
1:fb569e3:         return null;
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected BrokerPlugin configureAuthorization() throws Exception {
1:fb569e3:         return null;
1:3653f81:     }
1:3653f81: 
1:fd2805f:     protected void applyBrokerPolicies(BrokerService brokerService) throws Exception {
1:3653f81:         // NOOP here
1:3653f81:     }
1:3653f81: 
1:fd2805f:     protected void applyMemoryLimitPolicy(BrokerService brokerService) throws Exception {
1:3653f81:     }
1:3653f81: 
1:fd2805f:     protected void addOpenWireConnector(BrokerService brokerService) throws Exception {
1:fd2805f:         TransportConnector connector = new TransportConnector();
1:fd2805f:         connector.setUri(new URI("tcp://0.0.0.0:0"));
1:fd2805f:         connector.setName("openwire");
1:fd2805f:         brokerService.addConnector(connector);
1:fd2805f:     }
1:fd2805f: 
1:fd2805f:     protected void addMQTTConnector(BrokerService brokerService) throws Exception {
1:3653f81:         // Overrides of this method can add additional configuration options or add multiple
1:3653f81:         // MQTT transport connectors as needed, the port variable is always supposed to be
1:3653f81:         // assigned the primary MQTT connector's port.
1:fb569e3: 
1:fb569e3:         StringBuilder connectorURI = new StringBuilder();
1:fb569e3:         connectorURI.append(getProtocolScheme());
1:fb569e3:         connectorURI.append("://0.0.0.0:").append(port);
1:4b7131f:         String protocolConfig = getProtocolConfig();
1:fb569e3:         if (protocolConfig != null && !protocolConfig.isEmpty()) {
1:fb569e3:             connectorURI.append("?").append(protocolConfig);
1:fb569e3:         }
1:fb569e3: 
1:c99e2d8:         TransportConnector connector = new TransportConnector();
1:c99e2d8:         connector.setUri(new URI(connectorURI.toString()));
1:c99e2d8:         connector.setName("mqtt");
1:c99e2d8:         brokerService.addConnector(connector);
1:3653f81: 
1:fb569e3:         LOG.info("Added connector {} to broker", getProtocolScheme());
1:3653f81:     }
1:3653f81: 
1:3653f81:     public void stopBroker() throws Exception {
1:3653f81:         if (brokerService != null) {
1:3653f81:             brokerService.stop();
1:3653f81:             brokerService.waitUntilStopped();
1:3653f81:             brokerService = null;
1:3653f81:         }
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected String getQueueName() {
2:3653f81:         return getClass().getName() + "." + name.getMethodName();
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected String getTopicName() {
1:19c9404:         //wildcard characters are illegal in publish
1:19c9404:         //replace a + with something else, like _ which is allowed
1:19c9404:         return (getClass().getName() + "." + name.getMethodName()).replace("+", "_");
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected BrokerViewMBean getProxyToBroker() throws MalformedObjectNameException, JMSException {
1:3653f81:         ObjectName brokerViewMBean = new ObjectName(
1:3653f81:             "org.apache.activemq:type=Broker,brokerName=localhost");
1:3653f81:         BrokerViewMBean proxy = (BrokerViewMBean) brokerService.getManagementContext()
1:3653f81:                 .newProxyInstance(brokerViewMBean, BrokerViewMBean.class, true);
1:3653f81:         return proxy;
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected QueueViewMBean getProxyToQueue(String name) throws MalformedObjectNameException, JMSException {
1:3653f81:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName="+name);
1:3653f81:         QueueViewMBean proxy = (QueueViewMBean) brokerService.getManagementContext()
1:3653f81:                 .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:3653f81:         return proxy;
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected TopicViewMBean getProxyToTopic(String name) throws MalformedObjectNameException, JMSException {
1:3653f81:         ObjectName topicViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Topic,destinationName="+name);
1:3653f81:         TopicViewMBean proxy = (TopicViewMBean) brokerService.getManagementContext()
1:3653f81:                 .newProxyInstance(topicViewMBeanName, TopicViewMBean.class, true);
1:3653f81:         return proxy;
1:3653f81:     }
1:3653f81: 
1:3653f81:     /**
1:3653f81:      * Initialize an MQTTClientProvider instance.  By default this method uses the port that's
1:fb569e3:      * assigned to be the TCP based port using the base version of addMQTTConnector.  A subclass
1:3653f81:      * can either change the value of port or override this method to assign the correct port.
1:3653f81:      *
1:3653f81:      * @param provider
1:3653f81:      *        the MQTTClientProvider instance to initialize.
1:3653f81:      *
1:3653f81:      * @throws Exception if an error occurs during initialization.
1:3653f81:      */
1:3653f81:     protected void initializeConnection(MQTTClientProvider provider) throws Exception {
1:fb569e3:         if (!isUseSSL()) {
1:fb569e3:             provider.connect("tcp://localhost:" + port);
1:fb569e3:         } else {
1:6e2edf0:             // Setup SSL context...
1:6e2edf0:             File trustStore = new File(basedir(), "src/test/resources/server.keystore");
1:6e2edf0:             File keyStore = new File(basedir(), "src/test/resources/client.keystore");
1:6e2edf0: 
1:6e2edf0:             final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:6e2edf0:             sslContext.setKeyStore(keyStore.getCanonicalPath());
1:6e2edf0:             sslContext.setKeyStorePassword("password");
1:6e2edf0:             sslContext.setTrustStore(trustStore.getCanonicalPath());
1:6e2edf0:             sslContext.setTrustStorePassword("password");
1:6e2edf0:             sslContext.afterPropertiesSet();
1:6e2edf0: 
1:6e2edf0:             provider.setSslContext(sslContext.getSSLContext());
1:fb569e3:             provider.connect("ssl://localhost:" + port);
1:fb569e3:         }
1:3653f81:     }
1:3653f81: 
1:fb569e3:     public String getProtocolScheme() {
1:fb569e3:         return protocolScheme;
1:3653f81:     }
1:3653f81: 
1:fb569e3:     public void setProtocolScheme(String scheme) {
1:fb569e3:         this.protocolScheme = scheme;
1:fb569e3:     }
1:fb569e3: 
1:4b7131f:     public String getProtocolConfig() {
1:4b7131f:         return protocolConfig;
1:4b7131f:     }
1:4b7131f: 
1:4b7131f:     public void setProtocolConfig(String config) {
1:4b7131f:         this.protocolConfig = config;
1:4b7131f:     }
1:4b7131f: 
1:fb569e3:     public boolean isUseSSL() {
1:fb569e3:         return this.useSSL;
1:fb569e3:     }
1:fb569e3: 
1:fb569e3:     public void setUseSSL(boolean useSSL) {
1:fb569e3:         this.useSSL = useSSL;
1:fb569e3:     }
1:fb569e3: 
1:fb569e3:     public boolean isPersistent() {
1:fb569e3:         return persistent;
1:fb569e3:     }
1:fb569e3: 
1:fb569e3:     public int getPort() {
1:fb569e3:         return this.port;
1:fb569e3:     }
1:fb569e3: 
1:fb569e3:     public boolean isSchedulerSupportEnabled() {
1:3653f81:         return false;
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected static interface Task {
1:3653f81:         public void run() throws Exception;
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected  void within(int time, TimeUnit unit, Task task) throws InterruptedException {
1:3653f81:         long timeMS = unit.toMillis(time);
1:3653f81:         long deadline = System.currentTimeMillis() + timeMS;
1:3653f81:         while (true) {
1:3653f81:             try {
1:3653f81:                 task.run();
1:3653f81:                 return;
1:3653f81:             } catch (Throwable e) {
1:3653f81:                 long remaining = deadline - System.currentTimeMillis();
1:3653f81:                 if( remaining <=0 ) {
1:3653f81:                     if( e instanceof RuntimeException ) {
1:3653f81:                         throw (RuntimeException)e;
1:3653f81:                     }
1:3653f81:                     if( e instanceof Error ) {
1:3653f81:                         throw (Error)e;
1:3653f81:                     }
1:3653f81:                     throw new RuntimeException(e);
1:3653f81:                 }
1:3653f81:                 Thread.sleep(Math.min(timeMS/10, remaining));
1:3653f81:             }
1:3653f81:         }
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected MQTTClientProvider getMQTTClientProvider() {
1:c42b874:         return new FuseMQTTClientProvider();
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected MQTT createMQTTConnection() throws Exception {
1:3653f81:         return createMQTTConnection(null, false);
1:3653f81:     }
1:3653f81: 
1:3653f81:     protected MQTT createMQTTConnection(String clientId, boolean clean) throws Exception {
1:fb569e3:         if (isUseSSL()) {
1:fb569e3:             return createMQTTSslConnection(clientId, clean);
1:fb569e3:         } else {
1:fb569e3:             return createMQTTTcpConnection(clientId, clean);
1:fb569e3:         }
1:fb569e3:     }
1:fb569e3: 
1:fb569e3:     private MQTT createMQTTTcpConnection(String clientId, boolean clean) throws Exception {
1:3653f81:         MQTT mqtt = new MQTT();
1:3653f81:         mqtt.setConnectAttemptsMax(1);
1:3653f81:         mqtt.setReconnectAttemptsMax(0);
1:3653f81:         mqtt.setTracer(createTracer());
1:3653f81:         if (clientId != null) {
1:3653f81:             mqtt.setClientId(clientId);
1:3653f81:         }
1:3653f81:         mqtt.setCleanSession(clean);
1:3653f81:         mqtt.setHost("localhost", port);
1:3653f81:         return mqtt;
1:3653f81:     }
1:6e2edf0: 
1:fb569e3:     private MQTT createMQTTSslConnection(String clientId, boolean clean) throws Exception {
1:fb569e3:         MQTT mqtt = new MQTT();
1:fb569e3:         mqtt.setConnectAttemptsMax(1);
1:fb569e3:         mqtt.setReconnectAttemptsMax(0);
1:fb569e3:         mqtt.setTracer(createTracer());
1:fb569e3:         mqtt.setHost("ssl://localhost:" + port);
1:fb569e3:         if (clientId != null) {
1:fb569e3:             mqtt.setClientId(clientId);
1:fb569e3:         }
1:fb569e3:         mqtt.setCleanSession(clean);
1:6e2edf0: 
1:6e2edf0:         // Setup SSL context...
1:6e2edf0:         File trustStore = new File(basedir(), "src/test/resources/server.keystore");
1:6e2edf0:         File keyStore = new File(basedir(), "src/test/resources/client.keystore");
1:fb569e3: 
1:6e2edf0:         final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:6e2edf0:         sslContext.setKeyStore(keyStore.getCanonicalPath());
1:6e2edf0:         sslContext.setKeyStorePassword("password");
1:6e2edf0:         sslContext.setTrustStore(trustStore.getCanonicalPath());
1:6e2edf0:         sslContext.setTrustStorePassword("password");
1:6e2edf0:         sslContext.afterPropertiesSet();
1:fb569e3: 
1:6e2edf0:         mqtt.setSslContext(sslContext.getSSLContext());
1:fb569e3:         return mqtt;
1:fb569e3:     }
1:3653f81: 
1:3653f81:     protected Tracer createTracer() {
1:3653f81:         return new Tracer() {
1:fb569e3:             @Override
1:3653f81:             public void onReceive(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client Received:\n" + frame);
1:fb569e3:             }
1:fb569e3: 
1:fb569e3:             @Override
1:3653f81:             public void onSend(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client Sent:\n" + frame);
1:fb569e3:             }
1:3653f81: 
1:fb569e3:             @Override
1:3653f81:             public void debug(String message, Object... args) {
1:101b712:                 LOG.debug(String.format(message, args));
1:3653f81:             }
1:3653f81:         };
1:fb569e3:     }
1:3653f81: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:19c9404
/////////////////////////////////////////////////////////////////////////
1:         //wildcard characters are illegal in publish
1:         //replace a + with something else, like _ which is allowed
1:         return (getClass().getName() + "." + name.getMethodName()).replace("+", "_");
author:Timothy Bish
-------------------------------------------------------------------------------
commit:6e2edf0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // Setup SSL context...
1:             File trustStore = new File(basedir(), "src/test/resources/server.keystore");
1:             File keyStore = new File(basedir(), "src/test/resources/client.keystore");
1: 
1:             final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:             sslContext.setKeyStore(keyStore.getCanonicalPath());
1:             sslContext.setKeyStorePassword("password");
1:             sslContext.setTrustStore(trustStore.getCanonicalPath());
1:             sslContext.setTrustStorePassword("password");
1:             sslContext.afterPropertiesSet();
1: 
1:             provider.setSslContext(sslContext.getSSLContext());
/////////////////////////////////////////////////////////////////////////
1:         // Setup SSL context...
1:         File trustStore = new File(basedir(), "src/test/resources/server.keystore");
1:         File keyStore = new File(basedir(), "src/test/resources/client.keystore");
1: 
1:         final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:         sslContext.setKeyStore(keyStore.getCanonicalPath());
1:         sslContext.setKeyStorePassword("password");
1:         sslContext.setTrustStore(trustStore.getCanonicalPath());
1:         sslContext.setTrustStorePassword("password");
1:         sslContext.afterPropertiesSet();
1: 
1:         mqtt.setSslContext(sslContext.getSSLContext());
/////////////////////////////////////////////////////////////////////////
commit:455f1ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBStore;
/////////////////////////////////////////////////////////////////////////
1:     public static final String KAHADB_DIRECTORY = "target/activemq-data/";
1: 
/////////////////////////////////////////////////////////////////////////
1:     public String getTestName() {
/////////////////////////////////////////////////////////////////////////
1:         if (isPersistent()) {
1:             KahaDBStore kaha = new KahaDBStore();
1:             kaha.setDirectory(new File(KAHADB_DIRECTORY + getTestName()));
1:             brokerService.setPersistenceAdapter(kaha);
1:         }
commit:fd2805f
/////////////////////////////////////////////////////////////////////////
1:         brokerService = createBroker(true);
1:         configureBroker(brokerService);
1:         brokerService.start();
1:         brokerService.waitUntilStarted();
1:         port = brokerService.getTransportConnectorByName("mqtt").getConnectUri().getPort();
1:         jmsUri = brokerService.getTransportConnectorByName("openwire").getPublishableConnectString();
1:         cf = new ActiveMQConnectionFactory(jmsUri);
1:     }
1: 
1:     public void restartBroker() throws Exception {
1:         stopBroker();
1: 
1:         brokerService = createBroker(false);
1: 
1:         configureBroker(brokerService);
1: 
1:         brokerService.start();
1:         brokerService.waitUntilStarted();
1:         port = brokerService.getTransportConnectorByName("mqtt").getConnectUri().getPort();
1:         jmsUri = brokerService.getTransportConnectorByName("openwire").getPublishableConnectString();
1:         cf = new ActiveMQConnectionFactory(jmsUri);
1:     }
1: 
1:     protected BrokerService createBroker(boolean deleteAllMessages) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         brokerService.setPersistent(isPersistent());
1:         brokerService.setAdvisorySupport(false);
1:         brokerService.setUseJmx(true);
1:         brokerService.getManagementContext().setCreateConnector(false);
1:         brokerService.setSchedulerSupport(isSchedulerSupportEnabled());
1:         brokerService.setPopulateJMSXUserID(true);
1: 
1:         return brokerService;
1:     }
1: 
1:     protected void configureBroker(BrokerService brokerService) throws Exception {
1:         applyBrokerPolicies(brokerService);
1:         applyMemoryLimitPolicy(brokerService);
/////////////////////////////////////////////////////////////////////////
1:         addMQTTConnector(brokerService);
1:         addOpenWireConnector(brokerService);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected void applyBrokerPolicies(BrokerService brokerService) throws Exception {
1:     protected void applyMemoryLimitPolicy(BrokerService brokerService) throws Exception {
1:     protected void addOpenWireConnector(BrokerService brokerService) throws Exception {
1:         TransportConnector connector = new TransportConnector();
1:         connector.setUri(new URI("tcp://0.0.0.0:0"));
1:         connector.setName("openwire");
1:         brokerService.addConnector(connector);
1:     }
1: 
1:     protected void addMQTTConnector(BrokerService brokerService) throws Exception {
commit:101b712
/////////////////////////////////////////////////////////////////////////
0:         brokerService.setUseJmx(true);
0:         brokerService.getManagementContext().setCreateConnector(false);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client Received:\n" + frame);
1:                 LOG.debug("Client Sent:\n" + frame);
1:                 LOG.debug(String.format(message, args));
commit:4b7131f
/////////////////////////////////////////////////////////////////////////
1:         String protocolConfig = getProtocolConfig();
/////////////////////////////////////////////////////////////////////////
1:     public String getProtocolConfig() {
1:         return protocolConfig;
1:     }
1: 
1:     public void setProtocolConfig(String config) {
1:         this.protocolConfig = config;
1:     }
1: 
commit:829a186
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected String protocolScheme;
1:     protected boolean useSSL;
/////////////////////////////////////////////////////////////////////////
1:     public MQTTTestSupport(String connectorScheme, boolean useSSL) {
1:         this.useSSL = useSSL;
commit:619864d
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<BrokerPlugin> plugins = new ArrayList<BrokerPlugin>();
1:         createPlugins(plugins);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Allows a subclass to add additional broker plugins during the broker startup
1:      * process.  This method should not add Authorization or Authentication plugins
1:      * as those are handled by the configureAuthentication and configureAuthorization
1:      * methods later.
1:      *
1:      * @param plugins
1:      *        The List object to add Plugins for installation into the new Broker.
1:      *
1:      * @throws Exception if an error occurs during the plugin creation process.
1:      */
1:     protected void createPlugins(List<BrokerPlugin> plugins) throws Exception {
1:         // NOOP
1:     }
1: 
commit:fb569e3
/////////////////////////////////////////////////////////////////////////
0: import java.security.SecureRandom;
0: import java.security.cert.CertificateException;
0: import java.security.cert.X509Certificate;
0: import javax.net.ssl.KeyManager;
0: import javax.net.ssl.SSLContext;
0: import javax.net.ssl.TrustManager;
0: import javax.net.ssl.X509TrustManager;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.junit.runners.Parameterized.Parameter;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean persistent;
1:     protected String protocolConfig;
1: 
0:     @Parameter(0)
0:     public String protocolScheme;
1: 
0:     @Parameter(1)
0:     public boolean useSSL;
/////////////////////////////////////////////////////////////////////////
1:     public MQTTTestSupport() {
1:         this.protocolScheme = "mqtt";
1:         this.useSSL = false;
1:     }
0:     public MQTTTestSupport(String connectorScheme, boolean useSsl) {
1:         this.protocolScheme = connectorScheme;
0:         this.useSSL = useSsl;
/////////////////////////////////////////////////////////////////////////
1: 
1:         String basedir = basedir().getPath();
1:         System.setProperty("javax.net.ssl.trustStore", basedir + "/src/test/resources/client.keystore");
1:         System.setProperty("javax.net.ssl.trustStorePassword", "password");
1:         System.setProperty("javax.net.ssl.trustStoreType", "jks");
1:         System.setProperty("javax.net.ssl.keyStore", basedir + "/src/test/resources/server.keystore");
1:         System.setProperty("javax.net.ssl.keyStorePassword", "password");
1:         System.setProperty("javax.net.ssl.keyStoreType", "jks");
1: 
/////////////////////////////////////////////////////////////////////////
0:         brokerService.setSchedulerSupport(isSchedulerSupportEnabled());
1:         return null;
1:         return null;
/////////////////////////////////////////////////////////////////////////
1: 
1:         StringBuilder connectorURI = new StringBuilder();
1:         connectorURI.append(getProtocolScheme());
1:         connectorURI.append("://0.0.0.0:").append(port);
1:         if (protocolConfig != null && !protocolConfig.isEmpty()) {
1:             connectorURI.append("?").append(protocolConfig);
1:         }
1: 
0:         port = brokerService.addConnector(connectorURI.toString()).getConnectUri().getPort();
1:         LOG.info("Added connector {} to broker", getProtocolScheme());
/////////////////////////////////////////////////////////////////////////
1:      * assigned to be the TCP based port using the base version of addMQTTConnector.  A subclass
/////////////////////////////////////////////////////////////////////////
1:         if (!isUseSSL()) {
1:             provider.connect("tcp://localhost:" + port);
1:         } else {
0:             SSLContext ctx = SSLContext.getInstance("TLS");
0:             ctx.init(new KeyManager[0], new TrustManager[] { new DefaultTrustManager() }, new SecureRandom());
0:             provider.setSslContext(ctx);
1:             provider.connect("ssl://localhost:" + port);
1:         }
1:     public String getProtocolScheme() {
1:         return protocolScheme;
1:     public void setProtocolScheme(String scheme) {
1:         this.protocolScheme = scheme;
1:     }
1: 
1:     public boolean isUseSSL() {
1:         return this.useSSL;
1:     }
1: 
1:     public void setUseSSL(boolean useSSL) {
1:         this.useSSL = useSSL;
1:     }
1: 
1:     public boolean isPersistent() {
1:         return persistent;
1:     }
1: 
1:     public int getPort() {
1:         return this.port;
1:     }
1: 
1:     public boolean isSchedulerSupportEnabled() {
/////////////////////////////////////////////////////////////////////////
1:         if (isUseSSL()) {
1:             return createMQTTSslConnection(clientId, clean);
1:         } else {
1:             return createMQTTTcpConnection(clientId, clean);
1:         }
1:     }
1: 
1:     private MQTT createMQTTTcpConnection(String clientId, boolean clean) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     private MQTT createMQTTSslConnection(String clientId, boolean clean) throws Exception {
1:         MQTT mqtt = new MQTT();
1:         mqtt.setConnectAttemptsMax(1);
1:         mqtt.setReconnectAttemptsMax(0);
1:         mqtt.setTracer(createTracer());
1:         mqtt.setHost("ssl://localhost:" + port);
1:         if (clientId != null) {
1:             mqtt.setClientId(clientId);
1:         }
1:         mqtt.setCleanSession(clean);
1: 
0:         SSLContext ctx = SSLContext.getInstance("TLS");
0:         ctx.init(new KeyManager[0], new TrustManager[] { new DefaultTrustManager() }, new SecureRandom());
0:         mqtt.setSslContext(ctx);
1:         return mqtt;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     static class DefaultTrustManager implements X509TrustManager {
1: 
1:         @Override
0:         public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
1:         }
1: 
1:         @Override
0:         public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
1:         }
1: 
1:         @Override
0:         public X509Certificate[] getAcceptedIssuers() {
0:             return new X509Certificate[0];
1:         }
1:     }
commit:3653f81
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.transport.mqtt;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.LinkedList;
0: import java.util.List;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.JMSException;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.jmx.BrokerViewMBean;
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
1: import org.apache.activemq.broker.jmx.TopicViewMBean;
0: import org.apache.activemq.filter.DestinationMapEntry;
0: import org.apache.activemq.security.AuthenticationUser;
0: import org.apache.activemq.security.AuthorizationEntry;
0: import org.apache.activemq.security.AuthorizationPlugin;
0: import org.apache.activemq.security.DefaultAuthorizationMap;
0: import org.apache.activemq.security.SimpleAuthenticationPlugin;
0: import org.apache.activemq.security.TempDestinationAuthorizationEntry;
0: import org.apache.activemq.store.kahadb.scheduler.JobSchedulerStoreImpl;
1: import org.apache.activemq.transport.mqtt.util.ResourceLoadingSslContext;
1: import org.fusesource.mqtt.client.MQTT;
1: import org.fusesource.mqtt.client.Tracer;
1: import org.fusesource.mqtt.codec.MQTTFrame;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Rule;
1: import org.junit.rules.TestName;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class MQTTTestSupport {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(MQTTTestSupport.class);
1: 
1:     protected BrokerService brokerService;
1:     protected int port;
0:     protected int sslPort;
0:     protected int nioPort;
0:     protected int nioSslPort;
1:     protected String jmsUri = "vm://localhost";
1:     protected ActiveMQConnectionFactory cf;
1:     protected LinkedList<Throwable> exceptions = new LinkedList<Throwable>();
0:     protected int numberOfMessages;
1: 
1:     public static final int AT_MOST_ONCE = 0;
1:     public static final int AT_LEAST_ONCE = 1;
1:     public static final int EXACTLY_ONCE = 2;
1: 
1:     @Rule public TestName name = new TestName();
1: 
1:     public File basedir() throws IOException {
1:         ProtectionDomain protectionDomain = getClass().getProtectionDomain();
1:         return new File(new File(protectionDomain.getCodeSource().getLocation().getPath()), "../..").getCanonicalFile();
1:     }
1: 
0:     public static void main(String[] args) throws Exception {
0:         final MQTTTestSupport s = new MQTTTestSupport();
1: 
0:         s.sslPort = 5675;
0:         s.port = 5676;
0:         s.nioPort = 5677;
0:         s.nioSslPort = 5678;
1: 
0:         s.startBroker();
0:         while(true) {
0:             Thread.sleep(100000);
1:         }
1:     }
1: 
0:     public String getName() {
1:         return name.getMethodName();
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         exceptions.clear();
0:         numberOfMessages = 1000;
1:         startBroker();
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         stopBroker();
1:     }
1: 
1:     public void startBroker() throws Exception {
1: 
0:         createBroker();
1: 
0:         applyBrokerPolicies();
0:         applyMemoryLimitPolicy();
1: 
1:         // Setup SSL context...
1:         File keyStore = new File(basedir(), "src/test/resources/server.keystore");
1:         File trustStore = new File(basedir(), "src/test/resources/client.keystore");
1: 
1:         final ResourceLoadingSslContext sslContext = new ResourceLoadingSslContext();
1:         sslContext.setKeyStore(keyStore.getCanonicalPath());
1:         sslContext.setKeyStorePassword("password");
1:         sslContext.setTrustStore(trustStore.getCanonicalPath());
1:         sslContext.setTrustStorePassword("password");
1:         sslContext.afterPropertiesSet();
1:         brokerService.setSslContext(sslContext);
1: 
0:         ArrayList<BrokerPlugin> plugins = new ArrayList<BrokerPlugin>();
1: 
0:         addMQTTConnector();
0:         addOpenWireConnector();
1: 
0:         cf = new ActiveMQConnectionFactory(jmsUri);
1: 
1:         BrokerPlugin authenticationPlugin = configureAuthentication();
1:         if (authenticationPlugin != null) {
1:             plugins.add(configureAuthorization());
1:         }
1: 
1:         BrokerPlugin authorizationPlugin = configureAuthorization();
1:         if (authorizationPlugin != null) {
1:             plugins.add(configureAuthentication());
1:         }
1: 
1:         if (!plugins.isEmpty()) {
1:             BrokerPlugin[] array = new BrokerPlugin[plugins.size()];
1:             brokerService.setPlugins(plugins.toArray(array));
1:         }
1: 
0:         brokerService.start();
0:         brokerService.waitUntilStarted();
1:     }
1: 
0:     protected void applyMemoryLimitPolicy() throws Exception {
1:     }
1: 
0:     protected void createBroker() throws Exception {
0:         brokerService = new BrokerService();
0:         brokerService.setPersistent(isPersistent());
0:         brokerService.setAdvisorySupport(false);
0:         brokerService.setSchedulerSupport(true);
0:         brokerService.setPopulateJMSXUserID(true);
0:         brokerService.setSchedulerSupport(true);
1: 
0:         JobSchedulerStoreImpl jobStore = new JobSchedulerStoreImpl();
0:         jobStore.setDirectory(new File("activemq-data"));
1: 
0:         brokerService.setJobSchedulerStore(jobStore);
1:     }
1: 
1:     protected BrokerPlugin configureAuthentication() throws Exception {
0:         List<AuthenticationUser> users = new ArrayList<AuthenticationUser>();
0:         users.add(new AuthenticationUser("system", "manager", "users,admins"));
0:         users.add(new AuthenticationUser("user", "password", "users"));
0:         users.add(new AuthenticationUser("guest", "password", "guests"));
0:         SimpleAuthenticationPlugin authenticationPlugin = new SimpleAuthenticationPlugin(users);
1: 
0:         return authenticationPlugin;
1:     }
1: 
1:     protected BrokerPlugin configureAuthorization() throws Exception {
1: 
0:         @SuppressWarnings("rawtypes")
0:         List<DestinationMapEntry> authorizationEntries = new ArrayList<DestinationMapEntry>();
1: 
0:         AuthorizationEntry entry = new AuthorizationEntry();
0:         entry.setQueue(">");
0:         entry.setRead("admins");
0:         entry.setWrite("admins");
0:         entry.setAdmin("admins");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setQueue("USERS.>");
0:         entry.setRead("users");
0:         entry.setWrite("users");
0:         entry.setAdmin("users");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setQueue("GUEST.>");
0:         entry.setRead("guests");
0:         entry.setWrite("guests,users");
0:         entry.setAdmin("guests,users");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setTopic(">");
0:         entry.setRead("admins");
0:         entry.setWrite("admins");
0:         entry.setAdmin("admins");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setTopic("USERS.>");
0:         entry.setRead("users");
0:         entry.setWrite("users");
0:         entry.setAdmin("users");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setTopic("GUEST.>");
0:         entry.setRead("guests");
0:         entry.setWrite("guests,users");
0:         entry.setAdmin("guests,users");
0:         authorizationEntries.add(entry);
0:         entry = new AuthorizationEntry();
0:         entry.setTopic("ActiveMQ.Advisory.>");
0:         entry.setRead("guests,users");
0:         entry.setWrite("guests,users");
0:         entry.setAdmin("guests,users");
0:         authorizationEntries.add(entry);
1: 
0:         TempDestinationAuthorizationEntry tempEntry = new TempDestinationAuthorizationEntry();
0:         tempEntry.setRead("admins");
0:         tempEntry.setWrite("admins");
0:         tempEntry.setAdmin("admins");
1: 
0:         DefaultAuthorizationMap authorizationMap = new DefaultAuthorizationMap(authorizationEntries);
0:         authorizationMap.setTempDestinationAuthorizationEntry(tempEntry);
0:         AuthorizationPlugin authorizationPlugin = new AuthorizationPlugin(authorizationMap);
1: 
0:         return authorizationPlugin;
1:     }
1: 
0:     protected void applyBrokerPolicies() throws Exception {
1:         // NOOP here
1:     }
1: 
0:     protected void addOpenWireConnector() throws Exception {
0:         TransportConnector connector = brokerService.addConnector("tcp://0.0.0.0:0");
0:         jmsUri = connector.getPublishableConnectString();
1:     }
1: 
0:     protected void addMQTTConnector() throws Exception {
1:         // Overrides of this method can add additional configuration options or add multiple
1:         // MQTT transport connectors as needed, the port variable is always supposed to be
1:         // assigned the primary MQTT connector's port.
0:         TransportConnector connector = brokerService.addConnector(getProtocolScheme() + "://0.0.0.0:" + port);
0:         port = connector.getConnectUri().getPort();
1:     }
1: 
1:     public void stopBroker() throws Exception {
1:         if (brokerService != null) {
1:             brokerService.stop();
1:             brokerService.waitUntilStopped();
1:             brokerService = null;
1:         }
1:     }
1: 
1:     protected String getQueueName() {
1:         return getClass().getName() + "." + name.getMethodName();
1:     }
1: 
1:     protected String getTopicName() {
1:         return getClass().getName() + "." + name.getMethodName();
1:     }
1: 
1:     protected BrokerViewMBean getProxyToBroker() throws MalformedObjectNameException, JMSException {
1:         ObjectName brokerViewMBean = new ObjectName(
1:             "org.apache.activemq:type=Broker,brokerName=localhost");
1:         BrokerViewMBean proxy = (BrokerViewMBean) brokerService.getManagementContext()
1:                 .newProxyInstance(brokerViewMBean, BrokerViewMBean.class, true);
1:         return proxy;
1:     }
1: 
1:     protected QueueViewMBean getProxyToQueue(String name) throws MalformedObjectNameException, JMSException {
1:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName="+name);
1:         QueueViewMBean proxy = (QueueViewMBean) brokerService.getManagementContext()
1:                 .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:         return proxy;
1:     }
1: 
1:     protected TopicViewMBean getProxyToTopic(String name) throws MalformedObjectNameException, JMSException {
1:         ObjectName topicViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Topic,destinationName="+name);
1:         TopicViewMBean proxy = (TopicViewMBean) brokerService.getManagementContext()
1:                 .newProxyInstance(topicViewMBeanName, TopicViewMBean.class, true);
1:         return proxy;
1:     }
1: 
1:     /**
1:      * Initialize an MQTTClientProvider instance.  By default this method uses the port that's
0:      * assigned to be the TCP based port using the base version of addMQTTConnector.  A sbuclass
1:      * can either change the value of port or override this method to assign the correct port.
1:      *
1:      * @param provider
1:      *        the MQTTClientProvider instance to initialize.
1:      *
1:      * @throws Exception if an error occurs during initialization.
1:      */
1:     protected void initializeConnection(MQTTClientProvider provider) throws Exception {
0:         provider.connect("tcp://localhost:" + port);
1:     }
1: 
0:     protected String getProtocolScheme() {
0:         return "mqtt";
1:     }
1: 
0:     protected boolean isPersistent() {
1:         return false;
1:     }
1: 
1:     protected static interface Task {
1:         public void run() throws Exception;
1:     }
1: 
1:     protected  void within(int time, TimeUnit unit, Task task) throws InterruptedException {
1:         long timeMS = unit.toMillis(time);
1:         long deadline = System.currentTimeMillis() + timeMS;
1:         while (true) {
1:             try {
1:                 task.run();
1:                 return;
1:             } catch (Throwable e) {
1:                 long remaining = deadline - System.currentTimeMillis();
1:                 if( remaining <=0 ) {
1:                     if( e instanceof RuntimeException ) {
1:                         throw (RuntimeException)e;
1:                     }
1:                     if( e instanceof Error ) {
1:                         throw (Error)e;
1:                     }
1:                     throw new RuntimeException(e);
1:                 }
1:                 Thread.sleep(Math.min(timeMS/10, remaining));
1:             }
1:         }
1:     }
1: 
1:     protected MQTTClientProvider getMQTTClientProvider() {
0:         return new FuseMQQTTClientProvider();
1:     }
1: 
1:     protected MQTT createMQTTConnection() throws Exception {
1:         return createMQTTConnection(null, false);
1:     }
1: 
1:     protected MQTT createMQTTConnection(String clientId, boolean clean) throws Exception {
1:         MQTT mqtt = new MQTT();
1:         mqtt.setConnectAttemptsMax(1);
1:         mqtt.setReconnectAttemptsMax(0);
1:         mqtt.setTracer(createTracer());
1:         if (clientId != null) {
1:             mqtt.setClientId(clientId);
1:         }
1:         mqtt.setCleanSession(clean);
1:         mqtt.setHost("localhost", port);
1:         return mqtt;
1:     }
1: 
1:     protected Tracer createTracer() {
1:         return new Tracer() {
0:             @Override
1:             public void onReceive(MQTTFrame frame) {
0:                 LOG.info("Client Received:\n" + frame);
1:             }
1: 
0:             @Override
1:             public void onSend(MQTTFrame frame) {
0:                 LOG.info("Client Sent:\n" + frame);
1:             }
1: 
0:             @Override
1:             public void debug(String message, Object... args) {
0:                 LOG.info(String.format(message, args));
1:             }
1:         };
1:     }
1: }
author:Christian Posta
-------------------------------------------------------------------------------
commit:c42b874
/////////////////////////////////////////////////////////////////////////
1:         return new FuseMQTTClientProvider();
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:c99e2d8
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
/////////////////////////////////////////////////////////////////////////
0:         port = brokerService.getTransportConnectorByName("mqtt").getConnectUri().getPort();
/////////////////////////////////////////////////////////////////////////
1:         TransportConnector connector = new TransportConnector();
1:         connector.setUri(new URI(connectorURI.toString()));
1:         connector.setName("mqtt");
1:         brokerService.addConnector(connector);
0: 
============================================================================