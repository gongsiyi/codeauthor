6:9f0c86c: /**
1:9f0c86c:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9f0c86c:  * contributor license agreements.  See the NOTICE file distributed with
1:9f0c86c:  * this work for additional information regarding copyright ownership.
1:9f0c86c:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9f0c86c:  * (the "License"); you may not use this file except in compliance with
1:9f0c86c:  * the License.  You may obtain a copy of the License at
12:9f0c86c:  *
1:9f0c86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9f0c86c:  *
1:9f0c86c:  * Unless required by applicable law or agreed to in writing, software
1:9f0c86c:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9f0c86c:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9f0c86c:  * See the License for the specific language governing permissions and
1:9f0c86c:  * limitations under the License.
6:9f0c86c:  */
1:9f0c86c: package org.apache.activemq.usecases;
36:9f0c86c: 
1:9f0c86c: import javax.jms.Connection;
1:9f0c86c: import javax.jms.DeliveryMode;
1:9f0c86c: import javax.jms.MessageConsumer;
1:9f0c86c: import javax.jms.MessageProducer;
1:9f0c86c: import javax.jms.Queue;
1:9f0c86c: import javax.jms.Session;
1:9f0c86c: import javax.jms.TextMessage;
1:9f0c86c: 
1:9f0c86c: import org.apache.activemq.broker.BrokerService;
1:9f0c86c: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:9f0c86c: import org.apache.activemq.broker.region.policy.PolicyMap;
1:9f0c86c: 
1:9f0c86c: /**
1:4743a20:  * Test case intended to demonstrate delivery interruption to queue consumers when a JMS selector leaves some messages
1:4743a20:  * on the queue (due to use of a JMS Selector)
1:4743a20:  *
1:4743a20:  * testNonDiscriminatingConsumer() demonstrates proper functionality for consumers that don't use a selector to qualify
1:4743a20:  * their input.
1:4743a20:  *
1:4743a20:  * testDiscriminatingConsumer() demonstrates the failure condition in which delivery to the consumer eventually halts.
1:4743a20:  *
1:4743a20:  * The expected behavior is for the delivery to the client to be maintained regardless of the depth of the queue,
1:4743a20:  * particularly when the messages in the queue do not meet the selector criteria of the client.
1:9f0c86c:  *
1:9f0c86c:  * https://issues.apache.org/activemq/browse/AMQ-2217
1:4743a20:  *
1:9f0c86c:  */
1:9f0c86c: public class DiscriminatingConsumerLoadTest extends TestSupport {
1:9f0c86c: 
1:4743a20:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(DiscriminatingConsumerLoadTest.class);
1:9f0c86c: 
1:4743a20:     private Connection producerConnection;
1:4743a20:     private Connection consumerConnection;
1:9f0c86c: 
1:4743a20:     public static final String JMSTYPE_EATME = "DiscriminatingLoadClient.EatMe";
1:4743a20:     public static final String JMSTYPE_IGNOREME = "DiscriminatingLoadClient.IgnoreMe";
1:4743a20: 
1:4743a20:     private final int testSize = 5000; // setting this to a small number will pass all tests
1:9f0c86c: 
1:9f0c86c:     BrokerService broker;
1:9f0c86c: 
1:4743a20:     @Override
1:4743a20:     protected void setUp() throws Exception {
1:9f0c86c:         broker = new BrokerService();
1:9f0c86c:         broker.setPersistent(false);
1:9f0c86c: 
1:9f0c86c:         // workaround is to ensure sufficient dispatch buffer for the destination
1:9f0c86c:         PolicyMap policyMap = new PolicyMap();
1:9f0c86c:         PolicyEntry defaultPolicy = new PolicyEntry();
1:9f0c86c:         defaultPolicy.setMaxPageSize(testSize);
1:9f0c86c:         policyMap.setDefaultEntry(defaultPolicy);
1:9f0c86c:         broker.setDestinationPolicy(policyMap);
1:9f0c86c:         broker.start();
1:9f0c86c: 
1:4743a20:         super.setUp();
1:4743a20:         this.producerConnection = this.createConnection();
1:4743a20:         this.consumerConnection = this.createConnection();
1:4743a20:     }
1:9f0c86c: 
1:4743a20:     /**
1:4743a20:      * @see junit.framework.TestCase#tearDown()
1:4743a20:      */
1:4743a20:     @Override
1:4743a20:     protected void tearDown() throws Exception {
1:4743a20:         if (producerConnection != null) {
1:4743a20:             producerConnection.close();
1:4743a20:             producerConnection = null;
24:9f0c86c:         }
1:4743a20:         if (consumerConnection != null) {
1:4743a20:             consumerConnection.close();
1:4743a20:             consumerConnection = null;
1:4743a20:         }
1:4743a20:         super.tearDown();
1:4743a20:         broker.stop();
1:4743a20:     }
1:4743a20: 
1:4743a20:     /**
1:4743a20:      * Test to check if a single consumer with no JMS selector will receive all intended messages
1:4743a20:      *
1:4743a20:      * @throws java.lang.Exception
1:4743a20:      */
1:4743a20:     public void testNonDiscriminatingConsumer() throws Exception {
1:4743a20: 
1:4743a20:         consumerConnection = createConnection();
1:4743a20:         consumerConnection.start();
1:4743a20:         LOG.info("consumerConnection = " + consumerConnection);
1:4743a20: 
1:4743a20:         try {
1:4743a20:             Thread.sleep(1000);
1:4743a20:         } catch (Exception e) {
1:4743a20:         }
1:4743a20: 
1:4743a20:         // here we pass in null for the JMS selector
1:4743a20:         Consumer consumer = new Consumer(consumerConnection, null);
1:4743a20:         Thread consumerThread = new Thread(consumer);
1:4743a20: 
1:4743a20:         consumerThread.start();
1:4743a20: 
1:4743a20:         producerConnection = createConnection();
1:4743a20:         producerConnection.start();
1:4743a20:         LOG.info("producerConnection = " + producerConnection);
1:4743a20: 
1:4743a20:         try {
1:4743a20:             Thread.sleep(3000);
1:4743a20:         } catch (Exception e) {
1:4743a20:         }
1:4743a20: 
1:4743a20:         Producer producer = new Producer(producerConnection);
1:4743a20:         Thread producerThread = new Thread(producer);
1:4743a20:         producerThread.start();
1:4743a20: 
1:4743a20:         // now that everything is running, let's wait for the consumer thread to finish ...
1:4743a20:         consumerThread.join();
1:4743a20:         producer.stop = true;
1:4743a20: 
1:4743a20:         if (consumer.getCount() == testSize)
1:4743a20:             LOG.info("test complete .... all messsages consumed!!");
3:9f0c86c:         else
1:4743a20:             LOG.info("test failed .... Sent " + (testSize / 1) + " messages intended to be consumed ( " + testSize + " total), but only consumed "
1:4743a20:                 + consumer.getCount());
1:9f0c86c: 
1:4743a20:         assertTrue("Sent " + testSize + " messages intended to be consumed, but only consumed " + consumer.getCount(), (consumer.getCount() == testSize));
1:4743a20:         assertFalse("Delivery of messages to consumer was halted during this test", consumer.deliveryHalted());
1:4743a20:     }
1:9f0c86c: 
1:4743a20:     /**
1:4743a20:      * Test to check if a single consumer with a JMS selector will receive all intended messages
1:4743a20:      *
1:4743a20:      * @throws java.lang.Exception
1:4743a20:      */
1:4743a20:     public void testDiscriminatingConsumer() throws Exception {
1:9f0c86c: 
1:4743a20:         consumerConnection = createConnection();
1:4743a20:         consumerConnection.start();
1:4743a20:         LOG.info("consumerConnection = " + consumerConnection);
1:9f0c86c: 
1:4743a20:         try {
1:4743a20:             Thread.sleep(1000);
1:4743a20:         } catch (Exception e) {
1:4743a20:         }
1:9f0c86c: 
1:4743a20:         // here we pass the JMS selector we intend to consume
1:4743a20:         Consumer consumer = new Consumer(consumerConnection, JMSTYPE_EATME);
1:4743a20:         Thread consumerThread = new Thread(consumer);
1:9f0c86c: 
1:4743a20:         consumerThread.start();
1:9f0c86c: 
1:4743a20:         producerConnection = createConnection();
1:4743a20:         producerConnection.start();
1:4743a20:         LOG.info("producerConnection = " + producerConnection);
1:9f0c86c: 
1:4743a20:         try {
1:4743a20:             Thread.sleep(3000);
1:4743a20:         } catch (Exception e) {
1:4743a20:         }
1:9f0c86c: 
1:4743a20:         Producer producer = new Producer(producerConnection);
1:4743a20:         Thread producerThread = new Thread(producer);
1:4743a20:         producerThread.start();
1:9f0c86c: 
1:4743a20:         // now that everything is running, let's wait for the consumer thread to finish ...
1:4743a20:         consumerThread.join();
1:4743a20:         producer.stop = true;
1:9f0c86c: 
1:4743a20:         if (consumer.getCount() == (testSize / 2)) {
1:4743a20:             LOG.info("test complete .... all messsages consumed!!");
1:4743a20:         } else {
1:4743a20:             LOG.info("test failed .... Sent " + testSize + " original messages, only half of which (" + (testSize / 2)
1:4743a20:                 + ") were intended to be consumed: consumer paused at: " + consumer.getCount());
1:4743a20:             // System.out.println("test failed .... Sent " + testSize + " original messages, only half of which (" +
1:4743a20:             // (testSize / 2) +
1:4743a20:             // ") were intended to be consumed: consumer paused at: " + consumer.getCount());
1:4743a20: 
1:4743a20:         }
1:4743a20: 
1:4743a20:         assertTrue("Sent " + testSize + " original messages, only half of which (" + (testSize / 2) + ") were intended to be consumed: consumer paused at: "
1:4743a20:             + consumer.getCount(), (consumer.getCount() == (testSize / 2)));
1:4743a20:         assertTrue("Delivery of messages to consumer was halted during this test as it only wants half", consumer.deliveryHalted());
1:4743a20:     }
1:4743a20: 
1:4743a20:     /**
1:4743a20:      * Helper class that will publish 2 * testSize messages. The messages will be distributed evenly between the
1:4743a20:      * following two JMS types:
1:4743a20:      *
1:4743a20:      * @see JMSTYPE_INTENDED_FOR_CONSUMPTION
1:4743a20:      * @see JMSTYPE_NOT_INTENDED_FOR_CONSUMPTION
1:4743a20:      *
1:4743a20:      */
1:4743a20:     private class Producer extends Thread {
1:4743a20:         private int counterSent = 0;
1:4743a20:         private Connection connection = null;
1:4743a20:         public boolean stop = false;
1:4743a20: 
1:4743a20:         public Producer(Connection connection) {
1:4743a20:             this.connection = connection;
1:4743a20:         }
1:4743a20: 
1:4743a20:         @Override
1:4743a20:         public void run() {
1:4743a20:             try {
1:4743a20:                 final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4743a20:                 final Queue queue = session.createQueue("test");
1:4743a20: 
1:4743a20:                 // wait for 10 seconds to allow consumer.receive to be run
1:4743a20:                 // first
1:4743a20:                 Thread.sleep(10000);
1:4743a20:                 MessageProducer producer = session.createProducer(queue);
1:4743a20: 
1:4743a20:                 while (!stop && (counterSent < testSize)) {
1:4743a20:                     // first send a message intended to be consumed ....
1:4743a20:                     TextMessage message = session.createTextMessage("*** Ill ....... Ini ***"); // alma mater ...
1:4743a20:                     message.setJMSType(JMSTYPE_EATME);
1:4743a20:                     // LOG.info("sending .... JMSType = " + message.getJMSType());
1:4743a20:                     producer.send(message, DeliveryMode.NON_PERSISTENT, 0, 1800000);
1:4743a20: 
1:4743a20:                     counterSent++;
1:4743a20: 
1:4743a20:                     // now send a message intended to be consumed by some other consumer in the the future
1:4743a20:                     // ... we expect these messages to accrue in the queue
1:4743a20:                     message = session.createTextMessage("*** Ill ....... Ini ***"); // alma mater ...
1:4743a20:                     message.setJMSType(JMSTYPE_IGNOREME);
1:4743a20:                     // LOG.info("sending .... JMSType = " + message.getJMSType());
1:4743a20:                     producer.send(message, DeliveryMode.NON_PERSISTENT, 0, 1800000);
1:4743a20: 
1:4743a20:                     counterSent++;
1:4743a20:                 }
1:4743a20: 
1:4743a20:                 session.close();
1:4743a20: 
1:4743a20:             } catch (Exception e) {
1:4743a20:                 e.printStackTrace();
1:4743a20:             }
1:4743a20:             LOG.info("producer thread complete ... " + counterSent + " messages sent to the queue");
1:4743a20:         }
1:4743a20:     }
1:4743a20: 
1:4743a20:     /**
1:4743a20:      * Helper class that will consume messages from the queue based on the supplied JMS selector. Thread will stop after
1:4743a20:      * the first receive(..) timeout, or once all expected messages have been received (see testSize). If the thread
1:4743a20:      * stops due to a timeout, it is experiencing the delivery pause that is symptomatic of a bug in the broker.
1:4743a20:      *
1:4743a20:      */
1:4743a20:     private class Consumer extends Thread {
1:4743a20:         protected int counterReceived = 0;
1:4743a20:         private String jmsSelector = null;
1:4743a20:         private boolean deliveryHalted = false;
1:4743a20: 
1:4743a20:         public Consumer(Connection connection, String jmsSelector) {
1:4743a20:             this.jmsSelector = jmsSelector;
1:4743a20:         }
1:4743a20: 
1:4743a20:         @Override
1:4743a20:         public void run() {
1:4743a20:             try {
1:4743a20:                 Session session = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4743a20:                 final Queue queue = session.createQueue("test");
1:4743a20:                 MessageConsumer consumer = null;
1:4743a20:                 if (null != this.jmsSelector) {
1:4743a20:                     consumer = session.createConsumer(queue, "JMSType='" + this.jmsSelector + "'");
1:4743a20:                 } else {
1:4743a20:                     consumer = session.createConsumer(queue);
1:4743a20:                 }
1:4743a20: 
1:4743a20:                 while (!deliveryHalted && (counterReceived < testSize)) {
1:4743a20:                     TextMessage result = (TextMessage) consumer.receive(30000);
1:4743a20:                     if (result != null) {
1:4743a20:                         counterReceived++;
1:4743a20:                         // System.out.println("consuming .... JMSType = " + result.getJMSType() + " received = " +
1:4743a20:                         // counterReceived);
1:4743a20:                         LOG.info("consuming .... JMSType = " + result.getJMSType() + " received = " + counterReceived);
1:4743a20:                     } else {
1:4743a20:                         LOG.info("consuming .... timeout while waiting for a message ... broker must have stopped delivery ...  received = " + counterReceived);
1:4743a20:                         deliveryHalted = true;
1:4743a20:                     }
1:4743a20:                 }
1:4743a20:                 session.close();
1:4743a20:             } catch (Exception e) {
1:4743a20:                 e.printStackTrace();
1:4743a20:             }
1:4743a20: 
1:4743a20:         }
1:4743a20: 
1:4743a20:         public int getCount() {
1:4743a20:             return this.counterReceived;
1:4743a20:         }
1:4743a20: 
1:4743a20:         public boolean deliveryHalted() {
1:4743a20:             return this.deliveryHalted;
1:4743a20:         }
1:4743a20:     }
1:9f0c86c: 
1:9f0c86c: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1:  * Test case intended to demonstrate delivery interruption to queue consumers when a JMS selector leaves some messages
1:  * on the queue (due to use of a JMS Selector)
1:  *
1:  * testNonDiscriminatingConsumer() demonstrates proper functionality for consumers that don't use a selector to qualify
1:  * their input.
1:  *
1:  * testDiscriminatingConsumer() demonstrates the failure condition in which delivery to the consumer eventually halts.
1:  *
1:  * The expected behavior is for the delivery to the client to be maintained regardless of the depth of the queue,
1:  * particularly when the messages in the queue do not meet the selector criteria of the client.
1:  *
1:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(DiscriminatingConsumerLoadTest.class);
1:     private Connection producerConnection;
1:     private Connection consumerConnection;
1:     public static final String JMSTYPE_EATME = "DiscriminatingLoadClient.EatMe";
1:     public static final String JMSTYPE_IGNOREME = "DiscriminatingLoadClient.IgnoreMe";
1: 
1:     private final int testSize = 5000; // setting this to a small number will pass all tests
1:     @Override
1:     protected void setUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         super.setUp();
1:         this.producerConnection = this.createConnection();
1:         this.consumerConnection = this.createConnection();
1:     }
1:     /**
1:      * @see junit.framework.TestCase#tearDown()
1:      */
1:     @Override
1:     protected void tearDown() throws Exception {
1:         if (producerConnection != null) {
1:             producerConnection.close();
1:             producerConnection = null;
1:         if (consumerConnection != null) {
1:             consumerConnection.close();
1:             consumerConnection = null;
1:         }
1:         super.tearDown();
1:         broker.stop();
1:     }
1: 
1:     /**
1:      * Test to check if a single consumer with no JMS selector will receive all intended messages
1:      *
1:      * @throws java.lang.Exception
1:      */
1:     public void testNonDiscriminatingConsumer() throws Exception {
1: 
1:         consumerConnection = createConnection();
1:         consumerConnection.start();
1:         LOG.info("consumerConnection = " + consumerConnection);
1: 
1:         try {
1:             Thread.sleep(1000);
1:         } catch (Exception e) {
1:         }
1: 
1:         // here we pass in null for the JMS selector
1:         Consumer consumer = new Consumer(consumerConnection, null);
1:         Thread consumerThread = new Thread(consumer);
1: 
1:         consumerThread.start();
1: 
1:         producerConnection = createConnection();
1:         producerConnection.start();
1:         LOG.info("producerConnection = " + producerConnection);
1: 
1:         try {
1:             Thread.sleep(3000);
1:         } catch (Exception e) {
1:         }
1: 
1:         Producer producer = new Producer(producerConnection);
1:         Thread producerThread = new Thread(producer);
1:         producerThread.start();
1: 
1:         // now that everything is running, let's wait for the consumer thread to finish ...
1:         consumerThread.join();
1:         producer.stop = true;
1: 
1:         if (consumer.getCount() == testSize)
1:             LOG.info("test complete .... all messsages consumed!!");
1:             LOG.info("test failed .... Sent " + (testSize / 1) + " messages intended to be consumed ( " + testSize + " total), but only consumed "
1:                 + consumer.getCount());
1:         assertTrue("Sent " + testSize + " messages intended to be consumed, but only consumed " + consumer.getCount(), (consumer.getCount() == testSize));
1:         assertFalse("Delivery of messages to consumer was halted during this test", consumer.deliveryHalted());
1:     }
1:     /**
1:      * Test to check if a single consumer with a JMS selector will receive all intended messages
1:      *
1:      * @throws java.lang.Exception
1:      */
1:     public void testDiscriminatingConsumer() throws Exception {
1:         consumerConnection = createConnection();
1:         consumerConnection.start();
1:         LOG.info("consumerConnection = " + consumerConnection);
1:         try {
1:             Thread.sleep(1000);
1:         } catch (Exception e) {
1:         }
1:         // here we pass the JMS selector we intend to consume
1:         Consumer consumer = new Consumer(consumerConnection, JMSTYPE_EATME);
1:         Thread consumerThread = new Thread(consumer);
1:         consumerThread.start();
1:         producerConnection = createConnection();
1:         producerConnection.start();
1:         LOG.info("producerConnection = " + producerConnection);
1:         try {
1:             Thread.sleep(3000);
1:         } catch (Exception e) {
1:         }
1:         Producer producer = new Producer(producerConnection);
1:         Thread producerThread = new Thread(producer);
1:         producerThread.start();
1:         // now that everything is running, let's wait for the consumer thread to finish ...
1:         consumerThread.join();
1:         producer.stop = true;
1:         if (consumer.getCount() == (testSize / 2)) {
1:             LOG.info("test complete .... all messsages consumed!!");
1:         } else {
1:             LOG.info("test failed .... Sent " + testSize + " original messages, only half of which (" + (testSize / 2)
1:                 + ") were intended to be consumed: consumer paused at: " + consumer.getCount());
1:             // System.out.println("test failed .... Sent " + testSize + " original messages, only half of which (" +
1:             // (testSize / 2) +
1:             // ") were intended to be consumed: consumer paused at: " + consumer.getCount());
1: 
1:         }
1: 
1:         assertTrue("Sent " + testSize + " original messages, only half of which (" + (testSize / 2) + ") were intended to be consumed: consumer paused at: "
1:             + consumer.getCount(), (consumer.getCount() == (testSize / 2)));
1:         assertTrue("Delivery of messages to consumer was halted during this test as it only wants half", consumer.deliveryHalted());
1:     }
1: 
1:     /**
1:      * Helper class that will publish 2 * testSize messages. The messages will be distributed evenly between the
1:      * following two JMS types:
1:      *
1:      * @see JMSTYPE_INTENDED_FOR_CONSUMPTION
1:      * @see JMSTYPE_NOT_INTENDED_FOR_CONSUMPTION
1:      *
1:      */
1:     private class Producer extends Thread {
1:         private int counterSent = 0;
1:         private Connection connection = null;
1:         public boolean stop = false;
1: 
1:         public Producer(Connection connection) {
1:             this.connection = connection;
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 final Queue queue = session.createQueue("test");
1: 
1:                 // wait for 10 seconds to allow consumer.receive to be run
1:                 // first
1:                 Thread.sleep(10000);
1:                 MessageProducer producer = session.createProducer(queue);
1: 
1:                 while (!stop && (counterSent < testSize)) {
1:                     // first send a message intended to be consumed ....
1:                     TextMessage message = session.createTextMessage("*** Ill ....... Ini ***"); // alma mater ...
1:                     message.setJMSType(JMSTYPE_EATME);
1:                     // LOG.info("sending .... JMSType = " + message.getJMSType());
1:                     producer.send(message, DeliveryMode.NON_PERSISTENT, 0, 1800000);
1: 
1:                     counterSent++;
1: 
1:                     // now send a message intended to be consumed by some other consumer in the the future
1:                     // ... we expect these messages to accrue in the queue
1:                     message = session.createTextMessage("*** Ill ....... Ini ***"); // alma mater ...
1:                     message.setJMSType(JMSTYPE_IGNOREME);
1:                     // LOG.info("sending .... JMSType = " + message.getJMSType());
1:                     producer.send(message, DeliveryMode.NON_PERSISTENT, 0, 1800000);
1: 
1:                     counterSent++;
1:                 }
1: 
1:                 session.close();
1: 
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:             }
1:             LOG.info("producer thread complete ... " + counterSent + " messages sent to the queue");
1:         }
1:     }
1: 
1:     /**
1:      * Helper class that will consume messages from the queue based on the supplied JMS selector. Thread will stop after
1:      * the first receive(..) timeout, or once all expected messages have been received (see testSize). If the thread
1:      * stops due to a timeout, it is experiencing the delivery pause that is symptomatic of a bug in the broker.
1:      *
1:      */
1:     private class Consumer extends Thread {
1:         protected int counterReceived = 0;
1:         private String jmsSelector = null;
1:         private boolean deliveryHalted = false;
1: 
1:         public Consumer(Connection connection, String jmsSelector) {
1:             this.jmsSelector = jmsSelector;
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 Session session = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 final Queue queue = session.createQueue("test");
1:                 MessageConsumer consumer = null;
1:                 if (null != this.jmsSelector) {
1:                     consumer = session.createConsumer(queue, "JMSType='" + this.jmsSelector + "'");
1:                 } else {
1:                     consumer = session.createConsumer(queue);
1:                 }
1: 
1:                 while (!deliveryHalted && (counterReceived < testSize)) {
1:                     TextMessage result = (TextMessage) consumer.receive(30000);
1:                     if (result != null) {
1:                         counterReceived++;
1:                         // System.out.println("consuming .... JMSType = " + result.getJMSType() + " received = " +
1:                         // counterReceived);
1:                         LOG.info("consuming .... JMSType = " + result.getJMSType() + " received = " + counterReceived);
1:                     } else {
1:                         LOG.info("consuming .... timeout while waiting for a message ... broker must have stopped delivery ...  received = " + counterReceived);
1:                         deliveryHalted = true;
1:                     }
1:                 }
1:                 session.close();
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:             }
1: 
1:         }
1: 
1:         public int getCount() {
1:             return this.counterReceived;
1:         }
1: 
1:         public boolean deliveryHalted() {
1:             return this.deliveryHalted;
1:         }
1:     }
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:9f0c86c
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.JmsConnectionStartStopTest;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: 
1: /**
0:  * Test case intended to demonstrate delivery interruption to queue consumers when
0:  * a JMS selector leaves some messages on the queue (due to use of a JMS Selector)
1:  * 
0:  * testNonDiscriminatingConsumer() demonstrates proper functionality for consumers that don't use
0:  * a selector to qualify their input.
1:  * 
0:  * testDiscriminatingConsumer() demonstrates the failure condition in which delivery to the consumer
0:  * eventually halts.
1:  * 
0:  * The expected behavior is for the delivery to the client to be maintained regardless of the depth
0:  * of the queue, particularly when the messages in the queue do not meet the selector criteria of the
0:  * client.
1:  *
1:  * https://issues.apache.org/activemq/browse/AMQ-2217
1:  * 
1:  */
1: public class DiscriminatingConsumerLoadTest extends TestSupport {
1: 
0: 	private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory
0: 	.getLog(DiscriminatingConsumerLoadTest.class);
1: 
0: 	private Connection producerConnection;
0: 	private Connection consumerConnection;
0: 	private int counterSent = 0;
0: 	private int counterReceived = 0;
1: 	
0: 	public static final String JMSTYPE_EATME		= "DiscriminatingLoadClient.EatMe";
0: 	public static final String JMSTYPE_IGNOREME 	= "DiscriminatingLoadClient.IgnoreMe";
1: 
0: 	private int testSize = 5000; // setting this to a small number will pass all tests
1: 
1:     BrokerService broker;
1: 
0: 	protected void setUp() throws Exception {
1:         broker = new BrokerService();
1:         broker.setPersistent(false);
1: 
1:         // workaround is to ensure sufficient dispatch buffer for the destination
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultPolicy = new PolicyEntry();
1:         defaultPolicy.setMaxPageSize(testSize);
1:         policyMap.setDefaultEntry(defaultPolicy);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.start();
1: 
0: 		super.setUp();
0: 		this.producerConnection = this.createConnection();
0: 		this.consumerConnection = this.createConnection();
1: 	}
1: 
1: 	/**
0: 	 * @see junit.framework.TestCase#tearDown()
1: 	 */
0: 	protected void tearDown() throws Exception {
0: 		if (producerConnection != null) {
0: 			producerConnection.close();
0: 			producerConnection = null;
1: 		}
0: 		if (consumerConnection != null) {
0: 			consumerConnection.close();
0: 			consumerConnection = null;
1: 		}
0: 		super.tearDown();
0:         broker.stop();
1: 	}
1: 
1: 	/**
0: 	 * Test to check if a single consumer with no JMS selector will receive all intended messages
1: 	 * 
0: 	 * @throws java.lang.Exception
1: 	 */
0: 	public void testNonDiscriminatingConsumer() throws Exception {
1: 		
0: 		consumerConnection = createConnection();
0: 		consumerConnection.start();
0: 		LOG.info("consumerConnection = " +consumerConnection);
1: 
0: 		try {Thread.sleep(1000); } catch (Exception e) {}
1: 
0: 		// here we pass in null for the JMS selector
0: 		Consumer consumer = new Consumer(consumerConnection, null);
0: 		Thread consumerThread = new Thread(consumer);
1: 
0: 		consumerThread.start();
1: 
0: 		producerConnection = createConnection();
0: 		producerConnection.start();
0: 		LOG.info("producerConnection = " +producerConnection);
1: 
0: 		try {Thread.sleep(3000); } catch (Exception e) {}
1: 
0: 		Producer producer = new Producer(producerConnection);
0: 		Thread producerThread = new Thread(producer);
0: 		producerThread.start();
1: 
0: 		// now that everything is running, let's wait for the consumer thread to finish ...
0: 		consumerThread.join();
0: 		producer.stop = true;
1: 
0: 		if (consumer.getCount() == testSize )
0: 			LOG.info("test complete .... all messsages consumed!!");
1: 		else
0: 			LOG.info("test failed .... Sent " + (testSize / 1) + 
0: 					" messages intended to be consumed ( " + testSize + " total), but only consumed " + consumer.getCount());
1: 
1: 
0: 		assertTrue("Sent " + testSize + " messages intended to be consumed, but only consumed " + consumer.getCount(),
0: 				(consumer.getCount() == testSize ));
0: 		assertFalse("Delivery of messages to consumer was halted during this test", consumer.deliveryHalted());
1: 
1: 
1: 	}
1: 	
1: 	/**
0: 	 * Test to check if a single consumer with a JMS selector will receive all intended messages
1: 	 * 
0: 	 * @throws java.lang.Exception
1: 	 */
0: 	public void testDiscriminatingConsumer() throws Exception {
1: 
0: 		consumerConnection = createConnection();
0: 		consumerConnection.start();
0: 		LOG.info("consumerConnection = " +consumerConnection);
1: 
0: 		try {Thread.sleep(1000); } catch (Exception e) {}
1: 
0: 		// here we pass the JMS selector we intend to consume
0: 		Consumer consumer = new Consumer(consumerConnection, JMSTYPE_EATME);
0: 		Thread consumerThread = new Thread(consumer);
1: 
0: 		consumerThread.start();
1: 
0: 		producerConnection = createConnection();
0: 		producerConnection.start();
0: 		LOG.info("producerConnection = " +producerConnection);
1: 
0: 		try {Thread.sleep(3000); } catch (Exception e) {}
1: 
0: 		Producer producer = new Producer(producerConnection);
0: 		Thread producerThread = new Thread(producer);
0: 		producerThread.start();
1: 
0: 		// now that everything is running, let's wait for the consumer thread to finish ...
0: 		consumerThread.join();
0: 		producer.stop = true;
1: 
0: 		if (consumer.getCount() == (testSize / 2))
0:         {
0: 			LOG.info("test complete .... all messsages consumed!!");
1:         }
1:         else
0: 		{
0: 			LOG.info("test failed .... Sent " + testSize  + " original messages, only half of which (" + (testSize / 2) + 
0: 					") were intended to be consumed: consumer paused at: " + consumer.getCount());
0: 			//System.out.println("test failed .... Sent " + testSize  + " original messages, only half of which (" + (testSize / 2) +
0: 			//		") were intended to be consumed: consumer paused at: " + consumer.getCount());
1: 			
1: 		}
1: 			
0: 		assertTrue("Sent " + testSize  + " original messages, only half of which (" + (testSize / 2) + 
0: 					") were intended to be consumed: consumer paused at: " + consumer.getCount(),
0: 				(consumer.getCount() == (testSize / 2)));
0: 		assertTrue("Delivery of messages to consumer was halted during this test as it only wants half", consumer.deliveryHalted());
1: 	}
1: 	
1: 	/**
0: 	 * Helper class that will publish 2 * testSize messages.  The messages will be distributed evenly
0: 	 * between the following two JMS types:
1: 	 * 
0: 	 * @see JMSTYPE_INTENDED_FOR_CONSUMPTION
0: 	 * @see JMSTYPE_NOT_INTENDED_FOR_CONSUMPTION
1: 	 * 
0: 	 * @author jlyons
1: 	 *
1: 	 */
0: 	private class Producer extends Thread 
0: 	{
0: 		private int counterSent = 0;
0: 		private Connection connection = null;
0: 		public boolean stop = false;
1: 
0: 		public Producer(Connection connection)
0: 		{
0: 			this.connection = connection;
1: 		}
1: 
0: 		public void run() {
0: 			try {
0: 				final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 				final Queue queue = session.createQueue("test");
1: 
0: 				// wait for 10 seconds to allow consumer.receive to be run
0: 				// first
0: 				Thread.sleep(10000);
0: 				MessageProducer producer = session.createProducer(queue);
1: 
0: 				while (!stop && (counterSent < testSize))
0: 				{
0: 					// first send a message intended to be consumed ....
0: 					TextMessage message = session.createTextMessage("*** Ill ....... Ini ***");  // alma mater ...
0: 					message.setJMSType(JMSTYPE_EATME);
0: 					//LOG.info("sending .... JMSType = " + message.getJMSType());
0: 					producer.send(message,DeliveryMode.NON_PERSISTENT,0,1800000);
1: 					
0: 					counterSent++;
1: 
0: 					// now send a message intended to be consumed by some other consumer in the the future
0: 					// ... we expect these messages to accrue in the queue 
0: 					message = session.createTextMessage("*** Ill ....... Ini ***");  // alma mater ...
0: 					message.setJMSType(JMSTYPE_IGNOREME);
0: 					//LOG.info("sending .... JMSType = " + message.getJMSType());
0: 					producer.send(message,DeliveryMode.NON_PERSISTENT,0,1800000);
1: 
0: 					counterSent++;
1: 				}
1: 
0: 				session.close();
1: 
0: 			} catch (Exception e) {
0: 				e.printStackTrace();
1: 			}
0: 			LOG.info("producer thread complete ... " + counterSent + " messages sent to the queue");
1: 		}
1: 		
0: 		public int getCount()
0: 		{
0: 			return this.counterSent;
1: 		}
1: 		
1: 	}
1: 	
1: 	/**
0: 	 * Helper class that will consume messages from the queue based on the supplied JMS selector.
0: 	 * Thread will stop after the first receive(..) timeout, or once all expected messages have
0: 	 * been received (see testSize).  If the thread stops due to a timeout, it is experiencing the
0: 	 * delivery pause that is symptomatic of a bug in the broker.
1: 	 * 
0: 	 * @author jlyons
1: 	 *
1: 	 */
0: 	private class Consumer extends Thread 
0: 	{
0: 		protected int counterReceived = 0;
0: 		private Connection connection = null;
0: 		private String jmsSelector = null;
0: 		private boolean deliveryHalted = false;
1: 		
0: 		public Consumer(Connection connection, String jmsSelector)
0: 		{
0: 			this.connection = connection;
0: 			this.jmsSelector = jmsSelector;
1: 		}
1: 
0: 		public void run() {
0: 			boolean testComplete = false;
0: 			try {
0: 				Session session = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 				final Queue queue = session.createQueue("test");
0: 				MessageConsumer consumer = null;
0: 				if (null != this.jmsSelector)
0: 				{
0: 					consumer = session.createConsumer(queue, "JMSType='" + this.jmsSelector + "'");
1: 				}
1: 				else
0: 				{
0: 					consumer = session.createConsumer(queue);					
1: 				}
1: 
0: 				while (!deliveryHalted && (counterReceived < testSize))
0: 				{
0: 					TextMessage result = (TextMessage) consumer.receive(30000);
0: 					if (result != null) {
0: 						counterReceived++;
0: 						//System.out.println("consuming .... JMSType = " + result.getJMSType() + " received = " + counterReceived);
0: 						LOG.info("consuming .... JMSType = " + result.getJMSType() + " received = " + counterReceived);
0: 					} else
0: 					{
0: 						LOG.info("consuming .... timeout while waiting for a message ... broker must have stopped delivery ...  received = " + counterReceived);
0: 						deliveryHalted = true;
1: 					}
1: 				}
0: 				session.close();
0: 			} catch (Exception e) {
0: 				e.printStackTrace();
1: 			}
1: 
1: 		}
1: 		
0: 		public int getCount()
0: 		{
0: 			return this.counterReceived;
1: 		}
1: 		
0: 		public boolean deliveryHalted()
0: 		{
0: 			return this.deliveryHalted;
1: 		}
1: 	}
1: 
1: }
============================================================================