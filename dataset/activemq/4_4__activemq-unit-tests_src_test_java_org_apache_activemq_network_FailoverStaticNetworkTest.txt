1:c4d8bc4: /**
1:c4d8bc4:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c4d8bc4:  * contributor license agreements.  See the NOTICE file distributed with
1:c4d8bc4:  * this work for additional information regarding copyright ownership.
1:c4d8bc4:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c4d8bc4:  * (the "License"); you may not use this file except in compliance with
1:c4d8bc4:  * the License.  You may obtain a copy of the License at
1:c4d8bc4:  *
1:c4d8bc4:  *      http://www.apache.org/licenses/LICENSE-2.0
1:c4d8bc4:  *
1:c4d8bc4:  * Unless required by applicable law or agreed to in writing, software
1:c4d8bc4:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c4d8bc4:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c4d8bc4:  * See the License for the specific language governing permissions and
1:c4d8bc4:  * limitations under the License.
1:c4d8bc4:  */
1:c4d8bc4: package org.apache.activemq.network;
15:c4d8bc4: 
1:b2de5f3: import static org.junit.Assert.assertEquals;
1:b2de5f3: import static org.junit.Assert.assertTrue;
1:b2de5f3: 
1:986ed14: import java.net.URI;
1:4acd132: import java.util.ArrayList;
1:986ed14: import java.util.HashMap;
1:f793fbd: import java.util.HashSet;
1:4acd132: import java.util.List;
1:f793fbd: import java.util.Set;
1:986ed14: import java.util.Vector;
1:986ed14: import java.util.concurrent.ExecutorService;
1:986ed14: import java.util.concurrent.Executors;
1:4acd132: import java.util.concurrent.atomic.AtomicBoolean;
1:986ed14: 
1:c4d8bc4: import javax.jms.Connection;
1:c4d8bc4: import javax.jms.ConnectionFactory;
1:c4d8bc4: import javax.jms.JMSException;
1:4acd132: import javax.jms.Message;
1:c4d8bc4: import javax.jms.MessageConsumer;
1:c4d8bc4: import javax.jms.Session;
1:f793fbd: import javax.management.ObjectName;
1:c4d8bc4: import javax.net.ssl.KeyManager;
1:c4d8bc4: import javax.net.ssl.TrustManager;
1:986ed14: 
1:c4d8bc4: import org.apache.activemq.ActiveMQConnectionFactory;
1:d467220: import org.apache.activemq.AutoFailTestSupport;
1:c4d8bc4: import org.apache.activemq.broker.BrokerService;
1:c4d8bc4: import org.apache.activemq.broker.SslContext;
1:c4d8bc4: import org.apache.activemq.broker.TransportConnector;
1:c4d8bc4: import org.apache.activemq.command.ActiveMQDestination;
1:4acd132: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:c4d8bc4: import org.apache.activemq.transport.tcp.SslBrokerServiceTest;
1:986ed14: import org.apache.activemq.util.IntrospectionSupport;
1:4acd132: import org.apache.activemq.util.JMXSupport;
1:c4d8bc4: import org.apache.activemq.util.Wait;
1:c4d8bc4: import org.junit.After;
1:c4d8bc4: import org.junit.Before;
1:c4d8bc4: import org.junit.Test;
1:b2de5f3: import org.slf4j.Logger;
1:b2de5f3: import org.slf4j.LoggerFactory;
1:c4d8bc4: 
1:c4d8bc4: public class FailoverStaticNetworkTest {
1:8bf987b:     protected static final Logger LOG = LoggerFactory.getLogger(FailoverStaticNetworkTest.class);
1:c4d8bc4: 
1:b2de5f3:     private final static String DESTINATION_NAME = "testQ";
1:b2de5f3:     protected BrokerService brokerA;
1:986ed14:     protected BrokerService brokerA1;
1:c4d8bc4:     protected BrokerService brokerB;
1:986ed14:     protected BrokerService brokerC;
1:c4d8bc4: 
1:c4d8bc4: 
1:c4d8bc4:     private SslContext sslContext;
1:986ed14: 
1:c4d8bc4:     protected BrokerService createBroker(String scheme, String listenPort, String[] networkToPorts) throws Exception {
1:986ed14:         return createBroker(scheme, listenPort, networkToPorts, null);
1:986ed14:     }
1:986ed14: 
1:986ed14:     protected BrokerService createBroker(String scheme, String listenPort, String[] networkToPorts,
1:986ed14:                                          HashMap<String, String> networkProps) throws Exception {
1:c4d8bc4:         BrokerService broker = new BrokerService();
1:4c4f0d1:         broker.getManagementContext().setCreateConnector(false);
1:c4d8bc4:         broker.setSslContext(sslContext);
1:c4d8bc4:         broker.setDeleteAllMessagesOnStartup(true);
1:c4d8bc4:         broker.setBrokerName("Broker_" + listenPort);
1:4acd132:         // lazy init listener on broker start
1:4acd132:         TransportConnector transportConnector = new TransportConnector();
1:4acd132:         transportConnector.setUri(new URI(scheme + "://localhost:" + listenPort));
1:4acd132:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:4acd132:         transportConnectors.add(transportConnector);
1:4acd132:         broker.setTransportConnectors(transportConnectors);
1:c4d8bc4:         if (networkToPorts != null && networkToPorts.length > 0) {
1:c4d8bc4:             StringBuilder builder = new StringBuilder("static:(failover:(" + scheme + "://localhost:");
1:c4d8bc4:             builder.append(networkToPorts[0]);
1:c4d8bc4:             for (int i=1;i<networkToPorts.length; i++) {
1:c4d8bc4:                 builder.append("," + scheme + "://localhost:" + networkToPorts[i]);
2:c4d8bc4:             }
1:986ed14:             // limit the reconnects in case of initial random connection to slave
1:986ed14:             // leaving randomize on verifies that this config is picked up
1:4acd132:             builder.append(")?maxReconnectAttempts=0)?useExponentialBackOff=false");
1:986ed14:             NetworkConnector nc = broker.addNetworkConnector(builder.toString());
1:986ed14:             if (networkProps != null) {
1:986ed14:                 IntrospectionSupport.setProperties(nc, networkProps);
1:986ed14:             }
1:c4d8bc4:         }
1:c4d8bc4:         return broker;
1:c4d8bc4:     }
1:986ed14: 
1:986ed14:     private BrokerService createBroker(String listenPort, String dataDir) throws Exception {
1:986ed14:         BrokerService broker = new BrokerService();
1:986ed14:         broker.setUseJmx(false);
1:986ed14:         broker.getManagementContext().setCreateConnector(false);
1:986ed14:         broker.setBrokerName("Broker_Shared");
1:986ed14:         // lazy create transport connector on start completion
1:986ed14:         TransportConnector connector = new TransportConnector();
1:986ed14:         connector.setUri(new URI("tcp://localhost:" + listenPort));
1:986ed14:         broker.addConnector(connector);
1:986ed14:         broker.setDataDirectory(dataDir);
1:986ed14:         return broker;
1:986ed14:     }
1:986ed14: 
1:c4d8bc4:     @Before
1:4c4f0d1:     public void setUp() throws Exception {
1:c4d8bc4:         KeyManager[] km = SslBrokerServiceTest.getKeyManager();
1:c4d8bc4:         TrustManager[] tm = SslBrokerServiceTest.getTrustManager();
1:c4d8bc4:         sslContext = new SslContext(km, tm, null);
1:c4d8bc4:     }
1:b2de5f3: 
1:c4d8bc4:     @After
1:4c4f0d1:     public void tearDown() throws Exception {
1:c4d8bc4:         brokerB.stop();
1:c4d8bc4:         brokerB.waitUntilStopped();
1:b2de5f3: 
1:c4d8bc4:         brokerA.stop();
1:c4d8bc4:         brokerA.waitUntilStopped();
1:986ed14: 
1:986ed14:         if (brokerA1 != null) {
1:986ed14:             brokerA1.stop();
1:986ed14:             brokerA1.waitUntilStopped();
1:986ed14:         }
1:986ed14: 
1:986ed14:         if (brokerC != null) {
1:986ed14:             brokerC.stop();
1:986ed14:             brokerC.waitUntilStopped();
1:986ed14:         }
1:c4d8bc4:     }
1:c4d8bc4: 
1:4c4f0d1:     @Test
1:4c4f0d1:     public void testSendReceiveAfterReconnect() throws Exception {
1:4c4f0d1:         brokerA = createBroker("tcp", "61617", null);
1:4c4f0d1:         brokerA.start();
1:4c4f0d1:         brokerB = createBroker("tcp", "62617", new String[]{"61617"});
1:4c4f0d1:         brokerB.start();
1:4c4f0d1:         doTestNetworkSendReceive();
1:f793fbd: 
1:4c4f0d1:         LOG.info("stopping brokerA");
1:4c4f0d1:         brokerA.stop();
1:4c4f0d1:         brokerA.waitUntilStopped();
1:4c4f0d1: 
1:4c4f0d1:         LOG.info("restarting brokerA");
1:4c4f0d1:         brokerA = createBroker("tcp", "61617", null);
1:4c4f0d1:         brokerA.start();
1:4c4f0d1: 
1:4c4f0d1:         doTestNetworkSendReceive();
1:4c4f0d1:     }
1:4c4f0d1: 
1:4acd132:     @Test
1:4c4f0d1:     public void testSendReceiveFailover() throws Exception {
1:4c4f0d1:         brokerA = createBroker("tcp", "61617", null);
1:4c4f0d1:         brokerA.start();
1:4c4f0d1:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"});
1:4c4f0d1:         brokerB.start();
1:4c4f0d1:         doTestNetworkSendReceive();
1:4c4f0d1: 
1:f793fbd:         // check mbean
1:f793fbd:         Set<String> bridgeNames = getNetworkBridgeMBeanName(brokerB);
1:f793fbd:         assertEquals("only one bridgeName: " + bridgeNames, 1, bridgeNames.size());
1:f793fbd: 
1:4c4f0d1:         LOG.info("stopping brokerA");
1:4c4f0d1:         brokerA.stop();
1:4c4f0d1:         brokerA.waitUntilStopped();
1:4c4f0d1: 
1:4c4f0d1:         LOG.info("restarting brokerA");
1:4c4f0d1:         brokerA = createBroker("tcp", "63617", null);
1:4c4f0d1:         brokerA.start();
1:4c4f0d1: 
1:4c4f0d1:         doTestNetworkSendReceive();
1:4c4f0d1: 
1:f793fbd:         Set<String> otherBridgeNames = getNetworkBridgeMBeanName(brokerB);
1:f793fbd:         assertEquals("only one bridgeName: " + otherBridgeNames, 1, otherBridgeNames.size());
1:f793fbd: 
1:f793fbd:         assertTrue("there was an addition", bridgeNames.addAll(otherBridgeNames));
1:f793fbd:     }
1:f793fbd: 
1:f793fbd:     private Set<String> getNetworkBridgeMBeanName(BrokerService brokerB) throws Exception {
1:f793fbd:         Set<String> names = new HashSet<String>();
1:f793fbd:         for (ObjectName objectName : brokerB.getManagementContext().queryNames(null, null)) {
1:e3626e1:             if (objectName.getKeyProperty("networkBridge") != null) {
1:e3626e1:                 names.add(objectName.getKeyProperty("networkBridge"));
1:f793fbd:             }
1:f793fbd:         }
1:f793fbd:         return names;
1:4c4f0d1:     }
1:4c4f0d1: 
1:986ed14:     @Test
1:986ed14:     public void testSendReceiveFailoverDuplex() throws Exception {
1:986ed14:         final Vector<Throwable> errors = new Vector<Throwable>();
1:986ed14:         final String dataDir = "target/data/shared";
1:986ed14:         brokerA = createBroker("61617", dataDir);
1:986ed14:         brokerA.start();
1:986ed14: 
1:986ed14:         final BrokerService slave = createBroker("63617", dataDir);
1:986ed14:         brokerA1 = slave;
1:986ed14:         ExecutorService executor = Executors.newCachedThreadPool();
1:986ed14:         executor.execute(new Runnable() {
1:b2de5f3:             @Override
1:986ed14:             public void run() {
1:986ed14:                 try {
1:986ed14:                     slave.start();
1:986ed14:                 } catch (Exception e) {
1:986ed14:                     e.printStackTrace();
1:986ed14:                     errors.add(e);
1:986ed14:                 }
1:986ed14:             }
1:986ed14:         });
1:986ed14:         executor.shutdown();
1:986ed14: 
1:986ed14:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:986ed14:         networkConnectorProps.put("duplex", "true");
1:986ed14:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);
1:986ed14:         brokerB.start();
1:986ed14: 
1:986ed14:         doTestNetworkSendReceive(brokerA, brokerB);
1:986ed14:         doTestNetworkSendReceive(brokerB, brokerA);
1:986ed14: 
1:986ed14:         LOG.info("stopping brokerA (master shared_broker)");
1:986ed14:         brokerA.stop();
1:986ed14:         brokerA.waitUntilStopped();
1:986ed14: 
1:986ed14:         // wait for slave to start
1:986ed14:         brokerA1.waitUntilStarted();
1:986ed14: 
1:986ed14:         doTestNetworkSendReceive(brokerA1, brokerB);
1:986ed14:         doTestNetworkSendReceive(brokerB, brokerA1);
1:986ed14: 
1:986ed14:         assertTrue("No unexpected exceptions " + errors, errors.isEmpty());
1:986ed14:     }
1:986ed14: 
1:986ed14:     @Test
1:986ed14:     // master slave piggy in the middle setup
1:986ed14:     public void testSendReceiveFailoverDuplexWithPIM() throws Exception {
1:986ed14:         final String dataDir = "target/data/shared/pim";
1:986ed14:         brokerA = createBroker("61617", dataDir);
1:986ed14:         brokerA.start();
1:986ed14: 
1:986ed14:         final BrokerService slave = createBroker("63617", dataDir);
1:986ed14:         brokerA1 = slave;
1:986ed14:         ExecutorService executor = Executors.newCachedThreadPool();
1:986ed14:         executor.execute(new Runnable() {
1:b2de5f3:             @Override
1:986ed14:             public void run() {
1:986ed14:                 try {
1:986ed14:                     slave.start();
1:986ed14:                 } catch (Exception e) {
1:986ed14:                     e.printStackTrace();
1:986ed14:                 }
1:986ed14:             }
1:986ed14:         });
1:986ed14:         executor.shutdown();
1:986ed14: 
1:986ed14:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:986ed14:         networkConnectorProps.put("duplex", "true");
1:986ed14:         networkConnectorProps.put("networkTTL", "2");
1:986ed14: 
1:986ed14:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);
1:986ed14:         brokerB.start();
1:986ed14: 
1:986ed14:         assertTrue("all props applied", networkConnectorProps.isEmpty());
1:986ed14:         networkConnectorProps.put("duplex", "true");
1:986ed14:         networkConnectorProps.put("networkTTL", "2");
1:986ed14: 
1:986ed14:         brokerC = createBroker("tcp", "64617", new String[]{"61617", "63617"}, networkConnectorProps);
1:986ed14:         brokerC.start();
1:986ed14:         assertTrue("all props applied a second time", networkConnectorProps.isEmpty());
1:986ed14: 
1:986ed14:         doTestNetworkSendReceive(brokerC, brokerB);
1:986ed14:         doTestNetworkSendReceive(brokerB, brokerC);
1:986ed14: 
1:986ed14:         LOG.info("stopping brokerA (master shared_broker)");
1:986ed14:         brokerA.stop();
1:986ed14:         brokerA.waitUntilStopped();
1:986ed14: 
1:986ed14:         doTestNetworkSendReceive(brokerC, brokerB);
1:986ed14:         doTestNetworkSendReceive(brokerB, brokerC);
1:986ed14: 
1:986ed14:         brokerC.stop();
1:986ed14:         brokerC.waitUntilStopped();
1:986ed14:     }
1:986ed14: 
1:c4d8bc4:     /**
1:c4d8bc4:      * networked broker started after target so first connect attempt succeeds
1:c4d8bc4:      * start order is important
1:c4d8bc4:      */
1:4c4f0d1:     @Test
1:c4d8bc4:     public void testSendReceive() throws Exception {
1:b2de5f3: 
1:c4d8bc4:         brokerA = createBroker("tcp", "61617", null);
1:b2de5f3:         brokerA.start();
1:c4d8bc4:         brokerB = createBroker("tcp", "62617", new String[]{"61617","1111"});
1:c4d8bc4:         brokerB.start();
1:b2de5f3: 
1:4c4f0d1:         doTestNetworkSendReceive();
1:c4d8bc4:     }
1:c4d8bc4: 
1:c4d8bc4:     @Test
1:c4d8bc4:     public void testSendReceiveSsl() throws Exception {
1:b2de5f3: 
1:c4d8bc4:         brokerA = createBroker("ssl", "61617", null);
1:b2de5f3:         brokerA.start();
1:c4d8bc4:         brokerB = createBroker("ssl", "62617", new String[]{"61617", "1111"});
1:c4d8bc4:         brokerB.start();
1:b2de5f3: 
1:4c4f0d1:         doTestNetworkSendReceive();
1:c4d8bc4:     }
1:c4d8bc4: 
1:c4d8bc4:     @Test
1:4acd132:     public void testRepeatedSendReceiveWithMasterSlaveAlternate() throws Exception {
1:174c405:         doTestRepeatedSendReceiveWithMasterSlaveAlternate(null);
1:174c405:     }
1:4acd132: 
1:174c405:     @Test
1:174c405:     public void testRepeatedSendReceiveWithMasterSlaveAlternateDuplex() throws Exception {
1:174c405:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:174c405:         networkConnectorProps.put("duplex", "true");
1:174c405: 
1:174c405:         doTestRepeatedSendReceiveWithMasterSlaveAlternate(networkConnectorProps);
1:174c405:     }
1:174c405: 
1:174c405:     public void doTestRepeatedSendReceiveWithMasterSlaveAlternate(HashMap<String, String> networkConnectorProps) throws Exception {
1:174c405: 
1:174c405:         brokerB = createBroker("tcp", "62617", new String[]{"61610","61611"}, networkConnectorProps);
1:4acd132:         brokerB.start();
1:4acd132: 
1:4acd132:         final AtomicBoolean done = new AtomicBoolean(false);
1:4acd132:         ExecutorService executorService = Executors.newCachedThreadPool();
1:4acd132:         executorService.execute(new Runnable() {
1:4acd132:             @Override
1:4acd132:             public void run() {
1:4acd132:                 try {
1:4acd132:                     while (!done.get()) {
1:4acd132:                         brokerA = createBroker("tcp", "61610", null);
1:4acd132:                         brokerA.setBrokerName("Pair");
1:d467220:                         brokerA.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName="
1:4acd132:                                 + JMXSupport.encodeObjectNamePart("A") + "," + "Type=Broker"));
1:170b86a:                         ((KahaDBPersistenceAdapter)brokerA.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);
1:4acd132:                         brokerA.start();
1:4acd132:                         brokerA.waitUntilStopped();
1:4acd132: 
1:4acd132:                         // restart after peer taken over
1:4acd132:                         brokerA1.waitUntilStarted();
1:4acd132:                     }
1:4acd132:                 } catch (Exception ignored) {
1:4acd132:                     LOG.info("A create/start, unexpected: " + ignored, ignored);
1:4acd132:                 }
1:4acd132:             }
1:4acd132:         });
1:4acd132: 
1:4acd132:         // start with brokerA as master
1:4acd132:         Wait.waitFor(new Wait.Condition() {
1:4acd132:             @Override
1:4acd132:             public boolean isSatisified() throws Exception {
1:4acd132:                 return brokerA != null && brokerA.waitUntilStarted();
1:4acd132:             }
1:4acd132:         });
1:4acd132: 
1:4acd132:         executorService.execute(new Runnable() {
1:4acd132:             @Override
1:4acd132:             public void run() {
1:4acd132:                 try {
1:4acd132:                     while (!done.get()) {
1:4acd132:                         brokerA1 = createBroker("tcp", "61611", null);
1:4acd132:                         brokerA1.setBrokerName("Pair");
1:4acd132:                         // so they can coexist in local jmx we set the object name b/c the brokername identifies the shared store
1:d467220:                         brokerA1.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName="
1:4acd132:                             + JMXSupport.encodeObjectNamePart("A1") + "," + "Type=Broker"));
1:170b86a:                         ((KahaDBPersistenceAdapter)brokerA1.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);
1:4acd132:                         brokerA1.start();
1:4acd132:                         brokerA1.waitUntilStopped();
1:4acd132: 
1:4acd132:                         // restart after peer taken over
1:4acd132:                         brokerA.waitUntilStarted();
1:4acd132:                     }
1:4acd132:                 } catch (Exception ignored) {
1:4acd132:                     LOG.info("A1 create/start, unexpected: " + ignored, ignored);
1:4acd132:                 }
1:4acd132:             }
1:4acd132:         });
1:4acd132: 
1:174c405:         for (int i=0; i<4; i++) {
1:4acd132:             BrokerService currentMaster =  (i%2 == 0 ? brokerA : brokerA1);
1:d467220:             LOG.info("iteration: " + i + ", using: " + currentMaster.getBrokerObjectName().getKeyProperty("brokerName"));
1:4acd132:             currentMaster.waitUntilStarted();
1:4acd132: 
1:4acd132:             doTestNetworkSendReceive(brokerB, currentMaster);
1:4acd132: 
1:d467220:             LOG.info("Stopping " + currentMaster.getBrokerObjectName().getKeyProperty("brokerName"));
1:4acd132:             currentMaster.stop();
1:4acd132:             currentMaster.waitUntilStopped();
1:4acd132:         }
1:4acd132: 
1:174c405:         done.set(true);
1:4acd132:         LOG.info("all done");
1:4acd132:         executorService.shutdownNow();
1:4acd132:     }
1:4acd132: 
1:4c4f0d1:     private void doTestNetworkSendReceive() throws Exception, JMSException {
1:986ed14:         doTestNetworkSendReceive(brokerB, brokerA);
1:986ed14:     }
1:986ed14: 
1:4acd132:     private void doTestNetworkSendReceive(final BrokerService to, final BrokerService from) throws Exception, JMSException {
1:986ed14: 
1:986ed14:         LOG.info("Creating Consumer on the networked broker ..." + from);
1:b2de5f3: 
1:c4d8bc4:         SslContext.setCurrentSslContext(sslContext);
1:4c4f0d1:         // Create a consumer on brokerA
1:986ed14:         ConnectionFactory consFactory = createConnectionFactory(from);
1:c4d8bc4:         Connection consConn = consFactory.createConnection();
1:c4d8bc4:         consConn.start();
1:c4d8bc4:         Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:c4d8bc4:         ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);
1:c4d8bc4:         final MessageConsumer consumer = consSession.createConsumer(destination);
1:4c4f0d1: 
1:986ed14:         LOG.info("publishing to " + to);
1:4c4f0d1: 
1:986ed14:         sendMessageTo(destination, to);
1:b2de5f3: 
1:4c4f0d1:         boolean gotMessage = Wait.waitFor(new Wait.Condition() {
1:b2de5f3:             @Override
1:c4d8bc4:             public boolean isSatisified() throws Exception {
1:4acd132:                 Message message = consumer.receive(5000);
1:d467220:                 LOG.info("from:  " + from.getBrokerObjectName().getKeyProperty("brokerName") +  ", received: " + message);
1:4acd132:                 return message != null;
1:b2de5f3:             }
1:4c4f0d1:         });
1:d467220:         if (!gotMessage) {
1:d467220:             AutoFailTestSupport.dumpAllThreads("noMessage");
1:d467220:         }
1:4c4f0d1:         try {
1:4c4f0d1:             consConn.close();
1:4c4f0d1:         } catch (JMSException ignored) {
1:4c4f0d1:         }
1:4c4f0d1:         assertTrue("consumer on A got message", gotMessage);
1:c4d8bc4:     }
1:c4d8bc4: 
1:c4d8bc4:     private void sendMessageTo(ActiveMQDestination destination, BrokerService brokerService) throws Exception {
1:c4d8bc4:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:c4d8bc4:         Connection conn = factory.createConnection();
1:c4d8bc4:         conn.start();
1:c4d8bc4:         Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:c4d8bc4:         session.createProducer(destination).send(session.createTextMessage("Hi"));
1:c4d8bc4:         conn.close();
1:c4d8bc4:     }
1:b2de5f3: 
1:b2de5f3:     protected ConnectionFactory createConnectionFactory(final BrokerService broker) throws Exception {
1:b2de5f3:         String url = broker.getTransportConnectors().get(0).getServer().getConnectURI().toString();
1:c4d8bc4:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);
1:c4d8bc4:         connectionFactory.setOptimizedMessageDispatch(true);
1:c4d8bc4:         connectionFactory.setDispatchAsync(false);
1:c4d8bc4:         connectionFactory.setUseAsyncSend(false);
1:c4d8bc4:         connectionFactory.setOptimizeAcknowledge(false);
1:c4d8bc4:         connectionFactory.setAlwaysSyncSend(true);
1:c4d8bc4:         return connectionFactory;
1:c4d8bc4:     }
1:c4d8bc4: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:d467220
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
1:                         brokerA.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName="
/////////////////////////////////////////////////////////////////////////
1:                         brokerA1.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName="
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("iteration: " + i + ", using: " + currentMaster.getBrokerObjectName().getKeyProperty("brokerName"));
1:             LOG.info("Stopping " + currentMaster.getBrokerObjectName().getKeyProperty("brokerName"));
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("from:  " + from.getBrokerObjectName().getKeyProperty("brokerName") +  ", received: " + message);
1:         if (!gotMessage) {
1:             AutoFailTestSupport.dumpAllThreads("noMessage");
1:         }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:b2de5f3
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private final static String DESTINATION_NAME = "testQ";
1:     protected BrokerService brokerA;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:             if ("NetworkBridge".equals(objectName.getKeyProperty("service"))) {
0:                 names.add(objectName.getKeyProperty("networkBridgeName"));
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         brokerA.start();
1: 
1: 
1:         brokerA.start();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected ConnectionFactory createConnectionFactory(final BrokerService broker) throws Exception {
1:         String url = broker.getTransportConnectors().get(0).getServer().getConnectURI().toString();
author:Gary Tully
-------------------------------------------------------------------------------
commit:e3626e1
/////////////////////////////////////////////////////////////////////////
1:             if (objectName.getKeyProperty("networkBridge") != null) {
1:                 names.add(objectName.getKeyProperty("networkBridge"));
commit:174c405
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         doTestRepeatedSendReceiveWithMasterSlaveAlternate(null);
1:     }
1:     @Test
1:     public void testRepeatedSendReceiveWithMasterSlaveAlternateDuplex() throws Exception {
1:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:         networkConnectorProps.put("duplex", "true");
1: 
1:         doTestRepeatedSendReceiveWithMasterSlaveAlternate(networkConnectorProps);
1:     }
1: 
1:     public void doTestRepeatedSendReceiveWithMasterSlaveAlternate(HashMap<String, String> networkConnectorProps) throws Exception {
1: 
1:         brokerB = createBroker("tcp", "62617", new String[]{"61610","61611"}, networkConnectorProps);
/////////////////////////////////////////////////////////////////////////
1:         for (int i=0; i<4; i++) {
/////////////////////////////////////////////////////////////////////////
1:         done.set(true);
commit:4acd132
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Message;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.JMXSupport;
/////////////////////////////////////////////////////////////////////////
1:         // lazy init listener on broker start
1:         TransportConnector transportConnector = new TransportConnector();
1:         transportConnector.setUri(new URI(scheme + "://localhost:" + listenPort));
1:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:         transportConnectors.add(transportConnector);
1:         broker.setTransportConnectors(transportConnectors);
/////////////////////////////////////////////////////////////////////////
1:             builder.append(")?maxReconnectAttempts=0)?useExponentialBackOff=false");
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testRepeatedSendReceiveWithMasterSlaveAlternate() throws Exception {
1: 
0:         brokerB = createBroker("tcp", "62617", new String[]{"61610","61611"});
1:         brokerB.start();
1: 
1:         final AtomicBoolean done = new AtomicBoolean(false);
1:         ExecutorService executorService = Executors.newCachedThreadPool();
1:         executorService.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     while (!done.get()) {
1:                         brokerA = createBroker("tcp", "61610", null);
1:                         brokerA.setBrokerName("Pair");
0:                         brokerA.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "BrokerName="
1:                                 + JMXSupport.encodeObjectNamePart("A") + "," + "Type=Broker"));
0:                         ((KahaDBPersistenceAdapter)brokerA.getPersistenceAdapter()).setDatabaseLockedWaitDelay(1000);
1:                         brokerA.start();
1:                         brokerA.waitUntilStopped();
1: 
1:                         // restart after peer taken over
1:                         brokerA1.waitUntilStarted();
1:                     }
1:                 } catch (Exception ignored) {
1:                     LOG.info("A create/start, unexpected: " + ignored, ignored);
1:                 }
1:             }
1:         });
1: 
1:         // start with brokerA as master
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokerA != null && brokerA.waitUntilStarted();
1:             }
1:         });
1: 
1:         executorService.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     while (!done.get()) {
1:                         brokerA1 = createBroker("tcp", "61611", null);
1:                         brokerA1.setBrokerName("Pair");
1:                         // so they can coexist in local jmx we set the object name b/c the brokername identifies the shared store
0:                         brokerA1.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "BrokerName="
1:                             + JMXSupport.encodeObjectNamePart("A1") + "," + "Type=Broker"));
0:                         ((KahaDBPersistenceAdapter)brokerA1.getPersistenceAdapter()).setDatabaseLockedWaitDelay(1000);
1:                         brokerA1.start();
1:                         brokerA1.waitUntilStopped();
1: 
1:                         // restart after peer taken over
1:                         brokerA.waitUntilStarted();
1:                     }
1:                 } catch (Exception ignored) {
1:                     LOG.info("A1 create/start, unexpected: " + ignored, ignored);
1:                 }
1:             }
1:         });
1: 
0:         for (int i=0; i<10; i++) {
1:             BrokerService currentMaster =  (i%2 == 0 ? brokerA : brokerA1);
0:             LOG.info("iteration: " + i + ", using: " + currentMaster.getBrokerObjectName().getKeyProperty("BrokerName"));
1:             currentMaster.waitUntilStarted();
1: 
1:             doTestNetworkSendReceive(brokerB, currentMaster);
1: 
0:             LOG.info("Stopping " + currentMaster.getBrokerObjectName().getKeyProperty("BrokerName"));
1:             currentMaster.stop();
1:             currentMaster.waitUntilStopped();
1:         }
1: 
0:         done.set(false);
1:         LOG.info("all done");
1:         executorService.shutdownNow();
1:     }
1: 
1:     private void doTestNetworkSendReceive(final BrokerService to, final BrokerService from) throws Exception, JMSException {
/////////////////////////////////////////////////////////////////////////
1:                 Message message = consumer.receive(5000);
0:                 LOG.info("from:  " + from.getBrokerObjectName().getKeyProperty("BrokerName") +  ", received: " + message);
1:                 return message != null;
commit:f793fbd
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
0: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
0:         //broker.setUseJmx(false);
/////////////////////////////////////////////////////////////////////////
1:         // check mbean
1:         Set<String> bridgeNames = getNetworkBridgeMBeanName(brokerB);
1:         assertEquals("only one bridgeName: " + bridgeNames, 1, bridgeNames.size());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         Set<String> otherBridgeNames = getNetworkBridgeMBeanName(brokerB);
1:         assertEquals("only one bridgeName: " + otherBridgeNames, 1, otherBridgeNames.size());
1: 
1:         assertTrue("there was an addition", bridgeNames.addAll(otherBridgeNames));
1:     }
1: 
1:     private Set<String> getNetworkBridgeMBeanName(BrokerService brokerB) throws Exception {
1:         Set<String> names = new HashSet<String>();
1:         for (ObjectName objectName : brokerB.getManagementContext().queryNames(null, null)) {
0:             if ("NetworkBridge".equals(objectName.getKeyProperty("Type"))) {
0:                 names.add(objectName.getKeyProperty("Name"));
1:             }
1:         }
1:         return names;
commit:986ed14
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.HashMap;
1: import java.util.Vector;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IntrospectionSupport;
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerService brokerA1;
1:     protected BrokerService brokerC;
1: 
1:         return createBroker(scheme, listenPort, networkToPorts, null);
1:     }
1: 
1:     protected BrokerService createBroker(String scheme, String listenPort, String[] networkToPorts,
1:                                          HashMap<String, String> networkProps) throws Exception {
1:         broker.setUseJmx(false);
/////////////////////////////////////////////////////////////////////////
1:             // limit the reconnects in case of initial random connection to slave
1:             // leaving randomize on verifies that this config is picked up
0:             builder.append(")?maxReconnectAttempts=1)");
1:             NetworkConnector nc = broker.addNetworkConnector(builder.toString());
1:             if (networkProps != null) {
1:                 IntrospectionSupport.setProperties(nc, networkProps);
1:             }
1: 
1:     private BrokerService createBroker(String listenPort, String dataDir) throws Exception {
1:         BrokerService broker = new BrokerService();
0:         broker.setUseJmx(false);
1:         broker.getManagementContext().setCreateConnector(false);
1:         broker.setBrokerName("Broker_Shared");
1:         // lazy create transport connector on start completion
1:         TransportConnector connector = new TransportConnector();
1:         connector.setUri(new URI("tcp://localhost:" + listenPort));
1:         broker.addConnector(connector);
1:         broker.setDataDirectory(dataDir);
1:         return broker;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (brokerA1 != null) {
1:             brokerA1.stop();
1:             brokerA1.waitUntilStopped();
1:         }
1: 
1:         if (brokerC != null) {
1:             brokerC.stop();
1:             brokerC.waitUntilStopped();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testSendReceiveFailoverDuplex() throws Exception {
1:         final Vector<Throwable> errors = new Vector<Throwable>();
1:         final String dataDir = "target/data/shared";
1:         brokerA = createBroker("61617", dataDir);
1:         brokerA.start();
1: 
1:         final BrokerService slave = createBroker("63617", dataDir);
1:         brokerA1 = slave;
1:         ExecutorService executor = Executors.newCachedThreadPool();
1:         executor.execute(new Runnable() {
1:             public void run() {
1:                 try {
1:                     slave.start();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     errors.add(e);
1:                 }
1:             }
1:         });
1:         executor.shutdown();
1: 
1:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:         networkConnectorProps.put("duplex", "true");
1:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);
1:         brokerB.start();
1: 
1:         doTestNetworkSendReceive(brokerA, brokerB);
1:         doTestNetworkSendReceive(brokerB, brokerA);
1: 
1:         LOG.info("stopping brokerA (master shared_broker)");
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1: 
1:         // wait for slave to start
1:         brokerA1.waitUntilStarted();
1: 
1:         doTestNetworkSendReceive(brokerA1, brokerB);
1:         doTestNetworkSendReceive(brokerB, brokerA1);
1: 
1:         assertTrue("No unexpected exceptions " + errors, errors.isEmpty());
1:     }
1: 
1:     @Test
1:     // master slave piggy in the middle setup
1:     public void testSendReceiveFailoverDuplexWithPIM() throws Exception {
1:         final String dataDir = "target/data/shared/pim";
1:         brokerA = createBroker("61617", dataDir);
1:         brokerA.start();
1: 
1:         final BrokerService slave = createBroker("63617", dataDir);
1:         brokerA1 = slave;
1:         ExecutorService executor = Executors.newCachedThreadPool();
1:         executor.execute(new Runnable() {
1:             public void run() {
1:                 try {
1:                     slave.start();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1:         executor.shutdown();
1: 
1:         HashMap<String, String> networkConnectorProps = new HashMap<String, String>();
1:         networkConnectorProps.put("duplex", "true");
1:         networkConnectorProps.put("networkTTL", "2");
1: 
1:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);
1:         brokerB.start();
1: 
1:         assertTrue("all props applied", networkConnectorProps.isEmpty());
1:         networkConnectorProps.put("duplex", "true");
1:         networkConnectorProps.put("networkTTL", "2");
1: 
1:         brokerC = createBroker("tcp", "64617", new String[]{"61617", "63617"}, networkConnectorProps);
1:         brokerC.start();
1:         assertTrue("all props applied a second time", networkConnectorProps.isEmpty());
1: 
0:         //Thread.sleep(4000);
1:         doTestNetworkSendReceive(brokerC, brokerB);
1:         doTestNetworkSendReceive(brokerB, brokerC);
1: 
1:         LOG.info("stopping brokerA (master shared_broker)");
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1: 
1:         doTestNetworkSendReceive(brokerC, brokerB);
1:         doTestNetworkSendReceive(brokerB, brokerC);
1: 
1:         brokerC.stop();
1:         brokerC.waitUntilStopped();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         doTestNetworkSendReceive(brokerB, brokerA);
1:     }
1: 
0:     private void doTestNetworkSendReceive(BrokerService to, BrokerService from) throws Exception, JMSException {
1: 
1:         LOG.info("Creating Consumer on the networked broker ..." + from);
1:         ConnectionFactory consFactory = createConnectionFactory(from);
1:         LOG.info("publishing to " + to);
1:         sendMessageTo(destination, to);
commit:4c4f0d1
/////////////////////////////////////////////////////////////////////////
0:         broker.setUseJmx(true);
1:         broker.getManagementContext().setCreateConnector(false);
/////////////////////////////////////////////////////////////////////////
1:     public void setUp() throws Exception {
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testSendReceiveAfterReconnect() throws Exception {
1:         brokerA = createBroker("tcp", "61617", null);
1:         brokerA.start();
1:         brokerB = createBroker("tcp", "62617", new String[]{"61617"});
1:         brokerB.start();
1:         doTestNetworkSendReceive();
1: 
1:         LOG.info("stopping brokerA");
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1: 
1:         LOG.info("restarting brokerA");
1:         brokerA = createBroker("tcp", "61617", null);
1:         brokerA.start();
1: 
1:         doTestNetworkSendReceive();
1:     }
1: 
1:     @Test
1:     public void testSendReceiveFailover() throws Exception {
1:         brokerA = createBroker("tcp", "61617", null);
1:         brokerA.start();
1:         brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"});
1:         brokerB.start();
1:         doTestNetworkSendReceive();
1: 
1:         LOG.info("stopping brokerA");
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1: 
1:         LOG.info("restarting brokerA");
1:         brokerA = createBroker("tcp", "63617", null);
1:         brokerA.start();
1: 
1:         doTestNetworkSendReceive();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         doTestNetworkSendReceive();
/////////////////////////////////////////////////////////////////////////
1:         doTestNetworkSendReceive();
1:     private void doTestNetworkSendReceive() throws Exception, JMSException {
0:         LOG.info("Creating Consumer on the networked brokerA ...");
1:         // Create a consumer on brokerA
1: 
0:         LOG.info("publishing to brokerB");
1: 
1:         boolean gotMessage = Wait.waitFor(new Wait.Condition() {
1:         });
1:         try {
1:             consConn.close();
1:         } catch (JMSException ignored) {
1:         }
1:         assertTrue("consumer on A got message", gotMessage);
commit:c4d8bc4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
1: 
0: import static org.junit.Assert.assertTrue;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.Session;
1: import javax.net.ssl.KeyManager;
1: import javax.net.ssl.TrustManager;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.SslContext;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.transport.tcp.SslBrokerServiceTest;
1: import org.apache.activemq.util.Wait;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: public class FailoverStaticNetworkTest {
0:     protected static final Log LOG = LogFactory.getLog(FailoverStaticNetworkTest.class);
1: 
0: 	private final static String DESTINATION_NAME = "testQ";
0: 	protected BrokerService brokerA;
1:     protected BrokerService brokerB;
1: 
1: 
1:     private SslContext sslContext;
1:     
1:     protected BrokerService createBroker(String scheme, String listenPort, String[] networkToPorts) throws Exception {
1:         BrokerService broker = new BrokerService();
1:         broker.setSslContext(sslContext);
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.setBrokerName("Broker_" + listenPort);
0:         broker.addConnector(scheme + "://localhost:" + listenPort);
1:         if (networkToPorts != null && networkToPorts.length > 0) {
1:             StringBuilder builder = new StringBuilder("static:(failover:(" + scheme + "://localhost:");
1:             builder.append(networkToPorts[0]);
1:             for (int i=1;i<networkToPorts.length; i++) {
1:                 builder.append("," + scheme + "://localhost:" + networkToPorts[i]);
1:             }
0:             builder.append(")?randomize=false)");
0:             broker.addNetworkConnector(builder.toString());
1:         }
1:         return broker;
1:     }
1:   
1:     @Before
0:     public void init() throws Exception {
1:         KeyManager[] km = SslBrokerServiceTest.getKeyManager();
1:         TrustManager[] tm = SslBrokerServiceTest.getTrustManager();
1:         sslContext = new SslContext(km, tm, null);
1:     }
1:     
1:     @After
0:     public void cleanup() throws Exception {
1:         brokerB.stop();
1:         brokerB.waitUntilStopped();
1:         
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1:     }
1: 
1:     /**
1:      * networked broker started after target so first connect attempt succeeds
1:      * start order is important
1:      */
1:     @Test
1:     public void testSendReceive() throws Exception {
1:               
1:         brokerA = createBroker("tcp", "61617", null);
0:         brokerA.start();        
1:         brokerB = createBroker("tcp", "62617", new String[]{"61617","1111"});
1:         brokerB.start();
1:   
0:         testNetworkSendReceive();
1:     }
1: 
1:     @Test
1:     public void testSendReceiveSsl() throws Exception {
1:               
1:         brokerA = createBroker("ssl", "61617", null);
0:         brokerA.start();        
1:         brokerB = createBroker("ssl", "62617", new String[]{"61617", "1111"});
1:         brokerB.start();
1:   
0:         testNetworkSendReceive();
1:     }
1: 
0:     private void testNetworkSendReceive() throws Exception, JMSException {
0:         LOG.info("Creating Consumer on the networked broker ...");
1:         
1:         SslContext.setCurrentSslContext(sslContext);
0:         // Create a consumer on brokerB
0:         ConnectionFactory consFactory = createConnectionFactory(brokerA);
1:         Connection consConn = consFactory.createConnection();
1:         consConn.start();
1:         Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);
1:         final MessageConsumer consumer = consSession.createConsumer(destination);
1:         
0:         sendMessageTo(destination, brokerB);
1:         
0:         assertTrue("consumer got message", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return consumer.receive(1000) != null;
1:             }      
0:         }));
1:     }
1: 
1:     private void sendMessageTo(ActiveMQDestination destination, BrokerService brokerService) throws Exception {
1:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:         Connection conn = factory.createConnection();
1:         conn.start();
1:         Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createProducer(destination).send(session.createTextMessage("Hi"));
1:         conn.close();
1:     }
1:     
0:     protected ConnectionFactory createConnectionFactory(final BrokerService broker) throws Exception {    
0:         String url = ((TransportConnector) broker.getTransportConnectors().get(0)).getServer().getConnectURI().toString();
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);
1:         connectionFactory.setOptimizedMessageDispatch(true);
1:         connectionFactory.setDispatchAsync(false);
1:         connectionFactory.setUseAsyncSend(false);
1:         connectionFactory.setOptimizeAcknowledge(false);
1:         connectionFactory.setAlwaysSyncSend(true);
1:         return connectionFactory;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:170b86a
/////////////////////////////////////////////////////////////////////////
1:                         ((KahaDBPersistenceAdapter)brokerA.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);
/////////////////////////////////////////////////////////////////////////
1:                         ((KahaDBPersistenceAdapter)brokerA1.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1:     protected static final Logger LOG = LoggerFactory.getLogger(FailoverStaticNetworkTest.class);
/////////////////////////////////////////////////////////////////////////
0: }
============================================================================