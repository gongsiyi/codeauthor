1:261ccab: /**
1:261ccab:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:261ccab:  * contributor license agreements.  See the NOTICE file distributed with
1:261ccab:  * this work for additional information regarding copyright ownership.
1:261ccab:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:261ccab:  * (the "License"); you may not use this file except in compliance with
1:261ccab:  * the License.  You may obtain a copy of the License at
1:261ccab:  *
1:261ccab:  *      http://www.apache.org/licenses/LICENSE-2.0
1:261ccab:  *
1:261ccab:  * Unless required by applicable law or agreed to in writing, software
1:261ccab:  * distributed under the License is distributed on an "AS IS" BASIS,
1:261ccab:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:261ccab:  * See the License for the specific language governing permissions and
1:261ccab:  * limitations under the License.
1:261ccab:  */
1:f6cf0ba: package org.apache.activemq.network;
3:c26dd6a: 
1:9fece8f: import static org.junit.Assert.assertEquals;
1:9fece8f: import static org.junit.Assert.assertNotNull;
1:9fece8f: import static org.junit.Assert.assertNull;
1:88d85ae: import static org.junit.Assert.assertTrue;
1:af1b232: 
1:a15b395: import java.io.File;
1:a15b395: import java.io.IOException;
1:c26dd6a: import java.net.URI;
1:c26dd6a: import java.net.URISyntaxException;
1:c26dd6a: import java.util.ArrayList;
1:c26dd6a: import java.util.Enumeration;
1:c26dd6a: import java.util.HashMap;
1:c26dd6a: import java.util.Hashtable;
1:c26dd6a: import java.util.List;
1:c26dd6a: import java.util.Map;
1:c26dd6a: import java.util.concurrent.TimeUnit;
1:9fece8f: 
1:c26dd6a: import javax.jms.Connection;
1:f6cf0ba: import javax.jms.DeliveryMode;
1:c26dd6a: import javax.jms.MessageNotWriteableException;
1:c26dd6a: import javax.jms.Queue;
1:c26dd6a: import javax.jms.QueueBrowser;
1:c26dd6a: import javax.jms.Session;
1:c26dd6a: import javax.management.ObjectName;
1:ac23437: 
1:6f124c1: import javax.management.openmbean.CompositeData;
1:c26dd6a: import org.apache.activemq.ActiveMQConnectionFactory;
1:c26dd6a: import org.apache.activemq.broker.BrokerService;
1:c26dd6a: import org.apache.activemq.broker.BrokerTestSupport;
1:f6cf0ba: import org.apache.activemq.broker.StubConnection;
1:c26dd6a: import org.apache.activemq.broker.TransportConnector;
1:c26dd6a: import org.apache.activemq.broker.jmx.ManagementContext;
1:d7a8bc8: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:af1b232: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:af1b232: import org.apache.activemq.broker.region.policy.PolicyMap;
1:f6cf0ba: import org.apache.activemq.command.ActiveMQDestination;
1:6f124c1: import org.apache.activemq.command.ActiveMQMessage;
1:c26dd6a: import org.apache.activemq.command.ActiveMQTextMessage;
1:c26dd6a: import org.apache.activemq.command.ConnectionId;
1:f6cf0ba: import org.apache.activemq.command.ConnectionInfo;
1:f6cf0ba: import org.apache.activemq.command.ConsumerInfo;
1:c26dd6a: import org.apache.activemq.command.DestinationInfo;
1:f6cf0ba: import org.apache.activemq.command.Message;
1:f6cf0ba: import org.apache.activemq.command.MessageAck;
1:c26dd6a: import org.apache.activemq.command.MessageDispatch;
1:c26dd6a: import org.apache.activemq.command.MessageId;
1:f6cf0ba: import org.apache.activemq.command.ProducerInfo;
1:f6cf0ba: import org.apache.activemq.command.SessionInfo;
1:a15b395: import org.apache.activemq.transport.Transport;
1:c26dd6a: import org.apache.activemq.transport.TransportFactory;
1:a15b395: import org.apache.activemq.util.Wait;
1:a15b395: import org.apache.commons.io.FileUtils;
1:9fece8f: import org.junit.After;
1:9fece8f: import org.junit.Before;
1:9fece8f: import org.junit.Test;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:c26dd6a: 
1:c26dd6a: /**
1:ac23437:  * This class duplicates most of the functionality in {@link NetworkTestSupport}
1:ac23437:  * and {@link BrokerTestSupport} because more control was needed over how brokers
1:ac23437:  * and connectors are created. Also, this test asserts message counts via JMX on
1:ac23437:  * each broker.
1:c26dd6a:  */
1:9fece8f: public class BrokerNetworkWithStuckMessagesTest {
1:ac23437: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(BrokerNetworkWithStuckMessagesTest.class);
1:ac23437: 
1:ac23437:     private BrokerService localBroker;
1:ac23437:     private BrokerService remoteBroker;
1:30a9fe1:     private BrokerService secondRemoteBroker;
1:c26dd6a:     private DemandForwardingBridge bridge;
1:ac23437: 
1:c26dd6a:     protected Map<String, BrokerService> brokers = new HashMap<String, BrokerService>();
1:ac23437:     protected ArrayList<StubConnection> connections = new ArrayList<StubConnection>();
1:ac23437: 
1:c26dd6a:     protected TransportConnector connector;
1:c26dd6a:     protected TransportConnector remoteConnector;
1:30a9fe1:     protected TransportConnector secondRemoteConnector;
1:ac23437: 
1:c26dd6a:     protected long idGenerator;
1:c26dd6a:     protected int msgIdGenerator;
1:c26dd6a:     protected int tempDestGenerator;
1:c26dd6a:     protected int maxWait = 4000;
1:c26dd6a:     protected String queueName = "TEST";
1:ac23437: 
1:c26dd6a:     protected String amqDomain = "org.apache.activemq";
1:ac23437: 
1:9fece8f:     @Before
1:9fece8f:     public void setUp() throws Exception {
1:ac23437: 
1:ac23437:         // For those who want visual confirmation:
1:ac23437:         //   Uncomment the following to enable JMX support on a port number to use
1:ac23437:         //   Jconsole to view each broker. You will need to add some calls to
1:ac23437:         //   Thread.sleep() to be able to actually slow things down so that you
1:ac23437:         //   can manually see JMX attrs.
1:c26dd6a: //        System.setProperty("com.sun.management.jmxremote", "");
1:c26dd6a: //        System.setProperty("com.sun.management.jmxremote.port", "1099");
1:c26dd6a: //        System.setProperty("com.sun.management.jmxremote.authenticate", "false");
1:c26dd6a: //        System.setProperty("com.sun.management.jmxremote.ssl", "false");
1:ac23437: 
1:ac23437:         // Create the local broker
1:c26dd6a:         createBroker();
1:ac23437:         // Create the remote broker
1:c26dd6a:         createRemoteBroker();
1:ac23437: 
1:c26dd6a:         // Remove the activemq-data directory from the creation of the remote broker
1:c26dd6a:         FileUtils.deleteDirectory(new File("activemq-data"));
1:ac23437: 
1:ac23437:         // Create a network bridge between the local and remote brokers so that
1:f6cf0ba:         // demand-based forwarding can take place
1:f6cf0ba:         NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();
1:f6cf0ba:         config.setBrokerName("local");
1:f6cf0ba:         config.setDispatchAsync(false);
1:af1b232:         config.setDuplex(true);
1:af1b232: 
1:ac23437:         Transport localTransport = createTransport();
1:a15b395:         Transport remoteTransport = createRemoteTransport();
1:ac23437: 
1:ac23437:         // Create a network bridge between the two brokers
1:a15b395:         bridge = new DemandForwardingBridge(config, localTransport, remoteTransport);
1:c26dd6a:         bridge.setBrokerService(localBroker);
1:f6cf0ba:         bridge.start();
1:30a9fe1: 
1:ac23437: 
1:30a9fe1:         // introduce a second broker/bridge on remote that should not get any messages because of networkTtl=1
1:30a9fe1:         // local <-> remote <-> secondRemote
1:30a9fe1:         createSecondRemoteBroker();
1:30a9fe1:         config = new NetworkBridgeConfiguration();
1:30a9fe1:         config.setBrokerName("remote");
1:30a9fe1:         config.setDuplex(true);
1:30a9fe1: 
1:30a9fe1:         localTransport = createRemoteTransport();
1:30a9fe1:         remoteTransport = createSecondRemoteTransport();
1:30a9fe1: 
1:30a9fe1:         // Create a network bridge between the two brokers
1:30a9fe1:         bridge = new DemandForwardingBridge(config, localTransport, remoteTransport);
1:30a9fe1:         bridge.setBrokerService(remoteBroker);
1:30a9fe1:         bridge.start();
1:30a9fe1: 
1:c26dd6a:         waitForBridgeFormation();
7:a15b395:     }
1:ac23437: 
1:c26dd6a:     protected void waitForBridgeFormation() throws Exception {
1:c26dd6a:         for (final BrokerService broker : brokers.values()) {
1:c26dd6a:             if (!broker.getNetworkConnectors().isEmpty()) {
1:ac23437:                 // Max wait here is 30 secs
1:c26dd6a:                 Wait.waitFor(new Wait.Condition() {
3:ac23437:                     @Override
1:c26dd6a:                     public boolean isSatisified() throws Exception {
1:c26dd6a:                         return !broker.getNetworkConnectors().get(0).activeBridges().isEmpty();
1:c26dd6a:                     }});
1:c26dd6a:             }
1:c26dd6a:         }
1:c26dd6a:     }
1:ac23437: 
1:9fece8f:     @After
1:9fece8f:     public void tearDown() throws Exception {
1:f6cf0ba:         bridge.stop();
1:c26dd6a:         localBroker.stop();
1:c26dd6a:         remoteBroker.stop();
1:30a9fe1:         secondRemoteBroker.stop();
1:c26dd6a:     }
1:ac23437: 
1:9fece8f:     @Test(timeout=120000)
1:c26dd6a:     public void testBrokerNetworkWithStuckMessages() throws Exception {
1:ac23437: 
1:c26dd6a:         int sendNumMessages = 10;
1:c26dd6a:         int receiveNumMessages = 5;
1:ac23437: 
1:ac23437:         // Create a producer
1:c26dd6a:         StubConnection connection1 = createConnection();
1:f6cf0ba:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:f6cf0ba:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:f6cf0ba:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:f6cf0ba:         connection1.send(connectionInfo1);
1:f6cf0ba:         connection1.send(sessionInfo1);
1:f6cf0ba:         connection1.send(producerInfo);
1:ac23437: 
1:ac23437:         // Create a destination on the local broker
1:f6cf0ba:         ActiveMQDestination destinationInfo1 = null;
1:ac23437: 
1:ac23437:         // Send a 10 messages to the local broker
1:f6cf0ba:         for (int i = 0; i < sendNumMessages; ++i) {
1:c26dd6a:             destinationInfo1 = createDestinationInfo(connection1, connectionInfo1, ActiveMQDestination.QUEUE_TYPE);
1:c26dd6a:             connection1.request(createMessage(producerInfo, destinationInfo1, DeliveryMode.NON_PERSISTENT));
1:a15b395:         }
1:ac23437: 
1:ac23437:         // Ensure that there are 10 messages on the local broker
1:c26dd6a:         Object[] messages = browseQueueWithJmx(localBroker);
1:c26dd6a:         assertEquals(sendNumMessages, messages.length);
1:ac23437: 
1:ac23437:         // Create a synchronous consumer on the remote broker
1:af1b232:         StubConnection connection2 = createRemoteConnection();
1:f6cf0ba:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:f6cf0ba:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:f6cf0ba:         connection2.send(connectionInfo2);
1:f6cf0ba:         connection2.send(sessionInfo2);
1:ac23437:         ActiveMQDestination destinationInfo2 =
1:c26dd6a:             createDestinationInfo(connection2, connectionInfo2, ActiveMQDestination.QUEUE_TYPE);
1:a15b395:         final ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationInfo2);
2:f6cf0ba:         connection2.send(consumerInfo2);
1:ac23437: 
1:ac23437:         // Consume 5 of the messages from the remote broker and ack them.
2:f6cf0ba:         for (int i = 0; i < receiveNumMessages; ++i) {
1:af1b232:             Message message1 = receiveMessage(connection2, 20000);
1:c26dd6a:             assertNotNull(message1);
1:88d85ae:             LOG.info("on remote, got: " + message1.getMessageId());
1:af1b232:             connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:6f124c1:             assertTrue("JMSActiveMQBrokerPath property present and correct",
1:6f124c1:                     ((ActiveMQMessage)message1).getStringProperty(ActiveMQMessage.BROKER_PATH_PROPERTY).contains(localBroker.getBroker().getBrokerId().toString()));
1:c26dd6a:         }
1:ac23437: 
1:ac23437:         // Ensure that there are zero messages on the local broker. This tells
1:ac23437:         // us that those messages have been prefetched to the remote broker
1:af1b232:         // where the demand exists.
1:af1b232:         Wait.waitFor(new Wait.Condition() {
1:af1b232:             @Override
1:af1b232:             public boolean isSatisified() throws Exception {
1:af1b232:                 Object[] result = browseQueueWithJmx(localBroker);
1:af1b232:                return 0 == result.length;
1:af1b232:             }
1:af1b232:         });
1:c26dd6a:         messages = browseQueueWithJmx(localBroker);
1:c26dd6a:         assertEquals(0, messages.length);
1:af1b232: 
1:30a9fe1:         // try and pull the messages from remote, should be denied b/c on networkTtl
1:30a9fe1:         LOG.info("creating demand on second remote...");
1:30a9fe1:         StubConnection connection3 = createSecondRemoteConnection();
1:30a9fe1:         ConnectionInfo connectionInfo3 = createConnectionInfo();
1:30a9fe1:         SessionInfo sessionInfo3 = createSessionInfo(connectionInfo3);
1:30a9fe1:         connection3.send(connectionInfo3);
1:30a9fe1:         connection3.send(sessionInfo3);
1:30a9fe1:         ActiveMQDestination destinationInfo3 =
1:30a9fe1:             createDestinationInfo(connection3, connectionInfo3, ActiveMQDestination.QUEUE_TYPE);
1:30a9fe1:         final ConsumerInfo consumerInfoS3 = createConsumerInfo(sessionInfo3, destinationInfo3);
1:30a9fe1:         connection3.send(consumerInfoS3);
1:30a9fe1: 
1:30a9fe1:         Message messageExceedingTtl = receiveMessage(connection3, 5000);
1:30a9fe1:         if (messageExceedingTtl != null) {
1:30a9fe1:             LOG.error("got message on Second remote: " + messageExceedingTtl);
1:30a9fe1:             connection3.send(createAck(consumerInfoS3, messageExceedingTtl, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:30a9fe1:         }
1:30a9fe1: 
1:af1b232:         LOG.info("Closing consumer on remote");
1:ac23437:         // Close the consumer on the remote broker
1:c26dd6a:         connection2.send(consumerInfo2.createRemoveCommand());
1:af1b232:         // also close connection etc.. so messages get dropped from the local consumer  q
1:af1b232:         connection2.send(connectionInfo2.createRemoveCommand());
1:af1b232: 
1:af1b232:         // There should now be 5 messages stuck on the remote broker
1:88d85ae:         assertTrue("correct stuck message count", Wait.waitFor(new Wait.Condition() {
1:88d85ae:             @Override
1:88d85ae:             public boolean isSatisified() throws Exception {
1:88d85ae:                 Object[] result = browseQueueWithJmx(remoteBroker);
1:88d85ae:                 return 5 == result.length;
1:88d85ae:             }
1:88d85ae:         }));
1:c26dd6a:         messages = browseQueueWithJmx(remoteBroker);
1:c26dd6a:         assertEquals(5, messages.length);
1:af1b232: 
1:6f124c1:         assertTrue("can see broker path property",
1:6f124c1:                 ((String)((CompositeData)messages[1]).get("BrokerPath")).contains(localBroker.getBroker().getBrokerId().toString()));
1:6f124c1: 
1:6f124c1:         LOG.info("Messages now stuck on remote");
1:af1b232: 
1:af1b232:         // receive again on the origin broker
1:f6cf0ba:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationInfo1);
1:f6cf0ba:         connection1.send(consumerInfo1);
1:af1b232:         LOG.info("create local consumer: " + consumerInfo1);
1:af1b232: 
1:af1b232:         Message message1 = receiveMessage(connection1, 20000);
1:af1b232:         assertNotNull("Expect to get a replay as remote consumer is gone", message1);
1:af1b232:         connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:af1b232:         LOG.info("acked one message on origin, waiting for all messages to percolate back");
1:af1b232: 
1:af1b232:         Wait.waitFor(new Wait.Condition() {
1:af1b232:             @Override
1:af1b232:             public boolean isSatisified() throws Exception {
1:af1b232:                 Object[] result = browseQueueWithJmx(localBroker);
1:af1b232:                return 4 == result.length;
1:af1b232:             }
1:af1b232:         });
1:af1b232:         messages = browseQueueWithJmx(localBroker);
1:af1b232:         assertEquals(4, messages.length);
1:af1b232: 
1:af1b232:         LOG.info("checking for messages on remote again");
1:af1b232:         // messages won't migrate back again till consumer closes
1:af1b232:         connection2 = createRemoteConnection();
1:af1b232:         connectionInfo2 = createConnectionInfo();
1:af1b232:         sessionInfo2 = createSessionInfo(connectionInfo2);
1:af1b232:         connection2.send(connectionInfo2);
1:af1b232:         connection2.send(sessionInfo2);
1:a15b395:         ConsumerInfo consumerInfo3 = createConsumerInfo(sessionInfo2, destinationInfo2);
1:a15b395:         connection2.send(consumerInfo3);
1:af1b232:         message1 = receiveMessage(connection2, 20000);
1:af1b232:         assertNull("Messages have migrated back: " + message1, message1);
1:af1b232: 
1:af1b232:         // Consume the last 4 messages from the local broker and ack them just
1:ac23437:         // to clean up the queue.
1:af1b232:         int counter = 1;
1:af1b232:         for (; counter < receiveNumMessages; counter++) {
1:af1b232:             message1 = receiveMessage(connection1);
1:88d85ae:             LOG.info("local consume of: " + (message1 != null ? message1.getMessageId() : " null"));
1:af1b232:             connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:c26dd6a:         }
1:a15b395:         // Ensure that 5 messages were received
1:a15b395:         assertEquals(receiveNumMessages, counter);
1:af1b232: 
1:af1b232:         // verify all messages consumed
1:af1b232:         Wait.waitFor(new Wait.Condition() {
1:af1b232:             @Override
1:af1b232:             public boolean isSatisified() throws Exception {
1:af1b232:                 Object[] result = browseQueueWithJmx(remoteBroker);
1:af1b232:                return 0 == result.length;
1:af1b232:             }
1:af1b232:         });
1:c26dd6a:         messages = browseQueueWithJmx(remoteBroker);
1:af1b232:         assertEquals(0, messages.length);
1:af1b232: 
1:af1b232:         Wait.waitFor(new Wait.Condition() {
1:af1b232:             @Override
1:af1b232:             public boolean isSatisified() throws Exception {
1:af1b232:                 Object[] result = browseQueueWithJmx(localBroker);
1:af1b232:                return 0 == result.length;
1:af1b232:             }
1:af1b232:         });
1:af1b232:         messages = browseQueueWithJmx(localBroker);
1:c26dd6a:         assertEquals(0, messages.length);
1:af1b232: 
1:ac23437:         // Close the consumer on the remote broker
1:a15b395:         connection2.send(consumerInfo3.createRemoveCommand());
1:ac23437: 
1:a15b395:         connection1.stop();
1:a15b395:         connection2.stop();
1:30a9fe1:         connection3.stop();
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected BrokerService createBroker() throws Exception {
1:ac23437:         localBroker = new BrokerService();
1:c26dd6a:         localBroker.setBrokerName("localhost");
1:c26dd6a:         localBroker.setUseJmx(true);
1:c26dd6a:         localBroker.setPersistenceAdapter(null);
1:c26dd6a:         localBroker.setPersistent(false);
1:c26dd6a:         connector = createConnector();
1:c26dd6a:         localBroker.addConnector(connector);
1:af1b232:         configureBroker(localBroker);
1:c26dd6a:         localBroker.start();
1:c26dd6a:         localBroker.waitUntilStarted();
1:ac23437: 
1:c26dd6a:         localBroker.getManagementContext().setConnectorPort(2221);
1:ac23437: 
1:c26dd6a:         brokers.put(localBroker.getBrokerName(), localBroker);
1:ac23437: 
1:c26dd6a:         return localBroker;
1:c26dd6a:     }
1:af1b232: 
1:af1b232:     private void configureBroker(BrokerService broker) {
1:af1b232:         PolicyMap policyMap = new PolicyMap();
1:af1b232:         PolicyEntry defaultEntry = new PolicyEntry();
1:af1b232:         defaultEntry.setExpireMessagesPeriod(0);
1:af1b232:         ConditionalNetworkBridgeFilterFactory filterFactory = new ConditionalNetworkBridgeFilterFactory();
1:af1b232:         filterFactory.setReplayWhenNoConsumers(true);
1:af1b232:         defaultEntry.setNetworkBridgeFilterFactory(filterFactory);
1:af1b232:         policyMap.setDefaultEntry(defaultEntry);
1:af1b232:         broker.setDestinationPolicy(policyMap);
1:af1b232:     }
1:af1b232: 
1:c26dd6a:     protected BrokerService createRemoteBroker() throws Exception {
1:c26dd6a:         remoteBroker = new BrokerService();
1:c26dd6a:         remoteBroker.setBrokerName("remotehost");
1:c26dd6a:         remoteBroker.setUseJmx(true);
1:c26dd6a:         remoteBroker.setPersistenceAdapter(null);
1:c26dd6a:         remoteBroker.setPersistent(false);
1:c26dd6a:         remoteConnector = createRemoteConnector();
1:c26dd6a:         remoteBroker.addConnector(remoteConnector);
1:af1b232:         configureBroker(remoteBroker);
1:af1b232:         remoteBroker.start();
1:c26dd6a:         remoteBroker.waitUntilStarted();
1:ac23437: 
1:c26dd6a:         remoteBroker.getManagementContext().setConnectorPort(2222);
1:ac23437: 
1:c26dd6a:         brokers.put(remoteBroker.getBrokerName(), remoteBroker);
1:ac23437: 
1:c26dd6a:         return remoteBroker;
1:c26dd6a:     }
1:ac23437: 
1:30a9fe1:     protected BrokerService createSecondRemoteBroker() throws Exception {
1:30a9fe1:         secondRemoteBroker = new BrokerService();
1:30a9fe1:         secondRemoteBroker.setBrokerName("secondRemotehost");
1:30a9fe1:         secondRemoteBroker.setUseJmx(false);
1:30a9fe1:         secondRemoteBroker.setPersistenceAdapter(null);
1:30a9fe1:         secondRemoteBroker.setPersistent(false);
1:30a9fe1:         secondRemoteConnector = createSecondRemoteConnector();
1:30a9fe1:         secondRemoteBroker.addConnector(secondRemoteConnector);
1:30a9fe1:         configureBroker(secondRemoteBroker);
1:30a9fe1:         secondRemoteBroker.start();
1:30a9fe1:         secondRemoteBroker.waitUntilStarted();
1:30a9fe1: 
1:30a9fe1:         brokers.put(secondRemoteBroker.getBrokerName(), secondRemoteBroker);
1:30a9fe1: 
1:30a9fe1:         return secondRemoteBroker;
1:30a9fe1:     }
1:30a9fe1: 
1:c26dd6a:     protected Transport createTransport() throws Exception {
1:c26dd6a:         Transport transport = TransportFactory.connect(connector.getServer().getConnectURI());
1:c26dd6a:         return transport;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected Transport createRemoteTransport() throws Exception {
1:c26dd6a:         Transport transport = TransportFactory.connect(remoteConnector.getServer().getConnectURI());
1:c26dd6a:         return transport;
1:c26dd6a:     }
1:ac23437: 
1:30a9fe1:     protected Transport createSecondRemoteTransport() throws Exception {
1:30a9fe1:         Transport transport = TransportFactory.connect(secondRemoteConnector.getServer().getConnectURI());
1:30a9fe1:         return transport;
1:30a9fe1:     }
1:30a9fe1: 
1:c26dd6a:     protected TransportConnector createConnector() throws Exception, IOException, URISyntaxException {
1:c26dd6a:         return new TransportConnector(TransportFactory.bind(new URI(getLocalURI())));
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected TransportConnector createRemoteConnector() throws Exception, IOException, URISyntaxException {
1:c26dd6a:         return new TransportConnector(TransportFactory.bind(new URI(getRemoteURI())));
1:c26dd6a:     }
1:ac23437: 
1:30a9fe1:     protected TransportConnector createSecondRemoteConnector() throws Exception, IOException, URISyntaxException {
1:30a9fe1:         return new TransportConnector(TransportFactory.bind(new URI(getSecondRemoteURI())));
1:30a9fe1:     }
1:30a9fe1: 
1:c26dd6a:     protected String getRemoteURI() {
1:c26dd6a:         return "vm://remotehost";
1:c26dd6a:     }
1:ac23437: 
1:30a9fe1:     protected String getSecondRemoteURI() {
1:30a9fe1:         return "vm://secondRemotehost";
1:30a9fe1:     }
1:30a9fe1: 
1:c26dd6a:     protected String getLocalURI() {
1:c26dd6a:         return "vm://localhost";
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected StubConnection createConnection() throws Exception {
1:c26dd6a:         Transport transport = TransportFactory.connect(connector.getServer().getConnectURI());
1:c26dd6a:         StubConnection connection = new StubConnection(transport);
1:c26dd6a:         connections.add(connection);
1:c26dd6a:         return connection;
1:c26dd6a:     }
1:c26dd6a: 
1:c26dd6a:     protected StubConnection createRemoteConnection() throws Exception {
1:c26dd6a:         Transport transport = TransportFactory.connect(remoteConnector.getServer().getConnectURI());
1:c26dd6a:         StubConnection connection = new StubConnection(transport);
1:c26dd6a:         connections.add(connection);
1:c26dd6a:         return connection;
1:c26dd6a:     }
1:c26dd6a: 
1:30a9fe1:     protected StubConnection createSecondRemoteConnection() throws Exception {
1:30a9fe1:         Transport transport = TransportFactory.connect(secondRemoteConnector.getServer().getConnectURI());
1:30a9fe1:         StubConnection connection = new StubConnection(transport);
1:30a9fe1:         connections.add(connection);
1:30a9fe1:         return connection;
1:30a9fe1:     }
1:30a9fe1: 
1:ac23437:     @SuppressWarnings({ "unchecked", "unused" })
1:ac23437:     private Object[] browseQueueWithJms(BrokerService broker) throws Exception {
1:ac23437:         Object[] messages = null;
1:ac23437:         Connection connection = null;
1:ac23437:         Session session = null;
1:ac23437: 
1:ac23437:         try {
1:ac23437:             URI brokerUri = connector.getUri();
1:ac23437:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUri.toString());
1:ac23437:             connection = connectionFactory.createConnection();
1:ac23437:             connection.start();
1:ac23437:             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ac23437:             Queue destination = session.createQueue(queueName);
1:ac23437:             QueueBrowser browser = session.createBrowser(destination);
1:ac23437:             List<Message> list = new ArrayList<Message>();
1:ac23437:             for (Enumeration<Message> enumn = browser.getEnumeration(); enumn.hasMoreElements();) {
1:ac23437:                 list.add(enumn.nextElement());
1:ac23437:             }
1:ac23437:             messages = list.toArray();
1:ac23437:         }
1:ac23437:         finally {
1:ac23437:             if (session != null) {
1:ac23437:                 session.close();
1:ac23437:             }
1:ac23437:             if (connection != null) {
1:ac23437:                 connection.close();
1:ac23437:             }
1:ac23437:         }
1:ac23437:         LOG.info("+Browsed with JMS: " + messages.length);
1:ac23437: 
2:c26dd6a:         return messages;
1:c26dd6a:     }
1:ac23437: 
1:ac23437:     private Object[] browseQueueWithJmx(BrokerService broker) throws Exception {
1:ac23437:         Hashtable<String, String> params = new Hashtable<String, String>();
1:ac23437:         params.put("brokerName", broker.getBrokerName());
1:ac23437:         params.put("type", "Broker");
1:ac23437:         params.put("destinationType", "Queue");
1:ac23437:         params.put("destinationName", queueName);
1:ac23437:         ObjectName queueObjectName = ObjectName.getInstance(amqDomain, params);
1:ac23437: 
1:d7a8bc8:         ManagementContext mgmtCtx = broker.getManagementContext();
1:d7a8bc8:         QueueViewMBean queueView = (QueueViewMBean)mgmtCtx.newProxyInstance(queueObjectName, QueueViewMBean.class, true);
1:d7a8bc8: 
1:ac23437:         Object[] messages = queueView.browse();
1:ac23437: 
1:ac23437:         LOG.info("+Browsed with JMX: " + messages.length);
1:ac23437: 
1:ac23437:         return messages;
1:ac23437:     }
1:ac23437: 
1:c26dd6a:     protected ConnectionInfo createConnectionInfo() throws Exception {
1:c26dd6a:         ConnectionInfo info = new ConnectionInfo();
1:c26dd6a:         info.setConnectionId(new ConnectionId("connection:" + (++idGenerator)));
1:c26dd6a:         info.setClientId(info.getConnectionId().getValue());
1:c26dd6a:         return info;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected SessionInfo createSessionInfo(ConnectionInfo connectionInfo) throws Exception {
1:c26dd6a:         SessionInfo info = new SessionInfo(connectionInfo, ++idGenerator);
1:c26dd6a:         return info;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected ProducerInfo createProducerInfo(SessionInfo sessionInfo) throws Exception {
1:c26dd6a:         ProducerInfo info = new ProducerInfo(sessionInfo, ++idGenerator);
1:c26dd6a:         return info;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected ConsumerInfo createConsumerInfo(SessionInfo sessionInfo, ActiveMQDestination destination) throws Exception {
1:c26dd6a:         ConsumerInfo info = new ConsumerInfo(sessionInfo, ++idGenerator);
1:c26dd6a:         info.setBrowser(false);
1:c26dd6a:         info.setDestination(destination);
1:c26dd6a:         info.setPrefetchSize(1000);
1:c26dd6a:         info.setDispatchAsync(false);
1:c26dd6a:         return info;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected DestinationInfo createTempDestinationInfo(ConnectionInfo connectionInfo, byte destinationType) {
1:c26dd6a:         DestinationInfo info = new DestinationInfo();
1:c26dd6a:         info.setConnectionId(connectionInfo.getConnectionId());
1:c26dd6a:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:c26dd6a:         info.setDestination(ActiveMQDestination.createDestination(info.getConnectionId() + ":" + (++tempDestGenerator), destinationType));
1:c26dd6a:         return info;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected ActiveMQDestination createDestinationInfo(StubConnection connection, ConnectionInfo connectionInfo1, byte destinationType) throws Exception {
1:c26dd6a:         if ((destinationType & ActiveMQDestination.TEMP_MASK) != 0) {
1:c26dd6a:             DestinationInfo info = createTempDestinationInfo(connectionInfo1, destinationType);
1:c26dd6a:             connection.send(info);
1:c26dd6a:             return info.getDestination();
1:c26dd6a:         } else {
1:c26dd6a:             return ActiveMQDestination.createDestination(queueName, destinationType);
1:c26dd6a:         }
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode) {
1:c26dd6a:         Message message = createMessage(producerInfo, destination);
1:c26dd6a:         message.setPersistent(deliveryMode == DeliveryMode.PERSISTENT);
1:c26dd6a:         return message;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination) {
1:c26dd6a:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:c26dd6a:         message.setMessageId(new MessageId(producerInfo, ++msgIdGenerator));
1:c26dd6a:         message.setDestination(destination);
1:c26dd6a:         message.setPersistent(false);
2:c26dd6a:         try {
1:c26dd6a:             message.setText("Test Message Payload.");
1:c26dd6a:         } catch (MessageNotWriteableException e) {
1:c26dd6a:         }
1:c26dd6a:         return message;
1:c26dd6a:     }
1:c26dd6a: 
1:c26dd6a:     protected MessageAck createAck(ConsumerInfo consumerInfo, Message msg, int count, byte ackType) {
1:c26dd6a:         MessageAck ack = new MessageAck();
1:c26dd6a:         ack.setAckType(ackType);
1:c26dd6a:         ack.setConsumerId(consumerInfo.getConsumerId());
1:c26dd6a:         ack.setDestination(msg.getDestination());
1:c26dd6a:         ack.setLastMessageId(msg.getMessageId());
1:c26dd6a:         ack.setMessageCount(count);
1:c26dd6a:         return ack;
1:c26dd6a:     }
1:ac23437: 
1:c26dd6a:     public Message receiveMessage(StubConnection connection) throws InterruptedException {
1:c26dd6a:         return receiveMessage(connection, maxWait);
1:c26dd6a:     }
1:c26dd6a: 
1:c26dd6a:     public Message receiveMessage(StubConnection connection, long timeout) throws InterruptedException {
1:c26dd6a:         while (true) {
1:c26dd6a:             Object o = connection.getDispatchQueue().poll(timeout, TimeUnit.MILLISECONDS);
1:c26dd6a: 
1:c26dd6a:             if (o == null) {
1:c26dd6a:                 return null;
1:c26dd6a:             }
1:c26dd6a:             if (o instanceof MessageDispatch) {
1:c26dd6a: 
1:c26dd6a:                 MessageDispatch dispatch = (MessageDispatch)o;
1:c26dd6a:                 if (dispatch.getMessage() == null) {
1:c26dd6a:                     return null;
1:c26dd6a:                 }
1:c26dd6a:                 dispatch.setMessage(dispatch.getMessage().copy());
1:c26dd6a:                 dispatch.getMessage().setRedeliveryCounter(dispatch.getRedeliveryCounter());
1:c26dd6a:                 return dispatch.getMessage();
1:c26dd6a:             }
1:c26dd6a:         }
1:c26dd6a:     }
1:c26dd6a: }
============================================================================
author:Gary Tully
-------------------------------------------------------------------------------
commit:6f124c1
/////////////////////////////////////////////////////////////////////////
1: import javax.management.openmbean.CompositeData;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("JMSActiveMQBrokerPath property present and correct",
1:                     ((ActiveMQMessage)message1).getStringProperty(ActiveMQMessage.BROKER_PATH_PROPERTY).contains(localBroker.getBroker().getBrokerId().toString()));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("can see broker path property",
1:                 ((String)((CompositeData)messages[1]).get("BrokerPath")).contains(localBroker.getBroker().getBrokerId().toString()));
1: 
1:         LOG.info("Messages now stuck on remote");
commit:88d85ae
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("on remote, got: " + message1.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("correct stuck message count", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] result = browseQueueWithJmx(remoteBroker);
1:                 return 5 == result.length;
1:             }
1:         }));
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("local consume of: " + (message1 != null ? message1.getMessageId() : " null"));
commit:30a9fe1
/////////////////////////////////////////////////////////////////////////
1:     private BrokerService secondRemoteBroker;
/////////////////////////////////////////////////////////////////////////
1:     protected TransportConnector secondRemoteConnector;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // introduce a second broker/bridge on remote that should not get any messages because of networkTtl=1
1:         // local <-> remote <-> secondRemote
1:         createSecondRemoteBroker();
1:         config = new NetworkBridgeConfiguration();
1:         config.setBrokerName("remote");
1:         config.setDuplex(true);
1: 
1:         localTransport = createRemoteTransport();
1:         remoteTransport = createSecondRemoteTransport();
1: 
1:         // Create a network bridge between the two brokers
1:         bridge = new DemandForwardingBridge(config, localTransport, remoteTransport);
1:         bridge.setBrokerService(remoteBroker);
1:         bridge.start();
1: 
/////////////////////////////////////////////////////////////////////////
1:         secondRemoteBroker.stop();
/////////////////////////////////////////////////////////////////////////
1:         // try and pull the messages from remote, should be denied b/c on networkTtl
1:         LOG.info("creating demand on second remote...");
1:         StubConnection connection3 = createSecondRemoteConnection();
1:         ConnectionInfo connectionInfo3 = createConnectionInfo();
1:         SessionInfo sessionInfo3 = createSessionInfo(connectionInfo3);
1:         connection3.send(connectionInfo3);
1:         connection3.send(sessionInfo3);
1:         ActiveMQDestination destinationInfo3 =
1:             createDestinationInfo(connection3, connectionInfo3, ActiveMQDestination.QUEUE_TYPE);
1:         final ConsumerInfo consumerInfoS3 = createConsumerInfo(sessionInfo3, destinationInfo3);
1:         connection3.send(consumerInfoS3);
1: 
1:         Message messageExceedingTtl = receiveMessage(connection3, 5000);
1:         if (messageExceedingTtl != null) {
1:             LOG.error("got message on Second remote: " + messageExceedingTtl);
1:             connection3.send(createAck(consumerInfoS3, messageExceedingTtl, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         connection3.stop();
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerService createSecondRemoteBroker() throws Exception {
1:         secondRemoteBroker = new BrokerService();
1:         secondRemoteBroker.setBrokerName("secondRemotehost");
1:         secondRemoteBroker.setUseJmx(false);
1:         secondRemoteBroker.setPersistenceAdapter(null);
1:         secondRemoteBroker.setPersistent(false);
1:         secondRemoteConnector = createSecondRemoteConnector();
1:         secondRemoteBroker.addConnector(secondRemoteConnector);
1:         configureBroker(secondRemoteBroker);
1:         secondRemoteBroker.start();
1:         secondRemoteBroker.waitUntilStarted();
1: 
1:         brokers.put(secondRemoteBroker.getBrokerName(), secondRemoteBroker);
1: 
1:         return secondRemoteBroker;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected Transport createSecondRemoteTransport() throws Exception {
1:         Transport transport = TransportFactory.connect(secondRemoteConnector.getServer().getConnectURI());
1:         return transport;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected TransportConnector createSecondRemoteConnector() throws Exception, IOException, URISyntaxException {
1:         return new TransportConnector(TransportFactory.bind(new URI(getSecondRemoteURI())));
1:     }
1: 
1:     protected String getSecondRemoteURI() {
1:         return "vm://secondRemotehost";
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected StubConnection createSecondRemoteConnection() throws Exception {
1:         Transport transport = TransportFactory.connect(secondRemoteConnector.getServer().getConnectURI());
1:         StubConnection connection = new StubConnection(transport);
1:         connections.add(connection);
1:         return connection;
1:     }
1: 
commit:af1b232
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
1:         config.setDuplex(true);
1: 
/////////////////////////////////////////////////////////////////////////
1:         StubConnection connection2 = createRemoteConnection();
/////////////////////////////////////////////////////////////////////////
1:             Message message1 = receiveMessage(connection2, 20000);
1:             connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:         // where the demand exists.
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] result = browseQueueWithJmx(localBroker);
1:                return 0 == result.length;
1:             }
1:         });
1: 
1:         LOG.info("Closing consumer on remote");
1:         // also close connection etc.. so messages get dropped from the local consumer  q
1:         connection2.send(connectionInfo2.createRemoveCommand());
1: 
1:         // There should now be 5 messages stuck on the remote broker
1: 
0:          LOG.info("Messages now stuck on remote");
1: 
1:         // receive again on the origin broker
1:         LOG.info("create local consumer: " + consumerInfo1);
1: 
1:         Message message1 = receiveMessage(connection1, 20000);
1:         assertNotNull("Expect to get a replay as remote consumer is gone", message1);
1:         connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1:         LOG.info("acked one message on origin, waiting for all messages to percolate back");
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] result = browseQueueWithJmx(localBroker);
1:                return 4 == result.length;
1:             }
1:         });
1:         messages = browseQueueWithJmx(localBroker);
1:         assertEquals(4, messages.length);
1: 
1:         LOG.info("checking for messages on remote again");
1:         // messages won't migrate back again till consumer closes
1:         connection2 = createRemoteConnection();
1:         connectionInfo2 = createConnectionInfo();
1:         sessionInfo2 = createSessionInfo(connectionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         message1 = receiveMessage(connection2, 20000);
1:         assertNull("Messages have migrated back: " + message1, message1);
1: 
1:         // Consume the last 4 messages from the local broker and ack them just
1:         int counter = 1;
1:         for (; counter < receiveNumMessages; counter++) {
1:             message1 = receiveMessage(connection1);
1:             connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));
1: 
1:         // verify all messages consumed
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] result = browseQueueWithJmx(remoteBroker);
1:                return 0 == result.length;
1:             }
1:         });
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] result = browseQueueWithJmx(localBroker);
1:                return 0 == result.length;
1:             }
1:         });
1:         messages = browseQueueWithJmx(localBroker);
1:         assertEquals(0, messages.length);
1: 
/////////////////////////////////////////////////////////////////////////
1:         configureBroker(localBroker);
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void configureBroker(BrokerService broker) {
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setExpireMessagesPeriod(0);
1:         ConditionalNetworkBridgeFilterFactory filterFactory = new ConditionalNetworkBridgeFilterFactory();
1:         filterFactory.setReplayWhenNoConsumers(true);
1:         defaultEntry.setNetworkBridgeFilterFactory(filterFactory);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         broker.setDestinationPolicy(policyMap);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         configureBroker(remoteBroker);
1:         remoteBroker.start();
commit:d7a8bc8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
/////////////////////////////////////////////////////////////////////////
1:         ManagementContext mgmtCtx = broker.getManagementContext();
1:         QueueViewMBean queueView = (QueueViewMBean)mgmtCtx.newProxyInstance(queueObjectName, QueueViewMBean.class, true);
1:         
0:         Object[] messages = (Object[]) queueView.browse();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:9fece8f
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1: public class BrokerNetworkWithStuckMessagesTest {
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:     public void setUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void tearDown() throws Exception {
1:     @Test(timeout=120000)
/////////////////////////////////////////////////////////////////////////
commit:ac23437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * This class duplicates most of the functionality in {@link NetworkTestSupport}
1:  * and {@link BrokerTestSupport} because more control was needed over how brokers
1:  * and connectors are created. Also, this test asserts message counts via JMX on
1:  * each broker.
1: 
1: 
1:     private BrokerService localBroker;
1:     private BrokerService remoteBroker;
1: 
1:     protected ArrayList<StubConnection> connections = new ArrayList<StubConnection>();
1: 
1: 
1: 
1: 
1:     @Override
1: 
1:         // For those who want visual confirmation:
1:         //   Uncomment the following to enable JMX support on a port number to use
1:         //   Jconsole to view each broker. You will need to add some calls to
1:         //   Thread.sleep() to be able to actually slow things down so that you
1:         //   can manually see JMX attrs.
1: 
1:         // Create the local broker
1:         // Create the remote broker
1: 
1: 
1:         // Create a network bridge between the local and remote brokers so that
1:         Transport localTransport = createTransport();
1: 
1:         // Create a network bridge between the two brokers
1: 
1: 
1: 
1:                 // Max wait here is 30 secs
1:                     @Override
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // Create a producer
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Create a destination on the local broker
1: 
1:         // Send a 10 messages to the local broker
1: 
1:         // Ensure that there are 10 messages on the local broker
1: 
1: 
1:         // Create a synchronous consumer on the remote broker
1:         ActiveMQDestination destinationInfo2 =
1: 
1:         // Consume 5 of the messages from the remote broker and ack them.
1: 
1:         // Ensure that there are zero messages on the local broker. This tells
1:         // us that those messages have been prefetched to the remote broker
/////////////////////////////////////////////////////////////////////////
1:         // Close the consumer on the remote broker
/////////////////////////////////////////////////////////////////////////
1:         // to clean up the queue.
/////////////////////////////////////////////////////////////////////////
1:         // Close the consumer on the remote broker
1: 
1: 
1:         localBroker = new BrokerService();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "unchecked", "unused" })
1:     private Object[] browseQueueWithJms(BrokerService broker) throws Exception {
1:         Object[] messages = null;
1:         Connection connection = null;
1:         Session session = null;
1: 
1:         try {
1:             URI brokerUri = connector.getUri();
1:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUri.toString());
1:             connection = connectionFactory.createConnection();
1:             connection.start();
1:             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Queue destination = session.createQueue(queueName);
1:             QueueBrowser browser = session.createBrowser(destination);
1:             List<Message> list = new ArrayList<Message>();
1:             for (Enumeration<Message> enumn = browser.getEnumeration(); enumn.hasMoreElements();) {
1:                 list.add(enumn.nextElement());
1:             }
1:             messages = list.toArray();
1:         }
1:         finally {
1:             if (session != null) {
1:                 session.close();
1:             }
1:             if (connection != null) {
1:                 connection.close();
1:             }
1:         }
1:         LOG.info("+Browsed with JMS: " + messages.length);
1: 
1: 
1:     private Object[] browseQueueWithJmx(BrokerService broker) throws Exception {
1:         Hashtable<String, String> params = new Hashtable<String, String>();
1:         params.put("brokerName", broker.getBrokerName());
1:         params.put("type", "Broker");
1:         params.put("destinationType", "Queue");
1:         params.put("destinationName", queueName);
1:         ObjectName queueObjectName = ObjectName.getInstance(amqDomain, params);
1: 
0:         ManagementContext mgmtCtx = broker.getManagementContext();
0:         QueueViewMBean queueView = (QueueViewMBean)mgmtCtx.newProxyInstance(queueObjectName, QueueViewMBean.class, true);
1: 
1:         Object[] messages = queueView.browse();
1: 
1:         LOG.info("+Browsed with JMX: " + messages.length);
1: 
1:         return messages;
1:     }
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(BrokerNetworkWithStuckMessagesTest.class);
commit:261ccab
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:c26dd6a
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Hashtable;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.TimeUnit;
1: import javax.jms.Connection;
1: import javax.jms.MessageNotWriteableException;
1: import javax.jms.Queue;
1: import javax.jms.QueueBrowser;
1: import javax.jms.Session;
0: import javax.management.MBeanServer;
1: import javax.management.ObjectName;
0: import junit.framework.TestCase;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerTestSupport;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.jmx.ManagementContext;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.transport.TransportFactory;
1: /**
0:  * This class duplicates most of the functionality in {@link NetworkTestSupport} 
0:  * and {@link BrokerTestSupport} because more control was needed over how brokers 
0:  * and connectors are created. Also, this test asserts message counts via JMX on 
0:  * each broker. 
0:  * 
0:  * @author bsnyder
0:  *
1:  */
0: public class BrokerNetworkWithStuckMessagesTest extends TestCase /*NetworkTestSupport*/ {
1:     
1:     
0:     private BrokerService localBroker; 
0:     private BrokerService remoteBroker; 
1:     private DemandForwardingBridge bridge;
1:     
1:     protected Map<String, BrokerService> brokers = new HashMap<String, BrokerService>();
0:     protected ArrayList connections = new ArrayList();
1:     
1:     protected TransportConnector connector;
1:     protected TransportConnector remoteConnector;
1:     
1:     protected long idGenerator;
1:     protected int msgIdGenerator;
1:     protected int tempDestGenerator;
1:     protected int maxWait = 4000;
1:     protected String queueName = "TEST";
1:     
1:     protected String amqDomain = "org.apache.activemq";
1:         
0:     protected void setUp() throws Exception {
1:         
0:         // For those who want visual confirmation: 
0:         //   Uncomment the following to enable JMX support on a port number to use 
0:         //   Jconsole to view each broker. You will need to add some calls to 
0:         //   Thread.sleep() to be able to actually slow things down so that you 
0:         //   can manually see JMX attrs. 
1: //        System.setProperty("com.sun.management.jmxremote", "");
1: //        System.setProperty("com.sun.management.jmxremote.port", "1099");
1: //        System.setProperty("com.sun.management.jmxremote.authenticate", "false");
1: //        System.setProperty("com.sun.management.jmxremote.ssl", "false");
1:         
0:         // Create the local broker 
1:         createBroker();
0:         // Create the remote broker 
1:         createRemoteBroker();
1:         
1:         // Remove the activemq-data directory from the creation of the remote broker
1:         FileUtils.deleteDirectory(new File("activemq-data"));
/////////////////////////////////////////////////////////////////////////
0:         // Create a network bridge between the two brokers 
1:         bridge.setBrokerService(localBroker);
1:         waitForBridgeFormation();
0:     
1:     protected void waitForBridgeFormation() throws Exception {
1:         for (final BrokerService broker : brokers.values()) {
1:             if (!broker.getNetworkConnectors().isEmpty()) {
0:             	// Max wait here is 30 secs
1:                 Wait.waitFor(new Wait.Condition() {
1:                     public boolean isSatisified() throws Exception {
1:                         return !broker.getNetworkConnectors().get(0).activeBridges().isEmpty();
1:                     }});
1:             }
1:         }
1:     }
0:     
0:     protected void tearDown() throws Exception {
1:         localBroker.stop();
1:         remoteBroker.stop();
1:     public void testBrokerNetworkWithStuckMessages() throws Exception {
0:         
1:         int sendNumMessages = 10;
1:         int receiveNumMessages = 5;
0:         
0:         // Create a producer 
1:         StubConnection connection1 = createConnection();
/////////////////////////////////////////////////////////////////////////
0:         // Send a 10 messages to the local broker 
1:             destinationInfo1 = createDestinationInfo(connection1, connectionInfo1, ActiveMQDestination.QUEUE_TYPE);
1:             connection1.request(createMessage(producerInfo, destinationInfo1, DeliveryMode.NON_PERSISTENT));
1:         Object[] messages = browseQueueWithJmx(localBroker);
1:         assertEquals(sendNumMessages, messages.length);
0:         // Create a synchronous consumer on the remote broker 
1:             createDestinationInfo(connection2, connectionInfo2, ActiveMQDestination.QUEUE_TYPE);
/////////////////////////////////////////////////////////////////////////
0:             Message message1 = receiveMessage(connection2);
1:             assertNotNull(message1);
0:             connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.STANDARD_ACK_TYPE));
0:             
0:             Object[] msgs1 = browseQueueWithJmx(remoteBroker);
0:             LOG.info("Found [" + msgs1.length + "] messages with JMX");
0: //            assertEquals((sendNumMessages-i), msgs.length);
1:         messages = browseQueueWithJmx(localBroker);
1:         assertEquals(0, messages.length);
0:         
0:         // Close the consumer on the remote broker 
1:         connection2.send(consumerInfo2.createRemoveCommand());
1:         messages = browseQueueWithJmx(remoteBroker);
1:         assertEquals(5, messages.length);
/////////////////////////////////////////////////////////////////////////
0:         //////////////////////////////////////////////////////
0:         //////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             message1 = receiveMessage(connection2);
0:             assertNotNull(message1);
0:         // Let those acks percolate... This stinks but it's the only way currently
0:         // because these types of internal broker actions are non-deterministic. 
0:         Thread.sleep(4000);
1:         messages = browseQueueWithJmx(remoteBroker);
1:         assertEquals(0, messages.length);
1:     }
0:     
1:     protected BrokerService createBroker() throws Exception {
0:         localBroker = new BrokerService(); 
1:         localBroker.setBrokerName("localhost");
1:         localBroker.setUseJmx(true);
1:         localBroker.setPersistenceAdapter(null);
1:         localBroker.setPersistent(false);
1:         connector = createConnector();
1:         localBroker.addConnector(connector);
1:         localBroker.start();
1:         localBroker.waitUntilStarted();
0:         
1:         localBroker.getManagementContext().setConnectorPort(2221);
0:         
1:         brokers.put(localBroker.getBrokerName(), localBroker);
0:         
1:         return localBroker;
1:     }
0:     
1:     protected BrokerService createRemoteBroker() throws Exception {
1:         remoteBroker = new BrokerService();
1:         remoteBroker.setBrokerName("remotehost");
1:         remoteBroker.setUseJmx(true);
1:         remoteBroker.setPersistenceAdapter(null);
1:         remoteBroker.setPersistent(false);
1:         remoteConnector = createRemoteConnector();
1:         remoteBroker.addConnector(remoteConnector);
1:         remoteBroker.waitUntilStarted();
0:         
1:         remoteBroker.getManagementContext().setConnectorPort(2222);
0:         
1:         brokers.put(remoteBroker.getBrokerName(), remoteBroker);
0:         
1:         return remoteBroker;
1:     }
0:     
1:     protected Transport createTransport() throws Exception {
1:         Transport transport = TransportFactory.connect(connector.getServer().getConnectURI());
1:         return transport;
1:     }
0:     
1:     protected Transport createRemoteTransport() throws Exception {
1:         Transport transport = TransportFactory.connect(remoteConnector.getServer().getConnectURI());
1:         return transport;
1:     }
0:     
1:     protected TransportConnector createConnector() throws Exception, IOException, URISyntaxException {
1:         return new TransportConnector(TransportFactory.bind(new URI(getLocalURI())));
1:     }
0:     
1:     protected TransportConnector createRemoteConnector() throws Exception, IOException, URISyntaxException {
1:         return new TransportConnector(TransportFactory.bind(new URI(getRemoteURI())));
1:     }
0:     
1:     protected String getRemoteURI() {
1:         return "vm://remotehost";
1:     }
0: 
1:     protected String getLocalURI() {
1:         return "vm://localhost";
1:     }
0:     
1:     protected StubConnection createConnection() throws Exception {
1:         Transport transport = TransportFactory.connect(connector.getServer().getConnectURI());
1:         StubConnection connection = new StubConnection(transport);
1:         connections.add(connection);
1:         return connection;
1:     }
0: 
1:     protected StubConnection createRemoteConnection() throws Exception {
1:         Transport transport = TransportFactory.connect(remoteConnector.getServer().getConnectURI());
1:         StubConnection connection = new StubConnection(transport);
1:         connections.add(connection);
1:         return connection;
1:     }
0:     
0:     @SuppressWarnings("unchecked")
0:     private Object[] browseQueueWithJms(BrokerService broker) throws Exception {
0: 		Object[] messages = null;
0: 		Connection connection = null;
0: 		Session session = null;
0: 
1: 		try {
0: 			URI brokerUri = connector.getUri();
0: 			ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUri.toString());
0: 			connection = connectionFactory.createConnection();
0: 			connection.start();
0: 			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			Queue destination = session.createQueue(queueName);
0: 			QueueBrowser browser = session.createBrowser(destination);
0: 			List<Message> list = new ArrayList<Message>();
0: 			for (Enumeration<Message> enumn = browser.getEnumeration(); enumn.hasMoreElements();) {
0: 				list.add(enumn.nextElement());
1: 			}
0: 			messages = list.toArray();
1: 		}
0: 		finally {
0: 			if (session != null) {
0: 				session.close();
1: 			}
0: 			if (connection != null) {
0: 				connection.close();
1: 			}
1: 		}
0: 		LOG.info("+Browsed with JMS: " + messages.length);
0: 		
1: 		return messages;
0:     
0:     private Object[] browseQueueWithJmx(BrokerService broker) throws Exception {
0:         Hashtable<String, String> params = new Hashtable<String, String>();
0:         params.put("BrokerName", broker.getBrokerName());
0:         params.put("Type", "Queue");
0:         params.put("Destination", queueName);
0:         ObjectName queueObjectName = ObjectName.getInstance(amqDomain, params);
0:         
0:         ManagementContext mgmtCtx = broker.getManagementContext(); 
0:         MBeanServer mbs = mgmtCtx.getMBeanServer(); 
0:         Object[] messages = (Object[]) mbs.invoke(queueObjectName, "browse", new Object[0], new String[0]);
0:         
0: 		LOG.info("+Browsed with JMX: " + messages.length);
0:         
1:         return messages;
1:     }
0:     
1:     protected ConnectionInfo createConnectionInfo() throws Exception {
1:         ConnectionInfo info = new ConnectionInfo();
1:         info.setConnectionId(new ConnectionId("connection:" + (++idGenerator)));
1:         info.setClientId(info.getConnectionId().getValue());
1:         return info;
1:     }
0:     
1:     protected SessionInfo createSessionInfo(ConnectionInfo connectionInfo) throws Exception {
1:         SessionInfo info = new SessionInfo(connectionInfo, ++idGenerator);
1:         return info;
1:     }
0:     
1:     protected ProducerInfo createProducerInfo(SessionInfo sessionInfo) throws Exception {
1:         ProducerInfo info = new ProducerInfo(sessionInfo, ++idGenerator);
1:         return info;
1:     }
0:     
1:     protected ConsumerInfo createConsumerInfo(SessionInfo sessionInfo, ActiveMQDestination destination) throws Exception {
1:         ConsumerInfo info = new ConsumerInfo(sessionInfo, ++idGenerator);
1:         info.setBrowser(false);
1:         info.setDestination(destination);
1:         info.setPrefetchSize(1000);
1:         info.setDispatchAsync(false);
1:         return info;
1:     }
0:     
1:     protected DestinationInfo createTempDestinationInfo(ConnectionInfo connectionInfo, byte destinationType) {
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(connectionInfo.getConnectionId());
1:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:         info.setDestination(ActiveMQDestination.createDestination(info.getConnectionId() + ":" + (++tempDestGenerator), destinationType));
1:         return info;
1:     }
0:     
1:     protected ActiveMQDestination createDestinationInfo(StubConnection connection, ConnectionInfo connectionInfo1, byte destinationType) throws Exception {
1:         if ((destinationType & ActiveMQDestination.TEMP_MASK) != 0) {
1:             DestinationInfo info = createTempDestinationInfo(connectionInfo1, destinationType);
1:             connection.send(info);
1:             return info.getDestination();
1:         } else {
1:             return ActiveMQDestination.createDestination(queueName, destinationType);
1:         }
1:     }
0:     
1:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode) {
1:         Message message = createMessage(producerInfo, destination);
1:         message.setPersistent(deliveryMode == DeliveryMode.PERSISTENT);
1:         return message;
1:     }
0:     
1:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination) {
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setMessageId(new MessageId(producerInfo, ++msgIdGenerator));
1:         message.setDestination(destination);
1:         message.setPersistent(false);
1:         try {
1:             message.setText("Test Message Payload.");
1:         } catch (MessageNotWriteableException e) {
1:         }
1:         return message;
1:     }
0: 
1:     protected MessageAck createAck(ConsumerInfo consumerInfo, Message msg, int count, byte ackType) {
1:         MessageAck ack = new MessageAck();
1:         ack.setAckType(ackType);
1:         ack.setConsumerId(consumerInfo.getConsumerId());
1:         ack.setDestination(msg.getDestination());
1:         ack.setLastMessageId(msg.getMessageId());
1:         ack.setMessageCount(count);
1:         return ack;
1:     }
0:     
1:     public Message receiveMessage(StubConnection connection) throws InterruptedException {
1:         return receiveMessage(connection, maxWait);
1:     }
0: 
1:     public Message receiveMessage(StubConnection connection, long timeout) throws InterruptedException {
1:         while (true) {
1:             Object o = connection.getDispatchQueue().poll(timeout, TimeUnit.MILLISECONDS);
0: 
1:             if (o == null) {
1:                 return null;
1:             }
1:             if (o instanceof MessageDispatch) {
0: 
1:                 MessageDispatch dispatch = (MessageDispatch)o;
1:                 if (dispatch.getMessage() == null) {
1:                     return null;
1:                 }
1:                 dispatch.setMessage(dispatch.getMessage().copy());
1:                 dispatch.getMessage().setRedeliveryCounter(dispatch.getRedeliveryCounter());
1:                 return dispatch.getMessage();
1:             }
1:         }
commit:a15b395
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.IOException;
0: 
0: import org.apache.activemq.command.Command;
1: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.Wait;
1: import org.apache.commons.io.FileUtils;
/////////////////////////////////////////////////////////////////////////
0:         
0:         Transport localTransport = createTransport(); 
0:         localTransport.setTransportListener(new TransportListener() {
0:         	Command command = null;
0: 			public void onCommand(Object o) {
0: 				this.command = (Command) o;
0: 				LOG.info("Command from [" + command.getFrom() + "] to [" + command.getTo() + "]");
1: 			}
0: 
0: 			public void onException(IOException error) {
0: 				LOG.info("Command from [" + command.getFrom() + "] to [" + command.getTo() + "]");
0: 				LOG.info("Exception: " + error);
1: 			}
0: 
0: 			public void transportInterupted() {
0: 				LOG.info("Interruption on local transport");
1: 			}
0: 
0: 			public void transportResumed() {
0: 				LOG.info("Resumption on local transport");
1: 			}
0:         });
0:         
1:         Transport remoteTransport = createRemoteTransport();
0:         remoteTransport.setTransportListener(new TransportListener() {
0:         	Command command = null;
0: 			public void onCommand(Object o) {
0: 				this.command = (Command) o;
0: 				LOG.info("Command from [" + command.getFrom() + "] to [" + command.getTo() + "]");
1: 			}
0: 
0: 			public void onException(IOException error) {
0: 				LOG.info("Command from [" + command.getFrom() + "] to [" + command.getTo() + "]");
0: 				LOG.info("Exception: " + error);
1: 			}
0: 
0: 			public void transportInterupted() {
0: 				LOG.info("Interruption on remote transport");
1: 			}
0: 
0: 			public void transportResumed() {
0: 				LOG.info("Resumption on remote transport");
1: 			}
0:         });
0:         
1:         bridge = new DemandForwardingBridge(config, localTransport, remoteTransport);
0: //        broker.setUseJmx(true);
0: //        remoteBroker.setUseJmx(true);
0:         // Make sure persistence is disabled 
0:         broker.setPersistent(false);
0:         broker.setPersistenceAdapter(null);
0:         remoteBroker.setPersistent(false);
0:         remoteBroker.setPersistenceAdapter(null);
0:         
0:         // Remove the activemq-data directory from the creation of the remote broker
0:         FileUtils.deleteDirectory(new File("activemq-data"));
/////////////////////////////////////////////////////////////////////////
0: //	        connection1.send(createMessage(producerInfo, destinationInfo1, DeliveryMode.NON_PERSISTENT));
0: 	        connection1.request(createMessage(producerInfo, destinationInfo1, DeliveryMode.NON_PERSISTENT));
0:         int messageCount1 = countMessagesInQueue(connection1, connectionInfo1, destinationInfo1);
0:         assertEquals(10, messageCount1);
0:         final StubConnection connection2 = createRemoteConnection();
1:         final ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationInfo2);
0:         // Because the prefetch size is set to 1000 in the createConsumerInfo() 
0:         // method, this will cause the messages on the local broker to be 
0:         // forwarded to the remote broker. 
0:         	assertTrue("Message " + i + " was not received", Wait.waitFor(new Wait.Condition() {
0:                 public boolean isSatisified() throws Exception {
0: 			        Message message1 = receiveMessage(connection2);
0: 			        assertNotNull(message1);
0: 		            connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.STANDARD_ACK_TYPE));
0:                     return message1 != null;
0:                 }            
0:             }));
0: //	        Message message1 = receiveMessage(connection2);
0: //	        assertNotNull(message1);
0: //          connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.STANDARD_ACK_TYPE));
/////////////////////////////////////////////////////////////////////////
0:         int messageCount2 = countMessagesInQueue(connection1, connectionInfo1, destinationInfo1);
0: // Sometimes it fails here 
0:         assertEquals(0, messageCount2);
0:         int messageCount3 = countMessagesInQueue(connection2, connectionInfo2, destinationInfo2);
0:         assertEquals(5, messageCount3);
/////////////////////////////////////////////////////////////////////////
0:         // messages are stuck on the remote broker. AMQ-2324 and AMQ-2484 aim 
0:         // to fix this situation so that messages don't get stuck. 
1:         ConsumerInfo consumerInfo3 = createConsumerInfo(sessionInfo2, destinationInfo2);
1:         connection2.send(consumerInfo3);
0:         int counter = 0;
0:             connection2.send(createAck(consumerInfo3, message1, 1, MessageAck.STANDARD_ACK_TYPE));
0:             ++counter;
1:         // Ensure that 5 messages were received
1:         assertEquals(receiveNumMessages, counter);
0:         Thread.sleep(2000);
0:         int messageCount4 = countMessagesInQueue(connection2, connectionInfo2, destinationInfo1);
0: // Sometimes it fails here 
0:         assertEquals(0, messageCount4);
0:         
0:         // Close the consumer on the remote broker 
1:         connection2.send(consumerInfo3.createRemoveCommand());
0:         
1:         connection1.stop();
1:         connection2.stop();
commit:f6cf0ba
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.network;
0: 
1: import javax.jms.DeliveryMode;
0: 
0: import junit.framework.Test;
0: 
1: import org.apache.activemq.broker.StubConnection;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.SessionInfo;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: public class BrokerNetworkWithStuckMessagesTest extends NetworkTestSupport {
0: 	
0:     private static final Log LOG = LogFactory.getLog(BrokerNetworkWithStuckMessagesTest.class);
0: 	
0: 	private DemandForwardingBridge bridge;
0: 
0: 	protected void setUp() throws Exception {
0:         super.setUp();
0:         
0:         // Create a network bridge between the local and remote brokers so that 
1:         // demand-based forwarding can take place
1:         NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();
1:         config.setBrokerName("local");
1:         config.setDispatchAsync(false);
0:         bridge = new DemandForwardingBridge(config, createTransport(), createRemoteTransport());
0:         bridge.setBrokerService(broker);
1:         bridge.start();
0:         
0:         // Enable JMX support on the local and remote brokers 
0:         broker.setUseJmx(true);
0:         remoteBroker.setUseJmx(true);
0:         
0:         // Set the names of teh local and remote brokers 
0:         broker.setBrokerName("local");
0:         remoteBroker.setBrokerName("remote");
0:     }
0: 	
0: 	protected void tearDown() throws Exception {
1:         bridge.stop();
0:         super.tearDown();
0:     }
0: 
0: 	public void testBrokerNetworkWithStuckMessages() throws Exception {
0: 		
0: 		int sendNumMessages = 10;
0: 		int receiveNumMessages = 5;
0: 		
0: 		// Create a producer and send a batch of 10 messages to the local broker
0: 		StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
0:         
0:         // Create a destination on the local broker 
1:         ActiveMQDestination destinationInfo1 = null;
0:         
1:         for (int i = 0; i < sendNumMessages; ++i) {
0:         	destinationInfo1 = createDestinationInfo(connection1, connectionInfo1, ActiveMQDestination.QUEUE_TYPE);
0: 	        connection1.send(createMessage(producerInfo, destinationInfo1, DeliveryMode.NON_PERSISTENT));
0:         }
0:         
0:         // Ensure that there are 10 messages on the local broker 
0:         assertTrue(countMessagesInQueue(connection1, connectionInfo1, destinationInfo1) == 10);
0:         
0:         
0:         // Create a consumer on the remote broker 
0:         StubConnection connection2 = createRemoteConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
0:         ActiveMQDestination destinationInfo2 = 
0:         	createDestinationInfo(connection2, connectionInfo2, ActiveMQDestination.QUEUE_TYPE);
0:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationInfo2);
1:         connection2.send(consumerInfo2);
0:         
0:         // Consume 5 of the messages from the remote broker and ack them. 
0:         // Because the prefetch size is set to 1000, this will cause the 
0:         // messages on the local broker to be forwarded to the remote broker. 
1:         for (int i = 0; i < receiveNumMessages; ++i) {
0: 	        Message message1 = receiveMessage(connection2);
0: 	        assertNotNull(message1);
0:             connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.STANDARD_ACK_TYPE));
0:         }
0:         
0:         // Close the consumer on the remote broker 
0:         connection2.send(consumerInfo2.createRemoveCommand());
0:         
0:         // Ensure that there are zero messages on the local broker. This tells 
0:         // us that those messages have been prefetched to the remote broker 
0:         // where the demand exists. 
0:         assertTrue(countMessagesInQueue(connection1, connectionInfo1, destinationInfo1) == 0);
0:         
0:         // There should now be 5 messages stuck on the remote broker 
0:         assertTrue(countMessagesInQueue(connection2, connectionInfo2, destinationInfo1) == 5);
0:         
0:         // Create a consumer on the local broker just to confirm that it doesn't 
0:         // receive any messages  
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationInfo1);
1:         connection1.send(consumerInfo1);
0:         Message message1 = receiveMessage(connection1);
0:         
0: 		//////////////////////////////////////////////////////
0:         // An assertNull() is done here because this is currently the correct 
0:         // behavior. This is actually the purpose of this test - to prove that 
0:         // messages are stuck on the remote broker. AMQ-2324 aims to fix this 
0:         // situation so that messages don't get stuck. 
0:         assertNull(message1);
0: 		//////////////////////////////////////////////////////
0:         
0:         consumerInfo2 = createConsumerInfo(sessionInfo2, destinationInfo2);
1:         connection2.send(consumerInfo2);
0:         
0:         // Consume the last 5 messages from the remote broker and ack them just 
0:         // to clean up the queue. 
1:         for (int i = 0; i < receiveNumMessages; ++i) {
0: 	        message1 = receiveMessage(connection2);
0: 	        assertNotNull(message1);
0:             connection2.send(createAck(consumerInfo2, message1, 1, MessageAck.STANDARD_ACK_TYPE));
0:         }
0:         
0:         // Close the consumer on the remote broker 
0:         connection2.send(consumerInfo2.createRemoveCommand());
0:         
0:         // Ensure that the queue on the remote broker is empty 
0:         assertTrue(countMessagesInQueue(connection2, connectionInfo2, destinationInfo2) == 0);
0: 	}
0: 	
0:     public static Test suite() {
0:         return suite(BrokerNetworkWithStuckMessagesTest.class);
0:     }
0:     
0: }
============================================================================