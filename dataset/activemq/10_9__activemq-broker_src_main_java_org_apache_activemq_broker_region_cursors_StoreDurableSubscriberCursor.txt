2:4eef609: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
2:4eef609:  */
1:4eef609: package org.apache.activemq.broker.region.cursors;
1:74a7a8b: 
1:ae7de6c: import java.util.Collections;
1:4eef609: import java.util.HashMap;
1:ae7de6c: import java.util.List;
1:4eef609: import java.util.Map;
1:5441774: import java.util.concurrent.CopyOnWriteArrayList;
1:ae61847: 
1:4597ddd: import org.apache.activemq.advisory.AdvisorySupport;
1:23cda2d: import org.apache.activemq.broker.Broker;
1:4eef609: import org.apache.activemq.broker.ConnectionContext;
1:4eef609: import org.apache.activemq.broker.region.Destination;
1:93e2bd3: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:4eef609: import org.apache.activemq.broker.region.MessageReference;
1:4eef609: import org.apache.activemq.broker.region.Topic;
1:b6ba20b: import org.apache.activemq.command.Message;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:e7c9d21: 
1:4eef609: /**
1:fc00993:  * persist pending messages pending message (messages awaiting dispatch to a
1:230a86c:  * consumer) cursor
1:4eef609:  */
1:230a86c: public class StoreDurableSubscriberCursor extends AbstractPendingMessageCursor {
1:4597ddd: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(StoreDurableSubscriberCursor.class);
1:e2c83d6:     private final String clientId;
1:e2c83d6:     private final String subscriberName;
1:e2c83d6:     private final Map<Destination, TopicStorePrefetch> topics = new HashMap<Destination, TopicStorePrefetch>();
1:e2c83d6:     private final List<PendingMessageCursor> storePrefetches = new CopyOnWriteArrayList<PendingMessageCursor>();
1:e2c83d6:     private final PendingMessageCursor nonPersistent;
1:b6ba20b:     private PendingMessageCursor currentCursor;
1:93e2bd3:     private final DurableTopicSubscription subscription;
1:7d54942:     private boolean immediatePriorityDispatch = true;
1:ae61847: 
1:4eef609:     /**
1:e2c83d6:      * @param broker Broker for this cursor
1:e2c83d6:      * @param clientId clientId for this cursor
1:e2c83d6:      * @param subscriberName subscriber name for this cursor
1:e2c83d6:      * @param maxBatchSize currently ignored
1:e2c83d6:      * @param subscription  subscription for this cursor
1:4eef609:      */
1:93e2bd3:     public StoreDurableSubscriberCursor(Broker broker,String clientId, String subscriberName,int maxBatchSize, DurableTopicSubscription subscription) {
1:00879cf:         super(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker,subscription));
1:071b4b1:         this.subscription=subscription;
1:230a86c:         this.clientId = clientId;
1:230a86c:         this.subscriberName = subscriberName;
1:512b0c7:         if (broker.getBrokerService().isPersistent()) {
1:00879cf:             this.nonPersistent = new FilePendingMessageCursor(broker,clientId + subscriberName,this.prioritizedMessages);
1:93e2bd3:         } else {
1:00879cf:             this.nonPersistent = new VMPendingMessageCursor(this.prioritizedMessages);
1:512b0c7:         }
1:ae61847: 
1:e7c9d21:         this.nonPersistent.setMaxBatchSize(maxBatchSize);
1:512b0c7:         this.nonPersistent.setSystemUsage(systemUsage);
1:071b4b1:         this.storePrefetches.add(this.nonPersistent);
1:6519c3e: 
1:6519c3e:         if (prioritizedMessages) {
1:6519c3e:             setMaxAuditDepth(10*getMaxAuditDepth());
1:6519c3e:         }
1:1ee0017:     }
1:e7c9d21: 
1:00879cf:     @Override
1:230a86c:     public synchronized void start() throws Exception {
1:e2c83d6:         if (!isStarted()) {
1:1ee0017:             super.start();
1:230a86c:             for (PendingMessageCursor tsp : storePrefetches) {
1:ae61847:                 tsp.setMessageAudit(getMessageAudit());
1:c46003f:                 tsp.start();
1:c46003f:             }
1:c46003f:         }
1:ec63977:     }
1:071b4b1: 
1:00879cf:     @Override
1:230a86c:     public synchronized void stop() throws Exception {
1:e2c83d6:         if (isStarted()) {
1:93e2bd3:             if (subscription.isKeepDurableSubsActive()) {
1:93e2bd3:                 super.gc();
1:230a86c:                 for (PendingMessageCursor tsp : storePrefetches) {
1:93e2bd3:                     tsp.gc();
1:93e2bd3:                 }
1:93e2bd3:             } else {
1:93e2bd3:                 super.stop();
1:93e2bd3:                 for (PendingMessageCursor tsp : storePrefetches) {
1:93e2bd3:                     tsp.stop();
1:93e2bd3:                 }
1:53b29a2:                 getMessageAudit().clear();
1:c46003f:             }
1:ec63977:         }
1:3bf0245:     }
1:9dd11cb: 
1:9dd11cb:     /**
1:4eef609:      * Add a destination
1:ae61847:      *
1:4eef609:      * @param context
1:4eef609:      * @param destination
1:4eef609:      * @throws Exception
1:9dd11cb:      */
1:00879cf:     @Override
1:230a86c:     public synchronized void add(ConnectionContext context, Destination destination) throws Exception {
1:230a86c:         if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination.getActiveMQDestination())) {
1:071b4b1:             TopicStorePrefetch tsp = new TopicStorePrefetch(this.subscription,(Topic)destination, clientId, subscriberName);
1:6519c3e:             tsp.setMaxBatchSize(destination.getMaxPageSize());
1:6d8e2c5:             tsp.setSystemUsage(systemUsage);
1:6519c3e:             tsp.setMessageAudit(getMessageAudit());
1:1ee0017:             tsp.setEnableAudit(isEnableAudit());
1:e7c9d21:             tsp.setMemoryUsageHighWaterMark(getMemoryUsageHighWaterMark());
1:fe31092:             tsp.setUseCache(isUseCache());
1:eaac0d2:             tsp.setCacheEnabled(isUseCache() && tsp.isEmpty());
1:230a86c:             topics.put(destination, tsp);
1:4597ddd:             storePrefetches.add(tsp);
1:e2c83d6:             if (isStarted()) {
1:4597ddd:                 tsp.start();
1:4597ddd:             }
1:3bf0245:         }
1:6895d00:     }
1:1ee0017: 
1:4eef609:     /**
1:4eef609:      * remove a destination
1:ae61847:      *
1:4eef609:      * @param context
1:4eef609:      * @param destination
1:4eef609:      * @throws Exception
1:4eef609:      */
1:00879cf:     @Override
1:ae7de6c:     public synchronized List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:e2c83d6:         PendingMessageCursor tsp = topics.remove(destination);
1:230a86c:         if (tsp != null) {
1:4eef609:             storePrefetches.remove(tsp);
1:6519c3e:         }
1:ae7de6c:         return Collections.EMPTY_LIST;
1:6895d00:     }
1:6519c3e: 
1:4eef609:     /**
1:4eef609:      * @return true if there are no pending messages
1:4eef609:      */
1:00879cf:     @Override
1:230a86c:     public synchronized boolean isEmpty() {
1:53c4e12:         for (PendingMessageCursor tsp : storePrefetches) {
1:53c4e12:             if( !tsp.isEmpty() )
1:53c4e12:                 return false;
1:53c4e12:         }
1:54e2e3b:         return true;
1:7a6b944:     }
1:1ee0017: 
1:00879cf:     @Override
1:2a153b0:     public synchronized boolean isEmpty(Destination destination) {
1:230a86c:         boolean result = true;
1:ecf89a6:         TopicStorePrefetch tsp = topics.get(destination);
1:230a86c:         if (tsp != null) {
1:53c4e12:             result = tsp.isEmpty();
1:4597ddd:         }
1:4597ddd:         return result;
1:4597ddd:     }
1:1ee0017: 
1:4eef609:     /**
1:230a86c:      * Informs the Broker if the subscription needs to intervention to recover
1:230a86c:      * it's state e.g. DurableTopicSubscriber may do
1:ae61847:      *
1:e2c83d6:      * @see org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor
1:4eef609:      * @return true if recovery required
1:4eef609:      */
1:00879cf:     @Override
1:230a86c:     public boolean isRecoveryRequired() {
1:4eef609:         return false;
1:7a6b944:     }
1:c46003f: 
1:00879cf:     @Override
1:cc6213e:     public synchronized boolean tryAddMessageLast(MessageReference node, long wait) throws Exception {
1:230a86c:         if (node != null) {
1:230a86c:             Message msg = node.getMessage();
1:e2c83d6:             if (isStarted()) {
1:230a86c:                 if (!msg.isPersistent()) {
1:5e2adc0:                     nonPersistent.tryAddMessageLast(node, wait);
1:b6ba20b:                 }
1:b6ba20b:             }
1:230a86c:             if (msg.isPersistent()) {
1:9a8f6e4:                 Destination dest = (Destination) msg.getRegionDestination();
1:ecf89a6:                 TopicStorePrefetch tsp = topics.get(dest);
1:230a86c:                 if (tsp != null) {
1:6519c3e:                     tsp.addMessageLast(node);
1:fe31092:                     if (prioritizedMessages && immediatePriorityDispatch && tsp.isPaging()) {
1:fe31092:                         if (msg.getPriority() > tsp.getLastRecoveredPriority()) {
1:fe31092:                             tsp.recoverMessage(node.getMessage(), true);
1:e1bbde7:                             LOG.trace("cached high priority ({} message: {}, current paged batch priority: {}, cache size: {}", new Object[]{ msg.getPriority(), msg.getMessageId(), tsp.getLastRecoveredPriority(), tsp.batchList.size()});
1:fe31092:                         }
1:fe31092:                     }
1:fe31092:                 }
24:4eef609:             }
1:c46003f: 
1:4eef609:         }
1:53c4e12:         return true;
1:4eef609:     }
1:c46003f: 
1:00879cf:     @Override
1:93e2bd3:     public boolean isTransient() {
1:93e2bd3:         return subscription.isKeepDurableSubsActive();
1:93e2bd3:     }
1:93e2bd3: 
1:93e2bd3:     @Override
1:93e2bd3:     public void addMessageFirst(MessageReference node) throws Exception {
1:93e2bd3:         // for keep durable subs active, need to deal with redispatch
1:93e2bd3:         if (node != null) {
1:93e2bd3:             Message msg = node.getMessage();
1:93e2bd3:             if (!msg.isPersistent()) {
1:93e2bd3:                 nonPersistent.addMessageFirst(node);
1:93e2bd3:             } else {
1:9a8f6e4:                 Destination dest = (Destination) msg.getRegionDestination();
1:93e2bd3:                 TopicStorePrefetch tsp = topics.get(dest);
1:93e2bd3:                 if (tsp != null) {
1:93e2bd3:                     tsp.addMessageFirst(node);
1:93e2bd3:                 }
1:93e2bd3:             }
1:93e2bd3:         }
1:93e2bd3:     }
1:93e2bd3: 
1:93e2bd3:     @Override
1:2a153b0:     public synchronized void addRecoveredMessage(MessageReference node) throws Exception {
1:a110604:         nonPersistent.addMessageLast(node);
1:a110604:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized void clear() {
1:230a86c:         for (PendingMessageCursor tsp : storePrefetches) {
1:6519c3e:             tsp.clear();
1:6519c3e:         }
1:7d54942:     }
1:7d54942: 
1:00879cf:     @Override
1:230a86c:     public synchronized boolean hasNext() {
1:53c4e12:         boolean result = true;
1:230a86c:         if (result) {
1:230a86c:             try {
1:230a86c:                 currentCursor = getNextCursor();
1:230a86c:             } catch (Exception e) {
1:fc00993:                 LOG.error("Failed to get current cursor ", e);
1:b6ba20b:                 throw new RuntimeException(e);
1:7d54942:             }
1:230a86c:             result = currentCursor != null ? currentCursor.hasNext() : false;
1:230a86c:         }
1:c46003f:         return result;
1:dc02413:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized MessageReference next() {
1:230a86c:         MessageReference result = currentCursor != null ? currentCursor.next() : null;
1:4eef609:         return result;
1:b6ba20b:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized void remove() {
2:230a86c:         if (currentCursor != null) {
1:b6ba20b:             currentCursor.remove();
1:b6ba20b:         }
1:b6ba20b:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized void remove(MessageReference node) {
1:93e2bd3:         for (PendingMessageCursor tsp : storePrefetches) {
1:ed3f61a:             tsp.remove(node);
1:b6ba20b:         }
1:b6ba20b:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized void reset() {
1:4fbf92d:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:e2c83d6:             storePrefetch.reset();
1:b6ba20b:         }
1:b6ba20b:     }
1:a110604: 
1:00879cf:     @Override
1:230a86c:     public synchronized void release() {
1:ae61847:         this.currentCursor = null;
2:e2c83d6:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:e2c83d6:             storePrefetch.release();
1:b6ba20b:         }
1:4eef609:     }
1:ec63977: 
1:00879cf:     @Override
1:2747573:     public synchronized int size() {
1:53c4e12:         int pendingCount=0;
1:53c4e12:         for (PendingMessageCursor tsp : storePrefetches) {
1:53c4e12:             pendingCount += tsp.size();
1:53c4e12:         }
1:4eef609:         return pendingCount;
1:629bc81:     }
1:230a86c: 
1:00879cf:     @Override
1:734fb7d:     public synchronized long messageSize() {
1:734fb7d:         long pendingSize=0;
1:734fb7d:         for (PendingMessageCursor tsp : storePrefetches) {
1:734fb7d:             pendingSize += tsp.messageSize();
1:734fb7d:         }
1:734fb7d:         return pendingSize;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:4fbf92d:     public void setMaxBatchSize(int newMaxBatchSize) {
1:6519c3e:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:6519c3e:             storePrefetch.setMaxBatchSize(newMaxBatchSize);
1:4fbf92d:         }
1:6519c3e:         super.setMaxBatchSize(newMaxBatchSize);
1:629bc81:     }
1:c46003f: 
1:00879cf:     @Override
1:230a86c:     public synchronized void gc() {
1:ed3f61a:         for (PendingMessageCursor tsp : storePrefetches) {
1:3bf0245:             tsp.gc();
1:3bf0245:         }
1:3bf0245:     }
2:3bf0245: 
1:00879cf:     @Override
1:0326ab7:     public void setSystemUsage(SystemUsage usageManager) {
1:6d8e2c5:         super.setSystemUsage(usageManager);
1:e2c83d6:         for (PendingMessageCursor tsp : storePrefetches) {
1:6d8e2c5:             tsp.setSystemUsage(usageManager);
1:1ee0017:         }
1:1ee0017:     }
1:ae61847: 
1:00879cf:     @Override
1:e7c9d21:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:e7c9d21:         super.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:e7c9d21:         for (PendingMessageCursor cursor : storePrefetches) {
1:e7c9d21:             cursor.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:e7c9d21:         }
1:e7c9d21:     }
1:ae61847: 
1:00879cf:     @Override
1:0326ab7:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:1ee0017:         super.setMaxProducersToAudit(maxProducersToAudit);
1:9dd11cb:         for (PendingMessageCursor cursor : storePrefetches) {
1:6c5dd25:             cursor.setMaxProducersToAudit(maxProducersToAudit);
1:9dd11cb:         }
1:9dd11cb:     }
1:e7c9d21: 
1:00879cf:     @Override
1:0326ab7:     public void setMaxAuditDepth(int maxAuditDepth) {
1:1ee0017:         super.setMaxAuditDepth(maxAuditDepth);
2:1ee0017:         for (PendingMessageCursor cursor : storePrefetches) {
2:1ee0017:             cursor.setMaxAuditDepth(maxAuditDepth);
1:9dd11cb:         }
1:1ee0017:     }
1:ae61847: 
1:00879cf:     @Override
1:0326ab7:     public void setEnableAudit(boolean enableAudit) {
1:1ee0017:         super.setEnableAudit(enableAudit);
1:1ee0017:         for (PendingMessageCursor cursor : storePrefetches) {
1:1ee0017:             cursor.setEnableAudit(enableAudit);
1:1ee0017:         }
1:1ee0017:     }
1:ae61847: 
1:00879cf:     @Override
1:0326ab7:     public  void setUseCache(boolean useCache) {
1:071b4b1:         super.setUseCache(useCache);
1:071b4b1:         for (PendingMessageCursor cursor : storePrefetches) {
1:071b4b1:             cursor.setUseCache(useCache);
1:071b4b1:         }
1:071b4b1:     }
1:ae61847: 
1:230a86c:     protected synchronized PendingMessageCursor getNextCursor() throws Exception {
1:230a86c:         if (currentCursor == null || currentCursor.isEmpty()) {
1:230a86c:             currentCursor = null;
1:e2c83d6:             for (PendingMessageCursor tsp : storePrefetches) {
1:230a86c:                 if (tsp.hasNext()) {
1:230a86c:                     currentCursor = tsp;
1:b6ba20b:                     break;
1:071b4b1:                 }
1:1ee0017:             }
1:b6ba20b:             // round-robin
1:5441774:             if (storePrefetches.size()>1) {
1:5441774:                 PendingMessageCursor first = storePrefetches.remove(0);
1:5441774:                 storePrefetches.add(first);
1:5441774:             }
1:1ee0017:         }
1:b6ba20b:         return currentCursor;
1:1ee0017:     }
1:ae61847: 
1:00879cf:     @Override
1:230a86c:     public String toString() {
1:230a86c:         return "StoreDurableSubscriber(" + clientId + ":" + subscriberName + ")";
1:c46003f:     }
1:7d54942: 
1:7d54942:     public boolean isImmediatePriorityDispatch() {
1:7d54942:         return immediatePriorityDispatch;
1:7d54942:     }
1:7d54942: 
1:7d54942:     public void setImmediatePriorityDispatch(boolean immediatePriorityDispatch) {
1:7d54942:         this.immediatePriorityDispatch = immediatePriorityDispatch;
1:93e2bd3:     }
1:93e2bd3: 
1:7d54942: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:5e2adc0
/////////////////////////////////////////////////////////////////////////
1:                     nonPersistent.tryAddMessageLast(node, wait);
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean tryAddMessageLast(MessageReference node, long wait) throws Exception {
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     public synchronized long messageSize() {
1:         long pendingSize=0;
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:             pendingSize += tsp.messageSize();
1:         }
1:         return pendingSize;
1:     }
1: 
1:     @Override
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:6c5dd25
/////////////////////////////////////////////////////////////////////////
1:             cursor.setMaxProducersToAudit(maxProducersToAudit);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean addMessageLast(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         return true;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                             LOG.trace("cached high priority ({} message: {}, current paged batch priority: {}, cache size: {}", new Object[]{ msg.getPriority(), msg.getMessageId(), tsp.getLastRecoveredPriority(), tsp.batchList.size()});
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ae61847
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 tsp.setMessageAudit(getMessageAudit());
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:         this.currentCursor = null;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:                 Destination dest = (Destination) msg.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                 Destination dest = (Destination) msg.getRegionDestination();
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.QueueMessageReference;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:         return Collections.EMPTY_LIST;
commit:53c4e12
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final Subscription subscription;
/////////////////////////////////////////////////////////////////////////
0:     public StoreDurableSubscriberCursor(String clientId, String subscriberName, Store store, int maxBatchSize, Subscription subscription) {
0:         this.subscription = subscription;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             TopicStorePrefetch tsp = new TopicStorePrefetch((Topic)destination, clientId, subscriberName, subscription);
/////////////////////////////////////////////////////////////////////////
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:             if( !tsp.isEmpty() )
1:                 return false;
1:         }
1:         return true;
1:             result = tsp.isEmpty();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         boolean result = true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int pendingCount=0;
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:             pendingCount += tsp.size();
1:         }
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private Map<Destination, TopicStorePrefetch> topics = new HashMap<Destination, TopicStorePrefetch>();
/////////////////////////////////////////////////////////////////////////
1:         TopicStorePrefetch tsp = topics.get(destination);
/////////////////////////////////////////////////////////////////////////
1:                 TopicStorePrefetch tsp = topics.get(dest);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
0:         for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
0:             PendingMessageCursor tsp = i.next();
0:         for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
0:             PendingMessageCursor tsp = i.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<PendingMessageCursor> i = storePrefetches.iterator(); i.hasNext();) {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
1:  * persist pending messages pending message (messages awaiting dispatch to a
0:     private static final Log LOG = LogFactory.getLog(StoreDurableSubscriberCursor.class);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to get current cursor ", e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0:  * perist pending messages pending message (messages awaiting disptach to a
1:  * consumer) cursor
1: public class StoreDurableSubscriberCursor extends AbstractPendingMessageCursor {
0:     static private final Log log = LogFactory.getLog(StoreDurableSubscriberCursor.class);
0:     private int pendingCount;
0:     private Map topics = new HashMap();
0:     private LinkedList<PendingMessageCursor> storePrefetches = new LinkedList<PendingMessageCursor>();
/////////////////////////////////////////////////////////////////////////
0:     public StoreDurableSubscriberCursor(String clientId, String subscriberName, Store store, int maxBatchSize) {
1:         this.clientId = clientId;
1:         this.subscriberName = subscriberName;
0:         this.nonPersistent = new FilePendingMessageCursor(clientId + subscriberName, store);
1:     public synchronized void start() throws Exception {
0:         if (!started) {
0:             started = true;
1:             for (PendingMessageCursor tsp : storePrefetches) {
0:                 pendingCount += tsp.size();
1:     public synchronized void stop() throws Exception {
0:         if (started) {
0:             started = false;
1:             for (PendingMessageCursor tsp : storePrefetches) {
1: 
0:             pendingCount = 0;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void add(ConnectionContext context, Destination destination) throws Exception {
1:         if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination.getActiveMQDestination())) {
0:             TopicStorePrefetch tsp = new TopicStorePrefetch((Topic)destination, clientId, subscriberName);
1:             topics.put(destination, tsp);
0:             if (started) {
0:                 pendingCount += tsp.size();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void remove(ConnectionContext context, Destination destination) throws Exception {
0:         Object tsp = topics.remove(destination);
1:         if (tsp != null) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isEmpty() {
0:         return pendingCount <= 0;
0:     public boolean isEmpty(Destination destination) {
1:         boolean result = true;
0:         TopicStorePrefetch tsp = (TopicStorePrefetch)topics.get(destination);
1:         if (tsp != null) {
0:             result = tsp.size() <= 0;
1:      * Informs the Broker if the subscription needs to intervention to recover
1:      * it's state e.g. DurableTopicSubscriber may do
1:     public boolean isRecoveryRequired() {
0:     public synchronized void addMessageLast(MessageReference node) throws Exception {
1:         if (node != null) {
1:             Message msg = node.getMessage();
0:             if (started) {
1:                 if (!msg.isPersistent()) {
1:             if (msg.isPersistent()) {
0:                 Destination dest = msg.getRegionDestination();
0:                 TopicStorePrefetch tsp = (TopicStorePrefetch)topics.get(dest);
1:                 if (tsp != null) {
0:     public void addRecoveredMessage(MessageReference node) throws Exception {
1:     public synchronized void clear() {
0:         pendingCount = 0;
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:     public synchronized boolean hasNext() {
0:         boolean result = pendingCount > 0;
1:         if (result) {
1:             try {
1:                 currentCursor = getNextCursor();
1:             } catch (Exception e) {
0:                 log.error("Failed to get current cursor ", e);
1:             result = currentCursor != null ? currentCursor.hasNext() : false;
1:         }
1:     public synchronized MessageReference next() {
1:         MessageReference result = currentCursor != null ? currentCursor.next() : null;
1:     public synchronized void remove() {
1:         if (currentCursor != null) {
1:     public synchronized void remove(MessageReference node) {
1:         if (currentCursor != null) {
1:     public synchronized void reset() {
0:         for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:             AbstractPendingMessageCursor tsp = (AbstractPendingMessageCursor)i.next();
1:     public synchronized void release() {
0:         for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:             AbstractPendingMessageCursor tsp = (AbstractPendingMessageCursor)i.next();
0:     public int size() {
0:     public synchronized void setMaxBatchSize(int maxBatchSize) {
0:         for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:             AbstractPendingMessageCursor tsp = (AbstractPendingMessageCursor)i.next();
1:     public synchronized void gc() {
0:         for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:             PendingMessageCursor tsp = (PendingMessageCursor)i.next();
0:     public synchronized void setUsageManager(UsageManager usageManager) {
0:         for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:             PendingMessageCursor tsp = (PendingMessageCursor)i.next();
1:     protected synchronized PendingMessageCursor getNextCursor() throws Exception {
1:         if (currentCursor == null || currentCursor.isEmpty()) {
1:             currentCursor = null;
0:             for (Iterator i = storePrefetches.iterator(); i.hasNext();) {
0:                 AbstractPendingMessageCursor tsp = (AbstractPendingMessageCursor)i.next();
1:                 if (tsp.hasNext()) {
1:                     currentCursor = tsp;
/////////////////////////////////////////////////////////////////////////
1:     public String toString() {
1:         return "StoreDurableSubscriber(" + clientId + ":" + subscriberName + ")";
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
author:Gary Tully
-------------------------------------------------------------------------------
commit:eaac0d2
/////////////////////////////////////////////////////////////////////////
1:             tsp.setCacheEnabled(isUseCache() && tsp.isEmpty());
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
1:                 getMessageAudit().clear();
commit:fe31092
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             tsp.setUseCache(isUseCache());
/////////////////////////////////////////////////////////////////////////
1:                     if (prioritizedMessages && immediatePriorityDispatch && tsp.isPaging()) {
1:                         if (msg.getPriority() > tsp.getLastRecoveredPriority()) {
1:                             tsp.recoverMessage(node.getMessage(), true);
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("cached high priority (" + msg.getPriority() + ") message:" +
0:                                     msg.getMessageId() + ", current paged batch priority: " +
0:                                     tsp.getLastRecoveredPriority() + ", cache size:" + tsp.batchList.size());
1:                             }
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
commit:93e2bd3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
/////////////////////////////////////////////////////////////////////////
1:     private final DurableTopicSubscription subscription;
/////////////////////////////////////////////////////////////////////////
1:     public StoreDurableSubscriberCursor(Broker broker,String clientId, String subscriberName,int maxBatchSize, DurableTopicSubscription subscription) {
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:             if (subscription.isKeepDurableSubsActive()) {
1:                 super.gc();
0:                 super.getMessageAudit().clear();
1:                 for (PendingMessageCursor tsp : storePrefetches) {
1:                     tsp.gc();
0:                     tsp.getMessageAudit().clear();
1:                 }
1:             } else {
1:                 super.stop();
1:                 for (PendingMessageCursor tsp : storePrefetches) {
1:                     tsp.stop();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTransient() {
1:         return subscription.isKeepDurableSubsActive();
1:     }
1: 
1:     @Override
1:     public void addMessageFirst(MessageReference node) throws Exception {
1:         // for keep durable subs active, need to deal with redispatch
1:         if (node != null) {
1:             Message msg = node.getMessage();
1:             if (!msg.isPersistent()) {
1:                 nonPersistent.addMessageFirst(node);
1:             } else {
0:                 Destination dest = msg.getRegionDestination();
1:                 TopicStorePrefetch tsp = topics.get(dest);
1:                 if (tsp != null) {
1:                     tsp.addMessageFirst(node);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
commit:cb96783
/////////////////////////////////////////////////////////////////////////
0:                     // cache can become high priority cache for immediate dispatch
0:                     if (isStarted() && this.prioritizedMessages && immediatePriorityDispatch && !tsp.isCacheEnabled()) {
0:                             tsp.setCacheEnabled(true);
/////////////////////////////////////////////////////////////////////////
0:                         tsp.setCacheEnabled(false);
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
0:     private int cacheCurrentLowestPriority = UNKNOWN;
/////////////////////////////////////////////////////////////////////////
0:                     // cache can be come high priority cache for immediate dispatch
0:                         if (priority > tsp.getCurrentLowestPriority()) {
0:                                 LOG.trace("enabling cache for cursor on high priority message " + priority
0:                                         + ", current lowest: " + tsp.getCurrentLowestPriority());
0:                             cacheCurrentLowestPriority = tsp.getCurrentLowestPriority();
0:                     } else if (cacheCurrentLowestPriority != UNKNOWN && priority <= cacheCurrentLowestPriority) {
0:                         // already and need to acked sequence order
0:                             LOG.trace("disabling/clearing cache for cursor on lower priority message "
0:                                     + priority + ", tsp current lowest: " + tsp.getCurrentLowestPriority()
0:                                     + " cache lowest: " + cacheCurrentLowestPriority);
0:                         tsp.cacheEnabled = false;
0:                         cacheCurrentLowestPriority = UNKNOWN;
/////////////////////////////////////////////////////////////////////////
0:         cacheCurrentLowestPriority = UNKNOWN;
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
0:     private static final int UNKNOWN = -1;
/////////////////////////////////////////////////////////////////////////
0:     private int cacheCurrentPriority = UNKNOWN;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (prioritizedMessages) {
1:             setMaxAuditDepth(10*getMaxAuditDepth());
1:         }
/////////////////////////////////////////////////////////////////////////
1:             tsp.setMaxBatchSize(destination.getMaxPageSize());
1:             tsp.setMessageAudit(getMessageAudit());
/////////////////////////////////////////////////////////////////////////
1: 
0:                     // tps becomes a highest priority only cache when we have a new higher priority
0:                     // message and we are not currently caching
0:                     final int priority = msg.getPriority();
0:                         if (priority > tsp.getLastDispatchPriority()) {
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("enabling cache for cursor on high priority message " + priority);
1:                             }
0:                             tsp.cacheEnabled = true;
0:                             cacheCurrentPriority = priority;
0:                     } else if (cacheCurrentPriority > 0 && priority < cacheCurrentPriority) {
0:                         // go to the store to get next priority message as lower priority messages may be recovered
0:                         // already
1:                         tsp.clear();
0:                         cacheCurrentPriority = UNKNOWN;
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace("disabling/clearing cache for cursor on lower priority message " + priority);
1:                         }
1:                     tsp.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
1:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:             storePrefetch.setMaxBatchSize(newMaxBatchSize);
1:         super.setMaxBatchSize(newMaxBatchSize);
commit:7d54942
/////////////////////////////////////////////////////////////////////////
0:     private int lastAddPriority = 0;
1:     private boolean immediatePriorityDispatch = true;
/////////////////////////////////////////////////////////////////////////
0:             lastAddPriority = 0;
/////////////////////////////////////////////////////////////////////////
0:                     if (isStarted() && this.prioritizedMessages && immediatePriorityDispatch && !tsp.cacheEnabled) {
0:                         final int priority = msg.getPriority();
0:                         if (priority > lastAddPriority) {
0:                             // go get the latest priority message
0:                             LOG.debug("Clearing cursor on high priority message " + priority);
0:                             tsp.clear();
1:                         }
0:                         lastAddPriority = priority;
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isImmediatePriorityDispatch() {
1:         return immediatePriorityDispatch;
1:     }
1: 
1:     public void setImmediatePriorityDispatch(boolean immediatePriorityDispatch) {
1:         this.immediatePriorityDispatch = immediatePriorityDispatch;
1:     }    
commit:4fbf92d
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxBatchSize(int newMaxBatchSize) {
0:         if (newMaxBatchSize > getMaxBatchSize()) {
1:             for (PendingMessageCursor storePrefetch : storePrefetches) {
0:                 storePrefetch.setMaxBatchSize(newMaxBatchSize);
1:             }
0:             super.setMaxBatchSize(newMaxBatchSize);
commit:132f662
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:             tsp.remove(node);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(StoreDurableSubscriberCursor.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:00879cf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         super(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker,subscription));
1:             this.nonPersistent = new FilePendingMessageCursor(broker,clientId + subscriberName,this.prioritizedMessages);
1:             this.nonPersistent = new VMPendingMessageCursor(this.prioritizedMessages);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e7c9d21
/////////////////////////////////////////////////////////////////////////
1:         
1:         this.nonPersistent.setMaxBatchSize(maxBatchSize);
/////////////////////////////////////////////////////////////////////////
1:             tsp.setMemoryUsageHighWaterMark(getMemoryUsageHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:         super.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:         for (PendingMessageCursor cursor : storePrefetches) {
1:             cursor.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
commit:d261412
/////////////////////////////////////////////////////////////////////////
commit:5441774
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0:     private List<PendingMessageCursor> storePrefetches = new CopyOnWriteArrayList<PendingMessageCursor>();
/////////////////////////////////////////////////////////////////////////
1:             if (storePrefetches.size()>1) {
1:                 PendingMessageCursor first = storePrefetches.remove(0);
1:                 storePrefetches.add(first);
1:             }
commit:d3ebc9c
/////////////////////////////////////////////////////////////////////////
commit:0326ab7
/////////////////////////////////////////////////////////////////////////
0:     public void setMaxBatchSize(int maxBatchSize) {
/////////////////////////////////////////////////////////////////////////
1:     public void setSystemUsage(SystemUsage usageManager) {
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:     public void setMaxAuditDepth(int maxAuditDepth) {
1:     public void setEnableAudit(boolean enableAudit) {
1:     public  void setUseCache(boolean useCache) {
commit:512b0c7
/////////////////////////////////////////////////////////////////////////
1:         if (broker.getBrokerService().isPersistent()) {
0:             this.nonPersistent = new FilePendingMessageCursor(broker,clientId + subscriberName);
0:         }else {
0:             this.nonPersistent = new VMPendingMessageCursor();
1:         }
0:         this.nonPersistent.setMaxBatchSize(getMaxBatchSize());
1:         this.nonPersistent.setSystemUsage(systemUsage);
0:         this.nonPersistent.setEnableAudit(isEnableAudit());
0:         this.nonPersistent.setMaxAuditDepth(getMaxAuditDepth());
0:         this.nonPersistent.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isEmpty(Destination destination) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addRecoveredMessage(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setUseCache(boolean useCache) {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void dispatched(MessageReference message) {
commit:2747573
/////////////////////////////////////////////////////////////////////////
1:     public synchronized int size() {
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:     private Subscription subscription;
/////////////////////////////////////////////////////////////////////////
1:         this.subscription=subscription;
1:         this.storePrefetches.add(this.nonPersistent);
/////////////////////////////////////////////////////////////////////////
1:             TopicStorePrefetch tsp = new TopicStorePrefetch(this.subscription,(Topic)destination, clientId, subscriberName);
/////////////////////////////////////////////////////////////////////////
0:     public void setUseCache(boolean useCache) {
1:         super.setUseCache(useCache);
1:         for (PendingMessageCursor cursor : storePrefetches) {
1:             cursor.setUseCache(useCache);
1:         }
0:         if (nonPersistent != null) {
0:             nonPersistent.setUseCache(useCache);
1:         }
1:     }
1:     
commit:55810b3
/////////////////////////////////////////////////////////////////////////
0:             	tsp.setMessageAudit(getMessageAudit());
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:      * @param broker 
0:      * @param maxBatchSize 
0:      * @param subscription 
0:     public StoreDurableSubscriberCursor(Broker broker,String clientId, String subscriberName,int maxBatchSize, Subscription subscription) {
0:         this.nonPersistent = new FilePendingMessageCursor(broker,clientId + subscriberName);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Mark a message as already dispatched
0:      * @param message
1:      */
0:     public void dispatched(MessageReference message) {
0:         super.dispatched(message);
1:         for (PendingMessageCursor cursor : storePrefetches) {
0:             cursor.dispatched(message);
1:         }
0:         if (nonPersistent != null) {
0:             nonPersistent.dispatched(message);
1:         }
1:     }
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
1:             super.start();
/////////////////////////////////////////////////////////////////////////
0:             super.stop();
/////////////////////////////////////////////////////////////////////////
1:             tsp.setEnableAudit(isEnableAudit());
0:             tsp.setMaxAuditDepth(getMaxAuditDepth());
0:             tsp.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:         super.setMaxProducersToAudit(maxProducersToAudit);
1:         for (PendingMessageCursor cursor : storePrefetches) {
1:             cursor.setMaxAuditDepth(maxAuditDepth);
1:         }
0:         if (nonPersistent != null) {
0:             nonPersistent.setMaxProducersToAudit(maxProducersToAudit);
1:         }
1:     }
1: 
0:     public void setMaxAuditDepth(int maxAuditDepth) {
1:         super.setMaxAuditDepth(maxAuditDepth);
1:         for (PendingMessageCursor cursor : storePrefetches) {
1:             cursor.setMaxAuditDepth(maxAuditDepth);
1:         }
0:         if (nonPersistent != null) {
0:             nonPersistent.setMaxAuditDepth(maxAuditDepth);
1:         }
1:     }
1:     
0:     public synchronized void setEnableAudit(boolean enableAudit) {
1:         super.setEnableAudit(enableAudit);
1:         for (PendingMessageCursor cursor : storePrefetches) {
1:             cursor.setEnableAudit(enableAudit);
1:         }
0:         if (nonPersistent != null) {
0:             nonPersistent.setEnableAudit(enableAudit);
1:         }
1:     }
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:             tsp.setSystemUsage(systemUsage);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setSystemUsage(SystemUsage usageManager) {
1:         super.setSystemUsage(usageManager);
1:             tsp.setSystemUsage(usageManager);
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void clear(){
commit:dc02413
/////////////////////////////////////////////////////////////////////////
0:         nonPersistent.clear();
0:         for(PendingMessageCursor tsp: storePrefetches){
0:             tsp.clear();
1:         }
commit:b88db24
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void remove(MessageReference node){
commit:c46003f
/////////////////////////////////////////////////////////////////////////
0:     private LinkedList <PendingMessageCursor>storePrefetches=new LinkedList<PendingMessageCursor>();
/////////////////////////////////////////////////////////////////////////
0:         if(!started){
0:             started=true;
0:             for(PendingMessageCursor tsp: storePrefetches){
1:                 tsp.start();
0:                 pendingCount+=tsp.size();
1:             }
0:         if(started){
0:             started=false;
0:             for(PendingMessageCursor tsp: storePrefetches){
0:                 tsp.stop();
1:             }
1:            
0:             pendingCount=0;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isEmpty(Destination destination){
0:         boolean result=true;
0:             result=tsp.size()<=0;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         }     
0:         MessageReference result =  currentCursor!=null?currentCursor.next():null;
1:         return result;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public synchronized void gc(){
1: 
/////////////////////////////////////////////////////////////////////////
0:                 AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next();
/////////////////////////////////////////////////////////////////////////
1: 
0:     public String toString(){
0:         return "StoreDurableSubscriber("+clientId+":"+subscriberName+")";
1:     }
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0:         if(destination!=null&&!AdvisorySupport.isAdvisoryTopic(destination.getActiveMQDestination())){
0:             TopicStorePrefetch tsp=new TopicStorePrefetch((Topic)destination,clientId,subscriberName);
0:             tsp.setMaxBatchSize(getMaxBatchSize());
0:             tsp.setUsageManager(usageManager);
0:             topics.put(destination,tsp);
1:             storePrefetches.add(tsp);
0:             if(started){
1:                 tsp.start();
0:                 pendingCount+=tsp.size();
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
0:     public boolean isEmpty(Destination destination) {
0:         boolean result = true;
0:         TopicStorePrefetch tsp=(TopicStorePrefetch)topics.get(destination);
0:         if(tsp!=null){
0:             result = tsp.size() <= 0;
1:         }
1:         return result;
1:     }
commit:a110604
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void addRecoveredMessage(MessageReference node) throws Exception{
1:         nonPersistent.addMessageLast(node);
1:     }
commit:ec63977
/////////////////////////////////////////////////////////////////////////
1:     
0:     public synchronized void release(){
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next();
0:             tsp.release();
1:         }
1:     }
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
0:         tsp.setUsageManager(usageManager);
/////////////////////////////////////////////////////////////////////////
1:     
0:     public synchronized void gc() {
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             PendingMessageCursor tsp=(PendingMessageCursor)i.next();
1:             tsp.gc();
1:         }
1:     }
1:     
0:     public synchronized void setUsageManager(UsageManager usageManager){
0:         super.setUsageManager(usageManager);
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             PendingMessageCursor tsp=(PendingMessageCursor)i.next();
0:             tsp.setUsageManager(usageManager);
1:         }
1:     }
commit:629bc81
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         nonPersistent.reset();
/////////////////////////////////////////////////////////////////////////
0:     
0:     public synchronized void setMaxBatchSize(int maxBatchSize){
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next();
0:             tsp.setMaxBatchSize(maxBatchSize);
1:         }
0:         super.setMaxBatchSize(maxBatchSize);
1:     }
0:                 AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next(); 
0:             storePrefetches.addLast(storePrefetches.removeFirst());
commit:6895d00
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void remove(MessageReference node){
0:         if(currentCursor!=null){
0:             currentCursor.remove(node);
1:         }
0:         pendingCount--;
1:     }
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0:     
commit:7a6b944
/////////////////////////////////////////////////////////////////////////
0:         if(node!=null){
0:             Message msg=node.getMessage();
0:             if(started){
0:                 pendingCount++;
1:                 }
1:             }
0:             if(msg.isPersistent()){
0:                 Destination dest=msg.getRegionDestination();
0:                 TopicStorePrefetch tsp=(TopicStorePrefetch)topics.get(dest);
0:                 if(tsp!=null){
0:                     tsp.addMessageLast(node);
0:                     if(started){
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.Message;
0: import org.apache.activemq.kaha.Store;
0: 
0: 
0:     private boolean started;
0:     private PendingMessageCursor nonPersistent;
1:     private PendingMessageCursor currentCursor;
/////////////////////////////////////////////////////////////////////////
0:     public StoreDurableSubscriberCursor(String clientId,String subscriberName,Store store,int maxBatchSize){
0:         this.nonPersistent=new FilePendingMessageCursor(clientId+subscriberName,store);
0:         storePrefetches.add(nonPersistent);
0:         started=true;
0:             PendingMessageCursor tsp=(PendingMessageCursor)i.next();
0:         started=false;
0:             PendingMessageCursor tsp=(PendingMessageCursor)i.next();
/////////////////////////////////////////////////////////////////////////
0:         TopicStorePrefetch tsp=new TopicStorePrefetch((Topic)destination,clientId,subscriberName);
0:         tsp.setMaxBatchSize(getMaxBatchSize());
0:         if(started){
/////////////////////////////////////////////////////////////////////////
0:         Object tsp=topics.remove(destination);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageFirst(MessageReference node) throws IOException{
0:         if(started){
0:             throw new RuntimeException("This shouldn't be called!");
1:         }
0:     public synchronized void addMessageLast(MessageReference node) throws Exception{
0:         if(started){
0:             if(node!=null){
0:                 Message msg=node.getMessage();
0:                 if(!msg.isPersistent()){
0:                     nonPersistent.addMessageLast(node);
0:                 }else{
0:                     Destination dest=msg.getRegionDestination();
0:                     TopicStorePrefetch tsp=(TopicStorePrefetch)topics.get(dest);
0:                     if(tsp!=null){
0:                         tsp.addMessageLast(node);
0:                         // if the store has been empty - then this message is next to dispatch
0:                         if((pendingCount-nonPersistent.size())<=0){
0:                             tsp.nextToDispatch(node.getMessageId());
1:                         }
1:                     }
1:                 }
0:                 pendingCount++;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         boolean result=pendingCount>0;
0:         if(result){
0:             try{
0:                 currentCursor=getNextCursor();
0:             }catch(Exception e){
0:                 log.error("Failed to get current cursor ",e);
1:                 throw new RuntimeException(e);
0:             result=currentCursor!=null?currentCursor.hasNext():false;
0:     public synchronized MessageReference next(){
0:         return currentCursor!=null?currentCursor.next():null;
1:     }
0: 
0:         if(currentCursor!=null){
1:             currentCursor.remove();
1:         }
0:     public synchronized void reset(){
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next();
0:             tsp.reset();
1:         }
0:     protected synchronized PendingMessageCursor getNextCursor() throws Exception{
0:         if(currentCursor==null||currentCursor.isEmpty()){
0:             currentCursor=null;
0:             for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:                 AbstractPendingMessageCursor tsp=(AbstractPendingMessageCursor)i.next();
0:                 tsp.setMaxBatchSize(getMaxBatchSize());
0:                 if(tsp.hasNext()){
0:                     currentCursor=tsp;
1:                     break;
1:                 }
1:             // round-robin
0:             Object obj=storePrefetches.removeFirst();
0:             storePrefetches.addLast(obj);
1:         return currentCursor;
commit:4eef609
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
0: 
0: import java.io.IOException;
1: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
1: import java.util.Map;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.broker.region.Topic;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: /**
0:  * perist pending messages pending message (messages awaiting disptach to a consumer) cursor
0:  * 
0:  * @version $Revision$
1:  */
0: public class StoreDurableSubscriberCursor extends AbstractPendingMessageCursor{
0:     static private final Log log=LogFactory.getLog(StoreDurableSubscriberCursor.class);
0:     private int pendingCount=0;
0:     private String clientId;
0:     private String subscriberName;
0:     private int maxBatchSize=10;
0:     private LinkedList batchList=new LinkedList();
0:     private Map topics=new HashMap();
0:     private LinkedList storePrefetches=new LinkedList();
0:     private AtomicBoolean started=new AtomicBoolean();
0: 
1:     /**
0:      * @param topic
0:      * @param clientId
0:      * @param subscriberName
0:      * @throws IOException
1:      */
0:     public StoreDurableSubscriberCursor(String clientId,String subscriberName){
0:         this.clientId=clientId;
0:         this.subscriberName=subscriberName;
1:     }
0: 
0:     public synchronized void start() throws Exception{
0:         started.set(true);
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             TopicStorePrefetch tsp=(TopicStorePrefetch) i.next();
0:             tsp.start();
0:             pendingCount+=tsp.size();
1:         }
1:     }
0: 
0:     public synchronized void stop() throws Exception{
0:         started.set(false);
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             TopicStorePrefetch tsp=(TopicStorePrefetch) i.next();
0:             tsp.stop();
1:         }
0:         pendingCount=0;
1:     }
0: 
1:     /**
1:      * Add a destination
0:      * 
1:      * @param context
1:      * @param destination
1:      * @throws Exception
1:      */
0:     public synchronized void add(ConnectionContext context,Destination destination) throws Exception{
0:         TopicStorePrefetch tsp=new TopicStorePrefetch((Topic) destination,batchList,clientId,subscriberName);
0:         topics.put(destination,tsp);
0:         storePrefetches.add(tsp);
0:         if(started.get()){
0:             tsp.start();
0:             pendingCount+=tsp.size();
1:         }
1:     }
0: 
1:     /**
1:      * remove a destination
0:      * 
1:      * @param context
1:      * @param destination
1:      * @throws Exception
1:      */
0:     public synchronized void remove(ConnectionContext context,Destination destination) throws Exception{
0:         TopicStorePrefetch tsp=(TopicStorePrefetch) topics.remove(destination);
0:         if(tsp!=null){
1:             storePrefetches.remove(tsp);
1:         }
1:     }
0: 
1:     /**
1:      * @return true if there are no pending messages
1:      */
0:     public synchronized boolean isEmpty(){
0:         return pendingCount<=0;
1:     }
0: 
1:     /**
0:      * Informs the Broker if the subscription needs to intervention to recover it's state e.g. DurableTopicSubscriber
0:      * may do
0:      * 
0:      * @see org.apache.activemq.region.cursors.PendingMessageCursor
1:      * @return true if recovery required
1:      */
0:     public boolean isRecoveryRequired(){
1:         return false;
1:     }
0: 
0:     public synchronized void addMessageFirst(MessageReference node){
0:         pendingCount++;
1:     }
0: 
0:     public synchronized void addMessageLast(MessageReference node){
0:         pendingCount++;
1:     }
0: 
0:     public void clear(){
0:         pendingCount=0;
1:     }
0: 
0:     public synchronized boolean hasNext(){
0:         return !isEmpty();
1:     }
0: 
0:     public synchronized MessageReference next(){
0:         MessageReference result=null;
0:         if(!isEmpty()){
0:             if(batchList.isEmpty()){
0:                 try{
0:                     fillBatch();
0:                 }catch(Exception e){
0:                     log.error("Couldn't fill batch from store ",e);
0:                     throw new RuntimeException(e);
1:                 }
1:             }
0:             if(!batchList.isEmpty()){
0:                 result=(MessageReference) batchList.removeFirst();
1:             }
1:         }
1:         return result;
1:     }
0: 
0:     public synchronized void remove(){
0:         pendingCount--;
1:     }
0: 
0:     public void reset(){
0:         batchList.clear();
1:     }
0: 
0:     public int size(){
1:         return pendingCount;
1:     }
0: 
0:     private synchronized void fillBatch() throws Exception{
0:         for(Iterator i=storePrefetches.iterator();i.hasNext();){
0:             TopicStorePrefetch tsp=(TopicStorePrefetch) i.next();
0:             tsp.fillBatch();
0:             if(batchList.size()>=maxBatchSize){
0:                 break;
1:             }
1:         }
0:         // round-robin
0:         Object obj=storePrefetches.removeFirst();
0:         storePrefetches.addLast(obj);
1:     }
1: }
author:David Jencks
-------------------------------------------------------------------------------
commit:e2c83d6
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     private final String clientId;
1:     private final String subscriberName;
1:     private final Map<Destination, TopicStorePrefetch> topics = new HashMap<Destination, TopicStorePrefetch>();
1:     private final List<PendingMessageCursor> storePrefetches = new CopyOnWriteArrayList<PendingMessageCursor>();
1:     private final PendingMessageCursor nonPersistent;
0:     private final Subscription subscription;
1:      * @param broker Broker for this cursor
1:      * @param clientId clientId for this cursor
1:      * @param subscriberName subscriber name for this cursor
1:      * @param maxBatchSize currently ignored
1:      * @param subscription  subscription for this cursor
/////////////////////////////////////////////////////////////////////////
0:         //TODO is this correct? we are ignoring the constructor parameter matchBatchSize
0: //        this.nonPersistent.setMaxBatchSize(getMaxBatchSize());
1:         if (!isStarted()) {
/////////////////////////////////////////////////////////////////////////
1:         if (isStarted()) {
/////////////////////////////////////////////////////////////////////////
1:             if (isStarted()) {
/////////////////////////////////////////////////////////////////////////
1:         PendingMessageCursor tsp = topics.remove(destination);
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor
/////////////////////////////////////////////////////////////////////////
1:             if (isStarted()) {
/////////////////////////////////////////////////////////////////////////
1:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:             storePrefetch.reset();
1:         for (PendingMessageCursor storePrefetch : storePrefetches) {
1:             storePrefetch.release();
/////////////////////////////////////////////////////////////////////////
0:         for (PendingMessageCursor storePrefetch : storePrefetches) {
0:             storePrefetch.setMaxBatchSize(maxBatchSize);
1:         for (PendingMessageCursor tsp : storePrefetches) {
1:         for (PendingMessageCursor tsp : storePrefetches) {
/////////////////////////////////////////////////////////////////////////
0:             for (PendingMessageCursor tsp : storePrefetches) {
============================================================================