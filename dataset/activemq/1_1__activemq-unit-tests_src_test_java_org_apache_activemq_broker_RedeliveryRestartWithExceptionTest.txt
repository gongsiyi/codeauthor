1:52e1a05: /**
1:52e1a05:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:52e1a05:  * contributor license agreements.  See the NOTICE file distributed with
1:52e1a05:  * this work for additional information regarding copyright ownership.
1:52e1a05:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:52e1a05:  * (the "License"); you may not use this file except in compliance with
1:52e1a05:  * the License.  You may obtain a copy of the License at
1:52e1a05:  *
1:52e1a05:  *      http://www.apache.org/licenses/LICENSE-2.0
1:52e1a05:  *
1:52e1a05:  * Unless required by applicable law or agreed to in writing, software
1:52e1a05:  * distributed under the License is distributed on an "AS IS" BASIS,
1:52e1a05:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:52e1a05:  * See the License for the specific language governing permissions and
1:52e1a05:  * limitations under the License.
1:52e1a05:  */
1:52e1a05: package org.apache.activemq.broker;
2:52e1a05: 
1:52e1a05: import java.io.File;
1:52e1a05: import java.io.IOException;
1:52e1a05: import java.util.Set;
1:52e1a05: import javax.jms.ConnectionFactory;
1:dc25f2a: import javax.jms.DeliveryMode;
1:52e1a05: import javax.jms.Destination;
1:52e1a05: import javax.jms.JMSException;
1:52e1a05: import javax.jms.MessageConsumer;
1:52e1a05: import javax.jms.MessageProducer;
1:52e1a05: import javax.jms.Session;
1:52e1a05: import javax.jms.TextMessage;
1:52e1a05: import org.apache.activemq.ActiveMQConnection;
1:52e1a05: import org.apache.activemq.ActiveMQConnectionFactory;
1:52e1a05: import org.apache.activemq.TestSupport;
1:52e1a05: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:52e1a05: import org.apache.activemq.broker.region.policy.PolicyMap;
1:52e1a05: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:52e1a05: import org.apache.activemq.command.ActiveMQDestination;
1:52e1a05: import org.apache.activemq.command.ActiveMQQueue;
1:52e1a05: import org.apache.activemq.command.ActiveMQTopic;
1:52e1a05: import org.apache.activemq.command.Message;
1:52e1a05: import org.apache.activemq.command.ProducerId;
1:52e1a05: import org.apache.activemq.store.MessageStore;
1:52e1a05: import org.apache.activemq.store.PersistenceAdapter;
1:52e1a05: import org.apache.activemq.store.ProxyMessageStore;
1:52e1a05: import org.apache.activemq.store.ProxyTopicMessageStore;
1:52e1a05: import org.apache.activemq.store.TopicMessageStore;
1:52e1a05: import org.apache.activemq.store.TransactionStore;
1:52e1a05: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:dc25f2a: import org.apache.activemq.transport.tcp.TcpTransport;
1:52e1a05: import org.apache.activemq.usage.SystemUsage;
1:52e1a05: import org.junit.After;
1:52e1a05: import org.junit.Before;
1:52e1a05: import org.slf4j.Logger;
1:52e1a05: import org.slf4j.LoggerFactory;
1:52e1a05: 
1:52e1a05: public class RedeliveryRestartWithExceptionTest extends TestSupport {
1:52e1a05: 
1:52e1a05:     private static final transient Logger LOG = LoggerFactory.getLogger(RedeliveryRestartWithExceptionTest.class);
1:52e1a05:     ActiveMQConnection connection;
1:52e1a05:     BrokerService broker = null;
1:52e1a05:     String queueName = "redeliveryRestartQ";
1:52e1a05: 
1:52e1a05:     @Override
1:52e1a05:     @Before
1:52e1a05:     public void setUp() throws Exception {
1:52e1a05:         super.setUp();
1:52e1a05:         broker = new BrokerService();
1:52e1a05:         configureBroker(broker, true);
1:52e1a05:         broker.setDeleteAllMessagesOnStartup(true);
1:52e1a05:         broker.start();
1:52e1a05:     }
1:52e1a05: 
1:52e1a05:     @Override
1:52e1a05:     @After
1:52e1a05:     public void tearDown() throws Exception {
1:52e1a05:         if (connection != null) {
3:52e1a05:             connection.close();
1:52e1a05:         }
1:52e1a05:         broker.stop();
1:52e1a05:         super.tearDown();
1:52e1a05:     }
1:52e1a05: 
1:52e1a05:     protected void configureBroker(BrokerService broker, boolean throwExceptionOnUpdate) throws Exception {
1:52e1a05:         PolicyMap policyMap = new PolicyMap();
1:52e1a05:         PolicyEntry policy = new PolicyEntry();
1:52e1a05:         policy.setPersistJMSRedelivered(true);
1:52e1a05:         policyMap.setDefaultEntry(policy);
1:52e1a05:         broker.setDestinationPolicy(policyMap);
1:52e1a05:         broker.setPersistenceAdapter(new KahaDBWithUpdateExceptionPersistenceAdapter(throwExceptionOnUpdate));
1:52e1a05:         broker.addConnector("tcp://0.0.0.0:0");
1:52e1a05:     }
1:52e1a05: 
1:dc25f2a:     @org.junit.Test
1:52e1a05:     public void testValidateRedeliveryFlagAfterRestart() throws Exception {
1:52e1a05: 
1:52e1a05:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:52e1a05:             + "?jms.prefetchPolicy.all=0");
1:52e1a05:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:52e1a05:         connection.start();
1:52e1a05: 
1:52e1a05:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:52e1a05:         Destination destination = session.createQueue(queueName);
1:dc25f2a:         populateDestination(10, destination, connection, true);
1:52e1a05:         TextMessage msg = null;
1:52e1a05:         MessageConsumer consumer = session.createConsumer(destination);
1:52e1a05:         Exception expectedException = null;
1:52e1a05:         try {
1:52e1a05:             for (int i = 0; i < 5; i++) {
1:52e1a05:                 msg = (TextMessage) consumer.receive(5000);
1:52e1a05:                 LOG.info("not redelivered? got: " + msg);
1:52e1a05:                 assertNotNull("got the message", msg);
1:52e1a05:                 assertTrue("Should not receive the 5th message", i < 4);
1:52e1a05:                 //The first 4 messages will be ok but the 5th one should hit an exception in updateMessage and should not be delivered
1:52e1a05:             }
1:52e1a05:         } catch (Exception e) {
1:52e1a05:             //Expecting an exception and disconnect on the 5th message
1:52e1a05:             LOG.info("Got expected:", e);
1:52e1a05:             expectedException = e;
1:52e1a05:         }
1:52e1a05:         assertNotNull("Expecting an exception when updateMessage fails", expectedException);                
1:dc25f2a:         
1:52e1a05:         consumer.close();
1:ac635dd:         safeCloseConnection(connection);
1:52e1a05:         
1:52e1a05:         restartBroker();
1:52e1a05:         
1:52e1a05:         connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:52e1a05:             + "?jms.prefetchPolicy.all=0");
1:52e1a05:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:52e1a05:         connection.start();
1:52e1a05: 
1:52e1a05:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:52e1a05:         destination = session.createQueue(queueName);
1:52e1a05:         consumer = session.createConsumer(destination);
1:52e1a05:         
1:52e1a05:         
1:52e1a05:         // consume the messages that were previously delivered
1:52e1a05:         for (int i = 0; i < 4; i++) {
1:52e1a05:             msg = (TextMessage) consumer.receive(4000);
1:52e1a05:             LOG.info("redelivered? got: " + msg);
1:52e1a05:             assertNotNull("got the message again", msg);
2:52e1a05:             assertEquals("re delivery flag", true, msg.getJMSRedelivered());
1:52e1a05:             assertTrue("redelivery count survives restart", msg.getLongProperty("JMSXDeliveryCount") > 1);
1:52e1a05:             msg.acknowledge();
1:52e1a05:         }
1:52e1a05:         
1:52e1a05: 
1:52e1a05:         // consume the rest that were not redeliveries
1:52e1a05:         for (int i = 0; i < 6; i++) {
1:52e1a05:             msg = (TextMessage) consumer.receive(4000);
1:52e1a05:             LOG.info("not redelivered? got: " + msg);
1:52e1a05:             assertNotNull("got the message", msg);
1:52e1a05:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:52e1a05:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:52e1a05:             msg.acknowledge();
1:52e1a05:         }
1:52e1a05:         connection.close();
1:52e1a05:     }
1:52e1a05: 
1:52e1a05: 
1:52e1a05:     @org.junit.Test
1:52e1a05:     public void testValidateRedeliveryFlagAfterTransientFailureConnectionDrop() throws Exception {
1:52e1a05: 
1:52e1a05:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:52e1a05:             + "?jms.prefetchPolicy.all=0");
1:52e1a05:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:52e1a05:         connection.start();
1:52e1a05: 
1:52e1a05:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:52e1a05:         Destination destination = session.createQueue(queueName);
1:dc25f2a:         populateDestination(10, destination, connection, true);
1:52e1a05:         TextMessage msg = null;
1:52e1a05:         MessageConsumer consumer = session.createConsumer(destination);
1:52e1a05:         Exception expectedException = null;
1:52e1a05:         try {
1:52e1a05:             for (int i = 0; i < 5; i++) {
1:52e1a05:                 msg = (TextMessage) consumer.receive(5000);
1:52e1a05:                 LOG.info("not redelivered? got: " + msg);
1:52e1a05:                 assertNotNull("got the message", msg);
1:52e1a05:                 assertTrue("Should not receive the 5th message", i < 4);
1:52e1a05:                 //The first 4 messages will be ok but the 5th one should hit an exception in updateMessage and should not be delivered
1:52e1a05:             }
1:52e1a05:         } catch (Exception e) {
1:52e1a05:             //Expecting an exception and disconnect on the 5th message
1:52e1a05:             LOG.info("Got expected:", e);
1:52e1a05:             expectedException = e;
1:52e1a05:         }
1:52e1a05:         assertNotNull("Expecting an exception when updateMessage fails", expectedException);
1:52e1a05: 
1:52e1a05:         consumer.close();
1:ac635dd:         safeCloseConnection(connection);
1:52e1a05: 
1:52e1a05:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:52e1a05:         connection.start();
1:52e1a05: 
1:52e1a05:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:52e1a05:         destination = session.createQueue(queueName);
1:52e1a05:         consumer = session.createConsumer(destination);
1:52e1a05: 
1:52e1a05: 
1:52e1a05:         // consume the messages that were previously delivered
1:52e1a05:         for (int i = 0; i < 4; i++) {
1:52e1a05:             msg = (TextMessage) consumer.receive(4000);
1:52e1a05:             LOG.info("redelivered? got: " + msg);
1:52e1a05:             assertNotNull("got the message again", msg);
1:6cebd2c:             assertEquals("re delivery flag on:" + i, true, msg.getJMSRedelivered());
1:6cebd2c:             assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);
1:dc25f2a:             msg.acknowledge();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05: 
1:52e1a05:         // consume the rest that were not redeliveries
1:52e1a05:         for (int i = 0; i < 6; i++) {
1:52e1a05:             msg = (TextMessage) consumer.receive(4000);
1:52e1a05:             LOG.info("not redelivered? got: " + msg);
1:52e1a05:             assertNotNull("got the message", msg);
1:52e1a05:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:52e1a05:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:52e1a05:             msg.acknowledge();
1:52e1a05:         }
1:52e1a05:         connection.close();
1:52e1a05:     }
1:52e1a05: 
1:52e1a05:     @org.junit.Test
1:dc25f2a:     public void testValidateRedeliveryFlagOnNonPersistentAfterTransientFailureConnectionDrop() throws Exception {
1:dc25f2a: 
1:dc25f2a:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:dc25f2a:             + "?jms.prefetchPolicy.all=0");
1:dc25f2a:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:dc25f2a:         connection.start();
1:dc25f2a: 
1:dc25f2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:dc25f2a:         Destination destination = session.createQueue(queueName);
1:dc25f2a:         populateDestination(10, destination, connection, false);
1:dc25f2a:         TextMessage msg = null;
1:dc25f2a:         MessageConsumer consumer = session.createConsumer(destination);
1:dc25f2a:         for (int i = 0; i < 5; i++) {
1:dc25f2a:             msg = (TextMessage) consumer.receive(5000);
1:dc25f2a:             assertNotNull("got the message", msg);
1:dc25f2a:             assertFalse("not redelivered", msg.getJMSRedelivered());
1:dc25f2a:         }
1:dc25f2a: 
1:dc25f2a:         connection.getTransport().narrow(TcpTransport.class).getTransportListener().onException(new IOException("Die"));
1:dc25f2a: 
1:dc25f2a:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:dc25f2a:         connection.start();
1:dc25f2a: 
1:dc25f2a:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:dc25f2a:         destination = session.createQueue(queueName);
1:dc25f2a:         consumer = session.createConsumer(destination);
1:52e1a05: 
1:dc25f2a:         // consume the messages that were previously delivered
1:dc25f2a:         for (int i = 0; i < 5; i++) {
1:dc25f2a:             msg = (TextMessage) consumer.receive(4000);
1:dc25f2a:             LOG.info("redelivered? got: " + msg);
1:dc25f2a:             assertNotNull("got the message again", msg);
1:dc25f2a:             assertEquals("redelivery flag set on:" + i, true, msg.getJMSRedelivered());
1:dc25f2a:             assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);
1:dc25f2a:             msg.acknowledge();
1:dc25f2a:         }
1:dc25f2a: 
1:dc25f2a:         // consume the rest that were not redeliveries
1:dc25f2a:         for (int i = 0; i < 5; i++) {
1:dc25f2a:             msg = (TextMessage) consumer.receive(4000);
1:dc25f2a:             LOG.info("not redelivered? got: " + msg);
1:dc25f2a:             assertNotNull("got the message", msg);
1:dc25f2a:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:dc25f2a:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:52e1a05:             msg.acknowledge();
1:dc25f2a:         }
1:dc25f2a:         connection.close();
1:dc25f2a:     }
1:dc25f2a: 
1:52e1a05:     private void restartBroker() throws Exception {
1:52e1a05:         broker.stop();
1:52e1a05:         broker.waitUntilStopped();
1:52e1a05:         broker = createRestartedBroker();
1:52e1a05:         broker.start();
1:52e1a05:     }
1:52e1a05: 
1:52e1a05:     private BrokerService createRestartedBroker() throws Exception {
1:52e1a05:         broker = new BrokerService();
1:52e1a05:         configureBroker(broker, false);
1:52e1a05:         return broker;
1:52e1a05:     }
1:52e1a05: 
1:dc25f2a:     private void populateDestination(final int nbMessages, final Destination destination, javax.jms.Connection connection, boolean persistent) throws JMSException {
1:52e1a05:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:52e1a05:         MessageProducer producer = session.createProducer(destination);
1:dc25f2a:         producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:52e1a05:         for (int i = 1; i <= nbMessages; i++) {
1:52e1a05:             producer.send(session.createTextMessage("<hello id='" + i + "'/>"));
1:52e1a05:         }
1:52e1a05:         producer.close();
1:52e1a05:         session.close();
1:52e1a05:     }
1:52e1a05:     
1:52e1a05:     private class KahaDBWithUpdateExceptionPersistenceAdapter implements PersistenceAdapter {
1:52e1a05:         
1:52e1a05:         private KahaDBPersistenceAdapter kahaDB = new KahaDBPersistenceAdapter();
1:52e1a05:         private boolean throwExceptionOnUpdate;
1:52e1a05:         
1:52e1a05:         public KahaDBWithUpdateExceptionPersistenceAdapter(boolean throwExceptionOnUpdate) {
1:52e1a05:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:52e1a05:         }
1:52e1a05:         
1:52e1a05:         @Override
1:52e1a05:         public void start() throws Exception {
1:52e1a05:             kahaDB.start();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void stop() throws Exception {
1:52e1a05:             kahaDB.stop();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public Set<ActiveMQDestination> getDestinations() {
1:52e1a05:             return kahaDB.getDestinations();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public MessageStore createQueueMessageStore(ActiveMQQueue destination) 
1:52e1a05:                 throws IOException {
1:52e1a05:             MessageStore proxyMessageStoreWithException = new ProxyMessageStoreWithUpdateException(
1:52e1a05:                     kahaDB.createQueueMessageStore(destination), throwExceptionOnUpdate);
1:52e1a05:             return proxyMessageStoreWithException;
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public TopicMessageStore createTopicMessageStore(
1:52e1a05:                 ActiveMQTopic destination) throws IOException {
1:52e1a05:             TopicMessageStore proxyMessageStoreWithException = new ProxyTopicMessageStoreWithUpdateException(
1:52e1a05:                     kahaDB.createTopicMessageStore(destination), throwExceptionOnUpdate);
1:52e1a05:             return proxyMessageStoreWithException;
1:52e1a05:         }
1:52e1a05:         
1:52e1a05:         @Override
1:52e1a05:         public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:52e1a05:             return kahaDB.createJobSchedulerStore();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void removeQueueMessageStore(ActiveMQQueue destination) {
1:52e1a05:             kahaDB.removeQueueMessageStore(destination);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void removeTopicMessageStore(ActiveMQTopic destination) {
1:52e1a05:             kahaDB.removeTopicMessageStore(destination);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public TransactionStore createTransactionStore() throws IOException {
1:52e1a05:             return kahaDB.createTransactionStore();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void beginTransaction(ConnectionContext context)
1:52e1a05:                 throws IOException {
1:52e1a05:             kahaDB.beginTransaction(context);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void commitTransaction(ConnectionContext context)
1:52e1a05:                 throws IOException {
1:52e1a05:             kahaDB.commitTransaction(context);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void rollbackTransaction(ConnectionContext context)
1:52e1a05:                 throws IOException {
1:52e1a05:             kahaDB.rollbackTransaction(context);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public long getLastMessageBrokerSequenceId() throws IOException {
1:52e1a05:             return kahaDB.getLastMessageBrokerSequenceId();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void deleteAllMessages() throws IOException {
1:52e1a05:             kahaDB.deleteAllMessages();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void setUsageManager(SystemUsage usageManager) {
1:52e1a05:             kahaDB.setUsageManager(usageManager);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void setBrokerName(String brokerName) {
1:52e1a05:             kahaDB.setBrokerName(brokerName);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void setDirectory(File dir) {
1:52e1a05:             kahaDB.setDirectory(dir);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public File getDirectory() {
1:52e1a05:             return kahaDB.getDirectory();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public void checkpoint(boolean sync) throws IOException {
1:52e1a05:             kahaDB.checkpoint(sync);
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public long size() {
1:52e1a05:             return kahaDB.size();
1:52e1a05:         }
1:52e1a05: 
1:52e1a05:         @Override
1:52e1a05:         public long getLastProducerSequenceId(ProducerId id) throws IOException {
1:52e1a05:             return kahaDB.getLastProducerSequenceId(id);
1:52e1a05:         }
1:b07821a: 
1:b07821a:         @Override
1:b07821a:         public void allowIOResumption() {
1:b07821a:             kahaDB.allowIOResumption();
1:b07821a:         }
1:b07821a: 
1:52e1a05:     }
1:52e1a05:     
1:52e1a05:     private class ProxyMessageStoreWithUpdateException extends ProxyMessageStore {
1:52e1a05:         private boolean throwExceptionOnUpdate;
1:52e1a05:         private int numBeforeException = 4;
1:52e1a05:         public ProxyMessageStoreWithUpdateException(MessageStore delegate, boolean throwExceptionOnUpdate) {
1:52e1a05:             super(delegate);
1:52e1a05:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:52e1a05:         }
1:52e1a05:         
1:52e1a05:         @Override
1:52e1a05:         public void updateMessage(Message message) throws IOException {
1:52e1a05:             if(throwExceptionOnUpdate) {
1:52e1a05:                 if(numBeforeException > 0) {
1:52e1a05:                     numBeforeException--;
1:52e1a05:                     super.updateMessage(message);
1:52e1a05:                 } else {
1:52e1a05:                     // lets only do it once so we can validate transient store failure
1:52e1a05:                     throwExceptionOnUpdate = false;
1:52e1a05: 
1:52e1a05:                     //A message that has never been delivered will hit this exception
1:52e1a05:                     throw new IOException("Hit our simulated exception writing the update to disk");
1:52e1a05:                 }
1:52e1a05:             } else {
1:52e1a05:                 super.updateMessage(message);
1:52e1a05:             }
1:52e1a05:         }
1:52e1a05:     }
1:52e1a05:     
1:52e1a05:     private class ProxyTopicMessageStoreWithUpdateException extends ProxyTopicMessageStore {
1:52e1a05:         private boolean throwExceptionOnUpdate;
1:52e1a05:         private int numBeforeException = 4;
1:52e1a05:         public ProxyTopicMessageStoreWithUpdateException(TopicMessageStore delegate, boolean throwExceptionOnUpdate) {
1:52e1a05:             super(delegate);
1:52e1a05:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:52e1a05:         }
1:52e1a05:         
1:52e1a05:         @Override
1:52e1a05:         public void updateMessage(Message message) throws IOException {
1:52e1a05:             if(throwExceptionOnUpdate) {
1:52e1a05:                 if(numBeforeException > 0) {
1:52e1a05:                     numBeforeException--;
1:52e1a05:                     super.updateMessage(message);
1:52e1a05:                 } else {
1:52e1a05:                     //A message that has never been delivered will hit this exception
1:52e1a05:                     throw new IOException("Hit our simulated exception writing the update to disk");
1:52e1a05:                 }
1:52e1a05:             } else {
1:52e1a05:                 super.updateMessage(message);
1:52e1a05:             }
1:52e1a05:         }
1:52e1a05:     }
1:52e1a05: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:b07821a
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public void allowIOResumption() {
1:             kahaDB.allowIOResumption();
1:         }
1: 
commit:ac635dd
/////////////////////////////////////////////////////////////////////////
1:         safeCloseConnection(connection);
/////////////////////////////////////////////////////////////////////////
1:         safeCloseConnection(connection);
commit:dc25f2a
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.DeliveryMode;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.tcp.TcpTransport;
/////////////////////////////////////////////////////////////////////////
1:         populateDestination(10, destination, connection, true);
/////////////////////////////////////////////////////////////////////////
1:         populateDestination(10, destination, connection, true);
/////////////////////////////////////////////////////////////////////////
1:     @org.junit.Test
1:     public void testValidateRedeliveryFlagOnNonPersistentAfterTransientFailureConnectionDrop() throws Exception {
1: 
1:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:             + "?jms.prefetchPolicy.all=0");
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(queueName);
1:         populateDestination(10, destination, connection, false);
1:         TextMessage msg = null;
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         for (int i = 0; i < 5; i++) {
1:             msg = (TextMessage) consumer.receive(5000);
1:             assertNotNull("got the message", msg);
1:             assertFalse("not redelivered", msg.getJMSRedelivered());
1:         }
1: 
1:         connection.getTransport().narrow(TcpTransport.class).getTransportListener().onException(new IOException("Die"));
1: 
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = session.createQueue(queueName);
1:         consumer = session.createConsumer(destination);
1: 
1:         // consume the messages that were previously delivered
1:         for (int i = 0; i < 5; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("redelivered? got: " + msg);
1:             assertNotNull("got the message again", msg);
1:             assertEquals("redelivery flag set on:" + i, true, msg.getJMSRedelivered());
1:             assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);
1:             msg.acknowledge();
1:         }
1: 
1:         // consume the rest that were not redeliveries
1:         for (int i = 0; i < 5; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("not redelivered? got: " + msg);
1:             assertNotNull("got the message", msg);
1:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:             msg.acknowledge();
1:         }
1:         connection.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void populateDestination(final int nbMessages, final Destination destination, javax.jms.Connection connection, boolean persistent) throws JMSException {
1:         producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
commit:6cebd2c
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("re delivery flag on:" + i, true, msg.getJMSRedelivered());
1:             assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);
commit:52e1a05
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.Set;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.TestSupport;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.ProxyMessageStore;
1: import org.apache.activemq.store.ProxyTopicMessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class RedeliveryRestartWithExceptionTest extends TestSupport {
1: 
1:     private static final transient Logger LOG = LoggerFactory.getLogger(RedeliveryRestartWithExceptionTest.class);
1:     ActiveMQConnection connection;
1:     BrokerService broker = null;
1:     String queueName = "redeliveryRestartQ";
1: 
1:     @Override
1:     @Before
1:     public void setUp() throws Exception {
1:         super.setUp();
1:         broker = new BrokerService();
1:         configureBroker(broker, true);
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.start();
1:     }
1: 
1:     @Override
1:     @After
1:     public void tearDown() throws Exception {
1:         if (connection != null) {
1:             connection.close();
1:         }
1:         broker.stop();
1:         super.tearDown();
1:     }
1: 
1:     protected void configureBroker(BrokerService broker, boolean throwExceptionOnUpdate) throws Exception {
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry policy = new PolicyEntry();
1:         policy.setPersistJMSRedelivered(true);
1:         policyMap.setDefaultEntry(policy);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.setPersistenceAdapter(new KahaDBWithUpdateExceptionPersistenceAdapter(throwExceptionOnUpdate));
1:         broker.addConnector("tcp://0.0.0.0:0");
1:     }
1: 
1:     @org.junit.Test
1:     public void testValidateRedeliveryFlagAfterRestart() throws Exception {
1: 
1:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:             + "?jms.prefetchPolicy.all=0");
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(queueName);
0:         populateDestination(10, destination, connection);
1:         TextMessage msg = null;
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         Exception expectedException = null;
1:         try {
1:             for (int i = 0; i < 5; i++) {
1:                 msg = (TextMessage) consumer.receive(5000);
1:                 LOG.info("not redelivered? got: " + msg);
1:                 assertNotNull("got the message", msg);
1:                 assertTrue("Should not receive the 5th message", i < 4);
1:                 //The first 4 messages will be ok but the 5th one should hit an exception in updateMessage and should not be delivered
1:             }
1:         } catch (Exception e) {
1:             //Expecting an exception and disconnect on the 5th message
1:             LOG.info("Got expected:", e);
1:             expectedException = e;
1:         }
1:         assertNotNull("Expecting an exception when updateMessage fails", expectedException);                
1:         
1:         consumer.close();
1:         connection.close();
1:         
1:         restartBroker();
1:         
1:         connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:             + "?jms.prefetchPolicy.all=0");
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = session.createQueue(queueName);
1:         consumer = session.createConsumer(destination);
1:         
1:         
1:         // consume the messages that were previously delivered
1:         for (int i = 0; i < 4; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("redelivered? got: " + msg);
1:             assertNotNull("got the message again", msg);
1:             assertEquals("re delivery flag", true, msg.getJMSRedelivered());
1:             assertTrue("redelivery count survives restart", msg.getLongProperty("JMSXDeliveryCount") > 1);
1:             msg.acknowledge();
1:         }
1:         
1: 
1:         // consume the rest that were not redeliveries
1:         for (int i = 0; i < 6; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("not redelivered? got: " + msg);
1:             assertNotNull("got the message", msg);
1:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:             msg.acknowledge();
1:         }
1:         connection.close();
1:     }
1: 
1: 
1:     @org.junit.Test
1:     public void testValidateRedeliveryFlagAfterTransientFailureConnectionDrop() throws Exception {
1: 
1:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString()
1:             + "?jms.prefetchPolicy.all=0");
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(queueName);
0:         populateDestination(10, destination, connection);
1:         TextMessage msg = null;
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         Exception expectedException = null;
1:         try {
1:             for (int i = 0; i < 5; i++) {
1:                 msg = (TextMessage) consumer.receive(5000);
1:                 LOG.info("not redelivered? got: " + msg);
1:                 assertNotNull("got the message", msg);
1:                 assertTrue("Should not receive the 5th message", i < 4);
1:                 //The first 4 messages will be ok but the 5th one should hit an exception in updateMessage and should not be delivered
1:             }
1:         } catch (Exception e) {
1:             //Expecting an exception and disconnect on the 5th message
1:             LOG.info("Got expected:", e);
1:             expectedException = e;
1:         }
1:         assertNotNull("Expecting an exception when updateMessage fails", expectedException);
1: 
1:         consumer.close();
1:         connection.close();
1: 
1:         connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.start();
1: 
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = session.createQueue(queueName);
1:         consumer = session.createConsumer(destination);
1: 
1: 
1:         // consume the messages that were previously delivered
1:         for (int i = 0; i < 4; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("redelivered? got: " + msg);
1:             assertNotNull("got the message again", msg);
1:             assertEquals("re delivery flag", true, msg.getJMSRedelivered());
0:             assertTrue("redelivery count survives reconnect", msg.getLongProperty("JMSXDeliveryCount") > 1);
1:             msg.acknowledge();
1:         }
1: 
1: 
1:         // consume the rest that were not redeliveries
1:         for (int i = 0; i < 6; i++) {
1:             msg = (TextMessage) consumer.receive(4000);
1:             LOG.info("not redelivered? got: " + msg);
1:             assertNotNull("got the message", msg);
1:             assertEquals("not a redelivery", false, msg.getJMSRedelivered());
1:             assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));
1:             msg.acknowledge();
1:         }
1:         connection.close();
1:     }
1: 
1:     private void restartBroker() throws Exception {
1:         broker.stop();
1:         broker.waitUntilStopped();
1:         broker = createRestartedBroker();
1:         broker.start();
1:     }
1: 
1:     private BrokerService createRestartedBroker() throws Exception {
1:         broker = new BrokerService();
1:         configureBroker(broker, false);
1:         return broker;
1:     }
1: 
0:     private void populateDestination(final int nbMessages, final Destination destination, javax.jms.Connection connection) throws JMSException {
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(destination);
1:         for (int i = 1; i <= nbMessages; i++) {
1:             producer.send(session.createTextMessage("<hello id='" + i + "'/>"));
1:         }
1:         producer.close();
1:         session.close();
1:     }
1:     
1:     private class KahaDBWithUpdateExceptionPersistenceAdapter implements PersistenceAdapter {
1:         
1:         private KahaDBPersistenceAdapter kahaDB = new KahaDBPersistenceAdapter();
1:         private boolean throwExceptionOnUpdate;
1:         
1:         public KahaDBWithUpdateExceptionPersistenceAdapter(boolean throwExceptionOnUpdate) {
1:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:         }
1:         
1:         @Override
1:         public void start() throws Exception {
1:             kahaDB.start();
1:         }
1: 
1:         @Override
1:         public void stop() throws Exception {
1:             kahaDB.stop();
1:         }
1: 
1:         @Override
1:         public Set<ActiveMQDestination> getDestinations() {
1:             return kahaDB.getDestinations();
1:         }
1: 
1:         @Override
1:         public MessageStore createQueueMessageStore(ActiveMQQueue destination) 
1:                 throws IOException {
1:             MessageStore proxyMessageStoreWithException = new ProxyMessageStoreWithUpdateException(
1:                     kahaDB.createQueueMessageStore(destination), throwExceptionOnUpdate);
1:             return proxyMessageStoreWithException;
1:         }
1: 
1:         @Override
1:         public TopicMessageStore createTopicMessageStore(
1:                 ActiveMQTopic destination) throws IOException {
1:             TopicMessageStore proxyMessageStoreWithException = new ProxyTopicMessageStoreWithUpdateException(
1:                     kahaDB.createTopicMessageStore(destination), throwExceptionOnUpdate);
1:             return proxyMessageStoreWithException;
1:         }
1:         
1:         @Override
1:         public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:             return kahaDB.createJobSchedulerStore();
1:         }
1: 
1:         @Override
1:         public void removeQueueMessageStore(ActiveMQQueue destination) {
1:             kahaDB.removeQueueMessageStore(destination);
1:         }
1: 
1:         @Override
1:         public void removeTopicMessageStore(ActiveMQTopic destination) {
1:             kahaDB.removeTopicMessageStore(destination);
1:         }
1: 
1:         @Override
1:         public TransactionStore createTransactionStore() throws IOException {
1:             return kahaDB.createTransactionStore();
1:         }
1: 
1:         @Override
1:         public void beginTransaction(ConnectionContext context)
1:                 throws IOException {
1:             kahaDB.beginTransaction(context);
1:         }
1: 
1:         @Override
1:         public void commitTransaction(ConnectionContext context)
1:                 throws IOException {
1:             kahaDB.commitTransaction(context);
1:         }
1: 
1:         @Override
1:         public void rollbackTransaction(ConnectionContext context)
1:                 throws IOException {
1:             kahaDB.rollbackTransaction(context);
1:         }
1: 
1:         @Override
1:         public long getLastMessageBrokerSequenceId() throws IOException {
1:             return kahaDB.getLastMessageBrokerSequenceId();
1:         }
1: 
1:         @Override
1:         public void deleteAllMessages() throws IOException {
1:             kahaDB.deleteAllMessages();
1:         }
1: 
1:         @Override
1:         public void setUsageManager(SystemUsage usageManager) {
1:             kahaDB.setUsageManager(usageManager);
1:         }
1: 
1:         @Override
1:         public void setBrokerName(String brokerName) {
1:             kahaDB.setBrokerName(brokerName);
1:         }
1: 
1:         @Override
1:         public void setDirectory(File dir) {
1:             kahaDB.setDirectory(dir);
1:         }
1: 
1:         @Override
1:         public File getDirectory() {
1:             return kahaDB.getDirectory();
1:         }
1: 
1:         @Override
1:         public void checkpoint(boolean sync) throws IOException {
1:             kahaDB.checkpoint(sync);
1:         }
1: 
1:         @Override
1:         public long size() {
1:             return kahaDB.size();
1:         }
1: 
1:         @Override
1:         public long getLastProducerSequenceId(ProducerId id) throws IOException {
1:             return kahaDB.getLastProducerSequenceId(id);
1:         }
1:         
1:     }
1:     
1:     private class ProxyMessageStoreWithUpdateException extends ProxyMessageStore {
1:         private boolean throwExceptionOnUpdate;
1:         private int numBeforeException = 4;
1:         public ProxyMessageStoreWithUpdateException(MessageStore delegate, boolean throwExceptionOnUpdate) {
1:             super(delegate);
1:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:         }
1:         
1:         @Override
1:         public void updateMessage(Message message) throws IOException {
1:             if(throwExceptionOnUpdate) {
1:                 if(numBeforeException > 0) {
1:                     numBeforeException--;
1:                     super.updateMessage(message);
1:                 } else {
1:                     // lets only do it once so we can validate transient store failure
1:                     throwExceptionOnUpdate = false;
1: 
1:                     //A message that has never been delivered will hit this exception
1:                     throw new IOException("Hit our simulated exception writing the update to disk");
1:                 }
1:             } else {
1:                 super.updateMessage(message);
1:             }
1:         }
1:     }
1:     
1:     private class ProxyTopicMessageStoreWithUpdateException extends ProxyTopicMessageStore {
1:         private boolean throwExceptionOnUpdate;
1:         private int numBeforeException = 4;
1:         public ProxyTopicMessageStoreWithUpdateException(TopicMessageStore delegate, boolean throwExceptionOnUpdate) {
1:             super(delegate);
1:             this.throwExceptionOnUpdate = throwExceptionOnUpdate;
1:         }
1:         
1:         @Override
1:         public void updateMessage(Message message) throws IOException {
1:             if(throwExceptionOnUpdate) {
1:                 if(numBeforeException > 0) {
1:                     numBeforeException--;
1:                     super.updateMessage(message);
1:                 } else {
1:                     //A message that has never been delivered will hit this exception
1:                     throw new IOException("Hit our simulated exception writing the update to disk");
1:                 }
1:             } else {
1:                 super.updateMessage(message);
1:             }
1:         }
1:     }
1: }
============================================================================