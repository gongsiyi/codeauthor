1:e3154c3: /**
1:e3154c3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e3154c3:  * contributor license agreements.  See the NOTICE file distributed with
1:e3154c3:  * this work for additional information regarding copyright ownership.
1:e3154c3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e3154c3:  * (the "License"); you may not use this file except in compliance with
1:e3154c3:  * the License.  You may obtain a copy of the License at
1:e3154c3:  *
1:e3154c3:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e3154c3:  *
1:e3154c3:  * Unless required by applicable law or agreed to in writing, software
1:e3154c3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e3154c3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e3154c3:  * See the License for the specific language governing permissions and
1:e3154c3:  * limitations under the License.
1:e3154c3:  */
1:e3154c3: package org.apache.activemq.broker.scheduler;
11:e3154c3: 
1:e3154c3: import java.util.ArrayList;
1:e3154c3: import java.util.Calendar;
1:e3154c3: import java.util.Collections;
1:e3154c3: import java.util.List;
1:e3154c3: import java.util.StringTokenizer;
1:d57ebf8: 
1:e3154c3: import javax.jms.MessageFormatException;
1:363a1cf: 
1:e3154c3: public class CronParser {
1:3d61acf: 
1:e3154c3:     private static final int NUMBER_TOKENS = 5;
1:e3154c3:     private static final int MINUTES = 0;
1:e3154c3:     private static final int HOURS = 1;
1:e3154c3:     private static final int DAY_OF_MONTH = 2;
1:e3154c3:     private static final int MONTH = 3;
1:e3154c3:     private static final int DAY_OF_WEEK = 4;
1:e3154c3: 
1:e3154c3:     public static long getNextScheduledTime(final String cronEntry, long currentTime) throws MessageFormatException {
1:e3154c3: 
1:3d61acf:         long result = 0;
1:3d61acf: 
1:3d61acf:         if (cronEntry == null || cronEntry.length() == 0) {
1:3d61acf:             return result;
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         // Handle the once per minute case "* * * * *"
1:3d61acf:         // starting the next event at the top of the minute.
1:148ca81:         if (cronEntry.equals("* * * * *")) {
1:3d61acf:             result = currentTime + 60 * 1000;
1:d57ebf8:             result = result / 60000 * 60000;
1:3d61acf:             return result;
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         List<String> list = tokenize(cronEntry);
1:3d61acf:         List<CronEntry> entries = buildCronEntries(list);
1:3d61acf:         Calendar working = Calendar.getInstance();
1:3d61acf:         working.setTimeInMillis(currentTime);
1:3d61acf:         working.set(Calendar.SECOND, 0);
1:3d61acf: 
1:3d61acf:         CronEntry minutes = entries.get(MINUTES);
1:3d61acf:         CronEntry hours = entries.get(HOURS);
1:3d61acf:         CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);
1:3d61acf:         CronEntry month = entries.get(MONTH);
1:3d61acf:         CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);
1:3d61acf: 
1:3d61acf:         // Start at the top of the next minute, cron is only guaranteed to be
1:3d61acf:         // run on the minute.
1:3d61acf:         int timeToNextMinute = 60 - working.get(Calendar.SECOND);
1:3d61acf:         working.add(Calendar.SECOND, timeToNextMinute);
1:3d61acf: 
1:3d61acf:         // If its already to late in the day this will roll us over to tomorrow
1:3d61acf:         // so we'll need to check again when done updating month and day.
1:3d61acf:         int currentMinutes = working.get(Calendar.MINUTE);
1:3d61acf:         if (!isCurrent(minutes, currentMinutes)) {
1:051e2b7:             int nextMinutes = getNext(minutes, currentMinutes, working);
1:3d61acf:             working.add(Calendar.MINUTE, nextMinutes);
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         int currentHours = working.get(Calendar.HOUR_OF_DAY);
1:3d61acf:         if (!isCurrent(hours, currentHours)) {
1:051e2b7:             int nextHour = getNext(hours, currentHours, working);
1:3d61acf:             working.add(Calendar.HOUR_OF_DAY, nextHour);
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         // We can roll into the next month here which might violate the cron setting
1:3d61acf:         // rules so we check once then recheck again after applying the month settings.
1:3d61acf:         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);
1:3d61acf: 
1:3d61acf:         // Start by checking if we are in the right month, if not then calculations
1:3d61acf:         // need to start from the beginning of the month to ensure that we don't end
1:3d61acf:         // up on the wrong day.  (Can happen when DAY_OF_WEEK is set and current time
1:3d61acf:         // is ahead of the day of the week to execute on).
1:3d61acf:         doUpdateCurrentMonth(working, month);
1:3d61acf: 
1:3d61acf:         // Now Check day of week and day of month together since they can be specified
1:3d61acf:         // together in one entry, if both "day of month" and "day of week" are restricted
1:3d61acf:         // (not "*"), then either the "day of month" field (3) or the "day of week" field
1:3d61acf:         // (5) must match the current day or the Calenday must be advanced.
1:3d61acf:         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);
1:3d61acf: 
1:3d61acf:         // Now we can chose the correct hour and minute of the day in question.
1:3d61acf: 
1:3d61acf:         currentHours = working.get(Calendar.HOUR_OF_DAY);
1:3d61acf:         if (!isCurrent(hours, currentHours)) {
1:051e2b7:             int nextHour = getNext(hours, currentHours, working);
1:3d61acf:             working.add(Calendar.HOUR_OF_DAY, nextHour);
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         currentMinutes = working.get(Calendar.MINUTE);
1:3d61acf:         if (!isCurrent(minutes, currentMinutes)) {
1:051e2b7:             int nextMinutes = getNext(minutes, currentMinutes, working);
1:3d61acf:             working.add(Calendar.MINUTE, nextMinutes);
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         result = working.getTimeInMillis();
1:3d61acf: 
1:3d61acf:         if (result <= currentTime) {
1:3d61acf:             throw new ArithmeticException("Unable to compute next scheduled exection time.");
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         return result;
1:3d61acf:     }
1:3d61acf: 
1:3d61acf:     protected static long doUpdateCurrentMonth(Calendar working, CronEntry month) throws MessageFormatException {
1:3d61acf: 
1:3d61acf:         int currentMonth = working.get(Calendar.MONTH) + 1;
1:3d61acf:         if (!isCurrent(month, currentMonth)) {
1:051e2b7:             int nextMonth = getNext(month, currentMonth, working);
1:3d61acf:             working.add(Calendar.MONTH, nextMonth);
1:3d61acf: 
1:3d61acf:             // Reset to start of month.
1:3d61acf:             resetToStartOfDay(working, 1);
1:3d61acf: 
1:3d61acf:             return working.getTimeInMillis();
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         return 0L;
1:3d61acf:     }
1:3d61acf: 
1:3d61acf:     protected static long doUpdateCurrentDay(Calendar working, CronEntry dayOfMonth, CronEntry dayOfWeek) throws MessageFormatException {
1:3d61acf: 
1:3d61acf:         int currentDayOfWeek = working.get(Calendar.DAY_OF_WEEK) - 1;
1:3d61acf:         int currentDayOfMonth = working.get(Calendar.DAY_OF_MONTH);
1:3d61acf: 
1:3d61acf:         // Simplest case, both are unrestricted or both match today otherwise
1:3d61acf:         // result must be the closer of the two if both are set, or the next
1:3d61acf:         // match to the one that is.
1:3d61acf:         if (!isCurrent(dayOfWeek, currentDayOfWeek) ||
1:3d61acf:             !isCurrent(dayOfMonth, currentDayOfMonth) ) {
1:3d61acf: 
1:3d61acf:             int nextWeekDay = Integer.MAX_VALUE;
1:3d61acf:             int nextCalendarDay = Integer.MAX_VALUE;
1:3d61acf: 
1:363a1cf:             if (!isCurrent(dayOfWeek, currentDayOfWeek)) {
1:051e2b7:                 nextWeekDay = getNext(dayOfWeek, currentDayOfWeek, working);
1:363a1cf:             }
1:051e2b7: 
1:363a1cf:             if (!isCurrent(dayOfMonth, currentDayOfMonth)) {
1:051e2b7:                 nextCalendarDay = getNext(dayOfMonth, currentDayOfMonth, working);
1:363a1cf:             }
1:3d61acf: 
1:3d61acf:             if( nextWeekDay < nextCalendarDay ) {
1:3d61acf:                 working.add(Calendar.DAY_OF_WEEK, nextWeekDay);
1:3d61acf:             } else {
1:3d61acf:                 working.add(Calendar.DAY_OF_MONTH, nextCalendarDay);
1:3d61acf:             }
1:3d61acf: 
1:3d61acf:             // Since the day changed, we restart the clock at the start of the day
1:3d61acf:             // so that the next time will either be at 12am + value of hours and
1:3d61acf:             // minutes pattern.
1:3d61acf:             resetToStartOfDay(working, working.get(Calendar.DAY_OF_MONTH));
1:3d61acf: 
1:3d61acf:             return working.getTimeInMillis();
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         return 0L;
1:3d61acf:     }
1:3d61acf: 
1:3d61acf:     public static void validate(final String cronEntry) throws MessageFormatException {
1:3d61acf:         List<String> list = tokenize(cronEntry);
1:3d61acf:         List<CronEntry> entries = buildCronEntries(list);
1:3d61acf:         for (CronEntry e : entries) {
1:3d61acf:             validate(e);
1:3d61acf:         }
1:3d61acf:     }
1:3d61acf: 
1:3d61acf:     static void validate(final CronEntry entry) throws MessageFormatException {
1:3d61acf: 
1:3d61acf:         List<Integer> list = entry.currentWhen;
1:3d61acf:         if (list.isEmpty() || list.get(0).intValue() < entry.start || list.get(list.size() - 1).intValue() > entry.end) {
1:3d61acf:             throw new MessageFormatException("Invalid token: " + entry);
1:3d61acf:         }
1:3d61acf:     }
1:3d61acf: 
1:051e2b7:     static int getNext(final CronEntry entry, final int current, final Calendar working) throws MessageFormatException {
1:3d61acf:         int result = 0;
1:3d61acf: 
1:3d61acf:         if (entry.currentWhen == null) {
1:3d61acf:             entry.currentWhen = calculateValues(entry);
1:3d61acf:         }
1:3d61acf: 
1:3d61acf:         List<Integer> list = entry.currentWhen;
1:3d61acf:         int next = -1;
1:3d61acf:         for (Integer i : list) {
1:3d61acf:             if (i.intValue() > current) {
1:3d61acf:                 next = i.intValue();
1:3d61acf:                 break;
1:363a1cf:             }
1:363a1cf:         }
1:3d61acf:         if (next != -1) {
1:3d61acf:             result = next - current;
1:3d61acf:         } else {
1:3d61acf:             int first = list.get(0).intValue();
1:051e2b7: 
1:051e2b7:             int fixedEnd = entry.end;
1:051e2b7: 
1:051e2b7:             //months have different max values
1:051e2b7:             if("DayOfMonth".equals(entry.name)) {
1:051e2b7:                 fixedEnd = working.getActualMaximum(Calendar.DAY_OF_MONTH)+1;
1:051e2b7:             }
1:051e2b7: 
1:051e2b7:             result = fixedEnd + first - entry.start - current;
1:3d61acf: 
1:3d61acf:             // Account for difference of one vs zero based indices.
1:3d61acf:             if (entry.name.equals("DayOfWeek") || entry.name.equals("Month")) {
1:3d61acf:                 result++;
1:3d61acf:             }
1:3d61acf:         }
1:3d61acf: 
3:e3154c3:         return result;
17:e3154c3:     }
1:3d61acf: 
1:3d61acf:     static boolean isCurrent(final CronEntry entry, final int current) throws MessageFormatException {
1:3d61acf:         boolean result = entry.currentWhen.contains(new Integer(current));
1:3d61acf:         return result;
1:3d61acf:     }
1:3d61acf: 
1:3d61acf:     protected static void resetToStartOfDay(Calendar target, int day) {
1:3d61acf:         target.set(Calendar.DAY_OF_MONTH, day);
1:3d61acf:         target.set(Calendar.HOUR_OF_DAY, 0);
1:3d61acf:         target.set(Calendar.MINUTE, 0);
1:3d61acf:         target.set(Calendar.SECOND, 0);
1:3d61acf:     }
1:3d61acf: 
1:e3154c3:     static List<String> tokenize(String cron) throws IllegalArgumentException {
1:e3154c3:         StringTokenizer tokenize = new StringTokenizer(cron);
1:e3154c3:         List<String> result = new ArrayList<String>();
1:e3154c3:         while (tokenize.hasMoreTokens()) {
1:e3154c3:             result.add(tokenize.nextToken());
1:e3154c3:         }
1:e3154c3:         if (result.size() != NUMBER_TOKENS) {
1:e3154c3:             throw new IllegalArgumentException("Not a valid cron entry - wrong number of tokens(" + result.size()
1:e3154c3:                     + "): " + cron);
1:e3154c3:         }
1:e3154c3:         return result;
1:e3154c3:     }
1:363a1cf: 
1:3d61acf:     protected static List<Integer> calculateValues(final CronEntry entry) {
1:e3154c3:         List<Integer> result = new ArrayList<Integer>();
1:e3154c3:         if (isAll(entry.token)) {
1:363a1cf:             for (int i = entry.start; i <= entry.end; i++) {
1:e3154c3:                 result.add(i);
1:e3154c3:             }
1:e3154c3:         } else if (isAStep(entry.token)) {
1:e3154c3:             int denominator = getDenominator(entry.token);
1:e3154c3:             String numerator = getNumerator(entry.token);
1:e3154c3:             CronEntry ce = new CronEntry(entry.name, numerator, entry.start, entry.end);
1:e3154c3:             List<Integer> list = calculateValues(ce);
2:e3154c3:             for (Integer i : list) {
1:e3154c3:                 if (i.intValue() % denominator == 0) {
1:e3154c3:                     result.add(i);
1:e3154c3:                 }
1:e3154c3:             }
1:e3154c3:         } else if (isAList(entry.token)) {
1:e3154c3:             StringTokenizer tokenizer = new StringTokenizer(entry.token, ",");
1:e3154c3:             while (tokenizer.hasMoreTokens()) {
1:e3154c3:                 String str = tokenizer.nextToken();
1:e3154c3:                 CronEntry ce = new CronEntry(entry.name, str, entry.start, entry.end);
1:e3154c3:                 List<Integer> list = calculateValues(ce);
1:e3154c3:                 result.addAll(list);
1:e3154c3:             }
1:e3154c3:         } else if (isARange(entry.token)) {
1:e3154c3:             int index = entry.token.indexOf('-');
1:e3154c3:             int first = Integer.parseInt(entry.token.substring(0, index));
1:e3154c3:             int last = Integer.parseInt(entry.token.substring(index + 1));
1:e3154c3:             for (int i = first; i <= last; i++) {
1:e3154c3:                 result.add(i);
1:e3154c3:             }
2:e3154c3:         } else {
1:e3154c3:             int value = Integer.parseInt(entry.token);
1:e3154c3:             result.add(value);
1:e3154c3:         }
1:3d61acf:         Collections.sort(result);
1:e3154c3:         return result;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static boolean isARange(String token) {
1:e3154c3:         return token != null && token.indexOf('-') >= 0;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static boolean isAStep(String token) {
1:e3154c3:         return token != null && token.indexOf('/') >= 0;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static boolean isAList(String token) {
1:e3154c3:         return token != null && token.indexOf(',') >= 0;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static boolean isAll(String token) {
1:3aaa1e7:         return token != null && token.length() == 1 && (token.charAt(0) == '*' || token.charAt(0) == '?');
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static int getDenominator(final String token) {
2:e3154c3:         int result = 0;
1:e3154c3:         int index = token.indexOf('/');
1:e3154c3:         String str = token.substring(index + 1);
1:e3154c3:         result = Integer.parseInt(str);
1:e3154c3:         return result;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     protected static String getNumerator(final String token) {
1:e3154c3:         int index = token.indexOf('/');
1:e3154c3:         String str = token.substring(0, index);
1:e3154c3:         return str;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     static List<CronEntry> buildCronEntries(List<String> tokens) {
1:3d61acf: 
1:e3154c3:         List<CronEntry> result = new ArrayList<CronEntry>();
1:3d61acf: 
1:363a1cf:         CronEntry minutes = new CronEntry("Minutes", tokens.get(MINUTES), 0, 60);
1:3d61acf:         minutes.currentWhen = calculateValues(minutes);
1:e3154c3:         result.add(minutes);
1:363a1cf:         CronEntry hours = new CronEntry("Hours", tokens.get(HOURS), 0, 24);
1:3d61acf:         hours.currentWhen = calculateValues(hours);
1:e3154c3:         result.add(hours);
1:7738e86:         CronEntry dayOfMonth = new CronEntry("DayOfMonth", tokens.get(DAY_OF_MONTH), 1, 32);
1:3d61acf:         dayOfMonth.currentWhen = calculateValues(dayOfMonth);
1:e3154c3:         result.add(dayOfMonth);
1:e3154c3:         CronEntry month = new CronEntry("Month", tokens.get(MONTH), 1, 12);
1:3d61acf:         month.currentWhen = calculateValues(month);
1:e3154c3:         result.add(month);
1:e3154c3:         CronEntry dayOfWeek = new CronEntry("DayOfWeek", tokens.get(DAY_OF_WEEK), 0, 6);
1:3d61acf:         dayOfWeek.currentWhen = calculateValues(dayOfWeek);
1:e3154c3:         result.add(dayOfWeek);
1:3d61acf: 
1:e3154c3:         return result;
1:e3154c3:     }
1:e3154c3: 
1:e3154c3:     static class CronEntry {
1:3d61acf: 
1:e3154c3:         final String name;
1:e3154c3:         final String token;
1:e3154c3:         final int start;
1:e3154c3:         final int end;
1:3d61acf: 
1:3d61acf:         List<Integer> currentWhen;
1:3d61acf: 
1:e3154c3:         CronEntry(String name, String token, int start, int end) {
1:e3154c3:             this.name = name;
1:e3154c3:             this.token = token;
1:e3154c3:             this.start = start;
1:e3154c3:             this.end = end;
1:e3154c3:         }
1:3d61acf: 
1:e3154c3:         @Override
1:e3154c3:         public String toString() {
1:e3154c3:             return this.name + ":" + token;
1:e3154c3:         }
1:e3154c3:     }
1:e3154c3: 
1:e3154c3: }
============================================================================
author:Sami Nurminen
-------------------------------------------------------------------------------
commit:39caca7
/////////////////////////////////////////////////////////////////////////
commit:051e2b7
/////////////////////////////////////////////////////////////////////////
1:             int nextMinutes = getNext(minutes, currentMinutes, working);
1:             int nextHour = getNext(hours, currentHours, working);
/////////////////////////////////////////////////////////////////////////
1:             int nextHour = getNext(hours, currentHours, working);
1:             int nextMinutes = getNext(minutes, currentMinutes, working);
/////////////////////////////////////////////////////////////////////////
1:             int nextMonth = getNext(month, currentMonth, working);
/////////////////////////////////////////////////////////////////////////
1:                 nextWeekDay = getNext(dayOfWeek, currentDayOfWeek, working);
0:                 System.out.println("nextWeekDay:"+nextCalendarDay);
1: 
1:                 nextCalendarDay = getNext(dayOfMonth, currentDayOfMonth, working);
/////////////////////////////////////////////////////////////////////////
1:     static int getNext(final CronEntry entry, final int current, final Calendar working) throws MessageFormatException {
/////////////////////////////////////////////////////////////////////////
1: 
1:             int fixedEnd = entry.end;
1: 
1:             //months have different max values
1:             if("DayOfMonth".equals(entry.name)) {
1:                 fixedEnd = working.getActualMaximum(Calendar.DAY_OF_MONTH)+1;
1:             }
1: 
1:             result = fixedEnd + first - entry.start - current;
author:Matt Warhaftig
-------------------------------------------------------------------------------
commit:7738e86
/////////////////////////////////////////////////////////////////////////
1:         CronEntry dayOfMonth = new CronEntry("DayOfMonth", tokens.get(DAY_OF_MONTH), 1, 32);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d57ebf8
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             result = result / 60000 * 60000;
commit:3aaa1e7
/////////////////////////////////////////////////////////////////////////
1:         return token != null && token.length() == 1 && (token.charAt(0) == '*' || token.charAt(0) == '?');
commit:3d61acf
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         long result = 0;
1: 
1:         if (cronEntry == null || cronEntry.length() == 0) {
1:             return result;
1:         }
1: 
1:         // Handle the once per minute case "* * * * *"
1:         // starting the next event at the top of the minute.
0:         if (cronEntry.startsWith("* * * * *")) {
1:             result = currentTime + 60 * 1000;
0:             result = result / 1000 * 1000;
1:             return result;
1:         }
1: 
1:         List<String> list = tokenize(cronEntry);
1:         List<CronEntry> entries = buildCronEntries(list);
1:         Calendar working = Calendar.getInstance();
1:         working.setTimeInMillis(currentTime);
1:         working.set(Calendar.SECOND, 0);
1: 
1:         CronEntry minutes = entries.get(MINUTES);
1:         CronEntry hours = entries.get(HOURS);
1:         CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);
1:         CronEntry month = entries.get(MONTH);
1:         CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);
1: 
1:         // Start at the top of the next minute, cron is only guaranteed to be
1:         // run on the minute.
1:         int timeToNextMinute = 60 - working.get(Calendar.SECOND);
1:         working.add(Calendar.SECOND, timeToNextMinute);
1: 
1:         // If its already to late in the day this will roll us over to tomorrow
1:         // so we'll need to check again when done updating month and day.
1:         int currentMinutes = working.get(Calendar.MINUTE);
1:         if (!isCurrent(minutes, currentMinutes)) {
0:             int nextMinutes = getNext(minutes, currentMinutes);
1:             working.add(Calendar.MINUTE, nextMinutes);
1:         }
1: 
1:         int currentHours = working.get(Calendar.HOUR_OF_DAY);
1:         if (!isCurrent(hours, currentHours)) {
0:             int nextHour = getNext(hours, currentHours);
1:             working.add(Calendar.HOUR_OF_DAY, nextHour);
1:         }
1: 
1:         // We can roll into the next month here which might violate the cron setting
1:         // rules so we check once then recheck again after applying the month settings.
1:         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);
1: 
1:         // Start by checking if we are in the right month, if not then calculations
1:         // need to start from the beginning of the month to ensure that we don't end
1:         // up on the wrong day.  (Can happen when DAY_OF_WEEK is set and current time
1:         // is ahead of the day of the week to execute on).
1:         doUpdateCurrentMonth(working, month);
1: 
1:         // Now Check day of week and day of month together since they can be specified
1:         // together in one entry, if both "day of month" and "day of week" are restricted
1:         // (not "*"), then either the "day of month" field (3) or the "day of week" field
1:         // (5) must match the current day or the Calenday must be advanced.
1:         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);
1: 
1:         // Now we can chose the correct hour and minute of the day in question.
1: 
1:         currentHours = working.get(Calendar.HOUR_OF_DAY);
1:         if (!isCurrent(hours, currentHours)) {
0:             int nextHour = getNext(hours, currentHours);
1:             working.add(Calendar.HOUR_OF_DAY, nextHour);
1:         }
1: 
1:         currentMinutes = working.get(Calendar.MINUTE);
1:         if (!isCurrent(minutes, currentMinutes)) {
0:             int nextMinutes = getNext(minutes, currentMinutes);
1:             working.add(Calendar.MINUTE, nextMinutes);
1:         }
1: 
1:         result = working.getTimeInMillis();
1: 
1:         if (result <= currentTime) {
1:             throw new ArithmeticException("Unable to compute next scheduled exection time.");
1:         }
1: 
1:         return result;
1:     }
1: 
1:     protected static long doUpdateCurrentMonth(Calendar working, CronEntry month) throws MessageFormatException {
1: 
1:         int currentMonth = working.get(Calendar.MONTH) + 1;
1:         if (!isCurrent(month, currentMonth)) {
0:             int nextMonth = getNext(month, currentMonth);
1:             working.add(Calendar.MONTH, nextMonth);
1: 
1:             // Reset to start of month.
1:             resetToStartOfDay(working, 1);
1: 
1:             return working.getTimeInMillis();
1:         }
1: 
1:         return 0L;
1:     }
1: 
1:     protected static long doUpdateCurrentDay(Calendar working, CronEntry dayOfMonth, CronEntry dayOfWeek) throws MessageFormatException {
1: 
1:         int currentDayOfWeek = working.get(Calendar.DAY_OF_WEEK) - 1;
1:         int currentDayOfMonth = working.get(Calendar.DAY_OF_MONTH);
1: 
1:         // Simplest case, both are unrestricted or both match today otherwise
1:         // result must be the closer of the two if both are set, or the next
1:         // match to the one that is.
1:         if (!isCurrent(dayOfWeek, currentDayOfWeek) ||
1:             !isCurrent(dayOfMonth, currentDayOfMonth) ) {
1: 
1:             int nextWeekDay = Integer.MAX_VALUE;
1:             int nextCalendarDay = Integer.MAX_VALUE;
1: 
0:                 nextWeekDay = getNext(dayOfWeek, currentDayOfWeek);
1: 
0:                 nextCalendarDay = getNext(dayOfMonth, currentDayOfMonth);
1: 
1:             if( nextWeekDay < nextCalendarDay ) {
1:                 working.add(Calendar.DAY_OF_WEEK, nextWeekDay);
1:             } else {
1:                 working.add(Calendar.DAY_OF_MONTH, nextCalendarDay);
1:             }
1: 
1:             // Since the day changed, we restart the clock at the start of the day
1:             // so that the next time will either be at 12am + value of hours and
1:             // minutes pattern.
1:             resetToStartOfDay(working, working.get(Calendar.DAY_OF_MONTH));
1: 
1:             return working.getTimeInMillis();
1:         }
1: 
1:         return 0L;
1:     }
1: 
1:     public static void validate(final String cronEntry) throws MessageFormatException {
1:         List<String> list = tokenize(cronEntry);
1:         List<CronEntry> entries = buildCronEntries(list);
1:         for (CronEntry e : entries) {
1:             validate(e);
1:         }
1:     }
1: 
1:     static void validate(final CronEntry entry) throws MessageFormatException {
1: 
1:         List<Integer> list = entry.currentWhen;
1:         if (list.isEmpty() || list.get(0).intValue() < entry.start || list.get(list.size() - 1).intValue() > entry.end) {
1:             throw new MessageFormatException("Invalid token: " + entry);
1:         }
1:     }
1: 
0:     static int getNext(final CronEntry entry, final int current) throws MessageFormatException {
1:         int result = 0;
1: 
1:         if (entry.currentWhen == null) {
1:             entry.currentWhen = calculateValues(entry);
1:         }
1: 
1:         List<Integer> list = entry.currentWhen;
1:         int next = -1;
1:         for (Integer i : list) {
1:             if (i.intValue() > current) {
1:                 next = i.intValue();
1:                 break;
1:         if (next != -1) {
1:             result = next - current;
1:         } else {
1:             int first = list.get(0).intValue();
0:             result = entry.end + first - entry.start - current;
1: 
1:             // Account for difference of one vs zero based indices.
1:             if (entry.name.equals("DayOfWeek") || entry.name.equals("Month")) {
1:                 result++;
1:             }
1:         }
1: 
1:     static boolean isCurrent(final CronEntry entry, final int current) throws MessageFormatException {
1:         boolean result = entry.currentWhen.contains(new Integer(current));
1:         return result;
1:     }
1: 
1:     protected static void resetToStartOfDay(Calendar target, int day) {
1:         target.set(Calendar.DAY_OF_MONTH, day);
1:         target.set(Calendar.HOUR_OF_DAY, 0);
1:         target.set(Calendar.MINUTE, 0);
1:         target.set(Calendar.SECOND, 0);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected static List<Integer> calculateValues(final CronEntry entry) {
/////////////////////////////////////////////////////////////////////////
1:         Collections.sort(result);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         minutes.currentWhen = calculateValues(minutes);
1:         hours.currentWhen = calculateValues(hours);
1:         dayOfMonth.currentWhen = calculateValues(dayOfMonth);
1:         month.currentWhen = calculateValues(month);
1:         dayOfWeek.currentWhen = calculateValues(dayOfWeek);
1: 
1: 
1: 
1:         List<Integer> currentWhen;
1: 
1: 
commit:e0c678e
/////////////////////////////////////////////////////////////////////////
0:             CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);
/////////////////////////////////////////////////////////////////////////
0:                 int nextDay = getNext(dayOfMonth, currentDayOfMonth);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:148ca81
/////////////////////////////////////////////////////////////////////////
1:         if (cronEntry.equals("* * * * *")) {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
author:Gary Tully
-------------------------------------------------------------------------------
commit:363a1cf
/////////////////////////////////////////////////////////////////////////
0:             Calendar working = Calendar.getInstance();
0:             working.setTimeInMillis(currentTime);
1:             
0:             int currentMinutes = working.get(Calendar.MINUTE);
0:                 result = working.getTimeInMillis();
0:             int currentHours = working.get(Calendar.HOUR_OF_DAY);
0:             if (!isCurrent(hours, currentHours)) {
0:                 int nextHour = getNext(hours, currentHours);
0:                 working.add(Calendar.HOUR_OF_DAY, nextHour);
0:                 result = working.getTimeInMillis();
1:             }
0:             int currentDayOfWeek = working.get(Calendar.DAY_OF_WEEK) - 1;
1:             if (!isCurrent(dayOfWeek, currentDayOfWeek)) {
0:                 int nextDay = getNext(dayOfWeek, currentDayOfWeek);
0:                 working.add(Calendar.DAY_OF_WEEK, nextDay);
0:                 result = working.getTimeInMillis();
1:             }
0:             int currentMonth = working.get(Calendar.MONTH) + 1;
0:             if (!isCurrent(month, currentMonth)) {
0:                 int nextMonth = getNext(month, currentMonth);
0:                 working.add(Calendar.MONTH, nextMonth);
0:                 result = working.getTimeInMillis();
1:             }
0:             int currentDayOfMonth = working.get(Calendar.DAY_OF_MONTH);
1:             if (!isCurrent(dayOfMonth, currentDayOfMonth)) {
0:                 int nextDay = getNext(dayOfMonth, currentMonth);
0:                 working.add(Calendar.DAY_OF_MONTH, nextDay);
0:                 result = working.getTimeInMillis();
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:             for (int i = entry.start; i <= entry.end; i++) {
/////////////////////////////////////////////////////////////////////////
1:         CronEntry minutes = new CronEntry("Minutes", tokens.get(MINUTES), 0, 60);
1:         CronEntry hours = new CronEntry("Hours", tokens.get(HOURS), 0, 24);
author:Robert Davies
-------------------------------------------------------------------------------
commit:e3154c3
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.scheduler;
1: 
1: import java.util.ArrayList;
1: import java.util.Calendar;
1: import java.util.Collections;
1: import java.util.List;
1: import java.util.StringTokenizer;
1: import javax.jms.MessageFormatException;
1: 
1: public class CronParser {
1:     private static final int NUMBER_TOKENS = 5;
1:     private static final int MINUTES = 0;
1:     private static final int HOURS = 1;
1:     private static final int DAY_OF_MONTH = 2;
1:     private static final int MONTH = 3;
1:     private static final int DAY_OF_WEEK = 4;
1: 
1:     public static long getNextScheduledTime(final String cronEntry, long currentTime) throws MessageFormatException {
0:         long result = 0;
0:         if (cronEntry != null && cronEntry.length() > 0) {
0:             List<String> list = tokenize(cronEntry);
0:             List<CronEntry> entries = buildCronEntries(list);
0:             Calendar calendar = Calendar.getInstance();
0:             calendar.setTimeInMillis(currentTime);
0:             int currentMinutes = calendar.get(Calendar.MINUTE);
0:             int currentHours = calendar.get(Calendar.HOUR_OF_DAY);
0:             int currentDayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);
0:             int currentMonth = calendar.get(Calendar.MONTH) + 1;
0:             int currentDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;
1: 
0:             CronEntry minutes = entries.get(MINUTES);
0:             CronEntry hours = entries.get(HOURS);
0:             CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);
0:             CronEntry month = entries.get(MONTH);
0:             CronEntry dayOfWeek = entries.get(DAY_OF_MONTH);
0:             if (!isCurrent(month, currentMonth)) {
0:                 int nextMonth = getNext(month, currentMonth);
0:                 Calendar working = (Calendar) calendar.clone();
0:                 working.add(Calendar.MONTH, nextMonth);
0:                 result += working.getTimeInMillis();
1:             }
0:             if (!isCurrent(dayOfMonth, currentDayOfMonth)) {
0:                 int nextDay = getNext(dayOfMonth, currentMonth);
0:                 Calendar working = (Calendar) calendar.clone();
0:                 working.add(Calendar.DAY_OF_MONTH, nextDay);
0:                 result += working.getTimeInMillis();
1:             }
0:             if (!isCurrent(dayOfWeek, currentDayOfWeek)) {
0:                 int nextDay = getNext(dayOfWeek, currentDayOfWeek);
0:                 Calendar working = (Calendar) calendar.clone();
0:                 working.add(Calendar.DAY_OF_WEEK, nextDay);
0:                 result += working.getTimeInMillis();
1:             }
0:             if (!isCurrent(hours, currentHours)) {
0:                 int nextHour = getNext(hours, currentHours);
0:                 Calendar working = (Calendar) calendar.clone();
0:                 working.add(Calendar.HOUR_OF_DAY, nextHour);
0:                 result += working.getTimeInMillis();
1:             }
0:             if (!isCurrent(minutes, currentMinutes)) {
0:                 int nextMinutes = getNext(minutes, currentMinutes);
0:                 Calendar working = (Calendar) calendar.clone();
0:                 working.add(Calendar.MINUTE, nextMinutes);
0:                 result += working.getTimeInMillis();
1:             }
0:             if (result == 0) {
0:                 // this can occur for "* * * * *"
0:                 result = currentTime + 60 * 1000;
0:                 result = result / 1000 * 1000;
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     static List<String> tokenize(String cron) throws IllegalArgumentException {
1:         StringTokenizer tokenize = new StringTokenizer(cron);
1:         List<String> result = new ArrayList<String>();
1:         while (tokenize.hasMoreTokens()) {
1:             result.add(tokenize.nextToken());
1:         }
1:         if (result.size() != NUMBER_TOKENS) {
1:             throw new IllegalArgumentException("Not a valid cron entry - wrong number of tokens(" + result.size()
1:                     + "): " + cron);
1:         }
1:         return result;
1:     }
1: 
0:     public static void validate(final String cronEntry) throws MessageFormatException {
0:         List<String> list = tokenize(cronEntry);
0:         List<CronEntry> entries = buildCronEntries(list);
0:         for (CronEntry e : entries) {
0:             validate(e);
1:         }
1:     }
1: 
0:     static void validate(CronEntry entry) throws MessageFormatException {
1: 
0:         List<Integer> list = calculateValues(entry);
0:         if (list.isEmpty() || list.get(0).intValue() < entry.start || list.get(list.size() - 1).intValue() > entry.end) {
0:             throw new MessageFormatException("Invalid token: " + entry);
1:         }
1:     }
1: 
0:     static int getNext(final CronEntry entry, final int current) throws MessageFormatException {
1:         int result = 0;
0:         List<Integer> list = calculateValues(entry);
0:         Collections.sort(list);
0:         int next = -1;
1:         for (Integer i : list) {
0:             if (i.intValue() > current) {
0:                 next = i.intValue();
0:                 break;
1:             }
1:         }
0:         if (next != -1) {
0:             result = next - current;
1:         } else {
0:             int first = list.get(0).intValue();
0:             result = entry.end + first - entry.start - current;
1:         }
1: 
1:         return result;
1:     }
1: 
0:     static boolean isCurrent(final CronEntry entry, final int current) throws MessageFormatException {
1: 
0:         List<Integer> list = calculateValues(entry);
0:         boolean result = list.contains(new Integer(current));
1:         return result;
1:     }
1: 
0:     protected static List<Integer> calculateValues(CronEntry entry) {
1:         List<Integer> result = new ArrayList<Integer>();
1:         if (isAll(entry.token)) {
0:             for (int i = entry.start; i < entry.end; i++) {
1:                 result.add(i);
1:             }
1:         } else if (isAStep(entry.token)) {
1:             int denominator = getDenominator(entry.token);
1:             String numerator = getNumerator(entry.token);
1:             CronEntry ce = new CronEntry(entry.name, numerator, entry.start, entry.end);
1:             List<Integer> list = calculateValues(ce);
1:             for (Integer i : list) {
1:                 if (i.intValue() % denominator == 0) {
1:                     result.add(i);
1:                 }
1:             }
1:         } else if (isAList(entry.token)) {
1:             StringTokenizer tokenizer = new StringTokenizer(entry.token, ",");
1:             while (tokenizer.hasMoreTokens()) {
1:                 String str = tokenizer.nextToken();
1:                 CronEntry ce = new CronEntry(entry.name, str, entry.start, entry.end);
1:                 List<Integer> list = calculateValues(ce);
1:                 result.addAll(list);
1:             }
1:         } else if (isARange(entry.token)) {
1:             int index = entry.token.indexOf('-');
1:             int first = Integer.parseInt(entry.token.substring(0, index));
1:             int last = Integer.parseInt(entry.token.substring(index + 1));
1:             for (int i = first; i <= last; i++) {
1:                 result.add(i);
1:             }
1:         } else {
1:             int value = Integer.parseInt(entry.token);
1:             result.add(value);
1:         }
1:         return result;
1:     }
1: 
1:     protected static boolean isARange(String token) {
1:         return token != null && token.indexOf('-') >= 0;
1:     }
1: 
1:     protected static boolean isAStep(String token) {
1:         return token != null && token.indexOf('/') >= 0;
1:     }
1: 
1:     protected static boolean isAList(String token) {
1:         return token != null && token.indexOf(',') >= 0;
1:     }
1: 
1:     protected static boolean isAll(String token) {
0:         return token != null && token.length() == 1 && token.charAt(0) == '*';
1:     }
1: 
1:     protected static int getDenominator(final String token) {
1:         int result = 0;
1:         int index = token.indexOf('/');
1:         String str = token.substring(index + 1);
1:         result = Integer.parseInt(str);
1:         return result;
1:     }
1: 
1:     protected static String getNumerator(final String token) {
1:         int index = token.indexOf('/');
1:         String str = token.substring(0, index);
1:         return str;
1:     }
1: 
1:     static List<CronEntry> buildCronEntries(List<String> tokens) {
1:         List<CronEntry> result = new ArrayList<CronEntry>();
0:         CronEntry minutes = new CronEntry("Minutes", tokens.get(MINUTES), 0, 59);
1:         result.add(minutes);
0:         CronEntry hours = new CronEntry("Hours", tokens.get(HOURS), 0, 23);
1:         result.add(hours);
0:         CronEntry dayOfMonth = new CronEntry("DayOfMonth", tokens.get(DAY_OF_MONTH), 1, 31);
1:         result.add(dayOfMonth);
1:         CronEntry month = new CronEntry("Month", tokens.get(MONTH), 1, 12);
1:         result.add(month);
1:         CronEntry dayOfWeek = new CronEntry("DayOfWeek", tokens.get(DAY_OF_WEEK), 0, 6);
1:         result.add(dayOfWeek);
1:         return result;
1:     }
1: 
1:     static class CronEntry {
1:         final String name;
1:         final String token;
1:         final int start;
1:         final int end;
1:         CronEntry(String name, String token, int start, int end) {
1:             this.name = name;
1:             this.token = token;
1:             this.start = start;
1:             this.end = end;
1:         }
1:         @Override
1:         public String toString() {
1:             return this.name + ":" + token;
1:         }
1:     }
1: 
1: }
============================================================================