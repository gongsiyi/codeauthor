1:9352c9f: /**
1:9352c9f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9352c9f:  * contributor license agreements.  See the NOTICE file distributed with
1:9352c9f:  * this work for additional information regarding copyright ownership.
1:9352c9f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9352c9f:  * (the "License"); you may not use this file except in compliance with
1:9352c9f:  * the License.  You may obtain a copy of the License at
1:9352c9f:  *
1:9352c9f:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9352c9f:  *
1:9352c9f:  * Unless required by applicable law or agreed to in writing, software
1:9352c9f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9352c9f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9352c9f:  * See the License for the specific language governing permissions and
1:9352c9f:  * limitations under the License.
1:9352c9f:  */
1:9352c9f: package org.apache.activemq.bugs;
1:c808beb: 
1:29e3702: import java.io.File;
1:1a5ad28: import java.util.ArrayList;
1:1a5ad28: import java.util.List;
1:8e6446f: import java.util.Vector;
1:8e6446f: import java.util.concurrent.CountDownLatch;
1:8e6446f: import java.util.concurrent.ExecutorService;
1:8e6446f: import java.util.concurrent.Executors;
1:8e6446f: import java.util.concurrent.TimeUnit;
1:8e6446f: import java.util.concurrent.atomic.AtomicInteger;
1:9352c9f: import javax.jms.BytesMessage;
1:9352c9f: import javax.jms.Connection;
1:9352c9f: import javax.jms.ConnectionFactory;
1:29e3702: import javax.jms.DeliveryMode;
1:29e3702: import javax.jms.ExceptionListener;
1:9352c9f: import javax.jms.JMSException;
1:9352c9f: import javax.jms.Message;
1:9352c9f: import javax.jms.MessageConsumer;
1:29e3702: import javax.jms.MessageListener;
1:9352c9f: import javax.jms.MessageProducer;
1:9352c9f: import javax.jms.Session;
1:9352c9f: import javax.jms.Topic;
1:29e3702: import javax.jms.TopicConnection;
1:29e3702: import javax.jms.TopicConnectionFactory;
1:29e3702: import javax.jms.TopicPublisher;
1:29e3702: import javax.jms.TopicSession;
1:29e3702: import javax.jms.TopicSubscriber;
1:e35519f: import javax.management.ObjectName;
1:c808beb: import junit.framework.Test;
1:8e6446f: import org.apache.activemq.ActiveMQConnection;
1:9352c9f: import org.apache.activemq.ActiveMQConnectionFactory;
1:c808beb: import org.apache.activemq.CombinationTestSupport;
1:9352c9f: import org.apache.activemq.broker.BrokerService;
1:e35519f: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:e35519f: import org.apache.activemq.broker.region.policy.PolicyMap;
1:29e3702: import org.apache.activemq.command.ActiveMQTopic;
1:dd48ebe: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:8b1e16d: import org.apache.activemq.store.kahadb.KahaDBStore;
1:8b1e16d: import org.apache.activemq.util.IOHelper;
1:9caa5c8: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:29e3702: 
1:9352c9f: /**
1:b0c2a40:  *  A Test case for AMQ-1479
1:9352c9f:  */
1:8b1e16d: public class DurableConsumerTest extends CombinationTestSupport{
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DurableConsumerTest.class);
1:c709527:     private static int COUNT = 1024;
1:9352c9f:     private static String CONSUMER_NAME = "DURABLE_TEST";
1:9352c9f:     protected BrokerService broker;
1:29e3702:     
1:8b1e16d:     protected String bindAddress = "tcp://localhost:61616";
1:ac54a61:     
1:8b1e16d:     protected byte[] payload = new byte[1024 * 32];
1:9352c9f:     protected ConnectionFactory factory;
1:8e6446f:     protected Vector<Exception> exceptions = new Vector<Exception>();
1:29e3702:     
1:29e3702:     private static final String TOPIC_NAME = "failoverTopic";
1:29e3702:     private static final String CONNECTION_URL = "failover:(tcp://localhost:61616,tcp://localhost:61617)";
1:c808beb:     public boolean useDedicatedTaskRunner = false;
1:29e3702:     
1:8b1e16d:     private class SimpleTopicSubscriber implements MessageListener,ExceptionListener{
1:29e3702:         
1:29e3702:         private TopicConnection topicConnection = null;
1:29e3702:         
1:8b1e16d:         public SimpleTopicSubscriber(String connectionURL,String clientId,String topicName) {
1:29e3702:             
1:29e3702:             ActiveMQConnectionFactory topicConnectionFactory = null;
1:29e3702:             TopicSession topicSession = null;
1:29e3702:             Topic topic = null;
1:29e3702:             TopicSubscriber topicSubscriber = null;
1:29e3702:             
1:29e3702:             topicConnectionFactory = new ActiveMQConnectionFactory(connectionURL);
1:29e3702:             try {
1:29e3702:                 
1:29e3702:                 topic = new ActiveMQTopic(topicName);
2:29e3702:                 topicConnection = topicConnectionFactory.createTopicConnection();
1:29e3702:                 topicConnection.setClientID((clientId));
1:29e3702:                 topicConnection.start();
1:29e3702:                 
2:29e3702:                 topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:29e3702:                 topicSubscriber = topicSession.createDurableSubscriber(topic, (clientId));
1:29e3702:                 topicSubscriber.setMessageListener(this);
1:29e3702:                 
1:29e3702:             } catch (JMSException e) {
1:29e3702:                 e.printStackTrace();
1:29e3702:             }
1:d20da44:         }
1:d20da44:         
1:8b1e16d:         public void onMessage(Message arg0){
1:29e3702:         }
1:29e3702:         
1:8b1e16d:         public void closeConnection(){
1:29e3702:             if (topicConnection != null) {
1:29e3702:                 try {
1:29e3702:                     topicConnection.close();
1:29e3702:                 } catch (JMSException e) {
1:29e3702:                 }
1:29e3702:             }
1:29e3702:         }
1:29e3702:         
1:8b1e16d:         public void onException(JMSException exception){
1:29e3702:             exceptions.add(exception);
1:29e3702:         }
1:29e3702:     }
1:29e3702:     
1:8b1e16d:     private class MessagePublisher implements Runnable{
1:1a5ad28:         private final boolean shouldPublish = true;
1:29e3702:         
1:8b1e16d:         public void run(){
1:29e3702:             TopicConnectionFactory topicConnectionFactory = null;
1:29e3702:             TopicConnection topicConnection = null;
1:29e3702:             TopicSession topicSession = null;
1:29e3702:             Topic topic = null;
1:29e3702:             TopicPublisher topicPublisher = null;
1:29e3702:             Message message = null;
1:29e3702:             
1:29e3702:             topicConnectionFactory = new ActiveMQConnectionFactory(CONNECTION_URL);
1:29e3702:             try {
1:2e7d219:                 topic = new ActiveMQTopic(TOPIC_NAME);
1:2e7d219:                 topicConnection = topicConnectionFactory.createTopicConnection();
1:2e7d219:                 topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:2e7d219:                 topicPublisher = topicSession.createPublisher(topic);
1:2e7d219:                 message = topicSession.createMessage();
1:8b1e16d:             } catch (Exception ex) {
1:29e3702:                 exceptions.add(ex);
1:29e3702:             }
1:29e3702:             while (shouldPublish) {
1:29e3702:                 try {
1:29e3702:                     topicPublisher.publish(message, DeliveryMode.PERSISTENT, 1, 2 * 60 * 60 * 1000);
1:29e3702:                 } catch (JMSException ex) {
1:29e3702:                     exceptions.add(ex);
1:29e3702:                 }
1:29e3702:                 try {
1:29e3702:                     Thread.sleep(1);
1:29e3702:                 } catch (Exception ex) {
1:29e3702:                 }
1:29e3702:             }
1:29e3702:         }
1:29e3702:     }
1:29e3702:     
1:8b1e16d:     private void configurePersistence(BrokerService broker) throws Exception{
1:8b1e16d:         File dataDirFile = new File("target/" + getName());
1:dd48ebe:         KahaDBPersistenceAdapter kahaDBAdapter = new KahaDBPersistenceAdapter();
1:dd48ebe:         kahaDBAdapter.setDirectory(dataDirFile);
1:dd48ebe:         broker.setPersistenceAdapter(kahaDBAdapter);
1:29e3702:     }
1:29e3702:     
1:8b1e16d:     public void testFailover() throws Exception{
1:29e3702:         
1:d20da44:         configurePersistence(broker);
1:d20da44:         broker.start();
1:d20da44:         
1:8b1e16d:         Thread publisherThread = new Thread(new MessagePublisher());
1:29e3702:         publisherThread.start();
1:ac54a61:         final int numSubs = 100;
1:ac54a61:         final List<SimpleTopicSubscriber> list = new ArrayList<SimpleTopicSubscriber>(numSubs);
1:ac54a61:         for (int i = 0; i < numSubs; i++) {
1:29e3702:             
1:29e3702:             final int id = i;
1:8b1e16d:             Thread thread = new Thread(new Runnable(){
1:8b1e16d:                 public void run(){
1:1a5ad28:                     SimpleTopicSubscriber s =new SimpleTopicSubscriber(CONNECTION_URL, System.currentTimeMillis() + "-" + id, TOPIC_NAME);
1:1a5ad28:                     list.add(s);
1:29e3702:                 }
1:9caa5c8:             });
1:29e3702:             thread.start();
1:29e3702:             
1:29e3702:         }
1:29e3702: 
1:ac54a61:         Wait.waitFor(new Wait.Condition(){
1:ac54a61:             @Override
1:ac54a61:             public boolean isSatisified() throws Exception {
1:ac54a61:                 return numSubs == list.size();
1:ac54a61:             }
1:ac54a61:         });
1:29e3702: 
1:29e3702:         broker.stop();
1:29e3702:         broker = createBroker(false);
1:d20da44:         configurePersistence(broker);
1:d20da44:         broker.start();
1:2e7d219:         Thread.sleep(10000);
1:1a5ad28:         for (SimpleTopicSubscriber s:list) {
1:1a5ad28:             s.closeConnection();
1:29e3702:         }
1:ac54a61:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:1a5ad28:     }
1:d20da44:     
1:c808beb:     // makes heavy use of threads and can demonstrate https://issues.apache.org/activemq/browse/AMQ-2028
1:c808beb:     // with use dedicatedTaskRunner=true and produce OOM
1:8b1e16d:     public void initCombosForTestConcurrentDurableConsumer(){
1:8b1e16d:         addCombinationValues("useDedicatedTaskRunner", new Object[] { Boolean.TRUE, Boolean.FALSE });
1:c808beb:     }
1:d20da44:     
1:8b1e16d:     public void testConcurrentDurableConsumer() throws Exception{
1:29e3702:         
1:d20da44:         broker.start();
1:a7533ba:         broker.waitUntilStarted();
1:ac54a61:         
1:8e6446f:         factory = createConnectionFactory();
1:8e6446f:         final String topicName = getName();
1:8e6446f:         final int numMessages = 500;
1:8b1e16d:         int numConsumers = 1;
1:19bfd9d:         final CountDownLatch counsumerStarted = new CountDownLatch(numConsumers);
1:8e6446f:         final AtomicInteger receivedCount = new AtomicInteger();
1:8b1e16d:         Runnable consumer = new Runnable(){
1:8b1e16d:             public void run(){
1:8e6446f:                 final String consumerName = Thread.currentThread().getName();
1:8e6446f:                 int acked = 0;
1:8e6446f:                 int received = 0;
1:e35519f:                 
1:8e6446f:                 try {
1:8b1e16d:                     while (acked < numMessages / 2) {
1:8e6446f:                         // take one message and close, ack on occasion
1:8e6446f:                         Connection consumerConnection = factory.createConnection();
1:8b1e16d:                         ((ActiveMQConnection) consumerConnection).setWatchTopicAdvisories(false);
1:8e6446f:                         consumerConnection.setClientID(consumerName);
1:8b1e16d:                         Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:8e6446f:                         Topic topic = consumerSession.createTopic(topicName);
1:8e6446f:                         consumerConnection.start();
1:e35519f:                         
1:8b1e16d:                         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, consumerName);
1:c808beb:                         
1:8e6446f:                         counsumerStarted.countDown();
1:8e6446f:                         Message msg = null;
1:8e6446f:                         do {
1:8e6446f:                             msg = consumer.receive(5000);
1:8e6446f:                             if (msg != null) {
1:8e6446f:                                 receivedCount.incrementAndGet();
1:19bfd9d:                                 if (received != 0 && received % 100 == 0) {
1:19bfd9d:                                     LOG.info("Received msg: " + msg.getJMSMessageID());
1:19bfd9d:                                 }
1:19bfd9d:                                 if (++received % 2 == 0) {
1:8e6446f:                                     msg.acknowledge();
1:8e6446f:                                     acked++;
1:8e6446f:                                 }
1:8e6446f:                             }
1:8e6446f:                         } while (msg == null);
1:a7533ba: 
1:8e6446f:                         consumerConnection.close();
1:8e6446f:                     }
1:8e6446f:                     assertTrue(received >= acked);
1:8e6446f:                 } catch (Exception e) {
1:8e6446f:                     e.printStackTrace();
1:8e6446f:                     exceptions.add(e);
1:8e6446f:                 }
1:8e6446f:             }
1:8e6446f:         };
1:c808beb:         
1:c808beb:         ExecutorService executor = Executors.newFixedThreadPool(numConsumers);
1:748e419:         
1:8b1e16d:         for (int i = 0; i < numConsumers; i++) {
1:8e6446f:             executor.execute(consumer);
1:8e6446f:         }
1:8e6446f:         
1:8e6446f:         assertTrue(counsumerStarted.await(30, TimeUnit.SECONDS));
1:8e6446f:         
1:8e6446f:         Connection producerConnection = factory.createConnection();
1:8b1e16d:         ((ActiveMQConnection) producerConnection).setWatchTopicAdvisories(false);
1:8e6446f:         Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8e6446f:         Topic topic = producerSession.createTopic(topicName);
1:8e6446f:         MessageProducer producer = producerSession.createProducer(topic);
1:8e6446f:         producerConnection.start();
1:8b1e16d:         for (int i = 0; i < numMessages; i++) {
1:8e6446f:             BytesMessage msg = producerSession.createBytesMessage();
1:8e6446f:             msg.writeBytes(payload);
1:8e6446f:             producer.send(msg);
1:8b1e16d:             if (i != 0 && i % 100 == 0) {
1:8e6446f:                 LOG.info("Sent msg " + i);
1:8e6446f:             }
1:8e6446f:         }
1:29e3702:         
1:8e6446f:         executor.shutdown();
1:8e6446f:         executor.awaitTermination(30, TimeUnit.SECONDS);
1:9caa5c8:         
1:8b1e16d:         Wait.waitFor(new Wait.Condition(){
1:8b1e16d:             public boolean isSatisified() throws Exception{
1:19bfd9d:                 LOG.info("receivedCount: " + receivedCount.get());
1:19bfd9d:                 return receivedCount.get() == numMessages;
1:9caa5c8:             }
1:31ec5ba:         }, 360 * 1000);
1:19bfd9d:         assertEquals("got required some messages", numMessages, receivedCount.get());
1:7a59d28:         assertTrue("no exceptions, but: " + exceptions, exceptions.isEmpty());
1:8e6446f:     }
1:8e6446f:     
1:8b1e16d:     public void testConsumerRecover() throws Exception{
1:101c35b:         doTestConsumer(true);
1:101c35b:     }
1:101c35b:     
1:8b1e16d:     public void testConsumer() throws Exception{
1:101c35b:         doTestConsumer(false);
1:101c35b:     }
1:101c35b: 
1:e35519f:     public void testPrefetchViaBrokerConfig() throws Exception {
1:d20da44: 
1:e35519f:         Integer prefetchVal = new Integer(150);
1:e35519f:         PolicyEntry policyEntry = new PolicyEntry();
1:e35519f:         policyEntry.setDurableTopicPrefetch(prefetchVal.intValue());
1:e35519f:         policyEntry.setPrioritizedMessages(true);
1:e35519f:         PolicyMap policyMap = new PolicyMap();
1:e35519f:         policyMap.setDefaultEntry(policyEntry);
1:e35519f:         broker.setDestinationPolicy(policyMap);
1:d20da44:         broker.start();
1:d20da44: 
1:e35519f:         factory = createConnectionFactory();
1:e35519f:         Connection consumerConnection = factory.createConnection();
1:e35519f:         consumerConnection.setClientID(CONSUMER_NAME);
1:e35519f:         Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:e35519f:         Topic topic = consumerSession.createTopic(getClass().getName());
1:e35519f:         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
1:e35519f:         consumerConnection.start();
1:e35519f: 
1:e35519f:         ObjectName activeSubscriptionObjectName = broker.getAdminView().getDurableTopicSubscribers()[0];
1:e35519f:         Object prefetchFromSubView = broker.getManagementContext().getAttribute(activeSubscriptionObjectName, "PrefetchSize");
1:e35519f:         assertEquals(prefetchVal, prefetchFromSubView);
1:e35519f:     }
1:e35519f:     
1:101c35b:     public void doTestConsumer(boolean forceRecover) throws Exception{
1:8e6446f:         
1:101c35b:         if (forceRecover) {
1:101c35b:             configurePersistence(broker);
1:101c35b:         }
1:101c35b:         broker.start();
1:8e6446f:         
1:9352c9f:         factory = createConnectionFactory();
1:9352c9f:         Connection consumerConnection = factory.createConnection();
1:9352c9f:         consumerConnection.setClientID(CONSUMER_NAME);
1:9352c9f:         Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8b1e16d:         Topic topic = consumerSession.createTopic(getClass().getName());
1:9352c9f:         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
2:9352c9f:         consumerConnection.start();
1:9352c9f:         consumerConnection.close();
1:9dd11cb:         broker.stop();
1:d20da44:         broker = createBroker(false);
1:101c35b:         if (forceRecover) {
1:101c35b:             configurePersistence(broker);
1:101c35b:         }
1:d20da44:         broker.start();
1:8e6446f:         
1:9352c9f:         Connection producerConnection = factory.createConnection();
1:8e6446f:         
1:9352c9f:         Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8e6446f:         
1:9352c9f:         MessageProducer producer = producerSession.createProducer(topic);
1:9352c9f:         producerConnection.start();
1:8b1e16d:         for (int i = 0; i < COUNT; i++) {
1:9352c9f:             BytesMessage msg = producerSession.createBytesMessage();
1:9352c9f:             msg.writeBytes(payload);
1:9352c9f:             producer.send(msg);
1:8b1e16d:             if (i != 0 && i % 1000 == 0) {
1:9352c9f:                 LOG.info("Sent msg " + i);
1:8b1e16d:             }
1:8b1e16d:         }
1:9352c9f:         producerConnection.close();
1:9dd11cb:         broker.stop();
1:d20da44:         broker = createBroker(false);
1:101c35b:         if (forceRecover) {
1:101c35b:             configurePersistence(broker);
1:101c35b:         }
1:d20da44:         broker.start();
1:8e6446f:         
1:9352c9f:         consumerConnection = factory.createConnection();
1:9352c9f:         consumerConnection.setClientID(CONSUMER_NAME);
1:d20da44:         consumerConnection.start();
1:9352c9f:         consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8e6446f:         
1:9352c9f:         consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
1:8b1e16d:         for (int i = 0; i < COUNT; i++) {
1:17cc428:             Message msg = consumer.receive(10000);
1:8b1e16d:             assertNotNull("Missing message: " + i, msg);
1:8b1e16d:             if (i != 0 && i % 1000 == 0) {
1:9352c9f:                 LOG.info("Received msg " + i);
1:8b1e16d:             }
1:8e6446f:             
4:9352c9f:         }
1:9352c9f:         consumerConnection.close();
1:8b1e16d:         
1:9352c9f:     }
1:8b1e16d:     
1:1a5ad28:     @Override
1:8b1e16d:     protected void setUp() throws Exception{
1:9352c9f:         if (broker == null) {
1:d59fd98:             broker = createBroker(true);
1:9352c9f:         }
1:8b1e16d:         
1:9352c9f:         super.setUp();
1:9352c9f:     }
1:8b1e16d:     
1:1a5ad28:     @Override
1:8b1e16d:     protected void tearDown() throws Exception{
1:c808beb:         super.tearDown();
1:9352c9f:         if (broker != null) {
1:9352c9f:             broker.stop();
1:a7533ba:             broker.waitUntilStopped();
1:9352c9f:             broker = null;
1:9352c9f:         }
1:9352c9f:     }
1:8b1e16d:     
1:8b1e16d:     protected Topic creatTopic(Session s,String destinationName) throws JMSException{
1:9352c9f:         return s.createTopic(destinationName);
1:9352c9f:     }
1:8b1e16d:     
1:9352c9f:     /**
1:9352c9f:      * Factory method to create a new broker
1:9352c9f:      * 
1:9352c9f:      * @throws Exception
1:9352c9f:      */
1:8b1e16d:     protected BrokerService createBroker(boolean deleteStore) throws Exception{
1:9352c9f:         BrokerService answer = new BrokerService();
1:8b1e16d:         configureBroker(answer, deleteStore);
1:9352c9f:         return answer;
1:9352c9f:     }
1:8b1e16d:     
1:8b1e16d:     protected void configureBroker(BrokerService answer,boolean deleteStore) throws Exception{
1:d59fd98:         answer.setDeleteAllMessagesOnStartup(deleteStore);
1:8b1e16d:         KahaDBStore kaha = new KahaDBStore();
1:1a5ad28:         //kaha.setConcurrentStoreAndDispatchTopics(false);
1:8b1e16d:         File directory = new File("target/activemq-data/kahadb");
1:8b1e16d:         if (deleteStore) {
1:8b1e16d:             IOHelper.deleteChildren(directory);
1:8b1e16d:         }
1:8b1e16d:         kaha.setDirectory(directory);
1:1a5ad28:         //kaha.setMaxAsyncJobs(10);
1:8b1e16d:         
1:8b1e16d:         answer.setPersistenceAdapter(kaha);
1:9352c9f:         answer.addConnector(bindAddress);
1:52ca2de:         answer.setUseShutdownHook(false);
1:8e6446f:         answer.setAdvisorySupport(false);
1:c808beb:         answer.setDedicatedTaskRunner(useDedicatedTaskRunner);
1:9352c9f:     }
1:8b1e16d:     
1:8b1e16d:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception{
1:c808beb:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(bindAddress);
1:c808beb:         factory.setUseDedicatedTaskRunner(useDedicatedTaskRunner);
1:c808beb:         return factory;
1:9352c9f:     }
3:8b1e16d:     
1:8b1e16d:     public static Test suite(){
1:c808beb:         return suite(DurableConsumerTest.class);
1:c808beb:     }
1:c808beb:     
1:8b1e16d:     public static void main(String[] args){
1:c808beb:         junit.textui.TestRunner.run(suite());
1:c808beb:     }
1:9352c9f: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
1:         broker.waitUntilStarted();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStopped();
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableConsumerTest.class);
commit:31ec5ba
/////////////////////////////////////////////////////////////////////////
1:         }, 360 * 1000);
commit:ecaacd8
/////////////////////////////////////////////////////////////////////////
0:         }, 240 * 1000);
commit:a360742
/////////////////////////////////////////////////////////////////////////
0:         }, 120 * 1000);
commit:5a8d59d
/////////////////////////////////////////////////////////////////////////
0:         for( int i = 0; i < 100; i++ ) {
commit:101c35b
/////////////////////////////////////////////////////////////////////////
0:         for( int i = 0; i < 200; i++ ) {
/////////////////////////////////////////////////////////////////////////
0:     public void testConsumerRecover() throws Exception {
1:     	doTestConsumer(true);
1:     }
1:     
0:     public void testConsumer() throws Exception {
1:     	doTestConsumer(false);
1:     }
1:     
1:     public void doTestConsumer(boolean forceRecover) throws Exception{
1:         if (forceRecover) {
1:             configurePersistence(broker);
1:         }
1:         broker.start();
/////////////////////////////////////////////////////////////////////////
1:         if (forceRecover) {
1:             configurePersistence(broker);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (forceRecover) {
1:             configurePersistence(broker);
1:         }
commit:d20da44
/////////////////////////////////////////////////////////////////////////
0:     private void configurePersistence(BrokerService broker) throws Exception {
0:         File dataDirFile = new File("target/"+ getName());
0:         AMQPersistenceAdapterFactory fact = new AMQPersistenceAdapterFactory();
0:         fact.setDataDirectory(dataDirFile);
0:         fact.setForceRecoverReferenceStore(true);
0:     	broker.setPersistenceAdapter(fact.createPersistenceAdapter());
1:     }
1:     
1:     	configurePersistence(broker);
1:     	broker.start();
1:     	
/////////////////////////////////////////////////////////////////////////
1:         configurePersistence(broker);
1:         broker.start();
1:     	
1:     	broker.start();
1:     	
/////////////////////////////////////////////////////////////////////////
1:     	
1:     	broker.start();
1:     	
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false);
1:         broker.start();
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false);
1:         broker.start();
1:         consumerConnection.start();
/////////////////////////////////////////////////////////////////////////
commit:2e7d219
/////////////////////////////////////////////////////////////////////////
1:             	topic = new ActiveMQTopic(TOPIC_NAME);
1:             	topicConnection = topicConnectionFactory.createTopicConnection();
1:             	topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:             	topicPublisher = topicSession.createPublisher(topic);
1:             	message = topicSession.createMessage();
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(10000);
commit:29e3702
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.DeliveryMode;
1: import javax.jms.ExceptionListener;
1: import javax.jms.MessageListener;
1: import javax.jms.TopicConnection;
1: import javax.jms.TopicConnectionFactory;
1: import javax.jms.TopicPublisher;
1: import javax.jms.TopicSession;
1: import javax.jms.TopicSubscriber;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapterFactory;
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static final String TOPIC_NAME = "failoverTopic";
1:     private static final String CONNECTION_URL = "failover:(tcp://localhost:61616,tcp://localhost:61617)";
1:     
0:     private class SimpleTopicSubscriber implements MessageListener, ExceptionListener {
1: 
1:         private TopicConnection topicConnection = null;
0:         private String clientId;
1: 
0:         public SimpleTopicSubscriber(String connectionURL, String clientId, String topicName) {
1: 
1:             ActiveMQConnectionFactory topicConnectionFactory = null;
1:             TopicSession topicSession = null;
1:             Topic topic = null;
1:             TopicSubscriber topicSubscriber = null;
1:             
1: 
1:             topicConnectionFactory = new ActiveMQConnectionFactory(connectionURL);
1:             try {
1: 
1:                 topic = new ActiveMQTopic(topicName);
1:                 topicConnection = topicConnectionFactory.createTopicConnection();
1:                 topicConnection.setClientID((clientId));
1:                 topicConnection.start();
1: 
1:                 topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 topicSubscriber = topicSession.createDurableSubscriber(topic, (clientId));
0:                 this.clientId = clientId;
1:                 topicSubscriber.setMessageListener(this);
1: 
1:             } catch (JMSException e) {
1:             	e.printStackTrace();
1:             }
1:         }
1: 
0:         public void onMessage(Message arg0) {
1:         }
1: 
0:         public void closeConnection() {
1:             if (topicConnection != null) {
1:                 try {
1:                     topicConnection.close();
1:                 } catch (JMSException e) {
1:                 }
1:             }
1:         }
1: 
0: 		public void onException(JMSException exception) {
1: 			exceptions.add(exception);
1: 		}
1:     }   
1:     
0:     private class MessagePublisher implements Runnable {
0:         private boolean shouldPublish = true;
1: 
0:         public void run() {
1:             TopicConnectionFactory topicConnectionFactory = null;
1:             TopicConnection topicConnection = null;
1:             TopicSession topicSession = null;
1:             Topic topic = null;
1:             TopicPublisher topicPublisher = null;
1:             Message message = null;
1: 
1: 
1:             topicConnectionFactory = new ActiveMQConnectionFactory(CONNECTION_URL);
1:             try {
0:             topic = new ActiveMQTopic(TOPIC_NAME);
1:             topicConnection = topicConnectionFactory.createTopicConnection();
1:             topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
0:             topicPublisher = topicSession.createPublisher(topic);
0:             message = topicSession.createMessage();
0:             } catch( Exception ex ) {
1:             	exceptions.add(ex);
1:             }
1:             while (shouldPublish) {
1:                 try {
1:                     topicPublisher.publish(message, DeliveryMode.PERSISTENT, 1, 2 * 60 * 60 * 1000);
1:                 } catch (JMSException ex) {
1:                 	exceptions.add(ex);
1:                 }
1:                 try {
1:                     Thread.sleep(1);
1:                 } catch (Exception ex) {
1:                 }
1:             }
1:         }
1:     }
1:     
0:     public void testFailover() throws Exception {
1:         
0:     	Thread publisherThread = new Thread( new MessagePublisher() );
1:         publisherThread.start();
1:         
0:         for( int i = 0; i < 100; i++ ) {
1:             
1:             final int id = i;
0:             Thread thread = new Thread( new Runnable() {
0:                 public void run() {
1:                     
0:                     SimpleTopicSubscriber sub = new SimpleTopicSubscriber(CONNECTION_URL, System.currentTimeMillis()+"-"+id, TOPIC_NAME);
1:                 }
0:             } );
1:             thread.start();
1:             
0:             LOG.info( "subscribed " + i + " of 100" );
1:         }
1: 
0:         Thread.sleep(5000);
1:         broker.stop();
1:         broker = createBroker(false);
0:         Thread.sleep(5000);
0:         assertEquals(0, exceptions.size());
1:     }
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:         File dataDirFile = new File("target/"+ getName());
0:         AMQPersistenceAdapterFactory fact = new AMQPersistenceAdapterFactory();
0:         fact.setDataDirectory(dataDirFile);
0:         fact.setForceRecoverReferenceStore(true);
0:     	answer.setPersistenceAdapter(fact.createPersistenceAdapter());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
/////////////////////////////////////////////////////////////////////////
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  *  A Test case for AMQ-1479
commit:bcacddf
/////////////////////////////////////////////////////////////////////////
0:             Message msg =  consumer.receive(5000);            
0:             assertNotNull("Missing message: "+i, msg);
commit:5e3aa21
/////////////////////////////////////////////////////////////////////////
0:     private static int COUNT = 1024*10;
author:Gary Tully
-------------------------------------------------------------------------------
commit:ac54a61
/////////////////////////////////////////////////////////////////////////
1:         final int numSubs = 100;
1:         final List<SimpleTopicSubscriber> list = new ArrayList<SimpleTopicSubscriber>(numSubs);
1:         for (int i = 0; i < numSubs; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         Wait.waitFor(new Wait.Condition(){
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return numSubs == list.size();
1:             }
1:         });
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
commit:c709527
/////////////////////////////////////////////////////////////////////////
1:     private static int COUNT = 1024;
commit:cf33916
/////////////////////////////////////////////////////////////////////////
0:     private static int COUNT = 1024 * 10;
commit:383a7ac
/////////////////////////////////////////////////////////////////////////
0:     private static int COUNT = 1024 * 60;
commit:e35519f
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
0: import org.apache.activemq.broker.jmx.BrokerView;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testPrefetchViaBrokerConfig() throws Exception {
1: 
1:         Integer prefetchVal = new Integer(150);
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setDurableTopicPrefetch(prefetchVal.intValue());
1:         policyEntry.setPrioritizedMessages(true);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(policyEntry);
1:         broker.setDestinationPolicy(policyMap);
0:         broker.start();
1: 
1:         factory = createConnectionFactory();
1:         Connection consumerConnection = factory.createConnection();
1:         consumerConnection.setClientID(CONSUMER_NAME);
1:         Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = consumerSession.createTopic(getClass().getName());
1:         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
1:         consumerConnection.start();
1: 
1:         ObjectName activeSubscriptionObjectName = broker.getAdminView().getDurableTopicSubscribers()[0];
1:         Object prefetchFromSubView = broker.getManagementContext().getAttribute(activeSubscriptionObjectName, "PrefetchSize");
1:         assertEquals(prefetchVal, prefetchFromSubView);
1:     }
/////////////////////////////////////////////////////////////////////////
commit:17cc428
/////////////////////////////////////////////////////////////////////////
1:             Message msg = consumer.receive(10000);
commit:19bfd9d
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch counsumerStarted = new CountDownLatch(numConsumers);
/////////////////////////////////////////////////////////////////////////
1:                                 if (received != 0 && received % 100 == 0) {
1:                                     LOG.info("Received msg: " + msg.getJMSMessageID());
1:                                 }
1:                                 if (++received % 2 == 0) {
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("receivedCount: " + receivedCount.get());
1:                 return receivedCount.get() == numMessages;
1:         assertEquals("got required some messages", numMessages, receivedCount.get());
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.activemq.CombinationTestSupport;
0: import org.apache.activemq.util.ThreadTracker;
/////////////////////////////////////////////////////////////////////////
0: public class DurableConsumerTest extends CombinationTestSupport {
/////////////////////////////////////////////////////////////////////////
1:     public boolean useDedicatedTaskRunner = false;
1:        
/////////////////////////////////////////////////////////////////////////
0:                     new SimpleTopicSubscriber(CONNECTION_URL, System.currentTimeMillis()+"-"+id, TOPIC_NAME);
/////////////////////////////////////////////////////////////////////////
1:     
1:     // makes heavy use of threads and can demonstrate https://issues.apache.org/activemq/browse/AMQ-2028
1:     // with use dedicatedTaskRunner=true and produce OOM
0:     public void initCombosForTestConcurrentDurableConsumer() {
0:         addCombinationValues("useDedicatedTaskRunner", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         ExecutorService executor = Executors.newFixedThreadPool(numConsumers);
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();      
/////////////////////////////////////////////////////////////////////////
1:         answer.setDedicatedTaskRunner(useDedicatedTaskRunner);
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(bindAddress);
1:         factory.setUseDedicatedTaskRunner(useDedicatedTaskRunner);
1:         return factory;
0:     public static Test suite() {
1:         return suite(DurableConsumerTest.class);
1:     }
1: 
0:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
commit:748e419
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         }, 60*1000);
commit:9caa5c8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:         
0:         Wait.waitFor(new Wait.Condition() {
0:             public boolean isSatisified() throws Exception {
0:                 return receivedCount.get() > numMessages;
1:             } 
1:         });
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("no exceptions, but: " + exceptions, exceptions.isEmpty());
commit:8e6446f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
/////////////////////////////////////////////////////////////////////////
0:     protected byte[] payload = new byte[1024*32];
1:     protected Vector<Exception> exceptions = new Vector<Exception>();
0:     public void testConcurrentDurableConsumer() throws Exception {
1:         factory = createConnectionFactory();
1:         final String topicName = getName();
1:         final int numMessages = 500;
0:         int numConsumers = 20;
0:         final CountDownLatch counsumerStarted = new CountDownLatch(0);
1:         final AtomicInteger receivedCount = new AtomicInteger();
0:         Runnable consumer = new Runnable() {
0:             public void run() {
1:                 final String consumerName = Thread.currentThread().getName();
1:                 int acked = 0;
1:                 int received = 0;
1:                 
1: 
1:                 try {
0:                     while (acked < numMessages/2) {
1:                         // take one message and close, ack on occasion
1:                         Connection consumerConnection = factory.createConnection();
0:                         ((ActiveMQConnection)consumerConnection).setWatchTopicAdvisories(false);
1:                         consumerConnection.setClientID(consumerName);
0:                         Session consumerSession = consumerConnection.createSession(false,
0:                                         Session.CLIENT_ACKNOWLEDGE);
1:                         Topic topic = consumerSession.createTopic(topicName);
1:                         consumerConnection.start();
1:                         
0:                         MessageConsumer consumer = consumerSession
0:                                 .createDurableSubscriber(topic, consumerName);
1:                        
1:                         counsumerStarted.countDown();
1:                         Message msg = null;
1:                         do {
1:                             msg = consumer.receive(5000);
1:                             if (msg != null) {
1:                                 receivedCount.incrementAndGet();
0:                                 if (received++ % 2 == 0) {
1:                                     msg.acknowledge();
1:                                     acked++;
1:                                 }
1:                             }
1:                         } while (msg == null);
1: 
1:                         consumerConnection.close();
1:                     }
1:                     assertTrue(received >= acked);
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     exceptions.add(e);
1:                 }
1:             }
1:         };
1:         
0:         ExecutorService executor = Executors.newCachedThreadPool();
1: 
0:         for (int i=0; i<numConsumers ; i++) {
1:             executor.execute(consumer);
1:         }
1: 
1:         assertTrue(counsumerStarted.await(30, TimeUnit.SECONDS));
1:         
1:         Connection producerConnection = factory.createConnection();
0:         ((ActiveMQConnection)producerConnection).setWatchTopicAdvisories(false);
1:         Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = producerSession.createTopic(topicName);
1:         MessageProducer producer = producerSession.createProducer(topic);
1:         producerConnection.start();
0:         for (int i =0; i < numMessages; i++) {
1:             BytesMessage msg = producerSession.createBytesMessage();
1:             msg.writeBytes(payload);
1:             producer.send(msg);
0:             if (i != 0 && i%100==0) {
1:                 LOG.info("Sent msg " + i);
1:             }
1:         }
1: 
0:         Thread.sleep(2000);
1:         executor.shutdown();
1:         executor.awaitTermination(30, TimeUnit.SECONDS);
0:         assertTrue("got some messages: " + receivedCount.get(), receivedCount.get() > numMessages);
0:         assertTrue(exceptions.isEmpty());
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         answer.setUseJmx(false);
1:         answer.setAdvisorySupport(false);
author:Robert Davies
-------------------------------------------------------------------------------
commit:dd48ebe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:         KahaDBPersistenceAdapter kahaDBAdapter = new KahaDBPersistenceAdapter();
1:         kahaDBAdapter.setDirectory(dataDirFile);
1:         broker.setPersistenceAdapter(kahaDBAdapter);
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private final boolean shouldPublish = true;
/////////////////////////////////////////////////////////////////////////
0:         final List<SimpleTopicSubscriber> list = new ArrayList<SimpleTopicSubscriber>();
1:                     SimpleTopicSubscriber s =new SimpleTopicSubscriber(CONNECTION_URL, System.currentTimeMillis() + "-" + id, TOPIC_NAME);
1:                     list.add(s);
/////////////////////////////////////////////////////////////////////////
1:         for (SimpleTopicSubscriber s:list) {
1:             s.closeConnection();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         //kaha.setConcurrentStoreAndDispatchTopics(false);
1:         //kaha.setMaxAsyncJobs(10);
commit:8b1e16d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBStore;
1: import org.apache.activemq.util.IOHelper;
0:  * @version $Revision: 1.5 $ A Test case for AMQ-1479
1: public class DurableConsumerTest extends CombinationTestSupport{
0:     private static int COUNT = 1024 * 10;
1:     protected String bindAddress = "tcp://localhost:61616";
1:     
1:     protected byte[] payload = new byte[1024 * 32];
1:     
1:     private class SimpleTopicSubscriber implements MessageListener,ExceptionListener{
1:         
1:         public SimpleTopicSubscriber(String connectionURL,String clientId,String topicName) {
1:             
1:                 
1:                 
1:                 
0:                 e.printStackTrace();
1:         
1:         public void onMessage(Message arg0){
1:         
1:         public void closeConnection(){
/////////////////////////////////////////////////////////////////////////
1:         
1:         public void onException(JMSException exception){
0:             exceptions.add(exception);
1:         }
1:     }
1:     private class MessagePublisher implements Runnable{
1:         
1:         public void run(){
1:             
0:                 topic = new ActiveMQTopic(TOPIC_NAME);
0:                 topicConnection = topicConnectionFactory.createTopicConnection();
0:                 topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
0:                 topicPublisher = topicSession.createPublisher(topic);
0:                 message = topicSession.createMessage();
1:             } catch (Exception ex) {
0:                 exceptions.add(ex);
0:                     exceptions.add(ex);
/////////////////////////////////////////////////////////////////////////
1:     private void configurePersistence(BrokerService broker) throws Exception{
1:         File dataDirFile = new File("target/" + getName());
0:         broker.setPersistenceAdapter(fact.createPersistenceAdapter());
1:     public void testFailover() throws Exception{
0:         configurePersistence(broker);
0:         broker.start();
0:         
1:         Thread publisherThread = new Thread(new MessagePublisher());
0:         for (int i = 0; i < 100; i++) {
1:             Thread thread = new Thread(new Runnable(){
1:                 public void run(){
0:                     new SimpleTopicSubscriber(CONNECTION_URL, System.currentTimeMillis() + "-" + id, TOPIC_NAME);
0:             });
0:         
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestConcurrentDurableConsumer(){
1:         addCombinationValues("useDedicatedTaskRunner", new Object[] { Boolean.TRUE, Boolean.FALSE });
1:     public void testConcurrentDurableConsumer() throws Exception{
0:         
0:         broker.start();
0:         
1:         int numConsumers = 1;
1:         Runnable consumer = new Runnable(){
1:             public void run(){
1:                     while (acked < numMessages / 2) {
1:                         ((ActiveMQConnection) consumerConnection).setWatchTopicAdvisories(false);
1:                         Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, consumerName);
0:                         
/////////////////////////////////////////////////////////////////////////
0:                         
/////////////////////////////////////////////////////////////////////////
0:         
1:         for (int i = 0; i < numConsumers; i++) {
0:         
1:         ((ActiveMQConnection) producerConnection).setWatchTopicAdvisories(false);
1:         for (int i = 0; i < numMessages; i++) {
1:             if (i != 0 && i % 100 == 0) {
/////////////////////////////////////////////////////////////////////////
1:         Wait.waitFor(new Wait.Condition(){
1:             public boolean isSatisified() throws Exception{
1:             }
0:         }, 60 * 1000);
1:     public void testConsumerRecover() throws Exception{
0:         doTestConsumer(true);
1:     public void testConsumer() throws Exception{
0:         doTestConsumer(false);
0:         
0:         
1:         Topic topic = consumerSession.createTopic(getClass().getName());
/////////////////////////////////////////////////////////////////////////
0:         
1:         for (int i = 0; i < COUNT; i++) {
1:             if (i != 0 && i % 1000 == 0) {
/////////////////////////////////////////////////////////////////////////
0:         
1:         for (int i = 0; i < COUNT; i++) {
0:             Message msg = consumer.receive(5000);
1:             assertNotNull("Missing message: " + i, msg);
1:             if (i != 0 && i % 1000 == 0) {
1:     protected void setUp() throws Exception{
0:         
0:     
1:     protected void tearDown() throws Exception{
0:         super.tearDown();
0:     
1:     protected Topic creatTopic(Session s,String destinationName) throws JMSException{
0:     
1:     protected BrokerService createBroker(boolean deleteStore) throws Exception{
1:         configureBroker(answer, deleteStore);
1:     protected void configureBroker(BrokerService answer,boolean deleteStore) throws Exception{
1:         KahaDBStore kaha = new KahaDBStore();
1:         File directory = new File("target/activemq-data/kahadb");
1:         if (deleteStore) {
1:             IOHelper.deleteChildren(directory);
1:         }
1:         kaha.setDirectory(directory);
0:         
1:         answer.setPersistenceAdapter(kaha);
0:     
1:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception{
0:     
1:     public static Test suite(){
0:     
1:     public static void main(String[] args){
commit:52ca2de
/////////////////////////////////////////////////////////////////////////
1:         answer.setUseShutdownHook(false);
commit:8f190f1
/////////////////////////////////////////////////////////////////////////
0:             Message msg =  consumer.receive(5000);
commit:d59fd98
/////////////////////////////////////////////////////////////////////////
0:         broker =createBroker(false);
/////////////////////////////////////////////////////////////////////////
0:         broker =createBroker(false);
/////////////////////////////////////////////////////////////////////////
1:             broker = createBroker(true);
/////////////////////////////////////////////////////////////////////////
0:     protected BrokerService createBroker(boolean deleteStore) throws Exception {
0:         configureBroker(answer,deleteStore);
0:     protected void configureBroker(BrokerService answer,boolean deleteStore) throws Exception {
1:         answer.setDeleteAllMessagesOnStartup(deleteStore);
0:         answer.setUseShutdownHook(true);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
1:         broker.stop();
0:         broker =createBroker();
/////////////////////////////////////////////////////////////////////////
1:         broker.stop();
0:         broker =createBroker();
commit:9352c9f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
0: 
1: import javax.jms.BytesMessage;
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.Topic;
0: 
0: import junit.framework.TestCase;
0: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
1: /**
0:  * @version $Revision: 1.5 $
0:  * A Test case for AMQ-1479
1:  */
0: public class DurableConsumerTest extends TestCase {
0:     private static final Log LOG = LogFactory.getLog(DurableConsumerTest.class);
0:     private static int COUNT = 1024*100;
1:     private static String CONSUMER_NAME = "DURABLE_TEST";
1:     protected BrokerService broker;
0:    
0:     protected String bindAddress="tcp://localhost:61616";
0:   
0:     
0:    
0:     
0:   
0:     protected byte[] payload = new byte[1024*16];
1:     protected ConnectionFactory factory;
0:    
0:   
0:     
0:     public void testConsumer() throws Exception{
1:         factory = createConnectionFactory();
1:         Connection consumerConnection = factory.createConnection();
1:         consumerConnection.setClientID(CONSUMER_NAME);
1:         Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Topic topic  = consumerSession.createTopic(getClass().getName());
1:         MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
1:         consumerConnection.start();
1:         consumerConnection.close();
0:         
1:         Connection producerConnection = factory.createConnection();
0:        
1:         Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         
1:         MessageProducer producer = producerSession.createProducer(topic);
1:         producerConnection.start();
0:         for (int i =0; i < COUNT;i++) {
1:             BytesMessage msg = producerSession.createBytesMessage();
1:             msg.writeBytes(payload);
1:             producer.send(msg);
0:             if (i != 0 && i%1000==0) {
1:                 LOG.info("Sent msg " + i);
1:             }
1:         }
1:         producerConnection.close();
0:         
0:         
1:         consumerConnection = factory.createConnection();
1:         consumerConnection.setClientID(CONSUMER_NAME);
1:         consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:        
1:         consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);
1:         consumerConnection.start();
0:         for (int i =0; i < COUNT;i++) {
0:             Message msg =  consumer.receive(1000);
0:             assertNotNull(msg);
0:             if (i != 0 && i%1000==0) {
1:                 LOG.info("Received msg " + i);
1:             }
0:             
1:         }
1:         consumerConnection.close();
0:         
0:         
1:     }
0:     
0:     protected void setUp() throws Exception {
1:         if (broker == null) {
0:             broker = createBroker();
1:         }
0:         
0:        
0:        
1:         super.setUp();
1:     }
0: 
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         
1:         if (broker != null) {
1:             broker.stop();
1:             broker = null;
1:         }
1:     }
0: 
0:     protected Topic creatTopic(Session s, String destinationName) throws JMSException {
1:         return s.createTopic(destinationName);
1:     }
0: 
1:     /**
1:      * Factory method to create a new broker
1:      * 
1:      * @throws Exception
1:      */
0:     protected BrokerService createBroker() throws Exception {
1:         BrokerService answer = new BrokerService();
0:         configureBroker(answer);
0:         answer.start();
1:         return answer;
1:     }
0: 
0:     
0: 
0:     protected void configureBroker(BrokerService answer) throws Exception {
1:         answer.addConnector(bindAddress);
0:         answer.setDeleteAllMessagesOnStartup(true);
0:         answer.setUseShutdownHook(false);
1:     }
0: 
0:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
0:         return new ActiveMQConnectionFactory(bindAddress);
1:     }
0: 
0:    
1: }
============================================================================