1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:fc00993:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:d65ba80: 
1:18d616c: import java.io.IOException;
1:846cf7d: import java.util.ArrayList;
1:fd37e8c: import java.util.Collections;
1:3039b67: import java.util.List;
1:86cbdfd: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:6aacb03: import java.util.concurrent.atomic.AtomicBoolean;
1:6f70393: import java.util.concurrent.atomic.AtomicLong;
1:9ef4259: 
1:18d616c: import javax.jms.InvalidSelectorException;
1:83c3dca: import javax.jms.JMSException;
1:18d616c: 
1:4098942: import org.apache.activemq.broker.Broker;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:6aaf859: import org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor;
1:6519c3e: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1:0c0be94: import org.apache.activemq.broker.region.cursors.StoreDurableSubscriberCursor;
1:8dc1c12: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:933eb2f: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageDispatch;
1:933eb2f: import org.apache.activemq.command.MessageId;
1:83c3dca: import org.apache.activemq.store.TopicMessageStore;
1:83c3dca: import org.apache.activemq.usage.SystemUsage;
1:6d8e2c5: import org.apache.activemq.usage.Usage;
1:6d8e2c5: import org.apache.activemq.usage.UsageListener;
1:0f502fa: import org.apache.activemq.util.SubscriptionKey;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
21:d29ca2a: 
1:230a86c: public class DurableTopicSubscription extends PrefetchSubscription implements UsageListener {
1:d29ca2a: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DurableTopicSubscription.class);
1:9ef4259:     private final ConcurrentMap<MessageId, Integer> redeliveredMessages = new ConcurrentHashMap<MessageId, Integer>();
1:9ef4259:     private final ConcurrentMap<ActiveMQDestination, Destination> durableDestinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
1:0f502fa:     private final SubscriptionKey subscriptionKey;
1:7a68ad5:     private boolean keepDurableSubsActive;
1:21b2f84:     private final AtomicBoolean active = new AtomicBoolean();
1:21b2f84:     private final AtomicLong offlineTimestamp = new AtomicLong(-1);
1:d29ca2a: 
1:16f2d75:     public DurableTopicSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive)
1:8dc1c12:             throws JMSException {
1:8dc1c12:         super(broker, usageManager, context, info);
1:8dc1c12:         this.pending = new StoreDurableSubscriberCursor(broker, context.getClientId(), info.getSubscriptionName(), info.getPrefetchSize(), this);
1:9dd11cb:         this.pending.setSystemUsage(usageManager);
1:785454a:         this.pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:230a86c:         this.keepDurableSubsActive = keepDurableSubsActive;
1:230a86c:         subscriptionKey = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
2:d29ca2a:     }
1:bb17d61: 
1:3ddb71c:     public final boolean isActive() {
1:6aacb03:         return active.get();
1:566039f:     }
1:3a5b48a: 
1:6f70393:     public final long getOfflineTimestamp() {
1:6f70393:         return offlineTimestamp.get();
1:6f70393:     }
1:6f70393: 
1:566039f:     public void setOfflineTimestamp(long timestamp) {
1:566039f:         offlineTimestamp.set(timestamp);
1:566039f:     }
1:566039f: 
1:21b2f84:     @Override
1:d4382e4:     public boolean isFull() {
1:6aacb03:         return !active.get() || super.isFull();
1:566039f:     }
1:3a5b48a: 
1:21b2f84:     @Override
1:2db7df7:     public void gc() {
1:d65ba80:     }
1:c46562b: 
1:306f8a0:     /**
1:8dc1c12:      * store will have a pending ack for all durables, irrespective of the
1:8dc1c12:      * selector so we need to ack if node is un-matched
1:306f8a0:      */
1:21b2f84:     @Override
1:306f8a0:     public void unmatched(MessageReference node) throws IOException {
1:306f8a0:         MessageAck ack = new MessageAck();
1:3432a75:         ack.setAckType(MessageAck.UNMATCHED_ACK_TYPE);
1:306f8a0:         ack.setMessageID(node.getMessageId());
1:9a8f6e4:         Destination regionDestination = (Destination) node.getRegionDestination();
1:9a8f6e4:         regionDestination.acknowledge(this.getContext(), this, ack, node);
1:0f502fa:     }
1:c46562b: 
1:21b2f84:     @Override
1:6519c3e:     protected void setPendingBatchSize(PendingMessageCursor pending, int numberToDispatch) {
1:6519c3e:         // statically configured via maxPageSize
1:0f502fa:     }
1:0f502fa: 
1:21b2f84:     @Override
1:2db7df7:     public void add(ConnectionContext context, Destination destination) throws Exception {
1:caca105:         if (!destinations.contains(destination)) {
1:bb17d61:             super.add(context, destination);
1:0f502fa:         }
1:9c47f6b:         // do it just once per destination
1:caca105:         if (durableDestinations.containsKey(destination.getActiveMQDestination())) {
1:9c47f6b:             return;
1:9c47f6b:         }
1:caca105:         durableDestinations.put(destination.getActiveMQDestination(), destination);
1:0f502fa: 
1:93e2bd3:         if (active.get() || keepDurableSubsActive) {
1:8dc1c12:             Topic topic = (Topic) destination;
1:230a86c:             topic.activate(context, this);
1:eece576:             getSubscriptionStatistics().getEnqueues().add(pending.size());
1:93e2bd3:         } else if (destination.getMessageStore() != null) {
1:8dc1c12:             TopicMessageStore store = (TopicMessageStore) destination.getMessageStore();
1:16f2d75:             try {
1:eece576:                 getSubscriptionStatistics().getEnqueues().add(store.getMessageCount(subscriptionKey.getClientId(), subscriptionKey.getSubscriptionName()));
1:16f2d75:             } catch (IOException e) {
1:8dc1c12:                 JMSException jmsEx = new JMSException("Failed to retrieve enqueueCount from store " + e);
1:16f2d75:                 jmsEx.setLinkedException(e);
1:16f2d75:                 throw jmsEx;
1:449981b:             }
1:0f502fa:         }
1:2db7df7:         dispatchPending();
1:0f502fa:     }
1:0f502fa: 
1:42ad103:     // used by RetaineMessageSubscriptionRecoveryPolicy
1:42ad103:     public boolean isEmpty(Topic topic) {
1:42ad103:         return pending.isEmpty(topic);
1:42ad103:     }
1:42ad103: 
1:8dc1c12:     public void activate(SystemUsage memoryManager, ConnectionContext context, ConsumerInfo info, RegionBroker regionBroker) throws Exception {
1:6aacb03:         if (!active.get()) {
1:230a86c:             this.context = context;
1:230a86c:             this.info = info;
1:8dc1c12: 
1:e1bbde7:             LOG.debug("Activating {}", this);
1:230a86c:             if (!keepDurableSubsActive) {
1:a7533ba:                 for (Destination destination : durableDestinations.values()) {
1:a7533ba:                     Topic topic = (Topic) destination;
1:9fcf16e:                     add(context, topic);
1:230a86c:                     topic.activate(context, this);
1:230a86c:                 }
1:21b2f84: 
1:21b2f84:                 // On Activation we should update the configuration based on our new consumer info.
1:21b2f84:                 ActiveMQDestination dest = this.info.getDestination();
1:21b2f84:                 if (dest != null && regionBroker.getDestinationPolicy() != null) {
1:21b2f84:                     PolicyEntry entry = regionBroker.getDestinationPolicy().getEntryFor(dest);
1:21b2f84:                     if (entry != null) {
1:21b2f84:                         entry.configure(broker, usageManager, this);
1:21b2f84:                     }
1:21b2f84:                 }
1:8dc1c12:             }
1:21b2f84: 
1:cb96783:             synchronized (pendingLock) {
1:6aaf859:                 if (!((AbstractPendingMessageCursor) pending).isStarted() || !keepDurableSubsActive) {
1:a7533ba:                     pending.setSystemUsage(memoryManager);
1:a7533ba:                     pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:a7533ba:                     pending.setMaxAuditDepth(getMaxAuditDepth());
1:a7533ba:                     pending.setMaxProducersToAudit(getMaxProducersToAudit());
1:a7533ba:                     pending.start();
1:6c85967:                 }
1:6c85967:                 // use recovery policy every time sub is activated for retroactive topics and consumers
1:6c85967:                 for (Destination destination : durableDestinations.values()) {
1:6c85967:                     Topic topic = (Topic) destination;
1:6c85967:                     if (topic.isAlwaysRetroactive() || info.isRetroactive()) {
1:6c85967:                         topic.recoverRetroactiveMessages(context, this);
1:78950ec:                     }
1:78950ec:                 }
1:a7533ba:             }
1:6aacb03:             this.active.set(true);
1:6f70393:             this.offlineTimestamp.set(-1);
1:2db7df7:             dispatchPending();
1:6d8e2c5:             this.usageManager.getMemoryUsage().addUsageListener(this);
1:8dc1c12:         }
1:449981b:     }
1:8dc1c12: 
1:dbb1d8b:     public void deactivate(boolean keepDurableSubsActive, long lastDeliveredSequenceId) throws Exception {
1:e1bbde7:         LOG.debug("Deactivating keepActive={}, {}", keepDurableSubsActive, this);
1:6aacb03:         active.set(false);
1:7a68ad5:         this.keepDurableSubsActive = keepDurableSubsActive;
1:6f70393:         offlineTimestamp.set(System.currentTimeMillis());
1:7a68ad5:         usageManager.getMemoryUsage().removeUsageListener(this);
1:846cf7d: 
1:846cf7d:         ArrayList<Topic> topicsToDeactivate = new ArrayList<Topic>();
1:3039b67:         List<MessageReference> savedDispateched = null;
1:3039b67: 
1:6b4d077:         synchronized (pendingLock) {
1:a7533ba:             if (!keepDurableSubsActive) {
1:a7533ba:                 pending.stop();
1:a7533ba:             }
1:230a86c: 
1:6b4d077:             synchronized (dispatchLock) {
1:8947a09:                 for (Destination destination : durableDestinations.values()) {
1:8947a09:                     Topic topic = (Topic) destination;
2:230a86c:                     if (!keepDurableSubsActive) {
1:846cf7d:                         topicsToDeactivate.add(topic);
2:230a86c:                     } else {
1:6b4d077:                         topic.getDestinationStatistics().getInflight().subtract(dispatched.size());
1:449981b:                     }
1:0f502fa:                 }
1:3a5b48a: 
1:fd37e8c:                 // Before we add these back to pending they need to be in producer order not
1:fd37e8c:                 // dispatch order so we can add them to the front of the pending list.
1:fd37e8c:                 Collections.reverse(dispatched);
1:fd37e8c: 
1:6b4d077:                 for (final MessageReference node : dispatched) {
1:0f502fa:                     // Mark the dispatched messages as redelivered for next time.
1:dbb1d8b:                     if (lastDeliveredSequenceId == 0 || (lastDeliveredSequenceId > 0 && node.getMessageId().getBrokerSequenceId() <= lastDeliveredSequenceId)) {
1:dbb1d8b:                         Integer count = redeliveredMessages.get(node.getMessageId());
1:dbb1d8b:                         if (count != null) {
1:dbb1d8b:                             redeliveredMessages.put(node.getMessageId(), Integer.valueOf(count.intValue() + 1));
1:dbb1d8b:                         } else {
1:dbb1d8b:                             redeliveredMessages.put(node.getMessageId(), Integer.valueOf(1));
1:dbb1d8b:                         }
1:0f502fa:                     }
1:6b4d077:                     if (keepDurableSubsActive && pending.isTransient()) {
1:6b4d077:                         pending.addMessageFirst(node);
1:6b4d077:                         pending.rollback(node.getMessageId());
1:013f372:                     }
1:1ad0117:                     // createMessageDispatch increments on remove from pending for dispatch
1:1ad0117:                     node.decrementReferenceCount();
1:d65ba80:                 }
1:fd37e8c: 
1:3039b67:                 if (!topicsToDeactivate.isEmpty()) {
1:3039b67:                     savedDispateched = new ArrayList<MessageReference>(dispatched);
1:3039b67:                 }
1:6b4d077:                 dispatched.clear();
1:4605503:                 getSubscriptionStatistics().getInflightMessageSize().reset();
1:d65ba80:             }
1:6b4d077:             if (!keepDurableSubsActive && pending.isTransient()) {
1:230a86c:                 try {
1:ec63977:                     pending.reset();
1:230a86c:                     while (pending.hasNext()) {
1:230a86c:                         MessageReference node = pending.next();
1:d65ba80:                         node.decrementReferenceCount();
1:ec63977:                         pending.remove();
1:18d616c:                     }
1:230a86c:                 } finally {
1:ec63977:                     pending.release();
1:18d616c:                 }
1:18d616c:             }
1:013f372:         }
1:846cf7d:         for(Topic topic: topicsToDeactivate) {
1:3039b67:             topic.deactivate(context, this, savedDispateched);
1:846cf7d:         }
1:3a5b48a:         prefetchExtension.set(0);
1:d29ca2a:     }
1:3a5b48a: 
1:21b2f84:     @Override
1:230a86c:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
1:230a86c:         MessageDispatch md = super.createMessageDispatch(node, message);
1:fe31092:         if (node != QueueMessageReference.NULL_MESSAGE) {
1:1ad0117:             node.incrementReferenceCount();
1:933eb2f:             Integer count = redeliveredMessages.get(node.getMessageId());
2:230a86c:             if (count != null) {
1:d29ca2a:                 md.setRedeliveryCounter(count.intValue());
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return md;
1:d29ca2a:     }
1:18d616c: 
1:21b2f84:     @Override
1:2db7df7:     public void add(MessageReference node) throws Exception {
1:6aacb03:         if (!active.get() && !keepDurableSubsActive) {
1:8dc1c12:             return;
1:d29ca2a:         }
1:d29ca2a:         super.add(node);
1:d29ca2a:     }
1:0f502fa: 
1:21b2f84:     @Override
1:6c85967:     public void dispatchPending() throws IOException {
1:3ddb71c:         if (isActive()) {
1:3ddb71c:             super.dispatchPending();
1:d29ca2a:         }
1:d29ca2a:     }
1:ed3f61a: 
1:ed3f61a:     public void removePending(MessageReference node) throws IOException {
1:ed3f61a:         pending.remove(node);
1:ed3f61a:     }
1:3a5b48a: 
1:21b2f84:     @Override
1:2db7df7:     protected void doAddRecoveredMessage(MessageReference message) throws Exception {
1:8dc1c12:         synchronized (pending) {
1:e45bb06:             pending.addRecoveredMessage(message);
1:d29ca2a:         }
1:d29ca2a:     }
1:013f372: 
1:21b2f84:     @Override
1:449981b:     public int getPendingQueueSize() {
1:6aacb03:         if (active.get() || keepDurableSubsActive) {
1:07d4e8c:             return super.getPendingQueueSize();
1:d29ca2a:         }
1:8de60cf:         // TODO: need to get from store
1:3601e81:         return 0;
1:d29ca2a:     }
1:449981b: 
1:21b2f84:     @Override
1:230a86c:     public void setSelector(String selector) throws InvalidSelectorException {
1:81b4b9a:         if (active.get()) {
1:81b4b9a:             throw new UnsupportedOperationException("You cannot dynamically change the selector for durable topic subscriptions");
1:81b4b9a:         } else {
1:81b4b9a:             super.setSelector(getSelector());
1:81b4b9a:         }
1:d29ca2a:     }
1:013f372: 
1:21b2f84:     @Override
1:d29ca2a:     protected boolean canDispatch(MessageReference node) {
1:f46b184:         return true;  // let them go, our dispatchPending gates the active / inactive state.
1:d29ca2a:     }
1:d29ca2a: 
1:21b2f84:     @Override
1:d29ca2a:     protected void acknowledge(ConnectionContext context, MessageAck ack, MessageReference node) throws IOException {
1:2b99f39:         this.setTimeOfLastMessageAck(System.currentTimeMillis());
1:9a8f6e4:         Destination regionDestination = (Destination) node.getRegionDestination();
1:9a8f6e4:         regionDestination.acknowledge(context, this, ack, node);
1:d29ca2a:         redeliveredMessages.remove(node.getMessageId());
1:c46562b:         node.decrementReferenceCount();
1:ee54f09:         ((Destination)node.getRegionDestination()).getDestinationStatistics().getDequeues().increment();
1:82295fd:         if (info.isNetworkSubscription()) {
1:82295fd:             ((Destination)node.getRegionDestination()).getDestinationStatistics().getForwards().add(ack.getMessageCount());
1:82295fd:         }
1:d29ca2a:     }
1:d29ca2a: 
1:21b2f84:     @Override
1:230a86c:     public synchronized String toString() {
1:8dc1c12:         return "DurableTopicSubscription-" + getSubscriptionKey() + ", id=" + info.getConsumerId() + ", active=" + isActive() + ", destinations="
1:eece576:                 + durableDestinations.size() + ", total=" + getSubscriptionStatistics().getEnqueues().getCount() + ", pending=" + getPendingQueueSize() + ", dispatched=" + getSubscriptionStatistics().getDispatched().getCount()
1:8dc1c12:                 + ", inflight=" + dispatched.size() + ", prefetchExtension=" + getPrefetchExtension();
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public SubscriptionKey getSubscriptionKey() {
1:0f502fa:         return subscriptionKey;
1:c46562b:     }
1:c46562b: 
1:c46562b:     /**
1:c46562b:      * Release any references that we are holding.
1:c46562b:      */
1:21b2f84:     @Override
1:2db7df7:     public void destroy() {
1:6b4d077:         synchronized (pendingLock) {
1:230a86c:             try {
1:ec63977:                 pending.reset();
1:230a86c:                 while (pending.hasNext()) {
1:230a86c:                     MessageReference node = pending.next();
1:d65ba80:                     node.decrementReferenceCount();
1:d65ba80:                 }
1:230a86c:             } finally {
1:2db7df7:                 pending.release();
1:d65ba80:                 pending.clear();
1:d65ba80:             }
1:c46562b:         }
1:8dc1c12:         synchronized (dispatchLock) {
1:3a5b48a:             for (MessageReference node : dispatched) {
1:c46562b:                 node.decrementReferenceCount();
1:c46562b:             }
1:c46562b:             dispatched.clear();
1:d29ca2a:         }
1:1b6d397:         setSlowConsumer(false);
1:d29ca2a:     }
1:d65ba80: 
1:21b2f84:     @Override
1:6d8e2c5:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
1:230a86c:         if (oldPercentUsage > newPercentUsage && oldPercentUsage >= 90) {
1:230a86c:             try {
1:2db7df7:                 dispatchPending();
1:230a86c:             } catch (IOException e) {
1:230a86c:                 LOG.warn("problem calling dispatchMatched", e);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:c46562b: 
1:6519c3e:     @Override
1:149428b:     protected boolean isDropped(MessageReference node) {
1:8dc1c12:         return false;
1:d29ca2a:     }
1:d29ca2a: 
1:93e2bd3:     public boolean isKeepDurableSubsActive() {
1:93e2bd3:         return keepDurableSubsActive;
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:82295fd
/////////////////////////////////////////////////////////////////////////
1:         if (info.isNetworkSubscription()) {
1:             ((Destination)node.getRegionDestination()).getDestinationStatistics().getForwards().add(ack.getMessageCount());
1:         }
commit:4605503
/////////////////////////////////////////////////////////////////////////
1:                 getSubscriptionStatistics().getInflightMessageSize().reset();
commit:eece576
/////////////////////////////////////////////////////////////////////////
1:             getSubscriptionStatistics().getEnqueues().add(pending.size());
1:                 getSubscriptionStatistics().getEnqueues().add(store.getMessageCount(subscriptionKey.getClientId(), subscriptionKey.getSubscriptionName()));
/////////////////////////////////////////////////////////////////////////
1:                 + durableDestinations.size() + ", total=" + getSubscriptionStatistics().getEnqueues().getCount() + ", pending=" + getPendingQueueSize() + ", dispatched=" + getSubscriptionStatistics().getDispatched().getCount()
author:gtully
-------------------------------------------------------------------------------
commit:4318eba
/////////////////////////////////////////////////////////////////////////
commit:1ad0117
/////////////////////////////////////////////////////////////////////////
0:                         // not sure why pending.addMessageFirst does not take ownership of message reference
0:                         // by incrementing
1:                         node.incrementReferenceCount();
1:                     // createMessageDispatch increments on remove from pending for dispatch
1:                     node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:             node.incrementReferenceCount();
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
1:     public void deactivate(boolean keepDurableSubsActive, long lastDeliveredSequenceId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                     if (lastDeliveredSequenceId == 0 || (lastDeliveredSequenceId > 0 && node.getMessageId().getBrokerSequenceId() <= lastDeliveredSequenceId)) {
1:                         Integer count = redeliveredMessages.get(node.getMessageId());
1:                         if (count != null) {
1:                             redeliveredMessages.put(node.getMessageId(), Integer.valueOf(count.intValue() + 1));
1:                         } else {
1:                             redeliveredMessages.put(node.getMessageId(), Integer.valueOf(1));
1:                         }
commit:6aaf859
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
1:                 if (!((AbstractPendingMessageCursor) pending).isStarted() || !keepDurableSubsActive) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:81b4b9a
/////////////////////////////////////////////////////////////////////////
1:         if (active.get()) {
1:             throw new UnsupportedOperationException("You cannot dynamically change the selector for durable topic subscriptions");
1:         } else {
1:             super.setSelector(getSelector());
1:         }
/////////////////////////////////////////////////////////////////////////
commit:7a68ad5
/////////////////////////////////////////////////////////////////////////
1:     private boolean keepDurableSubsActive;
/////////////////////////////////////////////////////////////////////////
1:         this.keepDurableSubsActive = keepDurableSubsActive;
1:         usageManager.getMemoryUsage().removeUsageListener(this);
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<MessageId, Integer> redeliveredMessages = new ConcurrentHashMap<MessageId, Integer>();
1:     private final ConcurrentMap<ActiveMQDestination, Destination> durableDestinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Activating {}", this);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Deactivating keepActive={}, {}", keepDurableSubsActive, this);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:ee54f09
/////////////////////////////////////////////////////////////////////////
1:         ((Destination)node.getRegionDestination()).getDestinationStatistics().getDequeues().increment();
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:6c85967
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 }
1:                 // use recovery policy every time sub is activated for retroactive topics and consumers
1:                 for (Destination destination : durableDestinations.values()) {
1:                     Topic topic = (Topic) destination;
1:                     if (topic.isAlwaysRetroactive() || info.isRetroactive()) {
1:                         topic.recoverRetroactiveMessages(context, this);
/////////////////////////////////////////////////////////////////////////
1:     public void dispatchPending() throws IOException {
commit:42ad103
/////////////////////////////////////////////////////////////////////////
1:     // used by RetaineMessageSubscriptionRecoveryPolicy
1:     public boolean isEmpty(Topic topic) {
1:         return pending.isEmpty(topic);
1:     }
1: 
commit:78950ec
/////////////////////////////////////////////////////////////////////////
0:             if (topic.isAlwaysRetroactive() || info.isRetroactive()) {
0:                 topic.recoverRetroactiveMessages(context, this);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     // use recovery policy for retroactive topics and consumers
0:                         if (topic.isAlwaysRetroactive() || info.isRetroactive()) {
0:                             topic.recoverRetroactiveMessages(context, this);
1:                         }
commit:8947a09
/////////////////////////////////////////////////////////////////////////
0:             // always use the recovery policy
0:             topic.recoverRetroactiveMessages(context, this);
/////////////////////////////////////////////////////////////////////////
0:                     // always use the recovery policy.
1:                     for (Destination destination : durableDestinations.values()) {
1:                         Topic topic = (Topic) destination;
0:                         topic.recoverRetroactiveMessages(context, this);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
0:                 if (!((StoreDurableSubscriberCursor) pending).isStarted() || !keepDurableSubsActive) {
1:                     pending.setSystemUsage(memoryManager);
1:                     pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:                     pending.setMaxAuditDepth(getMaxAuditDepth());
1:                     pending.setMaxProducersToAudit(getMaxProducersToAudit());
1:                     pending.start();
0:                     // If nothing was in the persistent store, then try to use the
0:                     // recovery policy.
0:                     if (pending.isEmpty()) {
1:                         for (Destination destination : durableDestinations.values()) {
1:                             Topic topic = (Topic) destination;
0:                             topic.recoverRetroactiveMessages(context, this);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:             if (!keepDurableSubsActive) {
1:                 pending.stop();
1:             }
commit:6f70393
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private AtomicLong offlineTimestamp = new AtomicLong(-1);
/////////////////////////////////////////////////////////////////////////
1:     public final long getOfflineTimestamp() {
1:         return offlineTimestamp.get();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.offlineTimestamp.set(-1);
/////////////////////////////////////////////////////////////////////////
1:         offlineTimestamp.set(System.currentTimeMillis());
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
0:                 JMSException jmsEx = new JMSException("Failed to retrieve enqueueCount from store "+ e);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void removePending(MessageReference node) throws IOException {
1:         pending.remove(node);
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableTopicSubscription.class);
commit:bb17d61
/////////////////////////////////////////////////////////////////////////
1:         super.add(context, destination);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
commit:9c47f6b
/////////////////////////////////////////////////////////////////////////
1:         // do it just once per destination
0:         if (destinations.containsKey(destination.getActiveMQDestination())) {
1:             return;
1:         }
commit:9fcf16e
/////////////////////////////////////////////////////////////////////////
1:                     add(context, topic);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2b99f39
/////////////////////////////////////////////////////////////////////////
1:         this.setTimeOfLastMessageAck(System.currentTimeMillis());
commit:f46b184
/////////////////////////////////////////////////////////////////////////
1:         return true;  // let them go, our dispatchPending gates the active / inactive state.
commit:3039b67
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         List<MessageReference> savedDispateched = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (!topicsToDeactivate.isEmpty()) {
1:                     savedDispateched = new ArrayList<MessageReference>(dispatched);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             topic.deactivate(context, this, savedDispateched);
commit:21b2f84
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean active = new AtomicBoolean();
1:     private final AtomicLong offlineTimestamp = new AtomicLong(-1);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // On Activation we should update the configuration based on our new consumer info.
1:                 ActiveMQDestination dest = this.info.getDestination();
1:                 if (dest != null && regionBroker.getDestinationPolicy() != null) {
1:                     PolicyEntry entry = regionBroker.getDestinationPolicy().getEntryFor(dest);
1:                     if (entry != null) {
1:                         entry.configure(broker, usageManager, this);
1:                     }
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:566039f
/////////////////////////////////////////////////////////////////////////
1:     public void setOfflineTimestamp(long timestamp) {
1:         offlineTimestamp.set(timestamp);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Activating " + this);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Deactivating keepActive=" + keepDurableSubsActive + ", " + this);
1:         }
commit:8dc1c12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
/////////////////////////////////////////////////////////////////////////
1:             throws JMSException {
1:         super(broker, usageManager, context, info);
1:         this.pending = new StoreDurableSubscriberCursor(broker, context.getClientId(), info.getSubscriptionName(), info.getPrefetchSize(), this);
/////////////////////////////////////////////////////////////////////////
1:      * store will have a pending ack for all durables, irrespective of the
1:      * selector so we need to ack if node is un-matched
/////////////////////////////////////////////////////////////////////////
1:             return;
1:             Topic topic = (Topic) destination;
0:             this.enqueueCounter += pending.size();
1:             TopicMessageStore store = (TopicMessageStore) destination.getMessageStore();
0:                 this.enqueueCounter += store.getMessageCount(subscriptionKey.getClientId(), subscriptionKey.getSubscriptionName());
1:                 JMSException jmsEx = new JMSException("Failed to retrieve enqueueCount from store " + e);
/////////////////////////////////////////////////////////////////////////
1:     public void activate(SystemUsage memoryManager, ConnectionContext context, ConsumerInfo info, RegionBroker regionBroker) throws Exception {
1: 
0:             // On Activation we should update the configuration based on our new consumer info.
0:             ActiveMQDestination dest = this.info.getDestination();
0:             if (dest != null && regionBroker.getDestinationPolicy() != null) {
0:                 PolicyEntry entry = regionBroker.getDestinationPolicy().getEntryFor(dest);
0:                 if (entry != null) {
0:                     entry.configure(broker, usageManager, this);
1:                 }
1:             }
1: 
0:                 for (Destination destination : durableDestinations.values()) {
0:                     Topic topic = (Topic) destination;
/////////////////////////////////////////////////////////////////////////
0:                     for (Destination destination : durableDestinations.values()) {
0:                         Topic topic = (Topic) destination;
/////////////////////////////////////////////////////////////////////////
0:                 for (Destination destination : durableDestinations.values()) {
0:                     Topic topic = (Topic) destination;
/////////////////////////////////////////////////////////////////////////
1:         synchronized (pending) {
/////////////////////////////////////////////////////////////////////////
1:         return "DurableTopicSubscription-" + getSubscriptionKey() + ", id=" + info.getConsumerId() + ", active=" + isActive() + ", destinations="
0:                 + durableDestinations.size() + ", total=" + enqueueCounter + ", pending=" + getPendingQueueSize() + ", dispatched=" + dispatchCounter
1:                 + ", inflight=" + dispatched.size() + ", prefetchExtension=" + getPrefetchExtension();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         synchronized (dispatchLock) {
/////////////////////////////////////////////////////////////////////////
1:         return false;
commit:fd37e8c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 // Before we add these back to pending they need to be in producer order not
1:                 // dispatch order so we can add them to the front of the pending list.
1:                 Collections.reverse(dispatched);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:3a5b48a
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         prefetchExtension.set(0);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                + getPendingQueueSize() + ", dispatched=" + dispatchCounter + ", inflight=" + dispatched.size() + ", prefetchExtension=" + getPrefetchExtension();
/////////////////////////////////////////////////////////////////////////
1:             for (MessageReference node : dispatched) {
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:846cf7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: 
1:         ArrayList<Topic> topicsToDeactivate = new ArrayList<Topic>();
/////////////////////////////////////////////////////////////////////////
1:                         topicsToDeactivate.add(topic);
/////////////////////////////////////////////////////////////////////////
1:         for(Topic topic: topicsToDeactivate) {
0:             topic.deactivate(context, this);
1:         }
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:         Destination regionDestination = (Destination) node.getRegionDestination();
1:         regionDestination.acknowledge(this.getContext(), this, ack, node);
/////////////////////////////////////////////////////////////////////////
1:         Destination regionDestination = (Destination) node.getRegionDestination();
1:         regionDestination.acknowledge(context, this, ack, node);
commit:53c4e12
/////////////////////////////////////////////////////////////////////////
0:         super(broker, context, info);
0:         this.pending = new StoreDurableSubscriberCursor(context.getClientId(), info.getSubscriptionName(), broker.getTempDataStore(), info.getPrefetchSize(), this);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<MessageId, Integer> redeliveredMessages = new ConcurrentHashMap<MessageId, Integer>();
0:     private final ConcurrentHashMap<ActiveMQDestination, Destination> destinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:             Integer count = redeliveredMessages.get(node.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:         Integer count = redeliveredMessages.get(node.getMessageId());
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isActive() {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void gc() {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void deactivate(boolean keepDurableSubsActive) throws Exception {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1: public class DurableTopicSubscription extends PrefetchSubscription implements UsageListener {
0:     private static final Log LOG = LogFactory.getLog(PrefetchSubscription.class);
0:     private final ConcurrentHashMap redeliveredMessages = new ConcurrentHashMap();
0:     private final ConcurrentHashMap destinations = new ConcurrentHashMap();
0:     private boolean active;
0:     public DurableTopicSubscription(Broker broker, UsageManager usageManager, ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive)
0:         throws InvalidSelectorException {
0:         super(broker, context, info, new StoreDurableSubscriberCursor(context.getClientId(), info.getSubscriptionName(), broker.getTempDataStore(), info.getPrefetchSize()));
0:         this.usageManager = usageManager;
1:         this.keepDurableSubsActive = keepDurableSubsActive;
1:         subscriptionKey = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
0:     synchronized public boolean isActive() {
0:     protected synchronized boolean isFull() {
0:         return !active || super.isFull();
0:     synchronized public void gc() {
0:     public synchronized void add(ConnectionContext context, Destination destination) throws Exception {
0:         super.add(context, destination);
0:         destinations.put(destination.getActiveMQDestination(), destination);
0:         if (active || keepDurableSubsActive) {
0:             Topic topic = (Topic)destination;
1:             topic.activate(context, this);
0:             if (pending.isEmpty(topic)) {
0:                 topic.recoverRetroactiveMessages(context, this);
0:     public synchronized void activate(UsageManager memoryManager, ConnectionContext context, ConsumerInfo info) throws Exception {
0:         LOG.debug("Activating " + this);
0:         if (!active) {
0:             this.active = true;
1:             this.context = context;
1:             this.info = info;
1:             if (!keepDurableSubsActive) {
0:                 for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic)iter.next();
1:                     topic.activate(context, this);
1:             }
1: 
0:             // If nothing was in the persistent store, then try to use the
0:             // recovery policy.
0:             if (pending.isEmpty()) {
0:                 for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic)iter.next();
0:                     topic.recoverRetroactiveMessages(context, this);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void deactivate(boolean keepDurableSubsActive) throws Exception {
0:         active = false;
0:         synchronized (pending) {
1:         if (!keepDurableSubsActive) {
0:             for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                 Topic topic = (Topic)iter.next();
0:                 topic.deactivate(context, this);
0:         for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:             MessageReference node = (MessageReference)iter.next();
0:             Integer count = (Integer)redeliveredMessages.get(node.getMessageId());
1:             if (count != null) {
0:                 redeliveredMessages.put(node.getMessageId(), Integer.valueOf(count.intValue() + 1));
1:             } else {
0:                 redeliveredMessages.put(node.getMessageId(), Integer.valueOf(1));
0:             if (keepDurableSubsActive) {
0:                 synchronized (pending) {
1:             } else {
1:         if (!keepDurableSubsActive) {
0:             synchronized (pending) {
1:                 try {
1:                     while (pending.hasNext()) {
1:                         MessageReference node = pending.next();
1:                 } finally {
0:         prefetchExtension = 0;
1:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
1:         MessageDispatch md = super.createMessageDispatch(node, message);
0:         Integer count = (Integer)redeliveredMessages.get(node.getMessageId());
1:         if (count != null) {
0:     public synchronized void add(MessageReference node) throws Exception {
0:         if (!active && !keepDurableSubsActive) {
0:     protected synchronized void doAddRecoveredMessage(MessageReference message) throws Exception {
0:     public synchronized int getPendingQueueSize() {
0:         if (active || keepDurableSubsActive) {
1:     public void setSelector(String selector) throws InvalidSelectorException {
0:         throw new UnsupportedOperationException("You cannot dynamically change the selector for durable topic subscriptions");
0:     protected synchronized boolean canDispatch(MessageReference node) {
0:     protected synchronized void acknowledge(ConnectionContext context, MessageAck ack, MessageReference node) throws IOException {
0:         node.getRegionDestination().acknowledge(context, this, ack, node);
0:     public String getSubscriptionName() {
1:     public synchronized String toString() {
0:         return "DurableTopicSubscription:" + " consumer=" + info.getConsumerId() + ", destinations=" + destinations.size() + ", total=" + enqueueCounter + ", pending="
0:                + getPendingQueueSize() + ", dispatched=" + dispatchCounter + ", inflight=" + dispatched.size() + ", prefetchExtension=" + this.prefetchExtension;
0:     public String getClientId() {
1:     public SubscriptionKey getSubscriptionKey() {
0:     public synchronized void destroy() {
1:         try {
0:             synchronized (pending) {
1:                 while (pending.hasNext()) {
1:                     MessageReference node = pending.next();
1:         } finally {
0:         for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:             MessageReference node = (MessageReference)iter.next();
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.activemq.memory.UsageListener#onMemoryUseChanged(org.apache.activemq.memory.UsageManager,
0:      *      int, int)
0:     public void onMemoryUseChanged(UsageManager memoryManager, int oldPercentUsage, int newPercentUsage) {
1:         if (oldPercentUsage > newPercentUsage && oldPercentUsage >= 90) {
1:             try {
1:             } catch (IOException e) {
1:                 LOG.warn("problem calling dispatchMatched", e);
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
commit:333158a
/////////////////////////////////////////////////////////////////////////
0:         subscriptionKey = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:d65ba80
/////////////////////////////////////////////////////////////////////////
0:         dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:             dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:             	synchronized(pending) {
0:             		pending.addFirst(node);
1:             	}
/////////////////////////////////////////////////////////////////////////
0:         	synchronized(pending) {
0: 	            for (Iterator iter = pending.iterator(); iter.hasNext();) {
0: 	                MessageReference node = (MessageReference) iter.next();
1: 	                node.decrementReferenceCount();
0: 	                iter.remove();
1: 	            }
1:         	}
/////////////////////////////////////////////////////////////////////////
0:             ", pending="+getPendingQueueSize();
/////////////////////////////////////////////////////////////////////////
1:     	
0:     	synchronized(pending) {
0: 	        for (Iterator iter = pending.iterator(); iter.hasNext();) {
0: 	            MessageReference node = (MessageReference) iter.next();
1: 	            node.decrementReferenceCount();
1: 	        }
1: 	        pending.clear();
1:     	}
1:     	
commit:c46562b
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Release any references that we are holding.
1:      */
0:     synchronized public void destroy() {
1:         
0:         for (Iterator iter = pending.iterator(); iter.hasNext();) {
0:             MessageReference node = (MessageReference) iter.next();
1:             node.decrementReferenceCount();
1:         }
0:         pending.clear();
1:         
0:         for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:             MessageReference node = (MessageReference) iter.next();
1:             node.decrementReferenceCount();
1:         }
1:         dispatched.clear();
1:         
1:     }
commit:a2ae3a9
/////////////////////////////////////////////////////////////////////////
0:             iter.remove();
commit:18d616c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.util.Iterator;
1: 
1: import javax.jms.InvalidSelectorException;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:             if( keepDurableSubsActive ) {
0:                 pending.addFirst(node);
0:             } else {
0:                 node.decrementReferenceCount();
0:                 iter.remove();
1:             }
1:         
0:         if( !keepDurableSubsActive ) {
0:             for (Iterator iter = pending.iterator(); iter.hasNext();) {
0:                 MessageReference node = (MessageReference) iter.next();
0:                 node.decrementReferenceCount();
0:                 iter.remove();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         node.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:         node.decrementReferenceCount();
commit:449981b
/////////////////////////////////////////////////////////////////////////
0:     private final boolean keepDurableSubsActive;
0:     public DurableTopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive) throws InvalidSelectorException {
0:         this.keepDurableSubsActive = keepDurableSubsActive;
/////////////////////////////////////////////////////////////////////////
0:         if( active || keepDurableSubsActive ) {
0:         if( !isFull() ) {
0:             dispatchMatched();
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if( !keepDurableSubsActive ) {
0:                 for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic) iter.next();
0:                     topic.activate(context, this);
1:                 }
0:             if( !isFull() ) {
0:     synchronized public void deactivate(boolean keepDurableSubsActive) throws Exception {        
0:         if( !keepDurableSubsActive ) {
0:             for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                 Topic topic = (Topic) iter.next();
0:                 topic.deactivate(context, this);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if( !active && !keepDurableSubsActive ) {
/////////////////////////////////////////////////////////////////////////
1:     public int getPendingQueueSize() {
0:         if( active || keepDurableSubsActive ) {
1:    
commit:5ff3487
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = pending.iterator(); iter.hasNext();) {
0:         prefetchExtension=0;
/////////////////////////////////////////////////////////////////////////
0:             ", delivered="+this.prefetchExtension+
0:             ", pending="+this.pending.size();
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
0:     public int getPendingQueueSize(){
1:             return super.getPendingQueueSize();
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void add(ConnectionContext context, Destination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void activate(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void deactivate() throws Exception {        
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void add(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void acknowledge(ConnectionContext context, MessageAck ack) throws Exception {
commit:0f502fa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.SubscriptionKey;
0:     private final ConcurrentHashMap redeliveredMessages = new ConcurrentHashMap();
0:     private final ConcurrentHashMap destinations = new ConcurrentHashMap();
1:     private final SubscriptionKey subscriptionKey;
0:     private boolean active=false;
0:         subscriptionKey = new SubscriptionKey(context.getClientId(), info.getSubcriptionName());
1:     }
1: 
0:     synchronized public void add(ConnectionContext context, Destination destination) throws Throwable {
0:         super.add(context, destination);
0:         destinations.put(destination.getActiveMQDestination(), destination);
0:         if( active ) {
0:             Topic topic = (Topic) destination;            
0:             topic.activate(context, this);
1:         }
1:     }
1:    
0:     synchronized public void activate(ConnectionContext context, ConsumerInfo info) throws Throwable {
0:         if( !active ) {
0:             this.active = true;
0:             this.context = context;
0:             this.info = info;
0:             for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                 Topic topic = (Topic) iter.next();
0:                 topic.activate(context, this);
0:             if( !isFull() ) {                            
0:                 dispatchMatched();
0:     synchronized public void deactivate() throws Throwable {        
0:         for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:             Topic topic = (Topic) iter.next();
0:             topic.deactivate(context, this);
1:         }
1: 
1:             // Mark the dispatched messages as redelivered for next time.
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = matched.iterator(); iter.hasNext();) {
0:             MessageReference node = (MessageReference) iter.next();
0:             // node.decrementTargetCount();
0:             iter.remove();
1:         }        
/////////////////////////////////////////////////////////////////////////
0:         if( !active ) {
0:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return subscriptionKey.getSubscriptionName();
/////////////////////////////////////////////////////////////////////////
0:         return subscriptionKey.getClientId();
1:     }
1: 
0:     public SubscriptionKey getSubscriptionKey() {
1:         return subscriptionKey;
commit:04968b6
/////////////////////////////////////////////////////////////////////////
0:                     topic.recover(context, this, false);
commit:013f372
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.SubscriptionInfo;
/////////////////////////////////////////////////////////////////////////
0:     public DurableTopicSubscription(SubscriptionInfo info) throws InvalidSelectorException {
0:         super(null, createFakeConsumerInfo(info));
0:         this.clientId = info.getClientId();
0:         this.subscriptionName = info.getSubcriptionName();
0:         active=false;
0:         recovered=false;        
1:     }
1: 
0:     private static ConsumerInfo createFakeConsumerInfo(SubscriptionInfo info) {
0:         ConsumerInfo rc = new ConsumerInfo();
0:         rc.setSelector(info.getSelector());
0:         rc.setSubcriptionName(info.getSubcriptionName());
0:         rc.setDestination(info.getDestination());
0:         return rc;
1:     }
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
1: 
0: import java.io.IOException;
0: import java.util.Iterator;
1: 
0: import javax.jms.InvalidSelectorException;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
0: public class DurableTopicSubscription extends PrefetchSubscription {
1:     
0:     final protected String clientId;
0:     final protected String subscriptionName;
0:     final ConcurrentHashMap redeliveredMessages = new ConcurrentHashMap();
1:     
0:     boolean active=true;
0:     boolean recovered=true;
1:     
0:     public DurableTopicSubscription(ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         super(context, info);
0:         this.clientId = context.getClientId();
0:         this.subscriptionName = info.getSubcriptionName();
1:     }
1:     
0:     synchronized public boolean isActive() {
0:         return active;
1:     }
0:     synchronized public boolean isRecovered() {
0:         return recovered;
1:     }
1:     
0:     protected boolean isFull() {
0:         return !active || super.isFull();
1:     }
1:     
0:     synchronized public void gc() {
0:         if( !active && recovered ) {
0:             recovered = false;
1:             
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 MessageReference node = (MessageReference) iter.next();
0:                 // node.decrementTargetCount();
0:                 iter.remove();
1:             }
1:             
0:             for (Iterator iter = matched.iterator(); iter.hasNext();) {
0:                 MessageReference node = (MessageReference) iter.next();
0:                 // node.decrementTargetCount();
0:                 iter.remove();
1:             }
1:             
0:             delivered=0;
1:         }
1:     }
1: 
0:     synchronized public void deactivate() {        
0:         active=false;
0:         for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
1:             
0:             MessageReference node = (MessageReference) iter.next();
0:             Integer count = (Integer) redeliveredMessages.get(node.getMessageId());
0:             if( count !=null ) {
0:                 redeliveredMessages.put(node.getMessageId(), new Integer(count.intValue()+1));
0:             } else {
0:                 redeliveredMessages.put(node.getMessageId(), new Integer(1));
1:             }
1:             
0:             // Undo the dispatch.
0:             matched.addFirst(node);
0:             iter.remove();
1:         }
0:         delivered=0;
1:     }
1: 
0:     synchronized public void activate(ConnectionContext context, ConsumerInfo info) throws Throwable {
0:         if( !active ) {
0:             this.active = true;
0:             this.context = context;
0:             this.info = info;
0:             if( !recovered ) {
0:                 recovered=true;
0:                 for (Iterator iter = destinations.iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic) iter.next();
0:                     topic.recover(this, false);
1:                 }
0:             } else {
0:                 if( !isFull() ) {                            
0:                     dispatchMatched();
1:                 }
1:             }
1:         }
1:     }
1: 
0:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
0:         MessageDispatch md = super.createMessageDispatch(node, message);
0:         Integer count = (Integer) redeliveredMessages.get(node.getMessageId());
0:         if( count !=null ) {
1:             md.setRedeliveryCounter(count.intValue());
1:         }
1:         return md;
1:     }
1: 
0:     synchronized public void add(MessageReference node) throws Throwable {
0:         assert recovered;
0:         node = new IndirectMessageReference(node.getRegionDestination(), (Message) node);
1:         super.add(node);
0:         node.decrementReferenceCount();
1:     }
1: 
1:     protected boolean canDispatch(MessageReference node) {
0:         return active;
1:     }
1:     
0:     public synchronized void acknowledge(ConnectionContext context, MessageAck ack) throws Throwable {
0:         assert recovered;
0:         super.acknowledge(context, ack);
1:     }
1: 
1:     protected void acknowledge(ConnectionContext context, MessageAck ack, MessageReference node) throws IOException {
0:         node.getRegionDestination().acknowledge(context, this, ack, node);
1:         redeliveredMessages.remove(node.getMessageId());
0:         ((IndirectMessageReference)node).drop();
1:     }
1:     
0:     public String getSubscriptionName() {
0:         return subscriptionName;
1:     }
1:     
0:     public String toString() {
0:         return 
0:             "DurableTopicSubscription:" +
0:             " consumer="+info.getConsumerId()+
0:             ", destinations="+destinations.size()+
0:             ", dispatched="+dispatched.size()+
0:             ", delivered="+this.delivered+
0:             ", matched="+this.matched.size();
1:     }
1: 
0:     public String getClientId() {
0:         return clientId;
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:6b4d077
/////////////////////////////////////////////////////////////////////////
1:         synchronized (pendingLock) {
1:             synchronized (dispatchLock) {
0:                 for (Iterator<Destination> iter = durableDestinations.values().iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic)iter.next();
0:                     if (!keepDurableSubsActive) {
0:                         topic.deactivate(context, this);
0:                     } else {
1:                         topic.getDestinationStatistics().getInflight().subtract(dispatched.size());
0:                     }
0: 
1:                 for (final MessageReference node : dispatched) {
0:                     // Mark the dispatched messages as redelivered for next time.
0:                     Integer count = redeliveredMessages.get(node.getMessageId());
0:                     if (count != null) {
0:                         redeliveredMessages.put(node.getMessageId(), Integer.valueOf(count.intValue() + 1));
0:                     } else {
0:                         redeliveredMessages.put(node.getMessageId(), Integer.valueOf(1));
0:                     }
1:                     if (keepDurableSubsActive && pending.isTransient()) {
1:                         pending.addMessageFirst(node);
1:                         pending.rollback(node.getMessageId());
0:                     } else {
0:                         node.decrementReferenceCount();
0:                     }
0:                 }
1:                 dispatched.clear();
1:             if (!keepDurableSubsActive && pending.isTransient()) {
/////////////////////////////////////////////////////////////////////////
1:         synchronized (pendingLock) {
/////////////////////////////////////////////////////////////////////////
0:         synchronized  (dispatchLock) {
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Deactivating keepActive=" + keepDurableSubsActive + ", " + this);
/////////////////////////////////////////////////////////////////////////
0:             if (keepDurableSubsActive && pending.isTransient()) {
0:                     pending.rollback(node.getMessageId());
commit:caca105
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<ActiveMQDestination, Destination> durableDestinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
/////////////////////////////////////////////////////////////////////////
1:         if (!destinations.contains(destination)) {
0:             super.add(context, destination);
0:         // do it just once per destination
1:         if (durableDestinations.containsKey(destination.getActiveMQDestination())) {
0:              return;
0:         }
1:         durableDestinations.put(destination.getActiveMQDestination(), destination);
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<Destination> iter = durableDestinations.values()
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<Destination> iter = durableDestinations.values()
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<Destination> iter = durableDestinations.values().iterator(); iter.hasNext();) {
0:             Topic topic = (Topic)iter.next();
0:             if (!keepDurableSubsActive) {
0:             } else {
0:                 topic.getDestinationStatistics().getInflight().subtract(dispatched.size());
/////////////////////////////////////////////////////////////////////////
0:         return "DurableTopicSubscription-" + getSubscriptionKey() + ", id=" + info.getConsumerId() + ", active=" + isActive() + ", destinations=" + durableDestinations.size() + ", total=" + enqueueCounter + ", pending="
commit:a6b85cc
/////////////////////////////////////////////////////////////////////////
0:         return "DurableTopicSubscription-" + getSubscriptionKey() + ", id=" + info.getConsumerId() + ", active=" + isActive() + ", destinations=" + destinations.size() + ", total=" + enqueueCounter + ", pending="
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:         if (node != QueueMessageReference.NULL_MESSAGE) {
0:             Integer count = redeliveredMessages.get(node.getMessageId());
0:             if (count != null) {
0:                 md.setRedeliveryCounter(count.intValue());
0:             }
commit:93e2bd3
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (active.get() || keepDurableSubsActive) {
0:             Topic topic = (Topic)destination;
0:             topic.activate(context, this);
0:             if (pending.isEmpty(topic)) {
0:                 topic.recoverRetroactiveMessages(context, this);
0:             }
0:             this.enqueueCounter+=pending.size();
1:         } else if (destination.getMessageStore() != null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
1:     public boolean isKeepDurableSubsActive() {
1:         return keepDurableSubsActive;
0:     }
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1:             synchronized (pendingLock) {
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     public final boolean isActive() {
/////////////////////////////////////////////////////////////////////////
0:     protected void dispatchPending() throws IOException {
1:         if (isActive()) {
1:             super.dispatchPending();
0:         }
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         return isActive();
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void setPendingBatchSize(PendingMessageCursor pending, int numberToDispatch) {
1:         // statically configured via maxPageSize
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 pending.setMaxAuditDepth(getMaxAuditDepth());
0:                 pending.setMaxProducersToAudit(getMaxProducersToAudit());
commit:6aacb03
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean active = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:         return active.get();
1:         return !active.get() || super.isFull();
/////////////////////////////////////////////////////////////////////////
1:         if (active.get() || keepDurableSubsActive) {
/////////////////////////////////////////////////////////////////////////
1:         if (!active.get()) {
/////////////////////////////////////////////////////////////////////////
1:             this.active.set(true);
/////////////////////////////////////////////////////////////////////////
1:         active.set(false);
/////////////////////////////////////////////////////////////////////////
1:         if (!active.get() && !keepDurableSubsActive) {
/////////////////////////////////////////////////////////////////////////
0:         if (active.get() || keepDurableSubsActive) {
/////////////////////////////////////////////////////////////////////////
0:         return active.get();
commit:5baf5f5
/////////////////////////////////////////////////////////////////////////
0:         return "DurableTopicSubscription-" + getSubscriptionKey() + ", id=" + info.getConsumerId() + ", destinations=" + destinations.size() + ", total=" + enqueueCounter + ", pending="
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1:         ack.setAckType(MessageAck.UNMATCHED_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Activating " + this);
0:                 prefetch += prefetch/2;
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Deactivating " + this);
/////////////////////////////////////////////////////////////////////////
0: 
commit:5cbb4db
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Dectivating " + this);
commit:306f8a0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.filter.MessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * store will have a pending ack for all durables, irrespective of the selector
0:      * so we need to ack if node is un-matched
1:      */
1:     public void unmatched(MessageReference node) throws IOException {
1:         MessageAck ack = new MessageAck();
1:         ack.setMessageID(node.getMessageId());
0:         node.getRegionDestination().acknowledge(this.getContext(), this, ack, node);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1:         setSlowConsumer(false);
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
1:             pending.addRecoveredMessage(message);
author:Robert Davies
-------------------------------------------------------------------------------
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:         this.pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
/////////////////////////////////////////////////////////////////////////
0:                 pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
1:     public DurableTopicSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive)
0:         super(broker,usageManager, context, info);
0:         
/////////////////////////////////////////////////////////////////////////
0:         if (destination.getMessageStore() != null) {
0:             TopicMessageStore store = (TopicMessageStore)destination.getMessageStore();
1:             try {
0:                 this.enqueueCounter+=store.getMessageCount(subscriptionKey.getClientId(),subscriptionKey.getSubscriptionName());
1:             } catch (IOException e) {
0:                 JMSException jmsEx = new JMSException("Failed to retrieve eunqueueCount from store "+ e);
1:                 jmsEx.setLinkedException(e);
1:                 throw jmsEx;
0:             }
0:         }
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:         super(broker,dest,usageManager, context, info);
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFull() {
commit:149428b
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected boolean isDropped(MessageReference node) {
0:        return false;
0:      }
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
commit:55810b3
/////////////////////////////////////////////////////////////////////////
0:             int prefetch = info.getPrefetchSize();
0:             if (prefetch>0) {
0:             prefetch += prefetch/2;
0:             }
0:             int depth = Math.max(prefetch, this.pending.getMaxAuditDepth());
0:             this.pending.setMaxAuditDepth(depth);
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
0:         this.pending = new StoreDurableSubscriberCursor(broker,context.getClientId(), info.getSubscriptionName(), info.getPrefetchSize(), this);
/////////////////////////////////////////////////////////////////////////
0:     
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
0: 
1: import javax.jms.JMSException;
0: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     public DurableTopicSubscription(Broker broker, Destination dest,SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive)
0:         throws JMSException {
0:         if (dest != null && dest.getMessageStore() != null) {
0:             TopicMessageStore store = (TopicMessageStore)dest.getMessageStore();
0:             try {
0:                 this.enqueueCounter=store.getMessageCount(subscriptionKey.getClientId(),subscriptionKey.getSubscriptionName());
0:             } catch (IOException e) {
0:                 JMSException jmsEx = new JMSException("Failed to retrieve eunqueueCount from store "+ e);
0:                 jmsEx.setLinkedException(e);
0:                 throw jmsEx;
0:             }
0:         }
commit:2db7df7
/////////////////////////////////////////////////////////////////////////
0:     public boolean isActive() {
0:     protected boolean isFull() {
1:     public void gc() {
1:     public void add(ConnectionContext context, Destination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         dispatchPending();
0:     public void activate(SystemUsage memoryManager, ConnectionContext context,
0:             ConsumerInfo info) throws Exception {
0:                 for (Iterator<Destination> iter = destinations.values()
0:                         .iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic) iter.next();
0:             synchronized (pending) {
0:                 pending.setSystemUsage(memoryManager);
0:                 pending.start();
0:                 // If nothing was in the persistent store, then try to use the
0:                 // recovery policy.
0:                 if (pending.isEmpty()) {
0:                     for (Iterator<Destination> iter = destinations.values()
0:                             .iterator(); iter.hasNext();) {
0:                         Topic topic = (Topic) iter.next();
0:                         topic.recoverRetroactiveMessages(context, this);
0:                     }
1:             dispatchPending();
0:     public void deactivate(boolean keepDurableSubsActive) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatched) {
0:             dispatched.clear();
0:         }
/////////////////////////////////////////////////////////////////////////
1:     public void add(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected void doAddRecoveredMessage(MessageReference message) throws Exception {
0:         synchronized(pending) {
0:         }
0:     public int getPendingQueueSize() {
/////////////////////////////////////////////////////////////////////////
0:     protected boolean canDispatch(MessageReference node) {
/////////////////////////////////////////////////////////////////////////
1:     public void destroy() {
0:         synchronized (pending) {
0:             try {
0: 
0: 
0:             } finally {
1:                 pending.release();
0:                 pending.clear();
0:         synchronized(dispatched) {
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 MessageReference node = (MessageReference) iter.next();
0:                 node.decrementReferenceCount();
0:             }
0:             dispatched.clear();
/////////////////////////////////////////////////////////////////////////
1:                 dispatchPending();
commit:f472000
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:         for (final MessageReference node : dispatched) {
/////////////////////////////////////////////////////////////////////////
0:         dispatched.clear();
commit:2913fb8
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(DurableTopicSubscription.class);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:         super(broker,usageManager, context, info);
1:         this.pending.setSystemUsage(usageManager);
/////////////////////////////////////////////////////////////////////////
0:     protected void acknowledge(ConnectionContext context, MessageAck ack, MessageReference node) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:      * @param usageManager
commit:36486fe
/////////////////////////////////////////////////////////////////////////
0:             if (keepDurableSubsActive&& pending.isTransient()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!keepDurableSubsActive && pending.isTransient()) {
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.Usage;
1: import org.apache.activemq.usage.UsageListener;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     private final SystemUsage usageManager;
0:     public DurableTopicSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive)
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void activate(SystemUsage memoryManager, ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             pending.setSystemUsage(memoryManager);
/////////////////////////////////////////////////////////////////////////
1:             this.usageManager.getMemoryUsage().addUsageListener(this);
0:         this.usageManager.getMemoryUsage().removeUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.activemq.usage.UsageListener#onMemoryUseChanged(org.apache.activemq.usage.SystemUsage,
1:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized boolean isFull(){
/////////////////////////////////////////////////////////////////////////
0:         for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:             // Mark the dispatched messages as redelivered for next time.
0:             MessageReference node=(MessageReference)iter.next();
0:             Integer count=(Integer)redeliveredMessages.get(node.getMessageId());
0:             if(count!=null){
0:                 redeliveredMessages.put(node.getMessageId(),Integer.valueOf(count.intValue()+1));
0:             }else{
0:                 redeliveredMessages.put(node.getMessageId(),Integer.valueOf(1));
0:             if(keepDurableSubsActive){
0:                 synchronized(pending){
0:                     pending.addMessageFirst(node);
0:                 }
0:             }else{
0:                 node.decrementReferenceCount();
0:             }
0:             iter.remove();
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void doAddRecoveredMessage(MessageReference message) throws Exception{
0:     public synchronized int getPendingQueueSize(){
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized boolean canDispatch(MessageReference node){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized String toString(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void destroy(){
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:                     redeliveredMessages.put(node.getMessageId(),Integer.valueOf(count.intValue()+1));
0:                     redeliveredMessages.put(node.getMessageId(),Integer.valueOf(1));
commit:4d1a176
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void activate(UsageManager memoryManager,ConnectionContext context,ConsumerInfo info) throws Exception{
0:         log.debug("Activating "+this);
/////////////////////////////////////////////////////////////////////////
0:             }           
0:             pending.setUsageManager(memoryManager);
0:             pending.start();
0:            
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void add(MessageReference node) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void acknowledge(ConnectionContext context,MessageAck ack,MessageReference node) throws IOException{
commit:8de60cf
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageListener;
0: public class DurableTopicSubscription extends PrefetchSubscription implements UsageListener{
0: 
0:     private final ConcurrentHashMap redeliveredMessages=new ConcurrentHashMap();
0:     private final ConcurrentHashMap destinations=new ConcurrentHashMap();
0:     private final UsageManager usageManager;
0: 
0:     public DurableTopicSubscription(Broker broker,UsageManager usageManager,ConnectionContext context,
0:             ConsumerInfo info,boolean keepDurableSubsActive) throws InvalidSelectorException{
0:         super(broker,context,info,new StoreDurableSubscriberCursor(context.getClientId(),info.getSubscriptionName(),
0:                 broker.getTempDataStore(),info.getPrefetchSize()));
0:         this.usageManager=usageManager;
0:         this.keepDurableSubsActive=keepDurableSubsActive;
0:         subscriptionKey=new SubscriptionKey(context.getClientId(),info.getSubscriptionName());
0:     synchronized public boolean isActive(){
0:         return active;
0:     }
0: 
0:     protected boolean isFull(){
0:         return !active||super.isFull();
0:     }
0: 
0:     synchronized public void gc(){
0:     }
0: 
0:     public synchronized void add(ConnectionContext context,Destination destination) throws Exception{
0:         super.add(context,destination);
0:         destinations.put(destination.getActiveMQDestination(),destination);
0:         if(active||keepDurableSubsActive){
0:             Topic topic=(Topic)destination;
0:             topic.activate(context,this);
0:             if(pending.isEmpty(topic)){
0:                 topic.recoverRetroactiveMessages(context,this);
0: 
0:     public void activate(UsageManager memoryManager,ConnectionContext context,ConsumerInfo info) throws Exception{
0:         log.debug("Deactivating "+this);
0:         if(!active){
0:             this.active=true;
0:             this.context=context;
0:             this.info=info;
0:             if(!keepDurableSubsActive){
0:                 for(Iterator iter=destinations.values().iterator();iter.hasNext();){
0:                     Topic topic=(Topic)iter.next();
0:                     topic.activate(context,this);
0:             synchronized(pending){
0:             // If nothing was in the persistent store, then try to use the recovery policy.
0:             if(pending.isEmpty()){
0:                 for(Iterator iter=destinations.values().iterator();iter.hasNext();){
0:                     Topic topic=(Topic)iter.next();
0:                     topic.recoverRetroactiveMessages(context,this);
0:             this.usageManager.addUsageListener(this);
0:     synchronized public void deactivate(boolean keepDurableSubsActive) throws Exception{
0:         this.usageManager.removeUsageListener(this);
0:         if(!keepDurableSubsActive){
0:             for(Iterator iter=destinations.values().iterator();iter.hasNext();){
0:                 Topic topic=(Topic)iter.next();
0:                 topic.deactivate(context,this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected MessageDispatch createMessageDispatch(MessageReference node,Message message){
0:         MessageDispatch md=super.createMessageDispatch(node,message);
0:         Integer count=(Integer)redeliveredMessages.get(node.getMessageId());
0:         if(count!=null){
0:     public void add(MessageReference node) throws Exception{
0:         if(!active&&!keepDurableSubsActive){
0: 
0:     protected void doAddRecoveredMessage(MessageReference message) throws Exception{
0: 
0:     public int getPendingQueueSize(){
0:         if(active||keepDurableSubsActive){
1:         // TODO: need to get from store
0: 
0:     public void setSelector(String selector) throws InvalidSelectorException{
0:         throw new UnsupportedOperationException(
0:                 "You cannot dynamically change the selector for durable topic subscriptions");
0:     protected boolean canDispatch(MessageReference node){
0: 
0:     protected void acknowledge(ConnectionContext context,MessageAck ack,MessageReference node) throws IOException{
0:         node.getRegionDestination().acknowledge(context,this,ack,node);
0: 
0:     public String getSubscriptionName(){
0: 
0:     public String toString(){
0:         return "DurableTopicSubscription:"+" consumer="+info.getConsumerId()+", destinations="+destinations.size()
0:                 +", total="+enqueueCounter+", pending="+getPendingQueueSize()+", dispatched="+dispatchCounter
0:                 +", inflight="+dispatched.size()+", prefetchExtension="+this.prefetchExtension;
0:     public String getClientId(){
0:     public SubscriptionKey getSubscriptionKey(){
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * @param memoryManager
0:      * @param oldPercentUsage
0:      * @param newPercentUsage
0:      * @see org.apache.activemq.memory.UsageListener#onMemoryUseChanged(org.apache.activemq.memory.UsageManager, int,
0:      *      int)
0:      */
0:     public void onMemoryUseChanged(UsageManager memoryManager,int oldPercentUsage,int newPercentUsage){
0:         if(oldPercentUsage>newPercentUsage&&oldPercentUsage>=90){
0:             try{
0:                 dispatchMatched();
0:             }catch(IOException e){
0:                 log.warn("problem calling dispatchMatched",e);
0:             }
0:         }
0:     }
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.StoreDurableSubscriberCursor;
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
0:     public DurableTopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive) throws InvalidSelectorException {
0:         super(broker,context,info,new StoreDurableSubscriberCursor(context.getClientId(),info.getSubscriptionName(),broker.getTempDataStore(),info.getPrefetchSize()));
/////////////////////////////////////////////////////////////////////////
0:     public void activate(UsageManager memoryManager,ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 pending.setUsageManager(memoryManager);
commit:21391ce
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void add(ConnectionContext context, Destination destination) throws Exception {
commit:d2e6062
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     static private final Log log=LogFactory.getLog(PrefetchSubscription.class);
/////////////////////////////////////////////////////////////////////////
0:         log.debug("Deactivating " + this);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void deactivate(boolean keepDurableSubsActive) throws Exception {   
0:    
/////////////////////////////////////////////////////////////////////////
0:             ", total="+enqueueCounter+
0:             ", pending="+getPendingQueueSize()+
0:             ", dispatched="+dispatchCounter+
0:             ", inflight="+dispatched.size()+
0:             ", prefetchExtension="+this.prefetchExtension;
0:             
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
0:             if (pending.isEmpty(topic)) {
0:                 topic.recoverRetroactiveMessages(context, this);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             //If nothing was in the persistent store, then try to use the recovery policy.
0:             if (pending.isEmpty()) {
0:                 for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                     Topic topic = (Topic) iter.next();
0:                     topic.recoverRetroactiveMessages(context, this);
0:                 }
0:             }
commit:a110604
/////////////////////////////////////////////////////////////////////////
0:     protected void doAddRecoveredMessage(MessageReference message) throws Exception {
0:         pending.addRecoveredMessage(message);
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     
commit:ec63977
/////////////////////////////////////////////////////////////////////////
0:         if(!keepDurableSubsActive){
0:             synchronized(pending){
0:                 try{
1:                     pending.reset();
0:                     while(pending.hasNext()){
0:                         MessageReference node=pending.next();
0:                         node.decrementReferenceCount();
1:                         pending.remove();
0:                     }
0:                 }finally{
1:                     pending.release();
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:     public void destroy(){
0:         try{
0:             synchronized(pending){
1:                 pending.reset();
0:                 while(pending.hasNext()){
0:                     MessageReference node=pending.next();
0:                     node.decrementReferenceCount();
0:                 }
0:             }
0:         }finally{
0:             pending.release();
0:             pending.clear();
0:         }
0:         for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:             MessageReference node=(MessageReference)iter.next();
commit:6895d00
/////////////////////////////////////////////////////////////////////////
0:     public void add(ConnectionContext context, Destination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void activate(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             synchronized(pending) {
0:                 pending.start();
0:             }
0:         synchronized(pending){
0:             pending.stop();
0:         }
0:         synchronized(dispatched){
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                 // Mark the dispatched messages as redelivered for next time.
0:                 MessageReference node=(MessageReference)iter.next();
0:                 Integer count=(Integer)redeliveredMessages.get(node.getMessageId());
0:                 if(count!=null){
0:                     redeliveredMessages.put(node.getMessageId(),new Integer(count.intValue()+1));
0:                 }else{
0:                     redeliveredMessages.put(node.getMessageId(),new Integer(1));
0:                 }
0:                 if(keepDurableSubsActive){
0:                     synchronized(pending){
0:                         pending.addMessageFirst(node);
0:                     }
0:                 }else{
0:                     node.decrementReferenceCount();
0:                 }
0:                 iter.remove();
/////////////////////////////////////////////////////////////////////////
0:     public void add(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void destroy() {
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:     public DurableTopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, boolean keepDurableSubsActive,PendingMessageCursor cursor) throws InvalidSelectorException {
0:         super(broker,context,info,cursor);
/////////////////////////////////////////////////////////////////////////
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:        //super(broker,context, info, new StoreDurableSubscriberCursor(context.getClientId(),info.getSubcriptionName(),broker.getTempDataStore(),info.getPrefetchSize()));
0:        //super(broker,context, info, new FilePendingMessageCursor(context.getClientId() + info.getConsumerId().toString(),broker.getTempDataStore()));
0:        super(broker,context,info);
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.StoreDurableSubscriberCursor;
/////////////////////////////////////////////////////////////////////////
0:         //super(broker,context, info, new StoreDurableSubscriberCursor(context.getClientId(),info.getSubcriptionName()));
0:        // super(broker,context, info, new FilePendingMessageCursor(context.getClientId() + info.getConsumerId().toString(),broker.getTempDataStore()));
/////////////////////////////////////////////////////////////////////////
0:             pending.start();
0:         pending.stop();
commit:7d1e6bc
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.JMSException;
0: import org.apache.activemq.broker.region.cursors.FilePendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:         //super(broker,context, info, new FilePendingMessageCursor(context.getClientId() + info.getConsumerId().toString(),broker.getTempDataStore()));
0:         super(broker,context,info);
/////////////////////////////////////////////////////////////////////////
0:             		pending.addMessageFirst(node);
/////////////////////////////////////////////////////////////////////////
0:                 pending.reset();
0: 	            while(pending.hasNext()) {
0: 	                MessageReference node = pending.next();
0: 	                pending.remove();
/////////////////////////////////////////////////////////////////////////
0:             pending.reset();
0: 	        while(pending.hasNext()) {
0: 	            MessageReference node = pending.next();
commit:3601e81
/////////////////////////////////////////////////////////////////////////
0:     
0:     public int pending(){
0:         if (active){
0:             return super.pending();
0:         }
0:         //TODO: need to get from store
0:         
1:         return 0;
0:     }
0:     
commit:4098942
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:     public DurableTopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         super(broker,context, info);
0:     public DurableTopicSubscription(Broker broker,SubscriptionInfo info) throws InvalidSelectorException {
0:         super(broker,null, createFakeConsumerInfo(info));
author:James Strachan
-------------------------------------------------------------------------------
commit:5371cf5
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
0: 
0: import java.io.IOException;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:     public void setSelector(String selector) throws InvalidSelectorException {
0:         throw new UnsupportedOperationException("You cannot dynamically change the selector for durable topic subscriptions");
0:     }
============================================================================