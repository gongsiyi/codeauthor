1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.jdbc;
1:0168a82: 
1:74a7a8b: import java.io.File;
1:74a7a8b: import java.io.IOException;
1:4150650: import java.sql.Connection;
1:74a7a8b: import java.sql.SQLException;
1:74a7a8b: import java.util.Collections;
1:ea70e82: import java.util.HashMap;
1:4b44d31: import java.util.Locale;
1:74a7a8b: import java.util.Set;
1:86cbdfd: import java.util.concurrent.ScheduledFuture;
1:86cbdfd: import java.util.concurrent.ScheduledThreadPoolExecutor;
1:86cbdfd: import java.util.concurrent.ThreadFactory;
1:86cbdfd: import java.util.concurrent.TimeUnit;
11:d29ca2a: 
1:74a7a8b: import javax.sql.DataSource;
1:74a7a8b: 
1:c3801c4: import org.apache.activemq.ActiveMQMessageAudit;
1:90d0c4b: import org.apache.activemq.broker.BrokerService;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:0168a82: import org.apache.activemq.broker.Locker;
1:74846bb: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:933eb2f: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQQueue;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTopic;
1:1cec28c: import org.apache.activemq.command.Message;
1:64f3492: import org.apache.activemq.command.MessageAck;
1:ae840c4: import org.apache.activemq.command.MessageId;
1:a6a6a70: import org.apache.activemq.command.ProducerId;
1:d29ca2a: import org.apache.activemq.openwire.OpenWireFormat;
1:d29ca2a: import org.apache.activemq.store.MessageStore;
1:d29ca2a: import org.apache.activemq.store.PersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:d29ca2a: import org.apache.activemq.store.TransactionStore;
1:d29ca2a: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
1:d29ca2a: import org.apache.activemq.store.memory.MemoryTransactionStore;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:1cec28c: import org.apache.activemq.util.ByteSequence;
1:88acb0e: import org.apache.activemq.util.FactoryFinder;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:24a7626: import org.apache.activemq.util.LongSequenceGenerator;
1:170b86a: import org.apache.activemq.util.ServiceStopper;
1:5156610: import org.apache.activemq.util.ThreadPoolUtils;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * A {@link PersistenceAdapter} implementation using JDBC for persistence
1:d29ca2a:  * storage.
1:0168a82:  *
1:d29ca2a:  * This persistence adapter will correctly remember prepared XA transactions,
1:d29ca2a:  * but it will not keep track of local transaction commits so that operations
1:d29ca2a:  * performed against the Message store are done as a single uow.
1:0168a82:  *
1:68d245f:  * @org.apache.xbean.XBean element="jdbcPersistenceAdapter"
1:0168a82:  *
1:d29ca2a:  */
1:02ef3dc: public class JDBCPersistenceAdapter extends DataSourceServiceSupport implements PersistenceAdapter {
1:d29ca2a: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JDBCPersistenceAdapter.class);
1:8274f09:     private static FactoryFinder adapterFactoryFinder = new FactoryFinder(
1:0168a82:         "META-INF/services/org/apache/activemq/store/jdbc/");
1:8274f09:     private static FactoryFinder lockFactoryFinder = new FactoryFinder(
1:8274f09:         "META-INF/services/org/apache/activemq/store/jdbc/lock/");
1:d29ca2a: 
1:170b86a:     public static final long DEFAULT_LOCK_KEEP_ALIVE_PERIOD = 30 * 1000;
1:d29ca2a: 
1:6583ef1:     private WireFormat wireFormat = new OpenWireFormat();
1:4843dd4:     private Statements statements;
1:d29ca2a:     private JDBCAdapter adapter;
1:ea70e82:     private final JdbcMemoryTransactionStore transactionStore = new JdbcMemoryTransactionStore(this);
1:170b86a:     private ScheduledFuture<?> cleanupTicket;
1:90d0c4b:     private int cleanupPeriod = 1000 * 60 * 5;
1:d29ca2a:     private boolean useExternalMessageReferences;
1:d4a50a7:     private boolean createTablesOnStartup = true;
1:f730323:     private DataSource lockDataSource;
1:00e2f51:     private int transactionIsolation;
1:dbc661f:     private File directory;
1:ddda400:     private boolean changeAutoCommitAllowed = true;
1:0168a82: 
1:c3801c4:     protected int maxProducersToAudit=1024;
1:c3801c4:     protected int maxAuditDepth=1000;
1:a6a6a70:     protected boolean enableAudit=false;
1:ae840c4:     protected int auditRecoveryDepth = 1024;
1:c3801c4:     protected ActiveMQMessageAudit audit;
1:0168a82: 
1:24a7626:     protected LongSequenceGenerator sequenceGenerator = new LongSequenceGenerator();
1:4fbf92d:     protected int maxRows = DefaultJDBCAdapter.MAX_ROWS;
1:ea70e82:     protected final HashMap<ActiveMQDestination, MessageStore> storeCache = new HashMap<>();
1:d29ca2a: 
1:170b86a:     {
1:170b86a:         setLockKeepAlivePeriod(DEFAULT_LOCK_KEEP_ALIVE_PERIOD);
1:d29ca2a:     }
1:64f3492: 
1:d29ca2a:     public JDBCPersistenceAdapter() {
1:a6a6a70:     }
1:8274f09: 
1:d29ca2a:     public JDBCPersistenceAdapter(DataSource ds, WireFormat wireFormat) {
1:a039746:         super(ds);
1:d29ca2a:         this.wireFormat = wireFormat;
1:19881e7:     }
1:19881e7: 
1:0168a82:     @Override
1:933eb2f:     public Set<ActiveMQDestination> getDestinations() {
1:a039746:         TransactionContext c = null;
1:d29ca2a:         try {
1:a039746:             c = getTransactionContext();
1:d29ca2a:             return getAdapter().doGetDestinations(c);
1:f812e34:         } catch (IOException e) {
1:933eb2f:             return emptyDestinationSet();
1:f812e34:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:933eb2f:             return emptyDestinationSet();
1:d29ca2a:         } finally {
1:a039746:             if (c != null) {
1:24a7626:                 try {
1:ae840c4:                     c.close();
2:d29ca2a:                 } catch (Throwable e) {
1:0168a82:                 }
1:d29ca2a:             }
1:170b86a:         }
1:170b86a:     }
1:a6a6a70: 
1:933eb2f:     @SuppressWarnings("unchecked")
1:933eb2f:     private Set<ActiveMQDestination> emptyDestinationSet() {
1:933eb2f:         return Collections.EMPTY_SET;
1:933eb2f:     }
1:19881e7: 
1:ae840c4:     protected void createMessageAudit() {
1:ae840c4:         if (enableAudit && audit == null) {
1:ae840c4:             audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:ae840c4:             TransactionContext c = null;
1:0168a82: 
1:d29ca2a:             try {
1:ae840c4:                 c = getTransactionContext();
1:ae840c4:                 getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {
1:0168a82:                     @Override
1:ae840c4:                     public void messageId(MessageId id) {
1:ae840c4:                         audit.isDuplicate(id);
1:d29ca2a:                     }
1:ae840c4:                 });
1:f812e34:             } catch (Exception e) {
1:ae840c4:                 LOG.error("Failed to reload store message audit for JDBC persistence adapter", e);
1:f812e34:             } finally {
1:ae840c4:                 if (c != null) {
1:d29ca2a:                     try {
1:d29ca2a:                         c.close();
1:f812e34:                     } catch (Throwable e) {
1:d29ca2a:                     }
1:d29ca2a:                 }
1:6ce702d:             }
1:6ce702d:         }
1:24a7626:     }
1:0168a82: 
1:24a7626:     public void initSequenceIdGenerator() {
1:24a7626:         TransactionContext c = null;
1:d29ca2a:         try {
1:24a7626:             c = getTransactionContext();
1:24a7626:             getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {
1:0168a82:                 @Override
1:24a7626:                 public void messageId(MessageId id) {
1:24a7626:                     audit.isDuplicate(id);
1:24a7626:                 }
1:24a7626:             });
1:24a7626:         } catch (Exception e) {
1:24a7626:             LOG.error("Failed to reload store message audit for JDBC persistence adapter", e);
1:d29ca2a:         } finally {
1:24a7626:             if (c != null) {
1:24a7626:                 try {
1:24a7626:                     c.close();
1:d29ca2a:                 } catch (Throwable e) {
1:24a7626:                 }
1:24a7626:             }
1:24a7626:         }
1:ae840c4:     }
1:0168a82: 
1:0168a82:     @Override
1:d29ca2a:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
1:ea70e82:         MessageStore rc = storeCache.get(destination);
1:ea70e82:         if (rc == null) {
1:ea70e82:             MessageStore store = transactionStore.proxy(new JDBCMessageStore(this, getAdapter(), wireFormat, destination, audit));
1:ea70e82:             rc = storeCache.putIfAbsent(destination, store);
1:ea70e82:             if (rc == null) {
1:ea70e82:                 rc = store;
1:ea70e82:             }
1:d29ca2a:         }
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:933eb2f: 
1:0168a82:     @Override
1:d29ca2a:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:ea70e82:         TopicMessageStore rc = (TopicMessageStore) storeCache.get(destination);
1:ea70e82:         if (rc == null) {
1:ea70e82:             TopicMessageStore store = transactionStore.proxy(new JDBCTopicMessageStore(this, getAdapter(), wireFormat, destination, audit));
1:ea70e82:             rc = (TopicMessageStore) storeCache.putIfAbsent(destination, store);
1:ea70e82:             if (rc == null) {
1:ea70e82:                 rc = store;
1:ea70e82:             }
1:d29ca2a:         }
1:d29ca2a:         return rc;
1:ae840c4:     }
1:f812e34: 
1:00e2f51:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination
1:07b6a38:      * @param destination Destination to forget
1:07b6a38:      */
1:0168a82:     @Override
1:07b6a38:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:e73230b:         if (destination.isQueue() && getBrokerService().shouldRecordVirtualDestination(destination)) {
1:e73230b:             try {
1:e73230b:                 removeConsumerDestination(destination);
1:e73230b:             } catch (IOException ioe) {
1:e73230b:                 LOG.error("Failed to remove consumer destination: " + destination, ioe);
1:e73230b:             }
1:e73230b:         }
1:ea70e82:         storeCache.remove(destination);
1:e73230b:     }
1:e73230b: 
1:e73230b:     private void removeConsumerDestination(ActiveMQQueue destination) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext();
1:e73230b:         try {
1:e73230b:             String id = destination.getQualifiedName();
1:e73230b:             getAdapter().doDeleteSubscription(c, destination, id, id);
1:e73230b:         } catch (SQLException e) {
1:e73230b:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:e73230b:             throw IOExceptionSupport.create("Failed to remove consumer destination: " + destination, e);
1:e73230b:         } finally {
1:e73230b:             c.close();
1:e73230b:         }
1:d29ca2a:     }
1:64f3492: 
1:8274f09:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination
2:07b6a38:      * No state retained.... nothing to do
1:b0c2a40:      *
1:07b6a38:      * @param destination Destination to forget
1:07b6a38:      */
1:0168a82:     @Override
1:07b6a38:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:ea70e82:         storeCache.remove(destination);
1:d29ca2a:     }
1:f812e34: 
1:0168a82:     @Override
1:d29ca2a:     public TransactionStore createTransactionStore() throws IOException {
1:d29ca2a:         return this.transactionStore;
1:d29ca2a:     }
1:4843dd4: 
1:0168a82:     @Override
1:d29ca2a:     public long getLastMessageBrokerSequenceId() throws IOException {
1:e73230b:         TransactionContext c = getTransactionContext();
1:4843dd4:         try {
1:1cec28c:             long seq =  getAdapter().doGetLastMessageStoreSequenceId(c);
1:1cec28c:             sequenceGenerator.setLastSequenceId(seq);
1:1cec28c:             long brokerSeq = 0;
1:1cec28c:             if (seq != 0) {
1:952d036:                 byte[] msg = getAdapter().doGetMessageById(c, seq);
1:952d036:                 if (msg != null) {
1:952d036:                     Message last = (Message)wireFormat.unmarshal(new ByteSequence(msg));
1:952d036:                     brokerSeq = last.getMessageId().getBrokerSequenceId();
2:d29ca2a:                 } else {
1:952d036:                    LOG.warn("Broker sequence id wasn't recovered properly, possible duplicates!");
1:952d036:                 }
1:1cec28c:             }
1:1cec28c:             return brokerSeq;
4:d29ca2a:         } catch (SQLException e) {
1:a039746:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to get last broker message id: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:0168a82:     @Override
1:a6a6a70:     public long getLastProducerSequenceId(ProducerId id) throws IOException {
1:a6a6a70:         TransactionContext c = getTransactionContext();
1:a6a6a70:         try {
1:a6a6a70:             return getAdapter().doGetLastProducerSequenceId(c, id);
1:a6a6a70:         } catch (SQLException e) {
1:a6a6a70:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:a6a6a70:             throw IOExceptionSupport.create("Failed to get last broker message id: " + e, e);
1:a6a6a70:         } finally {
1:a6a6a70:             c.close();
1:a6a6a70:         }
1:a6a6a70:     }
1:a6a6a70: 
1:0168a82:     @Override
1:b07821a:     public void allowIOResumption() {}
1:b07821a: 
1:b07821a:     @Override
1:170b86a:     public void init() throws Exception {
1:d29ca2a:         getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());
1:d29ca2a: 
1:d4a50a7:         if (isCreateTablesOnStartup()) {
1:d29ca2a:             TransactionContext transactionContext = getTransactionContext();
1:2a815c2:             transactionContext.getExclusiveConnection();
1:d29ca2a:             transactionContext.begin();
1:d29ca2a:             try {
1:d29ca2a:                 try {
1:d29ca2a:                     getAdapter().doCreateTables(transactionContext);
1:d29ca2a:                 } catch (SQLException e) {
1:fc00993:                     LOG.warn("Cannot create tables due to: " + e);
1:f812e34:                     JDBCPersistenceAdapter.log("Failure Details: ", e);
1:d29ca2a:                 }
1:d29ca2a:             } finally {
1:d29ca2a:                 transactionContext.commit();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:0168a82:     @Override
1:170b86a:     public void doStart() throws Exception {
1:ec9975c: 
1:ec9975c:         if( brokerService!=null ) {
1:ec9975c:           wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:ec9975c:         }
1:ec9975c: 
1:d29ca2a:         // Cleanup the db periodically.
1:d29ca2a:         if (cleanupPeriod > 0) {
1:d2a9f7d:             cleanupTicket = getScheduledThreadPoolExecutor().scheduleWithFixedDelay(new Runnable() {
1:0168a82:                 @Override
1:5a81bbb:                 public void run() {
2:d29ca2a:                     cleanup();
1:5a81bbb:                 }
1:842686a:             }, 0, cleanupPeriod, TimeUnit.MILLISECONDS);
1:5a81bbb:         }
1:ae840c4:         createMessageAudit();
1:d29ca2a:     }
1:d29ca2a: 
1:0168a82:     @Override
1:170b86a:     public synchronized void doStop(ServiceStopper stopper) throws Exception {
1:a8d3908:         if (cleanupTicket != null) {
1:a8d3908:             cleanupTicket.cancel(true);
1:a8d3908:             cleanupTicket = null;
1:d29ca2a:         }
1:165959e:         closeDataSource(getDataSource());
1:d29ca2a:     }
1:5156610: 
1:d29ca2a:     public void cleanup() {
1:a039746:         TransactionContext c = null;
1:d29ca2a:         try {
1:fc00993:             LOG.debug("Cleaning up old messages.");
1:d29ca2a:             c = getTransactionContext();
1:2a815c2:             c.getExclusiveConnection();
1:fe31092:             getAdapter().doDeleteOldMessages(c);
1:f812e34:         } catch (IOException e) {
1:fc00993:             LOG.warn("Old message cleanup failed due to: " + e, e);
1:f812e34:         } catch (SQLException e) {
1:fc00993:             LOG.warn("Old message cleanup failed due to: " + e);
1:f812e34:             JDBCPersistenceAdapter.log("Failure Details: ", e);
1:f812e34:         } finally {
1:a039746:             if (c != null) {
1:d29ca2a:                 try {
1:d29ca2a:                     c.close();
1:f812e34:                 } catch (Throwable e) {
1:d29ca2a:                 }
1:d29ca2a:             }
1:fc00993:             LOG.debug("Cleanup done.");
1:d29ca2a:         }
1:d29ca2a:     }
1:a8d3908: 
1:0168a82:     @Override
1:d29ca2a:     public ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() {
1:d29ca2a:         if (clockDaemon == null) {
1:d29ca2a:             clockDaemon = new ScheduledThreadPoolExecutor(5, new ThreadFactory() {
1:0168a82:                 @Override
1:d29ca2a:                 public Thread newThread(Runnable runnable) {
1:13bbe52:                     Thread thread = new Thread(runnable, "ActiveMQ JDBC PA Scheduled Task");
1:d29ca2a:                     thread.setDaemon(true);
1:d29ca2a:                     return thread;
1:d29ca2a:                 }
1:d29ca2a:             });
1:d29ca2a:         }
1:d29ca2a:         return clockDaemon;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public JDBCAdapter getAdapter() throws IOException {
2:d29ca2a:         if (adapter == null) {
1:4843dd4:             setAdapter(createAdapter());
1:d29ca2a:         }
1:d29ca2a:         return adapter;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:6ce702d:      * @deprecated as of 5.7.0, replaced by {@link #getLocker()}
1:6ce702d:      */
1:6ce702d:     @Deprecated
1:6ce702d:     public Locker getDatabaseLocker() throws IOException {
1:6ce702d:         return getLocker();
1:d29ca2a:     }
1:0168a82: 
1:6ce702d:     /**
1:8274f09:      * Sets the database locker strategy to use to lock the database on startup
1:8274f09:      * @throws IOException
1:d29ca2a:      *
1:6ce702d:      * @deprecated as of 5.7.0, replaced by {@link #setLocker(org.apache.activemq.broker.Locker)}
1:8274f09:      */
1:0168a82:     @Deprecated
1:6ce702d:     public void setDatabaseLocker(Locker locker) throws IOException {
1:6ce702d:         setLocker(locker);
1:8274f09:     }
1:8274f09: 
1:f730323:     public DataSource getLockDataSource() throws IOException {
1:f730323:         if (lockDataSource == null) {
1:f730323:             lockDataSource = getDataSource();
1:f730323:             if (lockDataSource == null) {
1:f730323:                 throw new IllegalArgumentException(
1:f730323:                         "No dataSource property has been configured");
1:d29ca2a:             }
1:d29ca2a:         }
1:f730323:         return lockDataSource;
1:d29ca2a:     }
1:0168a82: 
1:f730323:     public void setLockDataSource(DataSource dataSource) {
1:f730323:         this.lockDataSource = dataSource;
1:165959e:         LOG.info("Using a separate dataSource for locking: "
1:165959e:                             + lockDataSource);
1:d29ca2a:     }
1:0168a82: 
1:74846bb:     @Override
1:90d0c4b:     public BrokerService getBrokerService() {
1:90d0c4b:         return brokerService;
1:d29ca2a:     }
1:0168a82: 
1:6ce702d:     /**
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     protected JDBCAdapter createAdapter() throws IOException {
1:8274f09: 
1:8274f09:         adapter = (JDBCAdapter) loadAdapter(adapterFactoryFinder, "adapter");
1:8274f09: 
1:8274f09:         // Use the default JDBC adapter if the
1:8274f09:         // Database type is not recognized.
1:8274f09:         if (adapter == null) {
1:8274f09:             adapter = new DefaultJDBCAdapter();
1:8274f09:             LOG.debug("Using default JDBC Adapter: " + adapter);
1:8274f09:         }
1:8274f09:         return adapter;
1:8274f09:     }
1:8274f09: 
1:8274f09:     private Object loadAdapter(FactoryFinder finder, String kind) throws IOException {
1:8274f09:         Object adapter = null;
4:d29ca2a:         TransactionContext c = getTransactionContext();
1:d29ca2a:         try {
1:d29ca2a:             try {
1:4843dd4:                 // Make the filename file system safe.
1:4843dd4:                 String dirverName = c.getConnection().getMetaData().getDriverName();
1:4b44d31:                 dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase(Locale.ENGLISH);
1:4843dd4: 
1:d29ca2a:                 try {
1:8274f09:                     adapter = finder.newInstance(dirverName);
1:8274f09:                     LOG.info("Database " + kind + " driver override recognized for : [" + dirverName + "] - adapter: " + adapter.getClass());
1:d29ca2a:                 } catch (Throwable e) {
1:11274e0:                     LOG.info("Database " + kind + " driver override not found for : [" + dirverName
1:8274f09:                              + "].  Will use default implementation.");
1:d29ca2a:                 }
1:4843dd4:             } catch (SQLException e) {
1:8274f09:                 LOG.warn("JDBC error occurred while trying to detect database type for overrides. Will use default implementations: "
1:f812e34:                           + e.getMessage());
1:a039746:                 JDBCPersistenceAdapter.log("Failure Details: ", e);
1:d29ca2a:             }
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:         return adapter;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setAdapter(JDBCAdapter adapter) {
1:d29ca2a:         this.adapter = adapter;
1:4843dd4:         this.adapter.setStatements(getStatements());
1:4fbf92d:         this.adapter.setMaxRows(getMaxRows());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public WireFormat getWireFormat() {
1:d29ca2a:         return wireFormat;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setWireFormat(WireFormat wireFormat) {
1:d29ca2a:         this.wireFormat = wireFormat;
1:d29ca2a:     }
1:d29ca2a: 
1:a039746:     public TransactionContext getTransactionContext(ConnectionContext context) throws IOException {
1:c50dc6f:         if (context == null || isBrokerContext(context)) {
1:d29ca2a:             return getTransactionContext();
1:f812e34:         } else {
1:f812e34:             TransactionContext answer = (TransactionContext)context.getLongTermStoreContext();
1:d29ca2a:             if (answer == null) {
1:00e2f51:                 answer = getTransactionContext();
1:d29ca2a:                 context.setLongTermStoreContext(answer);
1:d29ca2a:             }
1:d29ca2a:             return answer;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:c50dc6f:     private boolean isBrokerContext(ConnectionContext context) {
1:c50dc6f:         return context.getSecurityContext() != null && context.getSecurityContext().isBrokerContext();
1:c50dc6f:     }
1:c50dc6f: 
1:a039746:     public TransactionContext getTransactionContext() throws IOException {
1:4150650:         TransactionContext answer = new TransactionContext(this);
1:00e2f51:         if (transactionIsolation > 0) {
1:00e2f51:             answer.setTransactionIsolation(transactionIsolation);
1:00e2f51:         }
1:00e2f51:         return answer;
1:d29ca2a:     }
1:d29ca2a: 
1:0168a82:     @Override
1:d29ca2a:     public void beginTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         TransactionContext transactionContext = getTransactionContext(context);
1:d29ca2a:         transactionContext.begin();
1:d29ca2a:     }
1:d29ca2a: 
1:0168a82:     @Override
1:d29ca2a:     public void commitTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         TransactionContext transactionContext = getTransactionContext(context);
1:d29ca2a:         transactionContext.commit();
1:d29ca2a:     }
1:d29ca2a: 
1:0168a82:     @Override
1:d29ca2a:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         TransactionContext transactionContext = getTransactionContext(context);
1:d29ca2a:         transactionContext.rollback();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public int getCleanupPeriod() {
1:d29ca2a:         return cleanupPeriod;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Sets the number of milliseconds until the database is attempted to be
1:f812e34:      * cleaned up for durable topics
1:d29ca2a:      */
1:d29ca2a:     public void setCleanupPeriod(int cleanupPeriod) {
1:d29ca2a:         this.cleanupPeriod = cleanupPeriod;
1:d29ca2a:     }
1:d29ca2a: 
1:ddda400:     public boolean isChangeAutoCommitAllowed() {
1:ddda400:         return changeAutoCommitAllowed;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:ddda400:      * Whether the JDBC driver allows to set the auto commit.
1:ddda400:      * Some drivers does not allow changing the auto commit. The default value is true.
1:d29ca2a:      *
1:ddda400:      * @param changeAutoCommitAllowed true to change, false to not change.
1:d29ca2a:      */
1:ddda400:     public void setChangeAutoCommitAllowed(boolean changeAutoCommitAllowed) {
1:ddda400:         this.changeAutoCommitAllowed = changeAutoCommitAllowed;
1:ae840c4:     }
1:d29ca2a: 
1:0168a82:     @Override
1:d29ca2a:     public void deleteAllMessages() throws IOException {
1:d29ca2a:         TransactionContext c = getTransactionContext();
1:2a815c2:         c.getExclusiveConnection();
1:d29ca2a:         try {
1:d29ca2a:             getAdapter().doDropTables(c);
1:d29ca2a:             getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());
1:d29ca2a:             getAdapter().doCreateTables(c);
1:3432a75:             LOG.info("Persistence store purged.");
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create(e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseExternalMessageReferences() {
1:d29ca2a:         return useExternalMessageReferences;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {
1:d29ca2a:         this.useExternalMessageReferences = useExternalMessageReferences;
1:d29ca2a:     }
1:f812e34: 
1:d4a50a7:     public boolean isCreateTablesOnStartup() {
1:d4a50a7:         return createTablesOnStartup;
1:d29ca2a:     }
1:911177e: 
1:ddda400:     /**
1:27f15fd:      * Sets whether or not tables are created on startup
1:6ce702d:      */
1:d4a50a7:     public void setCreateTablesOnStartup(boolean createTablesOnStartup) {
1:d4a50a7:         this.createTablesOnStartup = createTablesOnStartup;
1:ae840c4:     }
1:d29ca2a: 
1:07b6a38:     /**
1:170b86a:      * @deprecated use {@link #setUseLock(boolean)} instead
1:d29ca2a:      *
1:f812e34:      * Sets whether or not an exclusive database lock should be used to enable
1:f812e34:      * JDBC Master/Slave. Enabled by default.
1:ddda400:      */
1:170b86a:     @Deprecated
1:90d0c4b:     public void setUseDatabaseLock(boolean useDatabaseLock) {
1:170b86a:         setUseLock(useDatabaseLock);
1:ae840c4:     }
1:d29ca2a: 
1:fc00993:     public static void log(String msg, SQLException e) {
1:f812e34:         String s = msg + e.getMessage();
1:f812e34:         while (e.getNextException() != null) {
1:911177e:             e = e.getNextException();
1:f812e34:             s += ", due to: " + e.getMessage();
1:911177e:         }
1:5fb5235:         LOG.warn(s, e);
1:911177e:     }
1:911177e: 
1:4843dd4:     public Statements getStatements() {
1:f812e34:         if (statements == null) {
1:4843dd4:             statements = new Statements();
1:4843dd4:         }
1:4843dd4:         return statements;
1:4843dd4:     }
1:4843dd4: 
1:4843dd4:     public void setStatements(Statements statements) {
1:4843dd4:         this.statements = statements;
1:0168a82:         if (adapter != null) {
1:0168a82:             this.adapter.setStatements(getStatements());
1:0168a82:         }
1:18d616c:     }
1:18d616c: 
1:18d616c:     /**
1:f812e34:      * @param usageManager The UsageManager that is controlling the
1:f812e34:      *                destination's memory usage.
1:18d616c:      */
1:0168a82:     @Override
1:6d8e2c5:     public void setUsageManager(SystemUsage usageManager) {
1:4843dd4:     }
1:4843dd4: 
1:0168a82:     @Override
1:170b86a:     public Locker createDefaultLocker() throws IOException {
1:486e637:         Locker locker = (Locker) loadAdapter(lockFactoryFinder, "lock");
1:8274f09:         if (locker == null) {
1:8274f09:             locker = new DefaultDatabaseLocker();
1:8274f09:             LOG.debug("Using default JDBC Locker: " + locker);
1:8274f09:         }
1:170b86a:         locker.configure(this);
1:19881e7:         return locker;
1:ae840c4:     }
1:d29ca2a: 
1:0168a82:     @Override
1:f812e34:     public void setBrokerName(String brokerName) {
1:c3801c4:     }
1:d29ca2a: 
1:0168a82:     @Override
1:f812e34:     public String toString() {
1:8274f09:         return "JDBCPersistenceAdapter(" + super.toString() + ")";
1:c3801c4:     }
1:d29ca2a: 
1:0168a82:     @Override
1:f812e34:     public void setDirectory(File dir) {
1:dbc661f:         this.directory=dir;
1:f812e34:     }
1:0168a82: 
1:0168a82:     @Override
1:dbc661f:     public File getDirectory(){
1:dbc661f:         if (this.directory==null && brokerService != null){
1:dbc661f:             this.directory=brokerService.getBrokerDataDirectory();
4:c3801c4:         }
1:dbc661f:         return this.directory;
1:c3801c4:     }
1:f812e34: 
1:4150650:     // interesting bit here is proof that DB is ok
1:0168a82:     @Override
1:f812e34:     public void checkpoint(boolean sync) throws IOException {
1:4150650:         // by pass TransactionContext to avoid IO Exception handler
1:4150650:         Connection connection = null;
1:4150650:         try {
1:4150650:             connection = getDataSource().getConnection();
1:b588d6c:             if (!connection.isValid(10)) {
1:b588d6c:                 throw new IOException("isValid(10) failed for: " + connection);
1:b588d6c:             }
1:4150650:         } catch (SQLException e) {
1:4150650:             LOG.debug("Could not get JDBC connection for checkpoint: " + e);
1:4150650:             throw IOExceptionSupport.create(e);
1:4150650:         } finally {
1:4150650:             if (connection != null) {
1:4150650:                 try {
1:4150650:                     connection.close();
1:4150650:                 } catch (Throwable ignored) {
1:4150650:                 }
1:4150650:             }
1:4150650:         }
1:c3801c4:     }
1:d29ca2a: 
1:170b86a:     @Override
1:6d8e2c5:     public long size(){
1:6d8e2c5:         return 0;
1:e0bdc01:     }
1:e0bdc01: 
1:07b6a38:     /**
1:170b86a:      * @deprecated use {@link Locker#setLockAcquireSleepInterval(long)} instead
1:d29ca2a:      *
1:19881e7:      * millisecond interval between lock acquire attempts, applied to newly created DefaultDatabaseLocker
1:19881e7:      * not applied if DataBaseLocker is injected.
1:d29ca2a:      *
1:19881e7:      */
1:0168a82:     @Deprecated
1:170b86a:     public void setLockAcquireSleepInterval(long lockAcquireSleepInterval) throws IOException {
1:170b86a:         getLocker().setLockAcquireSleepInterval(lockAcquireSleepInterval);
1:19881e7:     }
1:00e2f51: 
1:00e2f51:     /**
1:00e2f51:      * set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
1:00e2f51:      * This allowable dirty isolation level may not be achievable in clustered DB environments
1:06cbebc:      * so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
1:00e2f51:      * see isolation level constants in {@link java.sql.Connection}
1:00e2f51:      * @param transactionIsolation the isolation level to use
1:00e2f51:      */
1:00e2f51:     public void setTransactionIsolation(int transactionIsolation) {
1:00e2f51:         this.transactionIsolation = transactionIsolation;
1:00e2f51:     }
1:e0bdc01: 
1:0168a82:     public int getMaxProducersToAudit() {
1:0168a82:         return maxProducersToAudit;
1:0168a82:     }
1:d29ca2a: 
1:0168a82:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:0168a82:         this.maxProducersToAudit = maxProducersToAudit;
1:0168a82:     }
1:d29ca2a: 
1:0168a82:     public int getMaxAuditDepth() {
1:0168a82:         return maxAuditDepth;
1:0168a82:     }
1:d29ca2a: 
1:0168a82:     public void setMaxAuditDepth(int maxAuditDepth) {
1:0168a82:         this.maxAuditDepth = maxAuditDepth;
1:0168a82:     }
1:d29ca2a: 
1:0168a82:     public boolean isEnableAudit() {
1:0168a82:         return enableAudit;
1:0168a82:     }
1:d29ca2a: 
1:0168a82:     public void setEnableAudit(boolean enableAudit) {
1:0168a82:         this.enableAudit = enableAudit;
1:0168a82:     }
1:d29ca2a: 
1:ae840c4:     public int getAuditRecoveryDepth() {
1:ae840c4:         return auditRecoveryDepth;
1:e0bdc01:     }
1:d29ca2a: 
1:ae840c4:     public void setAuditRecoveryDepth(int auditRecoveryDepth) {
1:ae840c4:         this.auditRecoveryDepth = auditRecoveryDepth;
1:24a7626:     }
1:d29ca2a: 
1:24a7626:     public long getNextSequenceId() {
1:6348d11:         return sequenceGenerator.getNextSequenceId();
1:4fbf92d:     }
1:4fbf92d: 
1:4fbf92d:     public int getMaxRows() {
1:4fbf92d:         return maxRows;
1:4fbf92d:     }
1:4fbf92d: 
1:4fbf92d:     /*
1:4fbf92d:      * the max rows return from queries, with sparse selectors this may need to be increased
1:4fbf92d:      */
1:4fbf92d:     public void setMaxRows(int maxRows) {
1:4fbf92d:         this.maxRows = maxRows;
1:4fbf92d:     }
1:64f3492: 
1:64f3492:     public void recover(JdbcMemoryTransactionStore jdbcMemoryTransactionStore) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext();
1:64f3492:         try {
1:64f3492:             getAdapter().doRecoverPreparedOps(c, jdbcMemoryTransactionStore);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to recover from: " + jdbcMemoryTransactionStore + ". Reason: " + e,e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:bd45d93:     public void commitAdd(ConnectionContext context, final MessageId messageId, final long preparedSequenceId, final long newSequence) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:bd45d93:             getAdapter().doCommitAddOp(c, preparedSequenceId, newSequence);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to commit add: " + messageId + ". Reason: " + e, e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void commitRemove(ConnectionContext context, MessageAck ack) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:72613aa:             getAdapter().doRemoveMessage(c, (Long)ack.getLastMessageId().getEntryLocator(), null);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to commit last ack: " + ack + ". Reason: " + e,e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void commitLastAck(ConnectionContext context, long xidLastAck, long priority, ActiveMQDestination destination, String subName, String clientId) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:64f3492:             getAdapter().doSetLastAck(c, destination, null, clientId, subName, xidLastAck, priority);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to commit last ack with priority: " + priority + " on " + destination + " for " + subName + ":" + clientId + ". Reason: " + e,e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void rollbackLastAck(ConnectionContext context, JDBCTopicMessageStore store, MessageAck ack, String subName, String clientId) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:64f3492:             byte priority = (byte) store.getCachedStoreSequenceId(c, store.getDestination(), ack.getLastMessageId())[1];
1:64f3492:             getAdapter().doClearLastAck(c, store.getDestination(), priority, clientId, subName);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to rollback last ack: " + ack + " on " +  store.getDestination() + " for " + subName + ":" + clientId + ". Reason: " + e,e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492:     // after recovery there is no record of the original messageId for the ack
1:64f3492:     public void rollbackLastAck(ConnectionContext context, byte priority, ActiveMQDestination destination, String subName, String clientId) throws IOException {
1:64f3492:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:64f3492:             getAdapter().doClearLastAck(c, destination, priority, clientId, subName);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to rollback last ack with priority: " + priority + " on " + destination + " for " + subName + ":" + clientId + ". Reason: " + e, e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:ad770ea:     long[] getStoreSequenceIdForMessageId(ConnectionContext context, MessageId messageId, ActiveMQDestination destination) throws IOException {
1:64f3492:         long[] result = new long[]{-1, Byte.MAX_VALUE -1};
1:ad770ea:         TransactionContext c = getTransactionContext(context);
1:64f3492:         try {
1:64f3492:             result = adapter.getStoreSequenceId(c, destination, messageId);
1:64f3492:         } catch (SQLException e) {
1:64f3492:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:64f3492:             throw IOExceptionSupport.create("Failed to get store sequenceId for messageId: " + messageId +", on: " + destination + ". Reason: " + e, e);
1:64f3492:         } finally {
1:64f3492:             c.close();
1:64f3492:         }
1:64f3492:         return result;
1:64f3492:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:74846bb:         throw new UnsupportedOperationException();
1:74846bb:     }
1:24a7626: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:72613aa
/////////////////////////////////////////////////////////////////////////
1:             getAdapter().doRemoveMessage(c, (Long)ack.getLastMessageId().getEntryLocator(), null);
commit:bd45d93
/////////////////////////////////////////////////////////////////////////
1:     public void commitAdd(ConnectionContext context, final MessageId messageId, final long preparedSequenceId, final long newSequence) throws IOException {
1:             getAdapter().doCommitAddOp(c, preparedSequenceId, newSequence);
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     private final JdbcMemoryTransactionStore transactionStore = new JdbcMemoryTransactionStore(this);
/////////////////////////////////////////////////////////////////////////
1:     protected final HashMap<ActiveMQDestination, MessageStore> storeCache = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         MessageStore rc = storeCache.get(destination);
1:         if (rc == null) {
1:             MessageStore store = transactionStore.proxy(new JDBCMessageStore(this, getAdapter(), wireFormat, destination, audit));
1:             rc = storeCache.putIfAbsent(destination, store);
1:             if (rc == null) {
1:                 rc = store;
1:             }
1:         TopicMessageStore rc = (TopicMessageStore) storeCache.get(destination);
1:         if (rc == null) {
1:             TopicMessageStore store = transactionStore.proxy(new JDBCTopicMessageStore(this, getAdapter(), wireFormat, destination, audit));
1:             rc = (TopicMessageStore) storeCache.putIfAbsent(destination, store);
1:             if (rc == null) {
1:                 rc = store;
1:             }
/////////////////////////////////////////////////////////////////////////
1:         storeCache.remove(destination);
/////////////////////////////////////////////////////////////////////////
1:         storeCache.remove(destination);
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
0:             messageId.setEntryLocator(preparedSequenceId);
commit:b07821a
/////////////////////////////////////////////////////////////////////////
1:     public void allowIOResumption() {}
1: 
1:     @Override
commit:c50dc6f
/////////////////////////////////////////////////////////////////////////
1:         if (context == null || isBrokerContext(context)) {
/////////////////////////////////////////////////////////////////////////
1:     private boolean isBrokerContext(ConnectionContext context) {
1:         return context.getSecurityContext() != null && context.getSecurityContext().isBrokerContext();
1:     }
1: 
commit:2a815c2
/////////////////////////////////////////////////////////////////////////
1:             transactionContext.getExclusiveConnection();
/////////////////////////////////////////////////////////////////////////
1:             c.getExclusiveConnection();
/////////////////////////////////////////////////////////////////////////
1:         c.getExclusiveConnection();
commit:165959e
/////////////////////////////////////////////////////////////////////////
1:         closeDataSource(getDataSource());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Using a separate dataSource for locking: "
1:                             + lockDataSource);
commit:3155c62
/////////////////////////////////////////////////////////////////////////
0:     public void commitAdd(ConnectionContext context, MessageId messageId, long preparedSequenceId) throws IOException {
0:             long sequence = (Long)messageId.getEntryLocator();
0:             getAdapter().doCommitAddOp(c, preparedSequenceId, sequence);
commit:bc3587c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ad770ea
/////////////////////////////////////////////////////////////////////////
1:     long[] getStoreSequenceIdForMessageId(ConnectionContext context, MessageId messageId, ActiveMQDestination destination) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:             long sequence = (Long)messageId.getFutureOrSequenceLong();
/////////////////////////////////////////////////////////////////////////
0:             getAdapter().doRemoveMessage(c, (Long)ack.getLastMessageId().getFutureOrSequenceLong(), null);
commit:6348d11
/////////////////////////////////////////////////////////////////////////
1:         return sequenceGenerator.getNextSequenceId();
commit:b588d6c
/////////////////////////////////////////////////////////////////////////
1:             if (!connection.isValid(10)) {
1:                 throw new IOException("isValid(10) failed for: " + connection);
1:             }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:5156610
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:         
0:         ThreadPoolUtils.shutdown(clockDaemon);        
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:         throw new UnsupportedOperationException();
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:13bbe52
/////////////////////////////////////////////////////////////////////////
1:                     Thread thread = new Thread(runnable, "ActiveMQ JDBC PA Scheduled Task");
commit:02ef3dc
/////////////////////////////////////////////////////////////////////////
1: public class JDBCPersistenceAdapter extends DataSourceServiceSupport implements PersistenceAdapter {
/////////////////////////////////////////////////////////////////////////
commit:486e637
/////////////////////////////////////////////////////////////////////////
1:         Locker locker = (Locker) loadAdapter(lockFactoryFinder, "lock");
commit:dc258ab
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("databaselocker keepalive resulted in: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:         LOG.info(brokerService.getBrokerName() + ", no longer able to keep the exclusive lock so giving up being a master");
commit:64f3492
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
0:             transactionStore = new JdbcMemoryTransactionStore(this);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void recover(JdbcMemoryTransactionStore jdbcMemoryTransactionStore) throws IOException {
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             getAdapter().doRecoverPreparedOps(c, jdbcMemoryTransactionStore);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to recover from: " + jdbcMemoryTransactionStore + ". Reason: " + e,e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
0:     public void commitAdd(ConnectionContext context, MessageId messageId) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
1:         try {
0:             long sequence = (Long)messageId.getDataLocator();
0:             getAdapter().doCommitAddOp(c, sequence);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to commit add: " + messageId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public void commitRemove(ConnectionContext context, MessageAck ack) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
1:         try {
0:             getAdapter().doRemoveMessage(c, (Long)ack.getLastMessageId().getDataLocator(), null);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to commit last ack: " + ack + ". Reason: " + e,e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1: 
1:     public void commitLastAck(ConnectionContext context, long xidLastAck, long priority, ActiveMQDestination destination, String subName, String clientId) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
1:         try {
1:             getAdapter().doSetLastAck(c, destination, null, clientId, subName, xidLastAck, priority);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to commit last ack with priority: " + priority + " on " + destination + " for " + subName + ":" + clientId + ". Reason: " + e,e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public void rollbackLastAck(ConnectionContext context, JDBCTopicMessageStore store, MessageAck ack, String subName, String clientId) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
1:         try {
1:             byte priority = (byte) store.getCachedStoreSequenceId(c, store.getDestination(), ack.getLastMessageId())[1];
1:             getAdapter().doClearLastAck(c, store.getDestination(), priority, clientId, subName);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to rollback last ack: " + ack + " on " +  store.getDestination() + " for " + subName + ":" + clientId + ". Reason: " + e,e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     // after recovery there is no record of the original messageId for the ack
1:     public void rollbackLastAck(ConnectionContext context, byte priority, ActiveMQDestination destination, String subName, String clientId) throws IOException {
1:         TransactionContext c = getTransactionContext(context);
1:         try {
1:             getAdapter().doClearLastAck(c, destination, priority, clientId, subName);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to rollback last ack with priority: " + priority + " on " + destination + " for " + subName + ":" + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
0:     long[] getStoreSequenceIdForMessageId(MessageId messageId, ActiveMQDestination destination) throws IOException {
1:         long[] result = new long[]{-1, Byte.MAX_VALUE -1};
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             result = adapter.getStoreSequenceId(c, destination, messageId);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to get store sequenceId for messageId: " + messageId +", on: " + destination + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:         return result;
1:     }
1: 
commit:e73230b
/////////////////////////////////////////////////////////////////////////
1:         if (destination.isQueue() && getBrokerService().shouldRecordVirtualDestination(destination)) {
1:             try {
1:                 removeConsumerDestination(destination);
1:             } catch (IOException ioe) {
1:                 LOG.error("Failed to remove consumer destination: " + destination, ioe);
1:             }
1:         }
1:     }
1: 
1:     private void removeConsumerDestination(ActiveMQQueue destination) throws IOException {
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             String id = destination.getQualifiedName();
1:             getAdapter().doDeleteSubscription(c, destination, id, id);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to remove consumer destination: " + destination, e);
1:         } finally {
1:             c.close();
1:         }
commit:b6f63b0
/////////////////////////////////////////////////////////////////////////
commit:842686a
/////////////////////////////////////////////////////////////////////////
1:             }, 0, cleanupPeriod, TimeUnit.MILLISECONDS);
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:             getAdapter().doDeleteOldMessages(c);
commit:4150650
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:         TransactionContext answer = new TransactionContext(this);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failure occurred while stopping broker");
/////////////////////////////////////////////////////////////////////////
1:     // interesting bit here is proof that DB is ok
1:         // by pass TransactionContext to avoid IO Exception handler
1:         Connection connection = null;
1:         try {
1:             connection = getDataSource().getConnection();
1:         } catch (SQLException e) {
1:             LOG.debug("Could not get JDBC connection for checkpoint: " + e);
1:             throw IOExceptionSupport.create(e);
1:         } finally {
1:             if (connection != null) {
1:                 try {
1:                     connection.close();
1:                 } catch (Throwable ignored) {
1:                 }
1:             }
1:         }
commit:afa3f24
/////////////////////////////////////////////////////////////////////////
commit:4fbf92d
/////////////////////////////////////////////////////////////////////////
1:     protected int maxRows = DefaultJDBCAdapter.MAX_ROWS;
/////////////////////////////////////////////////////////////////////////
1:         this.adapter.setMaxRows(getMaxRows());
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public int getMaxRows() {
1:         return maxRows;
1:     }
1: 
1:     /*
1:      * the max rows return from queries, with sparse selectors this may need to be increased
1:      */
1:     public void setMaxRows(int maxRows) {
1:         this.maxRows = maxRows;
1:     }
commit:4679c8a
/////////////////////////////////////////////////////////////////////////
0:             getAdapter().doDeleteOldMessages(c, false);
0:             getAdapter().doDeleteOldMessages(c, true);
commit:06cbebc
/////////////////////////////////////////////////////////////////////////
1:      * so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Persistence store purged.");
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean enableAudit=false;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public long getLastProducerSequenceId(ProducerId id) throws IOException {
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             return getAdapter().doGetLastProducerSequenceId(c, id);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to get last broker message id: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }    
commit:5fb5235
/////////////////////////////////////////////////////////////////////////
1:         LOG.warn(s, e);
commit:11274e0
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Database " + kind + " driver override not found for : [" + dirverName
commit:d2a9f7d
/////////////////////////////////////////////////////////////////////////
1:             cleanupTicket = getScheduledThreadPoolExecutor().scheduleWithFixedDelay(new Runnable() {
commit:00e2f51
/////////////////////////////////////////////////////////////////////////
1:     private int transactionIsolation;
/////////////////////////////////////////////////////////////////////////
1:                 answer = getTransactionContext();
/////////////////////////////////////////////////////////////////////////
0:         TransactionContext answer = new TransactionContext(getDataSource());
1:         if (transactionIsolation > 0) {
1:             answer.setTransactionIsolation(transactionIsolation);
1:         }
1:         return answer;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:     
1:     /**
1:      * set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
1:      * This allowable dirty isolation level may not be achievable in clustered DB environments
0:      * so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABE_READ
1:      * see isolation level constants in {@link java.sql.Connection}
1:      * @param transactionIsolation the isolation level to use
1:      */
1:     public void setTransactionIsolation(int transactionIsolation) {
1:         this.transactionIsolation = transactionIsolation;
1:     }
commit:8274f09
/////////////////////////////////////////////////////////////////////////
1:     private static FactoryFinder adapterFactoryFinder = new FactoryFinder(
1:     private static FactoryFinder lockFactoryFinder = new FactoryFinder(
1:                                                                     "META-INF/services/org/apache/activemq/store/jdbc/lock/");
/////////////////////////////////////////////////////////////////////////
0:             setDatabaseLocker(loadDataBaseLocker());
1: 
1:     /**
1:      * Sets the database locker strategy to use to lock the database on startup
1:      * @throws IOException 
1:      */
0:     public void setDatabaseLocker(DatabaseLocker locker) throws IOException {
0:         databaseLocker = locker;
0:         databaseLocker.setPersistenceAdapter(this);
0:         databaseLocker.setLockAcquireSleepInterval(getLockAcquireSleepInterval());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:        
1:         adapter = (JDBCAdapter) loadAdapter(adapterFactoryFinder, "adapter");
1:        
1:         // Use the default JDBC adapter if the
1:         // Database type is not recognized.
1:         if (adapter == null) {
1:             adapter = new DefaultJDBCAdapter();
1:             LOG.debug("Using default JDBC Adapter: " + adapter);
1:         }
1:         return adapter;
1:     }
1: 
1:     private Object loadAdapter(FactoryFinder finder, String kind) throws IOException {
1:         Object adapter = null;
1:                     adapter = finder.newInstance(dirverName);
1:                     LOG.info("Database " + kind + " driver override recognized for : [" + dirverName + "] - adapter: " + adapter.getClass());
0:                     LOG.warn("Database " + kind + " driver override not found for : [" + dirverName
1:                              + "].  Will use default implementation.");
1:                 LOG.warn("JDBC error occurred while trying to detect database type for overrides. Will use default implementations: "
/////////////////////////////////////////////////////////////////////////
0:     protected DatabaseLocker loadDataBaseLocker() throws IOException {
0:         DatabaseLocker locker = (DefaultDatabaseLocker) loadAdapter(lockFactoryFinder, "lock");       
1:         if (locker == null) {
1:             locker = new DefaultDatabaseLocker();
1:             LOG.debug("Using default JDBC Locker: " + locker);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return "JDBCPersistenceAdapter(" + super.toString() + ")";
commit:a8d3908
/////////////////////////////////////////////////////////////////////////
0:     private ScheduledFuture<?> cleanupTicket, keepAliveTicket;
/////////////////////////////////////////////////////////////////////////
0:                     keepAliveTicket = getScheduledThreadPoolExecutor().scheduleAtFixedRate(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             cleanupTicket = getScheduledThreadPoolExecutor().scheduleAtFixedRate(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         if (cleanupTicket != null) {
1:             cleanupTicket.cancel(true);
1:             cleanupTicket = null;
0:         if (keepAliveTicket != null) {
0:             keepAliveTicket.cancel(false);
0:             keepAliveTicket = null;
1:         
0:         // do not shutdown clockDaemon as it may kill the thread initiating shutdown
commit:b22832e
/////////////////////////////////////////////////////////////////////////
0:         if (databaseLocker == null && isUseDatabaseLock()) {
commit:19881e7
/////////////////////////////////////////////////////////////////////////
0:     private long lockAcquireSleepInterval = DefaultDatabaseLocker.DEFAULT_LOCK_ACQUIRE_SLEEP_INTERVAL;
/////////////////////////////////////////////////////////////////////////
0:         DefaultDatabaseLocker locker = new DefaultDatabaseLocker(this);
0:         locker.setLockAcquireSleepInterval(getLockAcquireSleepInterval());
1:         return locker;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public long getLockAcquireSleepInterval() {
0:         return lockAcquireSleepInterval;
1:     }
1: 
0:     /*
1:      * millisecond interval between lock acquire attempts, applied to newly created DefaultDatabaseLocker
1:      * not applied if DataBaseLocker is injected.
1:      */
0:     public void setLockAcquireSleepInterval(long lockAcquireSleepInterval) {
0:         this.lockAcquireSleepInterval = lockAcquireSleepInterval;
1:     }
commit:5a81bbb
/////////////////////////////////////////////////////////////////////////
0:                 if (lockKeepAlivePeriod > 0) {
0:                     getScheduledThreadPoolExecutor().scheduleAtFixedRate(new Runnable() {
1:                         public void run() {
0:                             databaseLockKeepAlive();
1:                         }
0:                     }, lockKeepAlivePeriod, lockKeepAlivePeriod, TimeUnit.MILLISECONDS);
1:                 }
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0168a82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Locker;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
1:         "META-INF/services/org/apache/activemq/store/jdbc/");
0:         "META-INF/services/org/apache/activemq/store/jdbc/lock/");
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Deprecated
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (adapter != null) {
1:             this.adapter.setStatements(getStatements());
1:         }
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Deprecated
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
1:     }
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
1:     }
1:     public int getMaxAuditDepth() {
1:         return maxAuditDepth;
1:     }
1:     public void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
1:     }
1:     public boolean isEnableAudit() {
1:         return enableAudit;
1:     }
1:     public void setEnableAudit(boolean enableAudit) {
1:         this.enableAudit = enableAudit;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1: 
1:         if( brokerService!=null ) {
1:           wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:         }
1: 
commit:1399cf9
/////////////////////////////////////////////////////////////////////////
0:             long sequence = (Long)messageId.getEntryLocator();
/////////////////////////////////////////////////////////////////////////
0:             getAdapter().doRemoveMessage(c, (Long)ack.getLastMessageId().getEntryLocator(), null);
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:529e5c2
/////////////////////////////////////////////////////////////////////////
0:             transactionStore = new MemoryTransactionStore(this);
commit:b4f65ba
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failure occured while stopping broker");
commit:60c2605
/////////////////////////////////////////////////////////////////////////
0:     public long getLockKeepAlivePeriod() {
0:     public void setLockKeepAlivePeriod(long lockKeepAlivePeriod) {
commit:e0bdc01
/////////////////////////////////////////////////////////////////////////
0:     private long lockKeepAlivePeriod = 1000*30;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int getLockKeepAlivePeriod() {
0:         return lockKeepAlivePeriod;
1:     }
1: 
0:     public void setLockKeepAlivePeriod(int lockKeepAlivePeriod) {
0:         this.lockKeepAlivePeriod = lockKeepAlivePeriod;
1:     }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0:     private int lockKeepAlivePeriod;
/////////////////////////////////////////////////////////////////////////
1:     public Set<ActiveMQDestination> getDestinations() {
1:             return emptyDestinationSet();
1:             return emptyDestinationSet();
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1:     private Set<ActiveMQDestination> emptyDestinationSet() {
1:         return Collections.EMPTY_SET;
1:     }
1: 
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JDBCPersistenceAdapter.class);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Cannot create tables due to: " + e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("No databaseLocker configured for the JDBC Persistence Adapter");
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Cleaning up old messages.");
1:             LOG.warn("Old message cleanup failed due to: " + e, e);
1:             LOG.warn("Old message cleanup failed due to: " + e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Cleanup done.");
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Database driver recognized: [" + dirverName + "]");
0:                     LOG.warn("Database driver NOT recognized: [" + dirverName
0:                 LOG
/////////////////////////////////////////////////////////////////////////
1:     public static void log(String msg, SQLException e) {
0:         LOG.debug(s, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to get database when trying keepalive: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("No longer able to keep the exclusive lock so giving up being a master");
0:             LOG.warn("Failed to stop broker");
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.IOException;
1: import java.sql.SQLException;
1: import java.util.Collections;
1: import java.util.Set;
1: import javax.sql.DataSource;
1: 
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0: public class JDBCPersistenceAdapter extends DataSourceSupport implements PersistenceAdapter,
0:     BrokerServiceAware {
0:     private static FactoryFinder factoryFinder = new FactoryFinder(
0:                                                                    "META-INF/services/org/apache/activemq/store/jdbc/");
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
1:         } catch (SQLException e) {
1:         } finally {
1:                 } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1:                     JDBCPersistenceAdapter.log("Failure Details: ", e);
1: 
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
1:         } catch (SQLException e) {
1:         } finally {
1:                 } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         JDBCAdapter adapter = null;
/////////////////////////////////////////////////////////////////////////
0:                     adapter = (DefaultJDBCAdapter)factoryFinder.newInstance(dirverName);
0:                              + "].  Will use default JDBC implementation.");
0:                 log
0:                     .warn("JDBC error occurred while trying to detect database type.  Will use default JDBC implementation: "
1:                           + e.getMessage());
1:                 JDBCPersistenceAdapter.log("Failure Details: ", e);
/////////////////////////////////////////////////////////////////////////
1:             TransactionContext answer = (TransactionContext)context.getLongTermStoreContext();
/////////////////////////////////////////////////////////////////////////
1:      * Sets the number of milliseconds until the database is attempted to be
1:      * cleaned up for durable topics
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Sets whether or not an exclusive database lock should be used to enable
1:      * JDBC Master/Slave. Enabled by default.
1:         String s = msg + e.getMessage();
1:         while (e.getNextException() != null) {
1:             s += ", due to: " + e.getMessage();
1:         if (statements == null) {
/////////////////////////////////////////////////////////////////////////
1:      * @param usageManager The UsageManager that is controlling the
1:      *                destination's memory usage.
/////////////////////////////////////////////////////////////////////////
0:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setBrokerName(String brokerName) {
1:     public String toString() {
0:         return "JDBCPersistenceAdaptor(" + super.toString() + ")";
1:     public void setDirectory(File dir) {
1:     }
1: 
1:     public void checkpoint(boolean sync) throws IOException {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ScheduledFuture;
1: import java.util.concurrent.ScheduledThreadPoolExecutor;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.TimeUnit;
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.FactoryFinder;
1: import org.apache.activemq.wireformat.WireFormat;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @param usageManager The UsageManager that is controlling the destination's memory usage.
1:      */
0:     public void setUsageManager(UsageManager usageManager) {
1:     }
1: 
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.util.FactoryFinder;
commit:6583ef1
/////////////////////////////////////////////////////////////////////////
1:     private WireFormat wireFormat = new OpenWireFormat();
commit:4843dd4
/////////////////////////////////////////////////////////////////////////
1:     private Statements statements;
/////////////////////////////////////////////////////////////////////////
1:             setAdapter(createAdapter());
/////////////////////////////////////////////////////////////////////////
1:             try {
1: 
1:                 // Make the filename file system safe.
1:                 String dirverName = c.getConnection().getMetaData().getDriverName();
0:                 dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase();
0:                     adapter = (DefaultJDBCAdapter) factoryFinder.newInstance(dirverName);
0:                     log.info("Database driver recognized: [" + dirverName + "]");
0:                     log.warn("Database driver NOT recognized: [" + dirverName
0:                             + "].  Will use default JDBC implementation.");
1: 
1:             } catch (SQLException e) {
0:                 log.warn("JDBC error occurred while trying to detect database type.  Will use default JDBC implementation: "
0:                                 + e.getMessage());
0:                 JDBCPersistenceAdapter.log("Failure Details: ",e);
/////////////////////////////////////////////////////////////////////////
1:         this.adapter.setStatements(getStatements());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public Statements getStatements() {
0:         if( statements == null ) {
1:             statements = new Statements();
1:         }
1:         return statements;
1:     }
1: 
1:     public void setStatements(Statements statements) {
1:         this.statements = statements;
1:     }
1: 
commit:911177e
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:                 log.warn("Cannot create tables due to: " + e);
0:                 JDBCPersistenceAdapter.log("Failure Details: ",e);
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Old message cleanup failed due to: " + e);
0:             JDBCPersistenceAdapter.log("Failure Details: ",e);
/////////////////////////////////////////////////////////////////////////
0:                     log.warn("JDBC error occurred while trying to detect database type.  Will use default JDBC implementation: "
0:                     JDBCPersistenceAdapter.log("Failure Details: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
1:     
0:     static public void log(String msg, SQLException e) {
0:         String s = msg+e.getMessage();
0:         while( e.getNextException() != null ) {
1:             e = e.getNextException();
0:             s += ", due to: "+e.getMessage();
1:         }
0:         log.debug(s, e);
1:     }
1: 
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean element="jdbcPersistenceAdapter"
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
0: import java.io.IOException;
0: import java.sql.SQLException;
0: import java.util.Collections;
0: import java.util.Set;
1: 
0: import javax.sql.DataSource;
1: 
0: import org.activeio.FactoryFinder;
0: import org.activeio.command.WireFormat;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
1: import org.apache.activemq.store.memory.MemoryTransactionStore;
1: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ScheduledFuture;
0: import edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: 
1: /**
1:  * A {@link PersistenceAdapter} implementation using JDBC for persistence
1:  * storage.
1:  * 
1:  * This persistence adapter will correctly remember prepared XA transactions,
1:  * but it will not keep track of local transaction commits so that operations
1:  * performed against the Message store are done as a single uow.
1:  * 
0:  * @org.xbean.XBean element="jdbcPersistenceAdapter"
1:  * 
0:  * @version $Revision: 1.9 $
1:  */
0: public class JDBCPersistenceAdapter implements PersistenceAdapter {
1: 
0:     private static final Log log = LogFactory.getLog(JDBCPersistenceAdapter.class);
0:     private static FactoryFinder factoryFinder = new FactoryFinder("META-INF/services/org/apache/activemq/store/jdbc/");
1: 
0:     private WireFormat wireFormat = new OpenWireFormat(false);
0:     private DataSource dataSource;
1:     private JDBCAdapter adapter;
0:     private String adapterClass;
0:     private MemoryTransactionStore transactionStore;
0:     private ScheduledThreadPoolExecutor clockDaemon;
0:     private ScheduledFuture clockTicket;
0:     int cleanupPeriod = 1000 * 60 * 5;
1:     private boolean useExternalMessageReferences;
1: 
1:     public JDBCPersistenceAdapter() {
1:     }
1: 
1:     public JDBCPersistenceAdapter(DataSource ds, WireFormat wireFormat) {
0:         this.dataSource = ds;
1:         this.wireFormat = wireFormat;
1:     }
1: 
0:     public Set getDestinations() {
0:         // Get a connection and insert the message into the DB.
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             return getAdapter().doGetDestinations(c);
0:         } catch (IOException e) {
0:             return Collections.EMPTY_SET;
1:         } catch (SQLException e) {
0:             return Collections.EMPTY_SET;
1:         } finally {
1:             try {
1:                 c.close();
1:             } catch (Throwable e) {
1:             }
1:         }
1:     }
1: 
1:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
0:         MessageStore rc = new JDBCMessageStore(this, getAdapter(), wireFormat, destination);
0:         if (transactionStore != null) {
0:             rc = transactionStore.proxy(rc);
1:         }
1:         return rc;
1:     }
1: 
1:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
0:         TopicMessageStore rc = new JDBCTopicMessageStore(this, getAdapter(), wireFormat, destination);
0:         if (transactionStore != null) {
0:             rc = transactionStore.proxy(rc);
1:         }
1:         return rc;
1:     }
1: 
1:     public TransactionStore createTransactionStore() throws IOException {
0:         if (transactionStore == null) {
0:             transactionStore = new MemoryTransactionStore();
1:         }
1:         return this.transactionStore;
1:     }
1: 
1:     public long getLastMessageBrokerSequenceId() throws IOException {
0:         // Get a connection and insert the message into the DB.
1:         TransactionContext c = getTransactionContext();
1:         try {
0:             return getAdapter().doGetLastMessageBrokerSequenceId(c);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to get last broker message id: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
0:     public void start() throws Exception {
1:         
1:         getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());
1: 
1:         TransactionContext transactionContext = getTransactionContext();
1:         transactionContext.begin();
1:         try {
1:             try {
1:                 getAdapter().doCreateTables(transactionContext);
1:             } catch (SQLException e) {
0:                 log.warn("Cannot create tables due to: " + e, e);
1:             }
1:         } finally {
1:             transactionContext.commit();
1:         }
1: 
1:         cleanup();
1: 
1:         // Cleanup the db periodically.
1:         if (cleanupPeriod > 0) {
0:             clockTicket = getScheduledThreadPoolExecutor().scheduleAtFixedRate(new Runnable() {
0:                 public void run() {
1:                     cleanup();
1:                 }
0:             }, cleanupPeriod, cleanupPeriod, TimeUnit.MILLISECONDS);
1:         }
1:     }
1: 
0:     public synchronized void stop() throws Exception {
0:         if (clockTicket != null) {
0:             clockTicket.cancel(true);
0:             clockTicket = null;
0:             clockDaemon.shutdown();
1:         }
1:     }
1: 
1:     public void cleanup() {
1:         TransactionContext c = getTransactionContext();
1:         try {
0:             log.debug("Cleaning up old messages.");
1:             c = getTransactionContext();
0:             getAdapter().doDeleteOldMessages(c);
0:         } catch (IOException e) {
0:             log.warn("Old message cleanup failed due to: " + e, e);
1:         } catch (SQLException e) {
0:             log.warn("Old message cleanup failed due to: " + e, e);
1:         } finally {
1:             try {
1:                 c.close();
1:             } catch (Throwable e) {
1:             }
0:             log.debug("Cleanup done.");
1:         }
1:     }
1: 
0:     public void setScheduledThreadPoolExecutor(ScheduledThreadPoolExecutor clockDaemon) {
0:         this.clockDaemon = clockDaemon;
1:     }
1: 
1:     public ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() {
1:         if (clockDaemon == null) {
1:             clockDaemon = new ScheduledThreadPoolExecutor(5, new ThreadFactory() {
1:                 public Thread newThread(Runnable runnable) {
0:                     Thread thread = new Thread(runnable, "Cleanup Timmer");
1:                     thread.setDaemon(true);
1:                     return thread;
1:                 }
1:             });
1:         }
1:         return clockDaemon;
1:     }
1: 
1:     public JDBCAdapter getAdapter() throws IOException {
1:         if (adapter == null) {
0:             adapter = createAdapter();
1:         }
1:         return adapter;
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      */
1:     protected JDBCAdapter createAdapter() throws IOException {
0:         JDBCAdapter adapter=null;
1:         TransactionContext c = getTransactionContext();
1:         try {
1: 
0:             // If the adapter class is not specified.. try to detect they
0:             // right
0:             // type by getting info from the database.
0:             if (adapterClass == null) {
1: 
1:                 try {
1: 
0:                     // Make the filename file system safe.
0:                     String dirverName = c.getConnection().getMetaData().getDriverName();
0:                     dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase();
1: 
1:                     try {
0:                         adapter = (DefaultJDBCAdapter) factoryFinder.newInstance(dirverName);
0:                         log.info("Database driver recognized: [" + dirverName + "]");
1:                     } catch (Throwable e) {
0:                         log.warn("Database driver NOT recognized: [" + dirverName
0:                                 + "].  Will use default JDBC implementation.");
1:                     }
1: 
1:                 } catch (SQLException e) {
0:                     log
0:                             .warn("JDBC error occured while trying to detect database type.  Will use default JDBC implementation: "
0:                                     + e.getMessage());
0:                     log.debug("Reason: " + e, e);
1:                 }
1: 
1:             } else {
1:                 try {
0:                     Class clazz = JDBCPersistenceAdapter.class.getClassLoader().loadClass(adapterClass);
0:                     adapter = (DefaultJDBCAdapter) clazz.newInstance();
1:                 } catch (Throwable e) {
0:                     log.warn("Invalid JDBC adapter class class (" + adapterClass
0:                             + ").  Will use default JDBC implementation.");
0:                     log.debug("Reason: " + e, e);
1:                 }
1:             }
1: 
0:             // Use the default JDBC adapter if the
0:             // Database type is not recognized.
1:             if (adapter == null) {
0:                 adapter = new DefaultJDBCAdapter();
1:             }
1: 
1:         } finally {
1:             c.close();
1:         }
1:         return adapter;
1:     }
1: 
1:     public void setAdapter(JDBCAdapter adapter) {
1:         this.adapter = adapter;
1:     }
1: 
0:     public DataSource getDataSource() {
0:         return dataSource;
1:     }
1: 
0:     public void setDataSource(DataSource dataSource) {
0:         this.dataSource = dataSource;
1:     }
1: 
1:     public WireFormat getWireFormat() {
1:         return wireFormat;
1:     }
1: 
1:     public void setWireFormat(WireFormat wireFormat) {
1:         this.wireFormat = wireFormat;
1:     }
1: 
0:     public TransactionContext getTransactionContext(ConnectionContext context) {
0:         if (context == null) {
1:             return getTransactionContext();
1:         } else {
0:             TransactionContext answer = (TransactionContext) context.getLongTermStoreContext();
1:             if (answer == null) {
0:                 answer = new TransactionContext(dataSource);
1:                 context.setLongTermStoreContext(answer);
1:             }
1:             return answer;
1:         }
1:     }
1: 
0:     public TransactionContext getTransactionContext() {
0:         return new TransactionContext(dataSource);
1:     }
1: 
1:     public void beginTransaction(ConnectionContext context) throws IOException {
1:         TransactionContext transactionContext = getTransactionContext(context);
1:         transactionContext.begin();
1:     }
1: 
1:     public void commitTransaction(ConnectionContext context) throws IOException {
1:         TransactionContext transactionContext = getTransactionContext(context);
1:         transactionContext.commit();
1:     }
1: 
1:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:         TransactionContext transactionContext = getTransactionContext(context);
1:         transactionContext.rollback();
1:     }
1: 
1:     /**
0:      * @return Returns the adapterClass.
1:      */
0:     public String getAdapterClass() {
0:         return adapterClass;
1:     }
1: 
1:     /**
0:      * @param adapterClass
0:      *            The adapterClass to set.
1:      */
0:     public void setAdapterClass(String adapterClass) {
0:         this.adapterClass = adapterClass;
1:     }
1: 
1:     public int getCleanupPeriod() {
1:         return cleanupPeriod;
1:     }
1: 
1:     public void setCleanupPeriod(int cleanupPeriod) {
1:         this.cleanupPeriod = cleanupPeriod;
1:     }
1: 
1:     public void deleteAllMessages() throws IOException {
1:         TransactionContext c = getTransactionContext();
1:         try {
1:             getAdapter().doDropTables(c);
1:             getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());
1:             getAdapter().doCreateTables(c);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create(e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public boolean isUseExternalMessageReferences() {
1:         return useExternalMessageReferences;
1:     }
1: 
1:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {
1:         this.useExternalMessageReferences = useExternalMessageReferences;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:90beb3f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:170b86a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
/////////////////////////////////////////////////////////////////////////
0: public class JDBCPersistenceAdapter extends DataSourceServiceSupport implements PersistenceAdapter,
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_LOCK_KEEP_ALIVE_PERIOD = 30 * 1000;
0: 
1:     private ScheduledFuture<?> cleanupTicket;
/////////////////////////////////////////////////////////////////////////
1:     {
1:         setLockKeepAlivePeriod(DEFAULT_LOCK_KEEP_ALIVE_PERIOD);
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void init() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     public void doStart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void doStop(ServiceStopper stopper) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @deprecated use {@link #setUseLock(boolean)} instead
0:      *
1:     @Deprecated
1:         setUseLock(useDatabaseLock);
/////////////////////////////////////////////////////////////////////////
1:     public Locker createDefaultLocker() throws IOException {
1:         locker.configure(this);
/////////////////////////////////////////////////////////////////////////
1:      * @deprecated use {@link Locker#setLockAcquireSleepInterval(long)} instead
0:      *
0:      *
1:     public void setLockAcquireSleepInterval(long lockAcquireSleepInterval) throws IOException {
1:         getLocker().setLockAcquireSleepInterval(lockAcquireSleepInterval);
commit:97f03d4
/////////////////////////////////////////////////////////////////////////
0:             Locker service = getLocker();
commit:6ce702d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Locker;
/////////////////////////////////////////////////////////////////////////
0:     private Locker locker;
/////////////////////////////////////////////////////////////////////////
0:             Locker service = getDatabaseLocker();
/////////////////////////////////////////////////////////////////////////
0:         Locker service = getDatabaseLocker();
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      *
1:      * @deprecated as of 5.7.0, replaced by {@link #getLocker()}
1:      */
1:     @Deprecated
1:     public Locker getDatabaseLocker() throws IOException {
1:         return getLocker();
1:     }
0: 
0:     public Locker getLocker() throws IOException {
0:         if (locker == null && isUseDatabaseLock()) {
0:             setLocker(loadDataBaseLocker());
0:         return locker;
1:     }
0: 
1:     /**
0:      * Sets the database locker strategy to use to lock the database on startup
0:      * @throws IOException
0:      *
1:      * @deprecated as of 5.7.0, replaced by {@link #setLocker(org.apache.activemq.broker.Locker)}
1:      */
1:     public void setDatabaseLocker(Locker locker) throws IOException {
1:         setLocker(locker);
0:     public void setLocker(Locker locker) throws IOException {
0:         this.locker = locker;
0:         locker.configure(this);
0:         locker.setLockAcquireSleepInterval(getLockAcquireSleepInterval());
/////////////////////////////////////////////////////////////////////////
0:             Locker locker = getDatabaseLocker();
/////////////////////////////////////////////////////////////////////////
0:     protected Locker loadDataBaseLocker() throws IOException {
0:         DefaultDatabaseLocker locker = (DefaultDatabaseLocker) loadAdapter(lockFactoryFinder, "lock");
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCPersistenceAdapter.class);
commit:952d036
/////////////////////////////////////////////////////////////////////////
1:                 byte[] msg = getAdapter().doGetMessageById(c, seq);
1:                 if (msg != null) {
1:                     Message last = (Message)wireFormat.unmarshal(new ByteSequence(msg));
1:                     brokerSeq = last.getMessageId().getBrokerSequenceId();
0:                 } else {
1:                    LOG.warn("Broker sequence id wasn't recovered properly, possible duplicates!");
1:                 }
commit:1cec28c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.Message;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
1:             long seq =  getAdapter().doGetLastMessageStoreSequenceId(c);
1:             sequenceGenerator.setLastSequenceId(seq);
1:             long brokerSeq = 0;
1:             if (seq != 0) {
0:             	Message last = (Message)wireFormat.unmarshal(new ByteSequence(getAdapter().doGetMessageById(c, seq)));
0:             	brokerSeq = last.getMessageId().getBrokerSequenceId();
1:             }
1:             return brokerSeq;
commit:24a7626
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.LongSequenceGenerator;
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected LongSequenceGenerator sequenceGenerator = new LongSequenceGenerator();
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void initSequenceIdGenerator() {
1:         TransactionContext c = null;
1:         try {
1:             c = getTransactionContext();
1:             getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {
1:                 public void messageId(MessageId id) {
1:                     audit.isDuplicate(id);
1:                 }
1:             });
1:         } catch (Exception e) {
1:             LOG.error("Failed to reload store message audit for JDBC persistence adapter", e);
0:         } finally {
1:             if (c != null) {
1:                 try {
1:                     c.close();
0:                 } catch (Throwable e) {
1:                 }
1:             }
1:         }
0:         
1:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:     public long getNextSequenceId() {
0:         synchronized(sequenceGenerator) {
0:             return sequenceGenerator.getNextSequenceId();
1:         }
1:     }
commit:ae840c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
1:     protected int auditRecoveryDepth = 1024;
/////////////////////////////////////////////////////////////////////////
1:     protected void createMessageAudit() {
1:         if (enableAudit && audit == null) {
1:             audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:             TransactionContext c = null;
0:             
0:             try {
1:                 c = getTransactionContext();
1:                 getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {
1:                     public void messageId(MessageId id) {
1:                         audit.isDuplicate(id);
1:                     }
1:                 });
0:             } catch (Exception e) {
1:                 LOG.error("Failed to reload store message audit for JDBC persistence adapter", e);
0:             } finally {
1:                 if (c != null) {
0:                     try {
1:                         c.close();
0:                     } catch (Throwable e) {
1:                     }
1:                 }
1:             }
0:         MessageStore rc = new JDBCMessageStore(this, getAdapter(), wireFormat, destination, audit);
/////////////////////////////////////////////////////////////////////////
0:         TopicMessageStore rc = new JDBCTopicMessageStore(this, getAdapter(), wireFormat, destination, audit);
/////////////////////////////////////////////////////////////////////////
0:         
1:         createMessageAudit();
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getAuditRecoveryDepth() {
1:         return auditRecoveryDepth;
1:     }
0: 
1:     public void setAuditRecoveryDepth(int auditRecoveryDepth) {
1:         this.auditRecoveryDepth = auditRecoveryDepth;
1:     }
commit:c3801c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected int maxProducersToAudit=1024;
1:     protected int maxAuditDepth=1000;
0:     protected boolean enableAudit=true;
1:     protected ActiveMQMessageAudit audit;
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected ActiveMQMessageAudit createMessageAudit() {
0:     	if (enableAudit && audit == null) {
0:     		audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:     	}
0:     	return audit;
1:     }
0:         MessageStore rc = new JDBCMessageStore(this, getAdapter(), wireFormat, destination, createMessageAudit());
/////////////////////////////////////////////////////////////////////////
0:         TopicMessageStore rc = new JDBCTopicMessageStore(this, getAdapter(), wireFormat, destination, createMessageAudit());
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public int getMaxProducersToAudit() {
0: 		return maxProducersToAudit;
1: 	}
0: 
0: 	public void setMaxProducersToAudit(int maxProducersToAudit) {
0: 		this.maxProducersToAudit = maxProducersToAudit;
1: 	}
0: 
0: 	public int getMaxAuditDepth() {
0: 		return maxAuditDepth;
1: 	}
0: 
0: 	public void setMaxAuditDepth(int maxAuditDepth) {
0: 		this.maxAuditDepth = maxAuditDepth;
1: 	}
0: 
0: 	public boolean isEnableAudit() {
0: 		return enableAudit;
1: 	}
0: 
0: 	public void setEnableAudit(boolean enableAudit) {
0: 		this.enableAudit = enableAudit;
1: 	}
0:     
0:     
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:ddda400
/////////////////////////////////////////////////////////////////////////
1:     private boolean changeAutoCommitAllowed = true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isChangeAutoCommitAllowed() {
1:         return changeAutoCommitAllowed;
0:     }
0: 
1:     /**
1:      * Whether the JDBC driver allows to set the auto commit.
1:      * Some drivers does not allow changing the auto commit. The default value is true.
0:      *
1:      * @param changeAutoCommitAllowed true to change, false to not change.
1:      */
1:     public void setChangeAutoCommitAllowed(boolean changeAutoCommitAllowed) {
1:         this.changeAutoCommitAllowed = changeAutoCommitAllowed;
0:     }
0: 
commit:4b44d31
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:                 dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase(Locale.ENGLISH);
author:Robert Davies
-------------------------------------------------------------------------------
commit:dbc661f
/////////////////////////////////////////////////////////////////////////
1:     private File directory;
/////////////////////////////////////////////////////////////////////////
1:         this.directory=dir;
0:     }
0:     
1:     public File getDirectory(){
1:         if (this.directory==null && brokerService != null){
1:             this.directory=brokerService.getBrokerDataDirectory();
0:         }
1:         return this.directory;
commit:f730323
/////////////////////////////////////////////////////////////////////////
1:     private DataSource lockDataSource;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public DataSource getLockDataSource() throws IOException {
1:         if (lockDataSource == null) {
1:             lockDataSource = getDataSource();
1:             if (lockDataSource == null) {
1:                 throw new IllegalArgumentException(
1:                         "No dataSource property has been configured");
0:             }
0:         } else {
0:             LOG.info("Using a separate dataSource for locking: "
0:                     + lockDataSource);
0:         }
1:         return lockDataSource;
0:     }
0:     
1:     public void setLockDataSource(DataSource dataSource) {
1:         this.lockDataSource = dataSource;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         return new DefaultDatabaseLocker(getLockDataSource(), getStatements());
commit:4ee029e
/////////////////////////////////////////////////////////////////////////
0:                 if (brokerService != null) {
0:                     brokerService.getBroker().nowMasterBroker();
0:                 }
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     public void setUsageManager(SystemUsage usageManager) {
/////////////////////////////////////////////////////////////////////////
0: 
1:     public long size(){
1:         return 0;
0:     }
commit:759fd28
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
/////////////////////////////////////////////////////////////////////////
0:     public void setBrokerName(String brokerName){
0:     }
0:     
0: 
0:     public void setDirectory(File dir){        
0:     }
0: 
0:     public void checkpoint(boolean sync) throws IOException{        
0:     }
commit:415d46c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public String toString(){
0:         return "JDBCPersistenceAdaptor("+super.toString()+")";
0:     }
author:David Jencks
-------------------------------------------------------------------------------
commit:07b6a38
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Cleanup method to remove any state associated with the given destination
1:      * No state retained.... nothing to do
0:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeQueueMessageStore(ActiveMQQueue destination) {
0:     }
0: 
1:     /**
1:      * Cleanup method to remove any state associated with the given destination
1:      * No state retained.... nothing to do
0:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeTopicMessageStore(ActiveMQTopic destination) {
0:     }
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:27f15fd
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Sets the number of milliseconds until the database is attempted to be cleaned up for durable topics
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Sets whether or not tables are created on startup
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Sets whether or not an exclusive database lock should be used to enable JDBC Master/Slave. Enabled by default.
0:      */
commit:d4a50a7
/////////////////////////////////////////////////////////////////////////
1:     private boolean createTablesOnStartup = true;
/////////////////////////////////////////////////////////////////////////
1:         if (isCreateTablesOnStartup()) {
0:             TransactionContext transactionContext = getTransactionContext();
0:             transactionContext.begin();
0:                 try {
0:                     getAdapter().doCreateTables(transactionContext);
0:                 } catch (SQLException e) {
0:                     log.warn("Cannot create tables due to: " + e);
0:                     JDBCPersistenceAdapter.log("Failure Details: ",e);
0:                 }
0:             } finally {
0:                 transactionContext.commit();
/////////////////////////////////////////////////////////////////////////
1:     public boolean isCreateTablesOnStartup() {
1:         return createTablesOnStartup;
0:     }
0: 
1:     public void setCreateTablesOnStartup(boolean createTablesOnStartup) {
1:         this.createTablesOnStartup = createTablesOnStartup;
0:     }
0: 
commit:4f715a2
/////////////////////////////////////////////////////////////////////////
commit:08e4b7b
/////////////////////////////////////////////////////////////////////////
0:         }
0:         if (clockDaemon != null) {
0:             clockDaemon = null;
commit:90d0c4b
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ScheduledFuture;
0: import edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerServiceAware;
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.DataSource;
0: 
0: import java.io.IOException;
0: import java.sql.SQLException;
0: import java.util.Collections;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: public class JDBCPersistenceAdapter extends DataSourceSupport implements PersistenceAdapter, BrokerServiceAware {
0:     private BrokerService brokerService;
1:     private int cleanupPeriod = 1000 * 60 * 5;
0:     private boolean useDatabaseLock = true;
0:     private int lockKeepAlivePeriod = 0;
0:     private DatabaseLocker databaseLocker;
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (isUseDatabaseLock()) {
0:             DatabaseLocker service = getDatabaseLocker();
0:             if (service == null) {
0:                 log.warn("No databaseLocker configured for the JDBC Persistence Adapter");
0:             }
0:             else {
0:                 service.start();
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:         DatabaseLocker service = getDatabaseLocker();
0:         if (service != null) {
0:             service.stop();
0:         }
/////////////////////////////////////////////////////////////////////////
0:     
0:     public DatabaseLocker getDatabaseLocker() throws IOException {
0:         if (databaseLocker == null) {
0:             databaseLocker = createDatabaseLocker();
0:             if (lockKeepAlivePeriod > 0) {
0:                 getScheduledThreadPoolExecutor().scheduleAtFixedRate(new Runnable() {
0:                     public void run() {
0:                         databaseLockKeepAlive();
0:                     }
0:                 }, lockKeepAlivePeriod, lockKeepAlivePeriod, TimeUnit.MILLISECONDS);
0:             }
0:         }
0:         return databaseLocker;
0:     }
0: 
0:     /**
0:      * Sets the database locker strategy to use to lock the database on startup
0:      */
0:     public void setDatabaseLocker(DatabaseLocker databaseLocker) {
0:         this.databaseLocker = databaseLocker;
0:     }
0:     
1:     public BrokerService getBrokerService() {
1:         return brokerService;
0:     }
0: 
0:     public void setBrokerService(BrokerService brokerService) {
0:         this.brokerService = brokerService;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isUseDatabaseLock() {
0:         return useDatabaseLock;
0:     }
0: 
1:     public void setUseDatabaseLock(boolean useDatabaseLock) {
0:         this.useDatabaseLock = useDatabaseLock;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected void databaseLockKeepAlive() {
0:         boolean stop = false;
0:         try {
0:             DatabaseLocker locker = getDatabaseLocker();
0:             if (locker != null) {
0:                 if (!locker.keepAlive()) {
0:                     stop = true;
0:                 }
0:             }
0:         }
0:         catch (IOException e) {
0:             log.error("Failed to get database when trying keepalive: " + e, e);
0:         }
0:         if (stop) {
0:             stopBroker();
0:         }
0:     }
0: 
0:     protected void stopBroker() {
0:         // we can no longer keep the lock so lets fail
0:         log.info("No longer able to keep the exclusive lock so giving up being a master");
0:         try {
0:             brokerService.stop();
0:         }
0:         catch (Exception e) {
0:             log.warn("Failed to stop broker");
0:         }
0:     }
0: 
0:     protected DatabaseLocker createDatabaseLocker() throws IOException {
0:         return new DefaultDatabaseLocker(getDataSource(), getStatements());
0:     }
commit:a039746
/////////////////////////////////////////////////////////////////////////
0: public class JDBCPersistenceAdapter extends DataSourceSupport implements PersistenceAdapter {
/////////////////////////////////////////////////////////////////////////
1:         super(ds);
1:         TransactionContext c = null;
1:             c = getTransactionContext();
0:         }
0:         catch (IOException e) {
0:         }
0:         catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
0:         }
0:         finally {
1:             if (c != null) {
0:                 try {
0:                     c.close();
0:                 }
0:                 catch (Throwable e) {
0:                 }
/////////////////////////////////////////////////////////////////////////
1:         TransactionContext c = null;
0:         }
0:         catch (IOException e) {
0:         }
0:         catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("Failure Details: ", e);
0:         }
0:         finally {
1:             if (c != null) {
0:                 try {
0:                     c.close();
0:                 }
0:                 catch (Throwable e) {
0:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TransactionContext getTransactionContext(ConnectionContext context) throws IOException {
0:                 answer = new TransactionContext(getDataSource());
1:     public TransactionContext getTransactionContext() throws IOException {
0:         return new TransactionContext(getDataSource());
commit:d273cf9
/////////////////////////////////////////////////////////////////////////
0:         if (dataSource == null) { 
0:             throw new IllegalArgumentException("No dataSource property has been configured");
0:         }
commit:75bffcb
/////////////////////////////////////////////////////////////////////////
0:                     Thread thread = new Thread(runnable, "ActiveMQ Cleanup Timer");
commit:8fbbd24
/////////////////////////////////////////////////////////////////////////
0:             // If the adapter class is not specified.. try to detect the right
============================================================================