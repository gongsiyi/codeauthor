1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.jdbc.adapter;
1:1cec28c: 
1:03a211e: import static javax.xml.bind.DatatypeConverter.parseBase64Binary;
1:03a211e: import static javax.xml.bind.DatatypeConverter.printBase64Binary;
1:03a211e: 
1:d29ca2a: import java.io.IOException;
1:4f5e620: import java.sql.Connection;
1:d29ca2a: import java.sql.PreparedStatement;
1:d29ca2a: import java.sql.ResultSet;
1:d29ca2a: import java.sql.SQLException;
1:d29ca2a: import java.sql.Statement;
1:9b64c37: import java.util.ArrayList;
1:d29ca2a: import java.util.HashSet;
1:5fb5235: import java.util.LinkedList;
1:d29ca2a: import java.util.Set;
1:06cbebc: import java.util.concurrent.locks.ReadWriteLock;
1:06cbebc: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:4f5e620: 
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:a6a6a70: import org.apache.activemq.command.ProducerId;
1:d29ca2a: import org.apache.activemq.command.SubscriptionInfo;
1:64f3492: import org.apache.activemq.command.XATransactionId;
1:d29ca2a: import org.apache.activemq.store.jdbc.JDBCAdapter;
1:8732f70: import org.apache.activemq.store.jdbc.JDBCMessageIdScanListener;
1:d29ca2a: import org.apache.activemq.store.jdbc.JDBCMessageRecoveryListener;
1:911177e: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1:64f3492: import org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore;
1:4843dd4: import org.apache.activemq.store.jdbc.Statements;
1:d29ca2a: import org.apache.activemq.store.jdbc.TransactionContext;
1:64f3492: import org.apache.activemq.util.DataByteArrayOutputStream;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:74ba052: 
1:d29ca2a: /**
1:3b37436:  * Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
1:3b37436:  * encouraged to override the default implementation of methods to account for differences in JDBC Driver
1:3b37436:  * implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
1:d29ca2a:  * The databases/JDBC drivers that use this adapter are:
1:d29ca2a:  * <ul>
1:d29ca2a:  * <li></li>
1:d29ca2a:  * </ul>
1:457dbd8:  *
1:4843dd4:  * @org.apache.xbean.XBean element="defaultJDBCAdapter"
1:457dbd8:  *
1:457dbd8:  *
1:d29ca2a:  */
1:f812e34: public class DefaultJDBCAdapter implements JDBCAdapter {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DefaultJDBCAdapter.class);
1:d6e8a5b:     public static final int MAX_ROWS = org.apache.activemq.ActiveMQPrefetchPolicy.MAX_PREFETCH_SIZE;
1:03a211e:     private static final String FAILURE_MESSAGE = "Failure was: %s Message: %s SQLState: %s Vendor code: %s";
1:4843dd4:     protected Statements statements;
1:ff409b6:     private boolean batchStatements = true;
1:ff409b6:     //This is deprecated and should be removed in a future release
1:f812e34:     protected boolean batchStatments = true;
1:12f0195:     protected boolean prioritizedMessages;
1:4fbf92d:     protected int maxRows = MAX_ROWS;
1:1cec28c: 
1:f812e34:     protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {
1:f812e34:         s.setBytes(index, data);
1:b6f63b0:     }
1:8b64e13: 
1:f812e34:     protected byte[] getBinaryData(ResultSet rs, int index) throws SQLException {
1:d29ca2a:         return rs.getBytes(index);
1:4679c8a:     }
1:74ba052: 
1:266d23e:     @Override
1:03a211e:     public void doCreateTables(TransactionContext transactionContext) throws SQLException, IOException {
1:2a815c2:         // Check to see if the table already exists. If it does, then don't log warnings during startup.
1:2a815c2:         // Need to run the scripts anyways since they may contain ALTER statements that upgrade a previous version of the table
1:2a815c2:         boolean messageTableAlreadyExists = messageTableAlreadyExists(transactionContext);
1:03a211e: 
1:2a815c2:         for (String createStatement : this.statements.getCreateSchemaStatements()) {
1:2a815c2:             // This will fail usually since the tables will be
1:2a815c2:             // created already.
1:2a815c2:             executeStatement(transactionContext, createStatement, messageTableAlreadyExists);
1:03a211e:         }
1:03a211e:     }
1:03a211e: 
1:03a211e:     private boolean messageTableAlreadyExists(TransactionContext transactionContext) {
1:03a211e:         boolean alreadyExists = false;
1:03a211e:         ResultSet rs = null;
1:03a211e:         try {
1:03a211e:             rs = transactionContext.getConnection().getMetaData().getTables(null, null, this.statements.getFullMessageTableName(), new String[] { "TABLE" });
1:03a211e:             alreadyExists = rs.next();
1:03a211e:         } catch (Throwable ignore) {
1:03a211e:         } finally {
1:03a211e:             close(rs);
1:03a211e:         }
1:03a211e:         return alreadyExists;
1:03a211e:     }
1:03a211e: 
1:03a211e:     private void executeStatement(TransactionContext transactionContext, String createStatement, boolean ignoreStatementExecutionFailure) throws IOException {
1:03a211e:         Statement statement = null;
1:03a211e:         try {
1:03a211e:             LOG.debug("Executing SQL: " + createStatement);
1:03a211e:             statement = transactionContext.getConnection().createStatement();
1:03a211e:             statement.execute(createStatement);
1:03a211e: 
1:03a211e:             commitIfAutoCommitIsDisabled(transactionContext);
1:03a211e:         } catch (SQLException e) {
1:03a211e:             if (ignoreStatementExecutionFailure) {
1:03a211e:                 LOG.debug("Could not create JDBC tables; The message table already existed. " + String.format(FAILURE_MESSAGE, createStatement, e.getMessage(), e.getSQLState(), e.getErrorCode()));
1:03a211e:             } else {
1:03a211e:                 LOG.warn("Could not create JDBC tables; they could already exist. " + String.format(FAILURE_MESSAGE, createStatement, e.getMessage(), e.getSQLState(), e.getErrorCode()));
1:03a211e:                 JDBCPersistenceAdapter.log("Failure details: ", e);
1:ba5fdc5:             }
1:03a211e:         } finally {
1:03a211e:             closeStatement(statement);
1:03a211e:         }
1:03a211e:     }
1:03a211e: 
1:03a211e:     private void closeStatement(Statement statement) {
1:03a211e:         try {
1:03a211e:             if (statement != null) {
1:03a211e:                 statement.close();
1:03a211e:             }
1:03a211e:         } catch (SQLException ignored) {}
1:03a211e:     }
1:03a211e: 
1:03a211e:     private void commitIfAutoCommitIsDisabled(TransactionContext c) throws SQLException, IOException {
1:03a211e:         if (!c.getConnection().getAutoCommit()) {
1:03a211e:             c.getConnection().commit();
1:8b64e13:         }
1:8b64e13:     }
1:8b64e13: 
1:78c959a:     @Override
1:f812e34:     public void doDropTables(TransactionContext c) throws SQLException, IOException {
2:f812e34:         Statement s = null;
1:f812e34:         try {
2:f812e34:             s = c.getConnection().createStatement();
1:3b37436:             String[] dropStatments = this.statements.getDropSchemaStatements();
1:f812e34:             for (int i = 0; i < dropStatments.length; i++) {
2:d29ca2a:                 // This will fail usually since the tables will be
2:d29ca2a:                 // created already.
1:f812e34:                 try {
1:5a81bbb:                     LOG.debug("Executing SQL: " + dropStatments[i]);
1:933eb2f:                     s.execute(dropStatments[i]);
2:f812e34:                 } catch (SQLException e) {
1:3b37436:                     LOG.warn("Could not drop JDBC tables; they may not exist." + " Failure was: " + dropStatments[i]
1:3b37436:                             + " Message: " + e.getMessage() + " SQLState: " + e.getSQLState() + " Vendor code: "
1:3b37436:                             + e.getErrorCode());
2:f812e34:                     JDBCPersistenceAdapter.log("Failure details: ", e);
1:4679c8a:                 }
1:96adbc3:             }
1:03a211e:             commitIfAutoCommitIsDisabled(c);
1:f812e34:         } finally {
1:f812e34:             try {
1:5a81bbb:                 s.close();
1:f812e34:             } catch (Throwable e) {
1:5a81bbb:             }
1:c0edaf0:         }
1:c0edaf0:     }
1:74ba052: 
1:457dbd8:     @Override
1:1cec28c:     public long doGetLastMessageStoreSequenceId(TransactionContext c) throws SQLException, IOException {
1:64f3492:         PreparedStatement s = null;
1:8732f70:         ResultSet rs = null;
1:64f3492:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInMsgsStatement());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             long seq1 = 0;
1:f812e34:             if (rs.next()) {
1:f812e34:                 seq1 = rs.getLong(1);
1:12f0195:             }
1:d29ca2a:             rs.close();
4:d29ca2a:             s.close();
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInAcksStatement());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             long seq2 = 0;
1:f812e34:             if (rs.next()) {
1:f812e34:                 seq2 = rs.getLong(1);
1:952d036:             }
1:952d036:             long seq = Math.max(seq1, seq2);
1:952d036:             return seq;
1:f812e34:         } finally {
1:c0edaf0:             close(rs);
1:d29ca2a:             close(s);
1:fa4481c:         }
26:d29ca2a:     }
1:457dbd8: 
1:457dbd8:     @Override
1:1cec28c:     public byte[] doGetMessageById(TransactionContext c, long storeSequenceId) throws SQLException, IOException {
1:1cec28c:         PreparedStatement s = null;
1:1cec28c:         ResultSet rs = null;
1:1cec28c:         try {
1:1cec28c:             s = c.getConnection().prepareStatement(
1:1cec28c:                     this.statements.getFindMessageByIdStatement());
1:1cec28c:             s.setLong(1, storeSequenceId);
1:1cec28c:             rs = s.executeQuery();
1:1cec28c:             if (!rs.next()) {
1:1cec28c:                 return null;
1:1cec28c:             }
1:1cec28c:             return getBinaryData(rs, 1);
1:1cec28c:         } finally {
1:1cec28c:             close(rs);
1:1cec28c:             close(s);
1:1cec28c:         }
1:1cec28c:     }
1:457dbd8: 
1:4f5e620: 
1:64f3492:     /**
1:64f3492:      * A non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
1:64f3492:      */
1:457dbd8:     @Override
1:24a7626:     public void doAddMessage(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination, byte[] data,
1:64f3492:                              long expiration, byte priority, XATransactionId xid) throws SQLException, IOException {
2:f812e34:         PreparedStatement s = c.getAddMessageStatement();
1:f812e34:         try {
1:f812e34:             if (s == null) {
1:3b37436:                 s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());
1:ff409b6:                 if (this.batchStatements) {
1:d29ca2a:                     c.setAddMessageStatement(s);
1:d29ca2a:                 }
1:d29ca2a:             }
1:24a7626:             s.setLong(1, sequence);
1:f812e34:             s.setString(2, messageID.getProducerId().toString());
1:f812e34:             s.setLong(3, messageID.getProducerSequenceId());
1:f812e34:             s.setString(4, destination.getQualifiedName());
1:f812e34:             s.setLong(5, expiration);
1:4f5e620:             s.setLong(6, priority);
1:12f0195:             setBinaryData(s, 7, data);
1:64f3492:             if (xid != null) {
1:64f3492:                 byte[] xidVal = xid.getEncodedXidBytes();
1:64f3492:                 xidVal[0] = '+';
1:74ba052:                 String xidString = printBase64Binary(xidVal);
1:74ba052:                 s.setString(8, xidString);
1:12f0195:             } else {
1:74ba052:                 s.setString(8, null);
1:64f3492:             }
1:ff409b6:             if (this.batchStatements) {
1:d29ca2a:                 s.addBatch();
1:f812e34:             } else if (s.executeUpdate() != 1) {
2:d29ca2a:                 throw new SQLException("Failed add a message");
1:d29ca2a:             }
1:f812e34:         } finally {
1:ff409b6:             if (!this.batchStatements) {
1:3b37436:                 if (s != null) {
1:d29ca2a:                     s.close();
1:457dbd8:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:4f5e620: 
1:457dbd8:     @Override
1:266d23e:     public void doUpdateMessage(TransactionContext c, ActiveMQDestination destination, MessageId id, byte[] data) throws SQLException, IOException {
1:266d23e:         PreparedStatement s = null;
1:266d23e:         try {
1:266d23e:             s = c.getConnection().prepareStatement(this.statements.getUpdateMessageStatement());
1:266d23e:             setBinaryData(s, 1, data);
1:266d23e:             s.setString(2, id.getProducerId().toString());
1:266d23e:             s.setLong(3, id.getProducerSequenceId());
1:266d23e:             s.setString(4, destination.getQualifiedName());
1:266d23e:             if (s.executeUpdate() != 1) {
1:266d23e:                 throw new IOException("Could not update message: " + id + " in " + destination);
1:266d23e:             }
1:266d23e:         } finally {
1:266d23e:             close(s);
1:266d23e:         }
1:266d23e:     }
1:1cec28c: 
1:94708a2: 
1:457dbd8:     @Override
1:24a7626:     public void doAddMessageReference(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination,
1:3b37436:             long expirationTime, String messageRef) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = c.getAddMessageStatement();
1:f812e34:         try {
1:f812e34:             if (s == null) {
1:3b37436:                 s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());
1:ff409b6:                 if (this.batchStatements) {
1:d29ca2a:                     c.setAddMessageStatement(s);
1:d29ca2a:                 }
1:d29ca2a:             }
2:f812e34:             s.setLong(1, messageID.getBrokerSequenceId());
1:f812e34:             s.setString(2, messageID.getProducerId().toString());
1:f812e34:             s.setLong(3, messageID.getProducerSequenceId());
1:f812e34:             s.setString(4, destination.getQualifiedName());
1:f812e34:             s.setLong(5, expirationTime);
1:f812e34:             s.setString(6, messageRef);
1:ff409b6:             if (this.batchStatements) {
1:d29ca2a:                 s.addBatch();
1:f812e34:             } else if (s.executeUpdate() != 1) {
1:d29ca2a:                 throw new SQLException("Failed add a message");
1:d29ca2a:             }
1:f812e34:         } finally {
1:ff409b6:             if (!this.batchStatements) {
1:d29ca2a:                 s.close();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:64f3492: 
1:457dbd8:     @Override
1:4f5e620:     public long[] getStoreSequenceId(TransactionContext c, ActiveMQDestination destination, MessageId messageID) throws SQLException, IOException {
1:8732f70:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindMessageSequenceIdStatement());
1:f812e34:             s.setString(1, messageID.getProducerId().toString());
1:f812e34:             s.setLong(2, messageID.getProducerSequenceId());
1:4f5e620:             s.setString(3, destination.getQualifiedName());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             if (!rs.next()) {
1:4f5e620:                 return new long[]{0,0};
1:d29ca2a:             }
1:4f5e620:             return new long[]{rs.getLong(1), rs.getLong(2)};
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:64f3492: 
1:457dbd8:     @Override
1:24a7626:     public byte[] doGetMessage(TransactionContext c, MessageId id) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindMessageStatement());
1:24a7626:             s.setString(1, id.getProducerId().toString());
1:24a7626:             s.setLong(2, id.getProducerSequenceId());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             if (!rs.next()) {
1:d29ca2a:                 return null;
1:d29ca2a:             }
1:f812e34:             return getBinaryData(rs, 1);
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:b6f63b0: 
1:457dbd8:     @Override
1:f812e34:     public String doGetMessageReference(TransactionContext c, long seq) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindMessageStatement());
1:06cbebc:             s.setLong(1, seq);
1:f812e34:             rs = s.executeQuery();
1:f812e34:             if (!rs.next()) {
1:d29ca2a:                 return null;
1:d29ca2a:             }
1:d29ca2a:             return rs.getString(1);
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:4679c8a: 
1:64f3492:     /**
1:64f3492:      * A non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
1:64f3492:      */
1:457dbd8:     @Override
1:64f3492:     public void doRemoveMessage(TransactionContext c, long seq, XATransactionId xid) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = c.getRemovedMessageStatement();
1:06cbebc:         try {
1:f812e34:             if (s == null) {
1:64f3492:                 s = c.getConnection().prepareStatement(xid == null ?
1:64f3492:                         this.statements.getRemoveMessageStatement() : this.statements.getUpdateXidFlagStatement());
1:ff409b6:                 if (this.batchStatements) {
1:d29ca2a:                     c.setRemovedMessageStatement(s);
1:d29ca2a:                 }
1:d29ca2a:             }
1:64f3492:             if (xid == null) {
1:64f3492:                 s.setLong(1, seq);
1:64f3492:             } else {
1:64f3492:                 byte[] xidVal = xid.getEncodedXidBytes();
1:60624c4:                 xidVal[0] = '-';
1:74ba052:                 String xidString = printBase64Binary(xidVal);
1:74ba052:                 s.setString(1, xidString);
1:64f3492:                 s.setLong(2, seq);
1:64f3492:             }
1:ff409b6:             if (this.batchStatements) {
1:d29ca2a:                 s.addBatch();
1:f812e34:             } else if (s.executeUpdate() != 1) {
1:54e2e3b:                 throw new SQLException("Failed to remove message seq: " + seq);
1:d29ca2a:             }
1:f812e34:         } finally {
1:ff409b6:             if (!this.batchStatements && s != null) {
1:d29ca2a:                 s.close();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:4679c8a: 
1:457dbd8:     @Override
1:3b37436:     public void doRecover(TransactionContext c, ActiveMQDestination destination, JDBCMessageRecoveryListener listener)
1:f812e34:             throws Exception {
1:06cbebc:         PreparedStatement s = null;
1:06cbebc:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindAllMessagesStatement());
1:06cbebc:             s.setString(1, destination.getQualifiedName());
1:06cbebc:             rs = s.executeQuery();
1:3b37436:             if (this.statements.isUseExternalMessageReferences()) {
1:f812e34:                 while (rs.next()) {
1:3a5f48d:                     if (!listener.recoverMessageReference(rs.getString(2))) {
1:8732f70:                         break;
1:12f0195:                     }
1:8732f70:                 }
1:64f3492:             } else {
1:f812e34:                 while (rs.next()) {
1:f812e34:                     if (!listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:4d0e572:                         break;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:06cbebc:         } finally {
1:06cbebc:             close(rs);
1:06cbebc:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:fa4481c: 
1:457dbd8:     @Override
1:457dbd8:     public void doMessageIdScan(TransactionContext c, int limit,
1:8732f70:             JDBCMessageIdScanListener listener) throws SQLException, IOException {
1:06cbebc:         PreparedStatement s = null;
1:06cbebc:         ResultSet rs = null;
1:06cbebc:         try {
1:5ffcaf4:             s = c.getConnection().prepareStatement(this.statements.getFindAllMessageIdsStatement());
1:ae840c4:             s.setMaxRows(limit);
1:8732f70:             rs = s.executeQuery();
1:0bc545b:             // jdbc scrollable cursor requires jdbc ver > 1.0 and is often implemented locally so avoid
1:5fb5235:             LinkedList<MessageId> reverseOrderIds = new LinkedList<MessageId>();
1:8732f70:             while (rs.next()) {
1:5fb5235:                 reverseOrderIds.addFirst(new MessageId(rs.getString(2), rs.getLong(3)));
1:5fb5235:             }
1:0bc545b:             if (LOG.isDebugEnabled()) {
1:0bc545b:                 LOG.debug("messageIdScan with limit (" + limit + "), resulted in: " + reverseOrderIds.size() + " ids");
1:0bc545b:             }
1:5fb5235:             for (MessageId id : reverseOrderIds) {
1:5fb5235:                 listener.messageId(id);
1:8732f70:             }
1:8732f70:         } finally {
1:8732f70:             close(rs);
1:8732f70:             close(s);
1:8732f70:         }
1:8732f70:     }
1:06cbebc: 
1:457dbd8:     @Override
1:64f3492:     public void doSetLastAckWithPriority(TransactionContext c, ActiveMQDestination destination, XATransactionId xid, String clientId,
1:64f3492:                                          String subscriptionName, long seq, long priority) throws SQLException, IOException {
1:fa4481c:         PreparedStatement s = c.getUpdateLastAckStatement();
1:8732f70:         try {
1:fa4481c:             if (s == null) {
1:64f3492:                 s = c.getConnection().prepareStatement(xid == null ?
1:64f3492:                         this.statements.getUpdateDurableLastAckWithPriorityStatement() :
1:64f3492:                         this.statements.getUpdateDurableLastAckWithPriorityInTxStatement());
1:ff409b6:                 if (this.batchStatements) {
1:fa4481c:                     c.setUpdateLastAckStatement(s);
1:fa4481c:                 }
1:fa4481c:             }
1:64f3492:             if (xid != null) {
1:64f3492:                 byte[] xidVal = encodeXid(xid, seq, priority);
1:74ba052:                 String xidString = printBase64Binary(xidVal);
1:74ba052:                 s.setString(1, xidString);
1:64f3492:             } else {
1:64f3492:                 s.setLong(1, seq);
1:64f3492:             }
1:06cbebc:             s.setString(2, destination.getQualifiedName());
1:06cbebc:             s.setString(3, clientId);
1:06cbebc:             s.setString(4, subscriptionName);
1:4f5e620:             s.setLong(5, priority);
1:ff409b6:             if (this.batchStatements) {
1:fa4481c:                 s.addBatch();
1:fa4481c:             } else if (s.executeUpdate() != 1) {
1:64f3492:                 throw new SQLException("Failed update last ack with priority: " + priority + ", for sub: " + subscriptionName);
1:06cbebc:             }
1:06cbebc:         } finally {
1:ff409b6:             if (!this.batchStatements) {
1:06cbebc:                 close(s);
1:06cbebc:             }
1:06cbebc:         }
1:06cbebc:     }
1:06cbebc: 
1:06cbebc: 
1:457dbd8:     @Override
1:64f3492:     public void doSetLastAck(TransactionContext c, ActiveMQDestination destination, XATransactionId xid, String clientId,
1:64f3492:                              String subscriptionName, long seq, long priority) throws SQLException, IOException {
1:582f340:         PreparedStatement s = c.getUpdateLastAckStatement();
1:06cbebc:         try {
1:f812e34:             if (s == null) {
1:64f3492:                 s = c.getConnection().prepareStatement(xid == null ?
1:64f3492:                         this.statements.getUpdateDurableLastAckStatement() :
1:64f3492:                         this.statements.getUpdateDurableLastAckInTxStatement());
1:ff409b6:                 if (this.batchStatements) {
1:d29ca2a:                     c.setUpdateLastAckStatement(s);
1:64f3492:                 }
1:06cbebc:             }
1:64f3492:             if (xid != null) {
1:64f3492:                 byte[] xidVal = encodeXid(xid, seq, priority);
1:74ba052:                 String xidString = printBase64Binary(xidVal);
1:74ba052:                 s.setString(1, xidString);
1:64f3492:             } else {
1:64f3492:                 s.setLong(1, seq);
1:d29ca2a:             }
1:06cbebc:             s.setString(2, destination.getQualifiedName());
1:06cbebc:             s.setString(3, clientId);
1:06cbebc:             s.setString(4, subscriptionName);
1:06cbebc: 
1:ff409b6:             if (this.batchStatements) {
1:d29ca2a:                 s.addBatch();
1:f812e34:             } else if (s.executeUpdate() != 1) {
1:06cbebc:                 throw new IOException("Could not update last ack seq : "
1:06cbebc:                             + seq + ", for sub: " + subscriptionName);
1:fa4481c:             }
1:f812e34:         } finally {
1:ff409b6:             if (!this.batchStatements) {
1:fa4481c:                 close(s);
1:fa4481c:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:06cbebc: 
1:64f3492:     private byte[] encodeXid(XATransactionId xid, long seq, long priority) {
1:64f3492:         byte[] xidVal = xid.getEncodedXidBytes();
1:64f3492:         // encode the update
1:3adee8c:         DataByteArrayOutputStream outputStream = xid.internalOutputStream();
1:64f3492:         outputStream.position(1);
1:64f3492:         outputStream.writeLong(seq);
1:64f3492:         outputStream.writeByte(Long.valueOf(priority).byteValue());
1:64f3492:         return xidVal;
1:64f3492:     }
1:64f3492: 
1:457dbd8:     @Override
1:64f3492:     public void doClearLastAck(TransactionContext c, ActiveMQDestination destination, byte priority, String clientId, String subName) throws SQLException, IOException {
1:64f3492:         PreparedStatement s = null;
1:64f3492:         try {
1:64f3492:             s = c.getConnection().prepareStatement(this.statements.getClearDurableLastAckInTxStatement());
1:64f3492:             s.setString(1, destination.getQualifiedName());
1:64f3492:             s.setString(2, clientId);
1:64f3492:             s.setString(3, subName);
1:64f3492:             s.setLong(4, priority);
1:64f3492:             if (s.executeUpdate() != 1) {
1:64f3492:                 throw new IOException("Could not remove prepared transaction state from message ack for: " + clientId + ":" + subName);
1:64f3492:             }
1:64f3492:         } finally {
1:64f3492:             close(s);
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:457dbd8:     @Override
1:f812e34:     public void doRecoverSubscription(TransactionContext c, ActiveMQDestination destination, String clientId,
1:3b37436:             String subscriptionName, JDBCMessageRecoveryListener listener) throws Exception {
1:f812e34:         // dumpTables(c,
1:f812e34:         // destination.getQualifiedName(),clientId,subscriptionName);
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindAllDurableSubMessagesStatement());
1:06cbebc:             s.setString(1, destination.getQualifiedName());
1:06cbebc:             s.setString(2, clientId);
1:06cbebc:             s.setString(3, subscriptionName);
1:f812e34:             rs = s.executeQuery();
1:3b37436:             if (this.statements.isUseExternalMessageReferences()) {
1:f812e34:                 while (rs.next()) {
1:f812e34:                     if (!listener.recoverMessageReference(rs.getString(2))) {
1:4d0e572:                         break;
1:06cbebc:                     }
1:06cbebc:                 }
1:fa4481c:             } else {
1:f812e34:                 while (rs.next()) {
1:f812e34:                     if (!listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
2:3a5f48d:                         break;
1:06cbebc:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:06cbebc:         } finally {
1:06cbebc:             close(rs);
1:06cbebc:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:06cbebc: 
1:457dbd8:     @Override
1:f812e34:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, String clientId,
1:4f5e620:             String subscriptionName, long seq, long priority, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
1:457dbd8: 
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:4f5e620:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesStatement());
1:ada9e00:             s.setMaxRows(Math.min(maxReturned * 2, maxRows));
1:4679c8a:             s.setString(1, destination.getQualifiedName());
1:4679c8a:             s.setString(2, clientId);
1:4679c8a:             s.setString(3, subscriptionName);
1:8191f19:             s.setLong(4, seq);
1:4679c8a:             rs = s.executeQuery();
1:4679c8a:             int count = 0;
1:4679c8a:             if (this.statements.isUseExternalMessageReferences()) {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:4679c8a:                     if (listener.recoverMessageReference(rs.getString(1))) {
1:4679c8a:                         count++;
1:4f5e620:                     }
1:4679c8a:                 }
1:4f5e620:             } else {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:4679c8a:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:4679c8a:                         count++;
1:4679c8a:                     }
1:4679c8a:                 }
1:4679c8a:             }
1:4679c8a:         } finally {
1:4679c8a:             close(rs);
1:4679c8a:             close(s);
1:4679c8a:         }
1:4679c8a:     }
1:4679c8a: 
1:457dbd8:     @Override
1:4679c8a:     public void doRecoverNextMessagesWithPriority(TransactionContext c, ActiveMQDestination destination, String clientId,
1:4679c8a:             String subscriptionName, long seq, long priority, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
1:4679c8a: 
1:4679c8a:         PreparedStatement s = null;
1:4679c8a:         ResultSet rs = null;
1:4679c8a:         try {
1:4f5e620:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesByPriorityStatement());
1:d6e8a5b:             s.setMaxRows(Math.min(maxReturned * 2, maxRows));
1:8732f70:             s.setString(1, destination.getQualifiedName());
1:06cbebc:             s.setString(2, clientId);
1:06cbebc:             s.setString(3, subscriptionName);
1:8191f19:             s.setLong(4, seq);
1:6348d11:             s.setLong(5, priority);
1:f812e34:             rs = s.executeQuery();
1:f812e34:             int count = 0;
1:3b37436:             if (this.statements.isUseExternalMessageReferences()) {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:f812e34:                     if (listener.recoverMessageReference(rs.getString(1))) {
1:3a5f48d:                         count++;
1:4f5e620:                     }
1:d29ca2a:                 }
2:f812e34:             } else {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:f812e34:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:3a5f48d:                         count++;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:8732f70: 
1:457dbd8:     @Override
1:f812e34:     public int doGetDurableSubscriberMessageCount(TransactionContext c, ActiveMQDestination destination,
1:4679c8a:             String clientId, String subscriptionName, boolean isPrioritizedMessages) throws SQLException, IOException {
4:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         int result = 0;
1:f812e34:         try {
1:4679c8a:             if (isPrioritizedMessages) {
1:fa4481c:                 s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatementWithPriority());
1:fa4481c:             } else {
1:457dbd8:                 s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatement());
1:fa4481c:             }
5:f812e34:             s.setString(1, destination.getQualifiedName());
1:f812e34:             s.setString(2, clientId);
1:f812e34:             s.setString(3, subscriptionName);
3:f812e34:             rs = s.executeQuery();
2:f812e34:             if (rs.next()) {
1:f812e34:                 result = rs.getInt(1);
1:d29ca2a:             }
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:629bc81:         return result;
1:d29ca2a:     }
1:96adbc3: 
1:d29ca2a:     /**
1:457dbd8:      * @param c
1:457dbd8:      * @param info
1:457dbd8:      * @param retroactive
1:457dbd8:      * @throws SQLException
1:457dbd8:      * @throws IOException
1:d29ca2a:      */
1:457dbd8:     @Override
1:4679c8a:     public void doSetSubscriberEntry(TransactionContext c, SubscriptionInfo info, boolean retroactive, boolean isPrioritizedMessages)
1:a6a6a70:             throws SQLException, IOException {
1:f812e34:         // dumpTables(c, destination.getQualifiedName(), clientId,
1:f812e34:         // subscriptionName);
1:a6a6a70:         PreparedStatement s = null;
1:a6a6a70:         try {
1:f812e34:             long lastMessageId = -1;
1:f812e34:             if (!retroactive) {
1:3b37436:                 s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInMsgsStatement());
1:a6a6a70:                 ResultSet rs = null;
1:f812e34:                 try {
1:a6a6a70:                     rs = s.executeQuery();
1:a6a6a70:                     if (rs.next()) {
1:f812e34:                         lastMessageId = rs.getLong(1);
1:a6a6a70:                     }
1:a6a6a70:                 } finally {
1:a6a6a70:                     close(rs);
1:a6a6a70:                     close(s);
1:d29ca2a:                 }
1:d29ca2a:             }
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getCreateDurableSubStatement());
1:fa4481c:             int maxPriority = 1;
1:4679c8a:             if (isPrioritizedMessages) {
1:fa4481c:                 maxPriority = 10;
1:d29ca2a:             }
1:fa4481c: 
1:fa4481c:             for (int priority = 0; priority < maxPriority; priority++) {
1:fa4481c:                 s.setString(1, info.getDestination().getQualifiedName());
1:fa4481c:                 s.setString(2, info.getClientId());
1:fa4481c:                 s.setString(3, info.getSubscriptionName());
1:fa4481c:                 s.setString(4, info.getSelector());
1:fa4481c:                 s.setLong(5, lastMessageId);
1:fa4481c:                 s.setString(6, info.getSubscribedDestination().getQualifiedName());
1:4f5e620:                 s.setLong(7, priority);
1:fa4481c: 
1:fa4481c:                 if (s.executeUpdate() != 1) {
1:fa4481c:                     throw new IOException("Could not create durable subscription for: " + info.getClientId());
1:fa4481c:                 }
1:fa4481c:             }
1:fa4481c: 
1:f812e34:         } finally {
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:9b64c37: 
1:457dbd8:     @Override
1:f812e34:     public SubscriptionInfo doGetSubscriberEntry(TransactionContext c, ActiveMQDestination destination,
1:3b37436:             String clientId, String subscriptionName) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubStatement());
1:f812e34:             s.setString(1, destination.getQualifiedName());
1:f812e34:             s.setString(2, clientId);
1:f812e34:             s.setString(3, subscriptionName);
1:f812e34:             rs = s.executeQuery();
2:f812e34:             if (!rs.next()) {
1:d29ca2a:                 return null;
1:d29ca2a:             }
1:f812e34:             SubscriptionInfo subscription = new SubscriptionInfo();
1:9b64c37:             subscription.setDestination(destination);
1:d29ca2a:             subscription.setClientId(clientId);
1:2728ccb:             subscription.setSubscriptionName(subscriptionName);
1:9b64c37:             subscription.setSelector(rs.getString(1));
1:3b37436:             subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(2),
1:3b37436:                     ActiveMQDestination.QUEUE_TYPE));
1:d29ca2a:             return subscription;
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:9b64c37: 
1:457dbd8:     @Override
1:f812e34:     public SubscriptionInfo[] doGetAllSubscriptions(TransactionContext c, ActiveMQDestination destination)
2:f812e34:             throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindAllDurableSubsStatement());
1:f812e34:             s.setString(1, destination.getQualifiedName());
1:f812e34:             rs = s.executeQuery();
1:933eb2f:             ArrayList<SubscriptionInfo> rc = new ArrayList<SubscriptionInfo>();
1:f812e34:             while (rs.next()) {
1:f812e34:                 SubscriptionInfo subscription = new SubscriptionInfo();
1:d29ca2a:                 subscription.setDestination(destination);
1:d29ca2a:                 subscription.setSelector(rs.getString(1));
1:2728ccb:                 subscription.setSubscriptionName(rs.getString(2));
1:9b64c37:                 subscription.setClientId(rs.getString(3));
1:3b37436:                 subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(4),
1:f812e34:                         ActiveMQDestination.QUEUE_TYPE));
1:96adbc3:                 rc.add(subscription);
1:9b64c37:             }
1:933eb2f:             return rc.toArray(new SubscriptionInfo[rc.size()]);
6:f812e34:         } finally {
1:9b64c37:             close(rs);
1:9b64c37:             close(s);
1:9b64c37:         }
1:9b64c37:     }
1:9b64c37: 
1:457dbd8:     @Override
1:3b37436:     public void doRemoveAllMessages(TransactionContext c, ActiveMQDestination destinationName) throws SQLException,
1:f812e34:             IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getRemoveAllMessagesStatement());
1:f812e34:             s.setString(1, destinationName.getQualifiedName());
1:d29ca2a:             s.executeUpdate();
1:d29ca2a:             s.close();
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getRemoveAllSubscriptionsStatement());
1:f812e34:             s.setString(1, destinationName.getQualifiedName());
1:d29ca2a:             s.executeUpdate();
1:f812e34:         } finally {
1:d29ca2a:             close(s);
1:9b64c37:         }
1:d29ca2a:     }
1:9b64c37: 
1:457dbd8:     @Override
1:f812e34:     public void doDeleteSubscription(TransactionContext c, ActiveMQDestination destination, String clientId,
1:f812e34:             String subscriptionName) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getDeleteSubscriptionStatement());
1:f812e34:             s.setString(1, destination.getQualifiedName());
1:f812e34:             s.setString(2, clientId);
1:f812e34:             s.setString(3, subscriptionName);
1:d29ca2a:             s.executeUpdate();
1:f812e34:         } finally {
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:c0edaf0: 
1:f0d0ce0:     char priorityIterator = 0; // unsigned
1:457dbd8:     @Override
1:fe31092:     public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         try {
1:fe31092:             LOG.debug("Executing SQL: " + this.statements.getDeleteOldMessagesStatementWithPriority());
1:2a815c2:             s = c.getExclusiveConnection().prepareStatement(this.statements.getDeleteOldMessagesStatementWithPriority());
1:fe31092:             int priority = priorityIterator++%10;
1:fe31092:             s.setInt(1, priority);
1:fe31092:             s.setInt(2, priority);
1:f812e34:             int i = s.executeUpdate();
1:fe31092:             LOG.debug("Deleted " + i + " old message(s) at priority: " + priority);
1:f812e34:         } finally {
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:457dbd8:     @Override
1:fa4481c:     public long doGetLastAckedDurableSubscriberMessageId(TransactionContext c, ActiveMQDestination destination,
1:3b37436:             String clientId, String subscriberName) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:fa4481c:         long result = -1;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getLastAckedDurableSubscriberMessageStatement());
1:f812e34:             s.setString(1, destination.getQualifiedName());
4:f812e34:             s.setString(2, clientId);
2:f812e34:             s.setString(3, subscriberName);
1:f812e34:             rs = s.executeQuery();
1:f812e34:             if (rs.next()) {
1:fa4481c:                 result = rs.getLong(1);
1:b6f63b0:                 if (result == 0 && rs.wasNull()) {
1:b6f63b0:                     result = -1;
1:b6f63b0:                 }
1:d29ca2a:             }
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:4597ddd:         return result;
1:d29ca2a:     }
1:c0edaf0: 
1:adc45e8:     protected static void close(PreparedStatement s) {
8:f812e34:         try {
1:d29ca2a:             s.close();
1:f812e34:         } catch (Throwable e) {
1:d29ca2a:         }
1:d29ca2a:     }
1:c0edaf0: 
1:adc45e8:     protected static void close(ResultSet rs) {
1:f812e34:         try {
1:d29ca2a:             rs.close();
2:f812e34:         } catch (Throwable e) {
1:d29ca2a:         }
1:d29ca2a:     }
67:d29ca2a: 
1:457dbd8:     @Override
1:933eb2f:     public Set<ActiveMQDestination> doGetDestinations(TransactionContext c) throws SQLException, IOException {
1:933eb2f:         HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
1:f812e34:         PreparedStatement s = null;
5:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getFindAllDestinationsStatement());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             while (rs.next()) {
1:933eb2f:                 rc.add(ActiveMQDestination.createDestination(rs.getString(1), ActiveMQDestination.QUEUE_TYPE));
1:d29ca2a:             }
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:d29ca2a:             close(s);
1:d29ca2a:         }
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:ff409b6:      * @return true if batchStatements
1:d29ca2a:      */
1:ff409b6:     public boolean isBatchStatements() {
1:ff409b6:         return batchStatements;
1:d29ca2a:     }
1:d29ca2a: 
3:3b37436:     /**
1:ff409b6:      * Set the number of statements to process as a single batch DB update
1:ff409b6:      * @param batchStatements
1:ff409b6:      */
1:ff409b6:     public void setBatchStatements(boolean batchStatements) {
1:ff409b6:         this.batchStatements = batchStatements;
1:ff409b6:         // The next lines are deprecated and should be removed in a future release
1:ff409b6:         // and is here in case someone created their own
1:54e2e3b:        // this.batchStatments = batchStatements;
1:ff409b6:     }
1:ff409b6: 
1:ff409b6:     // Note - remove batchStatment in future distributions.  Here for backward compatibility
1:ff409b6:     /**
1:ff409b6:      * @return true if batchStements
1:ff409b6:      */
1:ff409b6:     public boolean isBatchStatments() {
1:ff409b6:         return this.batchStatements;
1:ff409b6:     }
1:ff409b6: 
1:ff409b6:     /**
1:ff409b6:      * This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
1:ff409b6:      * @deprecated
1:3b37436:      * @param batchStatments
4:3b37436:      */
1:f812e34:     public void setBatchStatments(boolean batchStatments) {
1:ff409b6:         LOG.warn("batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)");
1:ff409b6:         this.batchStatements = batchStatments;
1:f812e34:         this.batchStatments = batchStatments;
1:d29ca2a:     }
1:d29ca2a: 
1:457dbd8:     @Override
1:f812e34:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {
1:3b37436:         this.statements.setUseExternalMessageReferences(useExternalMessageReferences);
1:4843dd4:     }
1:4843dd4: 
1:3b37436:     /**
1:3b37436:      * @return the statements
1:d29ca2a:      */
1:f812e34:     public Statements getStatements() {
1:3b37436:         return this.statements;
1:4843dd4:     }
1:4843dd4: 
1:457dbd8:     @Override
1:f812e34:     public void setStatements(Statements statements) {
1:f812e34:         this.statements = statements;
1:12f0195:     }
1:12f0195: 
1:457dbd8:     @Override
1:4679c8a:     public int getMaxRows() {
1:4679c8a:         return maxRows;
1:12f0195:     }
1:12f0195: 
1:d6e8a5b:     /**
1:d6e8a5b:      * the max value for statement maxRows, used to limit jdbc queries
1:d6e8a5b:      */
1:457dbd8:     @Override
1:4679c8a:     public void setMaxRows(int maxRows) {
1:4679c8a:         this.maxRows = maxRows;
1:f812e34:     }
1:f812e34: 
1:457dbd8:     @Override
1:b6f63b0:     public void doRecordDestination(TransactionContext c, ActiveMQDestination destination) throws SQLException, IOException {
1:b6f63b0:         PreparedStatement s = null;
1:b6f63b0:         try {
1:b6f63b0:             s = c.getConnection().prepareStatement(this.statements.getCreateDurableSubStatement());
1:b6f63b0:             s.setString(1, destination.getQualifiedName());
1:b6f63b0:             s.setString(2, destination.getQualifiedName());
1:b6f63b0:             s.setString(3, destination.getQualifiedName());
1:b6f63b0:             s.setString(4, null);
1:b6f63b0:             s.setLong(5, 0);
1:b6f63b0:             s.setString(6, destination.getQualifiedName());
1:b6f63b0:             s.setLong(7, 11);  // entry out of priority range
1:b6f63b0: 
1:b6f63b0:             if (s.executeUpdate() != 1) {
1:b6f63b0:                 throw new IOException("Could not create ack record for destination: " + destination);
1:b6f63b0:             }
1:b6f63b0:         } finally {
1:b6f63b0:             close(s);
1:b6f63b0:         }
1:b6f63b0:     }
1:d29ca2a: 
1:457dbd8:     @Override
1:64f3492:     public void doRecoverPreparedOps(TransactionContext c, JdbcMemoryTransactionStore jdbcMemoryTransactionStore) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:64f3492:             s = c.getConnection().prepareStatement(this.statements.getFindOpsPendingOutcomeStatement());
1:f812e34:             rs = s.executeQuery();
1:64f3492:             while (rs.next()) {
1:64f3492:                 long id = rs.getLong(1);
1:74ba052:                 String encodedString = rs.getString(2);
1:74ba052:                 byte[] encodedXid = parseBase64Binary(encodedString);
1:64f3492:                 if (encodedXid[0] == '+') {
1:64f3492:                     jdbcMemoryTransactionStore.recoverAdd(id, getBinaryData(rs, 3));
1:64f3492:                 } else {
1:64f3492:                     jdbcMemoryTransactionStore.recoverAck(id, encodedXid, getBinaryData(rs, 3));
1:64f3492:                 }
1:d29ca2a:             }
1:64f3492: 
1:64f3492:             close(rs);
1:64f3492:             close(s);
1:64f3492: 
1:64f3492:             s = c.getConnection().prepareStatement(this.statements.getFindAcksPendingOutcomeStatement());
1:64f3492:             rs = s.executeQuery();
1:64f3492:             while (rs.next()) {
1:74ba052:                 String encodedString = rs.getString(1);
1:74ba052:                 byte[] encodedXid = parseBase64Binary(encodedString);
1:64f3492:                 String destination = rs.getString(2);
1:64f3492:                 String subName = rs.getString(3);
1:64f3492:                 String subId = rs.getString(4);
1:64f3492:                 jdbcMemoryTransactionStore.recoverLastAck(encodedXid,
1:64f3492:                         ActiveMQDestination.createDestination(destination, ActiveMQDestination.TOPIC_TYPE),
1:64f3492:                         subName, subId);
1:64f3492:             }
1:f812e34:         } finally {
1:d29ca2a:             close(rs);
1:4597ddd:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:457dbd8:     @Override
1:3155c62:     public void doCommitAddOp(TransactionContext c, long preparedSequence, long sequence) throws SQLException, IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         try {
1:64f3492:             s = c.getConnection().prepareStatement(this.statements.getClearXidFlagStatement());
1:64f3492:             s.setLong(1, sequence);
1:3155c62:             s.setLong(2, preparedSequence);
1:64f3492:             if (s.executeUpdate() != 1) {
1:64f3492:                 throw new IOException("Could not remove prepared transaction state from message add for sequenceId: " + sequence);
1:64f3492:             }
1:64f3492:         } finally {
1:64f3492:             close(s);
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492: 
1:64f3492:     @Override
1:f812e34:     public int doGetMessageCount(TransactionContext c, ActiveMQDestination destination) throws SQLException,
2:f812e34:             IOException {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         int result = 0;
1:f812e34:         try {
1:3b37436:             s = c.getConnection().prepareStatement(this.statements.getDestinationMessageCountStatement());
1:f812e34:             s.setString(1, destination.getQualifiedName());
1:f812e34:             rs = s.executeQuery();
1:f812e34:             if (rs.next()) {
1:f812e34:                 result = rs.getInt(1);
1:d29ca2a:             }
1:f812e34:         } finally {
1:4597ddd:             close(rs);
1:629bc81:             close(s);
1:d29ca2a:         }
1:4eef609:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     @Override
1:a2697b8:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, long[] lastRecoveredEntries,
1:a2697b8:             long maxSeq, int maxReturned, boolean isPrioritizedMessages, JDBCMessageRecoveryListener listener) throws Exception {
1:f812e34:         PreparedStatement s = null;
1:f812e34:         ResultSet rs = null;
1:f812e34:         try {
1:4679c8a:             if (isPrioritizedMessages) {
1:78c959a:                 s = c.getConnection().prepareStatement(limitQuery(this.statements.getFindNextMessagesByPriorityStatement()));
1:f812e34:             } else {
1:78c959a:                 s = c.getConnection().prepareStatement(limitQuery(this.statements.getFindNextMessagesStatement()));
1:d29ca2a:             }
1:eece28a:             s.setMaxRows(Math.min(maxReturned, maxRows));
1:f812e34:             s.setString(1, destination.getQualifiedName());
1:a2697b8:             s.setLong(2, maxSeq);
1:a2697b8:             int paramId = 3;
1:4679c8a:             if (isPrioritizedMessages) {
1:a2697b8:                 for (int i=9;i>=0;i--) {
1:a2697b8:                     s.setLong(paramId++, lastRecoveredEntries[i]);
1:a2697b8:                 }
1:a2697b8:             } else {
1:a2697b8:                 s.setLong(paramId, lastRecoveredEntries[0]);
1:d29ca2a:             }
1:f812e34:             rs = s.executeQuery();
1:f812e34:             int count = 0;
1:3b37436:             if (this.statements.isUseExternalMessageReferences()) {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:f812e34:                     if (listener.recoverMessageReference(rs.getString(1))) {
1:3a5f48d:                         count++;
1:f812e34:                     } else {
1:fc00993:                         LOG.debug("Stopped recover next messages");
1:4e1d383:                         break;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34:             } else {
1:13ec994:                 while (rs.next() && count < maxReturned) {
1:f812e34:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:3a5f48d:                         count++;
1:f812e34:                     } else {
1:fc00993:                         LOG.debug("Stopped recover next messages");
1:4e1d383:                         break;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:f812e34:         } catch (Exception e) {
1:457dbd8:             LOG.warn("Exception recovering next messages", e);
1:f812e34:         } finally {
2:629bc81:             close(rs);
1:629bc81:             close(s);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     @Override
1:64f3492:     public long doGetLastProducerSequenceId(TransactionContext c, ProducerId id)
1:64f3492:             throws SQLException, IOException {
1:64f3492:         PreparedStatement s = null;
1:64f3492:         ResultSet rs = null;
1:64f3492:         try {
1:64f3492:             s = c.getConnection().prepareStatement(this.statements.getLastProducerSequenceIdStatement());
1:64f3492:             s.setString(1, id.toString());
1:64f3492:             rs = s.executeQuery();
1:64f3492:             long seq = -1;
1:64f3492:             if (rs.next()) {
1:64f3492:                 seq = rs.getLong(1);
1:64f3492:             }
1:64f3492:             return seq;
1:64f3492:         } finally {
1:64f3492:             close(rs);
1:64f3492:             close(s);
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:ba5fdc5:     public static void dumpTables(Connection c, String destinationName, String clientId, String
1:457dbd8:       subscriptionName) throws SQLException {
1:457dbd8:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
1:457dbd8:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
1:457dbd8:         PreparedStatement s = c.prepareStatement("SELECT M.ID, D.LAST_ACKED_ID FROM "
1:457dbd8:                 + "ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D "
1:457dbd8:                 + "WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND D.SUB_NAME=?"
1:457dbd8:                 + " AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID"
1:4f5e620:                 + " ORDER BY M.ID");
1:4f5e620:       s.setString(1,destinationName); s.setString(2,clientId); s.setString(3,subscriptionName);
1:4f5e620:       printQuery(s,System.out); }
1:4f5e620: 
1:32d3fd5:     public static void dumpTables(java.sql.Connection c) throws SQLException {
1:54e2e3b:         printQuery(c, "SELECT COUNT(*) from ACTIVEMQ_MSGS", System.out);
1:54e2e3b: 
1:54e2e3b:         //printQuery(c, "SELECT COUNT(*) from ACTIVEMQ_ACKS", System.out);
1:54e2e3b: 
1:54e2e3b:         //printQuery(c, "Select * from ACTIVEMQ_MSGS ORDER BY ID", System.out);
1:54e2e3b:         //printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
1:4f5e620:     }
1:4f5e620: 
1:ba5fdc5:     public static void printQuery(java.sql.Connection c, String query, java.io.PrintStream out)
1:4f5e620:             throws SQLException {
1:4f5e620:         printQuery(c.prepareStatement(query), out);
1:4f5e620:     }
1:4f5e620: 
1:ba5fdc5:     public static void printQuery(java.sql.PreparedStatement s, java.io.PrintStream out)
1:4f5e620:             throws SQLException {
1:4f5e620: 
1:4f5e620:         ResultSet set = null;
1:4f5e620:         try {
1:4f5e620:             set = s.executeQuery();
1:32d3fd5:             java.sql.ResultSetMetaData metaData = set.getMetaData();
1:4f5e620:             for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:4f5e620:                 if (i == 1)
1:4f5e620:                     out.print("||");
1:4f5e620:                 out.print(metaData.getColumnName(i) + "||");
1:4f5e620:             }
1:4f5e620:             out.println();
1:4f5e620:             while (set.next()) {
1:4f5e620:                 for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:4f5e620:                     if (i == 1)
1:4f5e620:                         out.print("|");
1:4f5e620:                     out.print(set.getString(i) + "|");
1:4f5e620:                 }
1:4f5e620:                 out.println();
1:4f5e620:             }
1:4f5e620:         } finally {
1:4f5e620:             try {
1:4f5e620:                 set.close();
1:4f5e620:             } catch (Throwable ignore) {
1:4f5e620:             }
1:4f5e620:             try {
1:4f5e620:                 s.close();
1:4f5e620:             } catch (Throwable ignore) {
1:4f5e620:             }
1:4f5e620:         }
1:a6a6a70:     }
1:a6a6a70: 
1:b6f63b0:     @Override
1:78c959a:     public String limitQuery(String query) {
1:78c959a:         return query;
1:78c959a:     }
1:a6a6a70: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:2a815c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Check to see if the table already exists. If it does, then don't log warnings during startup.
1:         // Need to run the scripts anyways since they may contain ALTER statements that upgrade a previous version of the table
1:         boolean messageTableAlreadyExists = messageTableAlreadyExists(transactionContext);
1:         for (String createStatement : this.statements.getCreateSchemaStatements()) {
1:             // This will fail usually since the tables will be
1:             // created already.
1:             executeStatement(transactionContext, createStatement, messageTableAlreadyExists);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             s = c.getExclusiveConnection().prepareStatement(this.statements.getDeleteOldMessagesStatementWithPriority());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:13ec994
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCMessageStore;
/////////////////////////////////////////////////////////////////////////
1:                 while (rs.next() && count < maxReturned) {
1:                 while (rs.next() && count < maxReturned) {
/////////////////////////////////////////////////////////////////////////
1:                 while (rs.next() && count < maxReturned) {
1:                 while (rs.next() && count < maxReturned) {
/////////////////////////////////////////////////////////////////////////
1:                 while (rs.next() && count < maxReturned) {
/////////////////////////////////////////////////////////////////////////
1:                 while (rs.next() && count < maxReturned) {
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 while (rs.next() && count < maxReturned && listener.hasSpace()) {
0:                 while (rs.next() && count < maxReturned && listener.hasSpace()) {
/////////////////////////////////////////////////////////////////////////
0:                 while (rs.next() && count < maxReturned && listener.hasSpace() ) {
0:                 while (rs.next() && count < maxReturned  && listener.hasSpace()) {
/////////////////////////////////////////////////////////////////////////
0:                 while (rs.next() && count < maxReturned && listener.hasSpace()) {
/////////////////////////////////////////////////////////////////////////
0:                 while (rs.next() && count < maxReturned && listener.hasSpace()) {
commit:a2697b8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCMessageStore;
/////////////////////////////////////////////////////////////////////////
1:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, long[] lastRecoveredEntries,
1:             long maxSeq, int maxReturned, boolean isPrioritizedMessages, JDBCMessageRecoveryListener listener) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             s.setLong(2, maxSeq);
1:             int paramId = 3;
1:                 for (int i=9;i>=0;i--) {
1:                     s.setLong(paramId++, lastRecoveredEntries[i]);
1:                 }
1:             } else {
1:                 s.setLong(paramId, lastRecoveredEntries[0]);
commit:eece28a
/////////////////////////////////////////////////////////////////////////
1:             s.setMaxRows(Math.min(maxReturned, maxRows));
commit:3155c62
/////////////////////////////////////////////////////////////////////////
1:     public void doCommitAddOp(TransactionContext c, long preparedSequence, long sequence) throws SQLException, IOException {
1:             s.setLong(2, preparedSequence);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1:                 throw new SQLException("Failed to remove message seq: " + seq);
/////////////////////////////////////////////////////////////////////////
1:        // this.batchStatments = batchStatements;
/////////////////////////////////////////////////////////////////////////
1:         printQuery(c, "SELECT COUNT(*) from ACTIVEMQ_MSGS", System.out);
1: 
1:         //printQuery(c, "SELECT COUNT(*) from ACTIVEMQ_ACKS", System.out);
1: 
1:         //printQuery(c, "Select * from ACTIVEMQ_MSGS ORDER BY ID", System.out);
1:         //printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
commit:6348d11
/////////////////////////////////////////////////////////////////////////
0:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, long maxSeq, long lastRecoveredSeq,
/////////////////////////////////////////////////////////////////////////
0:             s.setLong(2, lastRecoveredSeq);
0:             s.setLong(3, maxSeq);
1:                 s.setLong(5, priority);
commit:266d23e
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void doUpdateMessage(TransactionContext c, ActiveMQDestination destination, MessageId id, byte[] data) throws SQLException, IOException {
1:         PreparedStatement s = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
1:             s = c.getConnection().prepareStatement(this.statements.getUpdateMessageStatement());
1:             setBinaryData(s, 1, data);
1:             s.setString(2, id.getProducerId().toString());
1:             s.setLong(3, id.getProducerSequenceId());
1:             s.setString(4, destination.getQualifiedName());
1:             if (s.executeUpdate() != 1) {
1:                 throw new IOException("Could not update message: " + id + " in " + destination);
1:             }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(s);
1:         }
1:     }
author:Jeroen Bastijns
-------------------------------------------------------------------------------
commit:03a211e
/////////////////////////////////////////////////////////////////////////
1: import static javax.xml.bind.DatatypeConverter.parseBase64Binary;
1: import static javax.xml.bind.DatatypeConverter.printBase64Binary;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final String FAILURE_MESSAGE = "Failure was: %s Message: %s SQLState: %s Vendor code: %s";
/////////////////////////////////////////////////////////////////////////
1:     public void doCreateTables(TransactionContext transactionContext) throws SQLException, IOException {
0:             // Check to see if the table already exists. If it does, then don't log warnings during startup.
0:             // Need to run the scripts anyways since they may contain ALTER statements that upgrade a previous version of the table
0:             boolean messageTableAlreadyExists = messageTableAlreadyExists(transactionContext);
1: 
0:             for (String createStatement : this.statements.getCreateSchemaStatements()) {
0:                 executeStatement(transactionContext, createStatement, messageTableAlreadyExists);
1:         }
1:     }
1: 
1:     private boolean messageTableAlreadyExists(TransactionContext transactionContext) {
1:         boolean alreadyExists = false;
1:         ResultSet rs = null;
1:         try {
1:             rs = transactionContext.getConnection().getMetaData().getTables(null, null, this.statements.getFullMessageTableName(), new String[] { "TABLE" });
1:             alreadyExists = rs.next();
1:         } catch (Throwable ignore) {
1:         } finally {
1:             close(rs);
1:         }
1:         return alreadyExists;
1:     }
1: 
1:     private void executeStatement(TransactionContext transactionContext, String createStatement, boolean ignoreStatementExecutionFailure) throws IOException {
1:         Statement statement = null;
1:         try {
1:             LOG.debug("Executing SQL: " + createStatement);
1:             statement = transactionContext.getConnection().createStatement();
1:             statement.execute(createStatement);
1: 
1:             commitIfAutoCommitIsDisabled(transactionContext);
1:         } catch (SQLException e) {
1:             if (ignoreStatementExecutionFailure) {
1:                 LOG.debug("Could not create JDBC tables; The message table already existed. " + String.format(FAILURE_MESSAGE, createStatement, e.getMessage(), e.getSQLState(), e.getErrorCode()));
1:             } else {
1:                 LOG.warn("Could not create JDBC tables; they could already exist. " + String.format(FAILURE_MESSAGE, createStatement, e.getMessage(), e.getSQLState(), e.getErrorCode()));
1:                 JDBCPersistenceAdapter.log("Failure details: ", e);
1:         } finally {
1:             closeStatement(statement);
1:         }
1:     }
1: 
1:     private void closeStatement(Statement statement) {
1:         try {
1:             if (statement != null) {
1:                 statement.close();
1:             }
1:         } catch (SQLException ignored) {}
1:     }
1: 
1:     private void commitIfAutoCommitIsDisabled(TransactionContext c) throws SQLException, IOException {
1:         if (!c.getConnection().getAutoCommit()) {
1:             c.getConnection().commit();
/////////////////////////////////////////////////////////////////////////
1:             commitIfAutoCommitIsDisabled(c);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:78c959a
/////////////////////////////////////////////////////////////////////////
1:                 s = c.getConnection().prepareStatement(limitQuery(this.statements.getFindNextMessagesByPriorityStatement()));
1:                 s = c.getConnection().prepareStatement(limitQuery(this.statements.getFindNextMessagesStatement()));
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String limitQuery(String query) {
1:         return query;
1:     }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:457dbd8
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void doMessageIdScan(TransactionContext c, int limit,
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatement());
/////////////////////////////////////////////////////////////////////////
1:      * @param c
1:      * @param info
1:      * @param retroactive
1:      * @throws SQLException
1:      * @throws IOException
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Exception recovering next messages", e);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:       subscriptionName) throws SQLException {
1:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
1:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
1:         PreparedStatement s = c.prepareStatement("SELECT M.ID, D.LAST_ACKED_ID FROM "
1:                 + "ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D "
1:                 + "WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND D.SUB_NAME=?"
1:                 + " AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID"
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8b64e13
/////////////////////////////////////////////////////////////////////////
1: 
0:             // if autoCommit used do not call commit
0:             if(!c.getConnection().getAutoCommit()){
0:                 c.getConnection().commit();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             // if autoCommit used do not call commit
0:             if(!c.getConnection().getAutoCommit()){
0:                c.getConnection().commit();
1:             }
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:ff409b6
/////////////////////////////////////////////////////////////////////////
1:     private boolean batchStatements = true;
1:     //This is deprecated and should be removed in a future release
/////////////////////////////////////////////////////////////////////////
1:                 if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (this.batchStatements) {
1:             if (!this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:                 if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (this.batchStatements) {
1:             if (!this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:                 if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (this.batchStatements) {
1:             if (!this.batchStatements && s != null) {
/////////////////////////////////////////////////////////////////////////
1:                 if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (this.batchStatements) {
1:             if (!this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:                 if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:             if (!this.batchStatements) {
/////////////////////////////////////////////////////////////////////////
1:      * @return true if batchStatements
1:     public boolean isBatchStatements() {
1:         return batchStatements;
1:      * Set the number of statements to process as a single batch DB update
1:      * @param batchStatements
1:      */
1:     public void setBatchStatements(boolean batchStatements) {
1:         this.batchStatements = batchStatements;
1:         // The next lines are deprecated and should be removed in a future release
1:         // and is here in case someone created their own
0:         this.batchStatments = batchStatements;
1:     }
1: 
1:     // Note - remove batchStatment in future distributions.  Here for backward compatibility
1:     /**
1:      * @return true if batchStements
1:      */
1:     public boolean isBatchStatments() {
1:         return this.batchStatements;
1:     }
1: 
1:     /**
1:      * This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
1:      * @deprecated
1:         LOG.warn("batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)");
1:         this.batchStatements = batchStatments;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:74ba052
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static javax.xml.bind.DatatypeConverter.parseBase64Binary;
0: import static javax.xml.bind.DatatypeConverter.printBase64Binary;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String xidString = printBase64Binary(xidVal);
1:                 s.setString(8, xidString);
1:                 s.setString(8, null);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String xidString = printBase64Binary(xidVal);
1:                 s.setString(1, xidString);
/////////////////////////////////////////////////////////////////////////
1:                 String xidString = printBase64Binary(xidVal);
1:                 s.setString(1, xidString);
/////////////////////////////////////////////////////////////////////////
1:                 String xidString = printBase64Binary(xidVal);
1:                 s.setString(1, xidString);
/////////////////////////////////////////////////////////////////////////
1:                 String encodedString = rs.getString(2);
1:                 byte[] encodedXid = parseBase64Binary(encodedString);
/////////////////////////////////////////////////////////////////////////
1:                 String encodedString = rs.getString(1);
1:                 byte[] encodedXid = parseBase64Binary(encodedString);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(DefaultJDBCAdapter.class);
commit:4f5e620
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintStream;
1: import java.sql.Connection;
0: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Message;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public long[] getStoreSequenceId(TransactionContext c, ActiveMQDestination destination, MessageId messageID) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
1:                 return new long[]{0,0};
1:             return new long[]{rs.getLong(1), rs.getLong(2)};
/////////////////////////////////////////////////////////////////////////
0:             String subscriptionName, long seq, long prio) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
0:             s.setLong(2, prio);
1:             s.setString(3, destination.getQualifiedName());
0:             s.setString(4, clientId);
0:             s.setString(5, subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:             String subscriptionName, long seq, long priority, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
1:         
0:             if (isPrioritizedMessages()) {
1:                 s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesByPriorityStatement());
1:             } else {
1:                 s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesStatement());
1:             }
0:             if (isPrioritizedMessages()) {
1:                 s.setLong(5, priority);
1:                 s.setLong(6, priority);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             long priority = Byte.MAX_VALUE - 1;
/////////////////////////////////////////////////////////////////////////
1:             s.setLong(7, priority);
/////////////////////////////////////////////////////////////////////////
1:     
0: /*    public void dumpTables(Connection c, String destinationName, String clientId, String
0:       subscriptionName) throws SQLException { 
0:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out); 
0:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out); 
0:         PreparedStatement s = c.prepareStatement("SELECT M.ID, D.LAST_ACKED_ID FROM " 
0:                 + "ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D " 
0:                 + "WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND D.SUB_NAME=?" 
0:                 + " AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID" 
1:                 + " ORDER BY M.ID");
1:       s.setString(1,destinationName); s.setString(2,clientId); s.setString(3,subscriptionName);
1:       printQuery(s,System.out); }
1: 
0:     public void dumpTables(Connection c) throws SQLException {
0:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
0:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
1:     }
1: 
0:     private void printQuery(Connection c, String query, PrintStream out)
1:             throws SQLException {
1:         printQuery(c.prepareStatement(query), out);
1:     }
1: 
0:     private void printQuery(PreparedStatement s, PrintStream out)
1:             throws SQLException {
1: 
1:         ResultSet set = null;
1:         try {
1:             set = s.executeQuery();
0:             ResultSetMetaData metaData = set.getMetaData();
1:             for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:                 if (i == 1)
1:                     out.print("||");
1:                 out.print(metaData.getColumnName(i) + "||");
1:             }
1:             out.println();
1:             while (set.next()) {
1:                 for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:                     if (i == 1)
1:                         out.print("|");
1:                     out.print(set.getString(i) + "|");
1:                 }
1:                 out.println();
1:             }
1:         } finally {
1:             try {
1:                 set.close();
1:             } catch (Throwable ignore) {
1:             }
1:             try {
1:                 s.close();
1:             } catch (Throwable ignore) {
1:             }
1:         }
0:     }  */  
commit:12f0195
/////////////////////////////////////////////////////////////////////////
1:     protected boolean prioritizedMessages;
/////////////////////////////////////////////////////////////////////////
0:             long expiration, byte priority) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
0:             s.setLong(6, priority);
1:             setBinaryData(s, 7, data);
/////////////////////////////////////////////////////////////////////////
1:     }    
1: 
0:     public boolean isPrioritizedMessages() {
0:         return prioritizedMessages;
1:     }
1: 
0:     public void setPrioritizedMessages(boolean prioritizedMessages) {
0:         this.prioritizedMessages = prioritizedMessages;
/////////////////////////////////////////////////////////////////////////
0:             if (isPrioritizedMessages()) {
0:                 s = c.getConnection().prepareStatement(this.statements.getFindNextMessagesByPriorityStatement());
1:             } else {
0:                 s = c.getConnection().prepareStatement(this.statements.getFindNextMessagesStatement());
1:             }
0:             if (!isPrioritizedMessages()) {
0:                 s.setLong(2, nextSeq);
1:             }
commit:952d036
/////////////////////////////////////////////////////////////////////////
0:                 // if there is no such message, ignore the value
0:                 if (this.doGetMessageById(c, seq2) == null) {
0:                     seq2 = 0;
1:                 }
1:             long seq = Math.max(seq1, seq2);
1:             return seq;
commit:d22e841
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(this.statements.getRemoveMessageStatement());
commit:1cec28c
/////////////////////////////////////////////////////////////////////////
1:     public long doGetLastMessageStoreSequenceId(TransactionContext c) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
1:     
1:     public byte[] doGetMessageById(TransactionContext c, long storeSequenceId) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
1:             s = c.getConnection().prepareStatement(
1:                     this.statements.getFindMessageByIdStatement());
1:             s.setLong(1, storeSequenceId);
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
1:                 return null;
1:             }
1:             return getBinaryData(rs, 1);
1:         } finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
commit:24a7626
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void doAddMessage(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination, byte[] data,
/////////////////////////////////////////////////////////////////////////
1:             s.setLong(1, sequence);
/////////////////////////////////////////////////////////////////////////
1:     public void doAddMessageReference(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination,
/////////////////////////////////////////////////////////////////////////
0:     public long getStoreSequenceId(TransactionContext c, MessageId messageID) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
1:     public byte[] doGetMessage(TransactionContext c, MessageId id) throws SQLException, IOException {
1:             s.setString(1, id.getProducerId().toString());
1:             s.setLong(2, id.getProducerSequenceId());
commit:5170a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ae840c4
/////////////////////////////////////////////////////////////////////////
0:     public void doMessageIdScan(TransactionContext c, int limit, 
1:             s.setMaxRows(limit);
0:                 listener.messageId(new MessageId(rs.getString(2), rs.getLong(3)));
commit:5ffcaf4
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindAllMessageIdsStatement());
commit:4e1d383
/////////////////////////////////////////////////////////////////////////
1:                         break;
/////////////////////////////////////////////////////////////////////////
1:                         break;
commit:94708a2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private Set<Long> lastRecoveredMessagesIds = Collections.synchronizedSet(new TreeSet<Long>());
author:Gary Tully
-------------------------------------------------------------------------------
commit:ada9e00
/////////////////////////////////////////////////////////////////////////
1:             s.setMaxRows(Math.min(maxReturned * 2, maxRows));
commit:d6e8a5b
/////////////////////////////////////////////////////////////////////////
1:     public static final int MAX_ROWS = org.apache.activemq.ActiveMQPrefetchPolicy.MAX_PREFETCH_SIZE;
/////////////////////////////////////////////////////////////////////////
1:             s.setMaxRows(Math.min(maxReturned * 2, maxRows));
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(Math.min(maxReturned * 2, maxRows));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * the max value for statement maxRows, used to limit jdbc queries
1:      */
commit:ba5fdc5
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:     public static void dumpTables(Connection c, String destinationName, String clientId, String
/////////////////////////////////////////////////////////////////////////
1:     public static void printQuery(java.sql.Connection c, String query, java.io.PrintStream out)
1:     public static void printQuery(java.sql.PreparedStatement s, java.io.PrintStream out)
/////////////////////////////////////////////////////////////////////////
1:     }
commit:c55f6a8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.BaseDestination;
/////////////////////////////////////////////////////////////////////////
0:     public static final int MAX_ROWS = BaseDestination.MAX_PAGE_SIZE;
commit:60624c4
/////////////////////////////////////////////////////////////////////////
1:                 xidVal[0] = '-';
commit:32d3fd5
/////////////////////////////////////////////////////////////////////////
0: /*    public static void dumpTables(Connection c, String destinationName, String clientId, String
/////////////////////////////////////////////////////////////////////////
1:     public static void dumpTables(java.sql.Connection c) throws SQLException {
0:         printQuery(c, "Select * from ACTIVEMQ_MSGS ORDER BY ID", System.out);
0:     private static void printQuery(java.sql.Connection c, String query, java.io.PrintStream out)
0:     private static void printQuery(java.sql.PreparedStatement s, java.io.PrintStream out)
1:             java.sql.ResultSetMetaData metaData = set.getMetaData();
commit:3adee8c
/////////////////////////////////////////////////////////////////////////
1:         DataByteArrayOutputStream outputStream = xid.internalOutputStream();
commit:f0d0ce0
/////////////////////////////////////////////////////////////////////////
1:     char priorityIterator = 0; // unsigned
commit:64f3492
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore;
1: import org.apache.activemq.util.DataByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * A non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
1:      */
1:                              long expiration, byte priority, XATransactionId xid) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
1:             if (xid != null) {
1:                 byte[] xidVal = xid.getEncodedXidBytes();
1:                 xidVal[0] = '+';
0:                 setBinaryData(s, 8, xidVal);
1:             } else {
0:                 setBinaryData(s, 8, null);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * A non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
1:      */
1:     public void doRemoveMessage(TransactionContext c, long seq, XATransactionId xid) throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(xid == null ?
1:                         this.statements.getRemoveMessageStatement() : this.statements.getUpdateXidFlagStatement());
1:             if (xid == null) {
1:                 s.setLong(1, seq);
1:             } else {
1:                 byte[] xidVal = xid.getEncodedXidBytes();
0:                 setBinaryData(s, 1, xidVal);
1:                 s.setLong(2, seq);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public void doSetLastAckWithPriority(TransactionContext c, ActiveMQDestination destination, XATransactionId xid, String clientId,
1:                                          String subscriptionName, long seq, long priority) throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(xid == null ?
1:                         this.statements.getUpdateDurableLastAckWithPriorityStatement() :
1:                         this.statements.getUpdateDurableLastAckWithPriorityInTxStatement());
1:             if (xid != null) {
1:                 byte[] xidVal = encodeXid(xid, seq, priority);
0:                 setBinaryData(s, 1, xidVal);
1:             } else {
1:                 s.setLong(1, seq);
1:             }
0:             s.setLong(5, priority);
1:                 throw new SQLException("Failed update last ack with priority: " + priority + ", for sub: " + subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:     public void doSetLastAck(TransactionContext c, ActiveMQDestination destination, XATransactionId xid, String clientId,
1:                              String subscriptionName, long seq, long priority) throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(xid == null ?
1:                         this.statements.getUpdateDurableLastAckStatement() :
1:                         this.statements.getUpdateDurableLastAckInTxStatement());
1:             if (xid != null) {
1:                 byte[] xidVal = encodeXid(xid, seq, priority);
0:                 setBinaryData(s, 1, xidVal);
1:             } else {
1:                 s.setLong(1, seq);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private byte[] encodeXid(XATransactionId xid, long seq, long priority) {
1:         byte[] xidVal = xid.getEncodedXidBytes();
1:         // encode the update
0:         DataByteArrayOutputStream outputStream = xid.getOutputStream();
1:         outputStream.position(1);
1:         outputStream.writeLong(seq);
1:         outputStream.writeByte(Long.valueOf(priority).byteValue());
1:         return xidVal;
1:     }
1: 
1:     @Override
1:     public void doClearLastAck(TransactionContext c, ActiveMQDestination destination, byte priority, String clientId, String subName) throws SQLException, IOException {
1:         PreparedStatement s = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
1:             s = c.getConnection().prepareStatement(this.statements.getClearDurableLastAckInTxStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subName);
1:             s.setLong(4, priority);
1:             if (s.executeUpdate() != 1) {
1:                 throw new IOException("Could not remove prepared transaction state from message ack for: " + clientId + ":" + subName);
1:             }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(s);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void doRecoverPreparedOps(TransactionContext c, JdbcMemoryTransactionStore jdbcMemoryTransactionStore) throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getFindOpsPendingOutcomeStatement());
1:             while (rs.next()) {
1:                 long id = rs.getLong(1);
0:                 byte[] encodedXid = getBinaryData(rs, 2);
1:                 if (encodedXid[0] == '+') {
1:                     jdbcMemoryTransactionStore.recoverAdd(id, getBinaryData(rs, 3));
1:                 } else {
1:                     jdbcMemoryTransactionStore.recoverAck(id, encodedXid, getBinaryData(rs, 3));
1:                 }
1: 
1:             close(rs);
1:             close(s);
1: 
1:             s = c.getConnection().prepareStatement(this.statements.getFindAcksPendingOutcomeStatement());
1:             rs = s.executeQuery();
1:             while (rs.next()) {
0:                 byte[] encodedXid = getBinaryData(rs, 1);
1:                 String destination = rs.getString(2);
1:                 String subName = rs.getString(3);
1:                 String subId = rs.getString(4);
1:                 jdbcMemoryTransactionStore.recoverLastAck(encodedXid,
1:                         ActiveMQDestination.createDestination(destination, ActiveMQDestination.TOPIC_TYPE),
1:                         subName, subId);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public void doCommitAddOp(TransactionContext c, long sequence) throws SQLException, IOException {
1:         PreparedStatement s = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
1:             s = c.getConnection().prepareStatement(this.statements.getClearXidFlagStatement());
1:             s.setLong(1, sequence);
1:             if (s.executeUpdate() != 1) {
1:                 throw new IOException("Could not remove prepared transaction state from message add for sequenceId: " + sequence);
1:             }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(s);
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long doGetLastProducerSequenceId(TransactionContext c, ProducerId id)
1:             throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
1:             s = c.getConnection().prepareStatement(this.statements.getLastProducerSequenceIdStatement());
1:             s.setString(1, id.toString());
1:             rs = s.executeQuery();
1:             long seq = -1;
1:             if (rs.next()) {
1:                 seq = rs.getLong(1);
1:             }
1:             return seq;
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:b6f63b0
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintStream;
0: import java.sql.Connection;
0: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
1:                 if (result == 0 && rs.wasNull()) {
1:                     result = -1;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     @Override
1:     public void doRecordDestination(TransactionContext c, ActiveMQDestination destination) throws SQLException, IOException {
1:         PreparedStatement s = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
1:             s = c.getConnection().prepareStatement(this.statements.getCreateDurableSubStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, destination.getQualifiedName());
1:             s.setString(3, destination.getQualifiedName());
1:             s.setString(4, null);
1:             s.setLong(5, 0);
1:             s.setString(6, destination.getQualifiedName());
1:             s.setLong(7, 11);  // entry out of priority range
1: 
1:             if (s.executeUpdate() != 1) {
1:                 throw new IOException("Could not create ack record for destination: " + destination);
1:             }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(s);
1:         }
1:     }
commit:adc45e8
/////////////////////////////////////////////////////////////////////////
1:     protected static void close(PreparedStatement s) {
1:     protected static void close(ResultSet rs) {
commit:fe31092
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(Math.max(maxReturned * 2, maxRows));
/////////////////////////////////////////////////////////////////////////
0:     int priorityIterator = 0;
1:     public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {
1:             LOG.debug("Executing SQL: " + this.statements.getDeleteOldMessagesStatementWithPriority());
0:             s = c.getConnection().prepareStatement(this.statements.getDeleteOldMessagesStatementWithPriority());
1:             int priority = priorityIterator++%10;
1:             s.setInt(1, priority);
1:             s.setInt(2, priority);
1:             LOG.debug("Deleted " + i + " old message(s) at priority: " + priority);
/////////////////////////////////////////////////////////////////////////
0:     }  */
commit:8191f19
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             s.setLong(4, seq);
/////////////////////////////////////////////////////////////////////////
1:             s.setLong(4, seq);
0:             s.setLong(5, priority);
commit:4fbf92d
/////////////////////////////////////////////////////////////////////////
0:     public static final int MAX_ROWS = 10000;
0:     // needs to be min twice the prefetch for a durable sub and large enough for selector range
1:     protected int maxRows = MAX_ROWS;
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(Math.max(maxReturned * 2, maxRows));
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(Math.max(maxReturned * 2, maxRows));
commit:4679c8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     // needs to be min twice the prefetch for a durable sub
0:     protected int maxRows = 2000;
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesStatement());
0:             s.setMaxRows(maxReturned * 2);
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriptionName);
1:             rs = s.executeQuery();
1:             int count = 0;
1:             if (this.statements.isUseExternalMessageReferences()) {
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessageReference(rs.getString(1))) {
1:                         count++;
1:                     }
1:                 }
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:                         count++;
1:                     }
1:                 }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
1:     public void doRecoverNextMessagesWithPriority(TransactionContext c, ActiveMQDestination destination, String clientId,
1:             String subscriptionName, long seq, long priority, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
1: 
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
0:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesByPriorityStatement());
0:             // maxRows needs to be twice prefetch as the db will replay all unacked, so inflight messages will
0:             // be returned and suppressed by the cursor audit. It is faster this way.
0:             s.setMaxRows(maxRows);
/////////////////////////////////////////////////////////////////////////
1:             String clientId, String subscriptionName, boolean isPrioritizedMessages) throws SQLException, IOException {
1:             if (isPrioritizedMessages) {
/////////////////////////////////////////////////////////////////////////
1:     public void doSetSubscriberEntry(TransactionContext c, SubscriptionInfo info, boolean retroactive, boolean isPrioritizedMessages)
/////////////////////////////////////////////////////////////////////////
1:             if (isPrioritizedMessages) {
/////////////////////////////////////////////////////////////////////////
0:     public void doDeleteOldMessages(TransactionContext c, boolean isPrioritizedMessages) throws SQLException, IOException {
1:             if (isPrioritizedMessages) {
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public int getMaxRows() {
1:         return maxRows;
1:     }
1: 
1:     public void setMaxRows(int maxRows) {
1:         this.maxRows = maxRows;
/////////////////////////////////////////////////////////////////////////
0:             long priority, int maxReturned, boolean isPrioritizedMessages, JDBCMessageRecoveryListener listener) throws Exception {
1:             if (isPrioritizedMessages) {
/////////////////////////////////////////////////////////////////////////
0:             if (isPrioritizedMessages) {
commit:fa4481c
/////////////////////////////////////////////////////////////////////////
0:     public void doSetLastAckWithPriority(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                 s = c.getConnection().prepareStatement(this.statements.getUpdateLastPriorityAckRowOfDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void doSetLastAck(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                                         String subscriptionName, long seq, long priority) throws SQLException, IOException {
1:         PreparedStatement s = c.getUpdateLastAckStatement();
1:             if (s == null) {
0:                 s = c.getConnection().prepareStatement(this.statements.getUpdateDurableLastAckStatement());
0:                 if (this.batchStatments) {
1:                     c.setUpdateLastAckStatement(s);
1:                 }
1:             }
0:             if (this.batchStatments) {
1:                 s.addBatch();
1:             } else if (s.executeUpdate() != 1) {
1:             }
0:             if (!this.batchStatments) {
1:                 close(s);
1:             }            
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (this.isPrioritizedMessages()) {
1:                 s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatementWithPriority());
1:             } else {
0:                 s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatement());    
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int maxPriority = 1;
0:             if (this.isPrioritizedMessages()) {
1:                 maxPriority = 10;
1: 
1:             for (int priority = 0; priority < maxPriority; priority++) {
1:                 s.setString(1, info.getDestination().getQualifiedName());
1:                 s.setString(2, info.getClientId());
1:                 s.setString(3, info.getSubscriptionName());
1:                 s.setString(4, info.getSelector());
1:                 s.setLong(5, lastMessageId);
1:                 s.setString(6, info.getSubscribedDestination().getQualifiedName());
0:                 s.setLong(7, priority);
1: 
1:                 if (s.executeUpdate() != 1) {
1:                     throw new IOException("Could not create durable subscription for: " + info.getClientId());
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (this.isPrioritizedMessages()) {
0:                 LOG.debug("Executing SQL: " + this.statements.getDeleteOldMessagesStatementWithPriority());
0:                 s = c.getConnection().prepareStatement(this.statements.getDeleteOldMessagesStatementWithPriority());
1:             } else {
0:                 LOG.debug("Executing SQL: " + this.statements.getDeleteOldMessagesStatement());
0:                 s = c.getConnection().prepareStatement(this.statements.getDeleteOldMessagesStatement());
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public long doGetLastAckedDurableSubscriberMessageId(TransactionContext c, ActiveMQDestination destination,
1:         long result = -1;
/////////////////////////////////////////////////////////////////////////
1:                 result = rs.getLong(1);
commit:06cbebc
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReadWriteLock;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
0:     protected ReadWriteLock cleanupExclusiveLock = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         doCreatePriorityAckRow(c, destination, clientId, subscriptionName, prio);
0:         doUpdateLatestAckRow(c, destination, clientId, subscriptionName, seq, prio);
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
1:             s.setString(2, destination.getQualifiedName());
1:             s.setString(3, clientId);
1:             s.setString(4, subscriptionName);
0:             s.setLong(5, prio);
0:                 throw new SQLException("Failed update last ack with priority: " + prio + ", for sub: " + subscriptionName);
0:             cleanupExclusiveLock.readLock().unlock();
0:     private void doCreatePriorityAckRow(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                                         String subscriptionName,long priority) throws SQLException, IOException{
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
0:         boolean exists = false;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
0:             s = c.getConnection().prepareStatement(this.statements.getSelectDurablePriorityAckStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriptionName);
0:             s.setLong(4, priority);
1: 
1:             rs = s.executeQuery();
0:             exists = rs.next();
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(rs);
1:             close(s);
1:         }
1: 
0:         if (!exists) {
0:             cleanupExclusiveLock.readLock().lock();
1:             try {
0:                 s = c.getConnection().prepareStatement(this.statements.getInsertDurablePriorityAckStatement());
1:                 s.setString(1, destination.getQualifiedName());
1:                 s.setString(2, clientId);
1:                 s.setString(3, subscriptionName);
0:                 s.setLong(4, priority);
0:                 if (s.executeUpdate() != 1) {
0:                     throw new IOException("Could not insert initial ack entry for priority: "
0:                             + priority + ", for sub: " + subscriptionName);
1:                 }
1: 
1:             } finally {
0:                 cleanupExclusiveLock.readLock().unlock();
1:                 close(s);
1:             }
1:         }
1:     }
1: 
0:     private void doUpdateLatestAckRow(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                                         String subscriptionName, long seq, long priority) throws SQLException, IOException{
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
0:         cleanupExclusiveLock.readLock().lock();
1:         try {
0:             s = c.getConnection().prepareStatement(this.statements.getUpdateDurableLastAckStatement());
1:             s.setLong(1, seq);
1:             s.setString(2, destination.getQualifiedName());
1:             s.setString(3, clientId);
1:             s.setString(4, subscriptionName);
1: 
0:            if (s.executeUpdate() != 1) {
1:                 throw new IOException("Could not update last ack seq : "
1:                             + seq + ", for sub: " + subscriptionName);
1:            }
1:         } finally {
0:             cleanupExclusiveLock.readLock().unlock();
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
0:         cleanupExclusiveLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         cleanupExclusiveLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
0:             cleanupExclusiveLock.readLock().unlock();
commit:3432a75
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public long[] doGetLastAckedDurableSubscriberMessageId(TransactionContext c, ActiveMQDestination destination,
0:         long[] result = new long[]{-1, Byte.MAX_VALUE - 1};
/////////////////////////////////////////////////////////////////////////
0:                 result[0] = rs.getLong(1);
0:                 result[1] = rs.getLong(2);
/////////////////////////////////////////////////////////////////////////
0:             long priority, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             s.setLong(2, nextSeq);
0:             if (isPrioritizedMessages()) {
0:                 s.setLong(3, priority);
0:                 s.setLong(4, priority);
commit:f206a1b
/////////////////////////////////////////////////////////////////////////
0:             // no set max rows as selectors may need to scan more than maxReturned messages to get what they need
/////////////////////////////////////////////////////////////////////////
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
0:     public long getStoreSequenceId(TransactionContext c, ActiveMQDestination destination, MessageId messageID) throws SQLException, IOException {
0:             s.setString(3, destination.getQualifiedName());
/////////////////////////////////////////////////////////////////////////
0:     public long doGetLastProducerSequenceId(TransactionContext c, ProducerId id)
1:             throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(this.statements.getLastProducerSequenceIdStatement());
0:             s.setString(1, id.toString());
1:             rs = s.executeQuery();
0:             long seq = -1;
1:             if (rs.next()) {
0:                 seq = rs.getLong(1);
1:             }
0:             return seq;
1:         } finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
commit:0bc545b
/////////////////////////////////////////////////////////////////////////
1:             // jdbc scrollable cursor requires jdbc ver > 1.0 and is often implemented locally so avoid
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("messageIdScan with limit (" + limit + "), resulted in: " + reverseOrderIds.size() + " ids");
1:             }
commit:5fb5235
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
0:             // jdbc scrollable cursor requires jdbc ver > 1.0 andis  often implemented locally so avoid
1:             LinkedList<MessageId> reverseOrderIds = new LinkedList<MessageId>();
1:                 reverseOrderIds.addFirst(new MessageId(rs.getString(2), rs.getLong(3)));
1:             }
1:             for (MessageId id : reverseOrderIds) {
1:                 listener.messageId(id);
commit:8732f70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.jdbc.JDBCMessageIdScanListener;
/////////////////////////////////////////////////////////////////////////
0:     public void doMessageIdScan(TransactionContext c, ActiveMQDestination destination, long limit, 
1:             JDBCMessageIdScanListener listener) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(this.statements.getFindAllMessageIds());
1:             s.setString(1, destination.getQualifiedName());
0:             // limit the query. just need the the last few messages that could be replayed 
0:             // on recovery. send or commit reply lost so it gets replayed.
1:             rs = s.executeQuery();
1:             while (rs.next()) {
0:                 if (!listener.messageId(new MessageId(rs.getString(2), rs.getLong(3)))) { 
1:                     break;
1:                 }
1:             }
1:         } finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1:     
commit:e2778fb
/////////////////////////////////////////////////////////////////////////
0:             if (!this.batchStatments && s != null) {
commit:9bb4682
/////////////////////////////////////////////////////////////////////////
0:             s.setLong(2, nextSeq);
commit:5a81bbb
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Executing SQL: " + dropStatments[i]);
/////////////////////////////////////////////////////////////////////////
0:                 if (s!=null) {
1:                     s.close();
1:                 }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:282f145
/////////////////////////////////////////////////////////////////////////
0:             c.getConnection().commit();
commit:9f6efd4
/////////////////////////////////////////////////////////////////////////
0:                 c.getConnection().commit();
commit:582f340
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement s = c.getUpdateLastAckStatement();
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:                     s.execute(createStatments[i]);
/////////////////////////////////////////////////////////////////////////
1:                     s.execute(dropStatments[i]);
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<SubscriptionInfo> rc = new ArrayList<SubscriptionInfo>();
/////////////////////////////////////////////////////////////////////////
1:             return rc.toArray(new SubscriptionInfo[rc.size()]);
/////////////////////////////////////////////////////////////////////////
1:     public Set<ActiveMQDestination> doGetDestinations(TransactionContext c) throws SQLException, IOException {
1:         HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
1:                 rc.add(ActiveMQDestination.createDestination(rs.getString(1), ActiveMQDestination.QUEUE_TYPE));
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(DefaultJDBCAdapter.class);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Executing SQL: " + createStatments[i]);
0:                         LOG.debug("Could not create JDBC tables; The message table already existed."
0:                         LOG.warn("Could not create JDBC tables; they could already exist." + " Failure was: "
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Could not drop JDBC tables; they may not exist." + " Failure was: "
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Executing SQL: " + statements.getDeleteOldMessagesStatement());
0:             LOG.debug("Deleted " + i + " old message(s).");
/////////////////////////////////////////////////////////////////////////
0:     private static void close(PreparedStatement s) {
0:     private static void close(ResultSet rs) {
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Stopped recover next messages");
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Stopped recover next messages");
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:  * Implements all the default JDBC operations that are used by the
0:  * JDBCPersistenceAdapter. <p/> sub-classing is encouraged to override the
0:  * default implementation of methods to account for differences in JDBC Driver
0:  * implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using
0:  * the getBytes()/setBytes() operations. <p/> The databases/JDBC drivers that
0:  * use this adapter are:
/////////////////////////////////////////////////////////////////////////
1: public class DefaultJDBCAdapter implements JDBCAdapter {
0:     private static final Log log = LogFactory.getLog(DefaultJDBCAdapter.class);
1:     protected boolean batchStatments = true;
1:     protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {
1:         s.setBytes(index, data);
1:     protected byte[] getBinaryData(ResultSet rs, int index) throws SQLException {
0:     public void doCreateTables(TransactionContext c) throws SQLException, IOException {
1:         Statement s = null;
1:         try {
0:             // Check to see if the table already exists. If it does, then don't
0:             // log warnings during startup.
0:             // Need to run the scripts anyways since they may contain ALTER
0:             // statements that upgrade a previous version
0:             boolean alreadyExists = false;
1:             ResultSet rs = null;
1:             try {
0:                 rs = c.getConnection().getMetaData().getTables(null, null,
0:                                                                statements.getFullMessageTableName(),
0:                                                                new String[] {"TABLE"});
0:                 alreadyExists = rs.next();
0:             } catch (Throwable ignore) {
1:             } finally {
1:             s = c.getConnection().createStatement();
0:             String[] createStatments = statements.getCreateSchemaStatements();
0:             for (int i = 0; i < createStatments.length; i++) {
1:                 try {
0:                     log.debug("Executing SQL: " + createStatments[i]);
0:                     boolean rc = s.execute(createStatments[i]);
1:                 } catch (SQLException e) {
0:                     if (alreadyExists) {
0:                         log.debug("Could not create JDBC tables; The message table already existed."
0:                                   + " Failure was: " + createStatments[i] + " Message: " + e.getMessage()
0:                                   + " SQLState: " + e.getSQLState() + " Vendor code: " + e.getErrorCode());
1:                     } else {
0:                         log.warn("Could not create JDBC tables; they could already exist." + " Failure was: "
0:                                  + createStatments[i] + " Message: " + e.getMessage() + " SQLState: "
0:                                  + e.getSQLState() + " Vendor code: " + e.getErrorCode());
1:                         JDBCPersistenceAdapter.log("Failure details: ", e);
1:         } finally {
1:             try {
1:             } catch (Throwable e) {
1:     public void doDropTables(TransactionContext c) throws SQLException, IOException {
1:         Statement s = null;
1:         try {
1:             s = c.getConnection().createStatement();
0:             String[] dropStatments = statements.getDropSchemaStatements();
1:             for (int i = 0; i < dropStatments.length; i++) {
1:                 try {
0:                     boolean rc = s.execute(dropStatments[i]);
1:                 } catch (SQLException e) {
0:                     log.warn("Could not drop JDBC tables; they may not exist." + " Failure was: "
0:                              + dropStatments[i] + " Message: " + e.getMessage() + " SQLState: "
0:                              + e.getSQLState() + " Vendor code: " + e.getErrorCode());
1:                     JDBCPersistenceAdapter.log("Failure details: ", e);
1:         } finally {
1:             try {
1:             } catch (Throwable e) {
0:     public long doGetLastMessageBrokerSequenceId(TransactionContext c) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
1:             rs = s.executeQuery();
1:             long seq1 = 0;
1:             if (rs.next()) {
1:                 seq1 = rs.getLong(1);
0:             s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInAcksStatement());
1:             rs = s.executeQuery();
1:             long seq2 = 0;
1:             if (rs.next()) {
1:                 seq2 = rs.getLong(1);
0:             return Math.max(seq1, seq2);
1:         } finally {
0:     public void doAddMessage(TransactionContext c, MessageId messageID, ActiveMQDestination destination,
0:                              byte[] data, long expiration) throws SQLException, IOException {
1:         PreparedStatement s = c.getAddMessageStatement();
1:         try {
1:             if (s == null) {
0:                 s = c.getConnection().prepareStatement(statements.getAddMessageStatement());
0:                 if (batchStatments) {
1:             s.setLong(1, messageID.getBrokerSequenceId());
1:             s.setString(2, messageID.getProducerId().toString());
1:             s.setLong(3, messageID.getProducerSequenceId());
1:             s.setString(4, destination.getQualifiedName());
1:             s.setLong(5, expiration);
0:             setBinaryData(s, 6, data);
0:             if (batchStatments) {
1:             } else if (s.executeUpdate() != 1) {
1:         } finally {
0:             if (!batchStatments) {
0:     public void doAddMessageReference(TransactionContext c, MessageId messageID,
0:                                       ActiveMQDestination destination, long expirationTime, String messageRef)
1:         throws SQLException, IOException {
1:         PreparedStatement s = c.getAddMessageStatement();
1:         try {
1:             if (s == null) {
0:                 s = c.getConnection().prepareStatement(statements.getAddMessageStatement());
0:                 if (batchStatments) {
1:             s.setLong(1, messageID.getBrokerSequenceId());
1:             s.setString(2, messageID.getProducerId().toString());
1:             s.setLong(3, messageID.getProducerSequenceId());
1:             s.setString(4, destination.getQualifiedName());
1:             s.setLong(5, expirationTime);
1:             s.setString(6, messageRef);
0:             if (batchStatments) {
1:             } else if (s.executeUpdate() != 1) {
1:         } finally {
0:             if (!batchStatments) {
0:     public long getBrokerSequenceId(TransactionContext c, MessageId messageID) throws SQLException,
1:         IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindMessageSequenceIdStatement());
1:             s.setString(1, messageID.getProducerId().toString());
1:             s.setLong(2, messageID.getProducerSequenceId());
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
1:         } finally {
0:     public byte[] doGetMessage(TransactionContext c, long seq) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindMessageStatement());
0:             s.setLong(1, seq);
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
1:             return getBinaryData(rs, 1);
1:         } finally {
1:     public String doGetMessageReference(TransactionContext c, long seq) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindMessageStatement());
0:             s.setLong(1, seq);
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
1:         } finally {
0:     public void doRemoveMessage(TransactionContext c, long seq) throws SQLException, IOException {
1:         PreparedStatement s = c.getRemovedMessageStatement();
1:         try {
1:             if (s == null) {
0:                 s = c.getConnection().prepareStatement(statements.getRemoveMessageStatment());
0:                 if (batchStatments) {
0:             s.setLong(1, seq);
0:             if (batchStatments) {
1:             } else if (s.executeUpdate() != 1) {
1:         } finally {
0:             if (!batchStatments) {
0:     public void doRecover(TransactionContext c, ActiveMQDestination destination,
0:                           JDBCMessageRecoveryListener listener) throws Exception {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindAllMessagesStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             rs = s.executeQuery();
0:             if (statements.isUseExternalMessageReferences()) {
1:                 while (rs.next()) {
1:             } else {
1:                 while (rs.next()) {
1:                     if (!listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:         } finally {
0:     public void doSetLastAck(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                              String subscriptionName, long seq) throws SQLException, IOException {
1:         PreparedStatement s = c.getAddMessageStatement();
1:         try {
1:             if (s == null) {
0:                 s = c.getConnection().prepareStatement(statements.getUpdateLastAckOfDurableSubStatement());
0:                 if (batchStatments) {
0:             s.setLong(1, seq);
0:             s.setString(2, destination.getQualifiedName());
0:             s.setString(3, clientId);
0:             s.setString(4, subscriptionName);
0:             if (batchStatments) {
1:             } else if (s.executeUpdate() != 1) {
1:         } finally {
0:             if (!batchStatments) {
1:     public void doRecoverSubscription(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                                       String subscriptionName, JDBCMessageRecoveryListener listener)
1:         throws Exception {
1:         // dumpTables(c,
1:         // destination.getQualifiedName(),clientId,subscriptionName);
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindAllDurableSubMessagesStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriptionName);
1:             rs = s.executeQuery();
0:             if (statements.isUseExternalMessageReferences()) {
1:                 while (rs.next()) {
1:                     if (!listener.recoverMessageReference(rs.getString(2))) {
1:             } else {
1:                 while (rs.next()) {
1:                     if (!listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:         } finally {
1:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, String clientId,
0:                                       String subscriptionName, long seq, int maxReturned,
0:                                       JDBCMessageRecoveryListener listener) throws Exception {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindDurableSubMessagesStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriptionName);
0:             s.setLong(4, seq);
1:             rs = s.executeQuery();
1:             int count = 0;
0:             if (statements.isUseExternalMessageReferences()) {
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessageReference(rs.getString(1))) {
1:                     } else {
1:             } else {
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
1:                     } else {
1:         } finally {
1:     public int doGetDurableSubscriberMessageCount(TransactionContext c, ActiveMQDestination destination,
0:                                                   String clientId, String subscriptionName)
1:         throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         int result = 0;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getDurableSubscriberMessageCountStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriptionName);
1:             rs = s.executeQuery();
1:             if (rs.next()) {
1:                 result = rs.getInt(1);
1:         } finally {
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doSetSubscriberEntry(java.sql.Connection,
0:      *      java.lang.Object, org.apache.activemq.service.SubscriptionInfo)
0:     public void doSetSubscriberEntry(TransactionContext c, SubscriptionInfo info, boolean retroactive)
0:         throws SQLException, IOException {
1:         // dumpTables(c, destination.getQualifiedName(), clientId,
1:         // subscriptionName);
1:         PreparedStatement s = null;
1:         try {
1:             long lastMessageId = -1;
1:             if (!retroactive) {
0:                 s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
1:                 ResultSet rs = null;
1:                 try {
1:                     rs = s.executeQuery();
1:                     if (rs.next()) {
1:                         lastMessageId = rs.getLong(1);
1:                 } finally {
0:             s = c.getConnection().prepareStatement(statements.getCreateDurableSubStatement());
0:             s.setString(1, info.getDestination().getQualifiedName());
0:             s.setString(2, info.getClientId());
0:             s.setString(3, info.getSubscriptionName());
0:             s.setString(4, info.getSelector());
0:             s.setLong(5, lastMessageId);
0:             if (s.executeUpdate() != 1) {
0:                 throw new IOException("Could not create durable subscription for: " + info.getClientId());
1:         } finally {
1:     public SubscriptionInfo doGetSubscriberEntry(TransactionContext c, ActiveMQDestination destination,
0:                                                  String clientId, String subscriptionName)
0:         throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindDurableSubStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
1:             SubscriptionInfo subscription = new SubscriptionInfo();
0:             subscription.setSubscribedDestination(ActiveMQDestination
0:                 .createDestination(rs.getString(2), ActiveMQDestination.QUEUE_TYPE));
1:         } finally {
1:     public SubscriptionInfo[] doGetAllSubscriptions(TransactionContext c, ActiveMQDestination destination)
0:         throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindAllDurableSubsStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             rs = s.executeQuery();
0:             ArrayList rc = new ArrayList();
1:             while (rs.next()) {
1:                 SubscriptionInfo subscription = new SubscriptionInfo();
0:                 subscription.setSubscribedDestination(ActiveMQDestination
0:                     .createDestination(rs.getString(4), ActiveMQDestination.QUEUE_TYPE));
1:         } finally {
0:     public void doRemoveAllMessages(TransactionContext c, ActiveMQDestination destinationName)
0:         throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getRemoveAllMessagesStatement());
1:             s.setString(1, destinationName.getQualifiedName());
0:             s = c.getConnection().prepareStatement(statements.getRemoveAllSubscriptionsStatement());
1:             s.setString(1, destinationName.getQualifiedName());
1:         } finally {
1:     public void doDeleteSubscription(TransactionContext c, ActiveMQDestination destination, String clientId,
1:                                      String subscriptionName) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getDeleteSubscriptionStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
1:         } finally {
0:     public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         try {
0:             log.debug("Executing SQL: " + statements.getDeleteOldMessagesStatement());
0:             s = c.getConnection().prepareStatement(statements.getDeleteOldMessagesStatement());
0:             s.setLong(1, System.currentTimeMillis());
1:             int i = s.executeUpdate();
0:             log.debug("Deleted " + i + " old message(s).");
1:         } finally {
1: 
0:     public long doGetLastAckedDurableSubscriberMessageId(TransactionContext c,
0:                                                          ActiveMQDestination destination, String clientId,
0:                                                          String subscriberName) throws SQLException,
1:         IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection()
0:                 .prepareStatement(statements.getLastAckedDurableSubscriberMessageStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriberName);
1:             rs = s.executeQuery();
1:             if (rs.next()) {
0:                 result = rs.getLong(1);
1:         } finally {
0:     static private void close(PreparedStatement s) {
1:         try {
1:         } catch (Throwable e) {
0:     static private void close(ResultSet rs) {
1:         try {
1:         } catch (Throwable e) {
0:     public Set doGetDestinations(TransactionContext c) throws SQLException, IOException {
0:         HashSet rc = new HashSet();
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindAllDestinationsStatement());
1:             rs = s.executeQuery();
1:             while (rs.next()) {
0:                 rc
0:                     .add(ActiveMQDestination.createDestination(rs.getString(1),
1:                                                                ActiveMQDestination.QUEUE_TYPE));
1:         } finally {
0:     public boolean isBatchStatments() {
1:     public void setBatchStatments(boolean batchStatments) {
1:         this.batchStatments = batchStatments;
1:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {
1:     public Statements getStatements() {
1:     public void setStatements(Statements statements) {
1:         this.statements = statements;
0:     public byte[] doGetNextDurableSubscriberMessageStatement(TransactionContext c,
0:                                                              ActiveMQDestination destination,
0:                                                              String clientId, String subscriberName)
0:         throws SQLException, IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getNextDurableSubscriberMessageStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             s.setString(2, clientId);
1:             s.setString(3, subscriberName);
1:             rs = s.executeQuery();
1:             if (!rs.next()) {
0:             return getBinaryData(rs, 1);
1:         } finally {
1:     }
1: 
1:     public int doGetMessageCount(TransactionContext c, ActiveMQDestination destination) throws SQLException,
1:         IOException {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         int result = 0;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getDestinationMessageCountStatement());
1:             s.setString(1, destination.getQualifiedName());
1:             rs = s.executeQuery();
1:             if (rs.next()) {
1:                 result = rs.getInt(1);
1:         } finally {
0:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, long nextSeq,
0:                                       int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
1:         PreparedStatement s = null;
1:         ResultSet rs = null;
1:         try {
0:             s = c.getConnection().prepareStatement(statements.getFindNextMessagesStatement());
1:             s.setString(1, destination.getQualifiedName());
0:             s.setLong(2, nextSeq);
1:             rs = s.executeQuery();
1:             int count = 0;
0:             if (statements.isUseExternalMessageReferences()) {
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessageReference(rs.getString(1))) {
0:                     } else {
0:             } else {
0:                 while (rs.next() && count < maxReturned) {
1:                     if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {
0:                     } else {
1:         } catch (Exception e) {
1:         } finally {
0:      * Useful for debugging. public void dumpTables(Connection c, String
0:      * destinationName, String clientId, String subscriptionName) throws
0:      * SQLException { printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
0:      * printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
0:      * PreparedStatement s = c.prepareStatement("SELECT M.ID, D.LAST_ACKED_ID
0:      * FROM " +"ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D " +"WHERE D.CONTAINER=? AND
0:      * D.CLIENT_ID=? AND D.SUB_NAME=?" +" AND M.CONTAINER=D.CONTAINER AND M.ID >
0:      * D.LAST_ACKED_ID" +" ORDER BY M.ID"); s.setString(1,destinationName);
0:      * s.setString(2,clientId); s.setString(3,subscriptionName);
0:      * public void dumpTables(Connection c) throws SQLException { printQuery(c,
0:      * "Select * from ACTIVEMQ_MSGS", System.out); printQuery(c, "Select * from
0:      * ACTIVEMQ_ACKS", System.out); }
0:      * private void printQuery(Connection c, String query, PrintStream out)
0:      * throws SQLException { printQuery(c.prepareStatement(query), out); }
0:      * private void printQuery(PreparedStatement s, PrintStream out) throws
0:      * SQLException {
0:      * ResultSet set=null; try { set = s.executeQuery(); ResultSetMetaData
0:      * metaData = set.getMetaData(); for( int i=1; i<=
0:      * metaData.getColumnCount(); i++ ) { if(i==1) out.print("||");
0:      * out.print(metaData.getColumnName(i)+"||"); } out.println();
0:      * while(set.next()) { for( int i=1; i<= metaData.getColumnCount(); i++ ) {
0:      * if(i==1) out.print("|"); out.print(set.getString(i)+"|"); }
0:      * out.println(); } } finally { try { set.close(); } catch (Throwable
0:      * ignore) {} try { s.close(); } catch (Throwable ignore) {} } }
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0:     public void doSetSubscriberEntry(TransactionContext c,SubscriptionInfo info,boolean retroactive) throws SQLException,IOException{
/////////////////////////////////////////////////////////////////////////
0:             s.setString(1,info.getDestination().getQualifiedName());
0:             s.setString(2,info.getClientId());
0:             s.setString(3,info.getSubscriptionName());
0:             s.setString(4,info.getSelector());
0:             s.setString(6, info.getSubscribedDestination().getQualifiedName());
0:                 throw new IOException("Could not create durable subscription for: "+info.getClientId());
/////////////////////////////////////////////////////////////////////////
1:             subscription.setSubscriptionName(subscriptionName);
0:             subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(2), ActiveMQDestination.QUEUE_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                 subscription.setSubscriptionName(rs.getString(2));
0:                 subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(4),ActiveMQDestination.QUEUE_TYPE));
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:f1e3420
/////////////////////////////////////////////////////////////////////////
0:             log.debug("Executing SQL: "+statements.getDeleteOldMessagesStatement());
commit:28316bb
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement s = c.getRemovedMessageStatement();
commit:4c96523
/////////////////////////////////////////////////////////////////////////
0:                     log.debug("Executing SQL: "+createStatments[i]);
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     public void doRecover(TransactionContext c, ActiveMQDestination destination, JDBCMessageRecoveryListener listener) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void doRecoverSubscription(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName, JDBCMessageRecoveryListener listener) throws Exception {
commit:4843dd4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.jdbc.Statements;
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean element="defaultJDBCAdapter"
0:  * 
1:     protected Statements statements;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 rs= c.getConnection().getMetaData().getTables(null,null, statements.getFullMessageTableName(), new String[] {"TABLE"});
/////////////////////////////////////////////////////////////////////////
0:             String[] createStatments = statements.getCreateSchemaStatements();
/////////////////////////////////////////////////////////////////////////
0:             String[] dropStatments = statements.getDropSchemaStatements();
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInAcksStatement());
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(statements.getAddMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(statements.getAddMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindMessageSequenceIdStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(statements.getRemoveMessageStatment());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindAllMessagesStatement());
0:             if( statements.isUseExternalMessageReferences() ) {
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(statements.getUpdateLastAckOfDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindAllDurableSubMessagesStatement());
0:             if( statements.isUseExternalMessageReferences() ) {
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getCreateDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindAllDurableSubsStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getRemoveAllMessagesStatement());
0:             s = c.getConnection().prepareStatement(statements.getRemoveAllSubscriptionsStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getDeleteSubscriptionStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getDeleteOldMessagesStatement());
/////////////////////////////////////////////////////////////////////////
0:             s = c.getConnection().prepareStatement(statements.getFindAllDestinationsStatement());
/////////////////////////////////////////////////////////////////////////
0:         statements.setUseExternalMessageReferences(useExternalMessageReferences);
1:     }
1: 
0:     public Statements getStatements() {
0:         return statements;
1:     }
1: 
0:     public void setStatements(Statements statements) {
0:         this.statements = statements;
commit:911177e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:                         JDBCPersistenceAdapter.log("Failure details: ",e);
/////////////////////////////////////////////////////////////////////////
0:                     JDBCPersistenceAdapter.log("Failure details: ",e);
commit:96adbc3
/////////////////////////////////////////////////////////////////////////
1:                 rc.add(subscription);
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void dumpTables(Connection c) throws SQLException {
0:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
0:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
1:     }
commit:9b64c37
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:     public SubscriptionInfo[] doGetAllSubscriptions(TransactionContext c, ActiveMQDestination destination) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindAllDurableSubsStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             rs = s.executeQuery();
1: 
0:             ArrayList rc = new ArrayList();
0:             while(rs.next()) {
0:                 SubscriptionInfo subscription = new SubscriptionInfo();
1:                 subscription.setDestination(destination);
1:                 subscription.setSelector(rs.getString(1));
0:                 subscription.setSubcriptionName(rs.getString(2));
1:                 subscription.setClientId(rs.getString(3));
1:             }
1: 
0:             return (SubscriptionInfo[]) rc.toArray(new SubscriptionInfo[rc.size()]);            
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
commit:c0edaf0
/////////////////////////////////////////////////////////////////////////
1:             
0:             // Check to see if the table already exists.  If it does, then don't log warnings during startup.
0:             // Need to run the scripts anyways since they may contain ALTER statements that upgrade a previous version of the table
0:             boolean alreadyExists = false;
0:             ResultSet rs=null;
0:             try {
0:                 rs= c.getConnection().getMetaData().getTables(null,null, statementProvider.getFullMessageTableName(), new String[] {"TABLE"});
0:                 alreadyExists = rs.next();                
0:             } catch (Throwable ignore) {
0:             } finally {
1:                 close(rs);
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
0:                     if( alreadyExists )  {
0:                         log.debug("Could not create JDBC tables; The message table already existed." +
0:                                 " Failure was: " + createStatments[i] + " Message: " + e.getMessage() +
0:                                 " SQLState: " + e.getSQLState() + " Vendor code: " + e.getErrorCode() );
0:                     } else {
0:                         log.warn("Could not create JDBC tables; they could already exist." +
0:                             " Failure was: " + createStatments[i] + " Message: " + e.getMessage() +
0:                             " SQLState: " + e.getSQLState() + " Vendor code: " + e.getErrorCode() );
1:                     }
1:             
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc.adapter;
1: 
1: import java.io.IOException;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.HashSet;
1: import java.util.Set;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.store.jdbc.JDBCAdapter;
1: import org.apache.activemq.store.jdbc.JDBCMessageRecoveryListener;
0: import org.apache.activemq.store.jdbc.StatementProvider;
1: import org.apache.activemq.store.jdbc.TransactionContext;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
0:  * Implements all the default JDBC operations that are used
0:  * by the JDBCPersistenceAdapter.
0:  * <p/>
0:  * sub-classing is encouraged to override the default
0:  * implementation of methods to account for differences
0:  * in JDBC Driver implementations.
0:  * <p/>
0:  * The JDBCAdapter inserts and extracts BLOB data using the
0:  * getBytes()/setBytes() operations.
0:  * <p/>
1:  * The databases/JDBC drivers that use this adapter are:
1:  * <ul>
1:  * <li></li>
1:  * </ul>
0:  *
0:  * @version $Revision: 1.10 $
1:  */
0: public class DefaultJDBCAdapter implements JDBCAdapter {
1: 
0:     private static final Log log = LogFactory.getLog(DefaultJDBCAdapter.class);
1: 
0:     final protected StatementProvider statementProvider;
0:     protected boolean batchStatments=true;
1: 
0:     protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {
0:         s.setBytes(index, data);
1:     }
1: 
0:     protected byte[] getBinaryData(ResultSet rs, int index) throws SQLException {
1:         return rs.getBytes(index);
1:     }
1: 
1:     /**
0:      * @param provider
1:      */
0:     public DefaultJDBCAdapter(StatementProvider provider) {
0:         this.statementProvider = new CachingStatementProvider(provider);
1:     }
1: 
0:     public DefaultJDBCAdapter() {
0:         this(new DefaultStatementProvider());
1:     }
1: 
0:     public void doCreateTables(TransactionContext c) throws SQLException, IOException {
0:         Statement s = null;
0:         try {
0:             log.info("creating tables");
0:             s = c.getConnection().createStatement();
0:             String[] createStatments = statementProvider.getCreateSchemaStatments();
0:             for (int i = 0; i < createStatments.length; i++) {
1:                 // This will fail usually since the tables will be
1:                 // created already.
0:                 try {
0:                     boolean rc = s.execute(createStatments[i]);
1:                 }
0:                 catch (SQLException e) {
0:                     log.warn("Could not create JDBC tables; they could already exist." +
0:                         " Failure was: " + createStatments[i] + " Message: " + e.getMessage() +
0:                         " SQLState: " + e.getSQLState() + " Vendor code: " + e.getErrorCode() );
1:                 }
1:             }
0:             c.getConnection().commit();
0:             log.info("done creating tables");
1:         }
0:         finally {
0:             try {
1:                 s.close();
1:             }
0:             catch (Throwable e) {
1:             }
1:         }
1:     }
1: 
0:     public void doDropTables(TransactionContext c) throws SQLException, IOException {
0:         Statement s = null;
0:         try {
0:             s = c.getConnection().createStatement();
0:             String[] dropStatments = statementProvider.getDropSchemaStatments();
0:             for (int i = 0; i < dropStatments.length; i++) {
1:                 // This will fail usually since the tables will be
1:                 // created already.
0:                 try {
0:                     boolean rc = s.execute(dropStatments[i]);
1:                 }
0:                 catch (SQLException e) {
0:                     log.warn("Could not drop JDBC tables; they may not exist." +
0:                         " Failure was: " + dropStatments[i] + " Message: " + e.getMessage() +
0:                         " SQLState: " + e.getSQLState() + " Vendor code: " + e.getErrorCode() );
1:                 }
1:             }
0:             c.getConnection().commit();
1:         }
0:         finally {
0:             try {
1:                 s.close();
1:             }
0:             catch (Throwable e) {
1:             }
1:         }
1:     }
0:     public long doGetLastMessageBrokerSequenceId(TransactionContext c) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
0:             s = c.getConnection().prepareStatement(statementProvider.getFindLastSequenceIdInMsgs());
0:             rs = s.executeQuery();
0:             long seq1 = 0;
0:             if (rs.next()) {
0:                 seq1 = rs.getLong(1);
1:             }
1:             rs.close();
1:             s.close();
0:             s = c.getConnection().prepareStatement(statementProvider.getFindLastSequenceIdInAcks());
0:             rs = s.executeQuery();
0:             long seq2 = 0;
0:             if (rs.next()) {
0:                 seq2 = rs.getLong(1);
1:             }
1:             
0:             return Math.max(seq1, seq2);
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
0:     public void doAddMessage(TransactionContext c, MessageId messageID, ActiveMQDestination destination, byte[] data, long expiration) throws SQLException, IOException {
0:         PreparedStatement s = c.getAddMessageStatement();
0:         try {
0:             if( s == null ) {
0:                 s = c.getConnection().prepareStatement(statementProvider.getAddMessageStatment());
0:                 if( batchStatments ) {
1:                     c.setAddMessageStatement(s);
1:                 }
1:             }
0:             s.setLong(1, messageID.getBrokerSequenceId());
0:             s.setString(2, messageID.getProducerId().toString());
0:             s.setLong(3, messageID.getProducerSequenceId());
0:             s.setString(4, destination.getQualifiedName());
0:             s.setLong(5, expiration);
0:             setBinaryData(s, 6, data);
0:             if( batchStatments ) {
1:                 s.addBatch();
0:             } else if ( s.executeUpdate() != 1 ) {
1:                 throw new SQLException("Failed add a message");
1:             }
0:         } finally {
0:             if( !batchStatments ) {
1:                 s.close();
1:             }
1:         }
1:     }
1:     
0:     public void doAddMessageReference(TransactionContext c, MessageId messageID, ActiveMQDestination destination, long expirationTime, String messageRef) throws SQLException, IOException {
0:         PreparedStatement s = c.getAddMessageStatement();
0:         try {
0:             if( s == null ) {
0:                 s = c.getConnection().prepareStatement(statementProvider.getAddMessageStatment());
0:                 if( batchStatments ) {
1:                     c.setAddMessageStatement(s);
1:                 }
1:             }
0:             s.setLong(1, messageID.getBrokerSequenceId());
0:             s.setString(2, messageID.getProducerId().toString());
0:             s.setLong(3, messageID.getProducerSequenceId());
0:             s.setString(4, destination.getQualifiedName());
0:             s.setLong(5, expirationTime);
0:             s.setString(6, messageRef);
0:             if( batchStatments ) {
1:                 s.addBatch();
0:             } else if ( s.executeUpdate() != 1 ) {
1:                 throw new SQLException("Failed add a message");
1:             }
0:         } finally {
0:             if( !batchStatments ) {
1:                 s.close();
1:             }
1:         }
1:     }
1: 
0:     public long getBrokerSequenceId(TransactionContext c, MessageId messageID) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindMessageSequenceIdStatment());
0:             s.setString(1, messageID.getProducerId().toString());
0:             s.setLong(2, messageID.getProducerSequenceId());
0:             rs = s.executeQuery();
1: 
0:             if (!rs.next()) {
0:                 return 0;
1:             }
0:             return rs.getLong(1);
1: 
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1: 	}
1: 
0:     public byte[] doGetMessage(TransactionContext c, long seq) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindMessageStatment());
0:             s.setLong(1, seq);
0:             rs = s.executeQuery();
1: 
0:             if (!rs.next()) {
1:                 return null;
1:             }
0:             return getBinaryData(rs, 1);
1: 
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1:     
0:     public String doGetMessageReference(TransactionContext c, long seq) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindMessageStatment());
0:             s.setLong(1, seq);
0:             rs = s.executeQuery();
1: 
0:             if (!rs.next()) {
1:                 return null;
1:             }
1:             return rs.getString(1);
1: 
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
0:     public void doRemoveMessage(TransactionContext c, long seq) throws SQLException, IOException {
1: 
0:         PreparedStatement s = c.getAddMessageStatement();
0:         try {
0:             if( s == null ) {
0:                 s = c.getConnection().prepareStatement(statementProvider.getRemoveMessageStatment());
0:                 if( batchStatments ) {
1:                     c.setRemovedMessageStatement(s);
1:                 }
1:             }
0:             s.setLong(1, seq);
1:             
0:             if( batchStatments ) {
1:                 s.addBatch();
0:             } else if ( s.executeUpdate() != 1 ) {
0:                 throw new SQLException("Failed to remove message");
1:             }
0:         } finally {
0:             if( !batchStatments ) {
1:                 s.close();
1:             }
1:         }        
1:     }
1:     
0:     public void doRecover(TransactionContext c, ActiveMQDestination destination, JDBCMessageRecoveryListener listener) throws Throwable {
0: //        printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
1: 
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindAllMessagesStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             rs = s.executeQuery();
1: 
0:             if( statementProvider.isUseExternalMessageReferences() ) {
0:                 while (rs.next()) {
0:                     listener.recoverMessageReference(rs.getString(2));
1:                 }
0:             } else {
0:                 while (rs.next()) {
0:                     listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2));
1:                 }
1:             }
1: 
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
1:     
0:     public void doSetLastAck(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName, long seq) throws SQLException, IOException {
1:         
0:         PreparedStatement s = c.getAddMessageStatement();
0:         try {
0:             if( s == null ) {
0:                 s = c.getConnection().prepareStatement(statementProvider.getUpdateLastAckOfDurableSub());
0:                 if( batchStatments ) {
1:                     c.setUpdateLastAckStatement(s);
1:                 }
1:             }
1:             
0:             s.setLong(1, seq);
0:             s.setString(2, destination.getQualifiedName());
0:             s.setString(3, clientId);
0:             s.setString(4, subscriptionName);
1: 
0:             if( batchStatments ) {
1:                 s.addBatch();
0:             } else if ( s.executeUpdate() != 1 ) {
1:                 throw new SQLException("Failed add a message");
1:             }
0:         } finally {
0:             if( !batchStatments ) {
1:                 s.close();
1:             }
1:         }
1: 
1:     }
1: 
0:     public void doRecoverSubscription(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName, JDBCMessageRecoveryListener listener) throws Throwable {
0: //        dumpTables(c, destination.getQualifiedName(),clientId,subscriptionName);
1: 
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindAllDurableSubMessagesStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
0:             rs = s.executeQuery();
1: 
0:             if( statementProvider.isUseExternalMessageReferences() ) {
0:                 while (rs.next()) {
0:                     listener.recoverMessageReference(rs.getString(2));
1:                 }
0:             } else {
0:                 while (rs.next()) {
0:                     listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2));
1:                 }
1:             }
1: 
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
1:     /**
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doSetSubscriberEntry(java.sql.Connection, java.lang.Object, org.apache.activemq.service.SubscriptionInfo)
1:      */
1:     
0:     public void doSetSubscriberEntry(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName, String selector, boolean retroactive) throws SQLException, IOException {
1: 
0: //        dumpTables(c, destination.getQualifiedName(), clientId, subscriptionName);
1:         
0:         PreparedStatement s = null;
0:         try {
1:             
0:             long lastMessageId = -1;
0:             if(!retroactive) {
0:                 s = c.getConnection().prepareStatement(statementProvider.getFindLastSequenceIdInMsgs());
0:                 ResultSet rs=null;
0:                 try {
0:                     rs = s.executeQuery();
0:                     if (rs.next()) {
0:                         lastMessageId = rs.getLong(1);
1:                     }
0:                 } finally {
1:                     close(rs);
1:                     close(s);
1:                 }
1:             }
1:             
0:             s = c.getConnection().prepareStatement(statementProvider.getCreateDurableSubStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
0:             s.setString(4, selector);
0:             s.setLong(5, lastMessageId);
1: 
0:             if (s.executeUpdate() != 1) {
0:                 throw new IOException("Could not create durable subscription for: "+clientId);
1:             }
1:         }
0:         finally {
1:             close(s);
1:         }
1:     }
1: 
0:     public SubscriptionInfo doGetSubscriberEntry(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName) throws SQLException, IOException {
1: 
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
1: 
0:             s = c.getConnection().prepareStatement(statementProvider.getFindDurableSubStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
0:             rs = s.executeQuery();
1: 
0:             if (!rs.next()) {
1:                 return null;
1:             }
1: 
0:             SubscriptionInfo subscription = new SubscriptionInfo();
1:             subscription.setDestination(destination);
1:             subscription.setClientId(clientId);
0:             subscription.setSubcriptionName(subscriptionName);
1:             subscription.setSelector(rs.getString(1));
1:             return subscription;
1:             
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:     }
1: 
0:     public void doRemoveAllMessages(TransactionContext c, ActiveMQDestination destinationName) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         try {
0:             s = c.getConnection().prepareStatement(statementProvider.getRemoveAllMessagesStatment());
0:             s.setString(1, destinationName.getQualifiedName());
1:             s.executeUpdate();
1:             s.close();
1:             
0:             s = c.getConnection().prepareStatement(statementProvider.getRemoveAllSubscriptionsStatment());
0:             s.setString(1, destinationName.getQualifiedName());
1:             s.executeUpdate();
1:             
1:         }
0:         finally {
1:             close(s);
1:         }
1:     }
1:     
0:     public void doDeleteSubscription(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         try {
0:             s = c.getConnection().prepareStatement(statementProvider.getDeleteSubscriptionStatment());
0:             s.setString(1, destination.getQualifiedName());
0:             s.setString(2, clientId);
0:             s.setString(3, subscriptionName);
1:             s.executeUpdate();
1:         }
0:         finally {
1:             close(s);
1:         }
1:     }
1: 
0:     public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {
0:         PreparedStatement s = null;
0:         try {
0:             s = c.getConnection().prepareStatement(statementProvider.getDeleteOldMessagesStatment());
0:             s.setLong(1, System.currentTimeMillis());
0:             int i = s.executeUpdate();
0:             log.debug("Deleted "+i+" old message(s).");
1:         }
0:         finally {
1:             close(s);
1:         }
1:     }
1: 
0:     static private void close(PreparedStatement s) {
0:         try {
1:             s.close();
1:         }
0:         catch (Throwable e) {
1:         }
1:     }
1: 
0:     static private void close(ResultSet rs) {
0:         try {
1:             rs.close();
1:         }
0:         catch (Throwable e) {
1:         }
1:     }
1: 
0:     public Set doGetDestinations(TransactionContext c) throws SQLException, IOException {
0:         HashSet rc = new HashSet();
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
0:             s = c.getConnection().prepareStatement(statementProvider.getFindAllDestinationsStatment());
0:             rs = s.executeQuery();
1: 
0:             while (rs.next()) {
0:                 rc.add( ActiveMQDestination.createDestination(rs.getString(1), ActiveMQDestination.QUEUE_TYPE));
1:             }
1:         }
0:         finally {
1:             close(rs);
1:             close(s);
1:         }
1:         return rc;
1:     }
1: 
0:     public boolean isBatchStatments() {
0:         return batchStatments;
1:     }
1: 
0:     public void setBatchStatments(boolean batchStatments) {
0:         this.batchStatments = batchStatments;
1:     }
1: 
0:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {
0:         statementProvider.setUseExternalMessageReferences(useExternalMessageReferences);
1:     }
1: 
0:     /*
0:      * Useful for debugging.
0:     public void dumpTables(Connection c, String destinationName, String clientId, String subscriptionName) throws SQLException {        
0:         printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out);
0:         printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out);
0:         PreparedStatement s = c.prepareStatement("SELECT M.ID, D.LAST_ACKED_ID FROM "
0:         +"ACTIVEMQ_MSGS M, "
0:         +"ACTIVEMQ_ACKS D "
0:         +"WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND D.SUB_NAME=?" 
0:         +" AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID"
0:         +" ORDER BY M.ID");
0:         s.setString(1,destinationName);
0:         s.setString(2,clientId);
0:         s.setString(3,subscriptionName);
0:         printQuery(s,System.out);
1:     }
1: 
0:     private void printQuery(Connection c, String query, PrintStream out) throws SQLException {
0:         printQuery(c.prepareStatement(query), out);
1:     }
1:     
0:     private void printQuery(PreparedStatement s, PrintStream out) throws SQLException {
1:         
0:         ResultSet set=null;
0:         try {
0:             set = s.executeQuery();
0:             ResultSetMetaData metaData = set.getMetaData();
0:             for( int i=1; i<= metaData.getColumnCount(); i++ ) {
0:                 if(i==1)
0:                     out.print("||");
0:                 out.print(metaData.getColumnName(i)+"||");
1:             }
0:             out.println();
0:             while(set.next()) {
0:                 for( int i=1; i<= metaData.getColumnCount(); i++ ) {
0:                     if(i==1)
0:                         out.print("|");
0:                     out.print(set.getString(i)+"|");
1:                 }
0:                 out.println();
1:             }
0:         } finally {
0:             try { set.close(); } catch (Throwable ignore) {}
0:             try { s.close(); } catch (Throwable ignore) {}
1:         }
1:     }
1:     */
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:3b37436
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.TreeSet;
/////////////////////////////////////////////////////////////////////////
1:  * Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
1:  * encouraged to override the default implementation of methods to account for differences in JDBC Driver
1:  * implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
0:  * The databases/JDBC drivers that use this adapter are:
/////////////////////////////////////////////////////////////////////////
0:     private Set<Long> lastRecoveredMessagesIds = new TreeSet<Long>();
/////////////////////////////////////////////////////////////////////////
0:                 rs = c.getConnection().getMetaData().getTables(null, null, this.statements.getFullMessageTableName(),
0:                         new String[] { "TABLE" });
0:             String[] createStatments = this.statements.getCreateSchemaStatements();
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("Could not create JDBC tables; The message table already existed." + " Failure was: "
0:                                 + createStatments[i] + " Message: " + e.getMessage() + " SQLState: " + e.getSQLState()
0:                                 + " Vendor code: " + e.getErrorCode());
0:                                 + createStatments[i] + " Message: " + e.getMessage() + " SQLState: " + e.getSQLState()
0:                                 + " Vendor code: " + e.getErrorCode());
/////////////////////////////////////////////////////////////////////////
1:             String[] dropStatments = this.statements.getDropSchemaStatements();
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Could not drop JDBC tables; they may not exist." + " Failure was: " + dropStatments[i]
1:                             + " Message: " + e.getMessage() + " SQLState: " + e.getSQLState() + " Vendor code: "
1:                             + e.getErrorCode());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInMsgsStatement());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInAcksStatement());
/////////////////////////////////////////////////////////////////////////
0:     public void doAddMessage(TransactionContext c, MessageId messageID, ActiveMQDestination destination, byte[] data,
0:             long expiration) throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());
0:                 if (this.batchStatments) {
/////////////////////////////////////////////////////////////////////////
0:             if (this.batchStatments) {
0:             if (!this.batchStatments) {
1:                 if (s != null) {
0:     public void doAddMessageReference(TransactionContext c, MessageId messageID, ActiveMQDestination destination,
1:             long expirationTime, String messageRef) throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());
0:                 if (this.batchStatments) {
/////////////////////////////////////////////////////////////////////////
0:             if (this.batchStatments) {
0:             if (!this.batchStatments) {
0:     public long getBrokerSequenceId(TransactionContext c, MessageId messageID) throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getFindMessageSequenceIdStatement());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindMessageStatement());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:                 s = c.getConnection().prepareStatement(this.statements.getRemoveMessageStatment());
0:                 if (this.batchStatments) {
0:             if (this.batchStatments) {
0:             if (!this.batchStatments) {
1:     public void doRecover(TransactionContext c, ActiveMQDestination destination, JDBCMessageRecoveryListener listener)
0:             throws Exception {
1:             s = c.getConnection().prepareStatement(this.statements.getFindAllMessagesStatement());
1:             if (this.statements.isUseExternalMessageReferences()) {
/////////////////////////////////////////////////////////////////////////
0:             String subscriptionName, long seq) throws SQLException, IOException {
0:                 s = c.getConnection().prepareStatement(this.statements.getUpdateLastAckOfDurableSubStatement());
0:                 if (this.batchStatments) {
/////////////////////////////////////////////////////////////////////////
0:             if (this.batchStatments) {
0:             if (!this.batchStatments) {
1:             String subscriptionName, JDBCMessageRecoveryListener listener) throws Exception {
1:             s = c.getConnection().prepareStatement(this.statements.getFindAllDurableSubMessagesStatement());
1:             if (this.statements.isUseExternalMessageReferences()) {
/////////////////////////////////////////////////////////////////////////
0:             String subscriptionName, long seq, int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
0:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubMessagesStatement());
/////////////////////////////////////////////////////////////////////////
1:             if (this.statements.isUseExternalMessageReferences()) {
/////////////////////////////////////////////////////////////////////////
1:             String clientId, String subscriptionName) throws SQLException, IOException {
0:             s = c.getConnection().prepareStatement(this.statements.getDurableSubscriberMessageCountStatement());
/////////////////////////////////////////////////////////////////////////
0:      * @param c 
0:      * @param info 
0:      * @param retroactive 
0:      * @throws SQLException 
0:      * @throws IOException 
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doSetSubscriberEntry(java.sql.Connection, java.lang.Object,
0:      *      org.apache.activemq.service.SubscriptionInfo)
0:             throws SQLException, IOException {
1:                 s = c.getConnection().prepareStatement(this.statements.getFindLastSequenceIdInMsgsStatement());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getCreateDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
0:             String clientId, String subscriptionName) throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getFindDurableSubStatement());
/////////////////////////////////////////////////////////////////////////
1:             subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(2),
1:                     ActiveMQDestination.QUEUE_TYPE));
/////////////////////////////////////////////////////////////////////////
0:             throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getFindAllDurableSubsStatement());
/////////////////////////////////////////////////////////////////////////
1:                 subscription.setSubscribedDestination(ActiveMQDestination.createDestination(rs.getString(4),
0:                         ActiveMQDestination.QUEUE_TYPE));
/////////////////////////////////////////////////////////////////////////
1:     public void doRemoveAllMessages(TransactionContext c, ActiveMQDestination destinationName) throws SQLException,
0:             IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getRemoveAllMessagesStatement());
1:             s = c.getConnection().prepareStatement(this.statements.getRemoveAllSubscriptionsStatement());
/////////////////////////////////////////////////////////////////////////
0:             String subscriptionName) throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getDeleteSubscriptionStatement());
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Executing SQL: " + this.statements.getDeleteOldMessagesStatement());
0:             s = c.getConnection().prepareStatement(this.statements.getDeleteOldMessagesStatement());
/////////////////////////////////////////////////////////////////////////
0:     public long doGetLastAckedDurableSubscriberMessageId(TransactionContext c, ActiveMQDestination destination,
1:             String clientId, String subscriberName) throws SQLException, IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getLastAckedDurableSubscriberMessageStatement());
/////////////////////////////////////////////////////////////////////////
1:             s = c.getConnection().prepareStatement(this.statements.getFindAllDestinationsStatement());
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @return true if batchStements
1:      */
0:         return this.batchStatments;
1:     /**
1:      * @param batchStatments
1:      */
1:         this.statements.setUseExternalMessageReferences(useExternalMessageReferences);
1:     /**
1:      * @return the statements
1:      */
1:         return this.statements;
1:     /**
0:      * @param c
0:      * @param destination
0:      * @param clientId
0:      * @param subscriberName
0:      * @return
0:      * @throws SQLException
0:      * @throws IOException
1:      */
0:     public byte[] doGetNextDurableSubscriberMessageStatement(TransactionContext c, ActiveMQDestination destination,
0:             String clientId, String subscriberName) throws SQLException, IOException {
0:             s = c.getConnection().prepareStatement(this.statements.getNextDurableSubscriberMessageStatement());
/////////////////////////////////////////////////////////////////////////
0:             IOException {
1:             s = c.getConnection().prepareStatement(this.statements.getDestinationMessageCountStatement());
/////////////////////////////////////////////////////////////////////////
0:             int maxReturned, JDBCMessageRecoveryListener listener) throws Exception {
0:         long id = 0;
0:         List<Long> cleanupIds = new ArrayList<Long>();
0:         int index = 0;
0:             s = c.getConnection().prepareStatement(this.statements.getFindNextMessagesStatement());
0:             s.setMaxRows(maxReturned * 2);
0:             s.setLong(2, nextSeq - maxReturned);
1:             if (this.statements.isUseExternalMessageReferences()) {
0:                     id = rs.getLong(1);
0:                     if (this.lastRecoveredMessagesIds.contains(id)) {
0:                         // this message was already recovered
0:                         cleanupIds.add(id);
0:                         continue;
0:                     }
0:                         this.lastRecoveredMessagesIds.add(id);
0:                     id = rs.getLong(1);
0:                     if (this.lastRecoveredMessagesIds.contains(id)) {
0:                         // this message was already recovered
0:                         cleanupIds.add(id);
0:                         continue;
0:                     }
0:                         this.lastRecoveredMessagesIds.add(id);
0:             // not cleanup the list of recovered messages
0:             index = 0;
0:             Iterator<Long> it = cleanupIds.iterator();
0:             while (it.hasNext() && index < count) {
0:                 this.lastRecoveredMessagesIds.remove(it.next());
0:             }
/////////////////////////////////////////////////////////////////////////
0:      * Useful for debugging. public void dumpTables(Connection c, String destinationName, String clientId, String
0:      * subscriptionName) throws SQLException { printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out); printQuery(c,
0:      * "Select * from ACTIVEMQ_ACKS", System.out); PreparedStatement s = c.prepareStatement("SELECT M.ID,
0:      * D.LAST_ACKED_ID FROM " +"ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D " +"WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND
0:      * D.SUB_NAME=?" +" AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID" +" ORDER BY M.ID");
0:      * s.setString(1,destinationName); s.setString(2,clientId); s.setString(3,subscriptionName);
0:      * public void dumpTables(Connection c) throws SQLException { printQuery(c, "Select * from ACTIVEMQ_MSGS",
0:      * System.out); printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out); }
0:      * private void printQuery(Connection c, String query, PrintStream out) throws SQLException {
0:      * printQuery(c.prepareStatement(query), out); }
0:      * private void printQuery(PreparedStatement s, PrintStream out) throws SQLException {
0:      * ResultSet set=null; try { set = s.executeQuery(); ResultSetMetaData metaData = set.getMetaData(); for( int i=1; i<=
0:      * metaData.getColumnCount(); i++ ) { if(i==1) out.print("||"); out.print(metaData.getColumnName(i)+"||"); }
0:      * out.println(); while(set.next()) { for( int i=1; i<= metaData.getColumnCount(); i++ ) { if(i==1) out.print("|");
0:      * out.print(set.getString(i)+"|"); } out.println(); } } finally { try { set.close(); } catch (Throwable ignore) {}
0:      * try { s.close(); } catch (Throwable ignore) {} } }
commit:4d0e572
/////////////////////////////////////////////////////////////////////////
1:                         break;
/////////////////////////////////////////////////////////////////////////
1:                         break;
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
1:                     if (!listener.recoverMessageReference(rs.getString(2))) {
1:                         break;
0:                     }
0:                     if(!listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2))) {
1:                         break;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                     if (!listener.recoverMessageReference(rs.getString(2))){
0:                         break;
0:                     }
0:                     if (!listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2))) {
0:                         break;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                     if(listener.recoverMessageReference(rs.getString(1))){
1:                         count++;
0:                     }else{
0:                         break;
0:                     }
0:                     if(listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2))){
1:                         count++;
0:                     }else{
0:                         break;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:     public void doRecoverNextMessages(TransactionContext c,ActiveMQDestination destination,long nextSeq,
0:             int maxReturned,JDBCMessageRecoveryListener listener) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:                     if(listener.recoverMessageReference(rs.getString(1))){
1:                         count++;
0:                     }else{
0:                         log.debug("Stopped recover next messages");
0:                     }
0:                     if(listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2))){
1:                         count++;
0:                     }else{
0:                         log.debug("Stopped recover next messages");
0:                     }
0:         }catch(Exception e){
0:         }finally{
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
0:     
0:     public long doGetLastAckedDurableSubscriberMessageId(TransactionContext c,ActiveMQDestination destination,String clientId, String subscriberName) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         long result = -1;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getLastAckedDurableSubscriberMessageStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriberName);
0:             rs=s.executeQuery();
0:             if(rs.next()){
0:                 result=rs.getLong(1);
0:             }
0:             rs.close();
0:             s.close();
0:         }finally{
1:             close(rs);
1:             close(s);
0:         }
1:         return result;
0:     }
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(maxReturned);
/////////////////////////////////////////////////////////////////////////
0:             s.setMaxRows(maxReturned);
0:             s.setLong(2,nextSeq);
/////////////////////////////////////////////////////////////////////////
0:         }catch(Exception e) {
0:             e.printStackTrace();
0:         }finally {
commit:5367f1e
/////////////////////////////////////////////////////////////////////////
0:     }    
commit:629bc81
/////////////////////////////////////////////////////////////////////////
0:     
0:    
0:     public int doGetMessageCount(TransactionContext c,ActiveMQDestination destination) throws SQLException, IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         int result=0;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getDestinationMessageCountStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             rs=s.executeQuery();
0:             if(rs.next()){
0:                 result=rs.getInt(1);
0:             }
0:         }finally{
1:             close(rs);
1:             close(s);
0:         }
1:         return result;
0:     }
0: 
0:     
0:     public void doRecoverNextMessages(TransactionContext c,ActiveMQDestination destination,long nextSeq,int maxReturned,JDBCMessageRecoveryListener listener) throws Exception{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindNextMessagesStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setLong(4,nextSeq);
0:             rs=s.executeQuery();
0:             int count=0;
0:             if(statements.isUseExternalMessageReferences()){
0:                 while(rs.next()&&count<maxReturned){
0:                     listener.recoverMessageReference(rs.getString(1));
0:                     count++;
0:                 }
0:             }else{
0:                 while(rs.next()&&count<maxReturned){
0:                     listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:                     count++;
0:                 }
0:             }
0:         }finally{
1:             close(rs);
1:             close(s);
0:             listener.finished();
0:         }
0:         
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
0:     
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  * Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
0:  * encouraged to override the default implementation of methods to account for differences in JDBC Driver
0:  * implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
0:  * 
0: public class DefaultJDBCAdapter implements JDBCAdapter{
0:     private static final Log log=LogFactory.getLog(DefaultJDBCAdapter.class);
0:     protected void setBinaryData(PreparedStatement s,int index,byte data[]) throws SQLException{
0:         s.setBytes(index,data);
0:     protected byte[] getBinaryData(ResultSet rs,int index) throws SQLException{
0:     public void doCreateTables(TransactionContext c) throws SQLException,IOException{
0:         Statement s=null;
0:         try{
0:             // Check to see if the table already exists. If it does, then don't log warnings during startup.
0:             // Need to run the scripts anyways since they may contain ALTER statements that upgrade a previous version
0:             // of the table
0:             boolean alreadyExists=false;
0:             try{
0:                 rs=c.getConnection().getMetaData().getTables(null,null,statements.getFullMessageTableName(),
0:                         new String[] { "TABLE" });
0:                 alreadyExists=rs.next();
0:             }catch(Throwable ignore){
0:             }finally{
0:             s=c.getConnection().createStatement();
0:             String[] createStatments=statements.getCreateSchemaStatements();
0:             for(int i=0;i<createStatments.length;i++){
0:                 try{
0:                     boolean rc=s.execute(createStatments[i]);
0:                 }catch(SQLException e){
0:                     if(alreadyExists){
0:                         log.debug("Could not create JDBC tables; The message table already existed."+" Failure was: "
0:                                 +createStatments[i]+" Message: "+e.getMessage()+" SQLState: "+e.getSQLState()
0:                                 +" Vendor code: "+e.getErrorCode());
0:                     }else{
0:                         log.warn("Could not create JDBC tables; they could already exist."+" Failure was: "
0:                                 +createStatments[i]+" Message: "+e.getMessage()+" SQLState: "+e.getSQLState()
0:                                 +" Vendor code: "+e.getErrorCode());
0:         }finally{
0:             try{
0:             }catch(Throwable e){
0:     public void doDropTables(TransactionContext c) throws SQLException,IOException{
0:         Statement s=null;
0:         try{
0:             s=c.getConnection().createStatement();
0:             String[] dropStatments=statements.getDropSchemaStatements();
0:             for(int i=0;i<dropStatments.length;i++){
0:                 try{
0:                     boolean rc=s.execute(dropStatments[i]);
0:                 }catch(SQLException e){
0:                     log.warn("Could not drop JDBC tables; they may not exist."+" Failure was: "+dropStatments[i]
0:                             +" Message: "+e.getMessage()+" SQLState: "+e.getSQLState()+" Vendor code: "
0:                             +e.getErrorCode());
0:         }finally{
0:             try{
0:             }catch(Throwable e){
0: 
0:     public long doGetLastMessageBrokerSequenceId(TransactionContext c) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
0:             rs=s.executeQuery();
0:             long seq1=0;
0:             if(rs.next()){
0:                 seq1=rs.getLong(1);
0:             s=c.getConnection().prepareStatement(statements.getFindLastSequenceIdInAcksStatement());
0:             rs=s.executeQuery();
0:             long seq2=0;
0:             if(rs.next()){
0:                 seq2=rs.getLong(1);
0:             return Math.max(seq1,seq2);
0:         }finally{
0:     public void doAddMessage(TransactionContext c,MessageId messageID,ActiveMQDestination destination,byte[] data,
0:             long expiration) throws SQLException,IOException{
0:         PreparedStatement s=c.getAddMessageStatement();
0:         try{
0:             if(s==null){
0:                 s=c.getConnection().prepareStatement(statements.getAddMessageStatement());
0:                 if(batchStatments){
0:             s.setLong(1,messageID.getBrokerSequenceId());
0:             s.setString(2,messageID.getProducerId().toString());
0:             s.setLong(3,messageID.getProducerSequenceId());
0:             s.setString(4,destination.getQualifiedName());
0:             s.setLong(5,expiration);
0:             setBinaryData(s,6,data);
0:             if(batchStatments){
0:             }else if(s.executeUpdate()!=1){
0:         }finally{
0:             if(!batchStatments){
0:     public void doAddMessageReference(TransactionContext c,MessageId messageID,ActiveMQDestination destination,
0:             long expirationTime,String messageRef) throws SQLException,IOException{
0:         PreparedStatement s=c.getAddMessageStatement();
0:         try{
0:             if(s==null){
0:                 s=c.getConnection().prepareStatement(statements.getAddMessageStatement());
0:                 if(batchStatments){
0:                     c.setAddMessageStatement(s);
0:                 }
0:             }
0:             s.setLong(1,messageID.getBrokerSequenceId());
0:             s.setString(2,messageID.getProducerId().toString());
0:             s.setLong(3,messageID.getProducerSequenceId());
0:             s.setString(4,destination.getQualifiedName());
0:             s.setLong(5,expirationTime);
0:             s.setString(6,messageRef);
0:             if(batchStatments){
0:                 s.addBatch();
0:             }else if(s.executeUpdate()!=1){
0:                 throw new SQLException("Failed add a message");
0:             }
0:         }finally{
0:             if(!batchStatments){
0:                 s.close();
0:             }
0:         }
0:     }
0:     public long getBrokerSequenceId(TransactionContext c,MessageId messageID) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindMessageSequenceIdStatement());
0:             s.setString(1,messageID.getProducerId().toString());
0:             s.setLong(2,messageID.getProducerSequenceId());
0:             rs=s.executeQuery();
0:             if(!rs.next()){
0:         }finally{
0:     public byte[] doGetMessage(TransactionContext c,long seq) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindMessageStatement());
0:             s.setLong(1,seq);
0:             rs=s.executeQuery();
0:             if(!rs.next()){
0:                 return null;
0:             }
0:             return getBinaryData(rs,1);
0:         }finally{
0:             close(rs);
0:             close(s);
0:         }
0:     }
0:     public String doGetMessageReference(TransactionContext c,long seq) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindMessageStatement());
0:             s.setLong(1,seq);
0:             rs=s.executeQuery();
0:             if(!rs.next()){
0:         }finally{
0:     public void doRemoveMessage(TransactionContext c,long seq) throws SQLException,IOException{
0:         PreparedStatement s=c.getRemovedMessageStatement();
0:         try{
0:             if(s==null){
0:                 s=c.getConnection().prepareStatement(statements.getRemoveMessageStatment());
0:                 if(batchStatments){
0:             s.setLong(1,seq);
0:             if(batchStatments){
0:             }else if(s.executeUpdate()!=1){
0:         }finally{
0:             if(!batchStatments){
0:         }
0:     public void doRecover(TransactionContext c,ActiveMQDestination destination,JDBCMessageRecoveryListener listener)
0:             throws Exception{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindAllMessagesStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             rs=s.executeQuery();
0:             if(statements.isUseExternalMessageReferences()){
0:                 while(rs.next()){
0:             }else{
0:                 while(rs.next()){
0:                     listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:         }finally{
0:         }
0:     public void doSetLastAck(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName,long seq) throws SQLException,IOException{
0:         PreparedStatement s=c.getAddMessageStatement();
0:         try{
0:             if(s==null){
0:                 s=c.getConnection().prepareStatement(statements.getUpdateLastAckOfDurableSubStatement());
0:                 if(batchStatments){
0:             s.setLong(1,seq);
0:             s.setString(2,destination.getQualifiedName());
0:             s.setString(3,clientId);
0:             s.setString(4,subscriptionName);
0:             if(batchStatments){
0:             }else if(s.executeUpdate()!=1){
0:         }finally{
0:             if(!batchStatments){
0:     public void doRecoverSubscription(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName,JDBCMessageRecoveryListener listener) throws Exception{
0:         // dumpTables(c, destination.getQualifiedName(),clientId,subscriptionName);
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindAllDurableSubMessagesStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             rs=s.executeQuery();
0:             if(statements.isUseExternalMessageReferences()){
0:                 while(rs.next()){
0:             }else{
0:                 while(rs.next()){
0:                     listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:         }finally{
0:     public void doRecoverNextMessages(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName,long seq,int maxReturned,JDBCMessageRecoveryListener listener) throws Exception{
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindDurableSubMessagesStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             s.setLong(4,seq);
0:             rs=s.executeQuery();
0:             int count=0;
0:             if(statements.isUseExternalMessageReferences()){
0:                 while(rs.next()&&count<maxReturned){
0:                     listener.recoverMessageReference(rs.getString(1));
0:                     count++;
0:                 }
0:             }else{
0:                 while(rs.next()&&count<maxReturned){
0:                     listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:                     count++;
0:                 }
0:             }
0:         }finally{
0:             close(rs);
0:             close(s);
0:             listener.finished();
0:         }
0:     }
0: 
0:     public int doGetDurableSubscriberMessageCount(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         int result=0;
0:             if(rs.next()){
0:                 result=rs.getInt(1);
0:             }
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doSetSubscriberEntry(java.sql.Connection, java.lang.Object,
0:      *      org.apache.activemq.service.SubscriptionInfo)
0:     public void doSetSubscriberEntry(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName,String selector,boolean retroactive) throws SQLException,IOException{
0:         // dumpTables(c, destination.getQualifiedName(), clientId, subscriptionName);
0:         PreparedStatement s=null;
0:         try{
0:             long lastMessageId=-1;
0:             if(!retroactive){
0:                 s=c.getConnection().prepareStatement(statements.getFindLastSequenceIdInMsgsStatement());
0:                 try{
0:                     rs=s.executeQuery();
0:                     if(rs.next()){
0:                         lastMessageId=rs.getLong(1);
0:                 }finally{
0:             s=c.getConnection().prepareStatement(statements.getCreateDurableSubStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             s.setString(4,selector);
0:             s.setLong(5,lastMessageId);
0:             if(s.executeUpdate()!=1){
0:         }finally{
0:     public SubscriptionInfo doGetSubscriberEntry(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindDurableSubStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             rs=s.executeQuery();
0:             if(!rs.next()){
0:             SubscriptionInfo subscription=new SubscriptionInfo();
0:         }finally{
0:     public SubscriptionInfo[] doGetAllSubscriptions(TransactionContext c,ActiveMQDestination destination)
0:             throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindAllDurableSubsStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             rs=s.executeQuery();
0:             ArrayList rc=new ArrayList();
0:             while(rs.next()){
0:                 SubscriptionInfo subscription=new SubscriptionInfo();
0:             return (SubscriptionInfo[])rc.toArray(new SubscriptionInfo[rc.size()]);
0:         }finally{
0:     public void doRemoveAllMessages(TransactionContext c,ActiveMQDestination destinationName) throws SQLException,
0:             IOException{
0:         PreparedStatement s=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getRemoveAllMessagesStatement());
0:             s.setString(1,destinationName.getQualifiedName());
0:             s=c.getConnection().prepareStatement(statements.getRemoveAllSubscriptionsStatement());
0:             s.setString(1,destinationName.getQualifiedName());
0:         }finally{
0:     public void doDeleteSubscription(TransactionContext c,ActiveMQDestination destination,String clientId,
0:             String subscriptionName) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getDeleteSubscriptionStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             s.executeUpdate();
0:         }finally{
0:             close(s);
0:         }
0:     }
0: 
0:     public void doDeleteOldMessages(TransactionContext c) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getDeleteOldMessagesStatement());
0:             s.setLong(1,System.currentTimeMillis());
0:             int i=s.executeUpdate();
0:         }finally{
0:     static private void close(PreparedStatement s){
0:         try{
0:         }catch(Throwable e){
0:     static private void close(ResultSet rs){
0:         try{
0:         }catch(Throwable e){
0:     public Set doGetDestinations(TransactionContext c) throws SQLException,IOException{
0:         HashSet rc=new HashSet();
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getFindAllDestinationsStatement());
0:             rs=s.executeQuery();
0:             while(rs.next()){
0:                 rc.add(ActiveMQDestination.createDestination(rs.getString(1),ActiveMQDestination.QUEUE_TYPE));
0:         }finally{
0:     public boolean isBatchStatments(){
0:     public void setBatchStatments(boolean batchStatments){
0:         this.batchStatments=batchStatments;
0:     public void setUseExternalMessageReferences(boolean useExternalMessageReferences){
0:     public Statements getStatements(){
0:     public void setStatements(Statements statements){
0:         this.statements=statements;
0:     public byte[] doGetNextDurableSubscriberMessageStatement(TransactionContext c,ActiveMQDestination destination,
0:             String clientId,String subscriberName) throws SQLException,IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getNextDurableSubscriberMessageStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriberName);
0:             rs=s.executeQuery();
0:             if(!rs.next()){
0:             return getBinaryData(rs,1);
0:         }finally{
0:     /**
0:      * @param c
0:      * @param destination
0:      * @param clientId
0:      * @param subscriberName
0:      * @param id
0:      * @return the previous Id
0:      * @throws Exception 
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doGetPrevDurableSubscriberMessageStatement(org.apache.activemq.store.jdbc.TransactionContext,
0:      *      org.apache.activemq.command.ActiveMQDestination, java.lang.String, java.lang.String, java.lang.String)
0:      */
0:     public void doGetPrevDurableSubscriberMessageIdStatement(TransactionContext c,ActiveMQDestination destination,
0:             String clientId,String subscriberName,long id,JDBCMessageRecoveryListener listener) throws Exception{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getPrevDurableSubscriberMessageIdStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setLong(2,id);
0:             rs=s.executeQuery();
0:             if (rs.next()) {
0:             listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:             listener.finished();
0:            
0:         }finally{
0:             close(rs);
0:             close(s);
0: 
0:     /**
0:      * @param c
0:      * @param destination
0:      * @param clientId
0:      * @param subscriberName
0:      * @param id
0:      * @return the next id
0:      * @throws SQLException
0:      * @throws IOException
0:      * @see org.apache.activemq.store.jdbc.JDBCAdapter#doGetNextDurableSubscriberMessageIdStatement(org.apache.activemq.store.jdbc.TransactionContext,
0:      *      org.apache.activemq.command.ActiveMQDestination, java.lang.String, java.lang.String, java.lang.String)
0:      */
0:     public void doGetNextDurableSubscriberMessageIdStatement(TransactionContext c,ActiveMQDestination destination,
0:             String clientId,String subscriberName,long id,JDBCMessageRecoveryListener listener) throws Exception{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getNextDurableSubscriberMessageIdStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setLong(2,id);
0:             rs=s.executeQuery();
0:             if (rs.next()) {
0:             listener.recoverMessage(rs.getLong(1),getBinaryData(rs,2));
0:             }
0:             listener.finished();
0:            
0:         }finally{
0:             close(rs);
0:             close(s);
0:         }
0:     }
0:     /*
0:      * Useful for debugging. public void dumpTables(Connection c, String destinationName, String clientId, String
0:      * subscriptionName) throws SQLException { printQuery(c, "Select * from ACTIVEMQ_MSGS", System.out); printQuery(c,
0:      * "Select * from ACTIVEMQ_ACKS", System.out); PreparedStatement s = c.prepareStatement("SELECT M.ID,
0:      * D.LAST_ACKED_ID FROM " +"ACTIVEMQ_MSGS M, " +"ACTIVEMQ_ACKS D " +"WHERE D.CONTAINER=? AND D.CLIENT_ID=? AND
0:      * D.SUB_NAME=?" +" AND M.CONTAINER=D.CONTAINER AND M.ID > D.LAST_ACKED_ID" +" ORDER BY M.ID");
0:      * s.setString(1,destinationName); s.setString(2,clientId); s.setString(3,subscriptionName);
0:      * printQuery(s,System.out); }
0:      * 
0:      * public void dumpTables(Connection c) throws SQLException { printQuery(c, "Select * from ACTIVEMQ_MSGS",
0:      * System.out); printQuery(c, "Select * from ACTIVEMQ_ACKS", System.out); }
0:      * 
0:      * private void printQuery(Connection c, String query, PrintStream out) throws SQLException {
0:      * printQuery(c.prepareStatement(query), out); }
0:      * 
0:      * private void printQuery(PreparedStatement s, PrintStream out) throws SQLException {
0:      * 
0:      * ResultSet set=null; try { set = s.executeQuery(); ResultSetMetaData metaData = set.getMetaData(); for( int i=1; i<=
0:      * metaData.getColumnCount(); i++ ) { if(i==1) out.print("||"); out.print(metaData.getColumnName(i)+"||"); }
0:      * out.println(); while(set.next()) { for( int i=1; i<= metaData.getColumnCount(); i++ ) { if(i==1) out.print("|");
0:      * out.print(set.getString(i)+"|"); } out.println(); } } finally { try { set.close(); } catch (Throwable ignore) {}
0:      * try { s.close(); } catch (Throwable ignore) {} } }
0:      */
commit:17946e5
/////////////////////////////////////////////////////////////////////////
0:           System.err.println("VANILLA STATEMENT = " + statements.getFindDurableSubMessagesStatement());
0:           System.err.println("STATEMENT = " + s);
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:     public void doRecoverNextMessages(TransactionContext c, ActiveMQDestination destination, String clientId, String subscriptionName, long seq, int maxReturned,JDBCMessageRecoveryListener listener) throws Exception {
0: //      dumpTables(c, destination.getQualifiedName(),clientId,subscriptionName);
0: 
0:       PreparedStatement s = null;
0:       ResultSet rs = null;
0:       try {
0: 
0:           s = c.getConnection().prepareStatement(statements.getFindDurableSubMessagesStatement());
0:           s.setString(1, destination.getQualifiedName());
0:           s.setString(2, clientId);
0:           s.setString(3, subscriptionName);
0:           s.setLong(4,seq);
0:           s.setInt(5,maxReturned);
0:           rs = s.executeQuery();
0: 
0:           if( statements.isUseExternalMessageReferences() ) {
0:               while (rs.next()) {
0:                   listener.recoverMessageReference(rs.getString(2));
0:               }
0:           } else {
0:               while (rs.next()) {
0:                   listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2));
0:               }
0:           }
0: 
0:       }
0:       finally {
0:           close(rs);
0:           close(s);
0:           listener.finished();
0:       }
0:       
0:   }
0:     
0:     public int doGetDurableSubscriberMessageCount(TransactionContext c,ActiveMQDestination destination,String clientId,
0:                     String subscriptionName) throws SQLException, IOException{
0:         PreparedStatement s=null;
0:         ResultSet rs=null;
0:         int result = 0;
0:         try{
0:             s=c.getConnection().prepareStatement(statements.getDurableSubscriberMessageCountStatement());
0:             s.setString(1,destination.getQualifiedName());
0:             s.setString(2,clientId);
0:             s.setString(3,subscriptionName);
0:             rs=s.executeQuery();
0:             result =  rs.getInt(1);
0:         }finally{
0:             close(rs);
0:             close(s);
0:         }
1:         return result;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public byte[] doGetNextDurableSubscriberMessageStatement(TransactionContext c,ActiveMQDestination destination,String clientId,String subscriberName) throws SQLException,IOException{
0:         PreparedStatement s = null;
0:         ResultSet rs = null;
0:         try {
0: 
0:             s = c.getConnection().prepareStatement(statements.getNextDurableSubscriberMessageStatement());
0:             s.setString(1, destination.getQualifiedName());
0:             s.setString(2, clientId);
0:             s.setString(3, subscriberName);
0:             rs = s.executeQuery();
0: 
0:             if (!rs.next()) {
0:                 return null;
0:             }
0:             return getBinaryData(rs, 1);
0: 
0:         }
0:         finally {
0:             close(rs);
0:             close(s);
0:         }
0:     }
0: 
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
0:             listener.finished();
0:         }     
/////////////////////////////////////////////////////////////////////////
0:             listener.finished();
0:         
============================================================================