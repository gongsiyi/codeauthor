1:5be5a62: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:5be5a62:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:5be5a62:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5be5a62:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5be5a62:  * See the License for the specific language governing permissions and
1:5be5a62:  * limitations under the License.
1:5be5a62:  */
1:8abcfd1: package org.apache.activemq.transport.http;
1:ff30070: 
1:ff30070: import java.io.DataInputStream;
1:ff30070: import java.io.IOException;
1:ff30070: import java.io.InterruptedIOException;
1:ff30070: import java.net.URI;
1:31c55f7: import java.security.cert.X509Certificate;
1:ef85089: import java.util.zip.GZIPInputStream;
1:ef85089: import java.util.zip.GZIPOutputStream;
1:ff30070: 
1:09bae42: import org.apache.activemq.command.ShutdownInfo;
1:8abcfd1: import org.apache.activemq.transport.FutureResponse;
1:8abcfd1: import org.apache.activemq.transport.util.TextWireFormat;
1:ef85089: import org.apache.activemq.util.ByteArrayOutputStream;
1:8abcfd1: import org.apache.activemq.util.IOExceptionSupport;
1:ff30070: import org.apache.activemq.util.IdGenerator;
1:8abcfd1: import org.apache.activemq.util.ServiceStopper;
1:31c55f7: import org.apache.activemq.wireformat.WireFormat;
1:ef85089: import org.apache.http.Header;
1:082fdc5: import org.apache.http.HttpHost;
1:ef85089: import org.apache.http.HttpRequest;
1:ef85089: import org.apache.http.HttpRequestInterceptor;
1:082fdc5: import org.apache.http.HttpResponse;
1:082fdc5: import org.apache.http.HttpStatus;
1:8a3bdd9: import org.apache.http.auth.AuthScope;
1:8a3bdd9: import org.apache.http.auth.UsernamePasswordCredentials;
1:082fdc5: import org.apache.http.client.HttpClient;
1:ef85089: import org.apache.http.client.HttpResponseException;
1:082fdc5: import org.apache.http.client.ResponseHandler;
1:082fdc5: import org.apache.http.client.methods.HttpGet;
1:082fdc5: import org.apache.http.client.methods.HttpHead;
1:ef85089: import org.apache.http.client.methods.HttpOptions;
1:082fdc5: import org.apache.http.client.methods.HttpPost;
1:4f6c55a: import org.apache.http.client.params.CookiePolicy;
1:4f6c55a: import org.apache.http.client.params.HttpClientParams;
1:571d452: import org.apache.http.conn.ClientConnectionManager;
1:082fdc5: import org.apache.http.conn.params.ConnRoutePNames;
1:d919db5: import org.apache.http.conn.scheme.PlainSocketFactory;
1:d919db5: import org.apache.http.conn.scheme.Scheme;
1:082fdc5: import org.apache.http.entity.ByteArrayEntity;
1:082fdc5: import org.apache.http.impl.client.BasicResponseHandler;
1:082fdc5: import org.apache.http.impl.client.DefaultHttpClient;
1:2d88395: import org.apache.http.impl.conn.PoolingClientConnectionManager;
1:082fdc5: import org.apache.http.message.AbstractHttpMessage;
1:082fdc5: import org.apache.http.params.HttpConnectionParams;
1:082fdc5: import org.apache.http.params.HttpParams;
1:ef85089: import org.apache.http.protocol.HttpContext;
1:082fdc5: import org.apache.http.util.EntityUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:ff30070: 
2:40a7d3b: /**
1:2d88395:  * A HTTP {@link org.apache.activemq.transport.Transport} which uses the
1:2d88395:  * <a href="http://hc.apache.org/index.html">Apache HTTP Client</a>
1:40a7d3b:  * library
1:40a7d3b:  */
1:40a7d3b: public class HttpClientTransport extends HttpTransportSupport {
1:ff30070: 
1:540dd5c:     public static final int MAX_CLIENT_TIMEOUT = 30000;
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(HttpClientTransport.class);
1:540dd5c:     private static final IdGenerator CLIENT_ID_GENERATOR = new IdGenerator();
1:ff30070: 
1:40a7d3b:     private HttpClient sendHttpClient;
1:40a7d3b:     private HttpClient receiveHttpClient;
1:540dd5c: 
1:540dd5c:     private final String clientID = CLIENT_ID_GENERATOR.generateId();
1:ff30070:     private boolean trace;
1:082fdc5:     private HttpGet httpMethod;
1:8978ac0:     private volatile int receiveCounter;
1:540dd5c: 
1:1a409b0:     private int soTimeout = MAX_CLIENT_TIMEOUT;
1:082fdc5: 
1:ef85089:     private boolean useCompression = false;
1:571d452:     protected boolean canSendCompressed = false;
1:ef85089:     private int minSendAsCompressedSize = 0;
1:ef85089: 
1:40a7d3b:     public HttpClientTransport(TextWireFormat wireFormat, URI remoteUrl) {
1:40a7d3b:         super(wireFormat, remoteUrl);
16:40a7d3b:     }
1:540dd5c: 
1:9ca56a0:     public FutureResponse asyncRequest(Object command) throws IOException {
1:40a7d3b:         return null;
1:ff30070:     }
1:ff30070: 
1:840ca30:     @Override
1:9ca56a0:     public void oneway(Object command) throws IOException {
1:540dd5c: 
1:540dd5c:         if (isStopped()) {
1:540dd5c:             throw new IOException("stopped.");
1:540dd5c:         }
1:082fdc5:         HttpPost httpMethod = new HttpPost(getRemoteUrl().toString());
1:40a7d3b:         configureMethod(httpMethod);
1:88acb0e:         String data = getTextWireFormat().marshalText(command);
1:88acb0e:         byte[] bytes = data.getBytes("UTF-8");
1:ef85089:         if (useCompression && canSendCompressed && bytes.length > minSendAsCompressedSize) {
1:ef85089:             ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:ef85089:             GZIPOutputStream stream = new GZIPOutputStream(bytesOut);
1:ef85089:             stream.write(bytes);
1:ef85089:             stream.close();
1:ef85089:             httpMethod.addHeader("Content-Type", "application/x-gzip");
1:ef85089:             if (LOG.isTraceEnabled()) {
1:ef85089:                 LOG.trace("Sending compressed, size = " + bytes.length + ", compressed size = " + bytesOut.size());
1:ef85089:             }
1:ef85089:             bytes = bytesOut.toByteArray();
1:ef85089:         }
1:082fdc5:         ByteArrayEntity entity = new ByteArrayEntity(bytes);
1:082fdc5:         httpMethod.setEntity(entity);
1:540dd5c: 
1:082fdc5:         HttpClient client = null;
1:082fdc5:         HttpResponse answer = null;
1:ff30070:         try {
1:082fdc5:             client = getSendHttpClient();
1:082fdc5:             answer = client.execute(httpMethod);
1:082fdc5:             int status = answer.getStatusLine().getStatusCode();
1:082fdc5:             if (status != HttpStatus.SC_OK) {
1:40a7d3b:                 throw new IOException("Failed to post command: " + command + " as response was: " + answer);
1:ff30070:             }
1:09bae42:             if (command instanceof ShutdownInfo) {
1:082fdc5:                 try {
1:082fdc5:                     stop();
1:082fdc5:                 } catch (Exception e) {
1:082fdc5:                     LOG.warn("Error trying to stop HTTP client: "+ e, e);
1:082fdc5:                 }
1:1a409b0:             }
1:7531e3e:         } catch (IOException e) {
1:40a7d3b:             throw IOExceptionSupport.create("Could not post command: " + command + " due to: " + e, e);
1:4af9754:         } finally {
1:082fdc5:             if (answer != null) {
1:082fdc5:                 EntityUtils.consume(answer.getEntity());
1:09bae42:             }
1:09bae42:         }
1:0684e20:     }
1:540dd5c: 
1:840ca30:     @Override
1:9ca56a0:     public Object request(Object command) throws IOException {
1:40a7d3b:         return null;
1:40a7d3b:     }
1:540dd5c: 
1:ef85089:     private DataInputStream createDataInputStream(HttpResponse answer) throws IOException {
1:ef85089:         Header encoding = answer.getEntity().getContentEncoding();
1:ef85089:         if (encoding != null && "gzip".equalsIgnoreCase(encoding.getValue())) {
1:ef85089:             return new DataInputStream(new GZIPInputStream(answer.getEntity().getContent()));
1:ef85089:         } else {
1:ef85089:             return new DataInputStream(answer.getEntity().getContent());
1:ef85089:         }
1:ef85089:     }
1:ef85089: 
1:840ca30:     @Override
1:40a7d3b:     public void run() {
1:540dd5c: 
1:ef85089:         if (LOG.isTraceEnabled()) {
1:ef85089:             LOG.trace("HTTP GET consumer thread starting: " + this);
1:ef85089:         }
1:40a7d3b:         HttpClient httpClient = getReceiveHttpClient();
1:40a7d3b:         URI remoteUrl = getRemoteUrl();
1:540dd5c: 
1:540dd5c:         while (!isStopped() && !isStopping()) {
1:88acb0e: 
1:082fdc5:             httpMethod = new HttpGet(remoteUrl.toString());
1:40a7d3b:             configureMethod(httpMethod);
1:082fdc5:             HttpResponse answer = null;
1:ff30070: 
1:09bae42:             try {
1:082fdc5:                 answer = httpClient.execute(httpMethod);
1:082fdc5:                 int status = answer.getStatusLine().getStatusCode();
1:082fdc5:                 if (status != HttpStatus.SC_OK) {
1:082fdc5:                     if (status == HttpStatus.SC_REQUEST_TIMEOUT) {
1:540dd5c:                         LOG.debug("GET timed out");
2:40a7d3b:                         try {
1:540dd5c:                             Thread.sleep(1000);
1:540dd5c:                         } catch (InterruptedException e) {
1:540dd5c:                             onException(new InterruptedIOException());
1:0a12bcb:                             Thread.currentThread().interrupt();
1:540dd5c:                             break;
1:540dd5c:                         }
1:540dd5c:                     } else {
1:540dd5c:                         onException(new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer));
1:540dd5c:                         break;
1:ff30070:                     }
1:540dd5c:                 } else {
1:8978ac0:                     receiveCounter++;
1:ef85089:                     DataInputStream stream = createDataInputStream(answer);
1:840ca30:                     Object command = getTextWireFormat().unmarshal(stream);
1:40a7d3b:                     if (command == null) {
1:b16d55f:                         LOG.debug("Received null command from url: " + remoteUrl);
1:ff30070:                     } else {
1:40a7d3b:                         doConsume(command);
1:40a7d3b:                     }
1:082fdc5:                     stream.close();
1:40a7d3b:                 }
1:540dd5c:             } catch (IOException e) {
1:540dd5c:                 onException(IOExceptionSupport.create("Failed to perform GET on: " + remoteUrl + " Reason: " + e.getMessage(), e));
1:540dd5c:                 break;
1:4af9754:             } finally {
1:082fdc5:                 if (answer != null) {
1:082fdc5:                     try {
1:082fdc5:                         EntityUtils.consume(answer.getEntity());
1:082fdc5:                     } catch (IOException e) {
1:082fdc5:                     }
1:082fdc5:                 }
1:40a7d3b:             }
1:40a7d3b:         }
1:40a7d3b:     }
1:ff30070: 
1:40a7d3b:     // Properties
1:40a7d3b:     // -------------------------------------------------------------------------
1:40a7d3b:     public HttpClient getSendHttpClient() {
1:40a7d3b:         if (sendHttpClient == null) {
1:40a7d3b:             sendHttpClient = createHttpClient();
1:40a7d3b:         }
1:40a7d3b:         return sendHttpClient;
1:40a7d3b:     }
1:540dd5c: 
1:40a7d3b:     public void setSendHttpClient(HttpClient sendHttpClient) {
1:40a7d3b:         this.sendHttpClient = sendHttpClient;
1:40a7d3b:     }
1:ff30070: 
1:40a7d3b:     public HttpClient getReceiveHttpClient() {
1:40a7d3b:         if (receiveHttpClient == null) {
1:40a7d3b:             receiveHttpClient = createHttpClient();
1:40a7d3b:         }
1:40a7d3b:         return receiveHttpClient;
1:40a7d3b:     }
1:ff30070: 
1:40a7d3b:     public void setReceiveHttpClient(HttpClient receiveHttpClient) {
1:40a7d3b:         this.receiveHttpClient = receiveHttpClient;
1:40a7d3b:     }
1:ff30070: 
1:40a7d3b:     // Implementation methods
1:40a7d3b:     // -------------------------------------------------------------------------
1:840ca30:     @Override
1:ff30070:     protected void doStart() throws Exception {
1:540dd5c: 
1:ef85089:         if (LOG.isTraceEnabled()) {
1:ef85089:             LOG.trace("HTTP GET consumer thread starting: " + this);
1:ef85089:         }
1:ff30070:         HttpClient httpClient = getReceiveHttpClient();
1:ff30070:         URI remoteUrl = getRemoteUrl();
1:540dd5c: 
1:082fdc5:         HttpHead httpMethod = new HttpHead(remoteUrl.toString());
1:ff30070:         configureMethod(httpMethod);
1:ef85089: 
1:ef85089:         // Request the options from the server so we can find out if the broker we are
1:ef85089:         // talking to supports GZip compressed content.  If so and useCompression is on
1:ef85089:         // then we can compress our POST data, otherwise we must send it uncompressed to
1:ef85089:         // ensure backwards compatibility.
1:ef85089:         HttpOptions optionsMethod = new HttpOptions(remoteUrl.toString());
1:ef85089:         ResponseHandler<String> handler = new BasicResponseHandler() {
1:ef85089:             @Override
1:ef85089:             public String handleResponse(HttpResponse response) throws HttpResponseException, IOException {
1:ef85089: 
1:ef85089:                 for(Header header : response.getAllHeaders()) {
1:ef85089:                     if (header.getName().equals("Accepts-Encoding") && header.getValue().contains("gzip")) {
1:ef85089:                         LOG.info("Broker Servlet supports GZip compression.");
1:ef85089:                         canSendCompressed = true;
1:ef85089:                         break;
1:ef85089:                     }
1:ef85089:                 }
1:ef85089: 
1:ef85089:                 return super.handleResponse(response);
1:ef85089:             }
1:ef85089:         };
1:ef85089: 
1:082fdc5:         try {
1:ef85089:             httpClient.execute(httpMethod, new BasicResponseHandler());
1:ef85089:             httpClient.execute(optionsMethod, handler);
1:082fdc5:         } catch(Exception e) {
1:56bed30:             LOG.trace("Error on start: ", e);
1:082fdc5:             throw new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + e.getMessage());
1:ff30070:         }
1:ef85089: 
1:540dd5c:         super.doStart();
1:ff30070:     }
1:540dd5c: 
1:840ca30:     @Override
1:40a7d3b:     protected void doStop(ServiceStopper stopper) throws Exception {
1:763ef10:         if (httpMethod != null) {
1:840ca30:             // In some versions of the JVM a race between the httpMethod and the completion
1:840ca30:             // of the method when using HTTPS can lead to a deadlock.  This hack attempts to
1:840ca30:             // detect that and interrupt the thread that's locked so that they can complete
1:840ca30:             // on another attempt.
1:840ca30:             for (int i = 0; i < 3; ++i) {
1:840ca30:                 Thread abortThread = new Thread(new Runnable() {
1:840ca30: 
1:840ca30:                     @Override
1:840ca30:                     public void run() {
1:840ca30:                         try {
1:840ca30:                             httpMethod.abort();
1:840ca30:                         } catch (Exception e) {
1:840ca30:                         }
1:840ca30:                     }
1:840ca30:                 });
1:840ca30: 
1:840ca30:                 abortThread.start();
1:840ca30:                 abortThread.join(2000);
1:34ce336:                 if (abortThread.isAlive() && !httpMethod.isAborted()) {
1:840ca30:                     abortThread.interrupt();
1:840ca30:                 }
1:840ca30:             }
1:763ef10:         }
1:40a7d3b:     }
1:ff30070: 
1:40a7d3b:     protected HttpClient createHttpClient() {
1:571d452:         DefaultHttpClient client = new DefaultHttpClient(createClientConnectionManager());
1:ef85089:         if (useCompression) {
1:ef85089:             client.addRequestInterceptor( new HttpRequestInterceptor() {
1:ef85089:                 @Override
1:ef85089:                 public void process(HttpRequest request, HttpContext context) {
1:ef85089:                     // We expect to received a compression response that we un-gzip
1:ef85089:                     request.addHeader("Accept-Encoding", "gzip");
1:ef85089:                 }
1:ef85089:             });
1:ef85089:         }
1:63b2d68:         if (getProxyHost() != null) {
1:082fdc5:             HttpHost proxy = new HttpHost(getProxyHost(), getProxyPort());
1:082fdc5:             client.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
1:8a3bdd9: 
1:d919db5:             if (client.getConnectionManager().getSchemeRegistry().get("http") == null) {
1:d919db5:                 client.getConnectionManager().getSchemeRegistry().register(
1:d919db5:                     new Scheme("http", getProxyPort(), PlainSocketFactory.getSocketFactory()));
1:d919db5:             }
1:d919db5: 
1:8a3bdd9:             if(getProxyUser() != null && getProxyPassword() != null) {
1:8a3bdd9:                 client.getCredentialsProvider().setCredentials(
1:8a3bdd9:                     new AuthScope(getProxyHost(), getProxyPort()),
1:8a3bdd9:                     new UsernamePasswordCredentials(getProxyUser(), getProxyPassword()));
1:8a3bdd9:             }
1:63b2d68:         }
1:06e929f: 
1:06e929f:         HttpParams params = client.getParams();
1:06e929f:         HttpConnectionParams.setSoTimeout(params, soTimeout);
1:4f6c55a:         HttpClientParams.setCookiePolicy(params, CookiePolicy.BROWSER_COMPATIBILITY);
1:06e929f: 
1:63b2d68:         return client;
1:082fdc5:     }
1:ff30070: 
1:571d452:     protected ClientConnectionManager createClientConnectionManager() {
1:571d452:         return new PoolingClientConnectionManager();
1:571d452:     }
1:571d452: 
1:082fdc5:     protected void configureMethod(AbstractHttpMessage method) {
1:082fdc5:         method.setHeader("clientID", clientID);
1:40a7d3b:     }
1:ff30070: 
1:540dd5c:     public boolean isTrace() {
1:540dd5c:         return trace;
1:540dd5c:     }
1:ff30070: 
1:540dd5c:     public void setTrace(boolean trace) {
1:540dd5c:         this.trace = trace;
1:540dd5c:     }
1:ff30070: 
1:840ca30:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         return receiveCounter;
1:8978ac0:     }
1:8978ac0: 
1:1a409b0:     public int getSoTimeout() {
1:1a409b0:         return soTimeout;
1:ff30070:     }
2:ff30070: 
1:1a409b0:     public void setSoTimeout(int soTimeout) {
1:1a409b0:         this.soTimeout = soTimeout;
1:1a409b0:     }
1:ef85089: 
1:ef85089:     public void setUseCompression(boolean useCompression) {
1:ef85089:         this.useCompression = useCompression;
1:ef85089:     }
1:ef85089: 
1:ef85089:     public boolean isUseCompression() {
1:ef85089:         return this.useCompression;
1:ef85089:     }
1:ef85089: 
1:ef85089:     public int getMinSendAsCompressedSize() {
1:ef85089:         return minSendAsCompressedSize;
1:ef85089:     }
1:ef85089: 
1:ef85089:     /**
1:ef85089:      * Sets the minimum size that must be exceeded on a send before compression is used if
1:ef85089:      * the useCompression option is specified.  For very small payloads compression can be
1:ef85089:      * inefficient compared to the transmission size savings.
1:ef85089:      *
1:ef85089:      * Default value is 0.
1:ef85089:      *
1:ef85089:      * @param minSendAsCompressedSize
1:ef85089:      */
1:ef85089:     public void setMinSendAsCompressedSize(int minSendAsCompressedSize) {
1:ef85089:         this.minSendAsCompressedSize = minSendAsCompressedSize;
1:ef85089:     }
1:ef85089: 
1:31c55f7:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         return null;
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public WireFormat getWireFormat() {
1:31c55f7:         return getTextWireFormat();
1:31c55f7:     }
1:40a7d3b: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:56bed30
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("Error on start: ", e);
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1:     }
1: 
1:     @Override
1:     public WireFormat getWireFormat() {
1:         return getTextWireFormat();
1:     }
commit:d919db5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.conn.scheme.PlainSocketFactory;
1: import org.apache.http.conn.scheme.Scheme;
/////////////////////////////////////////////////////////////////////////
1:             if (client.getConnectionManager().getSchemeRegistry().get("http") == null) {
1:                 client.getConnectionManager().getSchemeRegistry().register(
1:                     new Scheme("http", getProxyPort(), PlainSocketFactory.getSocketFactory()));
1:             }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:4f6c55a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.client.params.CookiePolicy;
1: import org.apache.http.client.params.HttpClientParams;
/////////////////////////////////////////////////////////////////////////
1:         HttpClientParams.setCookiePolicy(params, CookiePolicy.BROWSER_COMPATIBILITY);
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
1:                             Thread.currentThread().interrupt();
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:06e929f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         HttpParams params = client.getParams();
1:         HttpConnectionParams.setSoTimeout(params, soTimeout);
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:34ce336
/////////////////////////////////////////////////////////////////////////
1:                 if (abortThread.isAlive() && !httpMethod.isAborted()) {
commit:840ca30
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     Object command = getTextWireFormat().unmarshal(stream);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             // In some versions of the JVM a race between the httpMethod and the completion
1:             // of the method when using HTTPS can lead to a deadlock.  This hack attempts to
1:             // detect that and interrupt the thread that's locked so that they can complete
1:             // on another attempt.
1:             for (int i = 0; i < 3; ++i) {
1:                 Thread abortThread = new Thread(new Runnable() {
1: 
1:                     @Override
1:                     public void run() {
1:                         try {
1:                             httpMethod.abort();
1:                         } catch (Exception e) {
1:                         }
1:                     }
1:                 });
1: 
1:                 abortThread.start();
1:                 abortThread.join(2000);
0:                 if (!abortThread.isAlive()) {
1:                     abortThread.interrupt();
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:ef85089
/////////////////////////////////////////////////////////////////////////
1: import java.util.zip.GZIPInputStream;
1: import java.util.zip.GZIPOutputStream;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.apache.http.Header;
1: import org.apache.http.HttpRequest;
1: import org.apache.http.HttpRequestInterceptor;
1: import org.apache.http.client.HttpResponseException;
1: import org.apache.http.client.methods.HttpOptions;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.protocol.HttpContext;
/////////////////////////////////////////////////////////////////////////
1:     private boolean useCompression = false;
0:     private boolean canSendCompressed = false;
1:     private int minSendAsCompressedSize = 0;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (useCompression && canSendCompressed && bytes.length > minSendAsCompressedSize) {
1:             ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:             GZIPOutputStream stream = new GZIPOutputStream(bytesOut);
1:             stream.write(bytes);
1:             stream.close();
1:             httpMethod.addHeader("Content-Type", "application/x-gzip");
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("Sending compressed, size = " + bytes.length + ", compressed size = " + bytesOut.size());
1:             }
1:             bytes = bytesOut.toByteArray();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private DataInputStream createDataInputStream(HttpResponse answer) throws IOException {
1:         Header encoding = answer.getEntity().getContentEncoding();
1:         if (encoding != null && "gzip".equalsIgnoreCase(encoding.getValue())) {
1:             return new DataInputStream(new GZIPInputStream(answer.getEntity().getContent()));
1:         } else {
1:             return new DataInputStream(answer.getEntity().getContent());
1:         }
1:     }
1: 
1:         if (LOG.isTraceEnabled()) {
1:             LOG.trace("HTTP GET consumer thread starting: " + this);
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     DataInputStream stream = createDataInputStream(answer);
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isTraceEnabled()) {
1:             LOG.trace("HTTP GET consumer thread starting: " + this);
1:         }
1: 
1:         // Request the options from the server so we can find out if the broker we are
1:         // talking to supports GZip compressed content.  If so and useCompression is on
1:         // then we can compress our POST data, otherwise we must send it uncompressed to
1:         // ensure backwards compatibility.
1:         HttpOptions optionsMethod = new HttpOptions(remoteUrl.toString());
1:         ResponseHandler<String> handler = new BasicResponseHandler() {
1:             @Override
1:             public String handleResponse(HttpResponse response) throws HttpResponseException, IOException {
1: 
1:                 for(Header header : response.getAllHeaders()) {
1:                     if (header.getName().equals("Accepts-Encoding") && header.getValue().contains("gzip")) {
1:                         LOG.info("Broker Servlet supports GZip compression.");
1:                         canSendCompressed = true;
1:                         break;
1:                     }
1:                 }
1: 
1:                 return super.handleResponse(response);
1:             }
1:         };
1: 
1: 
1:             httpClient.execute(httpMethod, new BasicResponseHandler());
1:             httpClient.execute(optionsMethod, handler);
/////////////////////////////////////////////////////////////////////////
1:         if (useCompression) {
1:             client.addRequestInterceptor( new HttpRequestInterceptor() {
1:                 @Override
1:                 public void process(HttpRequest request, HttpContext context) {
1:                     // We expect to received a compression response that we un-gzip
1:                     request.addHeader("Accept-Encoding", "gzip");
1:                 }
1:             });
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setUseCompression(boolean useCompression) {
1:         this.useCompression = useCompression;
1:     }
1: 
1:     public boolean isUseCompression() {
1:         return this.useCompression;
1:     }
1: 
1:     public int getMinSendAsCompressedSize() {
1:         return minSendAsCompressedSize;
1:     }
1: 
1:     /**
1:      * Sets the minimum size that must be exceeded on a send before compression is used if
1:      * the useCompression option is specified.  For very small payloads compression can be
1:      * inefficient compared to the transmission size savings.
1:      *
1:      * Default value is 0.
1:      *
1:      * @param minSendAsCompressedSize
1:      */
1:     public void setMinSendAsCompressedSize(int minSendAsCompressedSize) {
1:         this.minSendAsCompressedSize = minSendAsCompressedSize;
1:     }
1: 
commit:f4df288
/////////////////////////////////////////////////////////////////////////
0: import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
/////////////////////////////////////////////////////////////////////////
0:         DefaultHttpClient client = new DefaultHttpClient(new ThreadSafeClientConnManager());
commit:8a3bdd9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.auth.AuthScope;
1: import org.apache.http.auth.UsernamePasswordCredentials;
/////////////////////////////////////////////////////////////////////////
0:         DefaultHttpClient client = new DefaultHttpClient();
1: 
1:             if(getProxyUser() != null && getProxyPassword() != null) {
1:                 client.getCredentialsProvider().setCredentials(
1:                     new AuthScope(getProxyHost(), getProxyPort()),
1:                     new UsernamePasswordCredentials(getProxyUser(), getProxyPassword()));
1:             }
commit:082fdc5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.HttpHost;
1: import org.apache.http.HttpResponse;
1: import org.apache.http.HttpStatus;
1: import org.apache.http.client.HttpClient;
1: import org.apache.http.client.ResponseHandler;
1: import org.apache.http.client.methods.HttpGet;
1: import org.apache.http.client.methods.HttpHead;
1: import org.apache.http.client.methods.HttpPost;
1: import org.apache.http.conn.params.ConnRoutePNames;
1: import org.apache.http.entity.ByteArrayEntity;
1: import org.apache.http.impl.client.BasicResponseHandler;
1: import org.apache.http.impl.client.DefaultHttpClient;
1: import org.apache.http.message.AbstractHttpMessage;
1: import org.apache.http.params.HttpConnectionParams;
1: import org.apache.http.params.HttpParams;
1: import org.apache.http.util.EntityUtils;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private HttpGet httpMethod;
1: 
/////////////////////////////////////////////////////////////////////////
1:         HttpPost httpMethod = new HttpPost(getRemoteUrl().toString());
1:         ByteArrayEntity entity = new ByteArrayEntity(bytes);
1:         httpMethod.setEntity(entity);
1:         HttpClient client = null;
1:         HttpResponse answer = null;
1:             client = getSendHttpClient();
0:             HttpParams params = client.getParams();
0:             HttpConnectionParams.setSoTimeout(params, soTimeout);
1:             answer = client.execute(httpMethod);
1:             int status = answer.getStatusLine().getStatusCode();
1:             if (status != HttpStatus.SC_OK) {
1:                 try {
1:                     stop();
1:                 } catch (Exception e) {
1:                     LOG.warn("Error trying to stop HTTP client: "+ e, e);
1:                 }
1:             if (answer != null) {
1:                 EntityUtils.consume(answer.getEntity());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             httpMethod = new HttpGet(remoteUrl.toString());
1:             HttpResponse answer = null;
1:                 answer = httpClient.execute(httpMethod);
1:                 int status = answer.getStatusLine().getStatusCode();
1:                 if (status != HttpStatus.SC_OK) {
1:                     if (status == HttpStatus.SC_REQUEST_TIMEOUT) {
/////////////////////////////////////////////////////////////////////////
0:                     DataInputStream stream = new DataInputStream(answer.getEntity().getContent());
1:                     stream.close();
1:                 if (answer != null) {
1:                     try {
1:                         EntityUtils.consume(answer.getEntity());
1:                     } catch (IOException e) {
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         HttpHead httpMethod = new HttpHead(remoteUrl.toString());
0:         ResponseHandler<String> handler = new BasicResponseHandler();
1:         try {
0:             httpClient.execute(httpMethod, handler);
1:         } catch(Exception e) {
1:             throw new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:         HttpClient client = new DefaultHttpClient();
1:             HttpHost proxy = new HttpHost(getProxyHost(), getProxyPort());
1:             client.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
1:     protected void configureMethod(AbstractHttpMessage method) {
1:         method.setHeader("clientID", clientID);
author:Christian Posta
-------------------------------------------------------------------------------
commit:571d452
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.conn.ClientConnectionManager;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean canSendCompressed = false;
/////////////////////////////////////////////////////////////////////////
1:         DefaultHttpClient client = new DefaultHttpClient(createClientConnectionManager());
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnectionManager createClientConnectionManager() {
1:         return new PoolingClientConnectionManager();
1:     }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a1ad8c
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
1:     private volatile int receiveCounter;
/////////////////////////////////////////////////////////////////////////
1:                     receiveCounter++;
/////////////////////////////////////////////////////////////////////////
1:     public int getReceiveCounter() {
1:         return receiveCounter;
1:     }
1: 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
0:  * A HTTP {@link org.apache.activemq.transport.TransportChannel} which uses the
0:  * <a href="http://jakarta.apache.org/commons/httpclient/">commons-httpclient</a>
1:     public static final int MAX_CLIENT_TIMEOUT = 30000;
0:     private static final Log LOG = LogFactory.getLog(HttpClientTransport.class);
1:     private static final IdGenerator CLIENT_ID_GENERATOR = new IdGenerator();
1: 
1:     private final String clientID = CLIENT_ID_GENERATOR.generateId();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (isStopped()) {
1:             throw new IOException("stopped.");
1:         }
1: 
1: 
1: 
1: 
0:             // checkSession(httpMethod);
/////////////////////////////////////////////////////////////////////////
1: 
0:         LOG.trace("HTTP GET consumer thread starting: " + this);
1: 
1:         while (!isStopped() && !isStopping()) {
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("GET timed out");
1:                             Thread.sleep(1000);
1:                         } catch (InterruptedException e) {
1:                             onException(new InterruptedIOException());
1:                             break;
1:                         }
1:                     } else {
1:                         onException(new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer));
1:                         break;
1:                 } else {
0:                     // checkSession(httpMethod);
0:                     DataInputStream stream = new DataInputStream(httpMethod.getResponseBodyAsStream());
0:                     Object command = (Object)getTextWireFormat().unmarshal(stream);
0:                         LOG.warn("Received null command from url: " + remoteUrl);
1:             } catch (IOException e) {
1:                 onException(IOExceptionSupport.create("Failed to perform GET on: " + remoteUrl + " Reason: " + e.getMessage(), e));
1:                 break;
/////////////////////////////////////////////////////////////////////////
1: 
0:         LOG.trace("HTTP GET consumer thread starting: " + this);
1: 
0:             throw new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer);
1: 
1:         super.doStart();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTrace() {
1:         return trace;
1:     }
1:     public void setTrace(boolean trace) {
1:         this.trace = trace;
1:     }
0:     // protected void checkSession(HttpMethod client) {
0:     // Header header = client.getRequestHeader("Set-Cookie");
0:     // if (header != null) {
0:     // String set_cookie = header.getValue();
0:     //
0:     // if (set_cookie != null && set_cookie.startsWith("JSESSIONID=")) {
0:     // String[] bits = set_cookie.split("[=;]");
0:     // sessionID = bits[1];
0:     // }
0:     // }
0:     // }
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public FutureResponse asyncRequest(Object command) throws IOException {
1:     public void oneway(Object command) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public Object request(Object command) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                 	Object command = (Object) getTextWireFormat().unmarshal(stream);                    
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
1:         String data = getTextWireFormat().marshalText(command);
1:         byte[] bytes = data.getBytes("UTF-8");
0:         httpMethod.setRequestBody(new ByteArrayInputStream(bytes));
1:         
/////////////////////////////////////////////////////////////////////////
0:                 	DataInputStream stream = new DataInputStream(httpMethod.getResponseBodyAsStream());                    
0:                 	Command command = (Command) getTextWireFormat().unmarshal(stream);                    
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:ff30070
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInputStream;
1: import java.io.IOException;
1: import java.io.InterruptedIOException;
1: import java.net.URI;
1: 
1: import org.apache.activemq.util.IdGenerator;
0: import org.apache.commons.httpclient.methods.HeadMethod;
/////////////////////////////////////////////////////////////////////////
0:     private static final IdGenerator clientIdGenerator = new IdGenerator();
1: 
1:     
0:     private final String clientID = clientIdGenerator.generateId();
1:     private boolean trace;
1:     
/////////////////////////////////////////////////////////////////////////
1:     	
0:     	if( isStopped() ) {
0:     		throw new IOException("stopped.");
1:     	}
1:     	
1:         	
1:                         
/////////////////////////////////////////////////////////////////////////
1:     	
1:                 
0:         while ( !isStopped() && !isStopping() ) {
/////////////////////////////////////////////////////////////////////////
0:                         log.debug("GET timed out");
1:                         try {
0: 							Thread.sleep(1000);
0: 						} catch (InterruptedException e) {
0: 							onException(new InterruptedIOException());
0: 							break;
1: 						}
0: 						onException(new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer));
0: 						break;
0:                 	DataInputStream stream = new DataInputStream(httpMethod.getResponseBodyAsStream());
1:                     
0:                 	Command command = getTextWireFormat().readCommand(stream);                    
1:                     } else {
0: 				onException(IOExceptionSupport.create("Failed to perform GET on: " + remoteUrl+" Reason: "+e.getMessage(),e));
0: 				break;
/////////////////////////////////////////////////////////////////////////
1:     protected void doStart() throws Exception {
1:     	
0:         log.trace("HTTP GET consumer thread starting: " + this);
1:         HttpClient httpClient = getReceiveHttpClient();
1:         URI remoteUrl = getRemoteUrl();
1:                 
0:         HeadMethod httpMethod = new HeadMethod(remoteUrl.toString());
1:         configureMethod(httpMethod);
1: 
0:         int answer = httpClient.executeMethod(httpMethod);
0:         if (answer != HttpStatus.SC_OK) {
0: 			throw new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer);
1:         }
1:     	
0:     	super.doStart();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:         method.setRequestHeader("clientID", clientID);
0: 	public boolean isTrace() {
0: 		return trace;
1: 	}
1: 
0: 	public void setTrace(boolean trace) {
0: 		this.trace = trace;
1: 	}
1: 
commit:5be5a62
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:8abcfd1
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.http;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.Response;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.util.TextWireFormat;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.ServiceStopper;
/////////////////////////////////////////////////////////////////////////
0:  * A HTTP {@link org.apache.activemq.transport.TransportChannel} which uses the <a
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:2d88395
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.impl.conn.PoolingClientConnectionManager;
/////////////////////////////////////////////////////////////////////////
1:  * A HTTP {@link org.apache.activemq.transport.Transport} which uses the
1:  * <a href="http://hc.apache.org/index.html">Apache HTTP Client</a>
/////////////////////////////////////////////////////////////////////////
0:         DefaultHttpClient client = new DefaultHttpClient(new PoolingClientConnectionManager());
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(HttpClientTransport.class);
commit:1a409b0
/////////////////////////////////////////////////////////////////////////
0: 
1:     private int soTimeout = MAX_CLIENT_TIMEOUT;
/////////////////////////////////////////////////////////////////////////
0:             params.setSoTimeout(soTimeout);
/////////////////////////////////////////////////////////////////////////
1:     public int getSoTimeout() {
1:         return soTimeout;
1:     }
0: 
1:     public void setSoTimeout(int soTimeout) {
1:         this.soTimeout = soTimeout;
1:     }
commit:09bae42
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ShutdownInfo;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.httpclient.HttpMethodRetryHandler;
0: import org.apache.commons.httpclient.NoHttpResponseException;
0: import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
0: import org.apache.commons.httpclient.params.HttpClientParams;
0: import org.apache.commons.httpclient.params.HttpMethodParams;
/////////////////////////////////////////////////////////////////////////
0:     private GetMethod httpMethod;
0:     
/////////////////////////////////////////////////////////////////////////
0:         InputStreamRequestEntity entity = new InputStreamRequestEntity(new ByteArrayInputStream(bytes));
0:         httpMethod.setRequestEntity(entity);
0:             HttpClientParams params = new HttpClientParams();
0:             params.setSoTimeout(MAX_CLIENT_TIMEOUT);
0:             client.setParams(params);
1:             if (command instanceof ShutdownInfo) {
1:             	try {
0:             		stop();
0:             	} catch (Exception e) {
0:             		LOG.warn("Error trying to stop HTTP client: "+ e, e);
1:             	}
1:             }
/////////////////////////////////////////////////////////////////////////
0:             httpMethod = new GetMethod(remoteUrl.toString());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	httpMethod.abort();
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:763ef10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (httpMethod != null) {
0:             httpMethod.abort();
1:         }
author:James Strachan
-------------------------------------------------------------------------------
commit:b16d55f
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Received null command from url: " + remoteUrl);
commit:63b2d68
/////////////////////////////////////////////////////////////////////////
0:         HttpClient client = new HttpClient();
1:         if (getProxyHost() != null) {
0:             client.getHostConfiguration().setProxy(getProxyHost(), getProxyPort());
1:         }
1:         return client;
commit:1ccd7bd
/////////////////////////////////////////////////////////////////////////
0:         while (!isStopped()) {
commit:0684e20
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.httpclient.Header;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (command.getDataStructureType() == ConnectionInfo.DATA_STRUCTURE_TYPE)
0:             clientID = ((ConnectionInfo) command).getClientId();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (sessionID != null) {
0:             method.addRequestHeader("Cookie", "JSESSIONID=" + sessionID);
/////////////////////////////////////////////////////////////////////////
0:         Header header = client.getRequestHeader("Set-Cookie");
0:         if (header != null) {
0:             String set_cookie = header.getValue();
0: 
0:             if (set_cookie != null && set_cookie.startsWith("JSESSIONID=")) {
0:                 String[] bits = set_cookie.split("[=;]");
0:                 sessionID = bits[1];
1:             }
0: 
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /** 
0:  * 
0:  * Copyright 2004 Protique Ltd
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); 
0:  * you may not use this file except in compliance with the License. 
0:  * You may obtain a copy of the License at 
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS, 
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
0:  * See the License for the specific language governing permissions and 
0:  * limitations under the License. 
0:  * 
0:  **/
0: package org.activemq.transport.http;
0: 
0: import org.activemq.command.Command;
0: import org.activemq.command.ConnectionInfo;
0: import org.activemq.command.Response;
0: import org.activemq.transport.FutureResponse;
0: import org.activemq.transport.util.TextWireFormat;
0: import org.activemq.util.IOExceptionSupport;
0: import org.activemq.util.ServiceStopper;
0: import org.apache.commons.httpclient.HttpClient;
0: import org.apache.commons.httpclient.HttpMethod;
0: import org.apache.commons.httpclient.HttpStatus;
0: import org.apache.commons.httpclient.methods.GetMethod;
0: import org.apache.commons.httpclient.methods.PostMethod;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.net.HttpURLConnection;
0: import java.net.URI;
0: 
1: /**
0:  * A HTTP {@link org.activemq.transport.TransportChannel} which uses the <a
0:  * href="http://jakarta.apache.org/commons/httpclient/">commons-httpclient</a>
1:  * library
0:  * 
0:  * @version $Revision$
1:  */
1: public class HttpClientTransport extends HttpTransportSupport {
0:     private static final Log log = LogFactory.getLog(HttpClientTransport.class);
0: 
1:     private HttpClient sendHttpClient;
1:     private HttpClient receiveHttpClient;
0:     private String clientID;
0:     private String sessionID;
0: 
0: 
1:     public HttpClientTransport(TextWireFormat wireFormat, URI remoteUrl) {
1:         super(wireFormat, remoteUrl);
1:     }
0: 
0:     public FutureResponse asyncRequest(Command command) throws IOException {
1:         return null;
1:     }
0: 
0:     public void oneway(Command command) throws IOException {
0:         if (command.getDataStructureType()==ConnectionInfo.DATA_STRUCTURE_TYPE)
0:             clientID=((ConnectionInfo)command).getClientId();
0:         
0:         PostMethod httpMethod = new PostMethod(getRemoteUrl().toString());
1:         configureMethod(httpMethod);
0:         httpMethod.setRequestBody(getTextWireFormat().toString(command));
1:         try {
0:             HttpClient client = getSendHttpClient();
0:             int answer = client.executeMethod(httpMethod);
0:             if (answer != HttpStatus.SC_OK) {
1:                 throw new IOException("Failed to post command: " + command + " as response was: " + answer);
1:             }
0:             checkSession(httpMethod);
1:         }
0:         catch (IOException e) {
1:             throw IOExceptionSupport.create("Could not post command: " + command + " due to: " + e, e);
1:         }
1:     }
0: 
0:     public Response request(Command command) throws IOException {
1:         return null;
1:     }
0: 
1:     public void run() {
0:         log.trace("HTTP GET consumer thread starting: " + this);
1:         HttpClient httpClient = getReceiveHttpClient();
1:         URI remoteUrl = getRemoteUrl();
0:         while (!isClosed()) {
0:             
0:             GetMethod httpMethod = new GetMethod(remoteUrl.toString());
1:             configureMethod(httpMethod);
0:      
1:             try {
0:                 int answer = httpClient.executeMethod(httpMethod);
0:                 if (answer != HttpStatus.SC_OK) {
0:                     if (answer == HttpStatus.SC_REQUEST_TIMEOUT) {
0:                         log.info("GET timed out");
1:                     }
0:                     else {
0:                         log.warn("Failed to perform GET on: " + remoteUrl + " as response was: " + answer);
1:                     }
1:                 }
0:                 else {
0:                     checkSession(httpMethod);
0:                     Command command = getTextWireFormat().readCommand(new DataInputStream(httpMethod.getResponseBodyAsStream()));
1:                     if (command == null) {
0:                         log.warn("Received null command from url: " + remoteUrl);
1:                     }
0:                     else {
1:                         doConsume(command);
1:                     }
1:                 }
1:             }
0:             catch (IOException e) {
0:                 log.warn("Failed to perform GET on: " + remoteUrl + " due to: " + e, e);
1:             }
1:         }
1:     }
0: 
0: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1:     public HttpClient getSendHttpClient() {
1:         if (sendHttpClient == null) {
1:             sendHttpClient = createHttpClient();
1:         }
1:         return sendHttpClient;
1:     }
0: 
1:     public void setSendHttpClient(HttpClient sendHttpClient) {
1:         this.sendHttpClient = sendHttpClient;
1:     }
0: 
1:     public HttpClient getReceiveHttpClient() {
1:         if (receiveHttpClient == null) {
1:             receiveHttpClient = createHttpClient();
1:         }
1:         return receiveHttpClient;
1:     }
0: 
1:     public void setReceiveHttpClient(HttpClient receiveHttpClient) {
1:         this.receiveHttpClient = receiveHttpClient;
1:     }
0: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1:     protected void doStop(ServiceStopper stopper) throws Exception {
0:         // TODO
1:     }
0: 
1:     protected HttpClient createHttpClient() {
0:         return new HttpClient();
1:     }
0: 
0:     protected void configureMethod(HttpMethod method) {
0:         if (sessionID!=null) {
0:             method.addRequestHeader("Cookie", "JSESSIONID="+sessionID);
1:         }
0:         else if (clientID != null) {
0:             method.setRequestHeader("clientID", clientID);
1:         }
1:     }
0: 
0:     protected void checkSession(HttpMethod client) {
0:         String set_cookie=client.getRequestHeader("Set-Cookie").getValue();
0:         
0:         if (set_cookie!=null && set_cookie.startsWith("JSESSIONID=")) {
0:             String[] bits=set_cookie.split("[=;]");
0:             sessionID=bits[1];
1:         }
1:     }
0:     
1: }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:7531e3e
/////////////////////////////////////////////////////////////////////////
0: //    private String sessionID;
/////////////////////////////////////////////////////////////////////////
0: //            checkSession(httpMethod);
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
0: //                    checkSession(httpMethod);
/////////////////////////////////////////////////////////////////////////
0: //        if (sessionID != null) {
0: //            method.addRequestHeader("Cookie", "JSESSIONID=" + sessionID);
0: //        }
0: //        else
0:           if (clientID != null) {
0: //    protected void checkSession(HttpMethod client) {
0: //        Header header = client.getRequestHeader("Set-Cookie");
0: //        if (header != null) {
0: //            String set_cookie = header.getValue();
0: //
0: //            if (set_cookie != null && set_cookie.startsWith("JSESSIONID=")) {
0: //                String[] bits = set_cookie.split("[=;]");
0: //                sessionID = bits[1];
0: //            }
0: //        }
0: //    }
commit:081b0e3
/////////////////////////////////////////////////////////////////////////
0:     public static final int MAX_CLIENT_TIMEOUT = 30000;
commit:4af9754
/////////////////////////////////////////////////////////////////////////
0:     public static final int MAX_CLIENT_TIMEOUT = 20000;
0: 
/////////////////////////////////////////////////////////////////////////
0:             client.setTimeout(MAX_CLIENT_TIMEOUT);
/////////////////////////////////////////////////////////////////////////
1:         } finally {
0:             httpMethod.getResponseBody();
0:             httpMethod.releaseConnection();
/////////////////////////////////////////////////////////////////////////
1:             } finally {
0:                 httpMethod.getResponseBody();
0:                 httpMethod.releaseConnection();
============================================================================