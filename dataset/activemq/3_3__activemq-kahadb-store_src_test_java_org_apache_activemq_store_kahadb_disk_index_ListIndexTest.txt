1:e11ece1: /**
1:e11ece1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e11ece1:  * contributor license agreements.  See the NOTICE file distributed with
1:e11ece1:  * this work for additional information regarding copyright ownership.
1:e11ece1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e11ece1:  * (the "License"); you may not use this file except in compliance with
1:e11ece1:  * the License.  You may obtain a copy of the License at
1:e11ece1:  *
1:e11ece1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e11ece1:  *
1:e11ece1:  * Unless required by applicable law or agreed to in writing, software
1:e11ece1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e11ece1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e11ece1:  * See the License for the specific language governing permissions and
1:e11ece1:  * limitations under the License.
1:e11ece1:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
1:e11ece1: 
1:334ade2: import java.io.ByteArrayInputStream;
1:334ade2: import java.io.ByteArrayOutputStream;
1:334ade2: import java.io.DataInput;
1:334ade2: import java.io.DataOutput;
1:334ade2: import java.io.IOException;
1:334ade2: import java.io.ObjectInputStream;
1:334ade2: import java.io.ObjectOutputStream;
1:e11ece1: import java.text.NumberFormat;
1:c73027d: import java.util.Arrays;
1:334ade2: import java.util.HashSet;
1:e11ece1: import java.util.Iterator;
1:334ade2: import java.util.LinkedList;
1:e11ece1: import java.util.Map;
1:e11ece1: import java.util.Random;
1:334ade2: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.Sequence;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.SequenceSet;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:81c167b: import org.junit.Test;
1:e11ece1: import org.slf4j.Logger;
1:e11ece1: import org.slf4j.LoggerFactory;
1:e11ece1: 
1:e11ece1: public class ListIndexTest extends IndexTestSupport {
1:e11ece1:     private static final Logger LOG = LoggerFactory.getLogger(ListIndexTest.class);
1:e11ece1:     private NumberFormat nf;
1:e11ece1: 
1:e11ece1:     @Override
1:e11ece1:     protected void setUp() throws Exception {
1:e11ece1:         super.setUp();
1:e11ece1:         nf = NumberFormat.getIntegerInstance();
1:e11ece1:         nf.setMinimumIntegerDigits(6);
1:e11ece1:         nf.setGroupingUsed(false);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     @Override
1:e11ece1:     protected Index<String, Long> createIndex() throws Exception {
1:e11ece1: 
1:e11ece1:         long id = tx.allocate().getPageId();
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         ListIndex<String, Long> index = new ListIndex<String, Long>(pf, id);
1:e11ece1:         index.setKeyMarshaller(StringMarshaller.INSTANCE);
1:e11ece1:         index.setValueMarshaller(LongMarshaller.INSTANCE);
1:e11ece1: 
1:e11ece1:         return index;
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testSize() throws Exception {
3:e11ece1:         createPageFileAndIndex(100);
1:e11ece1: 
1:e11ece1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
2:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         int count = 30;
1:e11ece1:         tx = pf.tx();
1:e11ece1:         doInsert(count);
1:e11ece1:         tx.commit();
1:e11ece1:         assertEquals("correct size", count, listIndex.size());
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:e11ece1:         while (iterator.hasNext()) {
1:e11ece1:             iterator.next();
1:e11ece1:             iterator.remove();
1:e11ece1:             assertEquals("correct size", --count, listIndex.size());
1:e11ece1:         }
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         count = 30;
1:e11ece1:         tx = pf.tx();
1:e11ece1:         doInsert(count);
1:e11ece1:         tx.commit();
1:e11ece1:         assertEquals("correct size", count, listIndex.size());
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         listIndex.clear(tx);
1:e11ece1:         assertEquals("correct size", 0, listIndex.size());
1:e11ece1:         tx.commit();
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:334ade2:     public void testPut() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1: 
1:334ade2:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:334ade2:         int count = 30;
1:334ade2:         tx = pf.tx();
1:334ade2:         doInsert(count);
1:e11ece1:         tx.commit();
1:334ade2:         assertEquals("correct size", count, listIndex.size());
1:e11ece1: 
1:334ade2:         tx = pf.tx();
1:334ade2:         Long value = listIndex.get(tx, key(10));
1:334ade2:         assertNotNull(value);
1:334ade2:         listIndex.put(tx, key(10), Long.valueOf(1024));
2:334ade2:         tx.commit();
1:e11ece1: 
1:334ade2:         tx = pf.tx();
1:334ade2:         value = listIndex.get(tx, key(10));
1:334ade2:         assertEquals(1024L, value.longValue());
1:334ade2:         assertTrue(listIndex.size() == 30);
1:334ade2:         tx.commit();
1:6d58dbe: 
1:334ade2:         tx = pf.tx();
1:334ade2:         value = listIndex.put(tx, key(31), Long.valueOf(2048));
1:334ade2:         assertNull(value);
1:334ade2:         assertTrue(listIndex.size() == 31);
1:334ade2:         tx.commit();
1:334ade2:     }
1:6d58dbe: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testAddFirst() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1: 
1:e11ece1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1: 
1:e11ece1:         // put is add last
1:e11ece1:         doInsert(10);
1:e11ece1:         listIndex.addFirst(tx, key(10), (long) 10);
1:e11ece1:         listIndex.addFirst(tx, key(11), (long) 11);
1:e11ece1: 
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         int counter = 11;
1:e11ece1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:e11ece1:         assertEquals(key(counter), iterator.next().getKey());
1:e11ece1:         counter--;
1:e11ece1:         assertEquals(key(counter), iterator.next().getKey());
1:e11ece1:         counter--;
1:e11ece1:         int count = 0;
1:e11ece1:         while (iterator.hasNext() && count < counter) {
1:81c167b:             Map.Entry<String, Long> entry = iterator.next();
1:e11ece1:             assertEquals(key(count), entry.getKey());
1:e11ece1:             assertEquals(count, (long) entry.getValue());
1:e11ece1:             count++;
1:e11ece1:         }
1:e11ece1:         tx.commit();
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testPruning() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1: 
2:e11ece1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:e11ece1: 
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         long pageCount = index.getPageFile().getPageCount();
1:e11ece1:         assertEquals(1, pageCount);
1:e11ece1: 
1:e11ece1:         long freePageCount = index.getPageFile().getFreePageCount();
1:e11ece1:         assertEquals("No free pages", 0, freePageCount);
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         doInsert(20);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         pageCount = index.getPageFile().getPageCount();
1:e11ece1:         LOG.info("page count: " + pageCount);
1:e11ece1:         assertTrue("used some pages", pageCount > 1);
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         // Remove the data.
1:e11ece1:         doRemove(20);
1:e11ece1: 
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         freePageCount = index.getPageFile().getFreePageCount();
1:e11ece1: 
1:e11ece1:         LOG.info("FreePage count: " + freePageCount);
1:e11ece1:         assertTrue("Some free pages " + freePageCount, freePageCount > 0);
1:e11ece1: 
1:e11ece1: 
1:e11ece1:         LOG.info("add some more to use up free list");
1:e11ece1:         tx = pf.tx();
1:e11ece1:         doInsert(20);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         freePageCount = index.getPageFile().getFreePageCount();
1:e11ece1: 
1:e11ece1:         LOG.info("FreePage count: " + freePageCount);
1:e11ece1:         assertEquals("no free pages " + freePageCount, 0, freePageCount);
1:e11ece1:         assertEquals("Page count is static", pageCount,  index.getPageFile().getPageCount());
1:e11ece1: 
3:e11ece1:         this.index.unload(tx);
1:e11ece1:         tx.commit();
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testIterationAddFirst() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         final int entryCount = 200;
2:e11ece1:         // Insert in reverse order..
1:e11ece1:         doInsertReverse(entryCount);
1:e11ece1:         this.index.unload(tx);
1:e11ece1:         tx.commit();
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         int counter = 0;
1:e11ece1:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
1:81c167b:             Map.Entry<String, Long> entry = i.next();
1:e11ece1:             assertEquals(key(counter), entry.getKey());
1:e11ece1:             assertEquals(counter, (long) entry.getValue());
1:e11ece1:             counter++;
1:e11ece1:         }
1:e11ece1:          assertEquals("We iterated over all entries", entryCount, counter);
1:e11ece1: 
1:e11ece1:         tx = pf.tx();
1:e11ece1:         // Remove the data.
1:e11ece1:         doRemove(entryCount);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         this.index.unload(tx);
1:e11ece1:         tx.commit();
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testIteration() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         // Insert in reverse order..
1:e11ece1:         final int entryCount = 200;
1:e11ece1:         doInsert(entryCount);
1:e11ece1: 
1:e11ece1:         this.index.unload(tx);
1:e11ece1:         tx.commit();
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         int counter = 0;
1:e11ece1:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
1:81c167b:             Map.Entry<String, Long> entry = i.next();
1:e11ece1:             assertEquals(key(counter), entry.getKey());
1:e11ece1:             assertEquals(counter, (long) entry.getValue());
1:e11ece1:             counter++;
1:e11ece1:         }
1:e11ece1:         assertEquals("We iterated over all entries", entryCount, counter);
1:e11ece1: 
1:e11ece1:         this.index.unload(tx);
1:e11ece1:         tx.commit();
1:e11ece1:     }
1:e11ece1: 
1:c73027d:     // https://issues.apache.org/jira/browse/AMQ-4221
1:c73027d:     public void testIterationRemoveTailAndPrev() throws Exception {
1:c73027d:         createPageFileAndIndex(100);
1:c73027d:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:c73027d:         this.index.load(tx);
1:c73027d:         tx.commit();
1:c73027d: 
1:c73027d:         String payload = new String(new byte[8]);
1:c73027d:         final int entryCount = 9;
1:c73027d:         for (int i=0; i<entryCount; i++) {
1:c73027d:             index.put(tx, payload + "-" + i, (long)i);
1:c73027d:         }
1:c73027d:         tx.commit();
1:c73027d: 
1:c73027d:         int counter = 0;
1:c73027d:         long[] toRemove = new long[] {6, 7, 8};
1:c73027d:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
1:c73027d:             Map.Entry<String, Long> entry = i.next();
1:c73027d:             assertEquals(counter, (long) entry.getValue());
1:c73027d:             if (Arrays.binarySearch(toRemove, counter++)  >= 0) {
1:c73027d:                 i.remove();
1:c73027d:             }
1:c73027d:         }
1:c73027d:         assertEquals("We iterated over all entries", entryCount, counter);
1:c73027d: 
1:c73027d:         this.index.unload(tx);
1:c73027d:         tx.commit();
1:c73027d:     }
1:c73027d: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testRandomRemove() throws Exception {
1:e11ece1: 
1:2b10259:         createPageFileAndIndex(4*1024);
1:e11ece1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         final int count = 4000;
1:e11ece1:         doInsert(count);
1:e11ece1: 
1:e11ece1:         Random rand = new Random(System.currentTimeMillis());
1:e11ece1:         int i = 0, prev = 0;
1:e11ece1:         while (!index.isEmpty(tx)) {
1:e11ece1:             prev = i;
1:e11ece1:             i = rand.nextInt(count);
1:e11ece1:             try {
1:e11ece1:                 index.remove(tx, key(i));
1:e11ece1:             } catch (Exception e) {
1:e11ece1:                 e.printStackTrace();
1:e11ece1:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:e11ece1:     public void testRemovePattern() throws Exception {
1:e11ece1:         createPageFileAndIndex(100);
1:e11ece1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:e11ece1:         final int count = 4000;
1:e11ece1:         doInsert(count);
1:e11ece1: 
1:e11ece1:         index.remove(tx, key(3697));
1:e11ece1:         index.remove(tx, key(1566));
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:2b10259:     public void testLargeAppendRemoveTimed() throws Exception {
1:2b10259:         createPageFileAndIndex(1024*4);
1:e11ece1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:e11ece1:         this.index.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1:         final int COUNT = 50000;
1:e11ece1:         long start = System.currentTimeMillis();
1:e11ece1:         for (int i = 0; i < COUNT; i++) {
1:334ade2:              listIndex.add(tx, key(i), (long) i);
1:e11ece1:              tx.commit();
1:e11ece1:         }
1:e11ece1:         LOG.info("Time to add " + COUNT + ": " + (System.currentTimeMillis() - start) + " mills");
1:e11ece1:         LOG.info("Page count: " + listIndex.getPageFile().getPageCount());
1:2b10259: 
1:2b10259:         start = System.currentTimeMillis();
1:2b10259:         tx = pf.tx();
1:2b10259:         int removeCount = 0;
1:2b10259:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:2b10259:         while (iterator.hasNext()) {
1:2b10259:             iterator.next();
1:2b10259:             iterator.remove();
1:2b10259:             removeCount++;
1:2b10259:         }
1:2b10259:         tx.commit();
1:2b10259:         assertEquals("Removed all", COUNT, removeCount);
1:2b10259:         LOG.info("Time to remove " + COUNT + ": " + (System.currentTimeMillis() - start) + " mills");
1:2b10259:         LOG.info("Page count: " + listIndex.getPageFile().getPageCount());
1:2b10259:         LOG.info("Page free count: " + listIndex.getPageFile().getFreePageCount());
1:e11ece1:     }
1:e11ece1: 
1:334ade2:     private int getMessageSize(int min, int max) {
1:334ade2:         return min + (int)(Math.random() * ((max - min) + 1));
1:e11ece1:     }
1:e11ece1: 
1:81c167b:     @Test(timeout=60000)
1:334ade2:     public void testLargeValueOverflow() throws Exception {
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:6d58dbe:         pf.setPageSize(4*1024);
1:6d58dbe:         pf.setEnablePageCaching(false);
1:6d58dbe:         pf.setWriteBatchSize(1);
1:6d58dbe:         pf.load();
1:6d58dbe:         tx = pf.tx();
1:6d58dbe:         long id = tx.allocate().getPageId();
1:e11ece1: 
1:334ade2:         ListIndex<Long, String> test = new ListIndex<Long, String>(pf, id);
1:334ade2:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:334ade2:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:334ade2:         test.load(tx);
1:e11ece1:         tx.commit();
1:e11ece1: 
1:334ade2:         final long NUM_ADDITIONS = 32L;
1:e11ece1: 
1:334ade2:         LinkedList<Long> expected = new LinkedList<Long>();
1:e11ece1: 
1:6d58dbe:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:334ade2:             final int stringSize = getMessageSize(1, 4096);
1:334ade2:             String val = new String(new byte[stringSize]);
1:334ade2:             expected.add(Long.valueOf(stringSize));
1:334ade2:             test.add(tx, i, val);
1:e11ece1:         }
1:e11ece1:         tx.commit();
1:6d58dbe: 
1:6d58dbe:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:334ade2:             String s = test.get(tx, i);
1:334ade2:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:e11ece1:         }
1:6d58dbe:         tx.commit();
1:6d58dbe: 
1:334ade2:         expected.clear();
1:334ade2: 
1:6d58dbe:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:334ade2:             final int stringSize = getMessageSize(1, 4096);
1:334ade2:             String val = new String(new byte[stringSize]);
1:334ade2:             expected.add(Long.valueOf(stringSize));
1:334ade2:             test.addFirst(tx, i+NUM_ADDITIONS, val);
1:334ade2:         }
1:6d58dbe:         tx.commit();
1:334ade2: 
1:6d58dbe:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:334ade2:             String s = test.get(tx, i+NUM_ADDITIONS);
1:334ade2:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:334ade2:         }
1:6d58dbe:         tx.commit();
1:334ade2: 
1:334ade2:         expected.clear();
1:334ade2: 
5:334ade2:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:334ade2:             final int stringSize = getMessageSize(1, 4096);
1:334ade2:             String val = new String(new byte[stringSize]);
1:334ade2:             expected.add(Long.valueOf(stringSize));
1:334ade2:             test.put(tx, i, val);
1:334ade2:         }
1:6d58dbe:         tx.commit();
1:334ade2: 
1:334ade2:         tx =  pf.tx();
1:334ade2:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:334ade2:             String s = test.get(tx, i);
1:334ade2:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:334ade2:         }
1:334ade2:         tx.commit();
1:334ade2:     }
1:334ade2: 
1:e11ece1:     void doInsertReverse(int count) throws Exception {
1:e11ece1:         for (int i = count - 1; i >= 0; i--) {
1:334ade2:             ((ListIndex<String, Long>) index).addFirst(tx, key(i), (long) i);
1:e11ece1:             tx.commit();
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     @Override
1:e11ece1:     protected String key(int i) {
1:e11ece1:         return "key:" + nf.format(i);
1:e11ece1:     }
7:334ade2: 
1:81c167b:     @Test(timeout=60000)
1:652b47f:     public void testListIndexConsistencyOverTime() throws Exception {
1:334ade2: 
1:6d58dbe:         final int NUM_ITERATIONS = 100;
1:334ade2: 
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:334ade2:         pf.setPageSize(4*1024);
1:334ade2:         pf.setEnablePageCaching(false);
1:334ade2:         pf.setWriteBatchSize(1);
1:334ade2:         pf.load();
1:334ade2:         tx = pf.tx();
1:334ade2:         long id = tx.allocate().getPageId();
1:334ade2: 
1:6d58dbe:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:6d58dbe:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:6d58dbe:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:6d58dbe:         test.load(tx);
1:6d58dbe:         tx.commit();
1:f77b252: 
1:6d58dbe:         int expectedListEntries = 0;
1:6d58dbe:         int nextSequenceId = 0;
1:6d58dbe: 
1:f77b252:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1:6d58dbe: 
1:6d58dbe:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:6d58dbe:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1:6d58dbe: 
1:6d58dbe:             for (int j = 0; j < expectedListEntries; j++) {
1:6d58dbe: 
1:6d58dbe:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1:6d58dbe: 
1:6d58dbe:                 int startSequenceId = nextSequenceId;
1:6d58dbe:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:6d58dbe:                     sequenceSet.add(nextSequenceId++);
1:6d58dbe:                     test.put(tx, String.valueOf(j), sequenceSet);
1:e11ece1:                 }
1:6d58dbe: 
1:6d58dbe:                 sequenceSet = test.get(tx, String.valueOf(j));
1:6d58dbe: 
1:6d58dbe:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:6d58dbe:                     sequenceSet.remove(startSequenceId++);
1:6d58dbe:                     test.put(tx, String.valueOf(j), sequenceSet);
1:6d58dbe:                 }
1:6d58dbe:             }
1:6d58dbe:         }
1:6d58dbe: 
1:6d58dbe:         LOG.info("Checking if Index has the expected number of entries.");
1:f77b252: 
1:6d58dbe:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:6d58dbe:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:6d58dbe:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:6d58dbe:         }
1:6d58dbe: 
1:6d58dbe:         LOG.info("Index has the expected number of entries.");
1:6d58dbe: 
1:6d58dbe:         assertEquals(expectedListEntries, test.size());
1:f77b252: 
1:6d58dbe:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:d2610fa:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:d2610fa:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:6d58dbe:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:d2610fa:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:6d58dbe:             assertEquals(expectedListEntries - (i + 1), test.size());
1:6d58dbe:         }
1:6d58dbe:     }
1:f77b252: 
1:81c167b:     @Test(timeout=60000)
1:f77b252:     public void testListLargeDataAddWithReverseRemove() throws Exception {
1:f77b252: 
1:f77b252:         final int NUM_ITERATIONS = 100;
1:f77b252: 
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:f77b252:         pf.setPageSize(4*1024);
1:f77b252:         pf.setEnablePageCaching(false);
1:f77b252:         pf.setWriteBatchSize(1);
1:f77b252:         pf.load();
1:f77b252:         tx = pf.tx();
1:f77b252:         long id = tx.allocate().getPageId();
1:f77b252: 
1:f77b252:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:f77b252:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:f77b252:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:f77b252:         test.load(tx);
1:f77b252:         tx.commit();
1:f77b252: 
1:f77b252:         int expectedListEntries = 0;
1:f77b252:         int nextSequenceId = 0;
1:f77b252: 
1:be8e58b:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entries and sparsely populating the sequences.");
1:f77b252: 
1:f77b252:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:f77b252:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1:f77b252: 
1:f77b252:             for (int j = 0; j < expectedListEntries; j++) {
1:f77b252: 
1:f77b252:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1:f77b252: 
1:f77b252:                 int startSequenceId = nextSequenceId;
1:f77b252:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:f77b252:                     sequenceSet.add(nextSequenceId++);
1:f77b252:                     test.put(tx, String.valueOf(j), sequenceSet);
1:f77b252:                 }
1:f77b252: 
1:f77b252:                 sequenceSet = test.get(tx, String.valueOf(j));
1:f77b252: 
1:f77b252:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:f77b252:                     sequenceSet.remove(startSequenceId++);
1:f77b252:                     test.put(tx, String.valueOf(j), sequenceSet);
1:f77b252:                 }
1:f77b252:             }
1:f77b252:         }
1:f77b252: 
1:f77b252:         LOG.info("Checking if Index has the expected number of entries.");
1:f77b252: 
1:f77b252:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:f77b252:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:f77b252:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:f77b252:         }
1:f77b252: 
1:f77b252:         LOG.info("Index has the expected number of entries.");
1:f77b252: 
1:f77b252:         assertEquals(expectedListEntries, test.size());
1:f77b252: 
1:f77b252:         for (int i = NUM_ITERATIONS - 1; i >= 0; --i) {
1:f77b252:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:f77b252:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:f77b252:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertEquals(--expectedListEntries, test.size());
1:f77b252:         }
1:f77b252:     }
1:f77b252: 
1:652b47f:     public void x_testSplitPerformance() throws Exception {
1:652b47f: 
1:652b47f:         final int NUM_ITERATIONS = 200;
1:652b47f:         final int RANGE = 200000;
1:652b47f: 
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:652b47f:         pf.setPageSize(4*1024);
1:652b47f:         pf.load();
1:652b47f:         tx = pf.tx();
1:652b47f:         long id = tx.allocate().getPageId();
1:652b47f: 
1:652b47f:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:652b47f:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:652b47f:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:652b47f:         test.load(tx);
1:652b47f:         tx.commit();
1:652b47f: 
1:652b47f:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:652b47f:             Sequence sequence = new Sequence(0);
1:652b47f:             sequence.setLast(RANGE);
1:652b47f:             SequenceSet sequenceSet  = new SequenceSet();
1:652b47f:             sequenceSet.add(sequence);
1:652b47f:             test.add(tx, String.valueOf(i), sequenceSet);
1:652b47f:         }
1:652b47f: 
1:652b47f:         long start = System.currentTimeMillis();
1:652b47f: 
1:652b47f:         // overflow the value in the last sequence
1:652b47f:         SequenceSet sequenceSet = test.get(tx, String.valueOf(NUM_ITERATIONS - 10));
1:652b47f:         for (int i=0; i<RANGE; i+=2) {
1:652b47f:             sequenceSet.remove(i);
1:652b47f:             test.put(tx, String.valueOf(NUM_ITERATIONS -1), sequenceSet);
1:652b47f:         }
1:652b47f:         LOG.info("duration: " + (System.currentTimeMillis() - start));
1:652b47f:     }
1:652b47f: 
1:81c167b:     @Test(timeout=60000)
1:f77b252:     public void testListLargeDataAddAndNonSequentialRemove() throws Exception {
1:f77b252: 
1:f77b252:         final int NUM_ITERATIONS = 100;
1:f77b252: 
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:f77b252:         pf.setPageSize(4*1024);
1:f77b252:         pf.setEnablePageCaching(false);
1:f77b252:         pf.setWriteBatchSize(1);
1:f77b252:         pf.load();
1:f77b252:         tx = pf.tx();
1:f77b252:         long id = tx.allocate().getPageId();
1:f77b252: 
1:f77b252:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:f77b252:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:f77b252:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:f77b252:         test.load(tx);
1:f77b252:         tx.commit();
1:f77b252: 
1:f77b252:         int expectedListEntries = 0;
1:f77b252:         int nextSequenceId = 0;
1:f77b252: 
1:f77b252:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1:f77b252: 
1:f77b252:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:f77b252:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1:f77b252: 
1:f77b252:             for (int j = 0; j < expectedListEntries; j++) {
1:f77b252: 
1:f77b252:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1:f77b252: 
1:f77b252:                 int startSequenceId = nextSequenceId;
1:f77b252:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:f77b252:                     sequenceSet.add(nextSequenceId++);
1:f77b252:                     test.put(tx, String.valueOf(j), sequenceSet);
1:f77b252:                 }
1:f77b252: 
1:f77b252:                 sequenceSet = test.get(tx, String.valueOf(j));
1:f77b252: 
1:f77b252:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:f77b252:                     sequenceSet.remove(startSequenceId++);
1:f77b252:                     test.put(tx, String.valueOf(j), sequenceSet);
1:f77b252:                 }
1:f77b252:             }
1:f77b252:         }
1:6d58dbe: 
1:f77b252:         LOG.info("Checking if Index has the expected number of entries.");
1:6d58dbe: 
1:f77b252:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:f77b252:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:f77b252:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:f77b252:         }
1:6d58dbe: 
1:f77b252:         LOG.info("Index has the expected number of entries.");
1:6d58dbe: 
1:f77b252:         assertEquals(expectedListEntries, test.size());
1:6d58dbe: 
1:f77b252:         for (int i = 0; i < NUM_ITERATIONS; i += 2) {
1:f77b252:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:f77b252:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:f77b252:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertEquals(--expectedListEntries, test.size());
1:f77b252:         }
1:f77b252: 
1:f77b252:         for (int i = NUM_ITERATIONS - 1; i > 0; i -= 2) {
1:f77b252:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:f77b252:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:f77b252:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1:f77b252: 
1:f77b252:             assertEquals(--expectedListEntries, test.size());
1:f77b252:         }
1:334ade2: 
1:f77b252:         assertEquals(0, test.size());
1:f77b252:     }
1:f77b252: 
1:334ade2:     static class HashSetStringMarshaller extends VariableMarshaller<HashSet<String>> {
1:334ade2:         final static HashSetStringMarshaller INSTANCE = new HashSetStringMarshaller();
1:334ade2: 
1:81c167b:         @Override
1:81c167b: 		public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
1:334ade2:             ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:334ade2:             ObjectOutputStream oout = new ObjectOutputStream(baos);
1:334ade2:             oout.writeObject(object);
1:334ade2:             oout.flush();
1:334ade2:             oout.close();
1:334ade2:             byte[] data = baos.toByteArray();
1:334ade2:             dataOut.writeInt(data.length);
1:334ade2:             dataOut.write(data);
1:6d58dbe:         }
1:334ade2: 
1:81c167b:         @Override
1:81c167b: 		@SuppressWarnings("unchecked")
1:334ade2:         public HashSet<String> readPayload(DataInput dataIn) throws IOException {
1:334ade2:             int dataLen = dataIn.readInt();
1:334ade2:             byte[] data = new byte[dataLen];
1:334ade2:             dataIn.readFully(data);
1:334ade2:             ByteArrayInputStream bais = new ByteArrayInputStream(data);
1:334ade2:             ObjectInputStream oin = new ObjectInputStream(bais);
1:334ade2:             try {
1:334ade2:                 return (HashSet<String>) oin.readObject();
1:334ade2:             } catch (ClassNotFoundException cfe) {
1:334ade2:                 IOException ioe = new IOException("Failed to read HashSet<String>: " + cfe);
1:334ade2:                 ioe.initCause(cfe);
1:334ade2:                 throw ioe;
1:334ade2:             }
1:334ade2:         }
1:334ade2:     }
4:334ade2: }
============================================================================
author:Gary Tully
-------------------------------------------------------------------------------
commit:c73027d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     // https://issues.apache.org/jira/browse/AMQ-4221
1:     public void testIterationRemoveTailAndPrev() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         String payload = new String(new byte[8]);
1:         final int entryCount = 9;
1:         for (int i=0; i<entryCount; i++) {
1:             index.put(tx, payload + "-" + i, (long)i);
1:         }
1:         tx.commit();
1: 
1:         int counter = 0;
1:         long[] toRemove = new long[] {6, 7, 8};
1:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
1:             Map.Entry<String, Long> entry = i.next();
1:             assertEquals(counter, (long) entry.getValue());
1:             if (Arrays.binarySearch(toRemove, counter++)  >= 0) {
1:                 i.remove();
1:             }
1:         }
1:         assertEquals("We iterated over all entries", entryCount, counter);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
commit:652b47f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.Sequence;
/////////////////////////////////////////////////////////////////////////
1:     public void testListIndexConsistencyOverTime() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void x_testSplitPerformance() throws Exception {
1: 
1:         final int NUM_ITERATIONS = 200;
1:         final int RANGE = 200000;
1: 
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             Sequence sequence = new Sequence(0);
1:             sequence.setLast(RANGE);
1:             SequenceSet sequenceSet  = new SequenceSet();
1:             sequenceSet.add(sequence);
1:             test.add(tx, String.valueOf(i), sequenceSet);
1:         }
1: 
1:         long start = System.currentTimeMillis();
1: 
1:         // overflow the value in the last sequence
1:         SequenceSet sequenceSet = test.get(tx, String.valueOf(NUM_ITERATIONS - 10));
1:         for (int i=0; i<RANGE; i+=2) {
1:             sequenceSet.remove(i);
1:             test.put(tx, String.valueOf(NUM_ITERATIONS -1), sequenceSet);
1:         }
1:         LOG.info("duration: " + (System.currentTimeMillis() - start));
1:     }
1: 
commit:be8e58b
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entries and sparsely populating the sequences.");
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1:         createPageFileAndIndex(4*1024);
/////////////////////////////////////////////////////////////////////////
1:     public void testLargeAppendRemoveTimed() throws Exception {
1:         createPageFileAndIndex(1024*4);
1: 
1:         start = System.currentTimeMillis();
1:         tx = pf.tx();
1:         int removeCount = 0;
1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:         while (iterator.hasNext()) {
1:             iterator.next();
1:             iterator.remove();
1:             removeCount++;
1:         }
1:         tx.commit();
1:         assertEquals("Removed all", COUNT, removeCount);
1:         LOG.info("Time to remove " + COUNT + ": " + (System.currentTimeMillis() - start) + " mills");
1:         LOG.info("Page count: " + listIndex.getPageFile().getPageCount());
1:         LOG.info("Page free count: " + listIndex.getPageFile().getFreePageCount());
commit:e11ece1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.text.NumberFormat;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.Random;
0: import org.apache.kahadb.util.LongMarshaller;
0: import org.apache.kahadb.util.StringMarshaller;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class ListIndexTest extends IndexTestSupport {
1:     private static final Logger LOG = LoggerFactory.getLogger(ListIndexTest.class);
1:     private NumberFormat nf;
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         nf = NumberFormat.getIntegerInstance();
1:         nf.setMinimumIntegerDigits(6);
1:         nf.setGroupingUsed(false);
1:     }
1: 
1:     @Override
1:     protected Index<String, Long> createIndex() throws Exception {
1: 
1:         long id = tx.allocate().getPageId();
1:         tx.commit();
1: 
1:         ListIndex<String, Long> index = new ListIndex<String, Long>(pf, id);
1:         index.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         index.setValueMarshaller(LongMarshaller.INSTANCE);
1: 
1:         return index;
1:     }
1: 
1:     public void testSize() throws Exception {
1:         createPageFileAndIndex(100);
1: 
1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         int count = 30;
1:         tx = pf.tx();
1:         doInsert(count);
1:         tx.commit();
1:         assertEquals("correct size", count, listIndex.size());
1: 
1:         tx = pf.tx();
1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:         while (iterator.hasNext()) {
1:             iterator.next();
1:             iterator.remove();
1:             assertEquals("correct size", --count, listIndex.size());
1:         }
1:         tx.commit();
1: 
1:         count = 30;
1:         tx = pf.tx();
1:         doInsert(count);
1:         tx.commit();
1:         assertEquals("correct size", count, listIndex.size());
1: 
1:         tx = pf.tx();
1:         listIndex.clear(tx);
1:         assertEquals("correct size", 0, listIndex.size());
1:         tx.commit();
1:     }
1: 
1:     public void testAddFirst() throws Exception {
1:         createPageFileAndIndex(100);
1: 
1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         tx = pf.tx();
1: 
1:         // put is add last
1:         doInsert(10);
1:         listIndex.addFirst(tx, key(10), (long) 10);
1:         listIndex.addFirst(tx, key(11), (long) 11);
1: 
1:         tx.commit();
1: 
1:         tx = pf.tx();
1:         int counter = 11;
1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);
1:         assertEquals(key(counter), iterator.next().getKey());
1:         counter--;
1:         assertEquals(key(counter), iterator.next().getKey());
1:         counter--;
1:         int count = 0;
1:         while (iterator.hasNext() && count < counter) {
0:             Map.Entry<String, Long> entry = (Map.Entry<String, Long>) iterator.next();
1:             assertEquals(key(count), entry.getKey());
1:             assertEquals(count, (long) entry.getValue());
1:             count++;
1:         }
1:         tx.commit();
1:     }
1: 
1:     public void testPruning() throws Exception {
1:         createPageFileAndIndex(100);
1: 
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1: 
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         long pageCount = index.getPageFile().getPageCount();
1:         assertEquals(1, pageCount);
1: 
1:         long freePageCount = index.getPageFile().getFreePageCount();
1:         assertEquals("No free pages", 0, freePageCount);
1: 
1:         tx = pf.tx();
1:         doInsert(20);
1:         tx.commit();
1: 
1:         pageCount = index.getPageFile().getPageCount();
1:         LOG.info("page count: " + pageCount);
1:         assertTrue("used some pages", pageCount > 1);
1: 
1:         tx = pf.tx();
1:         // Remove the data.
1:         doRemove(20);
1: 
1:         tx.commit();
1: 
1:         freePageCount = index.getPageFile().getFreePageCount();
1: 
1:         LOG.info("FreePage count: " + freePageCount);
1:         assertTrue("Some free pages " + freePageCount, freePageCount > 0);
1: 
1: 
1:         LOG.info("add some more to use up free list");
1:         tx = pf.tx();
1:         doInsert(20);
1:         tx.commit();
1: 
1:         freePageCount = index.getPageFile().getFreePageCount();
1: 
1:         LOG.info("FreePage count: " + freePageCount);
1:         assertEquals("no free pages " + freePageCount, 0, freePageCount);
1:         assertEquals("Page count is static", pageCount,  index.getPageFile().getPageCount());
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
1:     public void testIterationAddFirst() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         tx = pf.tx();
1:         final int entryCount = 200;
1:         // Insert in reverse order..
1:         doInsertReverse(entryCount);
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         int counter = 0;
1:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
0:             Map.Entry<String, Long> entry = (Map.Entry<String, Long>) i.next();
1:             assertEquals(key(counter), entry.getKey());
1:             assertEquals(counter, (long) entry.getValue());
1:             counter++;
1:         }
1:          assertEquals("We iterated over all entries", entryCount, counter);
1: 
1:         tx = pf.tx();
1:         // Remove the data.
1:         doRemove(entryCount);
1:         tx.commit();
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
1: 
1:     public void testIteration() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // Insert in reverse order..
1:         final int entryCount = 200;
1:         doInsert(entryCount);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         int counter = 0;
1:         for (Iterator<Map.Entry<String, Long>> i = index.iterator(tx); i.hasNext(); ) {
0:             Map.Entry<String, Long> entry = (Map.Entry<String, Long>) i.next();
1:             assertEquals(key(counter), entry.getKey());
1:             assertEquals(counter, (long) entry.getValue());
1:             counter++;
1:         }
1:         assertEquals("We iterated over all entries", entryCount, counter);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
0:     public void testVisitor() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // Insert in reverse order..
0:         doInsert(1000);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
0:         // BTree should iterate it in sorted order.
1: 
0:         /*index.visit(tx, new BTreeVisitor<String, Long>(){
0:             public boolean isInterestedInKeysBetween(String first, String second) {
0:                 return true;
1:             }
0:             public void visit(List<String> keys, List<Long> values) {
1:             }
0:         });*/
1: 
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
1: 
1:     public void testRandomRemove() throws Exception {
1: 
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         final int count = 4000;
1:         doInsert(count);
1: 
1:         Random rand = new Random(System.currentTimeMillis());
1:         int i = 0, prev = 0;
1:         while (!index.isEmpty(tx)) {
1:             prev = i;
1:             i = rand.nextInt(count);
1:             try {
1:                 index.remove(tx, key(i));
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:             }
1:         }
1:     }
1: 
1:     public void testRemovePattern() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> index = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         final int count = 4000;
1:         doInsert(count);
1: 
1:         index.remove(tx, key(3697));
1:         index.remove(tx, key(1566));
1:     }
1: 
0:     public void testLargeAppendTimed() throws Exception {
1:         createPageFileAndIndex(100);
1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
1:         this.index.load(tx);
1:         tx.commit();
1:         final int COUNT = 50000;
1:         long start = System.currentTimeMillis();
1:         for (int i = 0; i < COUNT; i++) {
0:             //String test = new String("test" + i);
0:             //ByteSequence bs = new ByteSequence(test.getBytes());
0:              listIndex.put(tx, key(i), (long) i);
1:              tx.commit();
1:         }
1:         LOG.info("Time to add " + COUNT + ": " + (System.currentTimeMillis() - start) + " mills");
1:         LOG.info("Page count: " + listIndex.getPageFile().getPageCount());
1:     }
1: 
1:     void doInsertReverse(int count) throws Exception {
1:         for (int i = count - 1; i >= 0; i--) {
0:             ((ListIndex) index).addFirst(tx, key(i), (long) i);
1:             tx.commit();
1:         }
1:     }
1: 
1:     @Override
1:     protected String key(int i) {
1:         return "key:" + nf.format(i);
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:81c167b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:             Map.Entry<String, Long> entry = iterator.next();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:             Map.Entry<String, Long> entry = i.next();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:             Map.Entry<String, Long> entry = i.next();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:         @Override
1: 		public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         @Override
1: 		@SuppressWarnings("unchecked")
commit:6010bd3
commit:f77b252
/////////////////////////////////////////////////////////////////////////
1:     public void testListLargeDataAddWithReverseRemove() throws Exception {
1: 
1:         final int NUM_ITERATIONS = 100;
1: 
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         int expectedListEntries = 0;
1:         int nextSequenceId = 0;
1: 
1:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1: 
1:             for (int j = 0; j < expectedListEntries; j++) {
1: 
1:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 int startSequenceId = nextSequenceId;
1:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:                     sequenceSet.add(nextSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1: 
1:                 sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:                     sequenceSet.remove(startSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1:             }
1:         }
1: 
1:         LOG.info("Checking if Index has the expected number of entries.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:         }
1: 
1:         LOG.info("Index has the expected number of entries.");
1: 
1:         assertEquals(expectedListEntries, test.size());
1: 
1:         for (int i = NUM_ITERATIONS - 1; i >= 0; --i) {
1:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertEquals(--expectedListEntries, test.size());
1:         }
1:     }
1: 
1:     public void testListLargeDataAddAndNonSequentialRemove() throws Exception {
1: 
1:         final int NUM_ITERATIONS = 100;
1: 
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         int expectedListEntries = 0;
1:         int nextSequenceId = 0;
1: 
1:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1: 
1:             for (int j = 0; j < expectedListEntries; j++) {
1: 
1:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 int startSequenceId = nextSequenceId;
1:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:                     sequenceSet.add(nextSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1: 
1:                 sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:                     sequenceSet.remove(startSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1:             }
1:         }
1: 
1:         LOG.info("Checking if Index has the expected number of entries.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:         }
1: 
1:         LOG.info("Index has the expected number of entries.");
1: 
1:         assertEquals(expectedListEntries, test.size());
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; i += 2) {
1:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertEquals(--expectedListEntries, test.size());
1:         }
1: 
1:         for (int i = NUM_ITERATIONS - 1; i > 0; i -= 2) {
1:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertEquals(--expectedListEntries, test.size());
1:         }
1: 
1:         assertEquals(0, test.size());
1:     }
1: 
commit:d2610fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
commit:6d58dbe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.SequenceSet;
/////////////////////////////////////////////////////////////////////////
0:     public void testListIndexConsistancyOverTime() throws Exception {
1: 
1:         final int NUM_ITERATIONS = 100;
1: 
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         int expectedListEntries = 0;
1:         int nextSequenceId = 0;
1: 
0:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             tx =  pf.tx();
1:             test.add(tx, String.valueOf(expectedListEntries++), new SequenceSet());
1:             tx.commit();
1: 
1:             tx =  pf.tx();
1:             for (int j = 0; j < expectedListEntries; j++) {
1: 
1:                 SequenceSet sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 int startSequenceId = nextSequenceId;
1:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:                     sequenceSet.add(nextSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1: 
1:                 sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:                     sequenceSet.remove(startSequenceId++);
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1:             }
1:             tx.commit();
1:         }
1: 
1:         LOG.info("Checking if Index has the expected number of entries.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             tx =  pf.tx();
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:             tx.commit();
1:         }
1: 
1:         LOG.info("Index has the expected number of entries.");
1: 
1:         assertEquals(expectedListEntries, test.size());
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
0:             LOG.info("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:             tx =  pf.tx();
1: 
0: //            assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:             tx.commit();
0:             LOG.info("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertEquals(expectedListEntries - (i + 1), test.size());
1:         }
1:     }
1: 
commit:334ade2
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.util.HashSet;
1: import java.util.LinkedList;
1: 
0: import org.apache.kahadb.page.PageFile;
0: import org.apache.kahadb.util.VariableMarshaller;
/////////////////////////////////////////////////////////////////////////
1:     public void testPut() throws Exception {
0:         createPageFileAndIndex(100);
1: 
1:         ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);
0:         this.index.load(tx);
1:         tx.commit();
1: 
1:         int count = 30;
1:         tx = pf.tx();
1:         doInsert(count);
1:         tx.commit();
1:         assertEquals("correct size", count, listIndex.size());
1: 
1:         tx = pf.tx();
1:         Long value = listIndex.get(tx, key(10));
1:         assertNotNull(value);
1:         listIndex.put(tx, key(10), Long.valueOf(1024));
1:         tx.commit();
1: 
1:         tx = pf.tx();
1:         value = listIndex.get(tx, key(10));
1:         assertEquals(1024L, value.longValue());
1:         assertTrue(listIndex.size() == 30);
1:         tx.commit();
1: 
1:         tx = pf.tx();
1:         value = listIndex.put(tx, key(31), Long.valueOf(2048));
1:         assertNull(value);
1:         assertTrue(listIndex.size() == 31);
1:         tx.commit();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:              listIndex.add(tx, key(i), (long) i);
/////////////////////////////////////////////////////////////////////////
1:     private int getMessageSize(int min, int max) {
1:         return min + (int)(Math.random() * ((max - min) + 1));
1:     }
1: 
1:     public void testLargeValueOverflow() throws Exception {
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<Long, String> test = new ListIndex<Long, String>(pf, id);
1:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:         test.load(tx);
0:         tx.commit();
1: 
1:         final long NUM_ADDITIONS = 32L;
1: 
1:         LinkedList<Long> expected = new LinkedList<Long>();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:             final int stringSize = getMessageSize(1, 4096);
1:             String val = new String(new byte[stringSize]);
1:             expected.add(Long.valueOf(stringSize));
1:             test.add(tx, i, val);
1:         }
0:         tx.commit();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:             String s = test.get(tx, i);
1:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:         }
0:         tx.commit();
1: 
1:         expected.clear();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:             final int stringSize = getMessageSize(1, 4096);
1:             String val = new String(new byte[stringSize]);
1:             expected.add(Long.valueOf(stringSize));
1:             test.addFirst(tx, i+NUM_ADDITIONS, val);
1:         }
0:         tx.commit();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:             String s = test.get(tx, i+NUM_ADDITIONS);
1:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:         }
0:         tx.commit();
1: 
1:         expected.clear();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; ++i) {
1:             final int stringSize = getMessageSize(1, 4096);
1:             String val = new String(new byte[stringSize]);
1:             expected.add(Long.valueOf(stringSize));
1:             test.put(tx, i, val);
1:         }
0:         tx.commit();
1: 
1:         tx =  pf.tx();
1:         for (long i = 0; i < NUM_ADDITIONS; i++) {
1:             String s = test.get(tx, i);
1:             assertEquals("string length did not match expected", expected.get((int)i), Long.valueOf(s.length()));
1:         }
0:         tx.commit();
1:     }
1: 
1:             ((ListIndex<String, Long>) index).addFirst(tx, key(i), (long) i);
/////////////////////////////////////////////////////////////////////////
0: 
1:     static class HashSetStringMarshaller extends VariableMarshaller<HashSet<String>> {
1:         final static HashSetStringMarshaller INSTANCE = new HashSetStringMarshaller();
0: 
0:         public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
1:             ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:             ObjectOutputStream oout = new ObjectOutputStream(baos);
1:             oout.writeObject(object);
1:             oout.flush();
1:             oout.close();
1:             byte[] data = baos.toByteArray();
1:             dataOut.writeInt(data.length);
1:             dataOut.write(data);
1:         }
0: 
0:         @SuppressWarnings("unchecked")
1:         public HashSet<String> readPayload(DataInput dataIn) throws IOException {
1:             int dataLen = dataIn.readInt();
1:             byte[] data = new byte[dataLen];
1:             dataIn.readFully(data);
1:             ByteArrayInputStream bais = new ByteArrayInputStream(data);
1:             ObjectInputStream oin = new ObjectInputStream(bais);
1:             try {
1:                 return (HashSet<String>) oin.readObject();
1:             } catch (ClassNotFoundException cfe) {
1:                 IOException ioe = new IOException("Failed to read HashSet<String>: " + cfe);
1:                 ioe.initCause(cfe);
1:                 throw ioe;
1:             }
1:         }
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.Sequence;
1: import org.apache.activemq.store.kahadb.disk.util.SequenceSet;
1: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:715010a
============================================================================