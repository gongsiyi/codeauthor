2:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f812e34:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
2:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport;
1:527bd15: 
1:74a7a8b: import java.io.IOException;
1:8978ac0: 
1:ef0c0e1: import org.apache.activemq.command.WireFormatInfo;
1:15065b7: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:6b33749: 
1:ef0c0e1: /**
1:f812e34:  * Used to make sure that commands are arriving periodically from the peer of
1:f812e34:  * the transport.
1:ef0c0e1:  */
1:0885c60: public class InactivityMonitor extends AbstractInactivityMonitor {
1:b141d21: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(InactivityMonitor.class);
1:b141d21: 
1:ef0c0e1:     private WireFormatInfo localWireFormatInfo;
1:ef0c0e1:     private WireFormatInfo remoteWireFormatInfo;
1:527bd15: 
1:4d0a8a5:     private boolean ignoreRemoteWireFormat = false;
1:ee4c8ee:     private boolean ignoreAllWireFormatInfo = false;
1:527bd15: 
1:15065b7:     public InactivityMonitor(Transport next, WireFormat wireFormat) {
1:0885c60:         super(next, wireFormat);
1:ee4c8ee:         if (this.wireFormat == null) {
1:ee4c8ee:             this.ignoreAllWireFormatInfo = true;
1:527bd15:         }
1:2f1822b:     }
1:1656e1d: 
1:3125cae:     @Override
1:3125cae:     public void start() throws Exception {
1:e5a94bf:         if (!isMonitorStarted()) {
1:e5a94bf:             startConnectCheckTask();
1:e5a94bf:         }
1:3125cae:         super.start();
1:3125cae:     }
1:3125cae: 
1:3125cae:     @Override
1:0885c60:     protected void processInboundWireFormatInfo(WireFormatInfo info) throws IOException {
1:3125cae:         stopConnectCheckTask();
1:0885c60:         IOException error = null;
1:0885c60:         remoteWireFormatInfo = info;
1:1ba3532:         try {
1:4f8a1e6:             startMonitorThreads();
1:1ba3532:         } catch (IOException e) {
1:4f8a1e6:             error = e;
1:1656e1d:         }
1:0885c60:         if (error != null) {
1:4f8a1e6:             onException(error);
1:1656e1d:         }
1:1656e1d:     }
1:3d33c0e: 
1:3125cae:     @Override
1:0885c60:     protected void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException{
1:0885c60:         localWireFormatInfo = info;
1:4f8a1e6:         startMonitorThreads();
1:3d33c0e:     }
1:b141d21: 
1:0885c60:     @Override
1:0885c60:     protected synchronized void startMonitorThreads() throws IOException {
1:0885c60:         if (isMonitorStarted()) {
1:b141d21:             return;
1:b141d21:         }
1:b141d21: 
1:0885c60:         long readCheckTime = getReadCheckTime();
1:1ba3532: 
1:b141d21:         if (readCheckTime > 0) {
1:33edc99:             setWriteCheckTime(writeCheckValueFromReadCheck(readCheckTime));
1:527bd15:         }
1:1ba3532: 
1:0885c60:         super.startMonitorThreads();
1:527bd15:     }
1:4f8a1e6: 
1:33edc99:     private long writeCheckValueFromReadCheck(long readCheckTime) {
1:33edc99:         return readCheckTime>3 ? readCheckTime/3 : readCheckTime;
1:527bd15:     }
1:4f8a1e6: 
1:0885c60:     @Override
1:0885c60:     protected boolean configuredOk() throws IOException {
1:ee4c8ee:         boolean configured = false;
1:ee4c8ee:         if (ignoreAllWireFormatInfo) {
1:ee4c8ee:             configured = true;
1:ee4c8ee:         } else if (localWireFormatInfo != null && remoteWireFormatInfo != null) {
1:ee4c8ee:             if (!ignoreRemoteWireFormat) {
1:2f1822b:                 if (LOG.isDebugEnabled()) {
1:55b9954:                     LOG.debug("Using min of local: " + localWireFormatInfo + " and remote: " + remoteWireFormatInfo);
1:6b33749:                 }
1:2f1822b: 
1:0885c60:                 long readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
1:33edc99:                 long writeCheckTime = writeCheckValueFromReadCheck(readCheckTime);
1:6b33749: 
1:0885c60:                 setReadCheckTime(readCheckTime);
1:0885c60:                 setInitialDelayTime(Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay()));
1:0885c60:                 setWriteCheckTime(writeCheckTime);
1:74a7a8b: 
2:4f8a1e6:             } else {
1:6b33749:                 if (LOG.isDebugEnabled()) {
1:55b9954:                     LOG.debug("Using local: " + localWireFormatInfo);
1:6f0dcac:                 }
1:ef0c0e1: 
1:0885c60:                 long readCheckTime = localWireFormatInfo.getMaxInactivityDuration();
1:33edc99:                 long writeCheckTime = writeCheckValueFromReadCheck(readCheckTime);
1:ef0c0e1: 
1:0885c60:                 setReadCheckTime(readCheckTime);
1:0885c60:                 setInitialDelayTime(localWireFormatInfo.getMaxInactivityDurationInitalDelay());
1:0885c60:                 setWriteCheckTime(writeCheckTime);
1:6f0dcac:             }
1:ee4c8ee:             configured = true;
1:1ba3532:         }
1:ef0c0e1: 
1:ee4c8ee:         return configured;
1:1ba3532:     }
1:ef0c0e1: 
1:d314b7f:     public boolean isIgnoreAllWireFormatInfo() {
1:d314b7f:         return ignoreAllWireFormatInfo;
4:4f8a1e6:     }
1:ef0c0e1: 
1:d314b7f:     public void setIgnoreAllWireFormatInfo(boolean ignoreAllWireFormatInfo) {
1:d314b7f:         this.ignoreAllWireFormatInfo = ignoreAllWireFormatInfo;
1:4f8a1e6:     }
1:ef0c0e1: 
1:d314b7f:     public boolean isIgnoreRemoteWireFormat() {
1:d314b7f:         return ignoreRemoteWireFormat;
1:4f8a1e6:     }
6:ef0c0e1: 
1:d314b7f:     public void setIgnoreRemoteWireFormat(boolean ignoreRemoteWireFormat) {
1:d314b7f:         this.ignoreRemoteWireFormat = ignoreRemoteWireFormat;
1:4f8a1e6:     }
1:4f8a1e6: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:e5a94bf
/////////////////////////////////////////////////////////////////////////
1:         if (!isMonitorStarted()) {
1:             startConnectCheckTask();
1:         }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:3125cae
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void start() throws Exception {
0:         startConnectCheckTask();
1:         super.start();
1:     }
1: 
1:     @Override
1:         stopConnectCheckTask();
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicInteger lastReceiveCounter = new AtomicInteger(0);
1:     
/////////////////////////////////////////////////////////////////////////
0:         int currentCounter = next.getReceiveCounter();
0:         int previousCounter = lastReceiveCounter.getAndSet(currentCounter);
0:         if (inReceive.get() || currentCounter!=previousCounter ) {
commit:c382b50
/////////////////////////////////////////////////////////////////////////
0:         if (failed.compareAndSet(false, true)) {
0:             stopMonitorThreads();
0:             transportListener.onException(error);
commit:2f1822b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	stopMonitorThreads();
/////////////////////////////////////////////////////////////////////////
0:                     if (monitorStarted.get()) {
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:             ASYNC_TASKS.execute(new Runnable() {  
0:                 public void run() {
0:                     onException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
0:                 };
1:                 
0:             });
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     		stopMonitorThreads();
0:     		transportListener.onException(error);
1:     }    	
commit:1656e1d
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean failed = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:             if( !failed.getAndSet(true) ) {
0:                     	handleException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
/////////////////////////////////////////////////////////////////////////
0:                 if( failed.get() ) {
/////////////////////////////////////////////////////////////////////////
0:     	if( !failed.getAndSet(true) ) {
0: 	        handleException(error);
1:     	}
0: 	private void handleException(IOException error) {
0: 		if (monitorStarted.get()) {
0: 		    stopMonitorThreads();
1: 		}
0: 		transportListener.onException(error);
1: 	}
1: 
commit:8de8d0b
/////////////////////////////////////////////////////////////////////////
0:             if( !inactive.getAndSet(true) ) {
commit:6b33749
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean inactive = new AtomicBoolean(false);
1:     
/////////////////////////////////////////////////////////////////////////
0:             if( inactive.getAndSet(false) ) {
1:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
1:                 }
0:                 ASYNC_TASKS.execute(new Runnable() {  
0:                     public void run() {
0:                         onException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
0:                     };
1:                     
0:                 });
/////////////////////////////////////////////////////////////////////////
0:             if( inactive.get() ) {
0:                 throw new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress());
0:             next.oneway(o);
commit:3d33c0e
/////////////////////////////////////////////////////////////////////////
0:             if( !allowReadCheck(elapsed) ) { // FUNKY qdox bug does not allow me to inline this expression.
/////////////////////////////////////////////////////////////////////////
1:     
0:     private boolean allowReadCheck(long elapsed) {
0:         return elapsed > (readCheckTime * 9 / 10);
1:     }
commit:b141d21
/////////////////////////////////////////////////////////////////////////
0:     private long readCheckTime;
0:     private long writeCheckTime;
0:             long elapsed = (now-lastRunTime);
1: 
0:                 LOG.debug(""+elapsed+" ms elapsed since last read check.");
1:             
0:             // Perhaps the timer executed a read check late.. and then executes
0:             // the next read check on time which causes the time elapsed between
0:             // read checks to be small..
1:             
0:             // If less than 90% of the read check Time elapsed then abort this readcheck. 
0:             if( elapsed < (readCheckTime * 9 / 10) ) {
0:                 LOG.debug("Aborting read check.. Not enough time elapsed since last read check.");
1:                 return;
1:             }
1:             
0:             lastRunTime = now;
/////////////////////////////////////////////////////////////////////////
0:         readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
1:         if (readCheckTime > 0) {
0:             writeCheckTime = readCheckTime/3;
/////////////////////////////////////////////////////////////////////////
0:                 READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, readCheckTime,readCheckTime);
commit:527bd15
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static int CHECKER_COUNTER;
0:     private static Timer  READ_CHECK_TIMER;
0:     private static Timer  WRITE_CHECK_TIMER;
1:     
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:             synchronized( InactivityMonitor.class ) {
0:             	if( CHECKER_COUNTER == 0 ) {
0:             	    READ_CHECK_TIMER = new Timer("InactivityMonitor ReadCheck");
0:             	    WRITE_CHECK_TIMER = new Timer("InactivityMonitor WriteCheck");
1:             	}
0:             	CHECKER_COUNTER++;
0:                 WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, writeCheckTime,writeCheckTime);
0:                 READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, checkTime,checkTime);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             synchronized( InactivityMonitor.class ) {
0: 	            WRITE_CHECK_TIMER.purge();
0: 	            READ_CHECK_TIMER.purge();
0: 	            CHECKER_COUNTER--;
0: 	            if(CHECKER_COUNTER==0) {
0: 	            	WRITE_CHECK_TIMER.cancel();
0: 	            	READ_CHECK_TIMER.cancel();
0: 	            	WRITE_CHECK_TIMER = null;
0: 	            	READ_CHECK_TIMER = null;
1: 	            }
1:             }
commit:6f0dcac
/////////////////////////////////////////////////////////////////////////
0:         long lastRunTime;
0:             long now = System.currentTimeMillis();
0:             if( lastRunTime != 0 && LOG.isDebugEnabled() ) {
0:                 LOG.debug(""+(now-lastRunTime)+" ms elapsed since last read check.");
1:             }
0:             lastRunTime = now; 
0:         long lastRunTime;
0:             long now = System.currentTimeMillis();
0:             if( lastRunTime != 0 && LOG.isDebugEnabled() ) {
0:                 LOG.debug(""+(now-lastRunTime)+" ms elapsed since last read check.");
1:             }
0:             lastRunTime = now; 
commit:1ba3532
/////////////////////////////////////////////////////////////////////////
0:             // TODO: use a thread pool for this..
0:             Thread thread = new Thread("ActiveMQ: Activity Generator: "+next.getRemoteAddress()) {
0:                 public void run() {
1:                     try {
0:                         oneway(new KeepAliveInfo());
1:                     } catch (IOException e) {
0:                         onException(e);
1:                     }
0:                 };
0:             };
0:             thread.setDaemon(true);
0:             thread.start();
/////////////////////////////////////////////////////////////////////////
1: 
0:             // TODO: use a thread pool for this..
0:             Thread thread = new Thread("ActiveMQ: Inactivity Handler: "+next.getRemoteAddress()) {
0:                 public void run() {
0:                     synchronized (readChecker) {
0:                         onException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
1:                     }
0:                 };
0:             };
0:             thread.setDaemon(true);
0:             thread.start();
1: 
commit:6bb7fba
/////////////////////////////////////////////////////////////////////////
0:         transportListener.onException(error);
commit:4f8a1e6
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("A send is in progress");
0:             return;
1: 
0:         if (!commandSent.get()) {
0:             LOG.trace("No message sent since last write check, sending a KeepAliveInfo");
0:             try {
0:                 synchronized (writeChecker) {
0:                     next.oneway(new KeepAliveInfo());
1:                 }
0:             } catch (IOException e) {
0:                 onException(e);
1:             }
1:         } else {
0:             LOG.trace("Message sent since last write check, resetting flag");
1:         }
1: 
0:         commandSent.set(false);
0:         if (inReceive.get()) {
0:             LOG.trace("A receive is in progress");
0:             return;
0:         if (!commandReceived.get()) {
0:             LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:             synchronized (readChecker) {
0:                 onException(new InactivityIOException("Channel was inactive for too long."));
1:             }
1:         } else {
0:             LOG.trace("Message received since last read check, resetting flag: ");
1:         }
0:         commandReceived.set(false);
0:         inReceive.set(true);
0:         try {
0:             if (command.getClass() == WireFormatInfo.class) {
0:                 synchronized (this) {
0:                     IOException error=null;
0:                     remoteWireFormatInfo = (WireFormatInfo)command;
0:                     try {
1:                         startMonitorThreads();
0:                     } catch (IOException e) {
1:                         error = e;
1:                     }
0:                     if( error!=null ) {
1:                         onException(error);
0:             synchronized (readChecker) {
0:                 transportListener.onCommand(command);
1:             }
0:         } finally {
0:             commandReceived.set(true);
0:             inReceive.set(false);
0:         // Disable inactivity monitoring while processing a command.
0:         inSend.set(true);
0:         try {
0:             if (o.getClass() == WireFormatInfo.class) {
0:                 synchronized (this) {
0:                     localWireFormatInfo = (WireFormatInfo)o;
1:                     startMonitorThreads();
0:             synchronized (writeChecker) {
0:                 next.oneway(o);
1:             }
0:         } finally {
0:             commandSent.set(true);
0:             inSend.set(false);
/////////////////////////////////////////////////////////////////////////
0:         synchronized (readChecker) {
0:             transportListener.onException(error);
0:         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(InactivityMonitor.class);
/////////////////////////////////////////////////////////////////////////
0:     private synchronized void startMonitorThreads() throws IOException {
0:         if (monitorStarted.get()) {
0:         }
0:         if (localWireFormatInfo == null) {
0:         }
0:         if (remoteWireFormatInfo == null) {
0:         }
/////////////////////////////////////////////////////////////////////////
0:     private synchronized void stopMonitorThreads() {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.util.concurrent.atomic.AtomicBoolean;
1: 
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * Used to make sure that commands are arriving periodically from the peer of
1:  * the transport.
1:  * 
0:     private final Log LOG = LogFactory.getLog(InactivityMonitor.class);
0:     private final AtomicBoolean monitorStarted = new AtomicBoolean(false);
0:     private final AtomicBoolean commandSent = new AtomicBoolean(false);
0:     private final AtomicBoolean inSend = new AtomicBoolean(false);
0:     private final AtomicBoolean commandReceived = new AtomicBoolean(true);
0:     private final AtomicBoolean inReceive = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         synchronized (writeChecker) {
0:             if (inSend.get()) {
0:                 LOG.trace("A send is in progress");
0:             if (!commandSent.get()) {
0:                 LOG.trace("No message sent since last write check, sending a KeepAliveInfo");
0:                 LOG.trace("Message sent since last write check, resetting flag");
/////////////////////////////////////////////////////////////////////////
0:         synchronized (readChecker) {
0:             if (inReceive.get()) {
0:                 LOG.trace("A receive is in progress");
0:             if (!commandReceived.get()) {
0:                 LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:                 LOG.trace("Message received since last read check, resetting flag: ");
/////////////////////////////////////////////////////////////////////////
0:         synchronized (readChecker) {
0:                 if (command.getClass() == WireFormatInfo.class) {
0:                     synchronized (this) {
0:                         remoteWireFormatInfo = (WireFormatInfo)command;
/////////////////////////////////////////////////////////////////////////
0:         synchronized (writeChecker) {
0:                 if (o.getClass() == WireFormatInfo.class) {
0:                     synchronized (this) {
0:                         localWireFormatInfo = (WireFormatInfo)o;
/////////////////////////////////////////////////////////////////////////
0:         if (monitorStarted.get()) {
0:             stopMonitorThreads();
0:         }
0:         if (monitorStarted.get())
0:         if (localWireFormatInfo == null)
0:         if (remoteWireFormatInfo == null)
0:         if (l > 0) {
0:             Scheduler.executePeriodically(writeChecker, l / 2);
/////////////////////////////////////////////////////////////////////////
0:         if (monitorStarted.compareAndSet(true, false)) {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:cafe4cb
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean monitorStarted= new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:     	if( monitorStarted.get() ) {
0: 	        stopMonitorThreads();
0: 	        getTransportListener().onException(error);
0:     	}
0:         if( monitorStarted.get() ) 
/////////////////////////////////////////////////////////////////////////
0:             monitorStarted.set(true);        
/////////////////////////////////////////////////////////////////////////
0:         if( monitorStarted.compareAndSet(true, false) ) {
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void onCommand(Object command) {
0:             if( command.getClass() == WireFormatInfo.class ) {
/////////////////////////////////////////////////////////////////////////
0:             transportListener.onCommand(command);
/////////////////////////////////////////////////////////////////////////
0:     public void oneway(Object o) throws IOException {
0:             if( o.getClass() == WireFormatInfo.class ) {
0:                     localWireFormatInfo = (WireFormatInfo) o;
0:             next.oneway(o);
/////////////////////////////////////////////////////////////////////////
0:         transportListener.onException(error);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:1ea430e
/////////////////////////////////////////////////////////////////////////
0:             log.trace("A send is in progress");
0:             log.trace("No message sent since last write check, sending a KeepAliveInfo");
0:             log.trace("Message sent since last write check, resetting flag");
/////////////////////////////////////////////////////////////////////////
0:             log.trace("A receive is in progress");
0:             log.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:             log.trace("Message received since last read check, resetting flag: ");
commit:ef0c0e1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
0: public class InactivityMonitor extends TransportFilter {
1:     private WireFormatInfo localWireFormatInfo;
1:     private WireFormatInfo remoteWireFormatInfo;
0:     private boolean monitorStarted=false;
/////////////////////////////////////////////////////////////////////////
0:     private final Runnable readChecker = new Runnable() {
0:         public void run() {
0:             readCheck();
0:         }
0:     };
0:     private final Runnable writeChecker = new Runnable() {
0:         public void run() {
0:             writeCheck();
0:         }
0:     };
1:     
1:     
0:     public InactivityMonitor(Transport next) {
0:         super(next);
0:     }
1: 
0:         stopMonitorThreads();
1: 
1:         
/////////////////////////////////////////////////////////////////////////
0:                 next.oneway(new KeepAliveInfo());                
/////////////////////////////////////////////////////////////////////////
0:             if( command.isWireFormatInfo() ) {
0:                 synchronized( this ) {
0:                     remoteWireFormatInfo = (WireFormatInfo) command;
0:                     try {
0:                         startMonitorThreads();
0:                     } catch (IOException e) {
0:                         onException(e);
0:                     }
0:                 }
0:             }
1: 
0:             if( command.isWireFormatInfo() ) {
0:                 synchronized( this ) {
0:                     localWireFormatInfo = (WireFormatInfo) command;
0:                     startMonitorThreads();
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         stopMonitorThreads();
1:     
1:     
0:     synchronized private void startMonitorThreads() throws IOException {
0:         if( monitorStarted ) 
0:             return;
0:         if( localWireFormatInfo == null )
0:             return;
0:         if( remoteWireFormatInfo == null )
0:             return;
1:         
0:         long l = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
0:         if( l > 0 ) {
0:             Scheduler.executePeriodically(writeChecker, l/2);
0:             Scheduler.executePeriodically(readChecker, l);
0:             monitorStarted=true;        
0:         }
0:     }
1:     
1:     /**
0:      * 
1:      */
0:     synchronized private void stopMonitorThreads() {
0:         if( monitorStarted ) {
0:             Scheduler.cancel(readChecker);
0:             Scheduler.cancel(writeChecker);
0:             monitorStarted=false;
0:         }
0:     }
1:     
1: 
commit:6583ef1
/////////////////////////////////////////////////////////////////////////
0:             break;
/////////////////////////////////////////////////////////////////////////
0:             log.debug("No message received since last read check! ");
0:             log.debug("Message received since last read check, resetting flag: ");
commit:477984f
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean commandSent=new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:         Scheduler.cancel(this);
0:     synchronized public void run() {
/////////////////////////////////////////////////////////////////////////
0:         Scheduler.cancel(this);
commit:1229c23
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Command;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private final Log log = LogFactory.getLog(InactivityMonitor.class);
0:     
0:     private byte readCheckIteration=0;
0:     private final AtomicBoolean commandSent=new AtomicBoolean(true);
0:     private final AtomicBoolean inSend=new AtomicBoolean(false);
0: 
0:     private final AtomicBoolean commandReceived=new AtomicBoolean(true);
0:     private final AtomicBoolean inReceive=new AtomicBoolean(false);
0:     public InactivityMonitor(Transport next, long maxInactivityDuration) {
0:         
0:         Scheduler.executePeriodically(this, maxInactivityDuration/2);
/////////////////////////////////////////////////////////////////////////
0:         switch(readCheckIteration) {
0:         case 0:
0:             writeCheck();
0:             readCheckIteration++;
0:             readCheck();
0:             writeCheck();
0:             readCheckIteration=0;
0:         }        
0:     }
0:     
0:     private void writeCheck() {
0:         if( inSend.get() ) {
0:             log.debug("A send is in progress");
0:             return;
0:         if( !commandSent.get() ) {
0:             log.debug("No message sent since last write check, sending a KeepAliveInfo");
0:             try {
0:                 next.oneway(new KeepAliveInfo());
0:             } catch (IOException e) {
0:                 onException(e);
0:             }
0:         } else {
0:             log.debug("Message sent since last write check, resetting flag");
0:         }
0:         
0:         commandSent.set(false);
0:         
0:     }
0: 
0:     private void readCheck() {
0:         if( inReceive.get() ) {
0:             log.debug("A receive is in progress");
0:             return;
0:         }
0:         
0:         if( !commandReceived.get() ) {
0:             log.debug("No message received since last read check!");
0:             onException(new InactivityIOException("Channel was inactive for too long."));           
0:         } else {
0:             log.debug("Message received since last read check, resetting flag");
0:         }
0:         
0:         commandReceived.set(false);
0:     }
0: 
0:     public void onCommand(Command command) {
0:         inReceive.set(true);
0:         try {
0:             commandListener.onCommand(command);
0:         } finally {
0:             inReceive.set(false);
0:             commandReceived.set(true);
0:         }
0:     }
0:     
0:     public void oneway(Command command) throws IOException {
0:         // Disable inactivity monitoring while processing a command.
0:         inSend.set(true);
0:         commandSent.set(true);
0:         try {
0:             next.oneway(command);
0:         } finally {
0:             inSend.set(false);
0:         }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport;
0: 
0: import java.io.IOException;
0: 
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.management.CountStatisticImpl;
0: import org.apache.activemq.thread.Scheduler;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: 
1: /**
0:  * Used to make sure that commands are arriving periodically from the peer of the transport.  
0:  * 
0:  * @version $Revision$
1:  */
0: public class InactivityMonitor extends TransportFilter implements Runnable {
0: 
0:     private final long maxInactivityDuration;
0:     private final AtomicBoolean cancled = new AtomicBoolean(false);
0:     private byte runIteration=0;
0: 
0:     private long lastReadCount;
0:     private long lastWriteCount;
0:     private final CountStatisticImpl readCounter;
0:     private final CountStatisticImpl writeCounter;
0:     
0:     public InactivityMonitor(Transport next, long maxInactivityDuration, CountStatisticImpl readCounter, CountStatisticImpl writeCounter ) {
0:         super(next);
0:         this.maxInactivityDuration = maxInactivityDuration;
0:         this.readCounter = readCounter;
0:         this.writeCounter = writeCounter;
0:     }
0:     
0:     public void start() throws Exception {
0:         next.start();
0:         Scheduler.executePeriodically(this, maxInactivityDuration/5);
0:     }
0:     
0:     public void stop() throws Exception {
0:         if( cancled.compareAndSet(false, true) ) {
0:             Scheduler.cancel(this);
0:         }
0:         next.stop();
0:     }
0:     
0:     public void run() {
0:         
0:         switch(runIteration) {
0:         case 1:
0:         case 2:
0:             long wc = writeCounter.getCount();
0:             if( wc==lastWriteCount ) {
0:                 try {
0:                     oneway(new KeepAliveInfo());
0:                 } catch (IOException e) {
0:                     onException(e);
0:                 }
0:             } else {
0:                 lastWriteCount = wc;
0:             }
0:             break;
0:         case 4:
0:             long rc = readCounter.getCount();
0:             if( rc == lastReadCount ) {
0:                 onException(new InactivityIOException("Channel was inactive for too long."));
0:             } else {
0:                 lastReadCount = rc;
0:             }
0:         }
0:         
0:         runIteration++;
0:         if(runIteration>=5)
0:             runIteration=0;
0:     }
0:     
0:     public void onException(IOException error) {
0:         if( cancled.compareAndSet(false, true) ) {
0:             Scheduler.cancel(this);
0:         }
0:         commandListener.onException(error);
0:     }
0: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:33edc99
/////////////////////////////////////////////////////////////////////////
1:             setWriteCheckTime(writeCheckValueFromReadCheck(readCheckTime));
1:     private long writeCheckValueFromReadCheck(long readCheckTime) {
1:         return readCheckTime>3 ? readCheckTime/3 : readCheckTime;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:                 long writeCheckTime = writeCheckValueFromReadCheck(readCheckTime);
/////////////////////////////////////////////////////////////////////////
1:                 long writeCheckTime = writeCheckValueFromReadCheck(readCheckTime);
commit:55b9954
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("Using min of local: " + localWireFormatInfo + " and remote: " + remoteWireFormatInfo);
0:                 }
0:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("Using local: " + localWireFormatInfo);
0:                 }
commit:1b45e3b
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(this + " "+(now-lastRunTime)+" ms elapsed since last write check.");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(this + " no message sent since last write check, sending a KeepAliveInfo");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(this + " message sent since last write check, resetting flag");
commit:27d0ff4
/////////////////////////////////////////////////////////////////////////
0:                     throw new InactivityIOException("Cannot send, channel has already failed: "+next.getRemoteAddress());
commit:1355cf5
/////////////////////////////////////////////////////////////////////////
0:     private static ThreadPoolExecutor ASYNC_TASKS;
/////////////////////////////////////////////////////////////////////////
0:                     ASYNC_TASKS = createExecutor();
/////////////////////////////////////////////////////////////////////////
0:                     ASYNC_TASKS.shutdownNow();
0:                     ASYNC_TASKS = null;
0:     private ThreadFactory factory = new ThreadFactory() {
0:         public Thread newThread(Runnable runnable) {
0:             Thread thread = new Thread(runnable, "InactivityMonitor Async Task: "+runnable);
0:             thread.setDaemon(true);
0:             return thread;
0:         }
0:     };
0:     private ThreadPoolExecutor createExecutor() {
0:         return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), factory);
commit:ee4c8ee
/////////////////////////////////////////////////////////////////////////
0:     private static long DEFAULT_CHECK_TIME_MILLS = 30000;
/////////////////////////////////////////////////////////////////////////
1:     private boolean ignoreAllWireFormatInfo = false;
0: 
0:     private long readCheckTime = DEFAULT_CHECK_TIME_MILLS;
0:     private long writeCheckTime = DEFAULT_CHECK_TIME_MILLS;
0:     private long initialDelayTime = DEFAULT_CHECK_TIME_MILLS;
/////////////////////////////////////////////////////////////////////////
1:         if (this.wireFormat == null) {
1:             this.ignoreAllWireFormatInfo = true;
0:         }
0:     }
0: 
0:     public void start() throws Exception {
0:         next.start();
0:         startMonitorThreads();
/////////////////////////////////////////////////////////////////////////
0:     public long getReadCheckTime() {
0:         return readCheckTime;
0:     }
0: 
0:     public void setReadCheckTime(long readCheckTime) {
0:         this.readCheckTime = readCheckTime;
0:     }
0: 
0:     public long getInitialDelayTime() {
0:         return initialDelayTime;
0:     }
0: 
0:     public void setInitialDelayTime(long initialDelayTime) {
0:         this.initialDelayTime = initialDelayTime;
0:     }
0:     
0:         if (!configuredOk()) {
0:             return;
/////////////////////////////////////////////////////////////////////////
0:     private boolean configuredOk() throws IOException {
1:         boolean configured = false;
1:         if (ignoreAllWireFormatInfo) {
1:             configured = true;
1:         } else if (localWireFormatInfo != null && remoteWireFormatInfo != null) {
1:             if (!ignoreRemoteWireFormat) {
0:                 readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
0:                 initialDelayTime = Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay());
0:             } else {
0:                 readCheckTime = localWireFormatInfo.getMaxInactivityDuration();
0:                 initialDelayTime = localWireFormatInfo.getMaxInactivityDurationInitalDelay();
0:             }
1:             configured = true;
0:         }
1:         return configured;
0:     }
0: 
commit:dee584b
/////////////////////////////////////////////////////////////////////////
0:     private boolean useKeepAlive = true;
/////////////////////////////////////////////////////////////////////////
0:         if (!commandSent.get() && useKeepAlive) {
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void setUseKeepAlive(boolean val) {
0:         useKeepAlive = val;
0:     }
commit:a593e35
/////////////////////////////////////////////////////////////////////////
0:                     onException(new InactivityIOException("Channel was inactive for too (>" + readCheckTime + ") long: "+next.getRemoteAddress()));
commit:6879442
/////////////////////////////////////////////////////////////////////////
0:     private boolean keepAliveResponseRequired;
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
/////////////////////////////////////////////////////////////////////////
0:                             info.setResponseRequired(keepAliveResponseRequired);
/////////////////////////////////////////////////////////////////////////
0:     }   
0:     
0:     public void setKeepAliveResponseRequired(boolean val) {
0:         keepAliveResponseRequired = val;
0:     }
/////////////////////////////////////////////////////////////////////////
0:             writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d314b7f
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean isIgnoreAllWireFormatInfo() {
1:         return ignoreAllWireFormatInfo;
0:     }
0: 
1:     public void setIgnoreAllWireFormatInfo(boolean ignoreAllWireFormatInfo) {
1:         this.ignoreAllWireFormatInfo = ignoreAllWireFormatInfo;
0:     }
0: 
1:     public boolean isIgnoreRemoteWireFormat() {
1:         return ignoreRemoteWireFormat;
0:     }
0: 
1:     public void setIgnoreRemoteWireFormat(boolean ignoreRemoteWireFormat) {
1:         this.ignoreRemoteWireFormat = ignoreRemoteWireFormat;
0:     }
commit:0885c60
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class InactivityMonitor extends AbstractInactivityMonitor {
1:         super(next, wireFormat);
1:     protected void processInboundWireFormatInfo(WireFormatInfo info) throws IOException {
1:         IOException error = null;
1:         remoteWireFormatInfo = info;
0:         try {
0:             startMonitorThreads();
0:         } catch (IOException e) {
0:             error = e;
0:         }
1:         if (error != null) {
0:             onException(error);
0:         }
0:     }
0: 
1:     protected void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException{
1:         localWireFormatInfo = info;
1:     @Override
1:     protected synchronized void startMonitorThreads() throws IOException {
1:         if (isMonitorStarted()) {
1:         long readCheckTime = getReadCheckTime();
0:             setWriteCheckTime(readCheckTime>3 ? readCheckTime/3 : readCheckTime);
0: 
1:         super.startMonitorThreads();
1:     @Override
1:     protected boolean configuredOk() throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 
1:                 long readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
0:                 long writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;
0: 
1:                 setReadCheckTime(readCheckTime);
1:                 setInitialDelayTime(Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay()));
1:                 setWriteCheckTime(writeCheckTime);
0: 
0: 
1:                 long readCheckTime = localWireFormatInfo.getMaxInactivityDuration();
0:                 long writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;
0: 
1:                 setReadCheckTime(readCheckTime);
1:                 setInitialDelayTime(localWireFormatInfo.getMaxInactivityDurationInitalDelay());
1:                 setWriteCheckTime(writeCheckTime);
0: 
commit:e4dfd57
/////////////////////////////////////////////////////////////////////////
0:                 WRITE_CHECK_TIMER.schedule(writeCheckerTask, initialDelayTime, writeCheckTime);
0:                 READ_CHECK_TIMER.schedule(readCheckerTask, initialDelayTime, readCheckTime);
/////////////////////////////////////////////////////////////////////////
0:                   WRITE_CHECK_TIMER.cancel();
0:                   READ_CHECK_TIMER.cancel();
commit:0bed411
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), factory);
0:         exec.allowCoreThreadTimeOut(true);
0:         return exec;
commit:4d0a8a5
/////////////////////////////////////////////////////////////////////////
0:  *
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:     private boolean ignoreRemoteWireFormat = false;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             // If less than 90% of the read check Time elapsed then abort this readcheck.
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             lastRunTime = now;
/////////////////////////////////////////////////////////////////////////
0:         stopMonitorThreads();
/////////////////////////////////////////////////////////////////////////
0:             ASYNC_TASKS.execute(new Runnable() {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         //further down the transport stack and gets called by more
0: 
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
0:     public void setIgnoreRemoteWireFormat(boolean val) {
0:         ignoreRemoteWireFormat = val;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (!ignoreRemoteWireFormat) {
0:             readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
0:             initialDelayTime = Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay());
0:         } else {
0:             readCheckTime = localWireFormatInfo.getMaxInactivityDuration();
0:             initialDelayTime = localWireFormatInfo.getMaxInactivityDurationInitalDelay();
0:         }
0: 
0:                 if( CHECKER_COUNTER == 0 ) {
0:                     READ_CHECK_TIMER = new Timer("InactivityMonitor ReadCheck",true);
0:                     WRITE_CHECK_TIMER = new Timer("InactivityMonitor WriteCheck",true);
0:                 }
0:                 CHECKER_COUNTER++;
/////////////////////////////////////////////////////////////////////////
0:                 WRITE_CHECK_TIMER.purge();
0:                 READ_CHECK_TIMER.purge();
0:                 CHECKER_COUNTER--;
0:                 if(CHECKER_COUNTER==0) {
0:                     WRITE_CHECK_TIMER.cancel();
0:                     READ_CHECK_TIMER.cancel();
0:                     WRITE_CHECK_TIMER = null;
0:                     READ_CHECK_TIMER = null;
0:                 }
0: 
0: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(InactivityMonitor.class);
commit:15065b7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
0:     private WireFormat wireFormat;
0:     
/////////////////////////////////////////////////////////////////////////
1:     public InactivityMonitor(Transport next, WireFormat wireFormat) {
0:         this.wireFormat = wireFormat;
/////////////////////////////////////////////////////////////////////////
0:         if (inSend.get()) {
/////////////////////////////////////////////////////////////////////////
0:         if (inReceive.get() || wireFormat.inReceive()) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:7a23855
/////////////////////////////////////////////////////////////////////////
0:             	    READ_CHECK_TIMER = new Timer("InactivityMonitor ReadCheck",true);
0:             	    WRITE_CHECK_TIMER = new Timer("InactivityMonitor WriteCheck",true);
commit:aa2c896
/////////////////////////////////////////////////////////////////////////
0:         if (!failed.compareAndSet(false,true)) {
commit:f559236
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean stopped = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:     private long initialDelayTime;
/////////////////////////////////////////////////////////////////////////
0:         closeDown();
/////////////////////////////////////////////////////////////////////////
0:                     if (stopped.get() == false) {
0:                         try {
0: 
0:                             KeepAliveInfo info = new KeepAliveInfo();
0:                             info.setResponseRequired(true);
0:                             oneway(info);
0:                         } catch (IOException e) {
0:                             onException(e);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                 closeDown();
0:                         onException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
/////////////////////////////////////////////////////////////////////////
0:                 
0:                 if( failed.get() ) {
0:                     closeDown();
0:                     throw new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress());
0:                 }
/////////////////////////////////////////////////////////////////////////
0:         closeDown();
0:         if (!failed.getAndSet(true)) {
0:             transportListener.onException(error);
0:         }
0:     	
0: 	private void closeDown() {
0:         stopped.set(true);
0:         if (monitorStarted.get()) {
0:             stopMonitorThreads();
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
0:         initialDelayTime =  Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay());
/////////////////////////////////////////////////////////////////////////
0:                 WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, initialDelayTime,writeCheckTime);
0:                 READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, initialDelayTime,readCheckTime);
commit:dd57e40
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         //synchronize this method - its not synchronized
0:         //further down the transport stack and gets called by more 
0:         //than one thread  by this class
0:         synchronized(inSend) {
0:             inSend.set(true);
0:             try {
0:                 if (o.getClass() == WireFormatInfo.class) {
0:                     synchronized (this) {
0:                         localWireFormatInfo = (WireFormatInfo)o;
0:                         startMonitorThreads();
0:                     }
0:                 if( inactive.get() ) {
0:                     throw new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress());
0:                 }
0:                 next.oneway(o);
0:             } finally {
0:                 commandSent.set(true);
0:                 inSend.set(false);
commit:4032a01
/////////////////////////////////////////////////////////////////////////
0:     private Thread writeThread;
/////////////////////////////////////////////////////////////////////////
0:             ASYNC_TASKS.execute(new Runnable() {  
0:                     Thread t = writeThread;
0:                     if (t != null) {
0:                         t.interrupt();
0:                     }
0:                     onException(new InactivityIOException("Channel was inactive for too long: "+next.getRemoteAddress()));
0:                         
0:                 
/////////////////////////////////////////////////////////////////////////
0:                 writeThread=Thread.currentThread();
0:             writeThread=null;
commit:a36426d
/////////////////////////////////////////////////////////////////////////
0:                         KeepAliveInfo info = new KeepAliveInfo();
0:                         info.setResponseRequired(true);
0:                         oneway(info);
/////////////////////////////////////////////////////////////////////////
0:             if (command.getClass() == KeepAliveInfo.class) {
0:                 KeepAliveInfo info = (KeepAliveInfo) command;
0:                 if (info.isResponseRequired()) {
0:                         info.setResponseRequired(false);
0:                         oneway(info);
0:                         onException(e);
0:             } else {
0:                 if (command.getClass() == WireFormatInfo.class) {
0:                     synchronized (this) {
0:                         IOException error = null;
0:                         remoteWireFormatInfo = (WireFormatInfo) command;
0:                         try {
0:                             startMonitorThreads();
0:                         } catch (IOException e) {
0:                             error = e;
0:                         }
0:                         if (error != null) {
0:                             onException(error);
0:                         }
0:                     }
0:                 }
0:                 synchronized (readChecker) {
0:                     transportListener.onCommand(command);
0:                 }
commit:de14440
/////////////////////////////////////////////////////////////////////////
0: import java.util.Timer;
0: import java.util.concurrent.SynchronousQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
0: import org.apache.activemq.thread.SchedulerTimerTask;
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadPoolExecutor ASYNC_TASKS;
0:     private static final Timer  READ_CHECK_TIMER = new Timer("InactivityMonitor ReadCheck");
0:     private static final Timer  WRITE_CHECK_TIMER = new Timer("InactivityMonitor WriteCheck");
/////////////////////////////////////////////////////////////////////////
0:     private SchedulerTimerTask writeCheckerTask;
0:     private SchedulerTimerTask readCheckerTask;
/////////////////////////////////////////////////////////////////////////
0:               
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(""+(now-lastRunTime)+" ms elapsed since last write check.");
0:                 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("A send is in progress");
0:             }
0:             if(LOG.isTraceEnabled()) {
0:                 LOG.trace("No message sent since last write check, sending a KeepAliveInfo");
0:             }
0:             ASYNC_TASKS.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             });
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Message sent since last write check, resetting flag");
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("A receive is in progress");
0:             }
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:             }
0:            
0:             ASYNC_TASKS.execute(new Runnable() {
0:             });
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Message received since last read check, resetting flag: ");
0:             }
0:         commandReceived.set(true);
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
0:         long checkTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());
0:         if (checkTime > 0) {
0:             writeCheckerTask = new SchedulerTimerTask(writeChecker);
0:             readCheckerTask = new  SchedulerTimerTask(readChecker);
0:             long writeCheckTime = checkTime/3;
0:             WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, writeCheckTime,writeCheckTime);
0:             READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, checkTime,checkTime);
/////////////////////////////////////////////////////////////////////////
0:             readCheckerTask.cancel();
0:             writeCheckerTask.cancel();
0:             WRITE_CHECK_TIMER.purge();
0:             READ_CHECK_TIMER.purge();
0:     
0:        
0:     static {
0:         ASYNC_TASKS =   new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "InactivityMonitor Async Task: "+runnable);
0:                 thread.setDaemon(true);
0:                 return thread;
0:             }
0:         });
0:     }
commit:ddff5e5
/////////////////////////////////////////////////////////////////////////
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     final void writeCheck() {
/////////////////////////////////////////////////////////////////////////
0:     final void readCheck() {
author:James Strachan
-------------------------------------------------------------------------------
commit:a6cb80c
/////////////////////////////////////////////////////////////////////////
0:  * Used to make sure that commands are arriving periodically from the peer of the transport.
0:  *
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         synchronized(writeChecker) {
0:             if( inSend.get() ) {
0:                 log.trace("A send is in progress");
0:                 return;
0: 
0:             if( !commandSent.get() ) {
0:                 log.trace("No message sent since last write check, sending a KeepAliveInfo");
0:                 try {
0:                     next.oneway(new KeepAliveInfo());
0:                 } catch (IOException e) {
0:                     onException(e);
0:                 }
0:             } else {
0:                 log.trace("Message sent since last write check, resetting flag");
0:             }
0: 
0:             commandSent.set(false);
0:         synchronized(readChecker) {
0:             if( inReceive.get() ) {
0:                 log.trace("A receive is in progress");
0:                 return;
0:             }
0: 
0:             if( !commandReceived.get() ) {
0:                 log.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
0:                 onException(new InactivityIOException("Channel was inactive for too long."));
0:             } else {
0:                 log.trace("Message received since last read check, resetting flag: ");
0:             }
0: 
0:             commandReceived.set(false);
0: 
0:         synchronized(readChecker) {
0:             inReceive.set(true);
0:             try {
0:                 if( command.getClass() == WireFormatInfo.class ) {
0:                     synchronized( this ) {
0:                         remoteWireFormatInfo = (WireFormatInfo) command;
0:                         try {
0:                             startMonitorThreads();
0:                         } catch (IOException e) {
0:                             onException(e);
0:                         }
0:                 transportListener.onCommand(command);
0:             } finally {
0:                 inReceive.set(false);
0:                 commandReceived.set(true);
0: 
0:         synchronized(writeChecker) {
0:             // Disable inactivity monitoring while processing a command.
0:             inSend.set(true);
0:             commandSent.set(true);
0:             try {
0:                 if( o.getClass() == WireFormatInfo.class ) {
0:                     synchronized( this ) {
0:                         localWireFormatInfo = (WireFormatInfo) o;
0:                         startMonitorThreads();
0:                     }
0:                 next.oneway(o);
0:             } finally {
0:                 inSend.set(false);
0: 
0: 
0: 
0:         if( monitorStarted.get() )
0: 
0:             monitorStarted.set(true);
0: 
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
commit:d85794c
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:         getTransportListener().onException(error);
commit:436fe42
/////////////////////////////////////////////////////////////////////////
0:             getTransportListener().onCommand(command);
/////////////////////////////////////////////////////////////////////////
0:         getTransportListener().onException(error);
============================================================================