1:64f3492: /**
1:64f3492:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:64f3492:  * contributor license agreements.  See the NOTICE file distributed with
1:64f3492:  * this work for additional information regarding copyright ownership.
1:64f3492:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:64f3492:  * (the "License"); you may not use this file except in compliance with
1:64f3492:  * the License.  You may obtain a copy of the License at
1:64f3492:  *
1:64f3492:  *      http://www.apache.org/licenses/LICENSE-2.0
1:64f3492:  *
1:64f3492:  * Unless required by applicable law or agreed to in writing, software
1:64f3492:  * distributed under the License is distributed on an "AS IS" BASIS,
1:64f3492:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:64f3492:  * See the License for the specific language governing permissions and
1:64f3492:  * limitations under the License.
1:64f3492:  */
1:64f3492: package org.apache.activemq.store.jdbc;
14:64f3492: 
1:64f3492: import java.io.IOException;
1:64f3492: import java.util.ArrayList;
1:64f3492: import java.util.Iterator;
1:efaf9cd: 
1:64f3492: import org.apache.activemq.broker.ConnectionContext;
1:64f3492: import org.apache.activemq.command.ActiveMQDestination;
1:ea70e82: import org.apache.activemq.command.ActiveMQQueue;
1:ea70e82: import org.apache.activemq.command.ActiveMQTopic;
1:64f3492: import org.apache.activemq.command.Message;
1:64f3492: import org.apache.activemq.command.MessageAck;
1:64f3492: import org.apache.activemq.command.MessageId;
1:64f3492: import org.apache.activemq.command.TransactionId;
1:64f3492: import org.apache.activemq.command.XATransactionId;
1:3155c62: import org.apache.activemq.store.IndexListener;
1:64f3492: import org.apache.activemq.store.MessageStore;
1:cfe099d: import org.apache.activemq.store.ProxyMessageStore;
1:64f3492: import org.apache.activemq.store.TopicMessageStore;
1:64f3492: import org.apache.activemq.store.TransactionRecoveryListener;
1:64f3492: import org.apache.activemq.store.memory.MemoryTransactionStore;
1:64f3492: import org.apache.activemq.util.ByteSequence;
1:64f3492: import org.apache.activemq.util.DataByteArrayInputStream;
1:64f3492: 
1:64f3492: /**
1:64f3492:  * respect 2pc prepare
1:64f3492:  * uses local transactions to maintain prepared state
1:64f3492:  * xid column provides transaction flag for additions and removals
1:64f3492:  * a commit clears that context and completes the work
1:64f3492:  * a rollback clears the flag and removes the additions
1:64f3492:  * Essentially a prepare is an insert &| update transaction
1:64f3492:  *  commit|rollback is an update &| remove
1:64f3492:  */
1:64f3492: public class JdbcMemoryTransactionStore extends MemoryTransactionStore {
1:64f3492: 
1:64f3492: 
1:64f3492:     public JdbcMemoryTransactionStore(JDBCPersistenceAdapter jdbcPersistenceAdapter) {
1:64f3492:         super(jdbcPersistenceAdapter);
11:64f3492:     }
1:cfe099d: 
1:cfe099d:     @Override
1:64f3492:     public void prepare(TransactionId txid) throws IOException {
1:64f3492:         Tx tx = inflightTransactions.remove(txid);
1:64f3492:         if (tx == null) {
1:64f3492:             return;
1:cfe099d:         }
1:3155c62: 
1:64f3492:         ConnectionContext ctx = new ConnectionContext();
1:64f3492:         // setting the xid modifies the add/remove to be pending transaction outcome
1:64f3492:         ctx.setXid((XATransactionId) txid);
1:64f3492:         persistenceAdapter.beginTransaction(ctx);
1:64f3492:         try {
1:cfe099d: 
1:64f3492:             // Do all the message adds.
1:64f3492:             for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext();) {
1:64f3492:                 AddMessageCommand cmd = iter.next();
1:64f3492:                 cmd.run(ctx);
1:cfe099d:             }
1:64f3492:             // And removes..
1:64f3492:             for (Iterator<RemoveMessageCommand> iter = tx.acks.iterator(); iter.hasNext();) {
1:64f3492:                 RemoveMessageCommand cmd = iter.next();
1:64f3492:                 cmd.run(ctx);
1:64f3492:             }
1:64f3492: 
1:bd45d93:             persistenceAdapter.commitTransaction(ctx);
1:bd45d93: 
1:64f3492:         } catch ( IOException e ) {
1:64f3492:             persistenceAdapter.rollbackTransaction(ctx);
1:64f3492:             throw e;
1:64f3492:         }
1:64f3492: 
1:64f3492:         ctx.setXid(null);
1:64f3492:         // setup for commit outcome
1:64f3492:         ArrayList<AddMessageCommand> updateFromPreparedStateCommands = new ArrayList<AddMessageCommand>();
1:64f3492:         for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext();) {
1:64f3492:             final AddMessageCommand addMessageCommand = iter.next();
1:3155c62:             updateFromPreparedStateCommands.add(new CommitAddOutcome(addMessageCommand));
1:64f3492:         }
1:64f3492:         tx.messages = updateFromPreparedStateCommands;
1:64f3492:         preparedTransactions.put(txid, tx);
1:64f3492: 
1:64f3492:     }
1:64f3492: 
1:64f3492: 
1:3155c62:     class CommitAddOutcome implements AddMessageCommand {
1:3155c62:         final Message message;
1:3155c62:         JDBCMessageStore jdbcMessageStore;
1:3155c62: 
1:3155c62:         public CommitAddOutcome(JDBCMessageStore jdbcMessageStore, Message message) {
1:3155c62:             this.jdbcMessageStore = jdbcMessageStore;
1:3155c62:             this.message = message;
1:3155c62:         }
1:3155c62: 
1:3155c62:         public CommitAddOutcome(AddMessageCommand addMessageCommand) {
1:3155c62:             this((JDBCMessageStore)addMessageCommand.getMessageStore(), addMessageCommand.getMessage());
1:3155c62:         }
1:3155c62: 
1:3155c62:         @Override
1:3155c62:         public Message getMessage() {
1:3155c62:             return message;
1:3155c62:         }
1:3155c62: 
1:3155c62:         @Override
1:3155c62:         public MessageStore getMessageStore() {
1:3155c62:             return jdbcMessageStore;
1:3155c62:         }
1:3155c62: 
1:3155c62:         @Override
1:3155c62:         public void run(final ConnectionContext context) throws IOException {
1:3155c62:             JDBCPersistenceAdapter jdbcPersistenceAdapter = (JDBCPersistenceAdapter) persistenceAdapter;
1:3155c62:             final Long preparedEntrySequence = (Long) message.getMessageId().getEntryLocator();
1:3155c62:             TransactionContext c = jdbcPersistenceAdapter.getTransactionContext(context);
1:3155c62: 
1:bd45d93:             long newSequence;
1:3155c62:             synchronized (jdbcMessageStore.pendingAdditions) {
1:bd45d93:                 newSequence = jdbcPersistenceAdapter.getNextSequenceId();
1:bd45d93:                 final long sequenceToSet = newSequence;
1:3155c62:                 c.onCompletion(new Runnable() {
1:3155c62:                     @Override
1:3155c62:                     public void run() {
1:bd45d93:                         message.getMessageId().setEntryLocator(sequenceToSet);
1:bd45d93:                         message.getMessageId().setFutureOrSequenceLong(sequenceToSet);
1:3155c62:                     }
1:3155c62:                 });
1:3155c62: 
1:3155c62:                 if (jdbcMessageStore.getIndexListener() != null) {
1:3155c62:                     jdbcMessageStore.getIndexListener().onAdd(new IndexListener.MessageContext(context, message, null));
1:3155c62:                 }
1:3155c62:             }
1:3155c62: 
1:bd45d93:             jdbcPersistenceAdapter.commitAdd(context, message.getMessageId(), preparedEntrySequence, newSequence);
1:3155c62:             jdbcMessageStore.onAdd(message, (Long)message.getMessageId().getEntryLocator(), message.getPriority());
1:3155c62:         }
1:3155c62: 
1:3155c62:         @Override
1:3155c62:         public void setMessageStore(MessageStore messageStore) {
1:3155c62:             jdbcMessageStore = (JDBCMessageStore) messageStore;
1:3155c62:         }
1:3155c62:     }
1:3155c62: 
1:cfe099d:     @Override
1:64f3492:     public void rollback(TransactionId txid) throws IOException {
1:64f3492: 
1:64f3492:         Tx tx = inflightTransactions.remove(txid);
1:64f3492:         if (tx == null) {
1:64f3492:             tx = preparedTransactions.remove(txid);
1:64f3492:             if (tx != null) {
1:64f3492:                 // undo prepare work
1:64f3492:                 ConnectionContext ctx = new ConnectionContext();
1:64f3492:                 persistenceAdapter.beginTransaction(ctx);
1:64f3492:                 try {
1:64f3492: 
1:64f3492:                     for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext(); ) {
1:64f3492:                         final Message message = iter.next().getMessage();
1:64f3492:                         // need to delete the row
1:64f3492:                         ((JDBCPersistenceAdapter) persistenceAdapter).commitRemove(ctx, new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, 1));
1:64f3492:                     }
1:64f3492: 
1:64f3492:                     for (Iterator<RemoveMessageCommand> iter = tx.acks.iterator(); iter.hasNext(); ) {
1:64f3492:                         RemoveMessageCommand removeMessageCommand = iter.next();
1:64f3492:                         if (removeMessageCommand instanceof LastAckCommand ) {
1:64f3492:                             ((LastAckCommand)removeMessageCommand).rollback(ctx);
1:64f3492:                         } else {
1:3155c62:                             MessageId messageId = removeMessageCommand.getMessageAck().getLastMessageId();
1:bd45d93:                             long sequence = (Long)messageId.getEntryLocator();
1:64f3492:                             // need to unset the txid flag on the existing row
1:bd45d93:                             ((JDBCPersistenceAdapter) persistenceAdapter).commitAdd(ctx, messageId, sequence, sequence);
1:efaf9cd: 
1:efaf9cd:                             if (removeMessageCommand instanceof RecoveredRemoveMessageCommand) {
1:efaf9cd:                                 ((JDBCMessageStore) removeMessageCommand.getMessageStore()).trackRollbackAck(((RecoveredRemoveMessageCommand) removeMessageCommand).getMessage());
1:efaf9cd:                             }
1:64f3492:                         }
1:64f3492:                     }
1:64f3492:                 } catch (IOException e) {
1:64f3492:                     persistenceAdapter.rollbackTransaction(ctx);
1:64f3492:                     throw e;
1:64f3492:                 }
2:64f3492:                 persistenceAdapter.commitTransaction(ctx);
1:64f3492:             }
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:cfe099d:     @Override
1:64f3492:     public void recover(TransactionRecoveryListener listener) throws IOException {
1:64f3492:         ((JDBCPersistenceAdapter)persistenceAdapter).recover(this);
1:64f3492:         super.recover(listener);
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void recoverAdd(long id, byte[] messageBytes) throws IOException {
1:64f3492:         final Message message = (Message) ((JDBCPersistenceAdapter)persistenceAdapter).getWireFormat().unmarshal(new ByteSequence(messageBytes));
1:54e2e3b:         message.getMessageId().setFutureOrSequenceLong(id);
1:3155c62:         message.getMessageId().setEntryLocator(id);
1:64f3492:         Tx tx = getPreparedTx(message.getTransactionId());
1:3155c62:         tx.add(new CommitAddOutcome(null, message));
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void recoverAck(long id, byte[] xid, byte[] message) throws IOException {
1:efaf9cd:         final Message msg = (Message) ((JDBCPersistenceAdapter)persistenceAdapter).getWireFormat().unmarshal(new ByteSequence(message));
1:54e2e3b:         msg.getMessageId().setFutureOrSequenceLong(id);
1:3155c62:         msg.getMessageId().setEntryLocator(id);
1:64f3492:         Tx tx = getPreparedTx(new XATransactionId(xid));
1:64f3492:         final MessageAck ack = new MessageAck(msg, MessageAck.STANDARD_ACK_TYPE, 1);
1:efaf9cd:         tx.add(new RecoveredRemoveMessageCommand() {
1:efaf9cd:             MessageStore messageStore = null;
11:64f3492:             @Override
1:64f3492:             public MessageAck getMessageAck() {
1:64f3492:                 return ack;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
3:64f3492:             public void run(ConnectionContext context) throws IOException {
1:64f3492:                 ((JDBCPersistenceAdapter)persistenceAdapter).commitRemove(context, ack);
1:cfe099d:             }
1:cfe099d: 
1:efaf9cd:             public Message getMessage() {
1:efaf9cd:                 return msg;
1:efaf9cd:             }
1:efaf9cd: 
1:efaf9cd:             @Override
1:efaf9cd:             public void setMessageStore(MessageStore messageStore) {
1:efaf9cd:                 this.messageStore = messageStore;
1:efaf9cd:             }
1:efaf9cd: 
1:64f3492:             @Override
3:64f3492:             public MessageStore getMessageStore() {
1:efaf9cd:                 return messageStore;
1:efaf9cd:             }
1:64f3492: 
3:64f3492:         });
1:64f3492:     }
1:64f3492: 
1:efaf9cd:     interface RecoveredRemoveMessageCommand extends RemoveMessageCommand {
1:efaf9cd:         Message getMessage();
1:efaf9cd: 
1:efaf9cd:         void setMessageStore(MessageStore messageStore);
1:64f3492:     }
1:64f3492: 
1:64f3492:     interface LastAckCommand extends RemoveMessageCommand {
1:64f3492:         void rollback(ConnectionContext context) throws IOException;
1:64f3492: 
1:64f3492:         String getClientId();
1:64f3492: 
1:64f3492:         String getSubName();
1:64f3492: 
1:64f3492:         long getSequence();
1:64f3492: 
1:64f3492:         byte getPriority();
1:64f3492: 
1:64f3492:         void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore);
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void recoverLastAck(byte[] encodedXid, final ActiveMQDestination destination, final String subName, final String clientId) throws IOException {
1:64f3492:         Tx tx = getPreparedTx(new XATransactionId(encodedXid));
1:64f3492:         DataByteArrayInputStream inputStream = new DataByteArrayInputStream(encodedXid);
1:64f3492:         inputStream.skipBytes(1); // +|-
1:64f3492:         final long lastAck = inputStream.readLong();
1:64f3492:         final byte priority = inputStream.readByte();
1:64f3492:         final MessageAck ack = new MessageAck();
1:64f3492:         ack.setDestination(destination);
1:64f3492:         tx.add(new LastAckCommand() {
1:64f3492:             JDBCTopicMessageStore jdbcTopicMessageStore;
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public MessageAck getMessageAck() {
1:64f3492:                 return ack;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public MessageStore getMessageStore() {
1:64f3492:                 return jdbcTopicMessageStore;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public void run(ConnectionContext context) throws IOException {
1:64f3492:                 ((JDBCPersistenceAdapter)persistenceAdapter).commitLastAck(context, lastAck, priority, destination, subName, clientId);
1:64f3492:                 jdbcTopicMessageStore.complete(clientId, subName);
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public void rollback(ConnectionContext context) throws IOException {
1:64f3492:                 ((JDBCPersistenceAdapter)persistenceAdapter).rollbackLastAck(context, priority, jdbcTopicMessageStore.getDestination(), subName, clientId);
1:64f3492:                 jdbcTopicMessageStore.complete(clientId, subName);
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public String getClientId() {
1:64f3492:                 return clientId;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public String getSubName() {
1:64f3492:                 return subName;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public long getSequence() {
1:64f3492:                 return lastAck;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public byte getPriority() {
1:64f3492:                 return priority;
1:64f3492:             }
1:64f3492: 
1:64f3492:             @Override
1:64f3492:             public void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore) {
1:64f3492:                 this.jdbcTopicMessageStore = jdbcTopicMessageStore;
1:64f3492:             }
1:64f3492:         });
1:64f3492: 
1:64f3492:     }
1:64f3492: 
1:64f3492:     @Override
1:64f3492:     protected void onRecovered(Tx tx) {
1:64f3492:         for (RemoveMessageCommand removeMessageCommand: tx.acks) {
1:64f3492:             if (removeMessageCommand instanceof LastAckCommand) {
1:64f3492:                 LastAckCommand lastAckCommand = (LastAckCommand) removeMessageCommand;
1:ea70e82:                 JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore) findMessageStore(lastAckCommand.getMessageAck().getDestination());
1:64f3492:                 jdbcTopicMessageStore.pendingCompletion(lastAckCommand.getClientId(), lastAckCommand.getSubName(), lastAckCommand.getSequence(), lastAckCommand.getPriority());
1:64f3492:                 lastAckCommand.setMessageStore(jdbcTopicMessageStore);
1:60624c4:             } else {
1:ea70e82:                 ((RecoveredRemoveMessageCommand)removeMessageCommand).setMessageStore(findMessageStore(removeMessageCommand.getMessageAck().getDestination()));
1:64f3492:             }
1:64f3492:         }
1:cfe099d:         for (AddMessageCommand addMessageCommand : tx.messages) {
1:ea70e82:             addMessageCommand.setMessageStore(findMessageStore(addMessageCommand.getMessage().getDestination()));
1:cfe099d:         }
1:64f3492:     }
1:64f3492: 
1:ea70e82:     private MessageStore findMessageStore(ActiveMQDestination destination) {
1:ea70e82:         ProxyMessageStore proxyMessageStore = null;
1:ea70e82:         try {
1:ea70e82:             if (destination.isQueue()) {
1:ea70e82:                 proxyMessageStore = (ProxyMessageStore) persistenceAdapter.createQueueMessageStore((ActiveMQQueue) destination);
1:ea70e82:             } else {
1:ea70e82:                 proxyMessageStore = (ProxyMessageStore) persistenceAdapter.createTopicMessageStore((ActiveMQTopic) destination);
1:ea70e82:             }
1:ea70e82:         } catch (IOException error) {
1:ea70e82:             throw new RuntimeException("Failed to find/create message store for destination: " + destination, error);
1:ea70e82:         }
1:ea70e82:         return proxyMessageStore.getDelegate();
1:ea70e82:     }
1:ea70e82: 
1:64f3492:     @Override
1:64f3492:     public void acknowledge(final TopicMessageStore topicMessageStore, final String clientId, final String subscriptionName,
1:64f3492:                            final MessageId messageId, final MessageAck ack) throws IOException {
1:64f3492: 
1:64f3492:         if (ack.isInTransaction()) {
1:64f3492:             Tx tx = getTx(ack.getTransactionId());
1:64f3492:             tx.add(new LastAckCommand() {
1:64f3492:                 public MessageAck getMessageAck() {
1:64f3492:                     return ack;
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 public void run(ConnectionContext ctx) throws IOException {
1:64f3492:                     topicMessageStore.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public MessageStore getMessageStore() {
1:64f3492:                     return topicMessageStore;
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public void rollback(ConnectionContext context) throws IOException {
1:64f3492:                     JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore)topicMessageStore;
1:64f3492:                     ((JDBCPersistenceAdapter)persistenceAdapter).rollbackLastAck(context,
1:64f3492:                             jdbcTopicMessageStore,
1:64f3492:                             ack,
1:64f3492:                             subscriptionName, clientId);
1:64f3492:                     jdbcTopicMessageStore.complete(clientId, subscriptionName);
1:64f3492:                 }
1:64f3492: 
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public String getClientId() {
1:64f3492:                     return clientId;
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public String getSubName() {
1:64f3492:                     return subscriptionName;
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public long getSequence() {
1:64f3492:                     throw new IllegalStateException("Sequence id must be inferred from ack");
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public byte getPriority() {
1:64f3492:                     throw new IllegalStateException("Priority must be inferred from ack or row");
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore) {
1:64f3492:                     throw new IllegalStateException("message store already known!");
1:64f3492:                 }
1:64f3492:             });
1:64f3492:         } else {
1:64f3492:             topicMessageStore.acknowledge(null, clientId, subscriptionName, messageId, ack);
1:64f3492:         }
1:64f3492:     }
1:64f3492: 
1:64f3492: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:bd45d93
/////////////////////////////////////////////////////////////////////////
1:             persistenceAdapter.commitTransaction(ctx);
1: 
/////////////////////////////////////////////////////////////////////////
1:             long newSequence;
1:                 newSequence = jdbcPersistenceAdapter.getNextSequenceId();
1:                 final long sequenceToSet = newSequence;
1:                         message.getMessageId().setEntryLocator(sequenceToSet);
1:                         message.getMessageId().setFutureOrSequenceLong(sequenceToSet);
/////////////////////////////////////////////////////////////////////////
1:             jdbcPersistenceAdapter.commitAdd(context, message.getMessageId(), preparedEntrySequence, newSequence);
/////////////////////////////////////////////////////////////////////////
1:                             long sequence = (Long)messageId.getEntryLocator();
1:                             ((JDBCPersistenceAdapter) persistenceAdapter).commitAdd(ctx, messageId, sequence, sequence);
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore) findMessageStore(lastAckCommand.getMessageAck().getDestination());
1:                 ((RecoveredRemoveMessageCommand)removeMessageCommand).setMessageStore(findMessageStore(removeMessageCommand.getMessageAck().getDestination()));
1:             addMessageCommand.setMessageStore(findMessageStore(addMessageCommand.getMessage().getDestination()));
1:     private MessageStore findMessageStore(ActiveMQDestination destination) {
1:         ProxyMessageStore proxyMessageStore = null;
1:         try {
1:             if (destination.isQueue()) {
1:                 proxyMessageStore = (ProxyMessageStore) persistenceAdapter.createQueueMessageStore((ActiveMQQueue) destination);
1:             } else {
1:                 proxyMessageStore = (ProxyMessageStore) persistenceAdapter.createTopicMessageStore((ActiveMQTopic) destination);
1:             }
1:         } catch (IOException error) {
1:             throw new RuntimeException("Failed to find/create message store for destination: " + destination, error);
1:         }
1:         return proxyMessageStore.getDelegate();
1:     }
1: 
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.activemq.broker.Broker;
0: import org.apache.activemq.broker.TransactionBroker;
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.Queue;
0: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transaction.Synchronization;
0: import org.apache.activemq.transaction.Transaction;
/////////////////////////////////////////////////////////////////////////
1: 
1:                             if (removeMessageCommand instanceof RecoveredRemoveMessageCommand) {
1:                                 ((JDBCMessageStore) removeMessageCommand.getMessageStore()).trackRollbackAck(((RecoveredRemoveMessageCommand) removeMessageCommand).getMessage());
1:                             }
/////////////////////////////////////////////////////////////////////////
1:         final Message msg = (Message) ((JDBCPersistenceAdapter)persistenceAdapter).getWireFormat().unmarshal(new ByteSequence(message));
1:         tx.add(new RecoveredRemoveMessageCommand() {
1:             MessageStore messageStore = null;
/////////////////////////////////////////////////////////////////////////
1:             public Message getMessage() {
1:                 return msg;
1:             }
1: 
1:             @Override
1:             public void setMessageStore(MessageStore messageStore) {
1:                 this.messageStore = messageStore;
1:             }
1: 
1:                 return messageStore;
1:     }
1:     interface RecoveredRemoveMessageCommand extends RemoveMessageCommand {
1:         Message getMessage();
1: 
1:         void setMessageStore(MessageStore messageStore);
/////////////////////////////////////////////////////////////////////////
0:                 ((RecoveredRemoveMessageCommand)removeMessageCommand).setMessageStore(queueStores.get(removeMessageCommand.getMessageAck().getDestination()));
commit:3155c62
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
1:             updateFromPreparedStateCommands.add(new CommitAddOutcome(addMessageCommand));
/////////////////////////////////////////////////////////////////////////
1:     class CommitAddOutcome implements AddMessageCommand {
1:         final Message message;
1:         JDBCMessageStore jdbcMessageStore;
1: 
1:         public CommitAddOutcome(JDBCMessageStore jdbcMessageStore, Message message) {
1:             this.jdbcMessageStore = jdbcMessageStore;
1:             this.message = message;
1:         }
1: 
1:         public CommitAddOutcome(AddMessageCommand addMessageCommand) {
1:             this((JDBCMessageStore)addMessageCommand.getMessageStore(), addMessageCommand.getMessage());
1:         }
1: 
1:         @Override
1:         public Message getMessage() {
1:             return message;
1:         }
1: 
1:         @Override
1:         public MessageStore getMessageStore() {
1:             return jdbcMessageStore;
1:         }
1: 
1:         @Override
1:         public void run(final ConnectionContext context) throws IOException {
1:             JDBCPersistenceAdapter jdbcPersistenceAdapter = (JDBCPersistenceAdapter) persistenceAdapter;
1:             final Long preparedEntrySequence = (Long) message.getMessageId().getEntryLocator();
1:             TransactionContext c = jdbcPersistenceAdapter.getTransactionContext(context);
1: 
1:             synchronized (jdbcMessageStore.pendingAdditions) {
0:                 message.getMessageId().setEntryLocator(jdbcPersistenceAdapter.getNextSequenceId());
1: 
1:                 c.onCompletion(new Runnable() {
1:                     @Override
1:                     public void run() {
0:                         message.getMessageId().setFutureOrSequenceLong(message.getMessageId().getEntryLocator());
1:                     }
1:                 });
1: 
1:                 if (jdbcMessageStore.getIndexListener() != null) {
1:                     jdbcMessageStore.getIndexListener().onAdd(new IndexListener.MessageContext(context, message, null));
1:                 }
1:             }
1: 
0:             jdbcPersistenceAdapter.commitAdd(context, message.getMessageId(), preparedEntrySequence);
1:             jdbcMessageStore.onAdd(message, (Long)message.getMessageId().getEntryLocator(), message.getPriority());
1:         }
1: 
1:         @Override
1:         public void setMessageStore(MessageStore messageStore) {
1:             jdbcMessageStore = (JDBCMessageStore) messageStore;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                             MessageId messageId = removeMessageCommand.getMessageAck().getLastMessageId();
0:                             ((JDBCPersistenceAdapter) persistenceAdapter).commitAdd(ctx, messageId, (Long)messageId.getEntryLocator());
/////////////////////////////////////////////////////////////////////////
1:         message.getMessageId().setEntryLocator(id);
1:         tx.add(new CommitAddOutcome(null, message));
1:         msg.getMessageId().setEntryLocator(id);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:                             (Long)message.getMessageId().getFutureOrSequenceLong(),
/////////////////////////////////////////////////////////////////////////
1:         message.getMessageId().setFutureOrSequenceLong(id);
/////////////////////////////////////////////////////////////////////////
0:                 ((JDBCMessageStore)messageStore).onAdd(message, ((Long)message.getMessageId().getFutureOrSequenceLong()).longValue(), message.getPriority());
/////////////////////////////////////////////////////////////////////////
1:         msg.getMessageId().setFutureOrSequenceLong(id);
commit:6348d11
/////////////////////////////////////////////////////////////////////////
0:                             message,
/////////////////////////////////////////////////////////////////////////
0:                 ((JDBCMessageStore)messageStore).onAdd(message, ((Long)message.getMessageId().getEntryLocator()).longValue(), message.getPriority());
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.ProxyMessageStore;
/////////////////////////////////////////////////////////////////////////
0:     private HashMap<ActiveMQDestination, MessageStore> queueStores = new HashMap<ActiveMQDestination, MessageStore>();
/////////////////////////////////////////////////////////////////////////
1: 
1:                 @Override
0:                 public void setMessageStore(MessageStore messageStore) {
0:                     throw new RuntimeException("MessageStore already known");
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             MessageStore messageStore;
/////////////////////////////////////////////////////////////////////////
0:                 return messageStore;
0:                 ((JDBCMessageStore)messageStore).onAdd(message.getMessageId(), ((Long)message.getMessageId().getEntryLocator()).longValue(), message.getPriority());
1:             }
1: 
1:             @Override
0:             public void setMessageStore(MessageStore messageStore) {
0:                 this.messageStore = messageStore;
/////////////////////////////////////////////////////////////////////////
0:     protected void onProxyQueueStore(ProxyMessageStore proxyQueueMessageStore) {
0:         queueStores.put(proxyQueueMessageStore.getDestination(), proxyQueueMessageStore.getDelegate());
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         for (AddMessageCommand addMessageCommand : tx.messages) {
0:             ActiveMQDestination destination = addMessageCommand.getMessage().getDestination();
0:             addMessageCommand.setMessageStore(destination.isQueue() ? queueStores.get(destination) : topicStores.get(destination));
1:         }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:1399cf9
/////////////////////////////////////////////////////////////////////////
0:                             (Long)message.getMessageId().getEntryLocator(),
/////////////////////////////////////////////////////////////////////////
0:         message.getMessageId().setEntryLocator(id);
/////////////////////////////////////////////////////////////////////////
0:         msg.getMessageId().setEntryLocator(id);
commit:c5cf038
author:Gary Tully
-------------------------------------------------------------------------------
commit:60624c4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             } else {
0:                 // when reading the store we ignore messages with non null XIDs but should include those with XIDS starting in - (pending acks in an xa transaction),
0:                 // but the sql is non portable to match BLOB with LIKE etc
0:                 // so we make up for it when we recover the ack
0:                 ((JDBCPersistenceAdapter)persistenceAdapter).getBrokerService().getRegionBroker().getDestinationMap().get(removeMessageCommand.getMessageAck().getDestination()).getDestinationStatistics().getMessages().increment();
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
commit:64f3492
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
1: import java.io.IOException;
0: import java.sql.SQLException;
1: import java.util.ArrayList;
0: import java.util.HashMap;
1: import java.util.Iterator;
0: import java.util.Map;
1: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.Subscription;
0: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.store.MessageStore;
0: import org.apache.activemq.store.ProxyTopicMessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionRecoveryListener;
0: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
1: import org.apache.activemq.store.memory.MemoryTransactionStore;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.util.DataByteArrayInputStream;
0: import org.apache.activemq.util.SubscriptionKey;
1: 
1: /**
1:  * respect 2pc prepare
1:  * uses local transactions to maintain prepared state
1:  * xid column provides transaction flag for additions and removals
1:  * a commit clears that context and completes the work
1:  * a rollback clears the flag and removes the additions
1:  * Essentially a prepare is an insert &| update transaction
1:  *  commit|rollback is an update &| remove
1:  */
1: public class JdbcMemoryTransactionStore extends MemoryTransactionStore {
1: 
1: 
0:     private HashMap<ActiveMQDestination, MessageStore> topicStores = new HashMap<ActiveMQDestination, MessageStore>();
1: 
1:     public JdbcMemoryTransactionStore(JDBCPersistenceAdapter jdbcPersistenceAdapter) {
1:         super(jdbcPersistenceAdapter);
1:     }
1: 
1:     @Override
1:     public void prepare(TransactionId txid) throws IOException {
1:         Tx tx = inflightTransactions.remove(txid);
1:         if (tx == null) {
1:             return;
1:         }
1: 
1:         ConnectionContext ctx = new ConnectionContext();
1:         // setting the xid modifies the add/remove to be pending transaction outcome
1:         ctx.setXid((XATransactionId) txid);
1:         persistenceAdapter.beginTransaction(ctx);
1:         try {
1: 
1:             // Do all the message adds.
1:             for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext();) {
1:                 AddMessageCommand cmd = iter.next();
1:                 cmd.run(ctx);
1:             }
1:             // And removes..
1:             for (Iterator<RemoveMessageCommand> iter = tx.acks.iterator(); iter.hasNext();) {
1:                 RemoveMessageCommand cmd = iter.next();
1:                 cmd.run(ctx);
1:             }
1: 
1:         } catch ( IOException e ) {
1:             persistenceAdapter.rollbackTransaction(ctx);
1:             throw e;
1:         }
1:         persistenceAdapter.commitTransaction(ctx);
1: 
1:         ctx.setXid(null);
1:         // setup for commit outcome
1:         ArrayList<AddMessageCommand> updateFromPreparedStateCommands = new ArrayList<AddMessageCommand>();
1:         for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext();) {
1:             final AddMessageCommand addMessageCommand = iter.next();
0:             updateFromPreparedStateCommands.add(new AddMessageCommand() {
1:                 @Override
0:                 public Message getMessage() {
0:                     return addMessageCommand.getMessage();
1:                 }
1: 
1:                 @Override
1:                 public MessageStore getMessageStore() {
0:                     return addMessageCommand.getMessageStore();
1:                 }
1: 
1:                 @Override
1:                 public void run(ConnectionContext context) throws IOException {
0:                     JDBCPersistenceAdapter jdbcPersistenceAdapter = (JDBCPersistenceAdapter) persistenceAdapter;
0:                     Message message = addMessageCommand.getMessage();
0:                     jdbcPersistenceAdapter.commitAdd(context, message.getMessageId());
0:                     ((JDBCMessageStore)addMessageCommand.getMessageStore()).onAdd(
0:                             message.getMessageId(),
0:                             (Long)message.getMessageId().getDataLocator(),
0:                             message.getPriority());
1: 
1:                 }
1:             });
1:         }
1:         tx.messages = updateFromPreparedStateCommands;
1:         preparedTransactions.put(txid, tx);
1: 
1:     }
1: 
1: 
1:     @Override
1:     public void rollback(TransactionId txid) throws IOException {
1: 
1:         Tx tx = inflightTransactions.remove(txid);
1:         if (tx == null) {
1:             tx = preparedTransactions.remove(txid);
1:             if (tx != null) {
1:                 // undo prepare work
1:                 ConnectionContext ctx = new ConnectionContext();
1:                 persistenceAdapter.beginTransaction(ctx);
1:                 try {
1: 
1:                     for (Iterator<AddMessageCommand> iter = tx.messages.iterator(); iter.hasNext(); ) {
1:                         final Message message = iter.next().getMessage();
1:                         // need to delete the row
1:                         ((JDBCPersistenceAdapter) persistenceAdapter).commitRemove(ctx, new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, 1));
1:                     }
1: 
1:                     for (Iterator<RemoveMessageCommand> iter = tx.acks.iterator(); iter.hasNext(); ) {
1:                         RemoveMessageCommand removeMessageCommand = iter.next();
1:                         if (removeMessageCommand instanceof LastAckCommand ) {
1:                             ((LastAckCommand)removeMessageCommand).rollback(ctx);
1:                         } else {
1:                             // need to unset the txid flag on the existing row
0:                             ((JDBCPersistenceAdapter) persistenceAdapter).commitAdd(ctx,
0:                                     removeMessageCommand.getMessageAck().getLastMessageId());
1:                         }
1:                     }
1:                 } catch (IOException e) {
1:                     persistenceAdapter.rollbackTransaction(ctx);
1:                     throw e;
1:                 }
1:                 persistenceAdapter.commitTransaction(ctx);
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     public void recover(TransactionRecoveryListener listener) throws IOException {
1:         ((JDBCPersistenceAdapter)persistenceAdapter).recover(this);
1:         super.recover(listener);
1:     }
1: 
1:     public void recoverAdd(long id, byte[] messageBytes) throws IOException {
1:         final Message message = (Message) ((JDBCPersistenceAdapter)persistenceAdapter).getWireFormat().unmarshal(new ByteSequence(messageBytes));
0:         message.getMessageId().setDataLocator(id);
1:         Tx tx = getPreparedTx(message.getTransactionId());
0:         tx.add(new AddMessageCommand() {
1:             @Override
0:             public Message getMessage() {
0:                 return message;
1:             }
1: 
1:             @Override
1:             public MessageStore getMessageStore() {
0:                 return null;
1:             }
1: 
1:             @Override
1:             public void run(ConnectionContext context) throws IOException {
0:                 ((JDBCPersistenceAdapter)persistenceAdapter).commitAdd(null, message.getMessageId());
1:             }
1: 
1:         });
1:     }
1: 
1:     public void recoverAck(long id, byte[] xid, byte[] message) throws IOException {
0:         Message msg = (Message) ((JDBCPersistenceAdapter)persistenceAdapter).getWireFormat().unmarshal(new ByteSequence(message));
0:         msg.getMessageId().setDataLocator(id);
1:         Tx tx = getPreparedTx(new XATransactionId(xid));
1:         final MessageAck ack = new MessageAck(msg, MessageAck.STANDARD_ACK_TYPE, 1);
0:         tx.add(new RemoveMessageCommand() {
1:             @Override
1:             public MessageAck getMessageAck() {
1:                 return ack;
1:             }
1: 
1:             @Override
1:             public void run(ConnectionContext context) throws IOException {
1:                 ((JDBCPersistenceAdapter)persistenceAdapter).commitRemove(context, ack);
1:             }
1: 
1:             @Override
1:             public MessageStore getMessageStore() {
0:                 return null;
1:             }
1: 
1:         });
1: 
1:     }
1: 
1:     interface LastAckCommand extends RemoveMessageCommand {
1:         void rollback(ConnectionContext context) throws IOException;
1: 
1:         String getClientId();
1: 
1:         String getSubName();
1: 
1:         long getSequence();
1: 
1:         byte getPriority();
1: 
1:         void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore);
1:     }
1: 
1:     public void recoverLastAck(byte[] encodedXid, final ActiveMQDestination destination, final String subName, final String clientId) throws IOException {
1:         Tx tx = getPreparedTx(new XATransactionId(encodedXid));
1:         DataByteArrayInputStream inputStream = new DataByteArrayInputStream(encodedXid);
1:         inputStream.skipBytes(1); // +|-
1:         final long lastAck = inputStream.readLong();
1:         final byte priority = inputStream.readByte();
1:         final MessageAck ack = new MessageAck();
1:         ack.setDestination(destination);
1:         tx.add(new LastAckCommand() {
1:             JDBCTopicMessageStore jdbcTopicMessageStore;
1: 
1:             @Override
1:             public MessageAck getMessageAck() {
1:                 return ack;
1:             }
1: 
1:             @Override
1:             public MessageStore getMessageStore() {
1:                 return jdbcTopicMessageStore;
1:             }
1: 
1:             @Override
1:             public void run(ConnectionContext context) throws IOException {
1:                 ((JDBCPersistenceAdapter)persistenceAdapter).commitLastAck(context, lastAck, priority, destination, subName, clientId);
1:                 jdbcTopicMessageStore.complete(clientId, subName);
1:             }
1: 
1:             @Override
1:             public void rollback(ConnectionContext context) throws IOException {
1:                 ((JDBCPersistenceAdapter)persistenceAdapter).rollbackLastAck(context, priority, jdbcTopicMessageStore.getDestination(), subName, clientId);
1:                 jdbcTopicMessageStore.complete(clientId, subName);
1:             }
1: 
1:             @Override
1:             public String getClientId() {
1:                 return clientId;
1:             }
1: 
1:             @Override
1:             public String getSubName() {
1:                 return subName;
1:             }
1: 
1:             @Override
1:             public long getSequence() {
1:                 return lastAck;
1:             }
1: 
1:             @Override
1:             public byte getPriority() {
1:                 return priority;
1:             }
1: 
1:             @Override
1:             public void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore) {
1:                 this.jdbcTopicMessageStore = jdbcTopicMessageStore;
1:             }
1:         });
1: 
1:     }
1: 
1:     @Override
0:     protected void onProxyTopicStore(ProxyTopicMessageStore proxyTopicMessageStore) {
0:         topicStores.put(proxyTopicMessageStore.getDestination(), proxyTopicMessageStore.getDelegate());
1:     }
1: 
1:     @Override
1:     protected void onRecovered(Tx tx) {
1:         for (RemoveMessageCommand removeMessageCommand: tx.acks) {
1:             if (removeMessageCommand instanceof LastAckCommand) {
1:                 LastAckCommand lastAckCommand = (LastAckCommand) removeMessageCommand;
0:                 JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore) topicStores.get(lastAckCommand.getMessageAck().getDestination());
1:                 jdbcTopicMessageStore.pendingCompletion(lastAckCommand.getClientId(), lastAckCommand.getSubName(), lastAckCommand.getSequence(), lastAckCommand.getPriority());
1:                 lastAckCommand.setMessageStore(jdbcTopicMessageStore);
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     public void acknowledge(final TopicMessageStore topicMessageStore, final String clientId, final String subscriptionName,
1:                            final MessageId messageId, final MessageAck ack) throws IOException {
1: 
1:         if (ack.isInTransaction()) {
1:             Tx tx = getTx(ack.getTransactionId());
1:             tx.add(new LastAckCommand() {
1:                 public MessageAck getMessageAck() {
1:                     return ack;
1:                 }
1: 
1:                 public void run(ConnectionContext ctx) throws IOException {
1:                     topicMessageStore.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:                 }
1: 
1:                 @Override
1:                 public MessageStore getMessageStore() {
1:                     return topicMessageStore;
1:                 }
1: 
1:                 @Override
1:                 public void rollback(ConnectionContext context) throws IOException {
1:                     JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore)topicMessageStore;
1:                     ((JDBCPersistenceAdapter)persistenceAdapter).rollbackLastAck(context,
1:                             jdbcTopicMessageStore,
1:                             ack,
1:                             subscriptionName, clientId);
1:                     jdbcTopicMessageStore.complete(clientId, subscriptionName);
1: 
0:                     Map<ActiveMQDestination, Destination> destinations = ((JDBCPersistenceAdapter) persistenceAdapter).getBrokerService().getRegionBroker().getDestinationMap();
0:                     Topic topic = (Topic) destinations.get(topicMessageStore.getDestination());
0:                     SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:                     topic.getDurableTopicSubs().get(key).getPending().rollback(ack.getLastMessageId());
0:                     topic.clearPendingMessages(key);
1:                 }
1: 
1: 
1:                 @Override
1:                 public String getClientId() {
1:                     return clientId;
1:                 }
1: 
1:                 @Override
1:                 public String getSubName() {
1:                     return subscriptionName;
1:                 }
1: 
1:                 @Override
1:                 public long getSequence() {
1:                     throw new IllegalStateException("Sequence id must be inferred from ack");
1:                 }
1: 
1:                 @Override
1:                 public byte getPriority() {
1:                     throw new IllegalStateException("Priority must be inferred from ack or row");
1:                 }
1: 
1:                 @Override
1:                 public void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore) {
1:                     throw new IllegalStateException("message store already known!");
1:                 }
1:             });
1:         } else {
1:             topicMessageStore.acknowledge(null, clientId, subscriptionName, messageId, ack);
1:         }
1:     }
1: 
1: }
============================================================================