1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:c1ebbc1:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:c1ebbc1:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:8023b9e: 
1:2b1cda1: import static org.apache.activemq.broker.region.cursors.AbstractStoreCursor.gotToTheStore;
1:25f112c: import static org.apache.activemq.transaction.Transaction.IN_USE_STATE;
1:2769298: 
1:c459784: import java.io.IOException;
1:f7cbe9f: import java.util.ArrayList;
1:f7cbe9f: import java.util.Collection;
1:f7cbe9f: import java.util.Collections;
1:f7cbe9f: import java.util.Comparator;
1:f7cbe9f: import java.util.HashSet;
1:f7cbe9f: import java.util.Iterator;
1:f7cbe9f: import java.util.LinkedHashMap;
1:f7cbe9f: import java.util.LinkedHashSet;
1:f7cbe9f: import java.util.LinkedList;
1:f7cbe9f: import java.util.List;
1:f7cbe9f: import java.util.Map;
1:f7cbe9f: import java.util.Set;
1:ea84378: import java.util.concurrent.CancellationException;
1:f24b4f7: import java.util.concurrent.ConcurrentLinkedQueue;
1:c459784: import java.util.concurrent.CountDownLatch;
1:83128fc: import java.util.concurrent.DelayQueue;
1:83128fc: import java.util.concurrent.Delayed;
1:c459784: import java.util.concurrent.ExecutorService;
1:c459784: import java.util.concurrent.TimeUnit;
1:cdb38b3: import java.util.concurrent.atomic.AtomicBoolean;
1:a0ba0bf: import java.util.concurrent.atomic.AtomicInteger;
1:c808beb: import java.util.concurrent.atomic.AtomicLong;
1:fb591e7: import java.util.concurrent.locks.Lock;
1:f81d0d5: import java.util.concurrent.locks.ReentrantLock;
1:28180b3: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:27262c8: 
1:c459784: import javax.jms.InvalidSelectorException;
1:c459784: import javax.jms.JMSException;
1:83128fc: import javax.jms.ResourceAllocationException;
1:f7cbe9f: 
1:13829ef: import org.apache.activemq.broker.BrokerService;
1:15412ba: import org.apache.activemq.broker.BrokerStoppedException;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:4569d7d: import org.apache.activemq.broker.ProducerBrokerExchange;
1:078a101: import org.apache.activemq.broker.region.cursors.OrderedPendingList;
1:078a101: import org.apache.activemq.broker.region.cursors.PendingList;
1:078a101: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1:078a101: import org.apache.activemq.broker.region.cursors.PrioritizedPendingList;
1:078a101: import org.apache.activemq.broker.region.cursors.QueueDispatchPendingList;
1:078a101: import org.apache.activemq.broker.region.cursors.StoreQueueCursor;
1:078a101: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
1:468e697: import org.apache.activemq.broker.region.group.CachedMessageGroupMapFactory;
1:e1d4780: import org.apache.activemq.broker.region.group.MessageGroupMap;
1:e7e15b5: import org.apache.activemq.broker.region.group.MessageGroupMapFactory;
1:97502bd: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.DispatchPolicy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy;
1:383a7ac: import org.apache.activemq.broker.util.InsertionCountList;
1:f7cbe9f: import org.apache.activemq.command.ActiveMQDestination;
1:ea70e82: import org.apache.activemq.command.ActiveMQMessage;
1:f7cbe9f: import org.apache.activemq.command.ConsumerId;
1:f7cbe9f: import org.apache.activemq.command.ExceptionResponse;
1:f7cbe9f: import org.apache.activemq.command.Message;
1:f7cbe9f: import org.apache.activemq.command.MessageAck;
1:f7cbe9f: import org.apache.activemq.command.MessageDispatchNotification;
1:f7cbe9f: import org.apache.activemq.command.MessageId;
1:f7cbe9f: import org.apache.activemq.command.ProducerAck;
1:f7cbe9f: import org.apache.activemq.command.ProducerInfo;
1:eb6c082: import org.apache.activemq.command.RemoveInfo;
1:f7cbe9f: import org.apache.activemq.command.Response;
1:9479de7: import org.apache.activemq.filter.BooleanExpression;
1:d29ca2a: import org.apache.activemq.filter.MessageEvaluationContext;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:9479de7: import org.apache.activemq.selector.SelectorParser;
1:179d95e: import org.apache.activemq.state.ProducerState;
1:54e2e3b: import org.apache.activemq.store.IndexListener;
1:ad1f751: import org.apache.activemq.store.ListenableFuture;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:d29ca2a: import org.apache.activemq.store.MessageStore;
1:6895d00: import org.apache.activemq.thread.Task;
1:6895d00: import org.apache.activemq.thread.TaskRunner;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:08aecbe: import org.apache.activemq.usage.Usage;
1:08aecbe: import org.apache.activemq.usage.UsageListener;
1:ed5d43b: import org.apache.activemq.util.BrokerSupport;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2b456dd: import org.slf4j.MDC;
1:2b1cda1: 
1:d29ca2a: /**
1:d29ca2a:  * The Queue is a List of MessageEntry objects that are dispatched to matching
1:d29ca2a:  * subscriptions.
1:d29ca2a:  */
1:54e2e3b: public class Queue extends BaseDestination implements Task, UsageListener, IndexListener {
1:8bf987b:     protected static final Logger LOG = LoggerFactory.getLogger(Queue.class);
1:c808beb:     protected final TaskRunnerFactory taskFactory;
1:cd54a16:     protected TaskRunner taskRunner;
1:28180b3:     private final ReentrantReadWriteLock consumersLock = new ReentrantReadWriteLock();
1:cd54a16:     protected final List<Subscription> consumers = new ArrayList<Subscription>(50);
1:28180b3:     private final ReentrantReadWriteLock messagesLock = new ReentrantReadWriteLock();
1:cd54a16:     protected PendingMessageCursor messages;
1:28180b3:     private final ReentrantReadWriteLock pagedInMessagesLock = new ReentrantReadWriteLock();
1:e947927:     private final PendingList pagedInMessages = new OrderedPendingList();
1:e2cafda:     // Messages that are paged in but have not yet been targeted at a subscription
1:28180b3:     private final ReentrantReadWriteLock pagedInPendingDispatchLock = new ReentrantReadWriteLock();
1:efc9a8d:     protected QueueDispatchPendingList dispatchPendingList = new QueueDispatchPendingList();
1:a0ba0bf:     private AtomicInteger pendingSends = new AtomicInteger(0);
1:d7f9146:     private MessageGroupMap messageGroupOwners;
1:d29ca2a:     private DispatchPolicy dispatchPolicy = new RoundRobinDispatchPolicy();
1:468e697:     private MessageGroupMapFactory messageGroupMapFactory = new CachedMessageGroupMapFactory();
1:ddb2c91:     final Lock sendLock = new ReentrantLock();
1:cd54a16:     private ExecutorService executor;
1:a1d5ff0:     private final Map<MessageId, Runnable> messagesWaitingForSpace = new LinkedHashMap<MessageId, Runnable>();
1:48764be:     private boolean useConsumerPriority = true;
1:48764be:     private boolean strictOrderDispatch = false;
1:ea84378:     private final QueueDispatchSelector dispatchSelector;
1:48764be:     private boolean optimizedDispatch = false;
1:a1d5ff0:     private boolean iterationRunning = false;
1:a321204:     private boolean firstConsumer = false;
1:a321204:     private int timeBeforeDispatchStarts = 0;
1:a321204:     private int consumersBeforeDispatchStarts = 0;
1:a321204:     private CountDownLatch consumersBeforeStartsLatch;
1:ea84378:     private final AtomicLong pendingWakeups = new AtomicLong();
1:42ee51f:     private boolean allConsumersExclusiveByDefault = false;
1:dcedd9f: 
1:8031d77:     private volatile boolean resetNeeded;
1:27262c8: 
1:ecf89a6:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
1:ea84378:         @Override
1:ecf89a6:         public void run() {
1:c808beb:             asyncWakeup();
1:df3bd83:         }
1:ecf89a6:     };
1:cdb38b3:     private final AtomicBoolean expiryTaskInProgress = new AtomicBoolean(false);
1:cdb38b3:     private final Runnable expireMessagesWork = new Runnable() {
1:511b60c:         @Override
1:cdc2fd3:         public void run() {
1:c6a485f:             expireMessages();
1:cdb38b3:             expiryTaskInProgress.set(false);
1:cdb38b3:         }
1:cdb38b3:     };
1:cdb38b3: 
1:cdb38b3:     private final Runnable expireMessagesTask = new Runnable() {
1:cdb38b3:         @Override
1:cdb38b3:         public void run() {
1:cdb38b3:             if (expiryTaskInProgress.compareAndSet(false, true)) {
1:cdb38b3:                 taskFactory.execute(expireMessagesWork);
1:cdb38b3:             }
1:60ad053:         }
1:27262c8:     };
1:511b60c: 
1:cb1b92b:     private final Object iteratingMutex = new Object();
1:85b9c81: 
1:a0ba0bf:     // gate on enabling cursor cache to ensure no outstanding sync
1:a0ba0bf:     // send before async sends resume
1:a0ba0bf:     public boolean singlePendingSend() {
1:a0ba0bf:         return pendingSends.get() <= 1;
1:a0ba0bf:     }
1:85b9c81: 
1:83128fc:     class TimeoutMessage implements Delayed {
1:511b60c: 
1:83128fc:         Message message;
1:83128fc:         ConnectionContext context;
1:83128fc:         long trigger;
1:511b60c: 
1:83128fc:         public TimeoutMessage(Message message, ConnectionContext context, long delay) {
1:66e8011:             this.message = message;
1:66e8011:             this.context = context;
1:83128fc:             this.trigger = System.currentTimeMillis() + delay;
1:52e1a05:         }
1:511b60c: 
1:511b60c:         @Override
1:83128fc:         public long getDelay(TimeUnit unit) {
1:83128fc:             long n = trigger - System.currentTimeMillis();
1:83128fc:             return unit.convert(n, TimeUnit.MILLISECONDS);
1:511b60c:         }
1:28180b3: 
1:511b60c:         @Override
1:83128fc:         public int compareTo(Delayed delayed) {
1:27262c8:             long other = ((TimeoutMessage) delayed).trigger;
1:83128fc:             int returnValue;
1:83128fc:             if (this.trigger < other) {
1:27262c8:                 returnValue = -1;
1:83128fc:             } else if (this.trigger > other) {
1:27262c8:                 returnValue = 1;
1:78492fe:             } else {
1:27262c8:                 returnValue = 0;
1:511b60c:             }
1:83128fc:             return returnValue;
1:511b60c:         }
1:511b60c:     }
1:27262c8: 
1:83128fc:     DelayQueue<TimeoutMessage> flowControlTimeoutMessages = new DelayQueue<TimeoutMessage>();
1:27262c8: 
1:83128fc:     class FlowControlTimeoutTask extends Thread {
1:27262c8: 
1:511b60c:         @Override
2:230a86c:         public void run() {
1:83128fc:             TimeoutMessage timeout;
1:28180b3:             try {
1:83128fc:                 while (true) {
1:83128fc:                     timeout = flowControlTimeoutMessages.take();
1:83128fc:                     if (timeout != null) {
1:230a86c:                         synchronized (messagesWaitingForSpace) {
1:83128fc:                             if (messagesWaitingForSpace.remove(timeout.message.getMessageId()) != null) {
1:27262c8:                                 ExceptionResponse response = new ExceptionResponse(
1:27262c8:                                         new ResourceAllocationException(
1:8e576be:                                                 "Usage Manager Memory Limit Wait Timeout. Stopping producer ("
1:27262c8:                                                         + timeout.message.getProducerId()
1:27262c8:                                                         + ") to prevent flooding "
1:27262c8:                                                         + getActiveMQDestination().getQualifiedName()
1:27262c8:                                                         + "."
1:27262c8:                                                         + " See http://activemq.apache.org/producer-flow-control.html for more info"));
1:83128fc:                                 response.setCorrelationId(timeout.message.getCommandId());
1:83128fc:                                 timeout.context.getConnection().dispatchAsync(response);
1:75990ef:                             }
1:75990ef:                         }
1:75990ef:                     }
1:78492fe:                 }
1:cce7566:             } catch (InterruptedException e) {
1:e1bbde7:                 LOG.debug(getName() + "Producer Flow Control Timeout Task is stopping");
1:2769298:             }
1:78492fe:         }
1:28180b3:     }
1:27262c8: 
1:83128fc:     private final FlowControlTimeoutTask flowControlTimeoutTask = new FlowControlTimeoutTask();
1:27262c8: 
1:0a7c5dc:     private final Comparator<Subscription> orderedCompare = new Comparator<Subscription>() {
1:27262c8: 
1:75990ef:         @Override
1:2a153b0:         public int compare(Subscription s1, Subscription s2) {
1:27262c8:             // We want the list sorted in descending order
1:0a7c5dc:             int val = s2.getConsumerInfo().getPriority() - s1.getConsumerInfo().getPriority();
1:0a7c5dc:             if (val == 0 && messageGroupOwners != null) {
1:0a7c5dc:                 // then ascending order of assigned message groups to favour less loaded consumers
1:0a7c5dc:                 // Long.compare in jdk7
1:5d697cf:                 long x = s1.getConsumerInfo().getAssignedGroupCount(destination);
1:5d697cf:                 long y = s2.getConsumerInfo().getAssignedGroupCount(destination);
1:0a7c5dc:                 val = (x < y) ? -1 : ((x == y) ? 0 : 1);
1:c459784:             }
1:0a7c5dc:             return val;
1:c459784:         }
1:ecf89a6:     };
1:27262c8: 
1:27262c8:     public Queue(BrokerService brokerService, final ActiveMQDestination destination, MessageStore store,
1:27262c8:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
1:13829ef:         super(brokerService, store, destination, parentStats);
1:48764be:         this.taskFactory = taskFactory;
1:48764be:         this.dispatchSelector = new QueueDispatchSelector(destination);
1:54e2e3b:         if (store != null) {
1:54e2e3b:             store.registerIndexListener(this);
1:54e2e3b:         }
1:c459784:     }
1:27262c8: 
1:ea84378:     @Override
1:947659c:     public List<Subscription> getConsumers() {
1:28180b3:         consumersLock.readLock().lock();
1:75990ef:         try {
1:947659c:             return new ArrayList<Subscription>(consumers);
1:e947927:         } finally {
1:28180b3:             consumersLock.readLock().unlock();
1:c459784:         }
1:63b2c40:     }
1:27262c8: 
1:27262c8:     // make the queue easily visible in the debugger from its task runner
1:27262c8:     // threads
1:08aecbe:     final class QueueThread extends Thread {
1:08aecbe:         final Queue queue;
1:27262c8: 
1:48764be:         public QueueThread(Runnable runnable, String name, Queue queue) {
1:08aecbe:             super(runnable, name);
1:08aecbe:             this.queue = queue;
1:47cfa55:         }
1:47cfa55:     }
1:27262c8: 
1:41cdadb:     class BatchMessageRecoveryListener implements MessageRecoveryListener {
1:41cdadb:         final LinkedList<Message> toExpire = new LinkedList<Message>();
1:41cdadb:         final double totalMessageCount;
1:41cdadb:         int recoveredAccumulator = 0;
1:41cdadb:         int currentBatchCount;
1:27262c8: 
1:41cdadb:         BatchMessageRecoveryListener(int totalMessageCount) {
1:41cdadb:             this.totalMessageCount = totalMessageCount;
1:41cdadb:             currentBatchCount = recoveredAccumulator;
1:47cfa55:         }
1:27262c8: 
1:ea84378:         @Override
1:230a86c:         public boolean recoverMessage(Message message) {
1:41cdadb:             recoveredAccumulator++;
1:e1bbde7:             if ((recoveredAccumulator % 10000) == 0) {
1:e1bbde7:                 LOG.info("cursor for {} has recovered {} messages. {}% complete", new Object[]{ getActiveMQDestination().getQualifiedName(), recoveredAccumulator, new Integer((int) (recoveredAccumulator * 100 / totalMessageCount))});
1:e2cafda:             }
1:230a86c:             // Message could have expired while it was being
1:230a86c:             // loaded..
1:93092f7:             message.setRegionDestination(Queue.this);
1:41cdadb:             if (message.isExpired() && broker.isExpired(message)) {
1:41cdadb:                 toExpire.add(message);
1:3a5f48d:                 return true;
1:e2cafda:             }
1:230a86c:             if (hasSpace()) {
1:28180b3:                 messagesLock.writeLock().lock();
1:dcedd9f:                 try {
1:28180b3:                     try {
1:3a5f48d:                         messages.addMessageLast(message);
1:2a328ed:                     } catch (Exception e) {
1:41cdadb:                         LOG.error("Failed to add message to cursor", e);
1:e2cafda:                     }
1:e2cafda:                 } finally {
1:28180b3:                     messagesLock.writeLock().unlock();
1:e2cafda:                 }
1:3a5f48d:                 destinationStatistics.getMessages().increment();
1:3a5f48d:                 return true;
1:e2cafda:             }
1:24fea93:             return false;
1:e2cafda:         }
1:b29ccf3: 
1:540b1c6:         @Override
1:230a86c:         public boolean recoverMessageReference(MessageId messageReference) throws Exception {
1:6895d00:             throw new RuntimeException("Should not be called.");
1:3f4d4a5:         }
1:27262c8: 
1:540b1c6:         @Override
1:230a86c:         public boolean hasSpace() {
1:3bf0245:             return true;
1:0d85869:         }
1:27262c8: 
1:540b1c6:         @Override
1:41cdadb:         public boolean isDuplicate(MessageId id) {
1:3a5f48d:             return false;
1:0f1ef01:         }
1:e8a7451: 
1:41cdadb:         public void reset() {
1:41cdadb:             currentBatchCount = recoveredAccumulator;
1:0f1ef01:         }
1:e2cafda: 
1:41cdadb:         public void processExpired() {
1:41cdadb:             for (Message message: toExpire) {
1:41cdadb:                 messageExpired(createConnectionContext(), createMessageReference(message));
1:27262c8:                 // drop message will decrement so counter
1:27262c8:                 // balance here
1:6895d00:                 destinationStatistics.getMessages().increment();
1:2e137fb:             }
1:28180b3:             toExpire.clear();
1:3f9d6e2:         }
1:3f4d4a5: 
1:41cdadb:         public boolean done() {
1:41cdadb:             return currentBatchCount == recoveredAccumulator;
1:f4ca650:         }
1:cd54a16:     }
1:0d85869: 
1:540b1c6:     @Override
1:cb1b92b:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:cb1b92b:         super.setPrioritizedMessages(prioritizedMessages);
1:efc9a8d:         dispatchPendingList.setPrioritizedMessages(prioritizedMessages);
1:d4382e4:     }
1:0d85869: 
1:540b1c6:     @Override
1:cd54a16:     public void initialize() throws Exception {
1:cdc2fd3: 
1:cd54a16:         if (this.messages == null) {
1:cd54a16:             if (destination.isTemporary() || broker == null || store == null) {
1:00879cf:                 this.messages = new VMPendingMessageCursor(isPrioritizedMessages());
1:dcedd9f:             } else {
1:cd54a16:                 this.messages = new StoreQueueCursor(broker, this);
1:cd54a16:             }
1:8d11f07:         }
1:2e137fb: 
1:27262c8:         // If a VMPendingMessageCursor don't use the default Producer System
1:27262c8:         // Usage
1:27262c8:         // since it turns into a shared blocking queue which can lead to a
1:27262c8:         // network deadlock.
1:27262c8:         // If we are cursoring to disk..it's not and issue because it does not
1:27262c8:         // block due
1:cd54a16:         // to large disk sizes.
1:c808beb:         if (messages instanceof VMPendingMessageCursor) {
1:cd54a16:             this.systemUsage = brokerService.getSystemUsage();
1:cd54a16:             memoryUsage.setParent(systemUsage.getMemoryUsage());
1:3f9d6e2:         }
1:18f9773: 
1:48764be:         this.taskRunner = taskFactory.createTaskRunner(this, "Queue:" + destination.getPhysicalName());
1:18f9773: 
1:13829ef:         super.initialize();
1:cc47ab6:         if (store != null) {
1:d29ca2a:             // Restore the persistent messages.
1:6d8e2c5:             messages.setSystemUsage(systemUsage);
1:1ee0017:             messages.setEnableAudit(isEnableAudit());
1:1ee0017:             messages.setMaxAuditDepth(getMaxAuditDepth());
1:1ee0017:             messages.setMaxProducersToAudit(getMaxProducersToAudit());
1:6d0c552:             messages.setUseCache(isUseCache());
1:785454a:             messages.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:785b16b:             store.start();
1:41cdadb:             final int messageCount = store.getMessageCount();
1:8d2c079:             if (messageCount > 0 && messages.isRecoveryRequired()) {
1:41cdadb:                 BatchMessageRecoveryListener listener = new BatchMessageRecoveryListener(messageCount);
1:8d11f07:                 do {
1:41cdadb:                    listener.reset();
1:41cdadb:                    store.recoverNextMessages(getMaxPageSize(), listener);
1:41cdadb:                    listener.processExpired();
1:41cdadb:                } while (!listener.done());
1:cc6213e:             } else {
1:ab28b77:                 destinationStatistics.getMessages().add(messageCount);
1:cd54a16:             }
1:8d11f07:         }
1:2db7df7:     }
1:18f9773: 
1:9216c18:     /*
1:27262c8:      * Holder for subscription that needs attention on next iterate browser
1:27262c8:      * needs access to existing messages in the queue that have already been
1:27262c8:      * dispatched
1:d4382e4:      */
1:9216c18:     class BrowserDispatch {
1:9216c18:         QueueBrowserSubscription browser;
1:18f9773: 
1:fde4721:         public BrowserDispatch(QueueBrowserSubscription browserSubscription) {
1:9216c18:             browser = browserSubscription;
1:9216c18:             browser.incrementQueueRef();
1:2db7df7:         }
1:044c07d: 
1:9216c18:         public QueueBrowserSubscription getBrowser() {
1:9216c18:             return browser;
1:2db7df7:         }
1:2db7df7:     }
1:3f9d6e2: 
1:f24b4f7:     ConcurrentLinkedQueue<BrowserDispatch> browserDispatches = new ConcurrentLinkedQueue<BrowserDispatch>();
1:3f9d6e2: 
1:540b1c6:     @Override
1:f81d0d5:     public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {
1:60ad053:         LOG.debug("{} add sub: {}, dequeues: {}, dispatched: {}, inflight: {}", new Object[]{ getActiveMQDestination().getQualifiedName(), sub, getDestinationStatistics().getDequeues().getCount(), getDestinationStatistics().getDispatched().getCount(), getDestinationStatistics().getInflight().getCount() });
1:f4ca650: 
1:2705e36:         super.addSubscription(context, sub);
1:f81d0d5:         // synchronize with dispatch method so that no new messages are sent
1:ba16efd:         // while setting up a subscription. avoid out of order messages,
1:ba16efd:         // duplicates, etc.
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:cc6213e:         try {
1:c459784: 
1:f81d0d5:             sub.add(context, this);
1:2705e36: 
1:f81d0d5:             // needs to be synchronized - so no contention with dispatching
1:28180b3:             // consumersLock.
1:28180b3:             consumersLock.writeLock().lock();
1:cc6213e:             try {
1:a321204:                 // set a flag if this is a first consumer
1:a321204:                 if (consumers.size() == 0) {
1:a321204:                     firstConsumer = true;
1:51f68fb:                     if (consumersBeforeDispatchStarts != 0) {
1:51f68fb:                         consumersBeforeStartsLatch = new CountDownLatch(consumersBeforeDispatchStarts - 1);
1:f81d0d5:                     }
1:47cfa55:                 } else {
1:51f68fb:                     if (consumersBeforeStartsLatch != null) {
1:51f68fb:                         consumersBeforeStartsLatch.countDown();
1:2db7df7:                     }
1:2db7df7:                 }
1:cd54a16: 
1:2a153b0:                 addToConsumerList(sub);
1:42ee51f:                 if (sub.getConsumerInfo().isExclusive() || isAllConsumersExclusiveByDefault()) {
1:d4382e4:                     Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();
1:48764be:                     if (exclusiveConsumer == null) {
1:48764be:                         exclusiveConsumer = sub;
1:0de4f88:                     } else if (sub.getConsumerInfo().getPriority() == Byte.MAX_VALUE ||
1:0de4f88:                         sub.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority()) {
1:48764be:                         exclusiveConsumer = sub;
1:2db7df7:                     }
1:d4382e4:                     dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
1:2db7df7:                 }
1:e2cafda:             } finally {
1:28180b3:                 consumersLock.writeLock().unlock();
1:2db7df7:             }
1:cd54a16: 
1:915333e:             if (sub instanceof QueueBrowserSubscription) {
1:fde4721:                 // tee up for dispatch in next iterate
1:9216c18:                 QueueBrowserSubscription browserSubscription = (QueueBrowserSubscription) sub;
1:f24b4f7:                 BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription);
1:f24b4f7:                 browserDispatches.add(browserDispatch);
1:2db7df7:             }
1:cd54a16: 
1:c8bd57c:             if (!this.optimizedDispatch) {
1:c8bd57c:                 wakeup();
1:c8bd57c:             }
1:c50b8e4:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:c8bd57c:         }
1:c8bd57c:         if (this.optimizedDispatch) {
1:c8bd57c:             // Outside of dispatchLock() to maintain the lock hierarchy of
1:27262c8:             // iteratingMutex -> dispatchLock. - see
1:27262c8:             // https://issues.apache.org/activemq/browse/AMQ-1878
1:c8bd57c:             wakeup();
1:2a153b0:         }
1:071b4b1:     }
1:27262c8: 
1:540b1c6:     @Override
1:eb6c082:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId)
1:27262c8:             throws Exception {
1:eb6c082:         super.removeSubscription(context, sub, lastDeliveredSequenceId);
1:d4382e4:         // synchronize with dispatch method so that no new messages are sent
1:ba16efd:         // while removing up a subscription.
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:28180b3:         try {
1:60ad053:             LOG.debug("{} remove sub: {}, lastDeliveredSeqId: {}, dequeues: {}, dispatched: {}, inflight: {}, groups: {}", new Object[]{
1:e1bbde7:                     getActiveMQDestination().getQualifiedName(),
1:e1bbde7:                     sub,
1:eb6c082:                     lastDeliveredSequenceId,
1:e1bbde7:                     getDestinationStatistics().getDequeues().getCount(),
1:e1bbde7:                     getDestinationStatistics().getDispatched().getCount(),
1:60ad053:                     getDestinationStatistics().getInflight().getCount(),
1:5d697cf:                     sub.getConsumerInfo().getAssignedGroupCount(destination)
1:75990ef:             });
1:28180b3:             consumersLock.writeLock().lock();
1:28180b3:             try {
1:2a153b0:                 removeFromConsumerList(sub);
1:d4382e4:                 if (sub.getConsumerInfo().isExclusive()) {
1:48764be:                     Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();
1:d4382e4:                     if (exclusiveConsumer == sub) {
1:d4382e4:                         exclusiveConsumer = null;
1:2e137fb:                         for (Subscription s : consumers) {
1:27262c8:                             if (s.getConsumerInfo().isExclusive()
1:27262c8:                                     && (exclusiveConsumer == null || s.getConsumerInfo().getPriority() > exclusiveConsumer
1:27262c8:                                             .getConsumerInfo().getPriority())) {
1:d4382e4:                                 exclusiveConsumer = s;
1:27262c8: 
1:d4382e4:                             }
1:d4382e4:                         }
1:d4382e4:                         dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
1:d4382e4:                     }
1:42ee51f:                 } else if (isAllConsumersExclusiveByDefault()) {
1:42ee51f:                     Subscription exclusiveConsumer = null;
1:42ee51f:                     for (Subscription s : consumers) {
1:42ee51f:                         if (exclusiveConsumer == null
1:42ee51f:                                 || s.getConsumerInfo().getPriority() > exclusiveConsumer
1:42ee51f:                                 .getConsumerInfo().getPriority()) {
1:42ee51f:                             exclusiveConsumer = s;
1:42ee51f:                                 }
1:42ee51f:                     }
1:42ee51f:                     dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
1:d4382e4:                 }
1:d4382e4:                 ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();
1:184761a:                 getMessageGroupOwners().removeConsumer(consumerId);
1:3f9d6e2: 
1:d4382e4:                 // redeliver inflight messages
1:27262c8: 
1:7343337:                 boolean markAsRedelivered = false;
1:7343337:                 MessageReference lastDeliveredRef = null;
1:7343337:                 List<MessageReference> unAckedMessages = sub.remove(context, this);
1:cd54a16: 
1:7343337:                 // locate last redelivered in unconsumed list (list in delivery rather than seq order)
1:eb6c082:                 if (lastDeliveredSequenceId > RemoveInfo.LAST_DELIVERED_UNSET) {
2:7343337:                     for (MessageReference ref : unAckedMessages) {
1:eb6c082:                         if (ref.getMessageId().getBrokerSequenceId() == lastDeliveredSequenceId) {
1:7343337:                             lastDeliveredRef = ref;
1:7343337:                             markAsRedelivered = true;
1:eb6c082:                             LOG.debug("found lastDeliveredSeqID: {}, message reference: {}", lastDeliveredSequenceId, ref.getMessageId());
1:e2cafda:                             break;
1:d4382e4:                         }
1:d4382e4:                     }
1:2db7df7:                 }
1:2a153b0: 
1:f47b370:                 for (Iterator<MessageReference> unackedListIterator = unAckedMessages.iterator(); unackedListIterator.hasNext(); ) {
1:f47b370:                     MessageReference ref = unackedListIterator.next();
1:29f34f4:                     // AMQ-5107: don't resend if the broker is shutting down
1:29f34f4:                     if ( this.brokerService.isStopping() ) {
1:29f34f4:                         break;
1:29f34f4:                     }
1:48764be:                     QueueMessageReference qmr = (QueueMessageReference) ref;
1:48764be:                     if (qmr.getLockOwner() == sub) {
1:ae7de6c:                         qmr.unlock();
1:2a153b0: 
1:27262c8:                         // have no delivery information
1:eb6c082:                         if (lastDeliveredSequenceId == RemoveInfo.LAST_DELIVERED_UNKNOWN) {
1:ae7de6c:                             qmr.incrementRedeliveryCounter();
1:2e137fb:                         } else {
1:7343337:                             if (markAsRedelivered) {
1:ae7de6c:                                 qmr.incrementRedeliveryCounter();
1:2db7df7:                             }
1:7343337:                             if (ref == lastDeliveredRef) {
1:7343337:                                 // all that follow were not redelivered
1:7343337:                                 markAsRedelivered = false;
1:2db7df7:                             }
1:4d01443:                         }
1:4d01443:                     }
1:f47b370:                     if (qmr.isDropped()) {
1:f47b370:                         unackedListIterator.remove();
1:4d01443:                     }
1:4d01443:                 }
1:f47b370:                 dispatchPendingList.addForRedelivery(unAckedMessages, strictOrderDispatch && consumers.isEmpty());
1:48764be:                 if (sub instanceof QueueBrowserSubscription) {
1:915333e:                     ((QueueBrowserSubscription)sub).decrementQueueRef();
1:915333e:                     browserDispatches.remove(sub);
1:4d01443:                 }
1:29f34f4:                 // AMQ-5107: don't resend if the broker is shutting down
1:efc9a8d:                 if (dispatchPendingList.hasRedeliveries() && (! this.brokerService.isStopping())) {
1:cb1b92b:                     doDispatch(new OrderedPendingList());
1:4d01443:                 }
1:c50b8e4:             } finally {
1:28180b3:                 consumersLock.writeLock().unlock();
1:4d01443:             }
1:c8bd57c:             if (!this.optimizedDispatch) {
1:f405a7e:                 wakeup();
1:4d01443:             }
1:c50b8e4:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:4d01443:         }
1:c8bd57c:         if (this.optimizedDispatch) {
1:f405a7e:             // Outside of dispatchLock() to maintain the lock hierarchy of
1:27262c8:             // iteratingMutex -> dispatchLock. - see
1:27262c8:             // https://issues.apache.org/activemq/browse/AMQ-1878
1:d4382e4:             wakeup();
1:4d01443:         }
1:4d01443:     }
1:8768a04: 
1:6da08b2:     private volatile ResourceAllocationException sendMemAllocationException = null;
1:540b1c6:     @Override
1:230a86c:     public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {
1:230a86c:         final ConnectionContext context = producerExchange.getConnectionContext();
1:d2e6062:         // There is delay between the client sending it and it arriving at the
1:d2e6062:         // destination.. it may have expired.
1:23cda2d:         message.setRegionDestination(this);
1:179d95e:         ProducerState state = producerExchange.getProducerState();
1:179d95e:         if (state == null) {
1:e1bbde7:             LOG.warn("Send failed for: {}, missing producer state for: {}", message, producerExchange);
1:179d95e:             throw new JMSException("Cannot send message to " + getActiveMQDestination() + " with invalid (null) producer state");
1:2db7df7:         }
1:3d024d6:         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
1:27262c8:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0
1:27262c8:                 && !context.isInRecoveryMode();
2:230a86c:         if (message.isExpired()) {
1:27262c8:             // message not stored - or added to stats yet - so chuck here
1:27c1719:             broker.getRoot().messageExpired(context, message, null);
2:230a86c:             if (sendProducerAck) {
1:cdc2fd3:                 ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
2:230a86c:                 context.getConnection().dispatchAsync(ack);
1:14c605f:             }
1:d2e6062:             return;
1:14c605f:         }
1:48764be:         if (memoryUsage.isFull()) {
1:cdc2fd3:             isFull(context, memoryUsage);
1:cdc2fd3:             fastProducer(context, producerInfo);
1:cdc2fd3:             if (isProducerFlowControl() && context.isProducerFlowControl()) {
1:01b1f7f:                 if (isFlowControlLogRequired()) {
1:0608175:                     LOG.warn("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:01b1f7f:                                 memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
1:0608175:                 } else {
1:0608175:                     LOG.debug("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:0608175:                             memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
1:01b1f7f:                 }
1:8ce0778:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
1:6da08b2:                     ResourceAllocationException resourceAllocationException = sendMemAllocationException;
1:6da08b2:                     if (resourceAllocationException == null) {
1:6da08b2:                         synchronized (this) {
1:6da08b2:                             resourceAllocationException = sendMemAllocationException;
1:6da08b2:                             if (resourceAllocationException == null) {
1:6da08b2:                                 sendMemAllocationException = resourceAllocationException = new ResourceAllocationException("Usage Manager Memory Limit reached on "
1:6da08b2:                                         + getActiveMQDestination().getQualifiedName() + "."
1:6da08b2:                                         + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:6da08b2:                             }
1:6da08b2:                         }
1:6da08b2:                     }
1:6da08b2:                     throw resourceAllocationException;
1:cdc2fd3:                 }
1:cdc2fd3: 
1:27262c8:                 // We can avoid blocking due to low usage if the producer is
1:27262c8:                 // sending
1:97e0fcc:                 // a sync message or if it is using a producer window
1:cdc2fd3:                 if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
1:27262c8:                     // copy the exchange state since the context will be
1:27262c8:                     // modified while we are waiting
1:a24133e:                     // for space.
1:a24133e:                     final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();
1:cdc2fd3:                     synchronized (messagesWaitingForSpace) {
1:89e538d:                      // Start flow control timeout task
1:89e538d:                         // Prevent trying to start it multiple times
1:89e538d:                         if (!flowControlTimeoutTask.isAlive()) {
1:89e538d:                             flowControlTimeoutTask.setName(getName()+" Producer Flow Control Timeout Task");
1:89e538d:                             flowControlTimeoutTask.start();
1:89e538d:                         }
1:83128fc:                         messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {
1:540b1c6:                             @Override
1:75990ef:                             public void run() {
1:27262c8: 
1:28180b3:                                 try {
1:cdc2fd3:                                     // While waiting for space to free up... the
1:25f112c:                                     // transaction may be done
1:25f112c:                                     if (message.isInTransaction()) {
1:25f112c:                                         if (context.getTransaction().getState() > IN_USE_STATE) {
1:25f112c:                                             throw new JMSException("Send transaction completed while waiting for space");
1:25f112c:                                         }
1:25f112c:                                     }
1:25f112c: 
1:25f112c:                                     // the message may have expired.
1:0d85869:                                     if (message.isExpired()) {
1:25f112c:                                         LOG.error("message expired waiting for space");
1:27c1719:                                         broker.messageExpired(context, message, null);
1:66e8011:                                         destinationStatistics.getExpired().increment();
1:cdc2fd3:                                     } else {
1:a24133e:                                         doMessageSend(producerExchangeCopy, message);
1:cdc2fd3:                                     }
1:cdc2fd3: 
1:cdc2fd3:                                     if (sendProducerAck) {
1:27262c8:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message
1:27262c8:                                                 .getSize());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(ack);
1:cdc2fd3:                                     } else {
1:cdc2fd3:                                         Response response = new Response();
1:cdc2fd3:                                         response.setCorrelationId(message.getCommandId());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(response);
1:cdc2fd3:                                     }
1:cdc2fd3: 
1:cdc2fd3:                                 } catch (Exception e) {
1:34f3329:                                     if (!sendProducerAck && !context.isInRecoveryMode() && !brokerService.isStopping()) {
1:cdc2fd3:                                         ExceptionResponse response = new ExceptionResponse(e);
1:cdc2fd3:                                         response.setCorrelationId(message.getCommandId());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(response);
1:cd54a16:                                     } else {
1:e1bbde7:                                         LOG.debug("unexpected exception on deferred send of: {}", message, e);
1:cdc2fd3:                                     }
1:e67d486:                                 } finally {
1:e67d486:                                     getDestinationStatistics().getBlockedSends().decrement();
1:e67d486:                                     producerExchangeCopy.blockingOnFlowControl(false);
1:d2e6062:                                 }
1:d2e6062:                             }
1:e1bbde7:                         });
1:cdc2fd3: 
1:e67d486:                         getDestinationStatistics().getBlockedSends().increment();
1:e67d486:                         producerExchange.blockingOnFlowControl(true);
1:8ce0778:                         if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
1:27262c8:                             flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage
1:27262c8:                                     .getSendFailIfNoSpaceAfterTimeout()));
1:d2e6062:                         }
1:cdc2fd3: 
1:97e0fcc:                         registerCallbackForNotFullNotification();
1:cdc2fd3:                         context.setDontSendReponse(true);
1:cdc2fd3:                         return;
1:d2e6062:                     }
1:d4382e4: 
1:cdc2fd3:                 } else {
1:d4382e4: 
1:48764be:                     if (memoryUsage.isFull()) {
1:0736953:                         waitForSpace(context, producerExchange, memoryUsage, "Usage Manager Memory Limit reached. Producer ("
1:27262c8:                                 + message.getProducerId() + ") stopped to prevent flooding "
1:27262c8:                                 + getActiveMQDestination().getQualifiedName() + "."
2:27262c8:                                 + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:d2e6062:                     }
1:d4382e4: 
1:cdc2fd3:                     // The usage manager could have delayed us by the time
1:cdc2fd3:                     // we unblock the message could have expired..
1:cdc2fd3:                     if (message.isExpired()) {
1:e1bbde7:                         LOG.debug("Expired message: {}", message);
1:27c1719:                         broker.getRoot().messageExpired(context, message, null);
1:cdc2fd3:                         return;
1:d2e6062:                     }
1:d2e6062:                 }
1:d2e6062:             }
1:d2e6062:         }
1:cdc2fd3:         doMessageSend(producerExchange, message);
1:230a86c:         if (sendProducerAck) {
1:3d024d6:             ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:230a86c:             context.getConnection().dispatchAsync(ack);
1:d2e6062:         }
1:3bf0245:     }
1:d4382e4: 
1:97e0fcc:     private void registerCallbackForNotFullNotification() {
1:97e0fcc:         // If the usage manager is not full, then the task will not
1:cdc2fd3:         // get called..
1:cdc2fd3:         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
1:cdc2fd3:             // so call it directly here.
1:cdc2fd3:             sendMessagesWaitingForSpaceTask.run();
1:cdc2fd3:         }
1:e006780:     }
1:cdc2fd3: 
1:54e2e3b:     private final LinkedList<MessageContext> indexOrderedCursorUpdates = new LinkedList<>();
1:cdc2fd3: 
1:54e2e3b:     @Override
1:54e2e3b:     public void onAdd(MessageContext messageContext) {
1:f96a20e:         synchronized (indexOrderedCursorUpdates) {
1:54e2e3b:             indexOrderedCursorUpdates.addLast(messageContext);
1:54e2e3b:         }
1:54e2e3b:     }
1:cdc2fd3: 
1:dd2572b:     public void rollbackPendingCursorAdditions(MessageId messageId) {
1:54e2e3b:         synchronized (indexOrderedCursorUpdates) {
1:f96a20e:             for (int i = indexOrderedCursorUpdates.size() - 1; i >= 0; i--) {
1:f96a20e:                 MessageContext mc = indexOrderedCursorUpdates.get(i);
1:dd2572b:                 if (mc.message.getMessageId().equals(messageId)) {
1:f96a20e:                     indexOrderedCursorUpdates.remove(mc);
1:f96a20e:                     if (mc.onCompletion != null) {
1:f96a20e:                         mc.onCompletion.run();
1:f96a20e:                     }
1:f96a20e:                     break;
1:f96a20e:                 }
1:f96a20e:             }
1:f96a20e:         }
1:f96a20e:     }
1:f96a20e: 
1:54e2e3b:     private void doPendingCursorAdditions() throws Exception {
1:54e2e3b:         LinkedList<MessageContext> orderedUpdates = new LinkedList<>();
1:54e2e3b:         sendLock.lockInterruptibly();
1:54e2e3b:         try {
1:54e2e3b:             synchronized (indexOrderedCursorUpdates) {
1:54e2e3b:                 MessageContext candidate = indexOrderedCursorUpdates.peek();
1:54e2e3b:                 while (candidate != null && candidate.message.getMessageId().getFutureOrSequenceLong() != null) {
1:54e2e3b:                     candidate = indexOrderedCursorUpdates.removeFirst();
1:54e2e3b:                     // check for duplicate adds suppressed by the store
1:54e2e3b:                     if (candidate.message.getMessageId().getFutureOrSequenceLong() instanceof Long && ((Long)candidate.message.getMessageId().getFutureOrSequenceLong()).compareTo(-1l) == 0) {
1:54e2e3b:                         LOG.warn("{} messageStore indicated duplicate add attempt for {}, suppressing duplicate dispatch", this, candidate.message.getMessageId());
1:54e2e3b:                     } else {
1:54e2e3b:                         orderedUpdates.add(candidate);
1:54e2e3b:                     }
1:54e2e3b:                     candidate = indexOrderedCursorUpdates.peek();
1:54e2e3b:                 }
1:54e2e3b:             }
1:9c2b1d2:             messagesLock.writeLock().lock();
1:9c2b1d2:             try {
1:9c2b1d2:                 for (MessageContext messageContext : orderedUpdates) {
1:9c2b1d2:                     if (!messages.addMessageLast(messageContext.message)) {
1:9c2b1d2:                         // cursor suppressed a duplicate
1:9c2b1d2:                         messageContext.duplicate = true;
1:9c2b1d2:                     }
1:9c2b1d2:                     if (messageContext.onCompletion != null) {
1:9c2b1d2:                         messageContext.onCompletion.run();
1:9c2b1d2:                     }
1:54e2e3b:                 }
1:9c2b1d2:             } finally {
1:9c2b1d2:                 messagesLock.writeLock().unlock();
1:54e2e3b:             }
1:54e2e3b:         } finally {
1:54e2e3b:             sendLock.unlock();
1:54e2e3b:         }
2:54e2e3b:         for (MessageContext messageContext : orderedUpdates) {
1:5861d86:             if (!messageContext.duplicate) {
1:5861d86:                 messageSent(messageContext.context, messageContext.message);
1:5861d86:             }
1:54e2e3b:         }
1:54e2e3b:         orderedUpdates.clear();
1:54e2e3b:     }
1:d4382e4: 
1:54e2e3b:     final class CursorAddSync extends Synchronization {
1:d4382e4: 
1:54e2e3b:         private final MessageContext messageContext;
1:d4382e4: 
1:54e2e3b:         CursorAddSync(MessageContext messageContext) {
1:54e2e3b:             this.messageContext = messageContext;
1:8a37f97:             this.messageContext.message.incrementReferenceCount();
1:dcedd9f:         }
1:d4382e4: 
1:540b1c6:         @Override
1:00fb444:         public void afterCommit() throws Exception {
1:54e2e3b:             if (store != null && messageContext.message.isPersistent()) {
1:54e2e3b:                 doPendingCursorAdditions();
1:54e2e3b:             } else {
1:54e2e3b:                 cursorAdd(messageContext.message);
1:54e2e3b:                 messageSent(messageContext.context, messageContext.message);
1:511b60c:             }
1:54e2e3b:             messageContext.message.decrementReferenceCount();
1:dcedd9f:         }
1:d4382e4: 
1:540b1c6:         @Override
1:00fb444:         public void afterRollback() throws Exception {
1:f96a20e:             if (store != null && messageContext.message.isPersistent()) {
1:dd2572b:                 rollbackPendingCursorAdditions(messageContext.message.getMessageId());
1:f96a20e:             }
1:54e2e3b:             messageContext.message.decrementReferenceCount();
1:3b28c7c:         }
1:3b28c7c:     }
1:d4382e4: 
1:27262c8:     void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,
1:27262c8:             Exception {
1:230a86c:         final ConnectionContext context = producerExchange.getConnectionContext();
1:ad1f751:         ListenableFuture<Object> result = null;
1:071b4b1: 
1:0736953:         producerExchange.incrementSend();
1:a0ba0bf:         pendingSends.incrementAndGet();
1:cc6213e:         do {
1:cc6213e:             checkUsage(context, producerExchange, message);
1:499e39e:             message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
1:499e39e:             if (store != null && message.isPersistent()) {
1:499e39e:                 message.getMessageId().setFutureOrSequenceLong(null);
1:499e39e:                 try {
1:b2327db:                     //AMQ-6133 - don't store async if using persistJMSRedelivered
1:b2327db:                     //This flag causes a sync update later on dispatch which can cause a race
1:b2327db:                     //condition if the original add is processed after the update, which can cause
1:b2327db:                     //a duplicate message to be stored
1:b2327db:                     if (messages.isCacheEnabled() && !isPersistJMSRedelivered()) {
1:499e39e:                         result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
1:499e39e:                         result.addListener(new PendingMarshalUsageTracker(message));
1:499e39e:                     } else {
1:499e39e:                         store.addMessage(context, message);
1:499e39e:                     }
1:499e39e:                 } catch (Exception e) {
1:499e39e:                     // we may have a store in inconsistent state, so reset the cursor
1:499e39e:                     // before restarting normal broker operations
1:499e39e:                     resetNeeded = true;
1:a0ba0bf:                     pendingSends.decrementAndGet();
1:dd2572b:                     rollbackPendingCursorAdditions(message.getMessageId());
1:499e39e:                     throw e;
1:499e39e:                 }
1:9c8bd33:             }
1:7c3bb40: 
1:7c3bb40:             //Clear the unmarshalled state if the message is marshalled
1:7c3bb40:             //Persistent messages will always be marshalled but non-persistent may not be
1:7c3bb40:             //Specially non-persistent messages over the VM transport won't be
1:7c3bb40:             if (isReduceMemoryFootprint() && message.isMarshalled()) {
1:7c3bb40:                 message.clearUnMarshalledState();
1:7c3bb40:             }
1:499e39e:             if(tryOrderedCursorAdd(message, context)) {
1:499e39e:                 break;
1:75990ef:             }
1:cc6213e:         } while (started.get());
1:cc6213e: 
1:ad1f751:         if (result != null && message.isResponseRequired() && !result.isCancelled()) {
1:511b60c:             try {
1:27262c8:                 result.get();
1:27262c8:             } catch (CancellationException e) {
1:27262c8:                 // ignore - the task has been cancelled if the message
1:27262c8:                 // has already been deleted
1:cc6213e:             }
1:cc6213e:         }
1:cc6213e:     }
1:071b4b1: 
1:cc6213e:     private boolean tryOrderedCursorAdd(Message message, ConnectionContext context) throws Exception {
1:cc6213e:         boolean result = true;
1:cc6213e: 
1:54e2e3b:         if (context.isInTransaction()) {
1:54e2e3b:             context.getTransaction().addSynchronization(new CursorAddSync(new MessageContext(context, message, null)));
1:54e2e3b:         } else if (store != null && message.isPersistent()) {
1:54e2e3b:             doPendingCursorAdditions();
1:54e2e3b:         } else {
1:54e2e3b:             // no ordering issue with non persistent messages
1:cc6213e:             result = tryCursorAdd(message);
1:903dec6:             messageSent(context, message);
1:54e2e3b:         }
1:54e2e3b: 
1:cc6213e:         return result;
1:54e2e3b:     }
1:cc6213e: 
1:0736953:     private void checkUsage(ConnectionContext context,ProducerBrokerExchange producerBrokerExchange, Message message) throws ResourceAllocationException, IOException, InterruptedException {
1:fb591e7:         if (message.isPersistent()) {
1:fb591e7:             if (store != null && systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {
1:2b10259:                 final String logMessage = "Persistent store is Full, " + getStoreUsageHighWaterMark() + "% of "
1:27262c8:                     + systemUsage.getStoreUsage().getLimit() + ". Stopping producer ("
1:27262c8:                     + message.getProducerId() + ") to prevent flooding "
1:27262c8:                     + getActiveMQDestination().getQualifiedName() + "."
1:fb591e7:                     + " See http://activemq.apache.org/producer-flow-control.html for more info";
1:d4382e4: 
1:0736953:                 waitForSpace(context, producerBrokerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
1:ea84378:             }
1:fb591e7:         } else if (messages.getSystemUsage() != null && systemUsage.getTempUsage().isFull()) {
1:2b10259:             final String logMessage = "Temp Store is Full ("
1:c1ebbc1:                     + systemUsage.getTempUsage().getPercentUsage() + "% of " + systemUsage.getTempUsage().getLimit()
1:04b2690:                     +"). Stopping producer (" + message.getProducerId()
1:27262c8:                 + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:fb591e7:                 + " See http://activemq.apache.org/producer-flow-control.html for more info";
1:d4382e4: 
1:0736953:             waitForSpace(context, producerBrokerExchange, messages.getSystemUsage().getTempUsage(), logMessage);
1:ea84378:         }
1:ea84378:     }
1:071b4b1: 
1:c6a485f:     private void expireMessages() {
1:e1bbde7:         LOG.debug("{} expiring messages ..", getActiveMQDestination().getQualifiedName());
1:cce7566: 
1:c6a485f:         // just track the insertion count
1:383a7ac:         List<Message> browsedMessages = new InsertionCountList<Message>();
1:3536b1e:         doBrowse(browsedMessages, this.getMaxExpirePageSize());
1:c808beb:         asyncWakeup();
1:e1bbde7:         LOG.debug("{} expiring messages done.", getActiveMQDestination().getQualifiedName());
1:90c8ded:     }
1:cce7566: 
1:540b1c6:     @Override
1:d29ca2a:     public void gc() {
1:90c8ded:     }
1:8d11f07: 
1:540b1c6:     @Override
1:27262c8:     public void acknowledge(ConnectionContext context, Subscription sub, MessageAck ack, MessageReference node)
1:27262c8:             throws IOException {
1:cdc2fd3:         messageConsumed(context, node);
1:d29ca2a:         if (store != null && node.isPersistent()) {
1:b07f31e:             store.removeAsyncMessage(context, convertToNonRangedAck(ack, node));
1:3b28c7c:         }
1:6895d00:     }
1:8d11f07: 
1:bfaff9b:     Message loadMessage(MessageId messageId) throws IOException {
1:def2a34:         Message msg = null;
1:def2a34:         if (store != null) { // can be null for a temp q
1:def2a34:             msg = store.getMessage(messageId);
1:e6f5d30:             if (msg != null) {
1:d29ca2a:                 msg.setRegionDestination(this);
1:6895d00:             }
1:6895d00:         }
1:d29ca2a:         return msg;
1:6895d00:     }
1:8d11f07: 
1:734fb7d:     public long getPendingMessageSize() {
1:4165972:         messagesLock.readLock().lock();
1:734fb7d:         try{
1:734fb7d:             return messages.messageSize();
1:511b60c:         } finally {
1:4165972:             messagesLock.readLock().unlock();
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     public long getPendingMessageCount() {
1:734fb7d:          return this.destinationStatistics.getMessages().getCount();
1:734fb7d:     }
1:734fb7d: 
1:ea84378:     @Override
1:d29ca2a:     public String toString() {
1:b9045db:         return destination.getQualifiedName() + ", subscriptions=" + consumers.size()
1:13c2072:                 + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + destinationStatistics.getMessages().getCount() + ", pending="
1:33089f3:                 + indexOrderedCursorUpdates.size();
1:044c07d:     }
1:d4382e4: 
1:540b1c6:     @Override
1:d29ca2a:     public void start() throws Exception {
1:f7cbe9f:         if (started.compareAndSet(false, true)) {
1:f7cbe9f:             if (memoryUsage != null) {
1:f7cbe9f:                 memoryUsage.start();
1:f7cbe9f:             }
1:f7cbe9f:             if (systemUsage.getStoreUsage() != null) {
1:f7cbe9f:                 systemUsage.getStoreUsage().start();
1:f7cbe9f:             }
1:f7cbe9f:             systemUsage.getMemoryUsage().addUsageListener(this);
1:f7cbe9f:             messages.start();
1:f7cbe9f:             if (getExpireMessagesPeriod() > 0) {
1:f7cbe9f:                 scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
1:f7cbe9f:             }
1:f7cbe9f:             doPageIn(false);
1:3a5f48d:         }
1:6895d00:     }
1:2db7df7: 
1:540b1c6:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:f7cbe9f:         if (started.compareAndSet(true, false)) {
1:f7cbe9f:             if (taskRunner != null) {
1:f7cbe9f:                 taskRunner.shutdown();
1:f7cbe9f:             }
1:f7cbe9f:             if (this.executor != null) {
1:6c1676b:                 ThreadPoolUtils.shutdownNow(executor);
1:6c1676b:                 executor = null;
1:f7cbe9f:             }
1:2db7df7: 
1:f7cbe9f:             scheduler.cancel(expireMessagesTask);
1:27262c8: 
1:f7cbe9f:             if (flowControlTimeoutTask.isAlive()) {
1:f7cbe9f:                 flowControlTimeoutTask.interrupt();
1:f7cbe9f:             }
1:2db7df7: 
1:f7cbe9f:             if (messages != null) {
1:f7cbe9f:                 messages.stop();
1:f7cbe9f:             }
1:2db7df7: 
1:a64976a:             for (MessageReference messageReference : pagedInMessages.values()) {
1:a64976a:                 messageReference.decrementReferenceCount();
1:a64976a:             }
1:a64976a:             pagedInMessages.clear();
1:a64976a: 
1:f7cbe9f:             systemUsage.getMemoryUsage().removeUsageListener(this);
1:f7cbe9f:             if (memoryUsage != null) {
1:f7cbe9f:                 memoryUsage.stop();
1:f7cbe9f:             }
1:35bd3ad:             if (systemUsage.getStoreUsage() != null) {
1:35bd3ad:                 systemUsage.getStoreUsage().stop();
1:35bd3ad:             }
1:f7cbe9f:             if (store != null) {
1:f7cbe9f:                 store.stop();
1:f7cbe9f:             }
1:f7cbe9f:         }
1:63e3f41:     }
1:2db7df7: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:ea84378:     @Override
1:d29ca2a:     public ActiveMQDestination getActiveMQDestination() {
1:d29ca2a:         return destination;
1:d4382e4:     }
1:8d11f07: 
1:e1d4780:     public MessageGroupMap getMessageGroupOwners() {
1:d7f9146:         if (messageGroupOwners == null) {
1:e7e15b5:             messageGroupOwners = getMessageGroupMapFactory().createMessageGroupMap();
1:d25c52c:             messageGroupOwners.setDestination(this);
1:d2e6062:         }
1:d29ca2a:         return messageGroupOwners;
1:6895d00:     }
1:2db7df7: 
1:d29ca2a:     public DispatchPolicy getDispatchPolicy() {
1:d29ca2a:         return dispatchPolicy;
1:6895d00:     }
1:2db7df7: 
1:d29ca2a:     public void setDispatchPolicy(DispatchPolicy dispatchPolicy) {
1:d29ca2a:         this.dispatchPolicy = dispatchPolicy;
1:6895d00:     }
1:2db7df7: 
1:e7e15b5:     public MessageGroupMapFactory getMessageGroupMapFactory() {
1:e7e15b5:         return messageGroupMapFactory;
1:6895d00:     }
1:4d01443: 
1:e7e15b5:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory) {
1:e7e15b5:         this.messageGroupMapFactory = messageGroupMapFactory;
1:6895d00:     }
1:4d01443: 
1:230a86c:     public PendingMessageCursor getMessages() {
1:3a9299b:         return this.messages;
1:6895d00:     }
1:4d01443: 
1:230a86c:     public void setMessages(PendingMessageCursor messages) {
1:230a86c:         this.messages = messages;
1:6895d00:     }
1:2a153b0: 
1:2a153b0:     public boolean isUseConsumerPriority() {
1:2a153b0:         return useConsumerPriority;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public void setUseConsumerPriority(boolean useConsumerPriority) {
1:2a153b0:         this.useConsumerPriority = useConsumerPriority;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public boolean isStrictOrderDispatch() {
1:2a153b0:         return strictOrderDispatch;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public void setStrictOrderDispatch(boolean strictOrderDispatch) {
1:2a153b0:         this.strictOrderDispatch = strictOrderDispatch;
1:2a153b0:     }
1:3f9d6e2: 
1:3f9d6e2:     public boolean isOptimizedDispatch() {
1:3f9d6e2:         return optimizedDispatch;
1:3f9d6e2:     }
1:3f9d6e2: 
1:3f9d6e2:     public void setOptimizedDispatch(boolean optimizedDispatch) {
1:3f9d6e2:         this.optimizedDispatch = optimizedDispatch;
1:3f9d6e2:     }
1:4d01443: 
1:a321204:     public int getTimeBeforeDispatchStarts() {
1:a321204:         return timeBeforeDispatchStarts;
1:6895d00:     }
1:4d01443: 
1:a321204:     public void setTimeBeforeDispatchStarts(int timeBeforeDispatchStarts) {
1:a321204:         this.timeBeforeDispatchStarts = timeBeforeDispatchStarts;
1:6895d00:     }
1:4d01443: 
1:a321204:     public int getConsumersBeforeDispatchStarts() {
1:a321204:         return consumersBeforeDispatchStarts;
1:6895d00:     }
1:4d01443: 
1:a321204:     public void setConsumersBeforeDispatchStarts(int consumersBeforeDispatchStarts) {
1:a321204:         this.consumersBeforeDispatchStarts = consumersBeforeDispatchStarts;
1:3a9299b:     }
1:42ee51f: 
1:42ee51f:     public void setAllConsumersExclusiveByDefault(boolean allConsumersExclusiveByDefault) {
1:42ee51f:         this.allConsumersExclusiveByDefault = allConsumersExclusiveByDefault;
1:42ee51f:     }
1:42ee51f: 
1:42ee51f:     public boolean isAllConsumersExclusiveByDefault() {
1:42ee51f:         return allConsumersExclusiveByDefault;
1:42ee51f:     }
1:42ee51f: 
1:dcedd9f:     public boolean isResetNeeded() {
1:dcedd9f:         return resetNeeded;
1:dcedd9f:     }
1:dcedd9f: 
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:cd54a16:     private QueueMessageReference createMessageReference(Message message) {
1:cd54a16:         QueueMessageReference result = new IndirectMessageReference(message);
1:6895d00:         return result;
1:3a9299b:     }
1:4d01443: 
1:540b1c6:     @Override
1:e6f5d30:     public Message[] browse() {
1:5619cd0:         List<Message> browseList = new ArrayList<Message>();
1:5619cd0:         doBrowse(browseList, getMaxBrowsePageSize());
1:5619cd0:         return browseList.toArray(new Message[browseList.size()]);
1:6895d00:     }
1:4d01443: 
1:5619cd0:     public void doBrowse(List<Message> browseList, int max) {
1:c6a485f:         final ConnectionContext connectionContext = createConnectionContext();
1:8216e7f:         try {
1:8216e7f:             int maxPageInAttempts = 1;
1:a3a8c1c:             if (max > 0) {
1:a3a8c1c:                 messagesLock.readLock().lock();
1:a3a8c1c:                 try {
1:a3a8c1c:                     maxPageInAttempts += (messages.size() / max);
1:a3a8c1c:                 } finally {
1:a3a8c1c:                     messagesLock.readLock().unlock();
1:a3a8c1c:                 }
1:a3a8c1c:                 while (shouldPageInMoreForBrowse(max) && maxPageInAttempts-- > 0) {
1:a3a8c1c:                     pageInMessages(!memoryUsage.isFull(110), max);
1:a3a8c1c:                 }
1:8216e7f:             }
1:efc9a8d:             doBrowseList(browseList, max, dispatchPendingList, pagedInPendingDispatchLock, connectionContext, "redeliveredWaitingDispatch+pagedInPendingDispatch");
1:e947927:             doBrowseList(browseList, max, pagedInMessages, pagedInMessagesLock, connectionContext, "pagedInMessages");
1:14d24cc: 
1:a64976a:             // we need a store iterator to walk messages on disk, independent of the cursor which is tracking
1:a64976a:             // the next message batch
1:15412ba:         } catch (BrokerStoppedException ignored) {
1:cc6213e:         } catch (Exception e) {
1:c6a485f:             LOG.error("Problem retrieving message for browse", e);
1:6895d00:         }
1:3a9299b:     }
1:14d24cc: 
1:e947927:     protected void doBrowseList(List<Message> browseList, int max, PendingList list, ReentrantReadWriteLock lock, ConnectionContext connectionContext, String name) throws Exception {
1:e947927:         List<MessageReference> toExpire = new ArrayList<MessageReference>();
1:e947927:         lock.readLock().lock();
1:e947927:         try {
1:e947927:             addAll(list.values(), browseList, max, toExpire);
1:8216e7f:         } finally {
1:e947927:             lock.readLock().unlock();
1:e947927:         }
1:e947927:         for (MessageReference ref : toExpire) {
1:e947927:             if (broker.isExpired(ref)) {
1:e947927:                 LOG.debug("expiring from {}: {}", name, ref);
1:e947927:                 messageExpired(connectionContext, ref);
1:a64976a:             } else {
1:e947927:                 lock.writeLock().lock();
1:e947927:                 try {
1:e947927:                     list.remove(ref);
1:cc6213e:                 } finally {
1:e947927:                     lock.writeLock().unlock();
1:e947927:                 }
1:a64976a:                 ref.decrementReferenceCount();
1:e947927:             }
1:e947927:         }
1:e947927:     }
1:e947927: 
1:14d24cc:     private boolean shouldPageInMoreForBrowse(int max) {
1:9c24716:         int alreadyPagedIn = 0;
1:14d24cc:         pagedInMessagesLock.readLock().lock();
1:14d24cc:         try {
1:9c24716:             alreadyPagedIn = pagedInMessages.size();
1:14d24cc:         } finally {
1:14d24cc:             pagedInMessagesLock.readLock().unlock();
1:4165972:         }
1:f158e7d:         int messagesInQueue = alreadyPagedIn;
1:8216e7f:         messagesLock.readLock().lock();
1:4165972:         try {
1:f158e7d:             messagesInQueue += messages.size();
1:4165972:         } finally {
1:8216e7f:             messagesLock.readLock().unlock();
1:14d24cc:         }
1:4165972: 
1:4165972:         LOG.trace("max {}, alreadyPagedIn {}, messagesCount {}, memoryUsage {}%", new Object[]{max, alreadyPagedIn, messagesInQueue, memoryUsage.getPercentUsage()});
1:026c6f4:         return (alreadyPagedIn == 0 || (alreadyPagedIn < max)
1:4165972:                 && (alreadyPagedIn < messagesInQueue)
1:026c6f4:                 && messages.hasSpace());
1:14d24cc:     }
1:14d24cc: 
1:a64976a:     private void addAll(Collection<? extends MessageReference> refs, List<Message> l, int max,
1:27262c8:             List<MessageReference> toExpire) throws Exception {
1:a64976a:         for (Iterator<? extends MessageReference> i = refs.iterator(); i.hasNext() && l.size() < max;) {
1:cb1b92b:             QueueMessageReference ref = (QueueMessageReference) i.next();
1:26807cd:             if (ref.isExpired() && (ref.getLockOwner() == null)) {
1:c6a485f:                 toExpire.add(ref);
1:ea70e82:             } else if (!ref.isAcked() && l.contains(ref.getMessage()) == false) {
1:c6a485f:                 l.add(ref.getMessage());
1:28180b3:             }
1:28180b3:         }
1:28180b3:     }
1:4d01443: 
1:1b45e3b:     public QueueMessageReference getMessage(String id) {
1:47cfa55:         MessageId msgId = new MessageId(id);
1:28180b3:         pagedInMessagesLock.readLock().lock();
1:28180b3:         try {
1:e947927:             QueueMessageReference ref = (QueueMessageReference)this.pagedInMessages.get(msgId);
1:1b45e3b:             if (ref != null) {
1:1b45e3b:                 return ref;
1:28180b3:             }
1:734fb7d:         } finally {
1:28180b3:             pagedInMessagesLock.readLock().unlock();
1:00879cf:         }
1:67ead20:         messagesLock.writeLock().lock();
1:28180b3:         try{
1:28180b3:             try {
1:28180b3:                 messages.reset();
1:00879cf:                 while (messages.hasNext()) {
1:1b45e3b:                     MessageReference mr = messages.next();
1:1b45e3b:                     QueueMessageReference qmr = createMessageReference(mr.getMessage());
1:1b45e3b:                     qmr.decrementReferenceCount();
1:1b45e3b:                     messages.rollback(qmr.getMessageId());
1:1b45e3b:                     if (msgId.equals(qmr.getMessageId())) {
1:1b45e3b:                         return qmr;
1:ec63977:                     }
1:3a9299b:                 }
1:e947927:             } finally {
1:28180b3:                 messages.release();
1:2748ae1:             }
1:f4d4c3b:         }finally {
1:67ead20:             messagesLock.writeLock().unlock();
1:c8bd57c:         }
2:511b60c:         return null;
1:540b1c6:     }
1:6d8e2c5: 
1:8d11f07:     public void purge() throws Exception {
1:8d11f07:         ConnectionContext c = createConnectionContext();
1:8d11f07:         List<MessageReference> list = null;
1:56bb079:         try {
1:56bb079:             sendLock.lock();
1:f19add1:             long originalMessageCount = this.destinationStatistics.getMessages().getCount();
1:56bb079:             do {
1:a3a8c1c:                 doPageIn(true, false, getMaxPageSize());  // signal no expiry processing needed.
1:56bb079:                 pagedInMessagesLock.readLock().lock();
1:28180b3:                 try {
1:56bb079:                     list = new ArrayList<MessageReference>(pagedInMessages.values());
1:56bb079:                 }finally {
1:56bb079:                     pagedInMessagesLock.readLock().unlock();
1:8d11f07:                 }
1:d2e6062: 
1:56bb079:                 for (MessageReference ref : list) {
1:56bb079:                     try {
1:56bb079:                         QueueMessageReference r = (QueueMessageReference) ref;
1:56bb079:                         removeMessage(c, r);
1:2eff835:                         messages.rollback(r.getMessageId());
1:56bb079:                     } catch (IOException e) {
1:56bb079:                     }
1:56bb079:                 }
1:56bb079:                 // don't spin/hang if stats are out and there is nothing left in the
1:56bb079:                 // store
1:56bb079:             } while (!list.isEmpty() && this.destinationStatistics.getMessages().getCount() > 0);
1:99f3d4c: 
1:56bb079:             if (this.destinationStatistics.getMessages().getCount() > 0) {
1:f19add1:                 LOG.warn("{} after purge of {} messages, message count stats report: {}", getActiveMQDestination().getQualifiedName(), originalMessageCount, this.destinationStatistics.getMessages().getCount());
1:56bb079:             }
1:56bb079:         } finally {
1:511b60c:             sendLock.unlock();
1:0d85869:         }
1:cb1b92b:     }
1:56bb079: 
1:511b60c:     @Override
1:ea70e82:     public void clearPendingMessages(int pendingAdditionsCount) {
1:28180b3:         messagesLock.writeLock().lock();
1:28180b3:         try {
1:ea70e82:             final ActiveMQMessage dummyPersistent = new ActiveMQMessage();
1:ea70e82:             dummyPersistent.setPersistent(true);
1:ea70e82:             for (int i=0; i<pendingAdditionsCount; i++) {
1:ea70e82:                 try {
1:ea70e82:                     // track the increase in the cursor size w/o reverting to the store
1:ea70e82:                     messages.addMessageFirst(dummyPersistent);
1:ea70e82:                 } catch (Exception ignored) {
1:ea70e82:                     LOG.debug("Unexpected exception on tracking pending message additions", ignored);
1:ea70e82:                 }
1:ea70e82:             }
1:cfe099d:             if (resetNeeded) {
1:cfe099d:                 messages.gc();
1:cfe099d:                 messages.reset();
1:cfe099d:                 resetNeeded = false;
1:f19add1:             } else {
1:cfe099d:                 messages.rebase();
1:cb1b92b:             }
1:101e711:             asyncWakeup();
1:28180b3:         } finally {
1:28180b3:             messagesLock.writeLock().unlock();
1:cb1b92b:         }
1:c5788d2:     }
1:d2e6062: 
1:e8a7451:     /**
1:9479de7:      * Removes the message matching the given messageId
1:6895d00:      */
1:9479de7:     public boolean removeMessage(String messageId) throws Exception {
1:9479de7:         return removeMatchingMessages(createMessageIdFilter(messageId), 1) > 0;
1:0deda25:     }
1:d2e6062: 
1:d4382e4:     /**
1:9479de7:      * Removes the messages matching the given selector
1:d2e6062:      *
1:9479de7:      * @return the number of messages removed
1:9216c18:      */
1:9479de7:     public int removeMatchingMessages(String selector) throws Exception {
1:9479de7:         return removeMatchingMessages(selector, -1);
1:3fe7760:     }
1:d2e6062: 
1:6895d00:     /**
1:230a86c:      * Removes the messages matching the given selector up to the maximum number
1:230a86c:      * of matched messages
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages removed
3:9479de7:      */
1:9479de7:     public int removeMatchingMessages(String selector, int maximumMessages) throws Exception {
1:9479de7:         return removeMatchingMessages(createSelectorFilter(selector), maximumMessages);
1:00fb444:     }
1:d2e6062: 
1:6895d00:     /**
1:230a86c:      * Removes the messages matching the given filter up to the maximum number
1:230a86c:      * of matched messages
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages removed
1:9479de7:      */
1:9479de7:     public int removeMatchingMessages(MessageReferenceFilter filter, int maximumMessages) throws Exception {
1:8d11f07:         int movedCounter = 0;
1:3813947:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
1:8d11f07:         ConnectionContext context = createConnectionContext();
1:8d11f07:         do {
1:d2e6062:             doPageIn(true);
1:28180b3:             pagedInMessagesLock.readLock().lock();
1:00879cf:             try {
1:18f9773:                 set.addAll(pagedInMessages.values());
1:28180b3:             } finally {
1:28180b3:                 pagedInMessagesLock.readLock().unlock();
1:8d11f07:             }
1:e947927:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:e947927:             for (MessageReference ref : list) {
1:8d11f07:                 IndirectMessageReference r = (IndirectMessageReference) ref;
1:8d11f07:                 if (filter.evaluate(context, r)) {
1:18f9773: 
1:e8a7451:                     removeMessage(context, r);
1:47cfa55:                     set.remove(r);
1:48764be:                     if (++movedCounter >= maximumMessages && maximumMessages > 0) {
1:8d11f07:                         return movedCounter;
1:8d11f07:                     }
1:8d11f07:                 }
1:8d11f07:             }
1:18f9773:         } while (set.size() < this.destinationStatistics.getMessages().getCount());
2:8d11f07:         return movedCounter;
1:d2e6062:     }
1:8d11f07: 
3:9479de7:     /**
1:9479de7:      * Copies the message matching the given messageId
1:9479de7:      */
1:27262c8:     public boolean copyMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest)
1:27262c8:             throws Exception {
1:9479de7:         return copyMatchingMessages(context, createMessageIdFilter(messageId), dest, 1) > 0;
1:2a328ed:     }
1:3bf0245: 
1:9479de7:     /**
1:9479de7:      * Copies the messages matching the given selector
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages copied
1:9479de7:      */
1:27262c8:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest)
1:27262c8:             throws Exception {
1:9479de7:         return copyMatchingMessagesTo(context, selector, dest, -1);
1:8d11f07:     }
1:3b28c7c: 
1:9479de7:     /**
1:230a86c:      * Copies the messages matching the given selector up to the maximum number
1:230a86c:      * of matched messages
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages copied
1:9479de7:      */
1:27262c8:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest,
1:27262c8:             int maximumMessages) throws Exception {
1:9479de7:         return copyMatchingMessages(context, createSelectorFilter(selector), dest, maximumMessages);
1:2a328ed:     }
1:6895d00: 
1:9479de7:     /**
1:230a86c:      * Copies the messages matching the given filter up to the maximum number of
1:230a86c:      * matched messages
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages copied
1:9479de7:      */
1:27262c8:     public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest,
1:27262c8:             int maximumMessages) throws Exception {
1:8023b9e: 
1:8023b9e:         if (destination.equals(dest)) {
1:8023b9e:             return 0;
1:8023b9e:         }
1:8023b9e: 
1:8d11f07:         int movedCounter = 0;
1:47cfa55:         int count = 0;
1:3813947:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
1:8d11f07:         do {
1:48764be:             int oldMaxSize = getMaxPageSize();
1:18f9773:             setMaxPageSize((int) this.destinationStatistics.getMessages().getCount());
1:89eecad:             doPageIn(true);
1:18f9773:             setMaxPageSize(oldMaxSize);
1:28180b3:             pagedInMessagesLock.readLock().lock();
1:511b60c:             try {
1:18f9773:                 set.addAll(pagedInMessages.values());
1:28180b3:             } finally {
1:28180b3:                 pagedInMessagesLock.readLock().unlock();
1:511b60c:             }
1:e947927:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:e947927:             for (MessageReference ref : list) {
1:8d11f07:                 IndirectMessageReference r = (IndirectMessageReference) ref;
2:9479de7:                 if (filter.evaluate(context, r)) {
1:511b60c: 
1:18f9773:                     r.incrementReferenceCount();
1:28180b3:                     try {
1:00879cf:                         Message m = r.getMessage();
1:e8a7451:                         BrokerSupport.resend(context, m, dest);
1:48764be:                         if (++movedCounter >= maximumMessages && maximumMessages > 0) {
1:d4382e4:                             return movedCounter;
1:511b60c:                         }
1:d4382e4:                     } finally {
1:00879cf:                         r.decrementReferenceCount();
1:511b60c:                     }
1:511b60c:                 }
3:47cfa55:                 count++;
1:511b60c:             }
1:8d11f07:         } while (count < this.destinationStatistics.getMessages().getCount());
1:8d11f07:         return movedCounter;
1:511b60c:     }
1:511b60c: 
1:9479de7:     /**
1:e8a7451:      * Move a message
1:c1ebbc1:      *
1:27262c8:      * @param context
1:27262c8:      *            connection context
1:27262c8:      * @param m
1:1b45e3b:      *            QueueMessageReference
1:27262c8:      * @param dest
1:27262c8:      *            ActiveMQDestination
1:e8a7451:      * @throws Exception
1:e8a7451:      */
1:1b45e3b:     public boolean moveMessageTo(ConnectionContext context, QueueMessageReference m, ActiveMQDestination dest) throws Exception {
1:2ea5d14:         Set<Destination> destsToPause = regionBroker.getDestinations(dest);
1:ea84378:         try {
1:2ea5d14:             for (Destination d: destsToPause) {
1:2ea5d14:                 if (d instanceof Queue) {
1:2ea5d14:                     ((Queue)d).pauseDispatch();
1:2ea5d14:                 }
1:2ea5d14:             }
1:2ea5d14:             BrokerSupport.resend(context, m.getMessage(), dest);
1:2ea5d14:             removeMessage(context, m);
1:2ea5d14:             messagesLock.writeLock().lock();
1:2ea5d14:             try {
1:2ea5d14:                 messages.rollback(m.getMessageId());
1:2ea5d14:                 if (isDLQ()) {
1:1ebf186:                     ActiveMQDestination originalDestination = m.getMessage().getOriginalDestination();
1:1ebf186:                     if (originalDestination != null) {
1:1ebf186:                         for (Destination destination : regionBroker.getDestinations(originalDestination)) {
1:1ebf186:                             DeadLetterStrategy strategy = destination.getDeadLetterStrategy();
1:1ebf186:                             strategy.rollback(m.getMessage());
1:1ebf186:                         }
1:1ebf186:                     }
1:2ea5d14:                 }
1:2ea5d14:             } finally {
1:2ea5d14:                 messagesLock.writeLock().unlock();
1:e8a7451:             }
1:00879cf:         } finally {
1:2ea5d14:             for (Destination d: destsToPause) {
1:2ea5d14:                 if (d instanceof Queue) {
1:2ea5d14:                     ((Queue)d).resumeDispatch();
1:2ea5d14:                 }
1:2ea5d14:             }
1:47cfa55:         }
1:2ea5d14: 
1:511b60c:         return true;
1:47cfa55:     }
1:511b60c: 
1:9479de7:     /**
1:9479de7:      * Moves the message matching the given messageId
1:9479de7:      */
1:27262c8:     public boolean moveMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest)
1:27262c8:             throws Exception {
1:9479de7:         return moveMatchingMessagesTo(context, createMessageIdFilter(messageId), dest, 1) > 0;
1:47cfa55:     }
1:511b60c: 
1:9479de7:     /**
1:9479de7:      * Moves the messages matching the given selector
1:c1ebbc1:      *
1:9479de7:      * @return the number of messages removed
1:9479de7:      */
1:27262c8:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest)
1:27262c8:             throws Exception {
1:48764be:         return moveMatchingMessagesTo(context, selector, dest, Integer.MAX_VALUE);
1:47cfa55:     }
1:6895d00: 
1:9479de7:     /**
1:230a86c:      * Moves the messages matching the given selector up to the maximum number
1:230a86c:      * of matched messages
1:9479de7:      */
1:27262c8:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest,
1:27262c8:             int maximumMessages) throws Exception {
1:9479de7:         return moveMatchingMessagesTo(context, createSelectorFilter(selector), dest, maximumMessages);
1:47cfa55:     }
1:6895d00: 
1:9479de7:     /**
1:230a86c:      * Moves the messages matching the given filter up to the maximum number of
1:230a86c:      * matched messages
1:9479de7:      */
1:27262c8:     public int moveMatchingMessagesTo(ConnectionContext context, MessageReferenceFilter filter,
1:27262c8:             ActiveMQDestination dest, int maximumMessages) throws Exception {
1:8023b9e: 
1:8023b9e:         if (destination.equals(dest)) {
1:8023b9e:             return 0;
1:8023b9e:         }
1:6895d00: 
1:8d11f07:         int movedCounter = 0;
1:e947927:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
1:8d11f07:         do {
1:89eecad:             doPageIn(true);
1:28180b3:             pagedInMessagesLock.readLock().lock();
1:47cfa55:             try {
1:18f9773:                 set.addAll(pagedInMessages.values());
1:47cfa55:             } finally {
1:28180b3:                 pagedInMessagesLock.readLock().unlock();
1:47cfa55:             }
1:47cfa55:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:47cfa55:             for (MessageReference ref : list) {
1:1b45e3b:                 if (filter.evaluate(context, ref)) {
1:9479de7:                     // We should only move messages that can be locked.
1:e947927:                     moveMessageTo(context, (QueueMessageReference)ref, dest);
1:1b45e3b:                     set.remove(ref);
1:48764be:                     if (++movedCounter >= maximumMessages && maximumMessages > 0) {
1:47cfa55:                         return movedCounter;
1:47cfa55:                     }
1:47cfa55:                 }
1:47cfa55:             }
1:e1f170d:         } while (set.size() < this.destinationStatistics.getMessages().getCount() && set.size() < maximumMessages);
1:d4382e4:         return movedCounter;
1:f81d0d5:     }
1:6895d00: 
1:e1f170d:     public int retryMessages(ConnectionContext context, int maximumMessages) throws Exception {
1:e1f170d:         if (!isDLQ()) {
1:e1f170d:             throw new Exception("Retry of message is only possible on Dead Letter Queues!");
1:f81d0d5:         }
1:e1f170d:         int restoredCounter = 0;
1:03b19b9:         // ensure we deal with a snapshot to avoid potential duplicates in the event of messages
1:03b19b9:         // getting immediate dlq'ed
1:03b19b9:         long numberOfRetryAttemptsToCheckAllMessagesOnce = this.destinationStatistics.getMessages().getCount();
1:e947927:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
1:41cdadb:         do {
1:89eecad:             doPageIn(true);
1:28180b3:             pagedInMessagesLock.readLock().lock();
1:47cfa55:             try {
1:e1f170d:                 set.addAll(pagedInMessages.values());
1:47cfa55:             } finally {
1:28180b3:                 pagedInMessagesLock.readLock().unlock();
1:8d11f07:             }
1:48764be:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:8d11f07:             for (MessageReference ref : list) {
1:03b19b9:                 numberOfRetryAttemptsToCheckAllMessagesOnce--;
1:e1f170d:                 if (ref.getMessage().getOriginalDestination() != null) {
1:6895d00: 
1:e947927:                     moveMessageTo(context, (QueueMessageReference)ref, ref.getMessage().getOriginalDestination());
1:e1f170d:                     set.remove(ref);
1:e1f170d:                     if (++restoredCounter >= maximumMessages && maximumMessages > 0) {
1:e1f170d:                         return restoredCounter;
1:2db7df7:                     }
1:d2e6062:                 }
1:d2e6062:             }
1:03b19b9:         } while (numberOfRetryAttemptsToCheckAllMessagesOnce > 0 && set.size() < this.destinationStatistics.getMessages().getCount());
1:e1f170d:         return restoredCounter;
1:ec63977:     }
1:6895d00: 
1:9479de7:     /**
1:071b4b1:      * @return true if we would like to iterate again
1:6895d00:      * @see org.apache.activemq.thread.Task#iterate()
1:6895d00:      */
1:511b60c:     @Override
1:230a86c:     public boolean iterate() {
1:3da9f1c:         MDC.put("activemq.destination", getName());
1:27262c8:         boolean pageInMoreMessages = false;
1:48764be:         synchronized (iteratingMutex) {
1:071b4b1: 
1:a1d5ff0:             // If optimize dispatch is on or this is a slave this method could be called recursively
1:a1d5ff0:             // we set this state value to short-circuit wakeup in those cases to avoid that as it
1:a1d5ff0:             // could lead to errors.
1:a1d5ff0:             iterationRunning = true;
1:6895d00: 
1:08aecbe:             // do early to allow dispatch of these waiting messages
1:83128fc:             synchronized (messagesWaitingForSpace) {
1:83128fc:                 Iterator<Runnable> it = messagesWaitingForSpace.values().iterator();
1:83128fc:                 while (it.hasNext()) {
1:97e0fcc:                     if (!memoryUsage.isFull()) {
1:83128fc:                         Runnable op = it.next();
1:83128fc:                         it.remove();
1:3249682:                         op.run();
1:cfe099d:                     } else {
1:97e0fcc:                         registerCallbackForNotFullNotification();
1:cc6213e:                         break;
1:3249682:                     }
1:ec63977:                 }
1:6895d00:             }
1:3249682: 
1:a321204:             if (firstConsumer) {
1:a321204:                 firstConsumer = false;
1:47cfa55:                 try {
1:a321204:                     if (consumersBeforeDispatchStarts > 0) {
1:27262c8:                         int timeout = 1000; // wait one second by default if
1:27262c8:                                             // consumer count isn't reached
1:a321204:                         if (timeBeforeDispatchStarts > 0) {
1:a321204:                             timeout = timeBeforeDispatchStarts;
1:6895d00:                         }
1:a321204:                         if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {
1:e1bbde7:                             LOG.debug("{} consumers subscribed. Starting dispatch.", consumers.size());
1:e947927:                         } else {
1:e1bbde7:                             LOG.debug("{} ms elapsed and {} consumers subscribed. Starting dispatch.", timeout, consumers.size());
1:6895d00:                         }
1:6895d00:                     }
1:a321204:                     if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {
1:a321204:                         iteratingMutex.wait(timeBeforeDispatchStarts);
1:e1bbde7:                         LOG.debug("{} ms elapsed. Starting dispatch.", timeBeforeDispatchStarts);
1:6895d00:                     }
1:511b60c:                 } catch (Exception e) {
1:8bf987b:                     LOG.error(e.toString());
1:6895d00:                 }
1:6895d00:             }
1:6895d00: 
1:734fb7d:             messagesLock.readLock().lock();
1:28180b3:             try{
1:184761a:                 pageInMoreMessages |= !messages.isEmpty();
1:d4382e4:             } finally {
1:734fb7d:                 messagesLock.readLock().unlock();
1:6895d00:             }
1:6895d00: 
1:28180b3:             pagedInPendingDispatchLock.readLock().lock();
1:28180b3:             try {
1:efc9a8d:                 pageInMoreMessages |= !dispatchPendingList.isEmpty();
1:28180b3:             } finally {
1:28180b3:                 pagedInPendingDispatchLock.readLock().unlock();
1:28180b3:             }
1:a64976a: 
1:b4e35fe:             boolean hasBrowsers = !browserDispatches.isEmpty();
1:6895d00: 
1:efc9a8d:             if (pageInMoreMessages || hasBrowsers || !dispatchPendingList.hasRedeliveries()) {
1:28180b3:                 try {
1:a3a8c1c:                     pageInMessages(hasBrowsers && getMaxBrowsePageSize() > 0, getMaxPageSize());
1:071b4b1:                 } catch (Throwable e) {
1:44e0eaf:                     LOG.error("Failed to page in more queue messages ", e);
1:28180b3:                 }
1:2e137fb:             }
1:27262c8: 
1:915333e:             if (hasBrowsers) {
1:b4e35fe:                 PendingList messagesInMemory = isPrioritizedMessages() ?
1:2b84cd6:                         new PrioritizedPendingList() : new OrderedPendingList();
1:28180b3:                 pagedInMessagesLock.readLock().lock();
1:b4e35fe:                 try {
1:b4e35fe:                     messagesInMemory.addAll(pagedInMessages);
1:b4e35fe:                 } finally {
1:28180b3:                     pagedInMessagesLock.readLock().unlock();
1:071b4b1:                 }
1:071b4b1: 
1:915333e:                 Iterator<BrowserDispatch> browsers = browserDispatches.iterator();
1:915333e:                 while (browsers.hasNext()) {
1:915333e:                     BrowserDispatch browserDispatch = browsers.next();
1:47cfa55:                     try {
1:3b0afd6:                         MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
1:f81d0d5:                         msgContext.setDestination(destination);
1:27262c8: 
1:915333e:                         QueueBrowserSubscription browser = browserDispatch.getBrowser();
1:d4382e4: 
1:b4e35fe:                         LOG.debug("dispatch to browser: {}, already dispatched/paged count: {}", browser, messagesInMemory.size());
1:915333e:                         boolean added = false;
1:b4e35fe:                         for (MessageReference node : messagesInMemory) {
1:e947927:                             if (!((QueueMessageReference)node).isAcked() && !browser.isDuplicate(node.getMessageId()) && !browser.atMax()) {
1:f81d0d5:                                 msgContext.setMessageReference(node);
1:fde4721:                                 if (browser.matches(node, msgContext)) {
1:fde4721:                                     browser.add(node);
1:915333e:                                     added = true;
1:071b4b1:                                 }
1:071b4b1:                             }
1:4d01443:                         }
1:915333e:                         // are we done browsing? no new messages paged
1:85bc9ce:                         if (!added || browser.atMax()) {
1:9216c18:                             browser.decrementQueueRef();
1:5bfbc54:                             browserDispatches.remove(browserDispatch);
1:41a1007:                         } else {
1:41a1007:                             wakeup();
1:4d01443:                         }
1:dcedd9f:                     } catch (Exception e) {
1:e1bbde7:                         LOG.warn("exception on dispatch to browser: {}", browserDispatch.getBrowser(), e);
1:4d01443:                     }
1:4d01443:                 }
1:6895d00:             }
1:d4382e4: 
1:7ceb4cb:             if (pendingWakeups.get() > 0) {
1:7ceb4cb:                 pendingWakeups.decrementAndGet();
1:6895d00:             }
1:3da9f1c:             MDC.remove("activemq.destination");
1:a1d5ff0:             iterationRunning = false;
1:6895d00: 
1:7ceb4cb:             return pendingWakeups.get() > 0;
1:6895d00:         }
1:97502bd:     }
1:6895d00: 
1:85b9c81:     public void pauseDispatch() {
1:85b9c81:         dispatchSelector.pause();
1:85b9c81:     }
1:85b9c81: 
1:85b9c81:     public void resumeDispatch() {
1:85b9c81:         dispatchSelector.resume();
1:078a101:         wakeup();
1:85b9c81:     }
1:85b9c81: 
1:85b9c81:     public boolean isDispatchPaused() {
1:85b9c81:         return dispatchSelector.isPaused();
1:85b9c81:     }
1:85b9c81: 
1:9479de7:     protected MessageReferenceFilter createMessageIdFilter(final String messageId) {
1:9479de7:         return new MessageReferenceFilter() {
1:511b60c:             @Override
1:9479de7:             public boolean evaluate(ConnectionContext context, MessageReference r) {
1:9479de7:                 return messageId.equals(r.getMessageId().toString());
1:47cfa55:             }
1:6895d00: 
1:ea84378:             @Override
1:47cfa55:             public String toString() {
1:48764be:                 return "MessageIdFilter: " + messageId;
1:3fe7760:             }
1:14d24cc:         };
1:2a328ed:     }
1:3a9299b: 
1:9479de7:     protected MessageReferenceFilter createSelectorFilter(String selector) throws InvalidSelectorException {
1:3a9299b: 
1:d5b604e:         if (selector == null || selector.isEmpty()) {
1:d5b604e:             return new MessageReferenceFilter() {
1:2748ae1: 
1:540b1c6:                 @Override
1:d5b604e:                 public boolean evaluate(ConnectionContext context, MessageReference messageReference) throws JMSException {
1:e8a7451:                     return true;
1:d5b604e:                 }
1:2a153b0:             };
1:d5b604e:         }
1:c50b8e4: 
1:1ab76f7:         final BooleanExpression selectorExpression = SelectorParser.parse(selector);
1:a1d5ff0: 
1:9479de7:         return new MessageReferenceFilter() {
1:540b1c6:             @Override
1:9479de7:             public boolean evaluate(ConnectionContext context, MessageReference r) throws JMSException {
1:9479de7:                 MessageEvaluationContext messageEvaluationContext = context.getMessageEvaluationContext();
1:a1d5ff0: 
1:9479de7:                 messageEvaluationContext.setMessageReference(r);
1:9479de7:                 if (messageEvaluationContext.getDestination() == null) {
1:9479de7:                     messageEvaluationContext.setDestination(getActiveMQDestination());
1:2a328ed:                 }
1:cb1b92b: 
1:9479de7:                 return selectorExpression.matches(messageEvaluationContext);
1:2a328ed:             }
1:d5b604e:         };
1:2a328ed:     }
1:cb1b92b: 
1:cd54a16:     protected void removeMessage(ConnectionContext c, QueueMessageReference r) throws IOException {
1:0d85869:         removeMessage(c, null, r);
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:28180b3:         try {
1:efc9a8d:             dispatchPendingList.remove(r);
1:28180b3:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:0d85869:         }
1:2a328ed:     }
1:28180b3: 
1:48764be:     protected void removeMessage(ConnectionContext c, Subscription subs, QueueMessageReference r) throws IOException {
1:44b00e9:         MessageAck ack = new MessageAck();
1:44b00e9:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:44b00e9:         ack.setDestination(destination);
1:44b00e9:         ack.setMessageID(r.getMessageId());
1:0d85869:         removeMessage(c, subs, r, ack);
1:8d11f07:     }
1:8d11f07: 
1:27262c8:     protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference,
1:27262c8:             MessageAck ack) throws IOException {
1:f92d45b:         LOG.trace("ack of {} with {}", reference.getMessageId(), ack);
1:00fb444:         // This sends the ack the the journal..
1:00fb444:         if (!ack.isInTransaction()) {
1:8d11f07:             acknowledge(context, sub, ack, reference);
1:47cfa55:             dropMessage(reference);
1:28180b3:         } else {
1:e2cafda:             try {
2:3fe7760:                 acknowledge(context, sub, ack, reference);
1:28180b3:             } finally {
1:3fe7760:                 context.getTransaction().addSynchronization(new Synchronization() {
1:cb1b92b: 
1:ea84378:                     @Override
1:3fe7760:                     public void afterCommit() throws Exception {
1:47cfa55:                         dropMessage(reference);
1:c8bd57c:                         wakeup();
1:8d11f07:                     }
1:cb1b92b: 
1:ea84378:                     @Override
1:3fe7760:                     public void afterRollback() throws Exception {
1:3fe7760:                         reference.setAcked(false);
1:f405a7e:                         wakeup();
1:8d11f07:                     }
1:a64976a:                 });
1:00fb444:             }
1:2a328ed:         }
1:a95c6db:         if (ack.isPoisonAck() || (sub != null && sub.getConsumerInfo().isNetworkSubscription())) {
1:d7f34d9:             // message gone to DLQ, is ok to allow redelivery
1:28180b3:             messagesLock.writeLock().lock();
1:e2cafda:             try {
1:d7f34d9:                 messages.rollback(reference.getMessageId());
1:8d11f07:             } finally {
1:28180b3:                 messagesLock.writeLock().unlock();
1:2a328ed:             }
1:25e3c1b:             if (sub != null && sub.getConsumerInfo().isNetworkSubscription()) {
1:25e3c1b:                 getDestinationStatistics().getForwards().increment();
1:25e3c1b:             }
1:2a328ed:         }
1:13c2072:         // after successful store update
1:13c2072:         reference.setAcked(true);
1:3fe7760:     }
1:cb1b92b: 
1:47cfa55:     private void dropMessage(QueueMessageReference reference) {
1:1241e41:         //use dropIfLive so we only process the statistics at most one time
1:1241e41:         if (reference.dropIfLive()) {
1:1d2226e:             getDestinationStatistics().getDequeues().increment();
1:1d2226e:             getDestinationStatistics().getMessages().decrement();
1:720ff40:             pagedInMessagesLock.writeLock().lock();
1:0d85869:             try {
1:1d2226e:                 pagedInMessages.remove(reference);
1:2db7df7:             } finally {
1:720ff40:                 pagedInMessagesLock.writeLock().unlock();
1:6e468b4:             }
1:021c828:         }
1:47cfa55:     }
1:6e468b4: 
1:48764be:     public void messageExpired(ConnectionContext context, MessageReference reference) {
1:48764be:         messageExpired(context, null, reference);
1:47cfa55:     }
1:28180b3: 
1:540b1c6:     @Override
1:48764be:     public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {
1:e1bbde7:         LOG.debug("message expired: {}", reference);
1:27c1719:         broker.messageExpired(context, reference, subs);
1:fb591e7:         destinationStatistics.getExpired().increment();
1:28180b3:         try {
1:48764be:             removeMessage(context, subs, (QueueMessageReference) reference);
1:28180b3:             messagesLock.writeLock().lock();
1:28180b3:             try {
1:47cfa55:                 messages.rollback(reference.getMessageId());
1:c50b8e4:             } finally {
1:28180b3:                 messagesLock.writeLock().unlock();
1:cb1b92b:             }
3:47cfa55:         } catch (IOException e) {
1:48764be:             LOG.error("Failed to remove expired Message from the store ", e);
1:3fe7760:         }
1:3fe7760:     }
1:47cfa55: 
1:cc6213e:     private final boolean cursorAdd(final Message msg) throws Exception {
1:28180b3:         messagesLock.writeLock().lock();
1:cdc2fd3:         try {
1:54e2e3b:             return messages.addMessageLast(msg);
1:c50b8e4:         } finally {
1:28180b3:             messagesLock.writeLock().unlock();
1:00fb444:         }
1:00fb444:     }
1:cb1b92b: 
1:cc6213e:     private final boolean tryCursorAdd(final Message msg) throws Exception {
1:cc6213e:         messagesLock.writeLock().lock();
1:cc6213e:         try {
1:cc6213e:             return messages.tryAddMessageLast(msg, 50);
1:cc6213e:         } finally {
1:cc6213e:             messagesLock.writeLock().unlock();
1:cc6213e:         }
1:cc6213e:     }
1:cc6213e: 
1:c1ebbc1:     final void messageSent(final ConnectionContext context, final Message msg) throws Exception {
1:a0ba0bf:         pendingSends.decrementAndGet();
1:6895d00:         destinationStatistics.getEnqueues().increment();
1:6895d00:         destinationStatistics.getMessages().increment();
1:f71e2fe:         destinationStatistics.getMessageSize().addSize(msg.getSize());
1:cdc2fd3:         messageDelivered(context, msg);
1:28180b3:         consumersLock.readLock().lock();
1:28180b3:         try {
1:2db7df7:             if (consumers.isEmpty()) {
1:9ad6c08:                 onMessageWithNoConsumers(context, msg);
1:c8bd57c:             }
1:28180b3:         }finally {
1:28180b3:             consumersLock.readLock().unlock();
1:cce7566:         }
1:e1bbde7:         LOG.debug("{} Message {} sent to {}", new Object[]{ broker.getBrokerName(), msg.getMessageId(), this.destination });
1:c8bd57c:         wakeup();
1:cce7566:     }
1:cce7566: 
1:540b1c6:     @Override
1:044c07d:     public void wakeup() {
1:30f531d:         if (optimizedDispatch && !iterationRunning) {
1:3f9d6e2:             iterate();
1:c808beb:             pendingWakeups.incrementAndGet();
1:28180b3:         } else {
1:8d9f47a:             asyncWakeup();
1:3f9d6e2:         }
1:2db7df7:     }
1:6895d00: 
1:c808beb:     private void asyncWakeup() {
1:2e137fb:         try {
1:c808beb:             pendingWakeups.incrementAndGet();
1:c808beb:             this.taskRunner.wakeup();
1:3f9d6e2:         } catch (InterruptedException e) {
1:a526a60:             LOG.warn("Async task runner failed to wakeup ", e);
1:2db7df7:         }
1:2db7df7:     }
1:cb1b92b: 
1:462efdb:     private void doPageIn(boolean force) throws Exception {
1:a3a8c1c:         doPageIn(force, true, getMaxPageSize());
1:3bf0245:     }
1:540b1c6: 
1:a3a8c1c:     private void doPageIn(boolean force, boolean processExpired, int maxPageSize) throws Exception {
1:a3a8c1c:         PendingList newlyPaged = doPageInForDispatch(force, processExpired, maxPageSize);
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:3f9d6e2:         try {
1:efc9a8d:             if (dispatchPendingList.isEmpty()) {
1:efc9a8d:                 dispatchPendingList.addAll(newlyPaged);
1:cb1b92b: 
1:47cfa55:             } else {
1:cb1b92b:                 for (MessageReference qmr : newlyPaged) {
1:efc9a8d:                     if (!dispatchPendingList.contains(qmr)) {
1:efc9a8d:                         dispatchPendingList.addMessageLast(qmr);
1:6895d00:                     }
1:6895d00:                 }
1:6895d00:             }
1:c50b8e4:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:6895d00:         }
1:6895d00:     }
1:d5b604e: 
1:a3a8c1c:     private PendingList doPageInForDispatch(boolean force, boolean processExpired, int maxPageSize) throws Exception {
1:cd54a16:         List<QueueMessageReference> result = null;
1:cb1b92b:         PendingList resultList = null;
1:28180b3: 
1:b4e35fe:         int toPageIn = maxPageSize;
1:b4e35fe:         messagesLock.readLock().lock();
1:b4e35fe:         try {
1:b4e35fe:             toPageIn = Math.min(toPageIn, messages.size());
1:b4e35fe:         } finally {
1:b4e35fe:             messagesLock.readLock().unlock();
1:b4e35fe:         }
1:28180b3:         int pagedInPendingSize = 0;
1:28180b3:         pagedInPendingDispatchLock.readLock().lock();
1:28180b3:         try {
1:efc9a8d:             pagedInPendingSize = dispatchPendingList.size();
1:28180b3:         } finally {
1:28180b3:             pagedInPendingDispatchLock.readLock().unlock();
1:28180b3:         }
1:a64976a:         if (isLazyDispatch() && !force) {
1:a64976a:             // Only page in the minimum number of messages which can be
1:a64976a:             // dispatched immediately.
1:b4e35fe:             toPageIn = Math.min(toPageIn, getConsumerMessageCountBeforeFull());
1:28180b3:         }
1:a3a8c1c: 
1:a3a8c1c:         if (LOG.isDebugEnabled()) {
1:a3a8c1c:             LOG.debug("{} toPageIn: {}, force:{}, Inflight: {}, pagedInMessages.size {}, pagedInPendingDispatch.size {}, enqueueCount: {}, dequeueCount: {}, memUsage:{}, maxPageSize:{}",
1:a3a8c1c:                     new Object[]{
1:a3a8c1c:                             this,
1:a3a8c1c:                             toPageIn,
1:a3a8c1c:                             force,
1:a3a8c1c:                             destinationStatistics.getInflight().getCount(),
1:a3a8c1c:                             pagedInMessages.size(),
1:a3a8c1c:                             pagedInPendingSize,
1:a3a8c1c:                             destinationStatistics.getEnqueues().getCount(),
1:a3a8c1c:                             destinationStatistics.getDequeues().getCount(),
1:a3a8c1c:                             getMemoryUsage().getUsage(),
1:a3a8c1c:                             maxPageSize
1:a3a8c1c:                     });
1:a3a8c1c:         }
1:a3a8c1c: 
1:a3a8c1c:         if (toPageIn > 0 && (force || (haveRealConsumer() && pagedInPendingSize < maxPageSize))) {
1:28180b3:             int count = 0;
1:28180b3:             result = new ArrayList<QueueMessageReference>(toPageIn);
1:28180b3:             messagesLock.writeLock().lock();
1:28180b3:             try {
1:28180b3:                 try {
1:28180b3:                     messages.setMaxBatchSize(toPageIn);
1:28180b3:                     messages.reset();
1:a3a8c1c:                     while (count < toPageIn && messages.hasNext()) {
1:28180b3:                         MessageReference node = messages.next();
1:28180b3:                         messages.remove();
1:28180b3: 
1:28180b3:                         QueueMessageReference ref = createMessageReference(node.getMessage());
1:540b1c6:                         if (processExpired && ref.isExpired()) {
2:28180b3:                             if (broker.isExpired(ref)) {
1:28180b3:                                 messageExpired(createConnectionContext(), ref);
1:28180b3:                             } else {
1:a64976a:                                 ref.decrementReferenceCount();
1:a64976a:                             }
1:28180b3:                         } else {
1:28180b3:                             result.add(ref);
1:28180b3:                             count++;
1:28180b3:                         }
1:28180b3:                     }
1:28180b3:                 } finally {
1:28180b3:                     messages.release();
1:28180b3:                 }
1:28180b3:             } finally {
1:28180b3:                 messagesLock.writeLock().unlock();
1:28180b3:             }
1:6e468b4: 
1:b29ccf3:             if (count > 0) {
1:b29ccf3:                 // Only add new messages, not already pagedIn to avoid multiple
1:b29ccf3:                 // dispatch attempts
1:b29ccf3:                 pagedInMessagesLock.writeLock().lock();
1:b29ccf3:                 try {
1:b29ccf3:                     if (isPrioritizedMessages()) {
1:b29ccf3:                         resultList = new PrioritizedPendingList();
1:28180b3:                     } else {
1:b29ccf3:                         resultList = new OrderedPendingList();
1:b29ccf3:                     }
1:b29ccf3:                     for (QueueMessageReference ref : result) {
1:b29ccf3:                         if (!pagedInMessages.contains(ref)) {
1:b29ccf3:                             pagedInMessages.addMessageLast(ref);
1:b29ccf3:                             resultList.addMessageLast(ref);
1:b29ccf3:                         } else {
1:b29ccf3:                             ref.decrementReferenceCount();
1:b29ccf3:                             // store should have trapped duplicate in it's index, or cursor audit trapped insert
1:b29ccf3:                             // or producerBrokerExchange suppressed send.
1:b29ccf3:                             // note: jdbc store will not trap unacked messages as a duplicate b/c it gives each message a unique sequence id
1:b29ccf3:                             LOG.warn("{}, duplicate message {} - {} from cursor, is cursor audit disabled or too constrained? Redirecting to dlq", this, ref.getMessageId(), ref.getMessage().getMessageId().getFutureOrSequenceLong());
1:b29ccf3:                             if (store != null) {
1:b29ccf3:                                 ConnectionContext connectionContext = createConnectionContext();
1:b29ccf3:                                 dropMessage(ref);
1:b29ccf3:                                 if (gotToTheStore(ref.getMessage())) {
1:b29ccf3:                                     LOG.debug("Duplicate message {} from cursor, removing from store", this, ref.getMessage());
1:b29ccf3:                                     store.removeMessage(connectionContext, new MessageAck(ref.getMessage(), MessageAck.POSION_ACK_TYPE, 1));
1:b29ccf3:                                 }
1:b29ccf3:                                 broker.getRoot().sendToDeadLetterQueue(connectionContext, ref.getMessage(), null, new Throwable("duplicate paged in from cursor for " + destination));
1:2b1cda1:                             }
1:cc47ab6:                         }
1:28180b3:                     }
1:b29ccf3:                 } finally {
1:b29ccf3:                     pagedInMessagesLock.writeLock().unlock();
1:28180b3:                 }
1:0608175:             } else if (!messages.hasSpace()) {
1:0608175:                 if (isFlowControlLogRequired()) {
1:0608175:                     LOG.warn("{} cursor blocked, no space available to page in messages; usage: {}", this, this.systemUsage.getMemoryUsage());
1:0608175:                 } else {
1:0608175:                     LOG.debug("{} cursor blocked, no space available to page in messages; usage: {}", this, this.systemUsage.getMemoryUsage());
1:0608175:                 }
1:28180b3:             }
1:28180b3:         }
1:960e65d: 
1:57a6f23:         // Avoid return null list, if condition is not validated
1:57a6f23:         return resultList != null ? resultList : new OrderedPendingList();
1:28180b3:     }
1:28180b3: 
1:a3a8c1c:     private final boolean haveRealConsumer() {
1:a3a8c1c:         return consumers.size() - browserDispatches.size() > 0;
1:a3a8c1c:     }
1:a3a8c1c: 
1:cb1b92b:     private void doDispatch(PendingList list) throws Exception {
1:8d9f47a:         boolean doWakeUp = false;
1:c459784: 
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:28180b3:         try {
1:5af5b59:             if (isPrioritizedMessages() && !dispatchPendingList.isEmpty() && list != null && !list.isEmpty()) {
1:5af5b59:                 // merge all to select priority order
1:5af5b59:                 for (MessageReference qmr : list) {
1:5af5b59:                     if (!dispatchPendingList.contains(qmr)) {
1:5af5b59:                         dispatchPendingList.addMessageLast(qmr);
1:5af5b59:                     }
1:5af5b59:                 }
1:5af5b59:                 list = null;
1:5af5b59:             }
1:5af5b59: 
1:efc9a8d:             doActualDispatch(dispatchPendingList);
1:60ad053:             // and now see if we can dispatch the new stuff.. and append to the pending
1:60ad053:             // list anything that does not actually get dispatched.
1:60ad053:             if (list != null && !list.isEmpty()) {
1:efc9a8d:                 if (dispatchPendingList.isEmpty()) {
1:efc9a8d:                     dispatchPendingList.addAll(doActualDispatch(list));
1:60ad053:                 } else {
1:60ad053:                     for (MessageReference qmr : list) {
1:efc9a8d:                         if (!dispatchPendingList.contains(qmr)) {
1:efc9a8d:                             dispatchPendingList.addMessageLast(qmr);
1:52e1a05:                         }
1:28180b3:                     }
1:60ad053:                     doWakeUp = true;
1:28180b3:                 }
1:28180b3:             }
1:28180b3:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:28180b3:         }
1:28180b3: 
1:8d9f47a:         if (doWakeUp) {
1:89eecad:             // avoid lock order contention
1:89eecad:             asyncWakeup();
1:28180b3:         }
1:28180b3:     }
1:47cfa55: 
1:e2cafda:     /**
1:b6115cf:      * @return list of messages that could get dispatched to consumers if they
1:b6115cf:      *         were not full.
1:e2cafda:      */
1:cb1b92b:     private PendingList doActualDispatch(PendingList list) throws Exception {
1:e2cafda:         List<Subscription> consumers;
1:60ad053:         consumersLock.readLock().lock();
1:47cfa55: 
1:28180b3:         try {
1:30f531d:             if (this.consumers.isEmpty()) {
1:f9d5449:                 // slave dispatch happens in processDispatchNotification
1:2a5ad36:                 return list;
1:63b2c40:             }
1:e2cafda:             consumers = new ArrayList<Subscription>(this.consumers);
1:28180b3:         } finally {
1:60ad053:             consumersLock.readLock().unlock();
1:63b2c40:         }
1:e2cafda: 
1:184761a:         Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());
1:e2cafda: 
1:cb1b92b:         for (Iterator<MessageReference> iterator = list.iterator(); iterator.hasNext();) {
1:e2cafda: 
1:540b1c6:             MessageReference node = iterator.next();
1:e2cafda:             Subscription target = null;
1:e2cafda:             for (Subscription s : consumers) {
1:f54713a:                 if (s instanceof QueueBrowserSubscription) {
1:f81d0d5:                     continue;
1:63b2c40:                 }
1:a526a60:                 if (!fullConsumers.contains(s)) {
1:e2cafda:                     if (!s.isFull()) {
1:a526a60:                         if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {
1:e2cafda:                             // Dispatch it.
1:e2cafda:                             s.add(node);
1:f92d45b:                             LOG.trace("assigned {} to consumer {}", node.getMessageId(), s.getConsumerInfo().getConsumerId());
1:2a5ad36:                             iterator.remove();
1:27262c8:                             target = s;
1:00879cf:                             break;
1:b6115cf:                         }
1:52e1a05:                     } else {
1:27262c8:                         // no further dispatch of list to a full consumer to
1:27262c8:                         // avoid out of order message receipt
1:a526a60:                         fullConsumers.add(s);
1:a526a60:                         LOG.trace("Subscription full {}", s);
1:b8d5ca8:                     }
1:b6115cf:                 }
1:47cfa55:             }
1:b8d5ca8: 
1:b8d5ca8:             if (target == null && node.isDropped()) {
1:b8d5ca8:                 iterator.remove();
1:47cfa55:             }
1:e2cafda: 
1:2a5ad36:             // return if there are no consumers or all consumers are full
1:b8d5ca8:             if (target == null && consumers.size() == fullConsumers.size()) {
1:2a5ad36:                 return list;
1:e2cafda:             }
1:e2cafda: 
1:27262c8:             // If it got dispatched, rotate the consumer list to get round robin
1:27262c8:             // distribution.
1:27262c8:             if (target != null && !strictOrderDispatch && consumers.size() > 1
1:27262c8:                     && !dispatchSelector.isExclusiveConsumer(target)) {
1:28180b3:                 consumersLock.writeLock().lock();
1:28180b3:                 try {
1:48764be:                     if (removeFromConsumerList(target)) {
1:e2cafda:                         addToConsumerList(target);
1:e2cafda:                         consumers = new ArrayList<Subscription>(this.consumers);
1:e2cafda:                     }
1:2e137fb:                 } finally {
1:28180b3:                     consumersLock.writeLock().unlock();
1:e2cafda:                 }
1:e2cafda:             }
1:cdc2fd3:         }
1:e2cafda: 
1:184761a:         return list;
1:2e137fb:     }
1:e2cafda: 
1:227ed96:     protected boolean assignMessageGroup(Subscription subscription, QueueMessageReference node) throws Exception {
1:227ed96:         boolean result = true;
1:227ed96:         // Keep message groups together.
1:227ed96:         String groupId = node.getGroupID();
1:227ed96:         int sequence = node.getGroupSequence();
1:227ed96:         if (groupId != null) {
1:8768a04: 
1:227ed96:             MessageGroupMap messageGroupOwners = getMessageGroupOwners();
1:227ed96:             // If we can own the first, then no-one else should own the
1:227ed96:             // rest.
1:227ed96:             if (sequence == 1) {
1:227ed96:                 assignGroup(subscription, messageGroupOwners, node, groupId);
1:28180b3:             } else {
1:d4382e4: 
1:227ed96:                 // Make sure that the previous owner is still valid, we may
1:227ed96:                 // need to become the new owner.
1:227ed96:                 ConsumerId groupOwner;
1:d4382e4: 
1:227ed96:                 groupOwner = messageGroupOwners.get(groupId);
1:227ed96:                 if (groupOwner == null) {
1:227ed96:                     assignGroup(subscription, messageGroupOwners, node, groupId);
1:28180b3:                 } else {
1:227ed96:                     if (groupOwner.equals(subscription.getConsumerInfo().getConsumerId())) {
1:227ed96:                         // A group sequence < 1 is an end of group signal.
1:227ed96:                         if (sequence < 0) {
1:227ed96:                             messageGroupOwners.removeGroup(groupId);
1:5d697cf:                             subscription.getConsumerInfo().decrementAssignedGroupCount(destination);
1:2e137fb:                         }
1:63b2c40:                     } else {
1:227ed96:                         result = false;
1:2e137fb:                     }
1:2e137fb:                 }
1:2e137fb:             }
1:2e137fb:         }
1:2db7df7: 
1:071b4b1:         return result;
1:2e137fb:     }
1:6895d00: 
1:227ed96:     protected void assignGroup(Subscription subs, MessageGroupMap messageGroupOwners, MessageReference n, String groupId) throws IOException {
1:227ed96:         messageGroupOwners.put(groupId, subs.getConsumerInfo().getConsumerId());
1:227ed96:         Message message = n.getMessage();
1:dd91e85:         message.setJMSXGroupFirstForConsumer(true);
1:5d697cf:         subs.getConsumerInfo().incrementAssignedGroupCount(destination);
1:2e137fb:     }
1:6895d00: 
1:a3a8c1c:     protected void pageInMessages(boolean force, int maxPageSize) throws Exception {
1:a3a8c1c:         doDispatch(doPageInForDispatch(force, true, maxPageSize));
1:d4382e4:     }
1:6895d00: 
1:2a153b0:     private void addToConsumerList(Subscription sub) {
1:2a153b0:         if (useConsumerPriority) {
1:2a153b0:             consumers.add(sub);
1:f4971bf:             Collections.sort(consumers, orderedCompare);
1:47cfa55:         } else {
1:2a153b0:             consumers.add(sub);
1:2a153b0:         }
1:2a153b0:     }
1:2a153b0: 
1:5269519:     private boolean removeFromConsumerList(Subscription sub) {
1:5269519:         return consumers.remove(sub);
1:2a153b0:     }
1:2db7df7: 
1:044c07d:     private int getConsumerMessageCountBeforeFull() throws Exception {
1:044c07d:         int total = 0;
1:28180b3:         consumersLock.readLock().lock();
1:d4382e4:         try {
1:044c07d:             for (Subscription s : consumers) {
1:a3a8c1c:                 if (s.isBrowser()) {
1:a3a8c1c:                     continue;
1:a3a8c1c:                 }
1:c8bd57c:                 int countBeforeFull = s.countBeforeFull();
1:93ccb9c:                 total += countBeforeFull;
1:93ccb9c:             }
1:f81d0d5:         } finally {
1:28180b3:             consumersLock.readLock().unlock();
1:044c07d:         }
1:044c07d:         return total;
1:044c07d:     }
1:044c07d: 
1:f9d5449:     /*
1:48764be:      * In slave mode, dispatch is ignored till we get this notification as the
1:48764be:      * dispatch process is non deterministic between master and slave. On a
1:48764be:      * notification, the actual dispatch to the subscription (as chosen by the
1:48764be:      * master) is completed. (non-Javadoc)
1:48764be:      * @see
1:48764be:      * org.apache.activemq.broker.region.BaseDestination#processDispatchNotification
1:48764be:      * (org.apache.activemq.command.MessageDispatchNotification)
1:f9d5449:      */
1:ea84378:     @Override
1:48764be:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
1:f9d5449:         // do dispatch
1:f9d5449:         Subscription sub = getMatchingSubscription(messageDispatchNotification);
1:f9d5449:         if (sub != null) {
1:f9d5449:             MessageReference message = getMatchingMessage(messageDispatchNotification);
1:f9d5449:             sub.add(message);
1:f9d5449:             sub.processMessageDispatchNotification(messageDispatchNotification);
1:044c07d:         }
1:2a153b0:     }
1:2db7df7: 
1:27262c8:     private QueueMessageReference getMatchingMessage(MessageDispatchNotification messageDispatchNotification)
1:27262c8:             throws Exception {
1:f9d5449:         QueueMessageReference message = null;
1:f9d5449:         MessageId messageId = messageDispatchNotification.getMessageId();
1:cb1b92b: 
1:28180b3:         pagedInPendingDispatchLock.writeLock().lock();
1:28180b3:         try {
1:efc9a8d:             for (MessageReference ref : dispatchPendingList) {
1:28180b3:                 if (messageId.equals(ref.getMessageId())) {
1:cb1b92b:                     message = (QueueMessageReference)ref;
1:efc9a8d:                     dispatchPendingList.remove(ref);
1:28180b3:                     break;
1:d4382e4:                 }
1:d4382e4:             }
1:28180b3:         } finally {
1:28180b3:             pagedInPendingDispatchLock.writeLock().unlock();
1:d4382e4:         }
1:28180b3: 
1:28180b3:         if (message == null) {
1:28180b3:             pagedInMessagesLock.readLock().lock();
1:28180b3:             try {
1:e947927:                 message = (QueueMessageReference)pagedInMessages.get(messageId);
1:28180b3:             } finally {
1:28180b3:                 pagedInMessagesLock.readLock().unlock();
1:28180b3:             }
1:28180b3:         }
1:28180b3: 
1:28180b3:         if (message == null) {
1:28180b3:             messagesLock.writeLock().lock();
1:28180b3:             try {
1:28180b3:                 try {
1:28180b3:                     messages.setMaxBatchSize(getMaxPageSize());
1:28180b3:                     messages.reset();
1:28180b3:                     while (messages.hasNext()) {
1:28180b3:                         MessageReference node = messages.next();
1:28180b3:                         messages.remove();
1:28180b3:                         if (messageId.equals(node.getMessageId())) {
1:28180b3:                             message = this.createMessageReference(node.getMessage());
1:28180b3:                             break;
1:28180b3:                         }
1:28180b3:                     }
1:28180b3:                 } finally {
1:28180b3:                     messages.release();
1:28180b3:                 }
1:28180b3:             } finally {
1:28180b3:                 messagesLock.writeLock().unlock();
1:28180b3:             }
1:28180b3:         }
1:28180b3: 
1:28180b3:         if (message == null) {
1:28180b3:             Message msg = loadMessage(messageId);
1:28180b3:             if (msg != null) {
1:28180b3:                 message = this.createMessageReference(msg);
1:28180b3:             }
1:28180b3:         }
1:28180b3: 
4:f9d5449:         if (message == null) {
1:27262c8:             throw new JMSException("Slave broker out of sync with master - Message: "
1:27262c8:                     + messageDispatchNotification.getMessageId() + " on "
1:27262c8:                     + messageDispatchNotification.getDestination() + " does not exist among pending("
1:efc9a8d:                     + dispatchPendingList.size() + ") for subscription: "
1:27262c8:                     + messageDispatchNotification.getConsumerId());
1:d4382e4:         }
1:f9d5449:         return message;
1:d4382e4:     }
1:cb1b92b: 
1:f9d5449:     /**
1:f9d5449:      * Find a consumer that matches the id in the message dispatch notification
1:c1ebbc1:      *
1:f9d5449:      * @param messageDispatchNotification
1:f9d5449:      * @return sub or null if the subscription has been removed before dispatch
1:f9d5449:      * @throws JMSException
1:f9d5449:      */
1:27262c8:     private Subscription getMatchingSubscription(MessageDispatchNotification messageDispatchNotification)
1:27262c8:             throws JMSException {
1:f9d5449:         Subscription sub = null;
1:28180b3:         consumersLock.readLock().lock();
1:28180b3:         try {
1:d4382e4:             for (Subscription s : consumers) {
1:f9d5449:                 if (messageDispatchNotification.getConsumerId().equals(s.getConsumerInfo().getConsumerId())) {
1:f9d5449:                     sub = s;
1:47cfa55:                     break;
1:d4382e4:                 }
1:d4382e4:             }
1:f81d0d5:         } finally {
1:28180b3:             consumersLock.readLock().unlock();
1:d4382e4:         }
1:f9d5449:         return sub;
1:d4382e4:     }
1:d5b604e: 
1:540b1c6:     @Override
1:f24b4f7:     public void onUsageChanged(@SuppressWarnings("rawtypes") Usage usage, int oldPercentUsage, int newPercentUsage) {
1:08aecbe:         if (oldPercentUsage > newPercentUsage) {
1:8d9f47a:             asyncWakeup();
1:f81d0d5:         }
1:f81d0d5:     }
1:d5b604e: 
1:540b1c6:     @Override
1:8bf987b:     protected Logger getLog() {
1:a0d2282:         return LOG;
1:f81d0d5:     }
1:f4d4c3b: 
1:f4d4c3b:     protected boolean isOptimizeStorage(){
1:f4d4c3b:         boolean result = false;
1:f4d4c3b:         if (isDoOptimzeMessageStorage()){
1:f4d4c3b:             consumersLock.readLock().lock();
1:f4d4c3b:             try{
1:f4d4c3b:                 if (consumers.isEmpty()==false){
1:f4d4c3b:                     result = true;
1:f4d4c3b:                     for (Subscription s : consumers) {
1:f4d4c3b:                         if (s.getPrefetchSize()==0){
1:f4d4c3b:                             result = false;
1:f4d4c3b:                             break;
1:f4d4c3b:                         }
1:f4d4c3b:                         if (s.isSlowConsumer()){
1:f4d4c3b:                             result = false;
1:f4d4c3b:                             break;
1:f4d4c3b:                         }
1:ca83305:                         if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){
1:f4d4c3b:                             result = false;
1:f4d4c3b:                             break;
1:f4d4c3b:                         }
1:f4d4c3b:                     }
1:f4d4c3b:                 }
1:c50b8e4:             } finally {
1:f4d4c3b:                 consumersLock.readLock().unlock();
1:f4d4c3b:             }
1:f4d4c3b:         }
1:f4d4c3b:         return result;
1:f4d4c3b:     }
1:2a328ed: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:57a6f23
/////////////////////////////////////////////////////////////////////////
1:         // Avoid return null list, if condition is not validated
1:         return resultList != null ? resultList : new OrderedPendingList();
commit:1ebf186
/////////////////////////////////////////////////////////////////////////
1:                     ActiveMQDestination originalDestination = m.getMessage().getOriginalDestination();
1:                     if (originalDestination != null) {
1:                         for (Destination destination : regionBroker.getDestinations(originalDestination)) {
1:                             DeadLetterStrategy strategy = destination.getDeadLetterStrategy();
1:                             strategy.rollback(m.getMessage());
1:                         }
1:                     }
commit:cdb38b3
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean expiryTaskInProgress = new AtomicBoolean(false);
1:     private final Runnable expireMessagesWork = new Runnable() {
1:             expiryTaskInProgress.set(false);
1:         }
1:     };
1: 
1:     private final Runnable expireMessagesTask = new Runnable() {
1:         @Override
1:         public void run() {
1:             if (expiryTaskInProgress.compareAndSet(false, true)) {
1:                 taskFactory.execute(expireMessagesWork);
1:             }
commit:026c6f4
/////////////////////////////////////////////////////////////////////////
1:         return (alreadyPagedIn == 0 || (alreadyPagedIn < max)
1:                 && messages.hasSpace());
commit:2eff835
/////////////////////////////////////////////////////////////////////////
1:                         messages.rollback(r.getMessageId());
/////////////////////////////////////////////////////////////////////////
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:             } else if (!ref.isAcked() && l.contains(ref.getMessage()) == false) {
/////////////////////////////////////////////////////////////////////////
1:     public void clearPendingMessages(int pendingAdditionsCount) {
1:             final ActiveMQMessage dummyPersistent = new ActiveMQMessage();
1:             dummyPersistent.setPersistent(true);
1:             for (int i=0; i<pendingAdditionsCount; i++) {
1:                 try {
1:                     // track the increase in the cursor size w/o reverting to the store
1:                     messages.addMessageFirst(dummyPersistent);
1:                 } catch (Exception ignored) {
1:                     LOG.debug("Unexpected exception on tracking pending message additions", ignored);
1:                 }
1:             }
commit:0608175
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:                 } else {
1:                     LOG.debug("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:                             memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
1:             } else if (!messages.hasSpace()) {
1:                 if (isFlowControlLogRequired()) {
1:                     LOG.warn("{} cursor blocked, no space available to page in messages; usage: {}", this, this.systemUsage.getMemoryUsage());
1:                 } else {
1:                     LOG.debug("{} cursor blocked, no space available to page in messages; usage: {}", this, this.systemUsage.getMemoryUsage());
1:                 }
commit:dd2572b
/////////////////////////////////////////////////////////////////////////
1:     public void rollbackPendingCursorAdditions(MessageId messageId) {
1:                 if (mc.message.getMessageId().equals(messageId)) {
/////////////////////////////////////////////////////////////////////////
1:                 rollbackPendingCursorAdditions(messageContext.message.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:                     rollbackPendingCursorAdditions(message.getMessageId());
commit:f96a20e
/////////////////////////////////////////////////////////////////////////
0:     public void rollbackPendingCursorAdditions(MessageContext messageContext) {
1:         synchronized (indexOrderedCursorUpdates) {
1:             for (int i = indexOrderedCursorUpdates.size() - 1; i >= 0; i--) {
1:                 MessageContext mc = indexOrderedCursorUpdates.get(i);
0:                 if (mc.message.getMessageId().equals(messageContext.message.getMessageId())) {
1:                     indexOrderedCursorUpdates.remove(mc);
1:                     if (mc.onCompletion != null) {
1:                         mc.onCompletion.run();
1:                     }
1:                     break;
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (store != null && messageContext.message.isPersistent()) {
0:                 rollbackPendingCursorAdditions(messageContext);
1:             }
commit:b29ccf3
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (count > 0) {
1:                 // Only add new messages, not already pagedIn to avoid multiple
1:                 // dispatch attempts
1:                 pagedInMessagesLock.writeLock().lock();
1:                 try {
1:                     if (isPrioritizedMessages()) {
1:                         resultList = new PrioritizedPendingList();
1:                         resultList = new OrderedPendingList();
1:                     }
1:                     for (QueueMessageReference ref : result) {
1:                         if (!pagedInMessages.contains(ref)) {
1:                             pagedInMessages.addMessageLast(ref);
1:                             resultList.addMessageLast(ref);
1:                         } else {
1:                             ref.decrementReferenceCount();
1:                             // store should have trapped duplicate in it's index, or cursor audit trapped insert
1:                             // or producerBrokerExchange suppressed send.
1:                             // note: jdbc store will not trap unacked messages as a duplicate b/c it gives each message a unique sequence id
1:                             LOG.warn("{}, duplicate message {} - {} from cursor, is cursor audit disabled or too constrained? Redirecting to dlq", this, ref.getMessageId(), ref.getMessage().getMessageId().getFutureOrSequenceLong());
1:                             if (store != null) {
1:                                 ConnectionContext connectionContext = createConnectionContext();
1:                                 dropMessage(ref);
1:                                 if (gotToTheStore(ref.getMessage())) {
1:                                     LOG.debug("Duplicate message {} from cursor, removing from store", this, ref.getMessage());
1:                                     store.removeMessage(connectionContext, new MessageAck(ref.getMessage(), MessageAck.POSION_ACK_TYPE, 1));
1:                                 }
1:                                 broker.getRoot().sendToDeadLetterQueue(connectionContext, ref.getMessage(), null, new Throwable("duplicate paged in from cursor for " + destination));
1:                 } finally {
1:                     pagedInMessagesLock.writeLock().unlock();
0:             } else if (!messages.hasSpace() && isFlowControlLogRequired()) {
0:                 LOG.warn("{} cursor blocked, no space available to page in messages; usage: {}", this, this.systemUsage.getMemoryUsage());
commit:03b19b9
/////////////////////////////////////////////////////////////////////////
0:                     DeadLetterStrategy strategy = getDeadLetterStrategy();
0:                     strategy.rollback(m.getMessage());
/////////////////////////////////////////////////////////////////////////
1:         // ensure we deal with a snapshot to avoid potential duplicates in the event of messages
1:         // getting immediate dlq'ed
1:         long numberOfRetryAttemptsToCheckAllMessagesOnce = this.destinationStatistics.getMessages().getCount();
/////////////////////////////////////////////////////////////////////////
1:                 numberOfRetryAttemptsToCheckAllMessagesOnce--;
/////////////////////////////////////////////////////////////////////////
1:         } while (numberOfRetryAttemptsToCheckAllMessagesOnce > 0 && set.size() < this.destinationStatistics.getMessages().getCount());
commit:2ea5d14
/////////////////////////////////////////////////////////////////////////
1:         Set<Destination> destsToPause = regionBroker.getDestinations(dest);
1:             for (Destination d: destsToPause) {
1:                 if (d instanceof Queue) {
1:                     ((Queue)d).pauseDispatch();
1:                 }
1:             }
1:             BrokerSupport.resend(context, m.getMessage(), dest);
1:             removeMessage(context, m);
1:             messagesLock.writeLock().lock();
1:             try {
1:                 messages.rollback(m.getMessageId());
1:                 if (isDLQ()) {
0:                     DeadLetterStrategy stratagy = getDeadLetterStrategy();
0:                     stratagy.rollback(m.getMessage());
1:                 }
1:             } finally {
1:                 messagesLock.writeLock().unlock();
1:             for (Destination d: destsToPause) {
1:                 if (d instanceof Queue) {
1:                     ((Queue)d).resumeDispatch();
1:                 }
1:             }
1: 
commit:8e576be
/////////////////////////////////////////////////////////////////////////
1:                                                 "Usage Manager Memory Limit Wait Timeout. Stopping producer ("
commit:6da08b2
/////////////////////////////////////////////////////////////////////////
1:     private volatile ResourceAllocationException sendMemAllocationException = null;
/////////////////////////////////////////////////////////////////////////
1:                     ResourceAllocationException resourceAllocationException = sendMemAllocationException;
1:                     if (resourceAllocationException == null) {
1:                         synchronized (this) {
1:                             resourceAllocationException = sendMemAllocationException;
1:                             if (resourceAllocationException == null) {
1:                                 sendMemAllocationException = resourceAllocationException = new ResourceAllocationException("Usage Manager Memory Limit reached on "
1:                                         + getActiveMQDestination().getQualifiedName() + "."
1:                                         + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:                             }
1:                         }
1:                     }
1:                     throw resourceAllocationException;
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1:                         } else {
1:                             wakeup();
commit:df3bd83
/////////////////////////////////////////////////////////////////////////
0:             if (getMessages().getMessageAudit() != null) {
0:                 getMessages().getMessageAudit().clear();
1:             }
commit:99f3d4c
/////////////////////////////////////////////////////////////////////////
0:             getMessages().getMessageAudit().clear();
1: 
commit:8023b9e
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (destination.equals(dest)) {
1:             return 0;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (destination.equals(dest)) {
1:             return 0;
1:         }
1: 
commit:25f112c
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transaction.Transaction.IN_USE_STATE;
/////////////////////////////////////////////////////////////////////////
1:                                     // transaction may be done
1:                                     if (message.isInTransaction()) {
1:                                         if (context.getTransaction().getState() > IN_USE_STATE) {
1:                                             throw new JMSException("Send transaction completed while waiting for space");
1:                                         }
1:                                     }
1: 
1:                                     // the message may have expired.
1:                                         LOG.error("message expired waiting for space");
commit:a0ba0bf
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:     private AtomicInteger pendingSends = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
1:     // gate on enabling cursor cache to ensure no outstanding sync
1:     // send before async sends resume
1:     public boolean singlePendingSend() {
1:         return pendingSends.get() <= 1;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         pendingSends.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:                     pendingSends.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:         pendingSends.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                         LOG.warn("{}, duplicate message {} - {} from cursor, is cursor audit disabled or too constrained? Redirecting to dlq", this, ref.getMessageId(), ref.getMessage().getMessageId().getFutureOrSequenceLong());
commit:01b1f7f
/////////////////////////////////////////////////////////////////////////
1:                 if (isFlowControlLogRequired()) {
1:                                 memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
1:                 }
commit:e67d486
/////////////////////////////////////////////////////////////////////////
1:                                 } finally {
1:                                     getDestinationStatistics().getBlockedSends().decrement();
1:                                     producerExchangeCopy.blockingOnFlowControl(false);
1:                         getDestinationStatistics().getBlockedSends().increment();
1:                         producerExchange.blockingOnFlowControl(true);
commit:2b1cda1
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.broker.region.cursors.AbstractStoreCursor.gotToTheStore;
1: 
/////////////////////////////////////////////////////////////////////////
0:                         // store should have trapped duplicate in it's index, or cursor audit trapped insert
0:                         // or producerBrokerExchange suppressed send.
0:                         LOG.warn("{}, duplicate message {} from cursor, is cursor audit disabled or too constrained? Redirecting to dlq", this, ref.getMessage());
0:                             dropMessage(ref);
0:                             if (gotToTheStore(ref.getMessage())) {
0:                                 LOG.debug("Duplicate message {} from cursor, removing from store", this, ref.getMessage());
0:                                 store.removeMessage(connectionContext, new MessageAck(ref.getMessage(), MessageAck.POSION_ACK_TYPE, 1));
1:                             }
0:                             broker.getRoot().sendToDeadLetterQueue(connectionContext, ref.getMessage(), null, new Throwable("duplicate paged in from cursor for " + destination));
commit:b4e35fe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             boolean hasBrowsers = !browserDispatches.isEmpty();
/////////////////////////////////////////////////////////////////////////
1:                 PendingList messagesInMemory = isPrioritizedMessages() ?
1:                 try {
1:                     messagesInMemory.addAll(pagedInMessages);
1:                 } finally {
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("dispatch to browser: {}, already dispatched/paged count: {}", browser, messagesInMemory.size());
1:                         for (MessageReference node : messagesInMemory) {
/////////////////////////////////////////////////////////////////////////
1:         int toPageIn = maxPageSize;
1:         messagesLock.readLock().lock();
1:         try {
1:             toPageIn = Math.min(toPageIn, messages.size());
1:         } finally {
1:             messagesLock.readLock().unlock();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             toPageIn = Math.min(toPageIn, getConsumerMessageCountBeforeFull());
commit:f47b370
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<MessageReference> unackedListIterator = unAckedMessages.iterator(); unackedListIterator.hasNext(); ) {
1:                     MessageReference ref = unackedListIterator.next();
/////////////////////////////////////////////////////////////////////////
1:                     if (qmr.isDropped()) {
1:                         unackedListIterator.remove();
1:                 dispatchPendingList.addForRedelivery(unAckedMessages, strictOrderDispatch && consumers.isEmpty());
commit:a3a8c1c
/////////////////////////////////////////////////////////////////////////
1:             if (max > 0) {
1:                 messagesLock.readLock().lock();
1:                 try {
1:                     maxPageInAttempts += (messages.size() / max);
1:                 } finally {
1:                     messagesLock.readLock().unlock();
1:                 }
1:                 while (shouldPageInMoreForBrowse(max) && maxPageInAttempts-- > 0) {
1:                     pageInMessages(!memoryUsage.isFull(110), max);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             doPageIn(true, false, getMaxPageSize());  // signal no expiry processing needed.
/////////////////////////////////////////////////////////////////////////
1:                     pageInMessages(hasBrowsers && getMaxBrowsePageSize() > 0, getMaxPageSize());
/////////////////////////////////////////////////////////////////////////
1:         doPageIn(force, true, getMaxPageSize());
1:     private void doPageIn(boolean force, boolean processExpired, int maxPageSize) throws Exception {
1:         PendingList newlyPaged = doPageInForDispatch(force, processExpired, maxPageSize);
/////////////////////////////////////////////////////////////////////////
1:     private PendingList doPageInForDispatch(boolean force, boolean processExpired, int maxPageSize) throws Exception {
0:         int toPageIn = Math.min(maxPageSize, messages.size());
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("{} toPageIn: {}, force:{}, Inflight: {}, pagedInMessages.size {}, pagedInPendingDispatch.size {}, enqueueCount: {}, dequeueCount: {}, memUsage:{}, maxPageSize:{}",
1:                     new Object[]{
1:                             this,
1:                             toPageIn,
1:                             force,
1:                             destinationStatistics.getInflight().getCount(),
1:                             pagedInMessages.size(),
1:                             pagedInPendingSize,
1:                             destinationStatistics.getEnqueues().getCount(),
1:                             destinationStatistics.getDequeues().getCount(),
1:                             getMemoryUsage().getUsage(),
1:                             maxPageSize
1:                     });
1:         }
1: 
1:         if (toPageIn > 0 && (force || (haveRealConsumer() && pagedInPendingSize < maxPageSize))) {
/////////////////////////////////////////////////////////////////////////
1:                     while (count < toPageIn && messages.hasNext()) {
/////////////////////////////////////////////////////////////////////////
1:     private final boolean haveRealConsumer() {
1:         return consumers.size() - browserDispatches.size() > 0;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void pageInMessages(boolean force, int maxPageSize) throws Exception {
1:         doDispatch(doPageInForDispatch(force, true, maxPageSize));
/////////////////////////////////////////////////////////////////////////
1:                 if (s.isBrowser()) {
1:                     continue;
1:                 }
commit:13ec994
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
0:                                     memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ({}) reached (%{}) on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
0:                                     memoryUsage.getLimit(), memoryUsage.getPercentUsage(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
commit:499e39e
/////////////////////////////////////////////////////////////////////////
1:             message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
1:             if (store != null && message.isPersistent()) {
1:                 message.getMessageId().setFutureOrSequenceLong(null);
1:                 try {
0:                     if (messages.isCacheEnabled()) {
1:                         result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
1:                         result.addListener(new PendingMarshalUsageTracker(message));
1:                     } else {
1:                         store.addMessage(context, message);
0:                     if (isReduceMemoryFootprint()) {
0:                         message.clearMarshalledState();
1:                     }
1:                 } catch (Exception e) {
1:                     // we may have a store in inconsistent state, so reset the cursor
1:                     // before restarting normal broker operations
1:                     resetNeeded = true;
1:                     throw e;
1:             }
1:             if(tryOrderedCursorAdd(message, context)) {
1:                 break;
commit:5af5b59
/////////////////////////////////////////////////////////////////////////
1:             if (isPrioritizedMessages() && !dispatchPendingList.isEmpty() && list != null && !list.isEmpty()) {
1:                 // merge all to select priority order
1:                 for (MessageReference qmr : list) {
1:                     if (!dispatchPendingList.contains(qmr)) {
1:                         dispatchPendingList.addMessageLast(qmr);
1:                     }
1:                 }
1:                 list = null;
1:             }
1: 
commit:2b84cd6
/////////////////////////////////////////////////////////////////////////
0:                 PendingList alreadyDispatchedMessages = isPrioritizedMessages() ?
1:                         new PrioritizedPendingList() : new OrderedPendingList();
0:                     alreadyDispatchedMessages.addAll(pagedInMessages);
commit:93092f7
/////////////////////////////////////////////////////////////////////////
1:             message.setRegionDestination(Queue.this);
commit:15412ba
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerStoppedException;
/////////////////////////////////////////////////////////////////////////
1:         } catch (BrokerStoppedException ignored) {
commit:5d697cf
/////////////////////////////////////////////////////////////////////////
1:                 long x = s1.getConsumerInfo().getAssignedGroupCount(destination);
1:                 long y = s2.getConsumerInfo().getAssignedGroupCount(destination);
/////////////////////////////////////////////////////////////////////////
1:                     sub.getConsumerInfo().getAssignedGroupCount(destination)
/////////////////////////////////////////////////////////////////////////
1:                             subscription.getConsumerInfo().decrementAssignedGroupCount(destination);
/////////////////////////////////////////////////////////////////////////
1:         subs.getConsumerInfo().incrementAssignedGroupCount(destination);
commit:b6fea83
/////////////////////////////////////////////////////////////////////////
0:                 message.getMessageId().setFutureOrSequenceLong(null);
commit:23ecbe8
/////////////////////////////////////////////////////////////////////////
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
1:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId)
1:         super.removeSubscription(context, sub, lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
1:                     lastDeliveredSequenceId,
/////////////////////////////////////////////////////////////////////////
1:                 if (lastDeliveredSequenceId > RemoveInfo.LAST_DELIVERED_UNSET) {
1:                         if (ref.getMessageId().getBrokerSequenceId() == lastDeliveredSequenceId) {
1:                             LOG.debug("found lastDeliveredSeqID: {}, message reference: {}", lastDeliveredSequenceId, ref.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:                         if (lastDeliveredSequenceId == RemoveInfo.LAST_DELIVERED_UNKNOWN) {
/////////////////////////////////////////////////////////////////////////
0:             message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
commit:ab28b77
/////////////////////////////////////////////////////////////////////////
1:                 destinationStatistics.getMessages().add(messageCount);
commit:85b9c81
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void pauseDispatch() {
1:         dispatchSelector.pause();
1:     }
1: 
1:     public void resumeDispatch() {
1:         dispatchSelector.resume();
1:     }
1: 
1:     public boolean isDispatchPaused() {
1:         return dispatchSelector.isPaused();
1:     }
1: 
commit:849987e
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("found lastDeliveredSeqID: {}, message reference: {}", lastDeiveredSequenceId, ref.getMessageId());
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
0:                 if (lastDeiveredSequenceId > 0) {
0:                             LOG.error("found lastDeliveredSeqID: {}, message reference: {}", lastDeiveredSequenceId, ref.getMessageId());
commit:13c2072
/////////////////////////////////////////////////////////////////////////
1:                 + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + destinationStatistics.getMessages().getCount() + ", pending="
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // after successful store update
1:         reference.setAcked(true);
commit:d25c52c
/////////////////////////////////////////////////////////////////////////
1:             messageGroupOwners.setDestination(this);
commit:60ad053
/////////////////////////////////////////////////////////////////////////
0:                 long x = s1.getConsumerInfo().getAssignedGroupCount();
0:                 long y = s2.getConsumerInfo().getAssignedGroupCount();
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} add sub: {}, dequeues: {}, dispatched: {}, inflight: {}", new Object[]{ getActiveMQDestination().getQualifiedName(), sub, getDestinationStatistics().getDequeues().getCount(), getDestinationStatistics().getDispatched().getCount(), getDestinationStatistics().getInflight().getCount() });
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("{} remove sub: {}, lastDeliveredSeqId: {}, dequeues: {}, dispatched: {}, inflight: {}, groups: {}", new Object[]{
1:                     getDestinationStatistics().getInflight().getCount(),
0:                     sub.getConsumerInfo().getAssignedGroupCount()
/////////////////////////////////////////////////////////////////////////
1:             }
1:             // and now see if we can dispatch the new stuff.. and append to the pending
1:             // list anything that does not actually get dispatched.
1:             if (list != null && !list.isEmpty()) {
0:                 if (redeliveredWaitingDispatch.isEmpty() && pagedInPendingDispatch.isEmpty()) {
0:                     pagedInPendingDispatch.addAll(doActualDispatch(list));
1:                 } else {
1:                     for (MessageReference qmr : list) {
0:                         if (!pagedInPendingDispatch.contains(qmr)) {
0:                             pagedInPendingDispatch.addMessageLast(qmr);
1:                     doWakeUp = true;
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
1:             consumersLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:                             subscription.getConsumerInfo().decrementAssignedGroupCount();
/////////////////////////////////////////////////////////////////////////
0:         subs.getConsumerInfo().incrementAssignedGroupCount();
commit:74f530a
/////////////////////////////////////////////////////////////////////////
0:             doBrowseList(browseList, max, redeliveredWaitingDispatch, pagedInPendingDispatchLock, connectionContext, "redeliveredWaitingDispatch");
commit:52e1a05
/////////////////////////////////////////////////////////////////////////
0:             if (redeliveredWaitingDispatch.isEmpty()) {
0:                 if (!pagedInPendingDispatch.isEmpty()) {
0:                     // Next dispatch anything that had not been
0:                     // dispatched before.
0:                     pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);
1:                 }
0:                 // and now see if we can dispatch the new stuff.. and append to the pending
0:                 // list anything that does not actually get dispatched.
0:                 if (list != null && !list.isEmpty()) {
0:                     if (pagedInPendingDispatch.isEmpty()) {
0:                         pagedInPendingDispatch.addAll(doActualDispatch(list));
1:                     } else {
0:                         for (MessageReference qmr : list) {
0:                             if (!pagedInPendingDispatch.contains(qmr)) {
0:                                 pagedInPendingDispatch.addMessageLast(qmr);
1:                             }
0:                         doWakeUp = true;
commit:33089f3
/////////////////////////////////////////////////////////////////////////
0:                 + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + size + ", pending="
1:                 + indexOrderedCursorUpdates.size();
/////////////////////////////////////////////////////////////////////////
0:                         this,
commit:67ead20
/////////////////////////////////////////////////////////////////////////
1:         messagesLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:             messagesLock.writeLock().unlock();
commit:9c2b1d2
/////////////////////////////////////////////////////////////////////////
1:             messagesLock.writeLock().lock();
1:             try {
1:                 for (MessageContext messageContext : orderedUpdates) {
1:                     if (!messages.addMessageLast(messageContext.message)) {
1:                         // cursor suppressed a duplicate
1:                         messageContext.duplicate = true;
1:                     }
1:                     if (messageContext.onCompletion != null) {
1:                         messageContext.onCompletion.run();
1:                     }
1:             } finally {
1:                 messagesLock.writeLock().unlock();
commit:8216e7f
/////////////////////////////////////////////////////////////////////////
1:             int maxPageInAttempts = 1;
1:             messagesLock.readLock().lock();
1:             try {
0:                 maxPageInAttempts += (messages.size() / getMaxPageSize());
1:             } finally {
1:                 messagesLock.readLock().unlock();
1:             }
0:             while (shouldPageInMoreForBrowse(max) && maxPageInAttempts-- > 0) {
commit:f19add1
/////////////////////////////////////////////////////////////////////////
1:         long originalMessageCount = this.destinationStatistics.getMessages().getCount();
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("{} after purge of {} messages, message count stats report: {}", getActiveMQDestination().getQualifiedName(), originalMessageCount, this.destinationStatistics.getMessages().getCount());
1:         } else {
0:             LOG.info("{} purged of {} messages", getActiveMQDestination().getQualifiedName(), originalMessageCount);
commit:5861d86
/////////////////////////////////////////////////////////////////////////
1:             if (!messageContext.duplicate) {
1:                 messageSent(messageContext.context, messageContext.message);
1:             }
commit:26807cd
/////////////////////////////////////////////////////////////////////////
1:             if (ref.isExpired() && (ref.getLockOwner() == null)) {
commit:8a37f97
/////////////////////////////////////////////////////////////////////////
1:             this.messageContext.message.incrementReferenceCount();
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class Queue extends BaseDestination implements Task, UsageListener, IndexListener {
/////////////////////////////////////////////////////////////////////////
1:         if (store != null) {
1:             store.registerIndexListener(this);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private final LinkedList<MessageContext> indexOrderedCursorUpdates = new LinkedList<>();
1:     @Override
1:     public void onAdd(MessageContext messageContext) {
1:         synchronized (indexOrderedCursorUpdates) {
1:             indexOrderedCursorUpdates.addLast(messageContext);
1:         }
1:     }
1:     private void doPendingCursorAdditions() throws Exception {
1:         LinkedList<MessageContext> orderedUpdates = new LinkedList<>();
1:         sendLock.lockInterruptibly();
1:         try {
1:             synchronized (indexOrderedCursorUpdates) {
1:                 MessageContext candidate = indexOrderedCursorUpdates.peek();
1:                 while (candidate != null && candidate.message.getMessageId().getFutureOrSequenceLong() != null) {
1:                     candidate = indexOrderedCursorUpdates.removeFirst();
1:                     // check for duplicate adds suppressed by the store
1:                     if (candidate.message.getMessageId().getFutureOrSequenceLong() instanceof Long && ((Long)candidate.message.getMessageId().getFutureOrSequenceLong()).compareTo(-1l) == 0) {
1:                         LOG.warn("{} messageStore indicated duplicate add attempt for {}, suppressing duplicate dispatch", this, candidate.message.getMessageId());
1:                     } else {
1:                         orderedUpdates.add(candidate);
1:                     }
1:                     candidate = indexOrderedCursorUpdates.peek();
1:                 }
1:             }
1:             for (MessageContext messageContext : orderedUpdates) {
0:                 if (!cursorAdd(messageContext.message)) {
0:                     // cursor suppressed a duplicate
0:                     messageContext.duplicate = true;
1:                 }
1:             }
1:         } finally {
1:             sendLock.unlock();
1:         }
1:         for (MessageContext messageContext : orderedUpdates) {
0:             if (!messageContext.duplicate) {
1:                 messageSent(messageContext.context, messageContext.message);
1:             }
0:             if (messageContext.onCompletion != null) {
0:                 messageContext.onCompletion.run();
1:         orderedUpdates.clear();
1:     }
1:     final class CursorAddSync extends Synchronization {
1:         private final MessageContext messageContext;
1:         CursorAddSync(MessageContext messageContext) {
1:             this.messageContext = messageContext;
1:             if (store != null && messageContext.message.isPersistent()) {
1:                 doPendingCursorAdditions();
1:             } else {
1:                 cursorAdd(messageContext.message);
1:             messageContext.message.decrementReferenceCount();
1:             messageContext.message.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:             orderedCursorAdd(message, context);
0:         if (store == null || (!context.isInTransaction() && !message.isPersistent())) {
/////////////////////////////////////////////////////////////////////////
0:     private void orderedCursorAdd(Message message, ConnectionContext context) throws Exception {
1:         if (context.isInTransaction()) {
1:             context.getTransaction().addSynchronization(new CursorAddSync(new MessageContext(context, message, null)));
1:         } else if (store != null && message.isPersistent()) {
1:             doPendingCursorAdditions();
1:         } else {
1:             // no ordering issue with non persistent messages
0:             cursorAdd(message);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     final boolean cursorAdd(final Message msg) throws Exception {
1:             return messages.addMessageLast(msg);
commit:f158e7d
/////////////////////////////////////////////////////////////////////////
1:         int messagesInQueue = alreadyPagedIn;
1:             messagesInQueue += messages.size();
commit:4165972
/////////////////////////////////////////////////////////////////////////
0:         int messagesInQueue = 0;
1:         messagesLock.readLock().lock();
1:         try {
0:             messagesInQueue = messages.size();
1:         } finally {
1:             messagesLock.readLock().unlock();
1:         }
1: 
1:         LOG.trace("max {}, alreadyPagedIn {}, messagesCount {}, memoryUsage {}%", new Object[]{max, alreadyPagedIn, messagesInQueue, memoryUsage.getPercentUsage()});
1:                 && (alreadyPagedIn < messagesInQueue)
commit:25e3c1b
/////////////////////////////////////////////////////////////////////////
1:             if (sub != null && sub.getConsumerInfo().isNetworkSubscription()) {
1:                 getDestinationStatistics().getForwards().increment();
1:             }
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.ListenableFuture;
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
0:                                     memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
1:         ListenableFuture<Object> result = null;
/////////////////////////////////////////////////////////////////////////
0:                         result.addListener(new PendingMarshalUsageTracker(message));
/////////////////////////////////////////////////////////////////////////
1:         if (result != null && message.isResponseRequired() && !result.isCancelled()) {
commit:9c24716
/////////////////////////////////////////////////////////////////////////
1:         int alreadyPagedIn = 0;
1:             alreadyPagedIn = pagedInMessages.size();
0:         LOG.trace("max {}, alreadyPagedIn {}, messagesCount {}, memoryUsage {}%", new Object[]{max, alreadyPagedIn, destinationStatistics.getMessages().getCount(), memoryUsage.getPercentUsage()});
0:         return (alreadyPagedIn < max)
0:                 && (alreadyPagedIn < destinationStatistics.getMessages().getCount())
0:                 && messages.hasSpace();
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:             if (resetNeeded) {
1:                 messages.gc();
1:                 messages.reset();
1:                 resetNeeded = false;
1:             } else {
1:                 messages.rebase();
commit:cc47ab6
/////////////////////////////////////////////////////////////////////////
0:                         // store should have trapped duplicate in it's index, also cursor audit
0:                         // we need to remove the duplicate from the store in the knowledge that the original message may be inflight
0:                         // note: jdbc store will not trap unacked messages as a duplicate b/c it gives each message a unique sequence id
0:                         LOG.warn("{}, duplicate message {} paged in, is cursor audit disabled? Removing from store and redirecting to dlq", this, ref.getMessage());
1:                         if (store != null) {
0:                             ConnectionContext connectionContext = createConnectionContext();
0:                             store.removeMessage(connectionContext, new MessageAck(ref.getMessage(), MessageAck.POSION_ACK_TYPE, 1));
0:                             broker.getRoot().sendToDeadLetterQueue(connectionContext, ref.getMessage(), null, new Throwable("duplicate paged in from store for " + destination));
1:                         }
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("ack of {} with {}", reference.getMessageId(), ack);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.trace("assigned {} to consumer {}", node.getMessageId(), s.getConsumerInfo().getConsumerId());
commit:14d24cc
/////////////////////////////////////////////////////////////////////////
1: 
0:             while (shouldPageInMoreForBrowse(max)) {
0:                 pageInMessages(!memoryUsage.isFull(110));
1:             };
1: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean shouldPageInMoreForBrowse(int max) {
1:         pagedInMessagesLock.readLock().lock();
1:         try {
0:             int alreadyPagedIn = pagedInMessages.size();
0:             return  alreadyPagedIn < max
0:                     && alreadyPagedIn < getDestinationStatistics().getMessages().getCount()
0:                     && !memoryUsage.isFull(110);
1:         } finally {
1:             pagedInMessagesLock.readLock().unlock();
1:         }
1:     }
1: 
commit:a64976a
/////////////////////////////////////////////////////////////////////////
1:         for (MessageReference messageReference : pagedInMessages.values()) {
1:             messageReference.decrementReferenceCount();
1:         }
1:         pagedInMessages.clear();
1: 
/////////////////////////////////////////////////////////////////////////
0:             // allow some page in even if we are full and producers are blocked on pfc
0:             pageInMessages(!memoryUsage.isFull(110));
/////////////////////////////////////////////////////////////////////////
1:                     } else {
1:                         ref.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
1:                     ref.decrementReferenceCount();
1:             // we need a store iterator to walk messages on disk, independent of the cursor which is tracking
1:             // the next message batch
1:     private void addAll(Collection<? extends MessageReference> refs, List<Message> l, int max,
1:         for (Iterator<? extends MessageReference> i = refs.iterator(); i.hasNext() && l.size() < max;) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         LOG.debug("{} toPageIn: {}, Inflight: {}, pagedInMessages.size {}, pagedInPendingDispatch.size {}, enqueueCount: {}, dequeueCount: {}, memUsage:{}",
0:                 new Object[]{
0:                         destination.getPhysicalName(),
0:                         toPageIn,
0:                         destinationStatistics.getInflight().getCount(),
0:                         pagedInMessages.size(),
0:                         pagedInPendingSize,
0:                         destinationStatistics.getEnqueues().getCount(),
0:                         destinationStatistics.getDequeues().getCount(),
0:                         getMemoryUsage().getUsage()
1:                 });
1:         if (isLazyDispatch() && !force) {
1:             // Only page in the minimum number of messages which can be
1:             // dispatched immediately.
0:             toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);
1:         }
commit:511b60c
/////////////////////////////////////////////////////////////////////////
0: import javax.transaction.xa.XAException;
/////////////////////////////////////////////////////////////////////////
0:     private LinkedList<Transaction> orderIndexUpdates = new LinkedList<Transaction>();
/////////////////////////////////////////////////////////////////////////
0:             synchronized (orderIndexUpdates) {
0:             ArrayList<SendSync> syncs = new ArrayList<SendSync>(200);
0:             sendLock.lockInterruptibly();
1:             try {
0:                 synchronized (orderIndexUpdates) {
0:                     Transaction next = orderIndexUpdates.peek();
0:                     while( next!=null && next.isCommitted() ) {
0:                         syncs.add(sendSyncs.remove(orderIndexUpdates.removeFirst()));
0:                         next = orderIndexUpdates.peek();
0:                     sync.processSend();
1:             } finally {
1:                 sendLock.unlock();
1:             }
0:             for (SendSync sync : syncs) {
0:                 sync.processSent();
/////////////////////////////////////////////////////////////////////////
0:     class OrderedNonTransactionWorkTx extends Transaction {
1: 
1:         @Override
0:         public void commit(boolean onePhase) throws XAException, IOException {
1:         }
1: 
1:         @Override
0:         public void rollback() throws XAException, IOException {
1:         }
1: 
1:         @Override
0:         public int prepare() throws XAException, IOException {
0:             return 0;
1:         }
1: 
1:         @Override
0:         public TransactionId getTransactionId() {
1:             return null;
1:         }
1: 
1:         @Override
0:         public Logger getLog() {
1:             return null;
1:         }
1: 
1:         @Override
0:         public boolean isCommitted() {
1:             return true;
1:         }
1: 
1:         @Override
0:         public void addSynchronization(Synchronization s) {
1:             try {
0:                 s.beforeCommit();
1:             } catch (Exception e) {
0:                 LOG.error("Failed to add not transactional message to orderedWork", e);
1:             }
1:         }
1:     }
1: 
0:         final Transaction transaction =
0:                 message.isInTransaction() ? context.getTransaction()
0:                         : new OrderedNonTransactionWorkTx();
/////////////////////////////////////////////////////////////////////////
0:         boolean needsOrderingWithTransactions = context.isInTransaction();
/////////////////////////////////////////////////////////////////////////
0:             // did a transaction commit beat us to the index?
0:             synchronized (orderIndexUpdates) {
0:                 needsOrderingWithTransactions |= !orderIndexUpdates.isEmpty();
1:             }
0:             if (needsOrderingWithTransactions ) {
/////////////////////////////////////////////////////////////////////////
0:         if (!needsOrderingWithTransactions) {
commit:85bc9ce
/////////////////////////////////////////////////////////////////////////
0:                             if (!node.isAcked() && !browser.isDuplicate(node.getMessageId()) && !browser.atMax()) {
/////////////////////////////////////////////////////////////////////////
1:                         if (!added || browser.atMax()) {
commit:dd91e85
/////////////////////////////////////////////////////////////////////////
1:         message.setJMSXGroupFirstForConsumer(true);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:1d2226e
/////////////////////////////////////////////////////////////////////////
1:             getDestinationStatistics().getDequeues().increment();
1:             getDestinationStatistics().getMessages().decrement();
1:                 pagedInMessages.remove(reference);
commit:7123534
/////////////////////////////////////////////////////////////////////////
0:                     getDestinationStatistics().getDequeues().increment();
0:                     getDestinationStatistics().getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6e468b4
/////////////////////////////////////////////////////////////////////////
0:                     updateMetricsOnMessageDrop();
/////////////////////////////////////////////////////////////////////////
0:     private void updateMetricsOnMessageDrop() {
0:         getDestinationStatistics().getDequeues().increment();
0:         getDestinationStatistics().getMessages().decrement();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                                 //We need to update the metrics here because the drop message
0:                                 //method will only update if the message was removed from the
0:                                 //pagedInMessages list which won't happen in this case
0:                                 updateMetricsOnMessageDrop();
commit:021c828
/////////////////////////////////////////////////////////////////////////
0:                 if (pagedInMessages.remove(reference) != null) {
0:                     getDestinationStatistics().getDequeues().increment();
0:                     getDestinationStatistics().getMessages().decrement();
1:                 }
commit:35bd3ad
/////////////////////////////////////////////////////////////////////////
1:             if (systemUsage.getStoreUsage() != null) {
1:                 systemUsage.getStoreUsage().stop();
1:             }
commit:56bb079
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             sendLock.lock();
0:             long originalMessageCount = this.destinationStatistics.getMessages().getCount();
1:             do {
0:                 doPageIn(true, false, getMaxPageSize());  // signal no expiry processing needed.
1:                 pagedInMessagesLock.readLock().lock();
1:                     list = new ArrayList<MessageReference>(pagedInMessages.values());
1:                 }finally {
1:                     pagedInMessagesLock.readLock().unlock();
1:                 for (MessageReference ref : list) {
1:                     try {
1:                         QueueMessageReference r = (QueueMessageReference) ref;
1:                         removeMessage(c, r);
1:                     } catch (IOException e) {
1:                     }
1:                 }
1:                 // don't spin/hang if stats are out and there is nothing left in the
1:                 // store
1:             } while (!list.isEmpty() && this.destinationStatistics.getMessages().getCount() > 0);
1: 
1:             if (this.destinationStatistics.getMessages().getCount() > 0) {
0:                 LOG.warn("{} after purge of {} messages, message count stats report: {}", getActiveMQDestination().getQualifiedName(), originalMessageCount, this.destinationStatistics.getMessages().getCount());
1:             }
1:         } finally {
0:             sendLock.unlock();
commit:2769298
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.broker.region.cursors.AbstractStoreCursor.gotToTheStore;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     }
commit:3f7ca84
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7c3bb40
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             //Clear the unmarshalled state if the message is marshalled
1:             //Persistent messages will always be marshalled but non-persistent may not be
1:             //Specially non-persistent messages over the VM transport won't be
1:             if (isReduceMemoryFootprint() && message.isMarshalled()) {
1:                 message.clearUnMarshalledState();
1:             }
commit:1241e41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         //use dropIfLive so we only process the statistics at most one time
1:         if (reference.dropIfLive()) {
0:             getDestinationStatistics().getDequeues().increment();
0:             getDestinationStatistics().getMessages().decrement();
commit:11622b3
/////////////////////////////////////////////////////////////////////////
commit:9c8bd33
/////////////////////////////////////////////////////////////////////////
0:                         result.addListener(new PendingMarshalUsageTracker(message));
1:                     }
0:                     if (isReduceMemoryFootprint()) {
0:                         message.clearMarshalledState();
commit:b9b98a4
/////////////////////////////////////////////////////////////////////////
0:                         message.beforeMarshall(null);
commit:b2327db
/////////////////////////////////////////////////////////////////////////
1:                     //AMQ-6133 - don't store async if using persistJMSRedelivered
1:                     //This flag causes a sync update later on dispatch which can cause a race
1:                     //condition if the original add is processed after the update, which can cause
1:                     //a duplicate message to be stored
1:                     if (messages.isCacheEnabled() && !isPersistJMSRedelivered()) {
commit:75990ef
/////////////////////////////////////////////////////////////////////////
0:                         final PendingMarshalUsageTracker tracker = new PendingMarshalUsageTracker(message);
0:                         result.addListener(new Runnable() {
1:                             @Override
1:                             public void run() {
0:                                 //Execute usage tracker and then check isReduceMemoryFootprint()
0:                                 tracker.run();
0:                                 if (isReduceMemoryFootprint()) {
1:                                     try {
0:                                         message.clearMarshalledState();
0:                                     } catch (JMSException e) {
0:                                         throw new IllegalStateException(e);
1:                                     }
1:                                 }
1:                             }
1:                         });
0:                         if (isReduceMemoryFootprint()) {
0:                             message.clearMarshalledState();
1:                         }
commit:903dec6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             messageSent(context, message);
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
1:         do {
1:             checkUsage(context, producerExchange, message);
0:             sendLock.lockInterruptibly();
1:             try {
0:                 message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
0:                 if (store != null && message.isPersistent()) {
0:                     message.getMessageId().setFutureOrSequenceLong(null);
1:                     try {
0:                         if (messages.isCacheEnabled()) {
0:                             result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
0:                             result.addListener(new PendingMarshalUsageTracker(message));
1:                         } else {
0:                             store.addMessage(context, message);
1:                         }
0:                         if (isReduceMemoryFootprint()) {
0:                             message.clearMarshalledState();
1:                         }
1:                     } catch (Exception e) {
0:                         // we may have a store in inconsistent state, so reset the cursor
0:                         // before restarting normal broker operations
0:                         resetNeeded = true;
0:                         throw e;
0:                 if(tryOrderedCursorAdd(message, context)) {
1:                     break;
1:                 }
1:             } finally {
0:                 sendLock.unlock();
1:         } while (started.get());
1: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean tryOrderedCursorAdd(Message message, ConnectionContext context) throws Exception {
1:         boolean result = true;
1: 
1:             result = tryCursorAdd(message);
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:     private final boolean cursorAdd(final Message msg) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     private final boolean tryCursorAdd(final Message msg) throws Exception {
1:         messagesLock.writeLock().lock();
1:         try {
1:             return messages.tryAddMessageLast(msg, 50);
1:         } finally {
1:             messagesLock.writeLock().unlock();
1:         }
1:     }
1: 
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     public long getPendingMessageSize() {
1:         messagesLock.readLock().lock();
1:         try{
1:             return messages.messageSize();
1:         } finally {
1:             messagesLock.readLock().unlock();
1:         }
1:     }
1: 
1:     public long getPendingMessageCount() {
1:          return this.destinationStatistics.getMessages().getCount();
1:     }
1: 
commit:785b16b
/////////////////////////////////////////////////////////////////////////
1:             store.start();
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:78492fe
/////////////////////////////////////////////////////////////////////////
0:         long previousDequeueCount = -1;
0:         long previousDequeueCountRepeated = 1L;
/////////////////////////////////////////////////////////////////////////
0:                 long currentDequeueCount = this.destinationStatistics.getDequeues().getCount();
0:                 if (previousDequeueCount == currentDequeueCount) {
0:                     previousDequeueCountRepeated++;
0:                     if (previousDequeueCountRepeated >= 3) {
0:                         // Break the infinite loop in case the removal fails
0:                         // 3 times in a row -> error is fatal and not transient.
0:                         LOG.error("Aborted purge operation after attempting to delete messages failed 3 times in a row (to avoid endless looping)");
0:                         throw new RuntimeException("Purge operation failed to delete messages failed 3 times in a row (to avoid endless looping)");
1:                     }
1:                 } else {
0:                     previousDequeueCount = currentDequeueCount;
0:                     previousDequeueCountRepeated = 0L;
1:                 }
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:             ThreadPoolUtils.shutdownNow(executor);
1:             executor = null;
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8031d77
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean resetNeeded;
commit:078a101
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.OrderedPendingList;
1: import org.apache.activemq.broker.region.cursors.PendingList;
1: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1: import org.apache.activemq.broker.region.cursors.PrioritizedPendingList;
1: import org.apache.activemq.broker.region.cursors.QueueDispatchPendingList;
1: import org.apache.activemq.broker.region.cursors.StoreQueueCursor;
1: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
1:         wakeup();
commit:f7cbe9f
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Comparator;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.LinkedHashSet;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatchNotification;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerAck;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean started = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList<Transaction> orderIndexUpdates = new LinkedList<Transaction>();
/////////////////////////////////////////////////////////////////////////
1:         if (started.compareAndSet(false, true)) {
1:             if (memoryUsage != null) {
1:                 memoryUsage.start();
1:             }
1:             if (systemUsage.getStoreUsage() != null) {
1:                 systemUsage.getStoreUsage().start();
1:             }
1:             systemUsage.getMemoryUsage().addUsageListener(this);
1:             messages.start();
1:             if (getExpireMessagesPeriod() > 0) {
1:                 scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
1:             }
1:             doPageIn(false);
1:         if (started.compareAndSet(true, false)) {
1:             if (taskRunner != null) {
1:                 taskRunner.shutdown();
1:             }
1:             if (this.executor != null) {
0:                 ThreadPoolUtils.shutdownNow(executor);
0:                 executor = null;
1:             }
1:             scheduler.cancel(expireMessagesTask);
1:             if (flowControlTimeoutTask.isAlive()) {
1:                 flowControlTimeoutTask.interrupt();
1:             }
1:             if (messages != null) {
1:                 messages.stop();
1:             }
0:             for (MessageReference messageReference : pagedInMessages.values()) {
0:                 messageReference.decrementReferenceCount();
1:             }
0:             pagedInMessages.clear();
1:             systemUsage.getMemoryUsage().removeUsageListener(this);
1:             if (memoryUsage != null) {
1:                 memoryUsage.stop();
1:             }
1:             if (store != null) {
1:                 store.stop();
1:             }
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug(getName() + "Producer Flow Control Timeout Task is stopping");
/////////////////////////////////////////////////////////////////////////
1:             if ((recoveredAccumulator % 10000) == 0) {
1:                 LOG.info("cursor for {} has recovered {} messages. {}% complete", new Object[]{ getActiveMQDestination().getQualifiedName(), recoveredAccumulator, new Integer((int) (recoveredAccumulator * 100 / totalMessageCount))});
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("{} add sub: {}, dequeues: {}, dispatched: {}, inflight: {}", new Object[]{ getActiveMQDestination().getQualifiedName(), getDestinationStatistics().getDequeues().getCount(), getDestinationStatistics().getDispatched().getCount(), getDestinationStatistics().getInflight().getCount() });
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("{} remove sub: {}, lastDeliveredSeqId: {}, dequeues: {}, dispatched: {}, inflight: {}", new Object[]{
1:                     getActiveMQDestination().getQualifiedName(),
1:                     sub,
0:                     lastDeiveredSequenceId,
1:                     getDestinationStatistics().getDequeues().getCount(),
1:                     getDestinationStatistics().getDispatched().getCount(),
0:                     getDestinationStatistics().getInflight().getCount()
1:             });
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("found lastDeliveredSeqID: {}, message reference: {}", lastDeiveredSequenceId, ref.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Send failed for: {}, missing producer state for: {}", message, producerExchange);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ({}) reached on {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
0:                                     memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName());
/////////////////////////////////////////////////////////////////////////
1:                                         LOG.debug("unexpected exception on deferred send of: {}", message, e);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Expired message: {}", message);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} expiring messages ..", getActiveMQDestination().getQualifiedName());
1:         LOG.debug("{} expiring messages done.", getActiveMQDestination().getQualifiedName());
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("expiring from pagedInPending: {}", ref);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("expiring from pagedInMessages: {}", ref);
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.debug("expiring from messages: {}", node);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("{} after purge complete, message count stats report: {}", getActiveMQDestination().getQualifiedName(), this.destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("{} consumers subscribed. Starting dispatch.", consumers.size());
1:                             LOG.debug("{} ms elapsed and {} consumers subscribed. Starting dispatch.", timeout, consumers.size());
1:                         LOG.debug("{} ms elapsed. Starting dispatch.", timeBeforeDispatchStarts);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("dispatch to browser: {}, already dispatched/paged count: {}", browser, alreadyDispatchedMessages.size());
/////////////////////////////////////////////////////////////////////////
1:                         LOG.warn("exception on dispatch to browser: {}", browserDispatch.getBrowser(), e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("message expired: {}", reference);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} Message {} sent to {}", new Object[]{ broker.getBrokerName(), msg.getMessageId(), this.destination });
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("{} toPageIn: {}, Inflight: {}, pagedInMessages.size {}, enqueueCount: {}, dequeueCount: {}",
0:                 new Object[]{
0:                         destination.getPhysicalName(),
0:                         toPageIn,
0:                         destinationStatistics.getInflight().getCount(),
0:                         pagedInMessages.size(),
0:                         destinationStatistics.getEnqueues().getCount(),
0:                         destinationStatistics.getDequeues().getCount()
0:                 });
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Failed to set boolean header", e);
author:Christian Posta
-------------------------------------------------------------------------------
commit:efc9a8d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.*;
/////////////////////////////////////////////////////////////////////////
1:     protected QueueDispatchPendingList dispatchPendingList = new QueueDispatchPendingList();
/////////////////////////////////////////////////////////////////////////
1:         dispatchPendingList.setPrioritizedMessages(prioritizedMessages);
/////////////////////////////////////////////////////////////////////////
0:                         dispatchPendingList.addMessageForRedelivery(qmr);
/////////////////////////////////////////////////////////////////////////
1:                 if (dispatchPendingList.hasRedeliveries() && (! this.brokerService.isStopping())) {
/////////////////////////////////////////////////////////////////////////
1:             doBrowseList(browseList, max, dispatchPendingList, pagedInPendingDispatchLock, connectionContext, "redeliveredWaitingDispatch+pagedInPendingDispatch");
/////////////////////////////////////////////////////////////////////////
1:                 pageInMoreMessages |= !dispatchPendingList.isEmpty();
/////////////////////////////////////////////////////////////////////////
1:             if (pageInMoreMessages || hasBrowsers || !dispatchPendingList.hasRedeliveries()) {
/////////////////////////////////////////////////////////////////////////
1:             dispatchPendingList.remove(r);
/////////////////////////////////////////////////////////////////////////
1:             if (dispatchPendingList.isEmpty()) {
1:                 dispatchPendingList.addAll(newlyPaged);
1:                     if (!dispatchPendingList.contains(qmr)) {
1:                         dispatchPendingList.addMessageLast(qmr);
/////////////////////////////////////////////////////////////////////////
1:             pagedInPendingSize = dispatchPendingList.size();
/////////////////////////////////////////////////////////////////////////
1:             doActualDispatch(dispatchPendingList);
1:                 if (dispatchPendingList.isEmpty()) {
1:                     dispatchPendingList.addAll(doActualDispatch(list));
1:                         if (!dispatchPendingList.contains(qmr)) {
1:                             dispatchPendingList.addMessageLast(qmr);
/////////////////////////////////////////////////////////////////////////
1:             for (MessageReference ref : dispatchPendingList) {
1:                     dispatchPendingList.remove(ref);
/////////////////////////////////////////////////////////////////////////
1:                     + dispatchPendingList.size() + ") for subscription: "
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:e947927
/////////////////////////////////////////////////////////////////////////
1:     private final PendingList pagedInMessages = new OrderedPendingList();
/////////////////////////////////////////////////////////////////////////
0:             doBrowseList(browseList, max, pagedInPendingDispatch, pagedInPendingDispatchLock, connectionContext, "pagedInPendingDispatch");
1:             doBrowseList(browseList, max, pagedInMessages, pagedInMessagesLock, connectionContext, "pagedInMessages");
/////////////////////////////////////////////////////////////////////////
1:     protected void doBrowseList(List<Message> browseList, int max, PendingList list, ReentrantReadWriteLock lock, ConnectionContext connectionContext, String name) throws Exception {
1:         List<MessageReference> toExpire = new ArrayList<MessageReference>();
1:         lock.readLock().lock();
1:         try {
1:             addAll(list.values(), browseList, max, toExpire);
1:         } finally {
1:             lock.readLock().unlock();
1:         }
1:         for (MessageReference ref : toExpire) {
1:             if (broker.isExpired(ref)) {
1:                 LOG.debug("expiring from {}: {}", name, ref);
1:                 messageExpired(connectionContext, ref);
1:             } else {
1:                 lock.writeLock().lock();
1:                 try {
1:                     list.remove(ref);
1:                 } finally {
1:                     lock.writeLock().unlock();
1:                 }
0:                 ref.decrementReferenceCount();
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             QueueMessageReference ref = (QueueMessageReference)this.pagedInMessages.get(msgId);
/////////////////////////////////////////////////////////////////////////
1:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:             for (MessageReference ref : list) {
1:                     moveMessageTo(context, (QueueMessageReference)ref, dest);
/////////////////////////////////////////////////////////////////////////
1:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:             for (MessageReference ref : list) {
1:                     moveMessageTo(context, (QueueMessageReference)ref, ref.getMessage().getOriginalDestination());
/////////////////////////////////////////////////////////////////////////
0:                 ArrayList<MessageReference> alreadyDispatchedMessages = null;
0:                     alreadyDispatchedMessages = new ArrayList<MessageReference>(pagedInMessages.values());
/////////////////////////////////////////////////////////////////////////
0:                         for (MessageReference node : alreadyDispatchedMessages) {
1:                             if (!((QueueMessageReference)node).isAcked() && !browser.isDuplicate(node.getMessageId()) && !browser.atMax()) {
/////////////////////////////////////////////////////////////////////////
0:                 pagedInMessages.remove(reference);
/////////////////////////////////////////////////////////////////////////
0:                     if (!pagedInMessages.contains(ref)) {
0:                         pagedInMessages.addMessageLast(ref);
/////////////////////////////////////////////////////////////////////////
1:                 message = (QueueMessageReference)pagedInMessages.get(messageId);
commit:dcedd9f
/////////////////////////////////////////////////////////////////////////
0:     private boolean resetNeeded;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
0:                     if (messages.isCacheEnabled()) {
0:                         result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
1:                     } else {
0:                         store.addMessage(context, message);
1:                     }
0:                     if (isReduceMemoryFootprint()) {
0:                         message.clearMarshalledState();
1:                     }
1:                 } catch (Exception e) {
0:                     // we may have a store in inconsistent state, so reset the cursor
0:                     // before restarting normal broker operations
0:                     resetNeeded = true;
0:                     throw e;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isResetNeeded() {
1:         return resetNeeded;
1:     }
1: 
commit:b8d5ca8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             }
1: 
1:             if (target == null && node.isDropped()) {
1:                 iterator.remove();
1:             if (target == null && consumers.size() == fullConsumers.size()) {
commit:2a5ad36
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             iterator.remove();
/////////////////////////////////////////////////////////////////////////
1:             // return if there are no consumers or all consumers are full
0:             if (target == null && (consumers.size() == 0 || consumers.size() == fullConsumers.size())) {
1:                 return list;
/////////////////////////////////////////////////////////////////////////
1:         return list;
author:artnaseef
-------------------------------------------------------------------------------
commit:29f34f4
/////////////////////////////////////////////////////////////////////////
1:                     // AMQ-5107: don't resend if the broker is shutting down
1:                     if ( this.brokerService.isStopping() ) {
1:                         break;
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 // AMQ-5107: don't resend if the broker is shutting down
0:                 if (!redeliveredWaitingDispatch.isEmpty() && (! this.brokerService.isStopping())) {
author:rajdavies
-------------------------------------------------------------------------------
commit:468e697
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.group.CachedMessageGroupMapFactory;
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:     private MessageGroupMapFactory messageGroupMapFactory = new CachedMessageGroupMapFactory();
author:Robert Davies
-------------------------------------------------------------------------------
commit:f71e2fe
/////////////////////////////////////////////////////////////////////////
1:         destinationStatistics.getMessageSize().addSize(msg.getSize());
commit:0736953
/////////////////////////////////////////////////////////////////////////
1:                         waitForSpace(context, producerExchange, memoryUsage, "Usage Manager Memory Limit reached. Producer ("
/////////////////////////////////////////////////////////////////////////
1:         producerExchange.incrementSend();
0:         checkUsage(context, producerExchange, message);
/////////////////////////////////////////////////////////////////////////
1:     private void checkUsage(ConnectionContext context,ProducerBrokerExchange producerBrokerExchange, Message message) throws ResourceAllocationException, IOException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:                 waitForSpace(context, producerBrokerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
/////////////////////////////////////////////////////////////////////////
1:             waitForSpace(context, producerBrokerExchange, messages.getSystemUsage().getTempUsage(), logMessage);
commit:ca83305
/////////////////////////////////////////////////////////////////////////
1:                         if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){
commit:f4d4c3b
/////////////////////////////////////////////////////////////////////////
0:                     result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected boolean isOptimizeStorage(){
1:         boolean result = false;
1:         if (isDoOptimzeMessageStorage()){
1:             consumersLock.readLock().lock();
1:             try{
1:                 if (consumers.isEmpty()==false){
1:                     result = true;
1:                     for (Subscription s : consumers) {
1:                         if (s.getPrefetchSize()==0){
1:                             result = false;
1:                             break;
1:                         }
1:                         if (s.isSlowConsumer()){
1:                             result = false;
1:                             break;
1:                         }
0:                         if (s.getInFlightUsage() > 10){
1:                             result = false;
1:                             break;
1:                         }
1:                     }
1:                 }
1:             }finally {
1:                 consumersLock.readLock().unlock();
1:             }
1:         }
1:         return result;
1:     }
commit:2705e36
/////////////////////////////////////////////////////////////////////////
1:         super.addSubscription(context, sub);
/////////////////////////////////////////////////////////////////////////
1:            
/////////////////////////////////////////////////////////////////////////
0:         super.removeSubscription(context, sub, lastDeiveredSequenceId);
commit:89e538d
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(getName() + "P roducer Flow Control Timeout Task is stopping");
/////////////////////////////////////////////////////////////////////////
1:                      // Start flow control timeout task
1:                         // Prevent trying to start it multiple times
1:                         if (!flowControlTimeoutTask.isAlive()) {
1:                             flowControlTimeoutTask.setName(getName()+" Producer Flow Control Timeout Task");
1:                             flowControlTimeoutTask.start();
1:                         }
/////////////////////////////////////////////////////////////////////////
commit:720ff40
/////////////////////////////////////////////////////////////////////////
1:             pagedInMessagesLock.writeLock().lock();
0:                     if (!pagedInMessages.containsKey(ref.getMessageId())) {            
1:                 pagedInMessagesLock.writeLock().unlock();
commit:28180b3
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
1:     private final ReentrantReadWriteLock consumersLock = new ReentrantReadWriteLock();
1:     private final ReentrantReadWriteLock messagesLock = new ReentrantReadWriteLock();
1:     private final ReentrantReadWriteLock pagedInMessagesLock = new ReentrantReadWriteLock();
1:     private final ReentrantReadWriteLock pagedInPendingDispatchLock = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.readLock().lock();
1:         try {
1:         }finally {
1:             consumersLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:                             messagesLock.writeLock().lock();
1:                             try{
0:                             }finally {
1:                                 messagesLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         pagedInPendingDispatchLock.writeLock().lock();
1:         try {
1:            // consumersLock.
1:             consumersLock.writeLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
1:                 consumersLock.writeLock().unlock();
1:                 pagedInMessagesLock.readLock().lock();
1:                 try{
0:                 }finally {
1:                     pagedInMessagesLock.readLock().unlock();
0:         }finally {
1:             pagedInPendingDispatchLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         pagedInPendingDispatchLock.writeLock().lock();
1:         try {
1:             consumersLock.writeLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
1:                 consumersLock.writeLock().unlock();
0:         }finally {
1:             pagedInPendingDispatchLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         messagesLock.readLock().lock();
0:         try{
0:         }finally {
0:             messagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             pagedInPendingDispatchLock.writeLock().lock();
1:             try {
0:                 addAll(pagedInPendingDispatch, browseList, max, toExpire);
0:                 for (MessageReference ref : toExpire) {
0:                     pagedInPendingDispatch.remove(ref);
1:                     if (broker.isExpired(ref)) {
0:                         LOG.debug("expiring from pagedInPending: " + ref);
0:                         messageExpired(connectionContext, ref);
1:                     }
1:                 }
1:             } finally {
1:                 pagedInPendingDispatchLock.writeLock().unlock();
1:             }
1:             toExpire.clear();
1:             pagedInMessagesLock.readLock().lock();
1:             try {
0:                 addAll(pagedInMessages.values(), browseList, max, toExpire);
1:             } finally {
1:                 pagedInMessagesLock.readLock().unlock();
1:             }
0:             for (MessageReference ref : toExpire) {
1:                 if (broker.isExpired(ref)) {
0:                     LOG.debug("expiring from pagedInMessages: " + ref);
0:                     messageExpired(connectionContext, ref);
1:                 } else {
0:                     pagedInMessagesLock.writeLock().lock();
1:                     try {
0:                         pagedInMessages.remove(ref.getMessageId());
1:                     } finally {
0:                         pagedInMessagesLock.writeLock().unlock();
1: 
0:             if (browseList.size() < getMaxBrowsePageSize()) {
1:                 messagesLock.writeLock().lock();
1:                 try {
1:                     try {
1:                         messages.reset();
0:                         while (messages.hasNext() && browseList.size() < max) {
1:                             MessageReference node = messages.next();
0:                             if (node.isExpired()) {
0:                                 if (broker.isExpired(node)) {
0:                                     LOG.debug("expiring from messages: " + node);
0:                                     messageExpired(connectionContext, createMessageReference(node.getMessage()));
1:                                 }
1:                                 messages.remove();
1:                             } else {
0:                                 messages.rollback(node.getMessageId());
0:                                 if (browseList.contains(node.getMessage()) == false) {
0:                                     browseList.add(node.getMessage());
1:                                 }
1:                             }
0:                             node.decrementReferenceCount();
1:                         }
1:                     } finally {
1:                         messages.release();
1:                     }
1:                 } finally {
1:                     messagesLock.writeLock().unlock();
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         pagedInMessagesLock.readLock().lock();
0:         try{
0:         }finally {
1:             pagedInMessagesLock.readLock().unlock();
0:         messagesLock.readLock().lock();
0:         try{
/////////////////////////////////////////////////////////////////////////
0:         }finally {
0:             messagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             pagedInMessagesLock.readLock().lock();
1:             try {
0:             }finally {
1:                 pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             pagedInMessagesLock.readLock().lock();
0:             try{
0:             }finally {
1:                 pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             pagedInMessagesLock.readLock().lock();
1:             try {
0:             }finally {
1:                 pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         messagesLock.writeLock().lock();
0:         try{
0:         }finally {
1:             messagesLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             pagedInMessagesLock.readLock().lock();
0:             try{
0:             }finally {
1:                 pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         pagedInMessagesLock.readLock().lock();
0:         try{
0:         }finally {
0:             pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             messagesLock.readLock().lock();
0:             try{
0:             }finally {
0:                 messagesLock.readLock().unlock();
1:             pagedInPendingDispatchLock.readLock().lock();
1:             try {
0:             }finally {
1:                 pagedInPendingDispatchLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:                 pagedInMessagesLock.readLock().lock();
0:                 try{
0:                 }finally {
0:                     pagedInMessagesLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         pagedInPendingDispatchLock.writeLock().lock();
1:         try {
0:             pagedInPendingDispatch.remove(r);
1:         } finally {
1:             pagedInPendingDispatchLock.writeLock().unlock();
1: 
/////////////////////////////////////////////////////////////////////////
1:             messagesLock.writeLock().lock();
0:             try{
0:             }finally {
1:                 messagesLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         pagedInMessagesLock.writeLock().lock();
0:         try{
0:         }finally {
0:             pagedInMessagesLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         messagesLock.writeLock().lock();
0:         try{
0:         }finally {
1:             messagesLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.readLock().lock();
1:         try {
0:         }finally {
1:             consumersLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:         int toPageIn = Math.min(getMaxPageSize(), messages.size());
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(destination.getPhysicalName() + " toPageIn: " + toPageIn + ", Inflight: "
0:                     + destinationStatistics.getInflight().getCount() + ", pagedInMessages.size "
0:                     + pagedInMessages.size() + ", enqueueSize: " + destinationStatistics.getEnqueues().getCount());
1: 
0:         if (isLazyDispatch() && !force) {
0:             // Only page in the minimum number of messages which can be
0:             // dispatched immediately.
0:             toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);
1:         }
1:         int pagedInPendingSize = 0;
1:         pagedInPendingDispatchLock.readLock().lock();
1:         try {
0:             pagedInPendingSize = pagedInPendingDispatch.size();
1:         } finally {
1:             pagedInPendingDispatchLock.readLock().unlock();
1:         }
0:         if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingSize < getMaxPageSize()))) {
1:             int count = 0;
1:             result = new ArrayList<QueueMessageReference>(toPageIn);
1:             messagesLock.writeLock().lock();
1:             try {
1:                 try {
1:                     messages.setMaxBatchSize(toPageIn);
1:                     messages.reset();
0:                     while (messages.hasNext() && count < toPageIn) {
1:                         MessageReference node = messages.next();
1:                         messages.remove();
1: 
1:                         QueueMessageReference ref = createMessageReference(node.getMessage());
0:                         if (ref.isExpired()) {
0:                             if (broker.isExpired(ref)) {
1:                                 messageExpired(createConnectionContext(), ref);
1:                             } else {
0:                                 ref.decrementReferenceCount();
1:                             }
1:                         } else {
1:                             result.add(ref);
1:                             count++;
1:                         }
1:                     }
1:                 } finally {
1:                     messages.release();
1:                 }
1:             } finally {
1:                 messagesLock.writeLock().unlock();
1:             }
0:             // Only add new messages, not already pagedIn to avoid multiple
0:             // dispatch attempts
0:             pagedInMessagesLock.readLock().lock();
1:             try {
0:                 resultList = new ArrayList<QueueMessageReference>(result.size());
0:                 for (QueueMessageReference ref : result) {
0:                     if (!pagedInMessages.containsKey(ref.getMessageId())) {
0:                         pagedInMessagesLock.readLock().unlock();
0:                         pagedInMessagesLock.writeLock().lock();
0:                         pagedInMessages.put(ref.getMessageId(), ref);
0:                         pagedInMessagesLock.readLock().lock();
0:                         pagedInMessagesLock.writeLock().unlock();
0:                         resultList.add(ref);
1:                     } else {
0:                         ref.decrementReferenceCount();
1:                     }
1:                 }
1:             } finally {
0:                 pagedInMessagesLock.readLock().unlock();
1:             }
1:         } else {
0:             // Avoid return null list, if condition is not validated
0:             resultList = new ArrayList<QueueMessageReference>();
1:         }
1: 
1:         pagedInPendingDispatchLock.writeLock().lock();
1:         try {
0:             if (!redeliveredWaitingDispatch.isEmpty()) {
0:                 // Try first to dispatch redelivered messages to keep an
0:                 // proper order
0:                 redeliveredWaitingDispatch = doActualDispatch(redeliveredWaitingDispatch);
1:             }
0:             if (!pagedInPendingDispatch.isEmpty()) {
0:                 // Next dispatch anything that had not been
0:                 // dispatched before.
0:                 pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);
1:             }
0:             // and now see if we can dispatch the new stuff.. and append to
0:             // the pending
0:             // list anything that does not actually get dispatched.
0:             if (list != null && !list.isEmpty()) {
0:                 if (pagedInPendingDispatch.isEmpty()) {
0:                     pagedInPendingDispatch.addAll(doActualDispatch(list));
1:                 } else {
0:                     for (QueueMessageReference qmr : list) {
0:                         if (!pagedInPendingDispatch.contains(qmr)) {
0:                             pagedInPendingDispatch.add(qmr);
0:                     doWakeUp = true;
1:         } finally {
1:             pagedInPendingDispatchLock.writeLock().unlock();
1: 
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.writeLock().lock();
1:         try {
0:         }finally {
1:             consumersLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:                 consumersLock.writeLock().lock();
1:                 try {
0:                 }finally {
0:                     consumersLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.readLock().lock();
0:         try{
0:         }finally {
1:             consumersLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         pagedInPendingDispatchLock.writeLock().lock();
1:         try {
0:             for (QueueMessageReference ref : pagedInPendingDispatch) {
1:                 if (messageId.equals(ref.getMessageId())) {
0:                     message = ref;
0:                     pagedInPendingDispatch.remove(ref);
1:                     break;
1:         } finally {
1:             pagedInPendingDispatchLock.writeLock().unlock();
1: 
1:         if (message == null) {
0:             pagedInMessagesLock.readLock().lock();
1:             try {
0:                 message = pagedInMessages.get(messageId);
1:             } finally {
0:                 pagedInMessagesLock.readLock().unlock();
1:             }
1:         }
1: 
1:         if (message == null) {
1:             messagesLock.writeLock().lock();
1:             try {
1:                 try {
1:                     messages.setMaxBatchSize(getMaxPageSize());
1:                     messages.reset();
1:                     while (messages.hasNext()) {
0:                         MessageReference node = messages.next();
0:                         messages.remove();
1:                         if (messageId.equals(node.getMessageId())) {
1:                             message = this.createMessageReference(node.getMessage());
1:                             break;
1:                         }
1:                     }
1:                 } finally {
1:                     messages.release();
1:                 }
1:             } finally {
1:                 messagesLock.writeLock().unlock();
1:             }
1:         }
1: 
1:         if (message == null) {
1:             Message msg = loadMessage(messageId);
1:             if (msg != null) {
1:                 message = this.createMessageReference(msg);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         consumersLock.readLock().lock();
1:         try {
0:         }finally {
1:             consumersLock.readLock().unlock();
commit:42ee51f
/////////////////////////////////////////////////////////////////////////
1:     private boolean allConsumersExclusiveByDefault = false;
/////////////////////////////////////////////////////////////////////////
1:                 if (sub.getConsumerInfo().isExclusive() || isAllConsumersExclusiveByDefault()) {
/////////////////////////////////////////////////////////////////////////
1:                 } else if (isAllConsumersExclusiveByDefault()) {
1:                     Subscription exclusiveConsumer = null;
1:                     for (Subscription s : consumers) {
1:                         if (exclusiveConsumer == null 
1:                                 || s.getConsumerInfo().getPriority() > exclusiveConsumer
1:                                 .getConsumerInfo().getPriority()) {
1:                             exclusiveConsumer = s;
1:                                 }
1:                     }
1:                     dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
/////////////////////////////////////////////////////////////////////////
1:     public void setAllConsumersExclusiveByDefault(boolean allConsumersExclusiveByDefault) {
1:         this.allConsumersExclusiveByDefault = allConsumersExclusiveByDefault;
1:     }
1: 
1:     public boolean isAllConsumersExclusiveByDefault() {
1:         return allConsumersExclusiveByDefault;
1:     }
1: 
1: 
commit:ddb2c91
/////////////////////////////////////////////////////////////////////////
1:     final Lock sendLock = new ReentrantLock();
/////////////////////////////////////////////////////////////////////////
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:                 this.messages = new VMPendingMessageCursor(isPrioritizedMessages());
/////////////////////////////////////////////////////////////////////////
0:         synchronized (pagedInMessages) {
0:             QueueMessageReference r = this.pagedInMessages.get(msgId);
0:             if (r != null) {
0:                 return r.getMessage();
1:         }
0:         synchronized (messages) {
1:             try {
0:                 messages.reset();
1:                 while (messages.hasNext()) {
0:                     MessageReference r = messages.next();
1:                     r.decrementReferenceCount();
0:                     messages.rollback(r.getMessageId());
0:                     if (msgId.equals(r.getMessageId())) {
1:                         Message m = r.getMessage();
0:                         if (m != null) {
0:                             return m;
1:                         break;
1:             } finally {
0:                 messages.release();
commit:27262c8
/////////////////////////////////////////////////////////////////////////
0:     // Messages that are paged in but have not yet been targeted at a
0:     // subscription
/////////////////////////////////////////////////////////////////////////
0:     protected final Map<MessageId, Runnable> messagesWaitingForSpace = Collections
0:             .synchronizedMap(new LinkedHashMap<MessageId, Runnable>());
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 
0:     private final Object iteratingMutex = new Object() {
1:     };
1: 
1: 
1: 
1:             long other = ((TimeoutMessage) delayed).trigger;
1:                 returnValue = -1;
1:                 returnValue = 1;
1:                 returnValue = 0;
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 ExceptionResponse response = new ExceptionResponse(
1:                                         new ResourceAllocationException(
0:                                                 "Usage Manager Memory Limit reached. Stopping producer ("
1:                                                         + timeout.message.getProducerId()
1:                                                         + ") to prevent flooding "
1:                                                         + getActiveMQDestination().getQualifiedName()
1:                                                         + "."
1:                                                         + " See http://activemq.apache.org/producer-flow-control.html for more info"));
/////////////////////////////////////////////////////////////////////////
1: 
1:             // We want the list sorted in descending order
1:     public Queue(BrokerService brokerService, final ActiveMQDestination destination, MessageStore store,
1:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     // make the queue easily visible in the debugger from its task runner
1:     // threads
/////////////////////////////////////////////////////////////////////////
1:         // If a VMPendingMessageCursor don't use the default Producer System
1:         // Usage
1:         // since it turns into a shared blocking queue which can lead to a
1:         // network deadlock.
1:         // If we are cursoring to disk..it's not and issue because it does not
1:         // block due
/////////////////////////////////////////////////////////////////////////
1:                                 // drop message will decrement so counter
1:                                 // balance here
/////////////////////////////////////////////////////////////////////////
1:      * Holder for subscription that needs attention on next iterate browser
1:      * needs access to existing messages in the queue that have already been
1:      * dispatched
/////////////////////////////////////////////////////////////////////////
1: 
1:             // iteratingMutex -> dispatchLock. - see
1:             // https://issues.apache.org/activemq/browse/AMQ-1878
1: 
0:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeiveredSequenceId)
1:             throws Exception {
0:                 LOG.debug("remove sub: " + sub + ", lastDeliveredSeqId: " + lastDeiveredSequenceId + ", dequeues: "
0:                         + getDestinationStatistics().getDequeues().getCount() + ", dispatched: "
0:                         + getDestinationStatistics().getDispatched().getCount() + ", inflight: "
0:                         + getDestinationStatistics().getInflight().getCount());
/////////////////////////////////////////////////////////////////////////
1:                             if (s.getConsumerInfo().isExclusive()
1:                                     && (exclusiveConsumer == null || s.getConsumerInfo().getPriority() > exclusiveConsumer
1:                                             .getConsumerInfo().getPriority())) {
/////////////////////////////////////////////////////////////////////////
1: 
0:                         // only increment redelivery if it was delivered or we
1:                         // have no delivery information
0:                         if (lastDeiveredSequenceId == 0
0:                                 || qmr.getMessageId().getBrokerSequenceId() <= lastDeiveredSequenceId) {
/////////////////////////////////////////////////////////////////////////
1:             // iteratingMutex -> dispatchLock. - see
1:             // https://issues.apache.org/activemq/browse/AMQ-1878
/////////////////////////////////////////////////////////////////////////
1:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0
1:                 && !context.isInRecoveryMode();
1:             // message not stored - or added to stats yet - so chuck here
/////////////////////////////////////////////////////////////////////////
0:                     LOG
0:                             .info("Usage Manager Memory Limit ("
0:                                     + memoryUsage.getLimit()
0:                                     + ") reached on "
0:                                     + getActiveMQDestination().getQualifiedName()
0:                                     + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it."
1:                                     + " See http://activemq.apache.org/producer-flow-control.html for more info");
0:                     throw new ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer ("
1:                             + message.getProducerId() + ") to prevent flooding "
1:                             + getActiveMQDestination().getQualifiedName() + "."
1:                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:                 // We can avoid blocking due to low usage if the producer is
1:                 // sending
1:                     // copy the exchange state since the context will be
1:                     // modified while we are waiting
/////////////////////////////////////////////////////////////////////////
1:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message
1:                                                 .getSize());
/////////////////////////////////////////////////////////////////////////
1: 
1:                             flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage
1:                                     .getSendFailIfNoSpaceAfterTimeout()));
/////////////////////////////////////////////////////////////////////////
0:                         waitForSpace(context, memoryUsage, "Usage Manager Memory Limit is full. Producer ("
1:                                 + message.getProducerId() + ") stopped to prevent flooding "
1:                                 + getActiveMQDestination().getQualifiedName() + "."
0:                                 + " See http://activemq.apache.org/producer-flow-control.html for more info");
/////////////////////////////////////////////////////////////////////////
1:     void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,
1:             Exception {
0:                     String logMessage = "Usage Manager Store is Full, " + getStoreUsageHighWaterMark() + "% of "
1:                             + systemUsage.getStoreUsage().getLimit() + ". Stopping producer ("
0:                             + message.getProducerId() + ") to prevent flooding "
0:                             + getActiveMQDestination().getQualifiedName() + "."
/////////////////////////////////////////////////////////////////////////
0:                 result = store.asyncAddQueueMessage(context, message);
/////////////////////////////////////////////////////////////////////////
1:                 result.get();
1:             } catch (CancellationException e) {
1:                 // ignore - the task has been cancelled if the message
1:                 // has already been deleted
/////////////////////////////////////////////////////////////////////////
1:     public void acknowledge(ConnectionContext context, Subscription sub, MessageAck ack, MessageReference node)
1:             throws IOException {
0:             // the original ack may be a ranged ack, but we are trying to delete
0:             // a specific
/////////////////////////////////////////////////////////////////////////
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size()
0:                 + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + size + ", in flight groups="
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void addAll(Collection<QueueMessageReference> refs, List<Message> l, int maxBrowsePageSize,
1:             List<MessageReference> toExpire) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             // don't spin/hang if stats are out and there is nothing left in the
0:             // store
0:             LOG.warn(getActiveMQDestination().getQualifiedName()
0:                     + " after purge complete, message count stats report: "
0:                     + this.destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
1:     public boolean copyMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest)
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest)
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest,
1:             int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest,
1:             int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:      * @param context
1:      *            connection context
1:      * @param m
0:      *            message
1:      * @param dest
1:      *            ActiveMQDestination
/////////////////////////////////////////////////////////////////////////
1:     public boolean moveMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest)
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest)
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest,
1:             int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int moveMatchingMessagesTo(ConnectionContext context, MessageReferenceFilter filter,
1:             ActiveMQDestination dest, int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         boolean pageInMoreMessages = false;
/////////////////////////////////////////////////////////////////////////
1:                         int timeout = 1000; // wait one second by default if
1:                                             // consumer count isn't reached
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug(timeout + " ms elapsed and " + consumers.size()
0:                                         + " consumers subscribed. Starting dispatch.");
/////////////////////////////////////////////////////////////////////////
1: 
0:             // Kinda ugly.. but I think dispatchLock is the only mutex
0:             // protecting the
0:             // pagedInPendingDispatch variable.
0:             // Perhaps we should page always into the pagedInPendingDispatch
0:             // list if
0:             // !messages.isEmpty(), and then if
0:             // !pagedInPendingDispatch.isEmpty()
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference,
1:             MessageAck ack) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                 final String logMessage = "Usage Manager Temp Store is Full. Stopping producer (" + msg.getProducerId()
1:                         + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(destination.getPhysicalName() + " toPageIn: " + toPageIn + ", Inflight: "
0:                         + destinationStatistics.getInflight().getCount() + ", pagedInMessages.size "
0:                 // Only page in the minimum number of messages which can be
0:                 // dispatched immediately.
/////////////////////////////////////////////////////////////////////////
1:                             
/////////////////////////////////////////////////////////////////////////
0:                 // Only add new messages, not already pagedIn to avoid multiple
0:                 // dispatch attempts
/////////////////////////////////////////////////////////////////////////
0:                     // Try first to dispatch redelivered messages to keep an
0:                     // proper order
/////////////////////////////////////////////////////////////////////////
0:                 // and now see if we can dispatch the new stuff.. and append to
0:                 // the pending
/////////////////////////////////////////////////////////////////////////
1:                             target = s;                            
1:                             // no further dispatch of list to a full consumer to
1:                             // avoid out of order message receipt
0:                     if (!node.isDropped() && !((QueueMessageReference) node).isAcked()
0:                             && (!node.isDropped() || s.getConsumerInfo().isBrowser())) {
0:                 // This means all subs were full or that there are no
0:                 // consumers...
1:             // If it got dispatched, rotate the consumer list to get round robin
1:             // distribution.
1:             if (target != null && !strictOrderDispatch && consumers.size() > 1
1:                     && !dispatchSelector.isExclusiveConsumer(target)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private QueueMessageReference getMatchingMessage(MessageDispatchNotification messageDispatchNotification)
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             throw new JMSException("Slave broker out of sync with master - Message: "
1:                     + messageDispatchNotification.getMessageId() + " on "
1:                     + messageDispatchNotification.getDestination() + " does not exist among pending("
0:                     + pagedInPendingDispatch.size() + ") for subscription: "
1:                     + messageDispatchNotification.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:     private Subscription getMatchingSubscription(MessageDispatchNotification messageDispatchNotification)
1:             throws JMSException {
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
0:     private final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
0:         this.scheduler = brokerService.getBroker().getScheduler();
commit:ea84378
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CancellationException;
0: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
1:     private final QueueDispatchSelector dispatchSelector;
1:     private final AtomicLong pendingWakeups = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         Future<Object> result = null;
/////////////////////////////////////////////////////////////////////////
0:                 if (context.isInTransaction()) {
0:                     store.addMessage(context, message);
0:                 }else {
0:                     result = store.asyncAddQueueMessage(context, message);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
0:         if (result != null && !result.isCancelled()) {
1:             try {
0:             result.get();
0:             }catch(CancellationException e) {
0:               //ignore - the task has been cancelled if the message
0:               // has already been deleted
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:             store.removeAsyncMessage(context, ack);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                     removeMessage(c, r);
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:960e65d
/////////////////////////////////////////////////////////////////////////
0:             int toPageIn = Math.min(getMaxPageSize(), messages.size());
1:            
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:             messages.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
commit:c459784
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.util.AbstractList;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.Comparator;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Set;
0: import java.util.concurrent.CopyOnWriteArraySet;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.TimeUnit;
1: import javax.jms.InvalidSelectorException;
1: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
0:     private final Object dispatchMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchMutex) {
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchMutex) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             synchronized(dispatchMutex) {
/////////////////////////////////////////////////////////////////////////
1:             } 
/////////////////////////////////////////////////////////////////////////
0: 	        synchronized(dispatchMutex) {
1: 	        } 
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchMutex) {
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchMutex) {
1:        
/////////////////////////////////////////////////////////////////////////
1:         } 
/////////////////////////////////////////////////////////////////////////
0:        synchronized(dispatchMutex) {
/////////////////////////////////////////////////////////////////////////
1:         } 
commit:63e3f41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (store!=null) {
0:             store.stop();
1:         }
commit:63b2c40
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private List<QueueMessageReference> pagedInPendingDispatch = new ArrayList<QueueMessageReference>(100);
/////////////////////////////////////////////////////////////////////////
0: 	                                    if (!pagedInPendingDispatch.contains(node)) {
0: 	                                        pagedInPendingDispatch.add(node);
1: 	                                    }
/////////////////////////////////////////////////////////////////////////
0:                     if (pagedInPendingDispatch.isEmpty()) {
0:                         pagedInPendingDispatch.addAll(doActualDispatch(list));
1:                     } else {
0:                         for (QueueMessageReference qmr : list) {
0:                             if (!pagedInPendingDispatch.contains(qmr)) {
0:                                 pagedInPendingDispatch.add(qmr);
1:                             }
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
0:     private List<QueueMessageReference> doActualDispatch(List<QueueMessageReference> list) throws Exception {
0:         List<QueueMessageReference> rc = new ArrayList<QueueMessageReference>(list.size());
/////////////////////////////////////////////////////////////////////////
0:         for (MessageReference node : list) {
commit:e2d743e
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
0: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
0:     private LinkedHashSet<QueueMessageReference> pagedInPendingDispatch = new LinkedHashSet<QueueMessageReference>(100);
/////////////////////////////////////////////////////////////////////////
0:                     pagedInPendingDispatch.addAll(doActualDispatch(list));
/////////////////////////////////////////////////////////////////////////
0:     private LinkedHashSet<QueueMessageReference> doActualDispatch(Collection<QueueMessageReference> collection) throws Exception {
0:         LinkedHashSet<QueueMessageReference> rc = new LinkedHashSet<QueueMessageReference>(collection.size());
/////////////////////////////////////////////////////////////////////////
0:         for (MessageReference node : collection) {
commit:b6115cf
/////////////////////////////////////////////////////////////////////////
0:         this.destinationStatistics.getMessages().setCount(0);
0:         getMessages().clear();
/////////////////////////////////////////////////////////////////////////
0:             synchronized (pagedInPendingDispatch) {
0:                 if (!pagedInPendingDispatch.isEmpty()) {
0:                     // Try to first dispatch anything that had not been
0:                     // dispatched before.
0:                 // and now see if we can dispatch the new stuff.. and append to
0:                 // the pending
0:                         for (QueueMessageReference qmr : list) {
0:                             if (!pagedInPendingDispatch.contains(qmr)) {
0:                                 pagedInPendingDispatch.add(qmr);
1:                             }
1:                         }
/////////////////////////////////////////////////////////////////////////
1:      * @return list of messages that could get dispatched to consumers if they
1:      *         were not full.
commit:e8a7451
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Move a message
0:      * @param context
0:      * @param r
0:      * @param dest
1:      * @throws Exception
1:      */
0:     public boolean moveMessageTo(ConnectionContext context,Message m,ActiveMQDestination dest) throws Exception {
0:         QueueMessageReference r = createMessageReference(m);
1:         BrokerSupport.resend(context, m, dest);
1:         removeMessage(context, r);
1:         return true;
1:     }
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:         int count = 0;
0:             synchronized (this.pagedInPendingDispatch) {
0:                 for (Iterator<QueueMessageReference> i = this.pagedInPendingDispatch
0:                         .iterator(); i.hasNext()
0:                         && count < getMaxBrowsePageSize();) {
0:                     l.add(i.next().getMessage());
1:                     count++;
0:             if (count < getMaxBrowsePageSize()) {
0:                 synchronized (pagedInMessages) {
0:                     for (Iterator<QueueMessageReference> i = this.pagedInMessages
0:                             .values().iterator(); i.hasNext()
0:                             && count < getMaxBrowsePageSize();) {
0:                         Message m = i.next().getMessage();
0:                         if (l.contains(m) == false) {
0:                             l.add(m);
1:                             count++;
0:             if (count < getMaxBrowsePageSize()) {
0:                 synchronized (messages) {
1:                     try {
0:                         messages.reset();
0:                         while (messages.hasNext()
0:                                 && count < getMaxBrowsePageSize()) {
0:                             MessageReference node = messages.next();
0:                             messages.rollback(node.getMessageId());
0:                             if (node != null) {
0:                                 Message m = node.getMessage();
0:                                 if (l.contains(m) == false) {
0:                                     l.add(m);
1:                                     count++;
1:                                 }
1:                             }
1:                         }
1:                     } finally {
0:                         messages.release();
1:                     }
1:                 }
1:             }
1:         } catch (IOException e) {
0:             LOG.error("Problem retrieving message in browse() ", e);
0:     public Message getMessage(String id) {
1:         MessageId msgId = new MessageId(id);
1:         try {
0:             synchronized (pagedInMessages) {
0:                 QueueMessageReference r = this.pagedInMessages.get(msgId);
0:                 if (r != null) {
0:                     return r.getMessage();
1:                 }
1:             }
0:             synchronized (messages) {
1:                 try {
0:                     messages.reset();
0:                     while (messages.hasNext()) {
1:                         try {
0:                             MessageReference r = messages.next();
0:                             messages.rollback(r.getMessageId());
0:                             if (msgId.equals(r.getMessageId())) {
1:                                 break;
1:                         } catch (IOException e) {
0:                             LOG.error("got an exception retrieving message "
0:                                     + id);
1:                 } finally {
0:                     messages.release();
1:         } catch (IOException e) {
0:             LOG.error("got an exception retrieving message " + id);
/////////////////////////////////////////////////////////////////////////
0:         return moveMatchingMessagesTo(context, selector, dest,Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:     public int moveMatchingMessagesTo(ConnectionContext context,
0:             MessageReferenceFilter filter, ActiveMQDestination dest,
0:             int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:             for (MessageReference ref : list) {
0:                     Message m = r.getMessage();
0:                     BrokerSupport.resend(context, m, dest);
0:                     removeMessage(context, r);
1:                     set.remove(r);
0:                     if (++movedCounter >= maximumMessages
0:                             && maximumMessages > 0) {
1:                         return movedCounter;
1:                     }
1:                 } else {
0:                     synchronized (messages) {
0:                         messages.rollback(r.getMessageId());
0:         } while (set.size() < this.destinationStatistics.getMessages().getCount()
0:                 && set.size() < maximumMessages);
/////////////////////////////////////////////////////////////////////////
0: 	                                synchronized(pagedInPendingDispatch) {
0: 	                                    pagedInPendingDispatch.add(node);
1: 	                                }
/////////////////////////////////////////////////////////////////////////
1:             public String toString() {
0:                 return "MessageIdFilter: "+messageId;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             dropMessage(reference);
1:                     dropMessage(reference);
/////////////////////////////////////////////////////////////////////////
1:     private void dropMessage(QueueMessageReference reference) {
0:         reference.drop();
0:         destinationStatistics.getMessages().decrement();
0:         synchronized(pagedInMessages) {
0:             pagedInMessages.remove(reference.getMessageId());
1:         }
0:         synchronized(messages) {
1:             messages.rollback(reference.getMessageId());
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:            
0:             int toPageIn = 0;
0:             if (force) {
0:                 toPageIn = getMaxPageSize();
1:             } else {
0:                 toPageIn = (getMaxPageSize() + (int) destinationStatistics
0:                         .getInflight().getCount())
0:                         - pagedInMessages.size();
0:                 toPageIn = Math.min(toPageIn, getMaxPageSize());
1:             }
/////////////////////////////////////////////////////////////////////////
1:                       
/////////////////////////////////////////////////////////////////////////
0:             synchronized(pagedInPendingDispatch) {
0:                 if(!pagedInPendingDispatch.isEmpty()) {
0:                     // Try to first dispatch anything that had not been dispatched before.
0:                     pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);
1:                 }
0:                 // and now see if we can dispatch the new stuff.. and append to the pending 
0:                 // list anything that does not actually get dispatched.
0:                 if (list != null && !list.isEmpty()) {
0:                     if (pagedInPendingDispatch.isEmpty()) {
0:                         pagedInPendingDispatch.addAll(doActualDispatch(list));
1:                     } else {
0:                         pagedInPendingDispatch.addAll(list);
1:                     }
commit:c8bd57c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (!this.optimizedDispatch) {
1:                     wakeup();
1:             }
1:         if (this.optimizedDispatch) {
1:             wakeup();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (!this.optimizedDispatch) {
1:                 wakeup();
1:             }
1:         if (this.optimizedDispatch) {
1:             // Outside of dispatchLock() to maintain the lock hierarchy of
0:             // iteratingMutex -> dispatchLock. - see https://issues.apache.org/activemq/browse/AMQ-1878
1:             wakeup();
1:         }
/////////////////////////////////////////////////////////////////////////
0:             toPageIn = Math.min(toPageIn,getMaxPageSize());
/////////////////////////////////////////////////////////////////////////
0:  //              System.out.println(getName()+": dispatching from pending: "+pagedInPendingDispatch.size());
/////////////////////////////////////////////////////////////////////////
0:             	zeroPrefetch |= s.getPrefetchSize() == 0;
1:             	int countBeforeFull = s.countBeforeFull();
commit:f405a7e
/////////////////////////////////////////////////////////////////////////
1:         // Outside of dispatchLock() to maintain the lock hierarchy of
0:         // iteratingMutex -> dispatchLock. - see https://issues.apache.org/activemq/browse/AMQ-1878
1:         wakeup();
/////////////////////////////////////////////////////////////////////////
0:         // Outside of dispatchLock() to maintain the lock hierarchy of
0:         // iteratingMutex -> dispatchLock. - see https://issues.apache.org/activemq/browse/AMQ-1878
1:         wakeup();
commit:e2cafda
/////////////////////////////////////////////////////////////////////////
1:     // Messages that are paged in but have not yet been targeted at a subscription
0:     private List<QueueMessageReference> pagedInPendingDispatch = new ArrayList<QueueMessageReference>(100);
/////////////////////////////////////////////////////////////////////////
0: //        System.out.println(getName()+" send "+message.getMessageId());
/////////////////////////////////////////////////////////////////////////
0: 	        // Kinda ugly.. but I think dispatchLock is the only mutex protecting the 
0: 	        // pagedInPendingDispatch variable. 	        
0: 	        dispatchLock.lock();
1: 	        try {
0: 	            result |= !pagedInPendingDispatch.isEmpty();
1: 	        } finally {
0: 	            dispatchLock.unlock();
1: 	        }
1: 	        
0: 	        // Perhaps we should page always into the pagedInPendingDispatch list is 
0:                 // !messages.isEmpty(), and then if !pagedInPendingDispatch.isEmpty()
0:                 // then we do a dispatch.
/////////////////////////////////////////////////////////////////////////
0:         dispatchLock.lock();
1:         try {
0:             if(!pagedInPendingDispatch.isEmpty()) {
0: //                System.out.println(getName()+": dispatching from pending: "+pagedInPendingDispatch.size());
0:                 // Try to first dispatch anything that had not been dispatched before.
0:                 pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);
0: //                System.out.println(getName()+": new pending list1: "+pagedInPendingDispatch.size());
1:             }
0:             // and now see if we can dispatch the new stuff.. and append to the pending 
0:             // list anything that does not actually get dispatched.
0:             if (list != null && !list.isEmpty()) {
0: //                System.out.println(getName()+": dispatching from paged in: "+list.size());
0:                 pagedInPendingDispatch.addAll(doActualDispatch(list));
0: //                System.out.println(getName()+": new pending list2: "+pagedInPendingDispatch.size());
1:             }
1:         } finally {
0:             dispatchLock.unlock();
1:         }
1:     }
1: 
1:     /**
0:      * @return list of messages that could get dispatched to consumers if they were not full.
1:      */
0:     private List<QueueMessageReference> doActualDispatch(List<QueueMessageReference> list) throws Exception {
0:         List<QueueMessageReference> rc = new ArrayList<QueueMessageReference>(list.size());
1:         List<Subscription> consumers;
1:         
0:         synchronized (this.consumers) {
1:             consumers = new ArrayList<Subscription>(this.consumers);
1:         }
1: 
0:         for (MessageReference node : list) {
1:             Subscription target = null;
0:             int interestCount=0;
1:             for (Subscription s : consumers) {
0:                 if (dispatchSelector.canSelect(s, node)) {
1:                     if (!s.isFull()) {
1:                         // Dispatch it.
1:                         s.add(node);
0: //                        System.out.println(getName()+" Dispatched to "+s.getConsumerInfo().getConsumerId()+", "+node.getMessageId());
0:                         target = s;
1:                         break;
1:                     } 
0:                     interestCount++;
1:                 }
1:             }
1:             
0:             if (target == null && interestCount>0) {
0:                 // This means all subs were full...
0:                 rc.add((QueueMessageReference)node);
1:             }
1: 
0:             // If it got dispatched, rotate the consumer list to get round robin distribution. 
0:             if (target != null && !strictOrderDispatch && consumers.size() > 1 &&
0:                     !dispatchSelector.isExclusiveConsumer(target)) {
0:                     if( removeFromConsumerList(target) ) {
1:                         addToConsumerList(target);
1:                         consumers = new ArrayList<Subscription>(this.consumers);
1: 
0:         //LOG.info(getName()+" Pending messages:");
0:         //for (MessageReference n : rc) {
0:        //     LOG.info(getName()+"  - " + n.getMessageId());
0:        // }
1:         
0:         return rc;
commit:7614fe2
/////////////////////////////////////////////////////////////////////////
0:                                     || target.getPendingQueueSize() > s.getPendingQueueSize()) {
commit:6dc4474
/////////////////////////////////////////////////////////////////////////
0:                             QueueMessageReference ref = createMessageReference(node.getMessage());
0:                                 messageExpired(createConnectionContext(), ref);
commit:3f4d4a5
/////////////////////////////////////////////////////////////////////////
0:         if (optimizedDispatch || isSlave()) {
/////////////////////////////////////////////////////////////////////////
0:     private boolean isSlave() {
0:         return broker.getBrokerService().isSlave();
1:     }
1: 
commit:0d85869
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             messageExpired(createConnectionContext(), message);
/////////////////////////////////////////////////////////////////////////
0:             //message not stored - or added to stats yet - so chuck here
/////////////////////////////////////////////////////////////////////////
1:                                     if (message.isExpired()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         removeMessage(c, null, r);
1:     }
1:     
0:     protected void removeMessage(ConnectionContext c, Subscription subs,QueueMessageReference r) throws IOException {
1:         removeMessage(c, subs, r, ack);
/////////////////////////////////////////////////////////////////////////
0:     public void messageExpired(ConnectionContext context,MessageReference reference) {
0:         messageExpired(context,null,reference);
1:     }
1:     
0:     public void messageExpired(ConnectionContext context,Subscription subs, MessageReference reference) {
0:         broker.messageExpired(context, reference);
0:         destinationStatistics.getDequeues().increment();
0:         destinationStatistics.getInflight().decrement();
1:         try {
0:             removeMessage(context,subs,(QueueMessageReference)reference);
0:         } catch (IOException e) {
0:             LOG.error("Failed to remove expired Message from the store ",e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                                 messageExpired(createConnectionContext(), node);
commit:4b27e76
/////////////////////////////////////////////////////////////////////////
0:         super.dispose(context);
commit:aee5d25
/////////////////////////////////////////////////////////////////////////
0:         answer.setBroker(this.broker);
commit:0f1ef01
/////////////////////////////////////////////////////////////////////////
0:         if (!msg.isPersistent() && messages.getSystemUsage() != null) {
0:             messages.getSystemUsage().getTempUsage().waitForSpace();
1:         }
0:         synchronized(messages) {
0:             messages.addMessageLast(msg);
1:         }
commit:8ab5f45
/////////////////////////////////////////////////////////////////////////
0:         messages.addMessageLast(msg);
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0:         if(memoryUsage.isFull()) {
1:             isFull(context, memoryUsage);
1:             fastProducer(context, producerInfo);
1:             if (isProducerFlowControl() && context.isProducerFlowControl()) {
0:                 if (systemUsage.isSendFailIfNoSpace()) {
0:                     throw new javax.jms.ResourceAllocationException("SystemUsage memory limit reached");
1:                 }
1:     
0:                 // We can avoid blocking due to low usage if the producer is sending
0:                 // a sync message or
0:                 // if it is using a producer window
1:                 if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
1:                     synchronized (messagesWaitingForSpace) {
0:                         messagesWaitingForSpace.add(new Runnable() {
1:                             public void run() {
1:     
1:                                 try {
1:     
1:                                     // While waiting for space to free up... the
0:                                     // message may have expired.
0:                                     if (broker.isExpired(message)) {
0:                                         broker.messageExpired(context, message);
0:                                         //message not added to stats yet
0:                                         //destinationStatistics.getMessages().decrement();
1:                                     } else {
1:                                         doMessageSend(producerExchange, message);
1:                                     }
1:     
1:                                     if (sendProducerAck) {
1:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:                                         context.getConnection().dispatchAsync(ack);
1:                                     } else {
1:                                         Response response = new Response();
1:                                         response.setCorrelationId(message.getCommandId());
1:                                         context.getConnection().dispatchAsync(response);
1:                                     }
1:     
1:                                 } catch (Exception e) {
0:                                     if (!sendProducerAck && !context.isInRecoveryMode()) {
1:                                         ExceptionResponse response = new ExceptionResponse(e);
1:                                         response.setCorrelationId(message.getCommandId());
1:                                         context.getConnection().dispatchAsync(response);
1:                                     }
0:                         });
1:     
0:                         // If the user manager is not full, then the task will not
1:                         // get called..
1:                         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
1:                             // so call it directly here.
1:                             sendMessagesWaitingForSpaceTask.run();
1:                         context.setDontSendReponse(true);
1:                         return;
1:     
1:                 } else {
1:     
0:                     // Producer flow control cannot be used, so we have do the flow
0:                     // control at the broker
0:                     // by blocking this thread until there is space available.
0:                     while (!memoryUsage.waitForSpace(1000)) {
0:                         if (context.getStopping().get()) {
0:                             throw new IOException("Connection closed, send aborted.");
1:                         }
1:     
1:                     // The usage manager could have delayed us by the time
1:                     // we unblock the message could have expired..
1:                     if (message.isExpired()) {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Expired message: " + message);
1:                         }
0:                         broker.getRoot().messageExpired(context, message);
1:                         return;
/////////////////////////////////////////////////////////////////////////
1:         messageConsumed(context, node);
/////////////////////////////////////////////////////////////////////////
1:         messageDelivered(context, msg);
commit:90c8ded
/////////////////////////////////////////////////////////////////////////
0:                 if (isProducerFlowControl() && context.isProducerFlowControl() ) {
0:                     if (systemUsage.isSendFailIfNoSpace() && systemUsage.getStoreUsage().isFull()) {
0:                         throw new javax.jms.ResourceAllocationException("Usage Manager Store is Full");
1:                     }
1:                 }
commit:2e137fb
/////////////////////////////////////////////////////////////////////////
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             dispatchLock.lock();
1:             try {
0:                 synchronized (this.consumers) {
0:                     consumers = new ArrayList<Subscription>(this.consumers);
1:                 }
1:             
0:                 for (MessageReference node : list) {
0:                     Subscription target = null;
0:                     List<Subscription> targets = null;
1:                     for (Subscription s : consumers) {
0:                         if (dispatchSelector.canSelect(s, node)) {
0:                             if (!s.isFull()) {
0:                                 s.add(node);
0:                                 target = s;
0:                                 break;
1:                             } else {
0:                                 if (targets == null) {
0:                                     targets = new ArrayList<Subscription>();
1:                                 }
0:                                 targets.add(s);
1:                         }
1:                     }
0:                     if (target == null && targets != null) {
0:                         // pick the least loaded to add the message too
0:                         for (Subscription s : targets) {
0:                             if (target == null
0:                                     || target.getInFlightUsage() > s.getInFlightUsage()) {
0:                                 target = s;
1:                             }
1:                         }
0:                         if (target != null) {
0:                             target.add(node);
1:                         }
1:                     }
0:                     if (target != null && !strictOrderDispatch && consumers.size() > 1 &&
0:                             !dispatchSelector.isExclusiveConsumer(target)) {
0:                         synchronized (this.consumers) {
0:                             if( removeFromConsumerList(target) ) {
0:                                 addToConsumerList(target);
0:                                 consumers = new ArrayList<Subscription>(this.consumers);
1:                             }
1:             } finally {
0:                 dispatchLock.unlock();
commit:18f9773
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         Set<MessageReference> set = new CopyOnWriteArraySet<MessageReference>();
1:                 set.addAll(pagedInMessages.values());
0:             List <MessageReference>list = new ArrayList<MessageReference>(set);
0:                     set.remove(r);
1:         } while (set.size() < this.destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
0:         Set<MessageReference> set = new CopyOnWriteArraySet<MessageReference>();
0:             int oldMaxSize=getMaxPageSize();
1:             setMaxPageSize((int) this.destinationStatistics.getMessages().getCount());
1:             setMaxPageSize(oldMaxSize);
1:                 set.addAll(pagedInMessages.values());
0:             List <MessageReference>list = new ArrayList<MessageReference>(set);
1:                     
1:                     r.incrementReferenceCount();                    
/////////////////////////////////////////////////////////////////////////
0:         Set<MessageReference> set = new CopyOnWriteArraySet<MessageReference>();
1:                 set.addAll(pagedInMessages.values());
0:             List <MessageReference>list = new ArrayList<MessageReference>(set);
0:             for (MessageReference ref:list) {
/////////////////////////////////////////////////////////////////////////
0:                         set.remove(r);
/////////////////////////////////////////////////////////////////////////
1:                 
0:         } while (set.size() < this.destinationStatistics.getMessages().getCount());
/////////////////////////////////////////////////////////////////////////
1:     
1:   
commit:dfcf776
/////////////////////////////////////////////////////////////////////////
0:                 message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
commit:dc4f299
/////////////////////////////////////////////////////////////////////////
0:         reference.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                                 node.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                             node.incrementReferenceCount();
commit:93ccb9c
/////////////////////////////////////////////////////////////////////////
0:         boolean zeroPrefetch = false;
0:             	PrefetchSubscription ps = (PrefetchSubscription) s;
0:             	zeroPrefetch |= ps.getPrefetchSize() == 0;
0:             	int countBeforeFull = ps.countBeforeFull();
1:                 total += countBeforeFull;
0:         if (total==0 && zeroPrefetch){
0:         	total=1;
1:         }
commit:84792ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (isLazyDispatch()&& !force) {
commit:044c07d
/////////////////////////////////////////////////////////////////////////
1:     public void wakeup() {
/////////////////////////////////////////////////////////////////////////
0:             int toPageIn = getMaxPageSize() - pagedInMessages.size();
0:             if (isLazyDispatch()) {
0:              // Only page in the minimum number of messages which can be dispatched immediately.
0:              toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     private int getConsumerMessageCountBeforeFull() throws Exception {
1:         int total = 0;
0:         synchronized (consumers) {
1:             for (Subscription s : consumers) {
0:                 total += ((PrefetchSubscription) s).countBeforeFull();
1:             }
1:         }
1: 
1:         return total;
1:     }
commit:3f9d6e2
/////////////////////////////////////////////////////////////////////////
0:     protected TaskRunnerFactory taskFactory;
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizedDispatch=false;
/////////////////////////////////////////////////////////////////////////
0:         this.taskFactory=taskFactory;       
/////////////////////////////////////////////////////////////////////////
0:         if (isOptimizedDispatch()) {
0:             this.taskRunner = taskFactory.createTaskRunner(this, "TempQueue:  " + destination.getPhysicalName());
0:         }else {
0:             this.executor =  Executors.newSingleThreadExecutor(new ThreadFactory() {
0:                 public Thread newThread(Runnable runnable) {
0:                     Thread thread = new Thread(runnable, "QueueThread:"+destination);
0:                     thread.setDaemon(true);
0:                     thread.setPriority(Thread.NORM_PRIORITY);
0:                     return thread;
1:                 }
0:             });
1:                
0:             this.taskRunner = new DeterministicTaskRunner(this.executor,this);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:     public boolean isOptimizedDispatch() {
1:         return optimizedDispatch;
1:     }
1: 
1:     public void setOptimizedDispatch(boolean optimizedDispatch) {
1:         this.optimizedDispatch = optimizedDispatch;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         if (optimizedDispatch) {
1:             iterate();
0:         }else {
1:             try {
0:                 taskRunner.wakeup();
1:             } catch (InterruptedException e) {
0:                 log.warn("Task Runner failed to wakeup ", e);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
commit:f4ca650
/////////////////////////////////////////////////////////////////////////
0:                 List<QueueMessageReference> inFlight = null;
0:                 synchronized(pagedInMessages) {
0:                     inFlight = new ArrayList<QueueMessageReference>(pagedInMessages.values());
1:                 }
1:                 
0:                 for (QueueMessageReference node:inFlight){
commit:cd54a16
/////////////////////////////////////////////////////////////////////////
0:     protected final Log log;
1:     protected TaskRunner taskRunner;    
1:     protected final List<Subscription> consumers = new ArrayList<Subscription>(50);
1:     protected PendingMessageCursor messages;
0:     private final LinkedHashMap<MessageId,QueueMessageReference> pagedInMessages = new LinkedHashMap<MessageId,QueueMessageReference>();
1:     private ExecutorService executor;
0:     protected final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
/////////////////////////////////////////////////////////////////////////
1:         
0:         this.log = LogFactory.getLog(getClass().getName() + "." + destination.getPhysicalName());
0:         this.dispatchSelector=new QueueDispatchSelector(destination);
1:        
1:     }
1:         
1:     public void initialize() throws Exception {
1:         if (this.messages == null) {
1:             if (destination.isTemporary() || broker == null || store == null) {
0:                 this.messages = new VMPendingMessageCursor();
1:             } else {
1:                 this.messages = new StoreQueueCursor(broker, this);
1:             }
0:         // If a VMPendingMessageCursor don't use the default Producer System Usage
0:         // since it turns into a shared blocking queue which can lead to a network deadlock.  
0:         // If we are ccursoring to disk..it's not and issue because it does not block due 
1:         // to large disk sizes.
0:         if( messages instanceof VMPendingMessageCursor ) {
1:             this.systemUsage = brokerService.getSystemUsage();
1:             memoryUsage.setParent(systemUsage.getMemoryUsage());
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 for (QueueMessageReference node:pagedInMessages.values()){
/////////////////////////////////////////////////////////////////////////
0:                 List<QueueMessageReference> list = new ArrayList<QueueMessageReference>();
0:                 for (QueueMessageReference node:pagedInMessages.values()){
/////////////////////////////////////////////////////////////////////////
1:     private QueueMessageReference createMessageReference(Message message) {
1:         QueueMessageReference result = new IndirectMessageReference(message);
/////////////////////////////////////////////////////////////////////////
0:             for (QueueMessageReference node:pagedInMessages.values()){
0:                 node.incrementReferenceCount();
0:                     Message m = node.getMessage();
0:                     node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected void removeMessage(ConnectionContext c, QueueMessageReference r) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     protected void wakeup() {
/////////////////////////////////////////////////////////////////////////
0:     private List<QueueMessageReference> doPageIn(boolean force) throws Exception {
1:         List<QueueMessageReference> result = null;
/////////////////////////////////////////////////////////////////////////
0:                 result = new ArrayList<QueueMessageReference>(toPageIn);
/////////////////////////////////////////////////////////////////////////
0:                                 QueueMessageReference ref = createMessageReference(node.getMessage());
0:                                 result.add(ref);
/////////////////////////////////////////////////////////////////////////
0:                     for(QueueMessageReference ref:result) {
/////////////////////////////////////////////////////////////////////////
0:     private void doDispatch(List<QueueMessageReference> list) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected void pageInMessages(boolean force) throws Exception {
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:             MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
/////////////////////////////////////////////////////////////////////////
0:         ConnectionContext answer = new ConnectionContext(new NonCachedMessageEvaluationContext());
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
0:     private boolean useConsumerPriority=true;
0:     private boolean strictOrderDispatch=false;
0:     private static final Comparator<Subscription>orderedCompare = new Comparator<Subscription>() {
1: 
1:         public int compare(Subscription s1, Subscription s2) {
0:             //We want the list sorted in descending order
0:             return s2.getConsumerInfo().getPriority() - s1.getConsumerInfo().getPriority();
1:         }        
1:     };
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 addToConsumerList(sub);
/////////////////////////////////////////////////////////////////////////
1:                 removeFromConsumerList(sub);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isUseConsumerPriority() {
1:         return useConsumerPriority;
1:     }
1: 
1:     public void setUseConsumerPriority(boolean useConsumerPriority) {
1:         this.useConsumerPriority = useConsumerPriority;
1:     }
1: 
1:     public boolean isStrictOrderDispatch() {
1:         return strictOrderDispatch;
1:     }
1: 
1:     public void setStrictOrderDispatch(boolean strictOrderDispatch) {
1:         this.strictOrderDispatch = strictOrderDispatch;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     if (target != null && !strictOrderDispatch && consumers.size() > 1 &&
0:                              !dispatchSelector.isExclusiveConsumer(target)) {
0:                         removeFromConsumerList(target);
0:                         addToConsumerList(target);
/////////////////////////////////////////////////////////////////////////
1:     
1:     private void addToConsumerList(Subscription sub) {
1:         if (useConsumerPriority) {
0:             int index = Collections
0:                     .binarySearch(consumers, sub, orderedCompare);
0:             // insert into the ordered list
0:             if (index < 0) {
0:                 consumers.add(-index - 1, sub);
0:             } else {
1:                 consumers.add(sub);
1:             }
0:         } else {
1:             consumers.add(sub);
1:         }
1:     }
1:     
0:     private void removeFromConsumerList(Subscription sub) {
0:         consumers.remove(sub);
1:     }
commit:8768a04
/////////////////////////////////////////////////////////////////////////
0:             synchronized (consumers) {
/////////////////////////////////////////////////////////////////////////
0:                     if (target == null && targets != null) {
0:                         // pick the least loaded to add the message too
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (target != null
0:                             && !dispatchSelector.isExclusiveConsumer(target)) {
1: 
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ThreadFactory;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DeterministicTaskRunner;
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor;
0:     private QueueDispatchSelector  dispatchSelector;
1:                
0:     public Queue(Broker broker, final ActiveMQDestination destination, final SystemUsage systemUsage,MessageStore store,DestinationStatistics parentStats,
/////////////////////////////////////////////////////////////////////////
1:        
0:         this.executor =  Executors.newSingleThreadExecutor(new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "QueueThread:"+destination);
0:                 thread.setDaemon(true);
0:                 thread.setPriority(Thread.NORM_PRIORITY);
0:                 return thread;
1:             }
0:         });
1:            
0:         this.taskRunner = new DeterministicTaskRunner(this.executor,this);
0:         this.dispatchSelector=new QueueDispatchSelector(destination);
1:        
1:     }
1: 
1:     /**
0:      * @param queue
0:      * @param string
0:      * @param b
0:      * @return
1:      */
0:     private TaskRunner DedicatedTaskRunner(Queue queue, String string, boolean b) {
0:         // TODO Auto-generated method stub
0:         return null;
/////////////////////////////////////////////////////////////////////////
1:    
/////////////////////////////////////////////////////////////////////////
1:                     Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();
0:                     if(exclusiveConsumer==null) {
0:                         exclusiveConsumer=sub;
0:                     }else if (sub.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority()){
0:                         exclusiveConsumer=sub;
1:                     dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
0:             doPageIn(false);
1:                 
0:                     if (!node.isDropped() && !node.isAcked() && (!node.isDropped() ||sub.getConsumerInfo().isBrowser())) {
1:                 
1:             wakeup();
0:         }finally {
/////////////////////////////////////////////////////////////////////////
0:         dispatchLock.lock();
1:         try {
1:             // synchronize with dispatch method so that no new messages are sent
0:             // while
0:             // removing up a subscription.
0:             synchronized (consumers) {
0:                 consumers.remove(sub);
1:                 if (sub.getConsumerInfo().isExclusive()) {
0:                     Subscription exclusiveConsumer = dispatchSelector
0:                             .getExclusiveConsumer();
1:                     if (exclusiveConsumer == sub) {
1:                         exclusiveConsumer = null;
1:                         for (Subscription s : consumers) {
0:                             if (s.getConsumerInfo().isExclusive()
0:                                     && (exclusiveConsumer == null
0:                                     || s.getConsumerInfo().getPriority() > exclusiveConsumer
0:                                             .getConsumerInfo().getPriority())) {
1:                                 exclusiveConsumer = s;
1: 
1:                             }
1:                         }
1:                         dispatchSelector.setExclusiveConsumer(exclusiveConsumer);
1:                     }
1:                 }
1:                 ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();
0:                 MessageGroupSet ownedGroups = getMessageGroupOwners()
0:                         .removeConsumer(consumerId);
1:                 // redeliver inflight messages
0:                 sub.remove(context, this);
1: 
0:                 List<MessageReference> list = new ArrayList<MessageReference>();
0:                 for (Iterator<MessageReference> i = pagedInMessages.values()
0:                         .iterator(); i.hasNext();) {
0:                     QueueMessageReference node = (QueueMessageReference) i
0:                             .next();
0:                     if (!node.isDropped() && !node.isAcked()
0:                             && node.getLockOwner() == sub) {
0:                         if (node.unlock()) {
0:                             node.incrementRedeliveryCounter();
0:                             list.add(node);
0:                 if (list != null && !consumers.isEmpty()) {
0:                     doDispatch(list);
1:                 }
1: 
0:             wakeup();
0:         }finally {
0:             dispatchLock.unlock();
/////////////////////////////////////////////////////////////////////////
0:         if (this.executor != null) {
0:             this.executor.shutdownNow();
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     r.incrementReferenceCount();
0:                     try {
0:                         Message m = r.getMessage();
0:                         BrokerSupport.resend(context, m, dest);
0:                         if (++movedCounter >= maximumMessages
0:                                 && maximumMessages > 0) {
1:                             return movedCounter;
1:                     } finally {
0:                         r.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                     r.incrementReferenceCount();
0:                     try {
0:                         Message m = r.getMessage();
0:                         BrokerSupport.resend(context, m, dest);
0:                         removeMessage(context, r);
0:                         if (++movedCounter >= maximumMessages
0:                                 && maximumMessages > 0) {
1:                             return movedCounter;
1:                     } finally {
0:                         r.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                pageInMessages(false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:         try{
1:         
/////////////////////////////////////////////////////////////////////////
1:     
1:         
0:         if (list != null) {
0:             synchronized (consumers) {      
0:                 for (MessageReference node : list) {
0:                     Subscription target = null;
0:                     List<Subscription> targets = null;
0:                     for (Subscription s : consumers) {
0:                         if (dispatchSelector.canSelect(s, node)) {
0:                             if (!s.isFull()) {
0:                                 s.add(node);
0:                                 target = s;
0:                                 break;
0:                             } else {
0:                                 if (targets == null) {
0:                                     targets = new ArrayList<Subscription>();
1:                                 }
0:                                 targets.add(s);
1:                             }
1:                         }
1:                     }
0:                     if (targets != null) {
0:                         // pick the least loaded to add the messag too
1:     
0:                         for (Subscription s : targets) {
0:                             if (target == null
0:                                     || target.getInFlightUsage() > s
0:                                             .getInFlightUsage()) {
0:                                 target = s;
1:                             }
1:                         }
0:                         if (target != null) {
0:                             target.add(node);
1:                         }
1:                     }
0:                     if (target != null && !dispatchSelector.isExclusiveConsumer(target)) {
0:                         consumers.remove(target);
0:                         consumers.add(target);
1:                     }
1:     
1:                 }
/////////////////////////////////////////////////////////////////////////
commit:24fea93
/////////////////////////////////////////////////////////////////////////
0:         //must return false  to prevent spinning
1:         return false;
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
1:             messages.setUseCache(isUseCache());
commit:f81d0d5
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
0:     private final ReentrantLock dispatchLock = new ReentrantLock();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {
0:         dispatchLock.lock();
0:         try {
1:             sub.add(context, this);
0:             destinationStatistics.getConsumers().increment();
0:             MessageEvaluationContext msgContext = new MessageEvaluationContext();
1:             // needs to be synchronized - so no contention with dispatching
0:             synchronized (consumers) {
0:                 consumers.add(sub);
0:                 if (sub.getConsumerInfo().isExclusive()) {
0:                     LockOwner owner = (LockOwner) sub;
0:                     if (exclusiveOwner == null) {
0:                     } else {
0:                         // switch the owner if the priority is higher.
0:                         if (owner.getLockPriority() > exclusiveOwner
0:                                 .getLockPriority()) {
0:                             exclusiveOwner = owner;
1:                         }
0:             // we hold the lock on the dispatchValue - so lets build the paged
0:             // in
0:             // list directly;
0:             doPageIn(false);
1:             // synchronize with dispatch method so that no new messages are sent
0:             // while
0:             // setting up a subscription. avoid out of order messages,
0:             // duplicates
0:             // etc.
1:             msgContext.setDestination(destination);
0:             synchronized (pagedInMessages) {
0:                 // Add all the matching messages in the queue to the
0:                 // subscription.
0:                 for (Iterator<MessageReference> i = pagedInMessages.values()
0:                         .iterator(); i.hasNext();) {
0:                     QueueMessageReference node = (QueueMessageReference) i
0:                             .next();
0:                     if (node.isDropped()
0:                             || (!sub.getConsumerInfo().isBrowser() && node
0:                                     .getLockOwner() != null)) {
1:                         continue;
0:                     try {
1:                         msgContext.setMessageReference(node);
0:                         if (sub.matches(node, msgContext)) {
0:                             sub.add(node);
1:                         }
0:                     } catch (IOException e) {
0:                         log.warn("Could not load message: " + e, e);
1:                     }
1:         } finally {
0:             dispatchLock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     final void wakeup() {
0:     private List<MessageReference> doPageIn(boolean force) throws Exception {
0:         dispatchLock.lock();
0:         try {
0:             final int toPageIn = getMaxPageSize() - pagedInMessages.size();
0:             if ((force || !consumers.isEmpty()) && toPageIn > 0) {
0:                 messages.setMaxBatchSize(toPageIn);
0:                 int count = 0;
0:                 result = new ArrayList<MessageReference>(toPageIn);
0:                 synchronized (messages) {
0:                     try {
0:                         messages.reset();
0:                         while (messages.hasNext() && count < toPageIn) {
0:                             MessageReference node = messages.next();
0:                             messages.remove();
0:                             if (!broker.isExpired(node)) {
0:                                 node = createMessageReference(node.getMessage());
0:                                 result.add(node);
0:                                 count++;
0:                             } else {
0:                                 broker.messageExpired(createConnectionContext(),
0:                                         node);
0:                                 destinationStatistics.getMessages().decrement();
1:                             }
1:                     } finally {
0:                         messages.release();
1:                 }
0:                 synchronized (pagedInMessages) {
0:                     for(MessageReference ref:result) {
0:                         pagedInMessages.put(ref.getMessageId(), ref);
1:                     }
0:         }finally {
0:             dispatchLock.unlock();
commit:d0f3d4d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final int toPageIn = getMaxPageSize() - pagedInMessages.size();
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:     private final TaskRunner taskRunner;    
1:         }
1:            
/////////////////////////////////////////////////////////////////////////
1:      * @return true if we would like to iterate again
0:         boolean result = false;
0:         synchronized (messages) {
0:             result = !messages.isEmpty();
0:         if (result) {
0:             try {
0:                 pageInMessages(false);
1:                
1:             } catch (Throwable e) {
0:                 log.error("Failed to page in more queue messages ", e);
1:             }
1:         }
0:         while (!messagesWaitingForSpace.isEmpty() && !memoryUsage.isFull()) {
1: 
0:         synchronized (messages) {
0:             result = !messages.isEmpty();
1:         }
1:         return result;
/////////////////////////////////////////////////////////////////////////
0:     final synchronized void wakeup() {
1:             
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void doDispatch(List<MessageReference> list) throws Exception {
1:        
0:                 MessageReference node = list.get(i);         
commit:3249682
/////////////////////////////////////////////////////////////////////////
0:         while (!messagesWaitingForSpace.isEmpty() &&!memoryUsage.isFull()) {
0:             Runnable op = messagesWaitingForSpace.removeFirst();
1:             op.run();
1:         }
1:         
commit:cce7566
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             wakeup();
/////////////////////////////////////////////////////////////////////////
0:         while (!messagesWaitingForSpace.isEmpty() &&!memoryUsage.isFull()) {
/////////////////////////////////////////////////////////////////////////
0:         wakeup();
/////////////////////////////////////////////////////////////////////////
0:         wakeup();
1:     }
1:     
0:     final void wakeup() {
0:         try {
0:             taskRunner.wakeup();
1:         } catch (InterruptedException e) {
0:             log.warn("Task Runner failed to wakeup ", e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
0:     public Queue(Broker broker, ActiveMQDestination destination, final SystemUsage systemUsage,MessageStore store,DestinationStatistics parentStats,
0:                  TaskRunnerFactory taskFactory) throws Exception {
0:         if (destination.isTemporary() || broker == null || store==null ) {
0:             this.messages = new StoreQueueCursor(broker,this);
/////////////////////////////////////////////////////////////////////////
1:         message.setRegionDestination(this);
0:             broker.getRoot().messageExpired(context, message);
/////////////////////////////////////////////////////////////////////////
0:                     broker.getRoot().messageExpired(context, message);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         removeMessage(c,(IndirectMessageReference) r);
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
0:             }else {
0:                 int messageCount = store.getMessageCount();
0:                 destinationStatistics.getMessages().setCount(messageCount);
/////////////////////////////////////////////////////////////////////////
0:             //message not added to stats yet
0:             //destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:                                     //message not added to stats yet
0:                                     //destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:                             //message not added to stats yet
0:                             //destinationStatistics.getMessages().decrement();
commit:8d11f07
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashMap;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static int MAXIMUM_PAGE_SIZE  = 1000;
0:     private final LinkedHashMap<MessageId,MessageReference> pagedInMessages = new LinkedHashMap<MessageId,MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:     
0:         super(broker, store, destination,systemUsage, parentStats);
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.values().iterator(); i
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<MessageReference> i = pagedInMessages.values().iterator(); i
/////////////////////////////////////////////////////////////////////////
0: 	public void gc(){
1: 	}
1:     
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.values().iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:     public void purge() throws Exception {   
1:         ConnectionContext c = createConnectionContext();
1:         List<MessageReference> list = null;
1:         do {
0:             pageInMessages();
0:             synchronized (pagedInMessages) {
0:                 list = new ArrayList<MessageReference>(pagedInMessages.values());
1:             }
1:             for (MessageReference ref : list) {
0:                     QueueMessageReference r = (QueueMessageReference) ref;
/////////////////////////////////////////////////////////////////////////
0:                         removeMessage(c, null, r, ack);
0:         } while (!pagedInMessages.isEmpty() || this.destinationStatistics.getMessages().getCount() > 0);
0:         gc();
/////////////////////////////////////////////////////////////////////////
1:         int movedCounter = 0;
0:         int count = 0;
1:         ConnectionContext context = createConnectionContext();
0:         List<MessageReference> list = null;
1:         do {
0:             pageInMessages();
0:             synchronized (pagedInMessages) {
0:                 list = new ArrayList<MessageReference>(pagedInMessages.values());
0:             for (MessageReference ref : list) {
1:                 IndirectMessageReference r = (IndirectMessageReference) ref;
1:                 if (filter.evaluate(context, r)) {
1: 
0:                     removeMessage(context, r);
0:                     if (++movedCounter >= maximumMessages
0:                             && maximumMessages > 0) {
1:                         return movedCounter;
1:                     }
1:                 }
0:                 count++;
1:             }
1:         } while (count < this.destinationStatistics.getMessages().getCount());
1:         return movedCounter;
/////////////////////////////////////////////////////////////////////////
1:         int movedCounter = 0;
0:         int count = 0;
0:         List<MessageReference> list = null;
1:         do {
0:             pageInMessages();
0:             synchronized (pagedInMessages) {
0:                 list = new ArrayList<MessageReference>(pagedInMessages.values());
1:             }
0:             for (MessageReference ref : list) {
1:                 IndirectMessageReference r = (IndirectMessageReference) ref;
0:                     // We should only copy messages that can be locked.
0:                     if (lockMessage(r)) {
0:                         r.incrementReferenceCount();
0:                         try {
0:                             Message m = r.getMessage();
0:                             BrokerSupport.resend(context, m, dest);
0:                             if (++movedCounter >= maximumMessages
0:                                     && maximumMessages > 0) {
1:                                 return movedCounter;
1:                             }
1:                         } finally {
0:                             r.decrementReferenceCount();
0:                 count++;
0:         } while (count < this.destinationStatistics.getMessages().getCount());
1:         return movedCounter;
/////////////////////////////////////////////////////////////////////////
0:     public int moveMatchingMessagesTo(ConnectionContext context,MessageReferenceFilter filter, ActiveMQDestination dest,int maximumMessages) throws Exception {
1:         int movedCounter = 0;
0:         int count = 0;
0:         List<MessageReference> list = null;
1:         do {
0:             pageInMessages();
0:             synchronized (pagedInMessages) {
0:                 list = new ArrayList<MessageReference>(pagedInMessages.values());
1:             }
0:             for (MessageReference ref : list) {
0:                 IndirectMessageReference r = (IndirectMessageReference) ref;
/////////////////////////////////////////////////////////////////////////
0:                             if (++movedCounter >= maximumMessages
0:                                     && maximumMessages > 0) {
0:                                 return movedCounter;
0:                 count++;
0:         } while (count < this.destinationStatistics.getMessages().getCount());
0:         return movedCounter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         removeMessage(c, null, r, ack);
1:     }
1:     
0:     protected void removeMessage(ConnectionContext context,Subscription sub,QueueMessageReference reference,MessageAck ack) throws IOException {
0:         reference.drop();
1:         acknowledge(context, sub, ack, reference);
0:         destinationStatistics.getMessages().decrement();
0:         synchronized(pagedInMessages) {
0:             pagedInMessages.remove(reference.getMessageId());
1:         }
0:         try {
0:             taskRunner.wakeup();
0:         } catch (InterruptedException e) {
0:             log.warn("Task Runner failed to wakeup ", e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         final int toPageIn = MAXIMUM_PAGE_SIZE - pagedInMessages.size();
/////////////////////////////////////////////////////////////////////////
0:                 for(MessageReference ref:result) {
0:                     pagedInMessages.put(ref.getMessageId(), ref);
1:                 }
commit:634da7a
/////////////////////////////////////////////////////////////////////////
commit:409902c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final List<Subscription> consumers = new ArrayList<Subscription>(50);
commit:2db7df7
/////////////////////////////////////////////////////////////////////////
0:     private final Object sendLock = new Object();
/////////////////////////////////////////////////////////////////////////
0:     public void addSubscription(ConnectionContext context,Subscription sub) throws Exception {
0:         MessageEvaluationContext msgContext = new MessageEvaluationContext();
1: 
0:         // needs to be synchronized - so no contention with dispatching
0:         synchronized (consumers) {
0:             consumers.add(sub);
0:             if (sub.getConsumerInfo().isExclusive()) {
0:                 LockOwner owner = (LockOwner) sub;
0:                 if (exclusiveOwner == null) {
0:                     exclusiveOwner = owner;
0:                 } else {
0:                     // switch the owner if the priority is higher.
0:                     if (owner.getLockPriority() > exclusiveOwner
0:                             .getLockPriority()) {
1:                     }
1:                 }
1:             }
1:         }
1: 
0:         // we hold the lock on the dispatchValue - so lets build the paged in
0:         // list directly;
0:         buildList(false);
1: 
0:         // synchronize with dispatch method so that no new messages are sent
0:         // while
0:         // setting up a subscription. avoid out of order messages,
0:         // duplicates
0:         // etc.
1: 
0:         msgContext.setDestination(destination);
0:         synchronized (pagedInMessages) {
0:             // Add all the matching messages in the queue to the
0:             // subscription.
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i
0:                     .hasNext();) {
0:                 QueueMessageReference node = (QueueMessageReference) i.next();
0:                 if (node.isDropped()
0:                         || (!sub.getConsumerInfo().isBrowser() && node
0:                                 .getLockOwner() != null)) {
0:                     continue;
1:                 }
0:                 try {
0:                     msgContext.setMessageReference(node);
0:                     if (sub.matches(node, msgContext)) {
0:                         sub.add(node);
1:                     }
0:                 } catch (IOException e) {
0:                     log.warn("Could not load message: " + e, e);
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
0:     public void removeSubscription(ConnectionContext context, Subscription sub)
0:             throws Exception {
0:         destinationStatistics.getConsumers().decrement();
0:         maximumPagedInMessages -= sub.getConsumerInfo().getPrefetchSize();
0:         // synchronize with dispatch method so that no new messages are sent
0:         // while
0:         // removing up a subscription.
0:         synchronized (consumers) {
0:             consumers.remove(sub);
0:             if (sub.getConsumerInfo().isExclusive()) {
0:                 LockOwner owner = (LockOwner) sub;
0:                 // Did we loose the exclusive owner??
0:                 if (exclusiveOwner == owner) {
0:                     // Find the exclusive consumer with the higest Lock
0:                     // Priority.
0:                     exclusiveOwner = null;
0:                     for (Iterator<Subscription> iter = consumers.iterator(); iter
0:                             .hasNext();) {
0:                         Subscription s = iter.next();
0:                         LockOwner so = (LockOwner) s;
0:                         if (s.getConsumerInfo().isExclusive()
0:                                 && (exclusiveOwner == null || so
0:                                         .getLockPriority() > exclusiveOwner
0:                                         .getLockPriority())) {
0:                             exclusiveOwner = so;
1:             if (consumers.isEmpty()) {
0:                 messages.gc();
1:             }
1:         }
0:         sub.remove(context, this);
0:         boolean wasExclusiveOwner = false;
0:         if (exclusiveOwner == sub) {
0:             exclusiveOwner = null;
0:             wasExclusiveOwner = true;
1:         }
0:         ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();
0:         MessageGroupSet ownedGroups = getMessageGroupOwners().removeConsumer(
0:                 consumerId);
0:         if (!sub.getConsumerInfo().isBrowser()) {
0:             MessageEvaluationContext msgContext = new MessageEvaluationContext();
1: 
0:             msgContext.setDestination(destination);
0:             // lets copy the messages to dispatch to avoid deadlock
0:             List<QueueMessageReference> messagesToDispatch = new ArrayList<QueueMessageReference>();
0:             synchronized (pagedInMessages) {
0:                 for (Iterator<MessageReference> i = pagedInMessages.iterator(); i
0:                         .hasNext();) {
0:                     QueueMessageReference node = (QueueMessageReference) i
0:                             .next();
0:                     if (node.isDropped()) {
0:                         continue;
1:                     }
0:                     String groupID = node.getGroupID();
0:                     // Re-deliver all messages that the sub locked
0:                     if (node.getLockOwner() == sub
0:                             || wasExclusiveOwner
0:                             || (groupID != null && ownedGroups
0:                                     .contains(groupID))) {
0:                         messagesToDispatch.add(node);
1:             }
0:             // now lets dispatch from the copy of the collection to
0:             // avoid deadlocks
0:             for (Iterator<QueueMessageReference> iter = messagesToDispatch
0:                     .iterator(); iter.hasNext();) {
0:                 QueueMessageReference node = iter.next();
0:                 node.incrementRedeliveryCounter();
0:                 node.unlock();
0:                 msgContext.setMessageReference(node);
0:                 dispatchPolicy.dispatch(node, msgContext, consumers);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:     void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
0:         synchronized (sendLock) {
0:             message.setRegionDestination(this);
0:             if (store != null && message.isPersistent()) {
0:                 while (!systemUsage.getStoreUsage().waitForSpace(1000)) {
0:                     if (context.getStopping().get()) {
0:                         throw new IOException(
0:                                 "Connection closed, send aborted.");
1:                     }
1: 
0:                 store.addMessage(context, message);
1: 
/////////////////////////////////////////////////////////////////////////
0:     private List<MessageReference> buildList(boolean force) throws Exception {
0:             int count = 0;
0:             result = new ArrayList<MessageReference>(toPageIn);
0:             synchronized (messages) {
0:                 try {
0:                     messages.reset();
0:                     while (messages.hasNext() && count < toPageIn) {
0:                         MessageReference node = messages.next();
0:                         messages.remove();
0:                         if (!broker.isExpired(node)) {
0:                             node = createMessageReference(node.getMessage());
0:                             result.add(node);
0:                             count++;
0:                         } else {
0:                             broker.messageExpired(createConnectionContext(),
0:                                     node);
0:                             destinationStatistics.getMessages().decrement();
1:                 } finally {
0:                     messages.release();
1:             }
0:             synchronized (pagedInMessages) {
0:                 pagedInMessages.addAll(result);
0:     private synchronized void doDispatch(List<MessageReference> list) throws Exception {
0:             MessageEvaluationContext msgContext = new MessageEvaluationContext();
0:             for (int i = 0; i < list.size(); i++) {
0:                 MessageReference node = list.get(i);
0:                 msgContext.setDestination(destination);
0:                 msgContext.setMessageReference(node);
0:                 dispatchPolicy.dispatch(node, msgContext, consumers);
1: 
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:     private final TaskRunner taskRunner;
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
1:             messages.setEnableAudit(isEnableAudit());
1:             messages.setMaxAuditDepth(getMaxAuditDepth());
1:             messages.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
0:     synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception{
commit:0da68b4
/////////////////////////////////////////////////////////////////////////
0: public class Queue extends BaseDestination implements Task {
/////////////////////////////////////////////////////////////////////////
0:         if (isProducerFlowControl() && context.isProducerFlowControl() && memoryUsage.isFull()) {
commit:4d01443
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized  void addSubscription(ConnectionContext context, Subscription sub) throws Exception {
1:         	
0:         	//needs to be synchronized - so no contention with dispatching
/////////////////////////////////////////////////////////////////////////
1:             
0:             //we hold the lock on the dispatchValue - so lets build the paged in
0:             //list directly;
0:             buildList(false);
1:            
0:             // etc.  
1:             
1:          
1:             
0:                         if (node.isDropped() ||  (!sub.getConsumerInfo().isBrowser() && node.getLockOwner()!=null)) {
/////////////////////////////////////////////////////////////////////////
1:           
1:             
1:             
0:     public synchronized void removeSubscription(ConnectionContext context,
0: 	        Subscription sub) throws Exception{
0: 		destinationStatistics.getConsumers().decrement();
0: 		maximumPagedInMessages-=sub.getConsumerInfo().getPrefetchSize();
0: 		// synchronize with dispatch method so that no new messages are sent
0: 		// while
0: 		// removing up a subscription.
0: 		synchronized(consumers){
0: 			consumers.remove(sub);
0: 			if(sub.getConsumerInfo().isExclusive()){
0: 				LockOwner owner=(LockOwner)sub;
0: 				// Did we loose the exclusive owner??
0: 				if(exclusiveOwner==owner){
0: 					// Find the exclusive consumer with the higest Lock
0: 					// Priority.
0: 					exclusiveOwner=null;
0: 					for(Iterator<Subscription> iter=consumers.iterator();iter
0: 					        .hasNext();){
0: 						Subscription s=iter.next();
0: 						LockOwner so=(LockOwner)s;
0: 						if(s.getConsumerInfo().isExclusive()
0: 						        &&(exclusiveOwner==null||so.getLockPriority()>exclusiveOwner
0: 						                .getLockPriority())){
0: 							exclusiveOwner=so;
1: 						}
1: 					}
1: 				}
1: 			}
0: 			if(consumers.isEmpty()){
0: 				messages.gc();
1: 			}
1: 		}
0: 		sub.remove(context,this);
0: 		boolean wasExclusiveOwner=false;
0: 		if(exclusiveOwner==sub){
0: 			exclusiveOwner=null;
0: 			wasExclusiveOwner=true;
1: 		}
0: 		ConsumerId consumerId=sub.getConsumerInfo().getConsumerId();
0: 		MessageGroupSet ownedGroups=getMessageGroupOwners().removeConsumer(
0: 		        consumerId);
0: 		if(!sub.getConsumerInfo().isBrowser()){
0: 			MessageEvaluationContext msgContext=context
0: 			        .getMessageEvaluationContext();
0: 			try{
0: 				msgContext.setDestination(destination);
0: 				// lets copy the messages to dispatch to avoid deadlock
0: 				List<QueueMessageReference> messagesToDispatch=new ArrayList<QueueMessageReference>();
0: 				synchronized(pagedInMessages){
0: 					for(Iterator<MessageReference> i=pagedInMessages.iterator();i
0: 					        .hasNext();){
0: 						QueueMessageReference node=(QueueMessageReference)i
0: 						        .next();
0: 						if(node.isDropped()){
0: 							continue;
1: 						}
0: 						String groupID=node.getGroupID();
0: 						// Re-deliver all messages that the sub locked
0: 						if(node.getLockOwner()==sub
0: 						        ||wasExclusiveOwner
0: 						        ||(groupID!=null&&ownedGroups.contains(groupID))){
0: 							messagesToDispatch.add(node);
1: 						}
1: 					}
1: 				}
0: 				// now lets dispatch from the copy of the collection to
0: 				// avoid deadlocks
0: 				for(Iterator<QueueMessageReference> iter=messagesToDispatch
0: 				        .iterator();iter.hasNext();){
0: 					QueueMessageReference node=iter.next();
0: 					node.incrementRedeliveryCounter();
0: 					node.unlock();
0: 					msgContext.setMessageReference(node);
0: 					dispatchPolicy.dispatch(node,msgContext,consumers);
1: 				}
0: 			}finally{
0: 				msgContext.clear();
1: 			}
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
1:     
0:     private   List<MessageReference> doPageIn(boolean force) throws Exception {
0:     	 List<MessageReference> result  = null;
0:     		result  = buildList(force);
0:     	return  result;
0:     private   synchronized List<MessageReference> buildList(boolean force) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     private  synchronized void doDispatch(List<MessageReference> list) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     private final SystemUsage systemUsage;
0:     private final MemoryUsage memoryUsage;
/////////////////////////////////////////////////////////////////////////
0:     public Queue(Broker broker, ActiveMQDestination destination, final SystemUsage systemUsage, MessageStore store, DestinationStatistics parentStats,
0:         this.systemUsage=systemUsage;
0:         this.memoryUsage = new MemoryUsage(systemUsage.getMemoryUsage(), destination.toString());
0:         this.memoryUsage.setUsagePortion(1.0f);
/////////////////////////////////////////////////////////////////////////
0:             store.setMemoryUsage(memoryUsage);
/////////////////////////////////////////////////////////////////////////
1:             messages.setSystemUsage(systemUsage);
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl() && memoryUsage.isFull()) {
0:             if (systemUsage.isSendFailIfNoSpace()) {
0:                 throw new javax.jms.ResourceAllocationException("SystemUsage memory limit reached");
/////////////////////////////////////////////////////////////////////////
0:                     if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
/////////////////////////////////////////////////////////////////////////
0:                 while (!memoryUsage.waitForSpace(1000)) {
/////////////////////////////////////////////////////////////////////////
0:             systemUsage.getStoreUsage().waitForSpace();
/////////////////////////////////////////////////////////////////////////
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size() + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + size
0:         if (memoryUsage != null) {
0:             memoryUsage.start();
/////////////////////////////////////////////////////////////////////////
0:         if (memoryUsage != null) {
0:             memoryUsage.stop();
/////////////////////////////////////////////////////////////////////////
0:     public MemoryUsage getBrokerMemoryUsage() {
0:         return memoryUsage;
/////////////////////////////////////////////////////////////////////////
0:         while (!memoryUsage.isFull() && !messagesWaitingForSpace.isEmpty()) {
commit:a401575
/////////////////////////////////////////////////////////////////////////
0:                         if(broker.isExpired(message)){
/////////////////////////////////////////////////////////////////////////
0: 	            	        	if(broker.isExpired(message)) {
/////////////////////////////////////////////////////////////////////////
0: 	                    if(broker.isExpired(message)){
/////////////////////////////////////////////////////////////////////////
0:                             if(!broker.isExpired(node)){
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:                     public boolean recoverMessage(Message message){
1:                             return true;
0:                         if(hasSpace()){
0:                             message.setRegionDestination(Queue.this);
0:                             synchronized(messages){
0:                                 try{
1:                                     messages.addMessageLast(message);
0:                                 }catch(Exception e){
0:                                     log.fatal("Failed to add message to cursor",e);
1:                                 }
1:                             destinationStatistics.getMessages().increment();
1:                             return true;
1:                         return false;
0:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception{
commit:a414c20
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     final Broker broker;
0:     public Queue(Broker broker,ActiveMQDestination destination, final UsageManager memoryManager, MessageStore store, DestinationStatistics parentStats,
0:         this.broker=broker;
/////////////////////////////////////////////////////////////////////////
0:                             broker.messageExpired(createConnectionContext(),message);
0:                             destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:             broker.messageExpired(context,message);
0:             destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:         			            broker.messageExpired(context,message);
0:                                 destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0: 	                        broker.messageExpired(context,message);
0:                             destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:                                 broker.messageExpired(createConnectionContext(),node);
0:                                 destinationStatistics.getMessages().decrement();
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
/////////////////////////////////////////////////////////////////////////
0:     final void sendMessage(final ConnectionContext context,Message msg) throws Exception{
commit:0527eba
/////////////////////////////////////////////////////////////////////////
0:         message.incrementReferenceCount();
commit:14c605f
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager = new UsageManager(memoryManager,destination.toString());
/////////////////////////////////////////////////////////////////////////
0:         if (usageManager != null) {
0:             usageManager.start();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (usageManager != null) {
0:             usageManager.stop();
1:         }
commit:ee4bb53
/////////////////////////////////////////////////////////////////////////
0:             messages.setMaxBatchSize(toPageIn);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
commit:d2e6062
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.StoreQueueCursor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0:     private  PendingMessageCursor messages;
/////////////////////////////////////////////////////////////////////////
0:     private boolean started = false;
0:             TaskRunnerFactory taskFactory, Store tmpStore) throws Exception {
0:         if(destination.isTemporary()){
0:             this.messages=new VMPendingMessageCursor();
0:         }else{
0:             this.messages=new StoreQueueCursor(this,tmpStore);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:                         // Message could have expired while it was being loaded..
0:                         if(message.isExpired()){
0:                             // TODO remove from store
1:                             return;
1:                         }
0:                         message.setRegionDestination(Queue.this);
/////////////////////////////////////////////////////////////////////////
1:      * 
0:      * @see org.apache.activemq.broker.region.Destination#lock(org.apache.activemq.broker.region.MessageReference,
0:      *      org.apache.activemq.broker.region.LockOwner)
/////////////////////////////////////////////////////////////////////////
1:         // There is delay between the client sending it and it arriving at the
1:         // destination.. it may have expired.
0:         if(message.isExpired()){
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Expired message: " + message);
1:             }
0:             return;
1:         }
0:                 if(message.isExpired()){
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Expired message: " + message);
1:                     }
0:                     return;
1:                 }
0:         if(store!=null&&message.isPersistent()){
0:             store.addMessage(context,message);
0:                     //even though the message could be expired - it won't be from the store
0:                     //and it's important to keep the store/cursor in step
0:                     synchronized(messages){
0:                         messages.addMessageLast(message);
1:                     }
0:                     // It could take while before we receive the commit
0:                     // operration.. by that time the message could have expired..
0:                     if(message.isExpired()){
0:                         // TODO: remove message from store.
0:                         if (log.isDebugEnabled()) {
0:                             log.debug("Expired message: " + message);
1:                         }
0:                         return;
1:                     }
0:             synchronized(messages){
0:                 messages.addMessageLast(message);
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
0:         started = true;
0:         messages.start();
0:         doPageIn(false);
0:         started = false;
0:         if(messages!=null){
0:             messages.stop();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         try{
1:             doPageIn(true);
0:         }catch(Exception e){
0:             log.error("caught an exception browsing " + this,e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     log.error("caught an exception browsing " + this,e);
/////////////////////////////////////////////////////////////////////////
1:       
1:         
/////////////////////////////////////////////////////////////////////////
1:     
0:         if((force||!consumers.isEmpty())&&toPageIn>0){
/////////////////////////////////////////////////////////////////////////
0:                             if(!node.isExpired()){
0:                                 node=createMessageReference(node.getMessage());
0:                                 result.add(node);
0:                                 count++;
0:                             }else{
0:                                 if (log.isDebugEnabled()) {
0:                                     log.debug("Expired message: " + node);
1:                                 }
1:                             }
commit:ec63977
/////////////////////////////////////////////////////////////////////////
0:         synchronized(messages){
0:             try{
0:                 messages.reset();
0:                 while(messages.hasNext()){
0:                     try{
0:                         MessageReference r=messages.next();
0:                         r.incrementReferenceCount();
0:                         try{
0:                             Message m=r.getMessage();
0:                             if(m!=null){
0:                                 l.add(m);
1:                             }
0:                         }finally{
0:                             r.decrementReferenceCount();
0:                     }catch(IOException e){
0:                         log.error("caught an exception brwsing "+this,e);
0:             }finally{
0:                 messages.release();
0:     public Message getMessage(String messageId){
0:         synchronized(messages){
0:             try{
0:                 messages.reset();
0:                 while(messages.hasNext()){
0:                     try{
0:                         MessageReference r=messages.next();
0:                         if(messageId.equals(r.getMessageId().toString())){
0:                             r.incrementReferenceCount();
0:                             try{
0:                                 Message m=r.getMessage();
0:                                 if(m!=null){
0:                                     return m;
1:                                 }
0:                             }finally{
0:                                 r.decrementReferenceCount();
0:                             break;
0:                     }catch(IOException e){
0:                         log.error("got an exception retrieving message "+messageId);
0:             }finally{
0:                 messages.release();
/////////////////////////////////////////////////////////////////////////
0:                     try{
0:                         messages.reset();
0:                         while(messages.hasNext()&&count<toPageIn){
0:                             MessageReference node=messages.next();
0:                             messages.remove();
0:                             node=createMessageReference(node.getMessage());
0:                             result.add(node);
0:                             count++;
1:                         }
0:                     }finally{
0:                         messages.release();
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:             messages.setUsageManager(getUsageManager());
/////////////////////////////////////////////////////////////////////////
1: 
0:                     public boolean hasSpace(){
1:                         return true;
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                 if (consumers.isEmpty()) {
0:                     messages.gc();
1:                 }
commit:e006780
/////////////////////////////////////////////////////////////////////////
0:         try{
0:             taskRunner.wakeup();
0:         }catch(InterruptedException e){
0:             log.warn("Task Runner failed to wakeup ",e);
1:         }
/////////////////////////////////////////////////////////////////////////
commit:3b28c7c
/////////////////////////////////////////////////////////////////////////
0:     private final Object doDispatchMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:     public MessageStore getMessageStore() {
/////////////////////////////////////////////////////////////////////////
0:         pageInMessages();
/////////////////////////////////////////////////////////////////////////
0:         pageInMessages();
/////////////////////////////////////////////////////////////////////////
0:         pageInMessages();
/////////////////////////////////////////////////////////////////////////
0:         pageInMessages();
/////////////////////////////////////////////////////////////////////////
0:             pageInMessages(false);
/////////////////////////////////////////////////////////////////////////
0:         pageInMessages(false);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private void pageInMessages() throws Exception{
0:         pageInMessages(true);
1:     }
0:     private void pageInMessages(boolean force) throws Exception{
0:         synchronized(doDispatchMutex) {
0:             doDispatch(doPageIn(force));
1:         }
1:     }
commit:6895d00
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
/////////////////////////////////////////////////////////////////////////
0: public class Queue implements Destination, Task {
0:     private final ActiveMQDestination destination;
0:     private final List consumers = new CopyOnWriteArrayList();
0:     private final Valve dispatchValve = new Valve(true);
0:     private final UsageManager usageManager;
0:     private final DestinationStatistics destinationStatistics = new DestinationStatistics();
0:     private  PendingMessageCursor messages = new VMPendingMessageCursor();
0:     private final LinkedList pagedInMessages = new LinkedList();
0:     private int garbageSize = 0;
0:     private int garbageSizeBeforeCollection = 1000;
0:     private final MessageStore store;
0:     private int highestSubscriptionPriority = Integer.MIN_VALUE;
0:     private int maximumPagedInMessages = garbageSizeBeforeCollection * 2;
0:     private final MessageEvaluationContext queueMsgConext = new MessageEvaluationContext();
0:     private final Object exclusiveLockMutex = new Object();
0:     private TaskRunner taskRunner;
/////////////////////////////////////////////////////////////////////////
0:         this.taskRunner = taskFactory.createTaskRunner(this, "Queue  "+destination.getPhysicalName());
/////////////////////////////////////////////////////////////////////////
0:     public void initialize() throws Exception{
0:         if(store!=null){
0:             messages.start();
0:             if(messages.isRecoveryRequired()){
0:                 store.recover(new MessageRecoveryListener(){
1: 
0:                     public void recoverMessage(Message message){
0:                         message.setRegionDestination(Queue.this);
0:                         synchronized(messages){
0:                             try{
0:                                 messages.addMessageLast(message);
0:                             }catch(Exception e){
0:                                 log.fatal("Failed to add message to cursor",e);
1:                             }
1:                         destinationStatistics.getMessages().increment();
0:                     public void recoverMessageReference(String messageReference) throws Exception{
1:                         throw new RuntimeException("Should not be called.");
1:                     }
0:                     public void finished(){
1:                     }
0:                 });
1:             }
1:     /**
0:      * Lock a node
0:      * @param node
0:      * @param lockOwner
0:      * @return true if can be locked
0:      * @see org.apache.activemq.broker.region.Destination#lock(org.apache.activemq.broker.region.MessageReference, org.apache.activemq.broker.region.LockOwner)
1:      */
0:     public boolean lock(MessageReference node,LockOwner lockOwner){
0:         synchronized(exclusiveLockMutex){
0:             if(exclusiveOwner==lockOwner){
0:                 return true;
1:             }
0:             if(exclusiveOwner!=null){
0:                 return false;
1:             }
0:             if(lockOwner.getLockPriority()<highestSubscriptionPriority){
0:                 return false;
1:             }
0:             if(lockOwner.isLockExclusive()){
0:                 exclusiveOwner=lockOwner;
1:             }
/////////////////////////////////////////////////////////////////////////
0:         maximumPagedInMessages += sub.getConsumerInfo().getPrefetchSize();
1:         
1:         
0:         MessageEvaluationContext msgContext=context.getMessageEvaluationContext();
0:         try{
0:             synchronized(consumers){
/////////////////////////////////////////////////////////////////////////
0:             // page in messages
0:             doPageIn();
0:             // synchronize with dispatch method so that no new messages are sent
0:             // while
0:             // setting up a subscription. avoid out of order messages, duplicates
0:             // etc.
0:             dispatchValve.turnOff();
0:             if (sub.getConsumerInfo().getPriority() > highestSubscriptionPriority) {
0:                 highestSubscriptionPriority = sub.getConsumerInfo().getPriority();
1:             }
0:             synchronized(pagedInMessages){
0:                 for(Iterator i=pagedInMessages.iterator();i.hasNext();){
0:                     QueueMessageReference node=(QueueMessageReference)i.next();
0:                     if(node.isDropped()){
0:                     try{
0:                         if(sub.matches(node,msgContext)){
0:                     }catch(IOException e){
0:                         log.warn("Could not load message: "+e,e);
0:         }finally{
/////////////////////////////////////////////////////////////////////////
0:         maximumPagedInMessages -= sub.getConsumerInfo().getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
0:                     synchronized (pagedInMessages) {
0:                         for(Iterator i =  pagedInMessages.iterator();i.hasNext();) {
0:                             QueueMessageReference node = (QueueMessageReference) i.next();
/////////////////////////////////////////////////////////////////////////
0:                         dispatchPolicy.dispatch(node, msgContext, consumers);
/////////////////////////////////////////////////////////////////////////
0:     public void send(final ConnectionContext context,final Message message) throws Exception{
0:         if(context.isProducerFlowControl()){
0:             if(usageManager.isSendFailIfNoSpace()&&usageManager.isFull()){
0:             }else{
0:         if (store != null && message.isPersistent()) {
0:         if(context.isInTransaction()){
0:             context.getTransaction().addSynchronization(new Synchronization(){
1: 
0:                 public void afterCommit() throws Exception{
0:                     sendMessage(context,message);
1:                 }
0:             });
0:         }else{
0:             sendMessage(context,message);
1:        
1:     
/////////////////////////////////////////////////////////////////////////
0:     public void dropEvent(boolean skipGc){
0:         synchronized(pagedInMessages){
1:         }
0:         if(!skipGc&&garbageSize>garbageSizeBeforeCollection){
0:             gc();
0:         synchronized (pagedInMessages) {
0:             for(Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 QueueMessageReference node = (QueueMessageReference) i.next();
0:                     i.remove();
0:         try{
0:             taskRunner.wakeup();
0:         }catch(InterruptedException e){
0:             log.warn("Task Runner failed to wakeup ",e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if( taskRunner!=null ) {
0:             taskRunner.shutdown();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         MessageReference result =  new IndirectMessageReference(this, store, message);
0:         result.decrementReferenceCount();
1:         return result;
1:     
/////////////////////////////////////////////////////////////////////////
0:         synchronized(pagedInMessages) {
0:             for (Iterator i = pagedInMessages.iterator();i.hasNext();) {
0:                 MessageReference r = (MessageReference)i.next();
0:                 r.incrementReferenceCount();
0:                 try {
0:                     Message m = r.getMessage();
0:                     if (m != null) {
0:                         l.add(m);
1:                     }
0:                 }catch(IOException e){
0:                     log.error("caught an exception brwsing " + this,e);
1:                 }
0:                 finally {
0:                     r.decrementReferenceCount();
1:                 }
1:             }
1:         }
0:                     MessageReference r = messages.next();
/////////////////////////////////////////////////////////////////////////
0:                     log.error("caught an exception brwsing " + this,e);
/////////////////////////////////////////////////////////////////////////
0:                     MessageReference r = messages.next();
/////////////////////////////////////////////////////////////////////////
0:                     log.error("got an exception retrieving message " + messageId);
0:     public void purge() throws Exception {
1:         
0:             doDispatch(doPageIn());
1:         
0:         synchronized (pagedInMessages) {
0:             for(Iterator i = pagedInMessages.iterator(); i.hasNext();){
0:                     QueueMessageReference r = (QueueMessageReference) i.next();
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageIn());
0:         synchronized (pagedInMessages) {
0:            for(Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                IndirectMessageReference r = (IndirectMessageReference) i.next();
0:                     removeMessage(c, r);
0:                     if (++counter >= maximumMessages && maximumMessages > 0) {
0:                         break;
1:                     
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageIn());
0:         synchronized (pagedInMessages) {
0:             for(Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 MessageReference r = (MessageReference) i.next();
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageIn());
0:         synchronized (pagedInMessages) {
0:             for(Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 IndirectMessageReference r = (IndirectMessageReference) i.next();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @return
1:      * @see org.apache.activemq.thread.Task#iterate()
1:      */
0:     public boolean iterate(){
0:         try{
0:             doDispatch(doPageIn(false));
0:          }catch(Exception e){
0:              log.error("Failed to page in more queue messages ",e);
1:          }
0:         return false;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:     
0:     private void sendMessage(final ConnectionContext context,Message msg) throws Exception{
1:         
0:         synchronized(messages){
0:             messages.addMessageLast(msg);
1:         }
1:         destinationStatistics.getEnqueues().increment();
1:         destinationStatistics.getMessages().increment();
0:         doDispatch(doPageIn(false));
1:     }
1:     
0:     private List doPageIn() throws Exception{
0:         return doPageIn(true);
1:     }
0:     private List doPageIn(boolean force) throws Exception{
0:         final int toPageIn=maximumPagedInMessages-pagedInMessages.size();
0:         List result=null;
0:         if((force || !consumers.isEmpty())&&toPageIn>0){
0:             try{
0:                 dispatchValve.increment();
0:                 int count=0;
0:                 result=new ArrayList(toPageIn);
0:                 synchronized(messages){
0:                     messages.reset();
0:                     while(messages.hasNext()&&count<toPageIn){
0:                         MessageReference node=messages.next();
0:                         messages.remove();
0:                         node=createMessageReference(node.getMessage());
0:                         result.add(node);
0:                         count++;
1:                     }
1:                 }
0:                 synchronized(pagedInMessages){
0:                     pagedInMessages.addAll(result);
1:                 }
0:             }finally{
0:                 queueMsgConext.clear();
0:                 dispatchValve.decrement();
1:             }
1:         }
0:         return result;
1:     }
1: 
0:     private void doDispatch(List list) throws Exception{
0:         if(list!=null&&!list.isEmpty()){
0:             try{
0:                 dispatchValve.increment();
0:                 for(int i=0;i<list.size();i++){
0:                     MessageReference node=(MessageReference)list.get(i);
0:                     queueMsgConext.setDestination(destination);
0:                     queueMsgConext.setMessageReference(node);
0:                     dispatchPolicy.dispatch(node,queueMsgConext,consumers);
1:                 }
0:             }finally{
0:                 queueMsgConext.clear();
0:                 dispatchValve.decrement();
1:             }
1:         }
1:     }
1: 
1:     
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
0: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
0: import org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:     protected  PendingMessageCursor messages = new VMPendingMessageCursor();
/////////////////////////////////////////////////////////////////////////
1:         
1:     }
1:     
0:     public void initialize() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                         try{
0:                             messages.addMessageLast(reference);
0:                         }catch(Exception e){
0:                            log.fatal("Failed to add message to cursor",e);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                 messages.reset();
0:                 while(messages.hasNext()) {
0:                     QueueMessageReference node = (QueueMessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:                         messages.reset();
0:                         while(messages.hasNext()) {
0:                             QueueMessageReference node = (QueueMessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.resetForGC();
0:             while(messages.hasNext()) {
0:                 QueueMessageReference node = (QueueMessageReference) messages.next();
0:                     messages.remove();
/////////////////////////////////////////////////////////////////////////
0:     public PendingMessageCursor getMessages(){
1:         return this.messages;
1:     }
0:     public void setMessages(PendingMessageCursor messages){
0:         this.messages=messages;
1:     }
/////////////////////////////////////////////////////////////////////////
0:                 messages.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                     MessageReference r = (MessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                     MessageReference r = (MessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                     QueueMessageReference r = (QueueMessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                 IndirectMessageReference r = (IndirectMessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                 MessageReference r = (MessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
0:             while(messages.hasNext()) {
0:                 IndirectMessageReference r = (IndirectMessageReference) messages.next();
/////////////////////////////////////////////////////////////////////////
commit:bfaff9b
/////////////////////////////////////////////////////////////////////////
0:                     QueueMessageReference node = (QueueMessageReference) iter.next();
/////////////////////////////////////////////////////////////////////////
0:                             QueueMessageReference node = (QueueMessageReference) iter.next();
/////////////////////////////////////////////////////////////////////////
0:                         QueueMessageReference node = (QueueMessageReference) iter.next();
/////////////////////////////////////////////////////////////////////////
0:                 QueueMessageReference node = (QueueMessageReference) iter.next();
/////////////////////////////////////////////////////////////////////////
1:     Message loadMessage(MessageId messageId) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         return new IndirectMessageReference(this, store, message);
/////////////////////////////////////////////////////////////////////////
0:     MessageStore getMessageStore() {
/////////////////////////////////////////////////////////////////////////
0:                     QueueMessageReference r = (QueueMessageReference) iter.next();
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 public void finished(){
1:                 }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c50b8e4
/////////////////////////////////////////////////////////////////////////
0:     // Messages that are paged in but have not yet been targeted at a subscription
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } finally {
/////////////////////////////////////////////////////////////////////////
0:             // consumersLock.
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:         } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
1:         } finally {
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ("
0:                              + memoryUsage.getLimit()
0:                              + ") reached on "
0:                              + getActiveMQDestination().getQualifiedName()
0:                              + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it."
0:                              + " See http://activemq.apache.org/producer-flow-control.html for more info");
/////////////////////////////////////////////////////////////////////////
0:         try {
1:         } finally {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         try {
1:         } finally {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             if (!node.isAcked() && !browser.isDuplicate(node.getMessageId())) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:         try {
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:                 } finally {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         try {
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
commit:97502bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             if (isDLQ()) {
0:                 DeadLetterStrategy stratagy = getDeadLetterStrategy();
0:                 stratagy.rollback(m.getMessage());
1:             }
0:         } finally {
commit:540b1c6
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:             doPageIn(true, false);  // signal no expiry processing needed.
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:         doPageIn(force, true);
1:     }
1: 
0:     private void doPageIn(boolean force, boolean processExpired) throws Exception {
0:         PendingList newlyPaged = doPageInForDispatch(force, processExpired);
/////////////////////////////////////////////////////////////////////////
0:     private PendingList doPageInForDispatch(boolean force, boolean processExpired) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                         if (processExpired && ref.isExpired()) {
/////////////////////////////////////////////////////////////////////////
1:             MessageReference node = iterator.next();
/////////////////////////////////////////////////////////////////////////
0:                 rc.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageInForDispatch(force, true));
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:3813947
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:         Set<MessageReference> set = new LinkedHashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
0:         Set<QueueMessageReference> set = new LinkedHashSet<QueueMessageReference>();
commit:3a5b48a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatchNotification;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerAck;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.Response;
commit:a1d5ff0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final Map<MessageId, Runnable> messagesWaitingForSpace = new LinkedHashMap<MessageId, Runnable>();
1:     private boolean iterationRunning = false;
/////////////////////////////////////////////////////////////////////////
1:             // If optimize dispatch is on or this is a slave this method could be called recursively
1:             // we set this state value to short-circuit wakeup in those cases to avoid that as it
1:             // could lead to errors.
1:             iterationRunning = true;
1: 
/////////////////////////////////////////////////////////////////////////
0:             } finally {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             iterationRunning = false;
1: 
/////////////////////////////////////////////////////////////////////////
0:         if ((optimizedDispatch || isSlave()) && !iterationRunning) {
commit:cb1b92b
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0: import org.apache.activemq.broker.region.cursors.OrderedPendingList;
0: import org.apache.activemq.broker.region.cursors.PendingList;
0: import org.apache.activemq.broker.region.cursors.PrioritizedPendingList;
/////////////////////////////////////////////////////////////////////////
0:     protected PendingList pagedInPendingDispatch = new OrderedPendingList();
0:     protected PendingList redeliveredWaitingDispatch = new OrderedPendingList();
/////////////////////////////////////////////////////////////////////////
1:     private final Object iteratingMutex = new Object();
/////////////////////////////////////////////////////////////////////////
1:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:         super.setPrioritizedMessages(prioritizedMessages);
1: 
0:         if (prioritizedMessages && this.pagedInPendingDispatch instanceof OrderedPendingList) {
0:             pagedInPendingDispatch = new PrioritizedPendingList();
0:             redeliveredWaitingDispatch = new PrioritizedPendingList();
0:         } else if(pagedInPendingDispatch instanceof PrioritizedPendingList) {
0:             pagedInPendingDispatch = new OrderedPendingList();
0:             redeliveredWaitingDispatch = new OrderedPendingList();
1:         }
1:     }
1: 
0:     @Override
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                     redeliveredWaitingDispatch.addMessageLast(qmr);
1:                     doDispatch(new OrderedPendingList());
/////////////////////////////////////////////////////////////////////////
0:                 addAll(pagedInPendingDispatch.values(), browseList, max, toExpire);
/////////////////////////////////////////////////////////////////////////
0:     private void addAll(Collection<? extends MessageReference> refs, List<Message> l, int maxBrowsePageSize,
0:         for (Iterator<? extends MessageReference> i = refs.iterator(); i.hasNext() && l.size() < getMaxBrowsePageSize();) {
1:             QueueMessageReference ref = (QueueMessageReference) i.next();
/////////////////////////////////////////////////////////////////////////
0:         PendingList newlyPaged = doPageInForDispatch(force);
1: 
1:                 for (MessageReference qmr : newlyPaged) {
0:                         pagedInPendingDispatch.addMessageLast(qmr);
/////////////////////////////////////////////////////////////////////////
0:     private PendingList doPageInForDispatch(boolean force) throws Exception {
1:         PendingList resultList = null;
/////////////////////////////////////////////////////////////////////////
0:                 if(isPrioritizedMessages()) {
0:                     resultList = new PrioritizedPendingList();
0:                 } else {
0:                     resultList = new OrderedPendingList();
1:                 }
0:                         resultList.addMessageLast(ref);
/////////////////////////////////////////////////////////////////////////
0:             resultList = new OrderedPendingList();
1:     private void doDispatch(PendingList list) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     for (MessageReference qmr : list) {
0:                             pagedInPendingDispatch.addMessageLast(qmr);
/////////////////////////////////////////////////////////////////////////
1:     private PendingList doActualDispatch(PendingList list) throws Exception {
1: 
/////////////////////////////////////////////////////////////////////////
0:         PendingList rc;
0:         if(isPrioritizedMessages()) {
0:             rc = new PrioritizedPendingList();
0:         } else {
0:             rc = new OrderedPendingList();
1:         }
1: 
1:         for (Iterator<MessageReference> iterator = list.iterator(); iterator.hasNext();) {
1: 
0:             MessageReference node = (MessageReference) iterator.next();
/////////////////////////////////////////////////////////////////////////
0:                 rc.addMessageLast((QueueMessageReference) node);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             for (MessageReference ref : pagedInPendingDispatch) {
1:                     message = (QueueMessageReference)ref;
commit:d5b604e
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (selector == null || selector.isEmpty()) {
1:             return new MessageReferenceFilter() {
1: 
0:                 @Override
1:                 public boolean evaluate(ConnectionContext context, MessageReference messageReference) throws JMSException {
0:                     return true;
1:                 }
1:             };
1:         }
1: 
commit:f24b4f7
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentLinkedQueue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     ConcurrentLinkedQueue<BrowserDispatch> browserDispatches = new ConcurrentLinkedQueue<BrowserDispatch>();
/////////////////////////////////////////////////////////////////////////
1:                 BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription);
1:                 browserDispatches.add(browserDispatch);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             BrowserDispatch pendingBrowserDispatch = browserDispatches.poll();
/////////////////////////////////////////////////////////////////////////
0:                 } while ((pendingBrowserDispatch = browserDispatches.poll()) != null);
/////////////////////////////////////////////////////////////////////////
1:     public void onUsageChanged(@SuppressWarnings("rawtypes") Usage usage, int oldPercentUsage, int newPercentUsage) {
commit:c1ebbc1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                         if (exclusiveConsumer == null
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (store != null && message.isPersistent()) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:                     + systemUsage.getTempUsage().getPercentUsage() + "% of " + systemUsage.getTempUsage().getLimit()
0: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
0:         Set<MessageReference> set = new HashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
0:         Set<MessageReference> set = new HashSet<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:         Set<QueueMessageReference> set = new HashSet<QueueMessageReference>();
/////////////////////////////////////////////////////////////////////////
0: 
1:     final void messageSent(final ConnectionContext context, final Message msg) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     if (!pagedInMessages.containsKey(ref.getMessageId())) {
/////////////////////////////////////////////////////////////////////////
1:      *
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:34f3329
/////////////////////////////////////////////////////////////////////////
1:                                     if (!sendProducerAck && !context.isInRecoveryMode() && !brokerService.isStopping()) {
commit:c5788d2
/////////////////////////////////////////////////////////////////////////
0:                 for (Transaction tx : orderedWork) {
0:                     syncs.add(sendSyncs.remove(tx));
1:                 }
0:                     for (SendSync sync : syncs) {
commit:548c194
/////////////////////////////////////////////////////////////////////////
0:                         SendSync sync = sendSyncs.remove(tx);
commit:0deda25
/////////////////////////////////////////////////////////////////////////
0: 
0:                 ArrayList<SendSync> syncs = new ArrayList<SendSync>(orderedWork.size());;
0: 
0:                         SendSync sync = sendSyncs.get(tx);
0:                         sync.processSend();
0:                         syncs.add(sync);
0: 
0:                 for (SendSync sync : syncs) {
0:                     sync.processSent();
1:                 }
commit:8461158
/////////////////////////////////////////////////////////////////////////
0:             LinkedList<Transaction> orderedWork = new LinkedList<Transaction>();;
0:                 Transaction next = orderIndexUpdates.peek();
0:                 while( next!=null && next.isCommitted() ) {
0:                     orderedWork.addLast(orderIndexUpdates.removeFirst());
0:                     next = orderIndexUpdates.peek();
0:             if (!orderedWork.isEmpty()) {
0:                         sendSyncs.remove(tx);
commit:30f531d
/////////////////////////////////////////////////////////////////////////
0:             if (!this.optimizedDispatch) {
0:         if (this.optimizedDispatch) {
/////////////////////////////////////////////////////////////////////////
0:             if (!this.optimizedDispatch) {
0:         if (this.optimizedDispatch) {
/////////////////////////////////////////////////////////////////////////
1:         if (optimizedDispatch && !iterationRunning) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (this.consumers.isEmpty()) {
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:a24133e
/////////////////////////////////////////////////////////////////////////
0:                     // copy the exchange state since the context will be modified while we are waiting
1:                     // for space.
1:                     final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy(); 
/////////////////////////////////////////////////////////////////////////
1:                                         doMessageSend(producerExchangeCopy, message);
commit:3fe7760
/////////////////////////////////////////////////////////////////////////
0:  	                            // Log showing message dispatching
0:  	                            if (LOG.isDebugEnabled()) {
0:  	                                LOG.debug(destination.getQualifiedName() + " - Recovery - Message pushed '" + node.hashCode() + " - " + node + "' to subscription: '" + rd.subscription + "'");
1:  	                            }
/////////////////////////////////////////////////////////////////////////
1:             acknowledge(context, sub, ack, reference);
0:             try {
1:                 acknowledge(context, sub, ack, reference);
0:             } finally {
1:                 context.getTransaction().addSynchronization(new Synchronization() {
1:                     public void afterCommit() throws Exception {
0:                         dropMessage(reference);
0:                         wakeup();
1:                     }
1:                     public void afterRollback() throws Exception {
1:                         reference.setAcked(false);
1:                     }
0:                 });
1:             }
/////////////////////////////////////////////////////////////////////////
0:         List<QueueMessageReference> resultList = null;
0:             int toPageIn = getMaxPageSize() + Math.max(0, (int)destinationStatistics.getInflight().getCount()) - pagedInMessages.size();
0:             toPageIn = Math.max(0, Math.min(toPageIn, getMaxPageSize()));
/////////////////////////////////////////////////////////////////////////
0:                 // Only add new messages, not already pagedIn to avoid multiple dispatch attempts
0:                     resultList = new ArrayList<QueueMessageReference>(result.size());
0:                     for(QueueMessageReference ref : result) {
0:                         if (!pagedInMessages.containsKey(ref.getMessageId())) {
0:                             pagedInMessages.put(ref.getMessageId(), ref);
0:                             resultList.add(ref);
1:                         }
0:             } else {
0:                 // Avoid return null list, if condition is not validated
0:                 resultList = new ArrayList<QueueMessageReference>();
0:         return resultList;
commit:c6e0a61
/////////////////////////////////////////////////////////////////////////
commit:44e0eaf
/////////////////////////////////////////////////////////////////////////
0:     protected static final Log LOG = LogFactory.getLog(Queue.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.fatal("Failed to add message to cursor", e);
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Expired message: " + message);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("caught an exception browsing " + this, e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("caught an exception browsing " + this, e);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.error("caught an exception brwsing " + this, e);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.error("got an exception retrieving message " + messageId);
/////////////////////////////////////////////////////////////////////////
1: 	                LOG.error("Failed to page in more queue messages ", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Task Runner failed to wakeup ", e);
commit:00fb444
/////////////////////////////////////////////////////////////////////////
0:     protected void removeMessage(ConnectionContext context,Subscription sub,final QueueMessageReference reference,MessageAck ack) throws IOException {
0:         reference.setAcked(true);
1:         // This sends the ack the the journal..
0: 
1:         if (!ack.isInTransaction()) {
0:             reference.drop();
0:             destinationStatistics.getMessages().decrement();
0:             synchronized(pagedInMessages) {
0:                 pagedInMessages.remove(reference.getMessageId());
1:             }
0:             wakeup();
0:         } else {
0:             context.getTransaction().addSynchronization(new Synchronization() {
0:                 
1:                 public void afterCommit() throws Exception {
0:                     reference.drop();
0:                     destinationStatistics.getMessages().decrement();
0:                     synchronized(pagedInMessages) {
0:                         pagedInMessages.remove(reference.getMessageId());
1:                     }
0:                     wakeup();
1:                 }
0:                 
1:                 public void afterRollback() throws Exception {
0:                     reference.setAcked(false);
1:                 }
0:             });
0: 
commit:2a328ed
/////////////////////////////////////////////////////////////////////////
0:     private final Object iteratingMutex = new Object() {};
/////////////////////////////////////////////////////////////////////////
0:         synchronized(iteratingMutex) {
0: 	        RecoveryDispatch rd;
0: 	        while ((rd = getNextRecoveryDispatch()) != null) {
0: 	            try {
0: 	                MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
0: 	                msgContext.setDestination(destination);
0: 	    
0: 	                for (QueueMessageReference node : rd.messages) {
0: 	                    if (!node.isDropped() && !node.isAcked() && (!node.isDropped() || rd.subscription.getConsumerInfo().isBrowser())) {
0: 	                        msgContext.setMessageReference(node);
0: 	                            if (rd.subscription.matches(node, msgContext)) {
0: 	                                rd.subscription.add(node);
1: 	                            }
1: 	                    }
1: 	                }
0: 	                
0: 	                if( rd.subscription instanceof QueueBrowserSubscription ) {
0: 	                    ((QueueBrowserSubscription)rd.subscription).decrementQueueRef();
1: 	                }
0: 	                
1: 	            } catch (Exception e) {
0: 	                e.printStackTrace();
1: 	            }
1: 	        }
0: 	
0: 	        boolean result = false;
0: 	        synchronized (messages) {
0: 	            result = !messages.isEmpty();
1: 	        }               
0: 	        
0: 	        if (result) {
0: 	            try {
0: 	               pageInMessages(false);
0: 	               
0: 	            } catch (Throwable e) {
0: 	                log.error("Failed to page in more queue messages ", e);
1: 	            }
1: 	        }
0: 	        synchronized(messagesWaitingForSpace) {
0: 	               while (!messagesWaitingForSpace.isEmpty() && !memoryUsage.isFull()) {
0: 	                   Runnable op = messagesWaitingForSpace.removeFirst();
0: 	                   op.run();
1: 	               }
1: 	        }
0: 	        return false;
commit:a9ba595
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void messageExpired(ConnectionContext context, PrefetchSubscription prefetchSubscription, MessageReference reference) {
0:         ((QueueMessageReference)reference).drop();
0:         // Not sure.. perhaps we should forge an ack to remove the message from the store.
0:         // acknowledge(context, sub, ack, reference);
0:         destinationStatistics.getMessages().decrement();
0:         synchronized(pagedInMessages) {
0:             pagedInMessages.remove(reference.getMessageId());
0:         }
0:         wakeup();
0:     }
/////////////////////////////////////////////////////////////////////////
0:             int toPageIn = (getMaxPageSize()+(int)destinationStatistics.getInflight().getCount()) - pagedInMessages.size();
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
0:                 
0:                 for (MessageReference ref : sub.remove(context, this)) {
0:                     QueueMessageReference qmr = (QueueMessageReference)ref;
1:                     qmr.incrementRedeliveryCounter();
0:                     if( qmr.getLockOwner()==sub ) {
1:                         qmr.unlock();
1:                         qmr.incrementRedeliveryCounter();
0:                     }
0:                     list.add(qmr);
0:                 if (!list.isEmpty() && !consumers.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:                 
commit:299a98d
/////////////////////////////////////////////////////////////////////////
commit:f4971bf
/////////////////////////////////////////////////////////////////////////
0:             consumers.add(sub);
1:             Collections.sort(consumers, orderedCompare);
commit:c9c1107
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             node.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
commit:5269519
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     class RecoveryDispatch {
0:         public ArrayList<QueueMessageReference> messages;
0:         public Subscription subscription;
0:     }
0:     LinkedList<RecoveryDispatch> recoveries = new LinkedList<RecoveryDispatch>();
0: //            MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
/////////////////////////////////////////////////////////////////////////
0: //            msgContext.setDestination(destination);
0: 
0:                 RecoveryDispatch rd = new RecoveryDispatch();
0:                 rd.messages =  new ArrayList<QueueMessageReference>(pagedInMessages.values());
0:                 rd.subscription = sub;
0:                 recoveries.addLast(rd);
0:             
0:             if( sub instanceof QueueBrowserSubscription ) {
0:                 ((QueueBrowserSubscription)sub).incrementQueueRef();
0:             }
0:             
0: //                System.out.println(new Date()+": Locked pagedInMessages: "+sub.getConsumerInfo().getConsumerId());
0: //                // Add all the matching messages in the queue to the
0: //                // subscription.
0: //                
0: //                for (QueueMessageReference node:pagedInMessages.values()){
0: //                    if (!node.isDropped() && !node.isAcked() && (!node.isDropped() ||sub.getConsumerInfo().isBrowser())) {
0: //                        msgContext.setMessageReference(node);
0: //                        if (sub.matches(node, msgContext)) {
0: //                            sub.add(node);
0: //                        }
0: //                    }
0: //                }
0: //                
0: //            }
/////////////////////////////////////////////////////////////////////////
0:     
0:     RecoveryDispatch getNextRecoveryDispatch() {
0:         synchronized (pagedInMessages) {
0:             if( recoveries.isEmpty() ) {
0:                 return null;
0:             }
0:             return recoveries.removeFirst();
0:         }
0: 
0:     }
0:     protected boolean isRecoveryDispatchEmpty() {
0:         synchronized (pagedInMessages) {
0:             return recoveries.isEmpty();
0:         }
0:     }
0:         
0:         RecoveryDispatch rd;
0:         while ((rd = getNextRecoveryDispatch()) != null) {
0:             try {
0:                 MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
0:                 msgContext.setDestination(destination);
0:     
0:                 for (QueueMessageReference node : rd.messages) {
0:                     if (!node.isDropped() && !node.isAcked() && (!node.isDropped() || rd.subscription.getConsumerInfo().isBrowser())) {
0:                         msgContext.setMessageReference(node);
0:                             if (rd.subscription.matches(node, msgContext)) {
0:                                 rd.subscription.add(node);
0:                             }
0:                     }
0:                 }
0:                 
0:                 if( rd.subscription instanceof QueueBrowserSubscription ) {
0:                     ((QueueBrowserSubscription)rd.subscription).decrementQueueRef();
0:                 }
0:             } catch (Exception e) {
0:                 e.printStackTrace();
0:             }
0:         }
0: 
0:         }               
0:         
/////////////////////////////////////////////////////////////////////////
0:             List<Subscription> consumers;
0:             synchronized (this.consumers) {
0:                 consumers = new ArrayList<Subscription>(this.consumers);
0:             }
0:             
0:             for (MessageReference node : list) {
0:                 Subscription target = null;
0:                 List<Subscription> targets = null;
0:                 for (Subscription s : consumers) {
0:                     if (dispatchSelector.canSelect(s, node)) {
0:                         if (!s.isFull()) {
0:                             s.add(node);
0:                             target = s;
0:                             break;
0:                         } else {
0:                             if (targets == null) {
0:                                 targets = new ArrayList<Subscription>();
0:                             }
0:                             targets.add(s);
0:                 if (target == null && targets != null) {
0:                     // pick the least loaded to add the message too
0:                     for (Subscription s : targets) {
0:                         if (target == null
0:                                 || target.getInFlightUsage() > s
0:                                         .getInFlightUsage()) {
0:                             target = s;
0:                         }
0:                     }
0:                     if (target != null) {
0:                         target.add(node);
0:                         node.incrementReferenceCount();
0:                     }
0:                 }
0:                 if (target != null && !strictOrderDispatch && consumers.size() > 1 &&
0:                          !dispatchSelector.isExclusiveConsumer(target)) {
0:                     synchronized (this.consumers) {
0:                         if( removeFromConsumerList(target) ) {
0:                             addToConsumerList(target);
0:                             consumers = new ArrayList<Subscription>(this.consumers);
0:                         }
0:                     }
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean removeFromConsumerList(Subscription sub) {
1:         return consumers.remove(sub);
commit:3d18d59
/////////////////////////////////////////////////////////////////////////
0:         
0:         synchronized(messagesWaitingForSpace) {
0:                while (!messagesWaitingForSpace.isEmpty() && !memoryUsage.isFull()) {
0:                    Runnable op = messagesWaitingForSpace.removeFirst();
0:                    op.run();
0:                }
commit:13829ef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public Queue(BrokerService brokerService, final ActiveMQDestination destination, MessageStore store,DestinationStatistics parentStats,
1:         super(brokerService, store, destination, parentStats);
/////////////////////////////////////////////////////////////////////////
0:         
0:         // If a VMPendingMessageCursor don't use the default Producer System Usage
0:         // since it turns into a shared blocking queue which can lead to a network deadlock.  
0:         // If we are ccursoring to disk..it's not and issue because it does not block due 
0:         // to large disk sizes.
0:         if( messages instanceof VMPendingMessageCursor ) {
0:             this.systemUsage = brokerService.getSystemUsage();
0:             memoryUsage.setParent(systemUsage.getMemoryUsage());
0:         }
1:         super.initialize();
commit:d83969f
/////////////////////////////////////////////////////////////////////////
0:             while (!systemUsage.getStoreUsage().waitForSpace(1000)) {
0:                 if (context.getStopping().get()) {
0:                     throw new IOException("Connection closed, send aborted.");
0:                 }
0:             }
commit:3d024d6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ProducerInfo;
/////////////////////////////////////////////////////////////////////////
1:         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
0:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0 && !context.isInRecoveryMode();
1:                 ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
/////////////////////////////////////////////////////////////////////////
0:             if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
/////////////////////////////////////////////////////////////////////////
0:                                     ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
/////////////////////////////////////////////////////////////////////////
0:             ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
commit:222daf2
/////////////////////////////////////////////////////////////////////////
0:         if (destination.isTemporary() || tmpStore==null ) {
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private final List<Subscription> consumers = new CopyOnWriteArrayList<Subscription>();
0:     private final LinkedList<MessageReference> pagedInMessages = new LinkedList<MessageReference>();
/////////////////////////////////////////////////////////////////////////
0:     
0:     private final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
1:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
1:         public void run() {
0:             try {
0:                 taskRunner.wakeup();
0:             } catch (InterruptedException e) {
0:             }
1:         };
1:     };
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (exclusiveOwner == lockOwner) {
0:             }
0:             if (exclusiveOwner != null) {
0:             }
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:                         for (Iterator<Subscription> iter = consumers.iterator(); iter.hasNext();) {
0:                             Subscription s = iter.next();
0:                             if (s.getConsumerInfo().isExclusive() && (exclusiveOwner == null || so.getLockPriority() > exclusiveOwner.getLockPriority())) {
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                     List<QueueMessageReference> messagesToDispatch = new ArrayList<QueueMessageReference>();
0:                         for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<QueueMessageReference> iter = messagesToDispatch.iterator(); iter.hasNext();) {
0:                         QueueMessageReference node = iter.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     if (context.getStopping().get()) {
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         List<Message> l = new ArrayList<Message>();
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
0:                 MessageReference r = i.next();
/////////////////////////////////////////////////////////////////////////
0:         return l.toArray(new Message[l.size()]);
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
0:                 MessageReference r = i.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:     private List<MessageReference> doPageIn() throws Exception {
0:     private List<MessageReference> doPageIn(boolean force) throws Exception {
0:         List<MessageReference> result = null;
0:                 result = new ArrayList<MessageReference>(toPageIn);
/////////////////////////////////////////////////////////////////////////
0:     private void doDispatch(List<MessageReference> list) throws Exception {
0:                     MessageReference node = list.get(i);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     final Broker broker;
0: 
0:     private PendingMessageCursor messages;
0:     private int garbageSize;
/////////////////////////////////////////////////////////////////////////
0:     private boolean started;
0: 
0:     public Queue(Broker broker, ActiveMQDestination destination, final UsageManager memoryManager, MessageStore store, DestinationStatistics parentStats,
0:                  TaskRunnerFactory taskFactory, Store tmpStore) throws Exception {
0:         this.broker = broker;
0:         this.usageManager = new UsageManager(memoryManager, destination.toString());
0:         if (destination.isTemporary()) {
0:             this.messages = new VMPendingMessageCursor();
0:         } else {
0:             this.messages = new StoreQueueCursor(this, tmpStore);
0: 
0:         this.taskRunner = taskFactory.createTaskRunner(this, "Queue  " + destination.getPhysicalName());
/////////////////////////////////////////////////////////////////////////
0:         // let's copy the enabled property from the parent DestinationStatistics
0: 
0:     public void initialize() throws Exception {
0:         if (store != null) {
0:             if (messages.isRecoveryRequired()) {
0:                 store.recover(new MessageRecoveryListener() {
1:                     public boolean recoverMessage(Message message) {
1:                         // Message could have expired while it was being
1:                         // loaded..
0:                         if (broker.isExpired(message)) {
0:                             broker.messageExpired(createConnectionContext(), message);
1:                         if (hasSpace()) {
0:                             synchronized (messages) {
0:                                 try {
0:                                 } catch (Exception e) {
0:                                     log.fatal("Failed to add message to cursor", e);
/////////////////////////////////////////////////////////////////////////
1:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:                     public void finished() {
1:                     public boolean hasSpace() {
/////////////////////////////////////////////////////////////////////////
0:     public boolean lock(MessageReference node, LockOwner lockOwner) {
0:         synchronized (exclusiveLockMutex) {
0:             if (exclusiveOwner == lockOwner)
0:                 return true;
0:             if (exclusiveOwner != null)
0:                 return false;
0:         return true;
/////////////////////////////////////////////////////////////////////////
0:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:         try {
0:                 consumers.add(sub);
0:                 if (sub.getConsumerInfo().isExclusive()) {
0:                     LockOwner owner = (LockOwner)sub;
0:                     if (exclusiveOwner == null) {
0:                         exclusiveOwner = owner;
0:                     } else {
0:                         // switch the owner if the priority is higher.
0:                         if (owner.getLockPriority() > exclusiveOwner.getLockPriority()) {
0:                             exclusiveOwner = owner;
0:                         }
0:                     }
0:                 }
0:             }
0:             // duplicates
0:             try {
0:                 msgContext.setDestination(destination);
0:                 synchronized (pagedInMessages) {
0:                     // Add all the matching messages in the queue to the
0:                     // subscription.
0:                     for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                         QueueMessageReference node = (QueueMessageReference)i.next();
0:                         if (node.isDropped()) {
0:                             continue;
0:                         }
0:                         try {
0:                             msgContext.setMessageReference(node);
0:                             if (sub.matches(node, msgContext)) {
0:                                 sub.add(node);
0:                             }
0:                         } catch (IOException e) {
0:                             log.warn("Could not load message: " + e, e);
0:                         }
0:                     }
0:                 }
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:                 consumers.remove(sub);
0:                 if (sub.getConsumerInfo().isExclusive()) {
0:                     LockOwner owner = (LockOwner)sub;
0:                     // Did we loose the exclusive owner??
0:                     if (exclusiveOwner == owner) {
0:                         // Find the exclusive consumer with the higest Lock
0:                         // Priority.
0:                         exclusiveOwner = null;
0:                         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:                             Subscription s = (Subscription)iter.next();
0:                             LockOwner so = (LockOwner)s;
0:                             if (s.getConsumerInfo().isExclusive() && (exclusiveOwner == null || so.getLockPriority() > exclusiveOwner.getLockPriority()))
0:                                 exclusiveOwner = so;
0:                         }
0:                     }
0:                 }
0:                 if (consumers.isEmpty()) {
0:                     messages.gc();
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:                         for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                             QueueMessageReference node = (QueueMessageReference)i.next();
/////////////////////////////////////////////////////////////////////////
0:                         QueueMessageReference node = (QueueMessageReference)iter.next();
0:                 } finally {
0:         } finally {
0: 
1:         public void run() {
0:             try {
0:                 taskRunner.wakeup();
0:             } catch (InterruptedException e) {
0:             }
0:         };
1:     public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {
1:         final ConnectionContext context = producerExchange.getConnectionContext();
0: 
0:         final boolean sendProducerAck = (!message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0) && !context.isInRecoveryMode();
1:         if (message.isExpired()) {
0:             broker.messageExpired(context, message);
1:             if (sendProducerAck) {
0:                 ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
1:                 context.getConnection().dispatchAsync(ack);
0:         if (context.isProducerFlowControl() && usageManager.isFull()) {
0:             if (usageManager.isSendFailIfNoSpace()) {
0:             }
0: 
0:             // We can avoid blocking due to low usage if the producer is sending
0:             // a sync message or
0:             // if it is using a producer window
0:             if (producerExchange.getProducerState().getInfo().getWindowSize() > 0 || message.isResponseRequired()) {
1:                 synchronized (messagesWaitingForSpace) {
0:                     messagesWaitingForSpace.add(new Runnable() {
1:                         public void run() {
0: 
0:                             try {
0: 
0:                                 // While waiting for space to free up... the
0:                                 // message may have expired.
0:                                 if (broker.isExpired(message)) {
0:                                     broker.messageExpired(context, message);
0:                                     destinationStatistics.getMessages().decrement();
0:                                 } else {
0:                                     doMessageSend(producerExchange, message);
0:                                 }
0: 
1:                                 if (sendProducerAck) {
0:                                     ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
1:                                     context.getConnection().dispatchAsync(ack);
0:                                 } else {
0:                                     Response response = new Response();
0:                                     response.setCorrelationId(message.getCommandId());
0:                                     context.getConnection().dispatchAsync(response);
0:                                 }
0: 
0:                             } catch (Exception e) {
0:                                 if (!sendProducerAck && !context.isInRecoveryMode()) {
0:                                     ExceptionResponse response = new ExceptionResponse(e);
0:                                     response.setCorrelationId(message.getCommandId());
0:                                     context.getConnection().dispatchAsync(response);
0:                                 }
0:                             }
0:                         }
0:                     });
0: 
0:                     // If the user manager is not full, then the task will not
0:                     // get called..
0:                     if (!usageManager.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
0:                         // so call it directly here.
0:                         sendMessagesWaitingForSpaceTask.run();
0:                     }
0:                     context.setDontSendReponse(true);
0:                     return;
0:                 }
0: 
0:             } else {
0: 
0:                 // Producer flow control cannot be used, so we have do the flow
0:                 // control at the broker
0:                 // by blocking this thread until there is space available.
0:                 while (!usageManager.waitForSpace(1000)) {
0:                     if (context.getStopping().get())
0: 
1:                 if (message.isExpired()) {
0:             }
1:         if (sendProducerAck) {
0:             ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
1:             context.getConnection().dispatchAsync(ack);
0:     void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
1:         final ConnectionContext context = producerExchange.getConnectionContext();
0:         message.setRegionDestination(this);
0:         if (store != null && message.isPersistent()) {
0:             store.addMessage(context, message);
0:         if (context.isInTransaction()) {
0:             // If this is a transacted message.. increase the usage now so that
0:             // a big TX does not blow up
0:             // our memory. This increment is decremented once the tx finishes..
0:             context.getTransaction().addSynchronization(new Synchronization() {
0:                 public void afterCommit() throws Exception {
0:                     try {
0:                         if (broker.isExpired(message)) {
0:                             broker.messageExpired(context, message);
0:                             return;
0:                         }
0:                         sendMessage(context, message);
0:                     } finally {
0:                     }
0: 
0:         } else {
0:             // Add to the pending list, this takes care of incrementing the
0:             // usage manager.
0:             sendMessage(context, message);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public void dropEvent(boolean skipGc) {
0:         synchronized (pagedInMessages) {
0:         if (!skipGc && garbageSize > garbageSizeBeforeCollection) {
0:         try {
0:         } catch (InterruptedException e) {
0:             log.warn("Task Runner failed to wakeup ", e);
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 QueueMessageReference node = (QueueMessageReference)i.next();
/////////////////////////////////////////////////////////////////////////
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size() + ", memory=" + usageManager.getPercentUsage() + "%, size=" + size
0:                + ", in flight groups=" + messageGroupOwners;
/////////////////////////////////////////////////////////////////////////
0:         if (taskRunner != null) {
0:         if (messages != null) {
/////////////////////////////////////////////////////////////////////////
1:     public PendingMessageCursor getMessages() {
0: 
1:     public void setMessages(PendingMessageCursor messages) {
1:         this.messages = messages;
0:         MessageReference result = new IndirectMessageReference(this, store, message);
/////////////////////////////////////////////////////////////////////////
0:         try {
0:         } catch (Exception e) {
0:             log.error("caught an exception browsing " + this, e);
0:         synchronized (pagedInMessages) {
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:                 } catch (IOException e) {
0:                     log.error("caught an exception browsing " + this, e);
0:                 } finally {
0:         synchronized (messages) {
0:             try {
0:                 while (messages.hasNext()) {
0:                     try {
0:                         MessageReference r = messages.next();
0:                         try {
0:                             Message m = r.getMessage();
0:                             if (m != null) {
0:                         } finally {
0:                     } catch (IOException e) {
0:                         log.error("caught an exception brwsing " + this, e);
0:             } finally {
0:         return (Message[])l.toArray(new Message[l.size()]);
0:     public Message getMessage(String messageId) {
0:         synchronized (messages) {
0:             try {
0:                 while (messages.hasNext()) {
0:                     try {
0:                         MessageReference r = messages.next();
0:                         if (messageId.equals(r.getMessageId().toString())) {
0:                             try {
0:                                 Message m = r.getMessage();
0:                                 if (m != null) {
0:                             } finally {
0:                     } catch (IOException e) {
0:                         log.error("got an exception retrieving message " + messageId);
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                     QueueMessageReference r = (QueueMessageReference)i.next();
/////////////////////////////////////////////////////////////////////////
0:                 } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:      * Removes the messages matching the given selector up to the maximum number
1:      * of matched messages
/////////////////////////////////////////////////////////////////////////
1:      * Removes the messages matching the given filter up to the maximum number
1:      * of matched messages
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 IndirectMessageReference r = (IndirectMessageReference)i.next();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:      * Copies the messages matching the given selector up to the maximum number
1:      * of matched messages
/////////////////////////////////////////////////////////////////////////
1:      * Copies the messages matching the given filter up to the maximum number of
1:      * matched messages
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 MessageReference r = (MessageReference)i.next();
/////////////////////////////////////////////////////////////////////////
0:                     } finally {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:      * Moves the messages matching the given selector up to the maximum number
1:      * of matched messages
1:      * Moves the messages matching the given filter up to the maximum number of
1:      * matched messages
0:             for (Iterator i = pagedInMessages.iterator(); i.hasNext();) {
0:                 IndirectMessageReference r = (IndirectMessageReference)i.next();
/////////////////////////////////////////////////////////////////////////
0:                         } finally {
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean iterate() {
0:         while (!usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0:             Runnable op = messagesWaitingForSpace.removeFirst();
0:             op.run();
0:         }
0: 
0:         try {
0:         } catch (Exception e) {
0:             log.error("Failed to page in more queue messages ", e);
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     final void sendMessage(final ConnectionContext context, Message msg) throws Exception {
0:         synchronized (messages) {
0: 
0:     private List doPageIn() throws Exception {
0: 
0:     private List doPageIn(boolean force) throws Exception {
0: 
0:         final int toPageIn = maximumPagedInMessages - pagedInMessages.size();
0:         List result = null;
0:         if ((force || !consumers.isEmpty()) && toPageIn > 0) {
0:             try {
0:                 int count = 0;
0:                 result = new ArrayList(toPageIn);
0:                 synchronized (messages) {
0: 
0:                     try {
0:                         while (messages.hasNext() && count < toPageIn) {
0:                             MessageReference node = messages.next();
0:                             if (!broker.isExpired(node)) {
0:                                 node = createMessageReference(node.getMessage());
0:                             } else {
0:                                 broker.messageExpired(createConnectionContext(), node);
0:                     } finally {
0:                 synchronized (pagedInMessages) {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:     private void doDispatch(List list) throws Exception {
0:         if (list != null && !list.isEmpty()) {
0:             try {
0:                 for (int i = 0; i < list.size(); i++) {
0:                     MessageReference node = (MessageReference)list.get(i);
0:                     dispatchPolicy.dispatch(node, queueMsgConext, consumers);
0:             } finally {
0: 
0:     private void pageInMessages() throws Exception {
0: 
0:     private void pageInMessages(boolean force) throws Exception {
0:         synchronized (doDispatchMutex) {
commit:d56ebd8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			try {
0: 				taskRunner.wakeup();
0: 			} catch (InterruptedException e) {
0: 			}
/////////////////////////////////////////////////////////////////////////
0:     	
0: 		while( !usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0: 			Runnable op = messagesWaitingForSpace.removeFirst();
0: 			op.run();
0: 		}
0: 
commit:6a928d5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:             try { 
0: 	            msgContext.setDestination(destination);
0: 	            synchronized(pagedInMessages){
0: 	                // Add all the matching messages in the queue to the
0: 	                // subscription.
0: 	                for(Iterator i=pagedInMessages.iterator();i.hasNext();){
0: 	                    QueueMessageReference node=(QueueMessageReference)i.next();
0: 	                    if(node.isDropped()){
0: 	                        continue;
0: 	                    }
0: 	                    try{
0: 	                        msgContext.setMessageReference(node);
0: 	                        if(sub.matches(node,msgContext)){
0: 	                            sub.add(node);
0: 	                        }
0: 	                    }catch(IOException e){
0: 	                        log.warn("Could not load message: "+e,e);
0: 	                    }
0: 	                }
0: 	            }
0:             } finally {
0:                 dispatchValve.turnOn();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	
0:     	final boolean sendProducerAck = ( !message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0 ) && !context.isInRecoveryMode();
0:             if( sendProducerAck ) {
/////////////////////////////////////////////////////////////////////////
0:         					        			                    					
0: 	        			        
0: 	        					// While waiting for space to free up... the message may have expired.
0: 	            	        	if(message.isExpired()) {
0: 	        			            broker.messageExpired(context,message);
0: 	                                destinationStatistics.getMessages().decrement();
0: 	        			        } else {
0: 	        			        	doMessageSend(producerExchange, message);
0: 	        			        }
0: 	        			        
0: 	            	            if( sendProducerAck ) {
0: 	            	        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 	            					context.getConnection().dispatchAsync(ack);	    	            	        		
0: 	            	            } else {
0: 	            	            	Response response = new Response();
0:     				                response.setCorrelationId(message.getCommandId());
0:     								context.getConnection().dispatchAsync(response);	    								
0: 	            	            }
0: 	            	            
0: 	            	        	if( !sendProducerAck && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0:         if( sendProducerAck ) {
0:     		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 			context.getConnection().dispatchAsync(ack);	    	            	        		
0:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	        
/////////////////////////////////////////////////////////////////////////
0:                 	
commit:6ce8c3b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         	if (exclusiveOwner == lockOwner)
0: 				return true;
0: 			if (exclusiveOwner != null)
0: 				return false;
0:      	return true;
/////////////////////////////////////////////////////////////////////////
0:             synchronized (consumers) {
0: 				consumers.add(sub);
0: 				if (sub.getConsumerInfo().isExclusive()) {
0: 					LockOwner owner = (LockOwner) sub;
0: 					if (exclusiveOwner == null) {
0: 						exclusiveOwner = owner;
0: 					} else {
0: 						// switch the owner if the priority is higher.
0: 						if (owner.getLockPriority() > exclusiveOwner.getLockPriority()) {
0: 							exclusiveOwner = owner;
0: 						}
0: 					}
0: 				}
0: 			}
0:             // setting up a subscription. avoid out of order messages,
0: 			// duplicates
/////////////////////////////////////////////////////////////////////////
0: 				consumers.remove(sub);
0: 				if (sub.getConsumerInfo().isExclusive()) {
0: 					LockOwner owner = (LockOwner) sub;
0: 					// Did we loose the exclusive owner??
0: 					if (exclusiveOwner == owner) {
0: 						// Find the exclusive consumer with the higest Lock
0: 						// Priority.
0: 						exclusiveOwner = null;
0: 						for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0: 							Subscription s = (Subscription) iter.next();
0: 							LockOwner so = (LockOwner) s;
0: 							if (s.getConsumerInfo().isExclusive() && (exclusiveOwner == null || so.getLockPriority() > exclusiveOwner.getLockPriority()))
0: 								exclusiveOwner = so;
0: 						}
0: 					}
0: 				}
0: 				if (consumers.isEmpty()) {
0: 					messages.gc();
0: 				}
0: 
0: 			}
0:             sub.remove(context, this);
/////////////////////////////////////////////////////////////////////////
commit:12dba4d
/////////////////////////////////////////////////////////////////////////
0:             if( ( !message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0 ) && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0:         			            if( !message.isResponseRequired() && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0: 	            	        	if( message.isResponseRequired() && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0:         if( ( !message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0 ) && !context.isInRecoveryMode() ) {
commit:a59cd03
/////////////////////////////////////////////////////////////////////////
0:         if ( context.isProducerFlowControl() && usageManager.isFull() ) {
0:             if(usageManager.isSendFailIfNoSpace()){
0:                 throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached");
0:             } 
0:             	
0:         	// We can avoid blocking due to low usage if the producer is sending a sync message or
0:         	// if it is using a producer window
0:         	if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || message.isResponseRequired() ) {
0:         		synchronized( messagesWaitingForSpace ) {
0:             		messagesWaitingForSpace.add(new Runnable() {
0:         				public void run() {
0:         					
0:         					// While waiting for space to free up... the message may have expired.
0:         			        if(message.isExpired()){
0:         			            if (log.isDebugEnabled()) {
0:         			                log.debug("Expired message: " + message);
0:         			            }
0:         			            
0:         			            if( !message.isResponseRequired() ) {
0:         			        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0:         							context.getConnection().dispatchAsync(ack);	    	            	        		
0:         			            }
0:         			            return;
0:         			        }
0:         					
0:         					
0: 	            	        try {							
0: 	            	        	doMessageSend(producerExchange, message);
0: 							} catch (Exception e) {
0: 	            	        	if( message.isResponseRequired() ) {
0:     				                ExceptionResponse response = new ExceptionResponse(e);
0:     				                response.setCorrelationId(message.getCommandId());
0:     								context.getConnection().dispatchAsync(response);	    								
0: 	            	        	}
0: 							}
0:         				}
0:         			});
0:             		
0:             		// If the user manager is not full, then the task will not get called..
0: 	            	if( !usageManager.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask) ) {
0: 	            		// so call it directly here.
0: 	            		sendMessagesWaitingForSpaceTask.run();
0: 	            	}			            	
0:             		context.setDontSendReponse(true);
0:             		return;
0:         		}
0:         		
0:         	} else {
0:         		
0:         		// Producer flow control cannot be used, so we have do the flow control at the broker 
0:         		// by blocking this thread until there is space available.	            		
0:                 while( !usageManager.waitForSpace(1000) ) {
0:                     if( context.getStopping().get() )
0:                         throw new IOException("Connection closed, send aborted.");
0:                 }
0:                 
0:                 // The usage manager could have delayed us by the time
0:                 // we unblock the message could have expired..
0:                 if(message.isExpired()){
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Expired message: " + message);
0:                     }
0:                     return;
0:                 }
commit:f7a30b8
/////////////////////////////////////////////////////////////////////////
0: 	            					
0: 	            					// While waiting for space to free up... the message may have expired.
0: 	            			        if(message.isExpired()){
0: 	            			            if (log.isDebugEnabled()) {
0: 	            			                log.debug("Expired message: " + message);
0: 	            			            }
0: 	            			            
0: 	            			            if( !message.isResponseRequired() ) {
0: 	            			        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 	            							context.getConnection().dispatchAsync(ack);	    	            	        		
0: 	            			            }
0: 	            			            return;
0: 	            			        }
0: 	            					
0: 	            					
/////////////////////////////////////////////////////////////////////////
0: 			            	}			            	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0:     		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 			context.getConnection().dispatchAsync(ack);	    	            	        		
0:         }
/////////////////////////////////////////////////////////////////////////
commit:489f5aa
/////////////////////////////////////////////////////////////////////////
0:         
0:         	// If this is a transacted message.. increase the usage now so that a big TX does not blow up
0:         	// our memory.  This increment is decremented once the tx finishes..
0:             message.incrementReferenceCount();
0:                 	try { 
0:                         // It could take while before we receive the commit
0:                         // op, by that time the message could have expired..
0: 	                    if(message.isExpired()){
0: 	                        // TODO: remove message from store.
0: 	                        if (log.isDebugEnabled()) {
0: 	                            log.debug("Expired message: " + message);
0: 	                        }
0: 	                        if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0: 	                    		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 	            				context.getConnection().dispatchAsync(ack);	    	            	        		
0: 	                        }
0: 	                        return;
0: 	                    }
0: 	                    sendMessage(context,message);
0:                 	} finally {
0:                         message.decrementReferenceCount();
0:                 	}
0:                 }
0:                 
0:                 @Override
0:                 public void afterRollback() throws Exception {
0:                     message.decrementReferenceCount();
0:         	// Add to the pending list, this takes care of incrementing the usage manager.
0:             sendMessage(context,message);            
/////////////////////////////////////////////////////////////////////////
0:         synchronized(messages){
0:             messages.addMessageLast(msg);
0:         }
commit:7de0e81
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager.setUsagePortion(1.0f);
commit:4207bd9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.ProducerAck;
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     private final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
0:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
0:     	public void run() {
0:     		
0:     		// We may need to do this in async thread since this is run for within a synchronization
0:     		// that the UsageManager is holding.
0:     		
0:     		synchronized( messagesWaitingForSpace ) {
0: 	    		while( !usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0: 	    			Runnable op = messagesWaitingForSpace.removeFirst();
0: 	    			op.run();
0: 	    		}
0:     		}
0:     		
0:     	};
0:     };
/////////////////////////////////////////////////////////////////////////
0:             if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0:         		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 				context.getConnection().dispatchAsync(ack);	    	            	        		
0:             }
0:         if ( context.isProducerFlowControl() ) {
0:         	if( usageManager.isFull() ) {
0: 	            if(usageManager.isSendFailIfNoSpace()){
0: 	                throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached");
0: 	            }else{
0: 	            	
0: 	            	// We can avoid blocking due to low usage if the producer is sending a sync message or
0: 	            	// if it is using a producer window
0: 	            	if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || message.isResponseRequired() ) {
0: 	            		synchronized( messagesWaitingForSpace ) {
0: 		            		messagesWaitingForSpace.add(new Runnable() {
0: 	            				public void run() {
0: 	    	            	        try {							
0: 	    	            	        	doMessageSend(producerExchange, message);
0: 	    	            	        	if( message.isResponseRequired() ) {
0: 		    				                Response response = new Response();
0: 		    				                response.setCorrelationId(message.getCommandId());
0: 		    								context.getConnection().dispatchAsync(response);
0: 	    	            	        	} else {
0: 	    	            	        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 		    								context.getConnection().dispatchAsync(ack);	    	            	        		
0: 	    	            	        	}
0: 	    							} catch (Exception e) {
0: 	    	            	        	if( message.isResponseRequired() ) {
0: 		    				                ExceptionResponse response = new ExceptionResponse(e);
0: 		    				                response.setCorrelationId(message.getCommandId());
0: 		    								context.getConnection().dispatchAsync(response);	    								
0: 	    	            	        	} else {
0: 	    	            	        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 		    								context.getConnection().dispatchAsync(ack);	    	            	        		
0: 	    	            	        	}
0: 	    							}
0: 	            				}
0: 	            			});
0: 		            		
0: 		            		// If the user manager is not full, then the task will not get called..
0: 			            	if( !usageManager.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask) ) {
0: 			            		// so call it directly here.
0: 			            		sendMessagesWaitingForSpaceTask.run();
0: 			            	}
0: 			            	
0: 		            		context.setDontSendReponse(true);
0: 		            		return;
0: 	            		}
0: 	            		
0: 	            	} else {
0: 	            		
0: 	            		// Producer flow control cannot be used, so we have do the flow control at the broker 
0: 	            		// by blocking this thread until there is space available.	            		
0: 		                while( !usageManager.waitForSpace(1000) ) {
0: 		                    if( context.getStopping().get() )
0: 		                        throw new IOException("Connection closed, send aborted.");
0: 		                }
0: 		                
0: 		                // The usage manager could have delayed us by the time
0: 		                // we unblock the message could have expired..
0: 		                if(message.isExpired()){
0: 		                    if (log.isDebugEnabled()) {
0: 		                        log.debug("Expired message: " + message);
0: 		                    }
0: 		                    if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0: 		                		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 		        				context.getConnection().dispatchAsync(ack);	    	            	        		
0: 		                    }
0: 		                    return;
0: 		                }
0: 	            	}
0: 	            }
0:         	}
0:         doMessageSend(producerExchange, message);
0:     }
0: 
0: 	private void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
0: 		final ConnectionContext context = producerExchange.getConnectionContext();
0: 		message.setRegionDestination(this);
/////////////////////////////////////////////////////////////////////////
0:                     // op, by that time the message could have expired..
0:                         if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0:                     		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0:             				context.getConnection().dispatchAsync(ack);	    	            	        		
0:                         }
/////////////////////////////////////////////////////////////////////////
0: 	}    
commit:4569d7d
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
0:     public void send(final ProducerBrokerExchange producerExchange,final Message message) throws Exception {
0:     	final ConnectionContext context = producerExchange.getConnectionContext(); 
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
0:                     public void recoverMessageReference(MessageId messageReference) throws Exception{
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
commit:a58d36b
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: 
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0:                     	// Message could have expired while it was being loaded..
0:                     	if( message.isExpired() ) {
0:                     		// TODO: remove message from store.
0:                     		return;
0:                     	}
0: 
0:                     	message.setRegionDestination(Queue.this);
/////////////////////////////////////////////////////////////////////////
0:     	// There is delay between the client sending it and it arriving at the
0:     	// destination.. it may have expired.
0:     	if( message.isExpired() ) {
0:     		return;
0:     	}
0:     		
0:                 
0:                 // The usage manager could have delayed us by the time
0:                 // we unblock the message could have expired..
0:             	if( message.isExpired() ) {
0:             		return;
0:             	}
/////////////////////////////////////////////////////////////////////////
0:                 	
0:                 	// It could take while before we receive the commit
0:                 	// operration.. by that time the message could have expired..
0:                 	if( message.isExpired() ) {
0:                 		// TODO: remove message from store.
0:                 		return;
0:                 	}
0: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0:         // Let the store know what usage manager we are using so that he can flush messages to disk
0:         // when usage gets high.
0:         if( store!=null ) {
0:             store.setUsageManager(usageManager);
0:         }
0:         
commit:36722d8
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager = new UsageManager(memoryManager);
0:         this.usageManager.setLimit(Long.MAX_VALUE);
0:         
commit:5d9d499
/////////////////////////////////////////////////////////////////////////
0:                     r.incrementReferenceCount();
commit:3b0377c
/////////////////////////////////////////////////////////////////////////
0:     public void acknowledge(ConnectionContext context, Subscription sub, MessageAck ack, MessageReference node) throws IOException {
0:             // the original ack may be a ranged ack, but we are trying to delete a specific 
0:             // message store here so we need to convert to a non ranged ack.
0:             if( ack.getMessageCount() > 0 ) {
0:                 // Dup the ack
0:                 MessageAck a = new MessageAck();
0:                 ack.copy(a);
0:                 ack = a;
0:                 // Convert to non-ranged.
0:                 ack.setFirstMessageId(node.getMessageId());
0:                 ack.setLastMessageId(node.getMessageId());
0:                 ack.setMessageCount(1);
0:             }
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
0:     public boolean removeMessage(String messageId) {
/////////////////////////////////////////////////////////////////////////
0:                             return true;
0:         return false;
commit:120f77d
/////////////////////////////////////////////////////////////////////////
0:                         }                        
0:                         return true;
commit:44b00e9
/////////////////////////////////////////////////////////////////////////
0:     private LockOwner exclusiveOwner;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean lock(MessageReference node, LockOwner lockOwner) {
0:         if (exclusiveOwner == lockOwner)
0:         if (lockOwner.getLockPriority() < highestSubscriptionPriority)
0:         if (lockOwner.isLockExclusive()) {
0:             exclusiveOwner = lockOwner;
/////////////////////////////////////////////////////////////////////////
0:                         
0:                         // We should only delete messages that can be locked.
0:                         if( r.lock(LockOwner.HIGH_PRIORITY_LOCK_OWNER) )  {
1:                             MessageAck ack = new MessageAck();
1:                             ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:                             ack.setDestination(destination);
1:                             ack.setMessageID(r.getMessageId());
0:                             acknowledge(c, null, ack, r);
0:                             r.drop();
0:                             dropEvent();
0:                             iter.remove();
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                     
0:                     // We should only delete messages that can be locked.
0:                     if( r.lock(LockOwner.HIGH_PRIORITY_LOCK_OWNER) )  {
0:                         MessageAck ack = new MessageAck();
0:                         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:                         ack.setDestination(destination);
0:                         ack.setMessageID(r.getMessageId());
0:                         acknowledge(c, null, ack, r);
0:                         r.drop();
0:                         dropEvent();
0:                         iter.remove();
0:                     }
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessageReference(String messageReference) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void send(final ConnectionContext context, final Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     public void afterCommit() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     private void dispatch(ConnectionContext context, MessageReference node, Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public boolean copyMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest) throws Exception {
commit:ed5d43b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.BrokerSupport;
/////////////////////////////////////////////////////////////////////////
0:     public boolean copyMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest) throws Throwable {
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 try {
0:                     MessageReference r = (MessageReference) iter.next();
0:                     if (messageId.equals(r.getMessageId().toString())) {
0:                         r.incrementReferenceCount();
0:                         try {
0:                             Message m = r.getMessage();
0:                             BrokerSupport.resend(context, m, dest);                            
0:                         } finally {
0:                             r.decrementReferenceCount();
0:                         }
0:                         break;
0:                     }
0:                 } catch (IOException e) {
0:                 }
0:             }
0:         }
0:         return false;
0:     }
0: 
commit:e6f5d30
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0:                     if (node.isDropped()) {
/////////////////////////////////////////////////////////////////////////
0:                     } catch (IOException e) {
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0: 
0:                             IndirectMessageReference node = (IndirectMessageReference) iter.next();
0:                             if (node.isDropped()) {
0: 
0: 
0:                             if (node.getLockOwner() == sub || wasExclusiveOwner
0:                                     || (groupID != null && ownedGroups.contains(groupID))) {
/////////////////////////////////////////////////////////////////////////
0:         } finally {
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl())
0: 
/////////////////////////////////////////////////////////////////////////
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:                 if (node.isDropped()) {
/////////////////////////////////////////////////////////////////////////
0:     public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack,
0:             final MessageReference node) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         if (msg != null) {
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size()
0:                 + ", memory=" + usageManager.getPercentUsage() + "%, size=" + messages.size() + ", in flight groups="
0:                 + messageGroupOwners;
/////////////////////////////////////////////////////////////////////////
0:             messageGroupOwners = new MessageGroupHashBucket(messageGroupHashBucketCount);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             synchronized (consumers) {
/////////////////////////////////////////////////////////////////////////
0:         } finally {
/////////////////////////////////////////////////////////////////////////
1:     public Message[] browse() {
0: 
0:         ArrayList l = new ArrayList();
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 try {
0:                     MessageReference r = (MessageReference) iter.next();
0:                     try {
0:                         Message m = r.getMessage();
0:                         if (m != null) {
0:                             l.add(m);
0:                         }
0:                     } finally {
0:                         r.decrementReferenceCount();
0:                     }
0:                 } catch (IOException e) {
0:                 }
0:             }
0:         }
0: 
0:         return (Message[]) l.toArray(new Message[l.size()]);
0:     }
0: 
0:     public void removeMessage(String messageId) {
0:         synchronized (messages) {
0:             ConnectionContext c = new ConnectionContext();
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 try {
0:                     IndirectMessageReference r = (IndirectMessageReference) iter.next();
0:                     if (messageId.equals(r.getMessageId().toString())) {
0:                         MessageAck ack = new MessageAck();
0:                         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:                         ack.setDestination(destination);
0:                         ack.setMessageID(r.getMessageId());
0:                         acknowledge(c, null, ack, r);
0:                         r.drop();
0:                         dropEvent();
0:                     }
0:                 } catch (IOException e) {
0:                 }
0:             }
0:         }
0:     }
0: 
0:     public Message getMessage(String messageId) {
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 try {
0:                     MessageReference r = (MessageReference) iter.next();
0:                     if (messageId.equals(r.getMessageId().toString())) {
0:                         r.incrementReferenceCount();
0:                         try {
0:                             Message m = r.getMessage();
0:                             if (m != null) {
0:                                 return m;
0:                             }
0:                         } finally {
0:                             r.decrementReferenceCount();
0:                         }
0:                         break;
0:                     }
0:                 } catch (IOException e) {
0:                 }
0:             }
0:         }
0:         return null;
0:     }
0: 
0:     public void purge() {
0:         synchronized (messages) {
0:             ConnectionContext c = new ConnectionContext();
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 try {
0:                     IndirectMessageReference r = (IndirectMessageReference) iter.next();
0:                     MessageAck ack = new MessageAck();
0:                     ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:                     ack.setDestination(destination);
0:                     ack.setMessageID(r.getMessageId());
0:                     acknowledge(c, null, ack, r);
0:                     r.drop();
0:                     dropEvent();
0:                 } catch (IOException e) {
0:                 }
0:             }
0:         }
0:     }
0: 
0: 
0: 
commit:4759253
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
0: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0:     protected final List consumers = new CopyOnWriteArrayList();
/////////////////////////////////////////////////////////////////////////
0:             synchronized (consumers) {
0:                 consumers.add(sub);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             synchronized (consumers) {
0:                 consumers.remove(sub);
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             synchronized(consumers) {
0:                 if (consumers.isEmpty()) {
0:                     log.debug("No subscriptions registered, will not dispatch message at this time.");
0:                     return;
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (consumers) {
0:             for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:                 Subscription sub = (Subscription) iter.next();
0:                 if (sub.getConsumerInfo().getPriority() > rc) {
0:                     rc = sub.getConsumerInfo().getPriority();
0:                 }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
0: 
0: import java.io.IOException;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.policy.DispatchPolicy;
1: import org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.filter.MessageEvaluationContext;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.thread.TaskRunnerFactory;
0: import org.apache.activemq.thread.Valve;
1: import org.apache.activemq.transaction.Synchronization;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: 
1: /**
1:  * The Queue is a List of MessageEntry objects that are dispatched to matching
1:  * subscriptions.
0:  * 
0:  * @version $Revision: 1.28 $
1:  */
0: public class Queue implements Destination {
0: 
0:     private final Log log;
0: 
0:     protected final ActiveMQDestination destination;
0:     protected final CopyOnWriteArrayList consumers = new CopyOnWriteArrayList();
0:     protected final LinkedList messages = new LinkedList();
0:     protected final Valve dispatchValve = new Valve(true);
0:     protected final UsageManager usageManager;
0:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
0: 
0:     private Subscription exclusiveOwner;
0:     private final ConcurrentHashMap messageGroupOwners = new ConcurrentHashMap();
0: 
0:     protected long garbageSize = 0;
0:     protected long garbageSizeBeforeCollection = 1000;
1:     private DispatchPolicy dispatchPolicy = new RoundRobinDispatchPolicy();
0:     protected final MessageStore store;
0:     protected int highestSubscriptionPriority;
0: 
0:     public Queue(ActiveMQDestination destination, final UsageManager memoryManager, MessageStore store,
0:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Throwable {
0:         this.destination = destination;
0:         this.usageManager = memoryManager;
0:         this.store = store;
0: 
0:         destinationStatistics.setParent(parentStats);
0:         this.log = LogFactory.getLog(getClass().getName() + "." + destination.getPhysicalName());
0: 
0:         if (store != null) {
1:             // Restore the persistent messages.
0:             store.recover(new MessageRecoveryListener() {
0:                 public void recoverMessage(Message message) {
0:                     message.setRegionDestination(Queue.this);
0:                     MessageReference reference = createMessageReference(message);
0:                     messages.add(reference);
0:                     reference.decrementReferenceCount();
0:                     destinationStatistics.getMessages().increment();
0:                 }
0: 
0:                 public void recoverMessageReference(String messageReference) throws Throwable {
0:                     throw new RuntimeException("Should not be called.");
0:                 }
0:             });
0:         }
0:     }
0: 
0:     public synchronized boolean lock(MessageReference node, Subscription sub) {
0:         if (exclusiveOwner == sub)
0:             return true;
0:         if (exclusiveOwner != null)
0:             return false;
0:         if (sub.getConsumerInfo().getPriority() != highestSubscriptionPriority)
0:             return false;
0:         if (sub.getConsumerInfo().isExclusive()) {
0:             exclusiveOwner = sub;
0:         }
0:         return true;
0:     }
0: 
0:     public void addSubscription(ConnectionContext context, Subscription sub) throws Throwable {
0:         sub.add(context, this);
0:         destinationStatistics.getConsumers().increment();
0: 
0:         // synchronize with dispatch method so that no new messages are sent
0:         // while
0:         // setting up a subscription. avoid out of order messages, duplicates
0:         // etc.
0:         dispatchValve.turnOff();
0: 
0:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:         try {
0:             consumers.add(sub);
0: 
0:             highestSubscriptionPriority = calcHighestSubscriptionPriority();
0:             msgContext.setDestination(destination);
0: 
0:             synchronized (messages) {
0:                 // Add all the matching messages in the queue to the
0:                 // subscription.
0:                 for (Iterator iter = messages.iterator(); iter.hasNext();) {
0: 
0:                     IndirectMessageReference node = (IndirectMessageReference) iter.next();
0:                     if (node.isDropped() ) {
0:                         continue;
0:                     }
0: 
0:                     try {
0:                         msgContext.setMessageReference(node);
0:                         if (sub.matches(node, msgContext)) {
0:                             sub.add(node);
0:                         }
0:                     }
0:                     catch (IOException e) {
0:                         log.warn("Could not load message: " + e, e);
0:                     }
0:                 }
0:             }
0: 
0:         }
0:         finally {
0:             msgContext.clear();
0:             dispatchValve.turnOn();
0:         }
0:     }
0: 
0:     public void removeSubscription(ConnectionContext context, Subscription sub) throws Throwable {
0: 
0:         destinationStatistics.getConsumers().decrement();
0: 
0:         // synchronize with dispatch method so that no new messages are sent
0:         // while
0:         // removing up a subscription.
0:         dispatchValve.turnOff();
0:         try {
0: 
0:             consumers.remove(sub);
0:             sub.remove(context, this);
0: 
0:             highestSubscriptionPriority = calcHighestSubscriptionPriority();
0: 
0:             boolean wasExclusiveOwner = false;
0:             if (exclusiveOwner == sub) {
0:                 exclusiveOwner = null;
0:                 wasExclusiveOwner = true;
0:             }
0: 
0:             HashSet ownedGroups = new HashSet();
0:             ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();
0:             for (Iterator iter = messageGroupOwners.keySet().iterator(); iter.hasNext();) {
0:                 String group = (String) iter.next();
0:                 ConsumerId owner = (ConsumerId) messageGroupOwners.get(group);
0:                 if (owner.equals(consumerId)) {
0:                     ownedGroups.add(group);
0:                     iter.remove();
0:                 }
0:             }
0: 
0:             synchronized (messages) {
0:                 if (!sub.getConsumerInfo().isBrowser()) {
0:                     MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:                     try {
0:                         msgContext.setDestination(destination);
0:                         
0:                         for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                             IndirectMessageReference node = (IndirectMessageReference) iter.next();                            
0:                             if (node.isDropped() ) {
0:                                 continue;
0:                             }
0:     
0:                             String groupID = node.getGroupID();
0:     
0:                             // Re-deliver all messages that the sub locked
0:                             if (node.getLockOwner() == sub || wasExclusiveOwner || (groupID != null && ownedGroups.contains(groupID))) {
0:                                 node.incrementRedeliveryCounter();
0:                                 node.unlock();
0:                                 msgContext.setMessageReference(node);
0:                                 dispatchPolicy.dispatch(context, node, msgContext, consumers);
0:                             }
0:                         }
0:                     } finally {
0:                         msgContext.clear();
0:                     }
0:                 }
0:             }
0: 
0:         }
0:         finally {
0:             dispatchValve.turnOn();
0:         }
0: 
0:     }
0: 
0:     public void send(final ConnectionContext context, final Message message) throws Throwable {
0: 
0:         if( context.isProducerFlowControl() )
0:             usageManager.waitForSpace();
0:         
0:         message.setRegionDestination(this);
0: 
0:         if (store != null && message.isPersistent())
0:             store.addMessage(context, message);
0: 
0:         final MessageReference node = createMessageReference(message);
0:         try {
0: 
0:             if (context.isInTransaction()) {
0:                 context.getTransaction().addSynchronization(new Synchronization() {
0:                     public void afterCommit() throws Throwable {
0:                         dispatch(context, node, message);
0:                     }
0:                 });
0:             }
0:             else {
0:                 dispatch(context, node, message);
0:             }
0:         } finally {
0:             node.decrementReferenceCount();
0:         }
0:     }
0: 
0:     public void dispose(ConnectionContext context) throws IOException {
0:         if (store != null) {
0:             store.removeAllMessages(context);
0:         }
0:         destinationStatistics.setParent(null);
0:     }
0: 
0:     public void dropEvent() {
0:         // TODO: need to also decrement when messages expire.
0:         destinationStatistics.getMessages().decrement();
0:         synchronized (messages) {
0:             garbageSize++;
0:             if (garbageSize > garbageSizeBeforeCollection) {
0:                 gc();
0:             }
0:         }
0:     }
0: 
1:     public void gc() {
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 // Remove dropped messages from the queue.
0:                 IndirectMessageReference node = (IndirectMessageReference) iter.next();
0:                 if (node.isDropped()) {                    
0:                     garbageSize--;
0:                     iter.remove();
0:                     continue;
0:                 }
0:             }
0:         }
0:     }
0: 
0:     public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack, final MessageReference node) throws IOException {
1:         if (store != null && node.isPersistent()) {
0:             store.removeMessage(context, ack);
0:         }
0:     }
0: 
0:     public Message loadMessage(MessageId messageId) throws IOException {
0:         Message msg = store.getMessage(messageId);
0:         if( msg!=null ) {
1:             msg.setRegionDestination(this);
0:         }
1:         return msg;
0:     }
0: 
1:     public String toString() {
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size() + ", memory=" + usageManager.getPercentUsage()
0:                 + "%, size=" + messages.size() + ", in flight groups=" + messageGroupOwners.size();
0:     }
0: 
1:     public void start() throws Exception {
0:     }
0: 
1:     public void stop() throws Exception {
0:     }
0: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1:     public ActiveMQDestination getActiveMQDestination() {
1:         return destination;
0:     }
0: 
0:     public UsageManager getUsageManager() {
0:         return usageManager;
0:     }
0: 
0:     public DestinationStatistics getDestinationStatistics() {
0:         return destinationStatistics;
0:     }
0: 
0:     public ConcurrentHashMap getMessageGroupOwners() {
1:         return messageGroupOwners;
0:     }
0: 
1:     public DispatchPolicy getDispatchPolicy() {
1:         return dispatchPolicy;
0:     }
0: 
1:     public void setDispatchPolicy(DispatchPolicy dispatchPolicy) {
1:         this.dispatchPolicy = dispatchPolicy;
0:     }
0: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
0:     private MessageReference createMessageReference(Message message) {
0:         return new IndirectMessageReference(this, message);
0:     }
0: 
0:     private void dispatch(ConnectionContext context, MessageReference node, Message message) throws Throwable {
0:         dispatchValve.increment();
0:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:         try {
0:             destinationStatistics.onMessageEnqueue(message);
0:             synchronized (messages) {
0:                 messages.add(node);
0:             }
0: 
0:             if (consumers.isEmpty())
0:                 return;
0: 
0:             msgContext.setDestination(destination);
0:             msgContext.setMessageReference(node);
0: 
0:             dispatchPolicy.dispatch(context, node, msgContext, consumers);
0:         }
0:         finally {
0:             msgContext.clear();
0:             dispatchValve.decrement();
0:         }
0:     }
0: 
0:     private int calcHighestSubscriptionPriority() {
0:         int rc = Integer.MIN_VALUE;
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             Subscription sub = (Subscription) iter.next();
0:             if (sub.getConsumerInfo().getPriority() > rc) {
0:                 rc = sub.getConsumerInfo().getPriority();
0:             }
0:         }
0:         return rc;
0:     }
0: 
0:     public MessageStore getMessageStore() {
0:         return store;
0:     }
0: 
0: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
1:         if (ack.isPoisonAck() || (sub != null && sub.getConsumerInfo().isNetworkSubscription())) {
commit:66e8011
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transaction.Transaction;
/////////////////////////////////////////////////////////////////////////
0:     final ConcurrentHashMap<Transaction, SendSync> sendSyncs = new ConcurrentHashMap<Transaction, SendSync>();
0:     private volatile LinkedList<Transaction> orderIndexUpdates = new LinkedList<Transaction>();
0: 
0:     // roll up all message sends
0:     class SendSync extends Synchronization {
0: 
0:         class MessageContext {
0:             public Message message;
0:             public ConnectionContext context;
0: 
0:             public MessageContext(ConnectionContext context, Message message) {
1:                 this.context = context;
1:                 this.message = message;
0:             }
0:         }
0: 
0:         final Transaction transaction;
0:         List<MessageContext> additions = new ArrayList<MessageContext>();
0: 
0:         public SendSync(Transaction transaction) {
0:             this.transaction = transaction;
0:         }
0: 
0:         public void add(ConnectionContext context, Message message) {
0:             additions.add(new MessageContext(context, message));
0:         }
0: 
0:         @Override
0:         public void beforeCommit() throws Exception {
0:             synchronized (sendLock) {
0:                 orderIndexUpdates.addLast(transaction);
0:             }
0:         }
0: 
0:         @Override
0:         public void afterCommit() throws Exception {
0:             LinkedList<Transaction> orderedWork = null;
0:             // use existing object to sync orderIndexUpdates that can be reassigned
0:             synchronized (sendLock) {
0:                 if (transaction == orderIndexUpdates.peek()) {
0:                     orderedWork = orderIndexUpdates;
0:                     orderIndexUpdates = new LinkedList<Transaction>();
0: 
0:                     // talking all the ordered work means that earlier
0:                     // and later threads do nothing.
0:                     // this avoids contention/race on the sendLock that
0:                     // guards the actual work.
0:                 }
0:             }
0:             // do the ordered work
0:             if (orderedWork != null) {
0:                 sendLock.lockInterruptibly();
0:                 try {
0:                     for (Transaction tx : orderedWork) {
0:                         sendSyncs.get(tx).processSend();
0:                     }
0:                 } finally {
0:                     sendLock.unlock();
0:                 }
0:                 for (Transaction tx : orderedWork) {
0:                     sendSyncs.get(tx).processSent();
0:                 }
0:                 sendSyncs.remove(transaction);
0:             }
0:         }
0: 
0:         // called with sendLock
0:         private void processSend() throws Exception {
0: 
0:             for (Iterator<MessageContext> iterator = additions.iterator(); iterator.hasNext(); ) {
0:                 MessageContext messageContext = iterator.next();
0:                 // It could take while before we receive the commit
0:                 // op, by that time the message could have expired..
0:                 if (broker.isExpired(messageContext.message)) {
0:                     broker.messageExpired(messageContext.context, messageContext.message, null);
1:                     destinationStatistics.getExpired().increment();
0:                     iterator.remove();
0:                     continue;
0:                 }
0:                 sendMessage(messageContext.message);
0:                 messageContext.message.decrementReferenceCount();
0:             }
0:         }
0: 
0:         private void processSent() throws Exception {
0:             for (MessageContext messageContext : additions) {
0:                 messageSent(messageContext.context, messageContext.message);
0:             }
0:         }
0: 
0:         @Override
0:         public void afterRollback() throws Exception {
0:             try {
0:                 for (MessageContext messageContext : additions) {
0:                     messageContext.message.decrementReferenceCount();
0:                 }
0:             } finally {
0:                 sendSyncs.remove(transaction);
0:             }
0:         }
0:     }
0: 
0:     // called while holding the sendLock
0:     private void registerSendSync(Message message, ConnectionContext context) {
0:         final Transaction transaction = context.getTransaction();
0:         Queue.SendSync currentSync = sendSyncs.get(transaction);
0:         if (currentSync == null) {
0:             currentSync = new Queue.SendSync(transaction);
0:             transaction.addSynchronization(currentSync);
0:             sendSyncs.put(transaction, currentSync);
0:         }
0:         currentSync.add(context, message);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 registerSendSync(message, context);
commit:0a7c5dc
/////////////////////////////////////////////////////////////////////////
1:     private final Comparator<Subscription> orderedCompare = new Comparator<Subscription>() {
1:             int val = s2.getConsumerInfo().getPriority() - s1.getConsumerInfo().getPriority();
1:             if (val == 0 && messageGroupOwners != null) {
1:                 // then ascending order of assigned message groups to favour less loaded consumers
1:                 // Long.compare in jdk7
0:                 long x = s1.getConsumerInfo().getLastDeliveredSequenceId();
0:                 long y = s2.getConsumerInfo().getLastDeliveredSequenceId();
1:                 val = (x < y) ? -1 : ((x == y) ? 0 : 1);
0:             }
1:             return val;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             subscription.getConsumerInfo().setLastDeliveredSequenceId(subscription.getConsumerInfo().getLastDeliveredSequenceId() - 1);
/////////////////////////////////////////////////////////////////////////
0:         subs.getConsumerInfo().setLastDeliveredSequenceId(subs.getConsumerInfo().getLastDeliveredSequenceId() + 1);
commit:d41f40a
/////////////////////////////////////////////////////////////////////////
0:             messages.reset();
commit:a526a60
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Async task runner failed to wakeup ", e);
/////////////////////////////////////////////////////////////////////////
1:                 if (!fullConsumers.contains(s)) {
0:                     if (!s.isFull()) {
1:                         if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {
0:                             // Dispatch it.
0:                             s.add(node);
0:                             target = s;
0:                             break;
0:                         }
0:                     } else {
0:                         // no further dispatch of list to a full consumer to
0:                         // avoid out of order message receipt
1:                         fullConsumers.add(s);
1:                         LOG.trace("Subscription full {}", s);
commit:7a7d684
/////////////////////////////////////////////////////////////////////////
0:             pageInMessages(!isUseCache());
commit:e900fb4
/////////////////////////////////////////////////////////////////////////
0:                         wakeup();
/////////////////////////////////////////////////////////////////////////
0:                     if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {
/////////////////////////////////////////////////////////////////////////
0:                 if (!node.isDropped()) {
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
1:             store.removeAsyncMessage(context, convertToNonRangedAck(ack, node));
commit:8d2c079
/////////////////////////////////////////////////////////////////////////
1:             if (messageCount > 0 && messages.isRecoveryRequired()) {
commit:179d95e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.state.ProducerState;
/////////////////////////////////////////////////////////////////////////
1:         ProducerState state = producerExchange.getProducerState();
1:         if (state == null) {
0:             LOG.warn("Send failed for: " + message + ",  missing producer state for: " + producerExchange);
1:             throw new JMSException("Cannot send message to " + getActiveMQDestination() + " with invalid (null) producer state");
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(broker.getBrokerName() + " Message " + msg.getMessageId() + " sent to " + this.destination);
commit:41cdadb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:     class BatchMessageRecoveryListener implements MessageRecoveryListener {
1:         final LinkedList<Message> toExpire = new LinkedList<Message>();
1:         final double totalMessageCount;
1:         int recoveredAccumulator = 0;
1:         int currentBatchCount;
0: 
1:         BatchMessageRecoveryListener(int totalMessageCount) {
1:             this.totalMessageCount = totalMessageCount;
1:             currentBatchCount = recoveredAccumulator;
0:         }
0: 
0:         public boolean recoverMessage(Message message) {
1:             recoveredAccumulator++;
0:             if (LOG.isInfoEnabled() && (recoveredAccumulator % 10000) == 0) {
0:                 LOG.info("cursor for " + getActiveMQDestination().getQualifiedName() + " has recovered "
0:                         + recoveredAccumulator + " messages. " +
0:                         (int) (recoveredAccumulator * 100 / totalMessageCount) + "% complete");
0:             }
0:             // Message could have expired while it was being
0:             // loaded..
1:             if (message.isExpired() && broker.isExpired(message)) {
1:                 toExpire.add(message);
0:                 return true;
0:             }
0:             if (hasSpace()) {
0:                 message.setRegionDestination(Queue.this);
0:                 messagesLock.writeLock().lock();
0:                 try {
0:                     try {
0:                         messages.addMessageLast(message);
0:                     } catch (Exception e) {
1:                         LOG.error("Failed to add message to cursor", e);
0:                     }
0:                 } finally {
0:                     messagesLock.writeLock().unlock();
0:                 }
0:                 destinationStatistics.getMessages().increment();
0:                 return true;
0:             }
0:             return false;
0:         }
0: 
0:         public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:             throw new RuntimeException("Should not be called.");
0:         }
0: 
0:         public boolean hasSpace() {
0:             return true;
0:         }
0: 
1:         public boolean isDuplicate(MessageId id) {
0:             return false;
0:         }
0: 
1:         public void reset() {
1:             currentBatchCount = recoveredAccumulator;
0:         }
0: 
1:         public void processExpired() {
1:             for (Message message: toExpire) {
1:                 messageExpired(createConnectionContext(), createMessageReference(message));
0:                 // drop message will decrement so counter
0:                 // balance here
0:                 destinationStatistics.getMessages().increment();
0:             }
0:             toExpire.clear();
0:         }
0: 
1:         public boolean done() {
1:             return currentBatchCount == recoveredAccumulator;
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:             final int messageCount = store.getMessageCount();
1:                 BatchMessageRecoveryListener listener = new BatchMessageRecoveryListener(messageCount);
1:                 do {
1:                    listener.reset();
1:                    store.recoverNextMessages(getMaxPageSize(), listener);
1:                    listener.processExpired();
1:                } while (!listener.done());
commit:8ce0778
/////////////////////////////////////////////////////////////////////////
1:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
/////////////////////////////////////////////////////////////////////////
1:                         if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
commit:383a7ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.util.InsertionCountList;
/////////////////////////////////////////////////////////////////////////
1:         List<Message> browsedMessages = new InsertionCountList<Message>();
commit:af1b232
/////////////////////////////////////////////////////////////////////////
0:                 if (!fullConsumers.contains(s) && !s.isFull()) {
0:                     if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node)) {
0:                         // Dispatch it.
0:                         s.add(node);
0:                         target = s;
0:                         break;
0:                     // no further dispatch of list to a full consumer to
0:                     // avoid out of order message receipt
0:                     fullConsumers.add(s);
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("Sub full " + s);
0:                 // make sure it gets dispatched again
0:                 if (!node.isDropped() && !((QueueMessageReference) node).isAcked() &&
0:                         (!node.isDropped() || s.getConsumerInfo().isBrowser())) {
0:                     interestCount++;
0:                 }
commit:2b10259
/////////////////////////////////////////////////////////////////////////
0:                         waitForSpace(context, memoryUsage, "Usage Manager Memory Limit reached. Producer ("
/////////////////////////////////////////////////////////////////////////
1:                 final String logMessage = "Persistent store is Full, " + getStoreUsageHighWaterMark() + "% of "
/////////////////////////////////////////////////////////////////////////
1:             final String logMessage = "Temp Store is Full ("
commit:101e711
/////////////////////////////////////////////////////////////////////////
0:     public void clearPendingMessages() {
0:         messagesLock.writeLock().lock();
0:         try {
0:             if (store != null) {
0:                 store.resetBatching();
0:             }
0:             messages.gc();
1:             asyncWakeup();
0:         } finally {
0:             messagesLock.writeLock().unlock();
0:         }
0:     }
0: 
commit:b9045db
/////////////////////////////////////////////////////////////////////////
1:         return destination.getQualifiedName() + ", subscriptions=" + consumers.size()
commit:27c1719
/////////////////////////////////////////////////////////////////////////
1:             broker.getRoot().messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
1:                                         broker.messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
1:                         broker.getRoot().messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
0:                                 broker.messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
1:         broker.messageExpired(context, reference, subs);
commit:1b45e3b
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(getActiveMQDestination().getQualifiedName() + " add sub: " + sub + ", dequeues: "
0:                     + getDestinationStatistics().getDequeues().getCount() + ", dispatched: "
0:                     + getDestinationStatistics().getDispatched().getCount() + ", inflight: "
0:                     + getDestinationStatistics().getInflight().getCount());
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(getActiveMQDestination().getQualifiedName() + " remove sub: " + sub + ", lastDeliveredSeqId: " + lastDeiveredSequenceId + ", dequeues: "
/////////////////////////////////////////////////////////////////////////
1:     public QueueMessageReference getMessage(String id) {
0:             QueueMessageReference ref = this.pagedInMessages.get(msgId);
1:             if (ref != null) {
1:                 return ref;
/////////////////////////////////////////////////////////////////////////
1:                     MessageReference mr = messages.next();
1:                     QueueMessageReference qmr = createMessageReference(mr.getMessage());
1:                     qmr.decrementReferenceCount();
1:                     messages.rollback(qmr.getMessageId());
1:                     if (msgId.equals(qmr.getMessageId())) {
1:                         return qmr;
/////////////////////////////////////////////////////////////////////////
0:      *
1:      *            QueueMessageReference
1:     public boolean moveMessageTo(ConnectionContext context, QueueMessageReference m, ActiveMQDestination dest) throws Exception {
0:         BrokerSupport.resend(context, m.getMessage(), dest);
0:         removeMessage(context, m);
0:             messages.rollback(m.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:         Set<QueueMessageReference> set = new CopyOnWriteArraySet<QueueMessageReference>();
/////////////////////////////////////////////////////////////////////////
0:             List<QueueMessageReference> list = new ArrayList<QueueMessageReference>(set);
0:             for (QueueMessageReference ref : list) {
1:                 if (filter.evaluate(context, ref)) {
0:                     moveMessageTo(context, ref, dest);
1:                     set.remove(ref);
commit:462efdb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void doPageIn(boolean force) throws Exception {
0:         List<QueueMessageReference> newlyPaged = doPageInForDispatch(force);
0:         pagedInPendingDispatchLock.writeLock().lock();
0:         try {
0:             if (pagedInPendingDispatch.isEmpty()) {
0:                 pagedInPendingDispatch.addAll(newlyPaged);
0:             } else {
0:                 for (QueueMessageReference qmr : newlyPaged) {
0:                     if (!pagedInPendingDispatch.contains(qmr)) {
0:                         pagedInPendingDispatch.add(qmr);
0:                     }
0:                 }
0:             }
0:         } finally {
0:             pagedInPendingDispatchLock.writeLock().unlock();
0:         }
0:     }
0: 
0:     private List<QueueMessageReference> doPageInForDispatch(boolean force) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageInForDispatch(force));
commit:aad7e73
/////////////////////////////////////////////////////////////////////////
0:                 if (messages.isCacheEnabled()) {
0:                     result = store.asyncAddQueueMessage(context, message);
0:                 } else {
0:                     store.addMessage(context, message);
0:                 }
commit:1edb58a
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(getActiveMQDestination().getQualifiedName() + " expiring messages ..");
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(getActiveMQDestination().getQualifiedName() + " expiring messages done.");
0:         }
commit:514ef7d
/////////////////////////////////////////////////////////////////////////
0:                     + pagedInMessages.size() + ", enqueueCount: " + destinationStatistics.getEnqueues().getCount()
0:                     + ", dequeueCount: " + destinationStatistics.getDequeues().getCount());
commit:c1da3ac
/////////////////////////////////////////////////////////////////////////
0:                 if (isReduceMemoryFootprint()) {
0:                     message.clearMarshalledState();
0:                 }
commit:04b2690
/////////////////////////////////////////////////////////////////////////
0:             final String logMessage = "Usage Manager Temp Store is Full ("
0:                     + systemUsage.getTempUsage().getPercentUsage() + "% of " + systemUsage.getTempUsage().getLimit() 
1:                     +"). Stopping producer (" + message.getProducerId()
commit:db5ba04
/////////////////////////////////////////////////////////////////////////
0:                     double totalMessageCount = store.getMessageCount();
0:                     int recoveredMessageCount = 0;
0:                         if ((++recoveredMessageCount % 50000) == 0) {
0:                             LOG.info("cursor for " + getActiveMQDestination().getQualifiedName() + " has recovered "
0:                                     + recoveredMessageCount + " messages. " +
0:                                     (int)(recoveredMessageCount*100/totalMessageCount) + "% complete");
0:                         }
commit:0af6b06
/////////////////////////////////////////////////////////////////////////
0:                     public void afterCommit() throws Exception {
commit:7343337
/////////////////////////////////////////////////////////////////////////
1:                 boolean markAsRedelivered = false;
1:                 MessageReference lastDeliveredRef = null;
1:                 List<MessageReference> unAckedMessages = sub.remove(context, this);
0: 
1:                 // locate last redelivered in unconsumed list (list in delivery rather than seq order)
0:                 if (lastDeiveredSequenceId != 0) {
1:                     for (MessageReference ref : unAckedMessages) {
0:                         if (ref.getMessageId().getBrokerSequenceId() == lastDeiveredSequenceId) {
1:                             lastDeliveredRef = ref;
1:                             markAsRedelivered = true;
0:                             LOG.debug("found lastDeliveredSeqID: " + lastDeiveredSequenceId + ", message reference: " + ref.getMessageId());
0:                             break;
0:                         }
0:                     }
0:                 }
1:                 for (MessageReference ref : unAckedMessages) {
0: 
0:                         if (lastDeiveredSequenceId == 0) {
0:                         } else {
1:                             if (markAsRedelivered) {
0:                                 qmr.incrementRedeliveryCounter();
0:                             }
1:                             if (ref == lastDeliveredRef) {
1:                                 // all that follow were not redelivered
1:                                 markAsRedelivered = false;
0:                             }
commit:fb591e7
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.Lock;
0: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
0:     private final Lock sendLock = new ReentrantLock();
/////////////////////////////////////////////////////////////////////////
0:                     doDispatch(new ArrayList<QueueMessageReference>());
/////////////////////////////////////////////////////////////////////////
0:         
0:         checkUsage(context, message);
0:         sendLock.lockInterruptibly();
0:         try {
0:             if (store != null && message.isPersistent()) {        
0:             if (context.isInTransaction()) {
0:                 // If this is a transacted message.. increase the usage now so that
0:                 // a big TX does not blow up
0:                 // our memory. This increment is decremented once the tx finishes..
0:                 message.incrementReferenceCount();
0:             
0:                 context.getTransaction().addSynchronization(new Synchronization() {
0:                     @Override
0:                     public void beforeCommit() throws Exception {
0:                         sendLock.lockInterruptibly();
0:                     }
0:                     @Override
0:                     public void afterCommit() throws Exception {
0:                         try {
0:                             // It could take while before we receive the commit
0:                             // op, by that time the message could have expired..
0:                             if (broker.isExpired(message)) {
0:                                 broker.messageExpired(context, message);
1:                                 destinationStatistics.getExpired().increment();
0:                                 return;
0:                             }
0:                             sendMessage(message);
0:                         } finally {
0:                             sendLock.unlock();
0:                             message.decrementReferenceCount();
0:                         messageSent(context, message);
0:                     }
0:                     @Override
0:                     public void afterRollback() throws Exception {
0:                 });
0:             } else {
0:                 // Add to the pending list, this takes care of incrementing the
0:                 // usage manager.
0:                 sendMessage(message);
0:             }
0:         } finally {
0:             sendLock.unlock();
0:         }
0:         if (!context.isInTransaction()) {
0:             messageSent(context, message);
/////////////////////////////////////////////////////////////////////////
0:     private void checkUsage(ConnectionContext context, Message message) throws ResourceAllocationException, IOException, InterruptedException {
1:         if (message.isPersistent()) {
1:             if (store != null && systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {
0:                 final String logMessage = "Usage Manager Store is Full, " + getStoreUsageHighWaterMark() + "% of "
0:                     + systemUsage.getStoreUsage().getLimit() + ". Stopping producer ("
0:                     + message.getProducerId() + ") to prevent flooding "
0:                     + getActiveMQDestination().getQualifiedName() + "."
1:                     + " See http://activemq.apache.org/producer-flow-control.html for more info";
0: 
0:                 waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
0:             }
1:         } else if (messages.getSystemUsage() != null && systemUsage.getTempUsage().isFull()) {
0:             final String logMessage = "Usage Manager Temp Store is Full. Stopping producer (" + message.getProducerId()
0:                 + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:                 + " See http://activemq.apache.org/producer-flow-control.html for more info";
0:             
0:             waitForSpace(context, messages.getSystemUsage().getTempUsage(), logMessage);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     final void sendMessage(final Message msg) throws Exception {
0:     }
0:     
0:     final void messageSent(final ConnectionContext context, final Message msg) throws Exception {     
commit:50daa35
/////////////////////////////////////////////////////////////////////////
0:             if (context.isInTransaction()) {
0:                 store.removeMessage(context, ack);
0:             } else {
0:                 store.removeAsyncMessage(context, ack);
0:             }
commit:956c3e0
/////////////////////////////////////////////////////////////////////////
0:             // don't spin/hang if stats are out and there is nothing left in the store
0:         } while (!list.isEmpty() && this.destinationStatistics.getMessages().getCount() > 0);
0:         if (this.destinationStatistics.getMessages().getCount() > 0) {
0:             LOG.warn(getActiveMQDestination().getQualifiedName() + " after purge complete, message count stats report: " +  this.destinationStatistics.getMessages().getCount());
0:         }
commit:a0d2282
/////////////////////////////////////////////////////////////////////////
0:                 if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {
0:                     String logMessage = "Usage Manager Store is Full, " + getStoreUsageHighWaterMark() + "% of " + systemUsage.getStoreUsage().getLimit() + ". Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
0:                     waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     protected Log getLog() {
1:         return LOG;
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1:         List<Message> browseList = new ArrayList<Message>();
1:         doBrowse(browseList, getMaxBrowsePageSize());
1:         return browseList.toArray(new Message[browseList.size()]);
1:     public void doBrowse(List<Message> browseList, int max) {
0:                     addAll(pagedInPendingDispatch, browseList, max, toExpire);
0:                             LOG.debug("expiring from pagedInPending: " + ref);
0:                     addAll(pagedInMessages.values(), browseList, max, toExpire);
0:                         LOG.debug("expiring from pagedInMessages: " + ref);
/////////////////////////////////////////////////////////////////////////
0:                 if (browseList.size() < getMaxBrowsePageSize()) {
0:                             while (messages.hasNext() && browseList.size() < max) {
0:                                         LOG.debug("expiring from messages: " + node);
0:                                     if (browseList.contains(node.getMessage()) == false) {
0:                                         browseList.add(node.getMessage());
0:                                 node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                             r.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                                 } else {
0:                                     ref.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                         } else {
0:                             ref.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
commit:fde4721
/////////////////////////////////////////////////////////////////////////
0:      * Holder for subscription that needs attention on next iterate
0:      * browser needs access to existing messages in the queue that have already been dispatched
1:         public BrowserDispatch(QueueBrowserSubscription browserSubscription) {
/////////////////////////////////////////////////////////////////////////
1:                 // tee up for dispatch in next iterate
0:                     BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription);
0:                     browserDispatches.addLast(browserDispatch);
0:             
/////////////////////////////////////////////////////////////////////////
0:         boolean pageInMoreMessages = false;       
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             
0:             BrowserDispatch pendingBrowserDispatch = getNextBrowserDispatch();
/////////////////////////////////////////////////////////////////////////
0:             if (pageInMoreMessages || pendingBrowserDispatch != null) {
0:                     pageInMessages(pendingBrowserDispatch != null);
0:             
0:             if (pendingBrowserDispatch != null) {
0:                 ArrayList<QueueMessageReference> alreadyDispatchedMessages = null;
0:                 synchronized (pagedInMessages) {
0:                     alreadyDispatchedMessages = new ArrayList<QueueMessageReference>(pagedInMessages.values());
0:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("dispatch to browser: " + pendingBrowserDispatch.getBrowser()
0:                             + ", already dispatched/paged count: " + alreadyDispatchedMessages.size());
0:                 }
0:                 do {
0:                     try {
0:                         MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
0:                         msgContext.setDestination(destination);
0:                         
0:                         QueueBrowserSubscription browser = pendingBrowserDispatch.getBrowser();
0:                         for (QueueMessageReference node : alreadyDispatchedMessages) {
0:                             if (!node.isAcked()) {
0:                                 msgContext.setMessageReference(node);
1:                                 if (browser.matches(node, msgContext)) {
1:                                     browser.add(node);
0:                                 }
0:                             }
0:                         }
0:                         pendingBrowserDispatch.done();
0:                     } catch (Exception e) {
0:                         LOG.warn("exception on dispatch to browser: " + pendingBrowserDispatch.getBrowser(), e);
0:                     }
0:                 
0:                 } while ((pendingBrowserDispatch = getNextBrowserDispatch()) != null);
0:             }
0:             
commit:def2a34
/////////////////////////////////////////////////////////////////////////
1:         Message msg = null;
1:         if (store != null) { // can be null for a temp q
1:             msg = store.getMessage(messageId);
0:             if (msg != null) {
0:                 msg.setRegionDestination(this);
0:             }
commit:7ceb4cb
/////////////////////////////////////////////////////////////////////////
1:             if (pendingWakeups.get() > 0) {
1:                 pendingWakeups.decrementAndGet();
0:             }
1:             return pendingWakeups.get() > 0;
/////////////////////////////////////////////////////////////////////////
0:                         + pagedInMessages.size() + ", enqueueSize: " + destinationStatistics.getEnqueues().getCount());
commit:97e0fcc
/////////////////////////////////////////////////////////////////////////
1:                 // a sync message or if it is using a producer window
/////////////////////////////////////////////////////////////////////////
0:                                     } else {
0:                                         LOG.debug("unexpected exception on deferred send of :" + message, e);
1:                         registerCallbackForNotFullNotification();
/////////////////////////////////////////////////////////////////////////
1:     private void registerCallbackForNotFullNotification() {
1:         // If the usage manager is not full, then the task will not
0:         // get called..
0:         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
0:             // so call it directly here.
0:             sendMessagesWaitingForSpaceTask.run();
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 while (!messagesWaitingForSpace.isEmpty()) {
1:                     if (!memoryUsage.isFull()) {
0:                         Runnable op = messagesWaitingForSpace.removeFirst();
0:                         op.run();
0:                     } else {
1:                         registerCallbackForNotFullNotification();
0:                         break;
0:                     }
commit:f1f4e2c
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager Memory Limit ("+ memoryUsage.getLimit() + ") reached on " + getActiveMQDestination().getQualifiedName()
commit:adb7fcc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.security.SecurityContext;
/////////////////////////////////////////////////////////////////////////
0:         answer.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final TaskRunnerFactory taskFactory;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicLong pendingWakeups = new AtomicLong();
0:     
1:             asyncWakeup();
/////////////////////////////////////////////////////////////////////////
1:         if (messages instanceof VMPendingMessageCursor) {
0:         this.taskRunner =
0:             taskFactory.createTaskRunner(this, "Queue:" + destination.getPhysicalName());
/////////////////////////////////////////////////////////////////////////
1:         asyncWakeup();
/////////////////////////////////////////////////////////////////////////
0: 	        }        
0: 	        return pendingWakeups.decrementAndGet() > 0;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             pendingWakeups.incrementAndGet();
0: 
1:     private void asyncWakeup() {
1:             pendingWakeups.incrementAndGet();
1:             this.taskRunner.wakeup();    
/////////////////////////////////////////////////////////////////////////
0:                         doWakeUp = true;
commit:3536b1e
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.AbstractList;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.Comparator;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Set;
0: import java.util.concurrent.CopyOnWriteArraySet;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.TimeUnit;
0: 
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (message.isExpired()) {
0:                             if (broker.isExpired(message)) {
0:                                 messageExpired(createConnectionContext(), createMessageReference(message));
0:                                 // drop message will decrement so counter balance here
0:                                 destinationStatistics.getMessages().increment();
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                                         LOG.error("expired waiting for space..");
/////////////////////////////////////////////////////////////////////////
1:         doBrowse(browsedMessages, this.getMaxExpirePageSize());
/////////////////////////////////////////////////////////////////////////
0:         doBrowse(l, getMaxBrowsePageSize());
0:     
0:     public void doBrowse(List<Message> l, int max) {
0:             pageInMessages(false);
/////////////////////////////////////////////////////////////////////////
0:                     addAll(pagedInMessages.values(), l, max, toExpire);
/////////////////////////////////////////////////////////////////////////
0:                                 MessageReference node = messages.next();        
0:                                 if (node.isExpired()) {
0:                                     }
0:                                     messages.remove();
0:                                 } else {
0:                                     messages.rollback(node.getMessageId());
0:                                     if (l.contains(node.getMessage()) == false) {
/////////////////////////////////////////////////////////////////////////
0:         }     
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
/////////////////////////////////////////////////////////////////////////
0:                             if (ref.isExpired()) {
0:                                 if (broker.isExpired(ref)) {
0:                                     messageExpired(createConnectionContext(), ref);
0:                                 }
0:                             } else {
0:                             }   
commit:89eecad
/////////////////////////////////////////////////////////////////////////
0:         do {        
1:             doPageIn(true);
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
1:             doPageIn(true);
/////////////////////////////////////////////////////////////////////////
1:             doPageIn(true);
/////////////////////////////////////////////////////////////////////////
0: 	        // Perhaps we should page always into the pagedInPendingDispatch list if 
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchMutex) {            
0:             synchronized (pagedInPendingDispatch) {
0:                 pagedInPendingDispatch.remove(r);
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:             if (isLazyDispatch() && !force) {
0:             if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingDispatch.size() < getMaxPageSize()))) {
/////////////////////////////////////////////////////////////////////////
0:                 // and now see if we can dispatch the new stuff.. and append to the pending
/////////////////////////////////////////////////////////////////////////
1:             // avoid lock order contention
1:             asyncWakeup();
/////////////////////////////////////////////////////////////////////////
commit:8d9f47a
/////////////////////////////////////////////////////////////////////////
1:         asyncWakeup();
/////////////////////////////////////////////////////////////////////////
0:         } else {
1:             asyncWakeup();
0:     public void asyncWakeup() {
0:         try {
0:             this.taskRunner.wakeup();
0:         } catch (InterruptedException e) {
0:             LOG.warn("Async task tunner failed to wakeup ", e);
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
1:         boolean doWakeUp = false;
/////////////////////////////////////////////////////////////////////////
0:                         doWakeUp  = true;
1:         if (doWakeUp) {
0:             wakeup();
0:         }
/////////////////////////////////////////////////////////////////////////
0:             asyncWakeup();
commit:5e90f00
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (getExpireMessagesPeriod() > 0) {
0:             scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());
0:         }
/////////////////////////////////////////////////////////////////////////
commit:a1bd85e
/////////////////////////////////////////////////////////////////////////
0:             scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());
commit:ca242f4
/////////////////////////////////////////////////////////////////////////
0:                         if (broker.isExpired(ref)) {
0:                             messageExpired(connectionContext, ref);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                     if (broker.isExpired(ref)) {
0:                         messageExpired(connectionContext, ref);
0:                     } else {
0:                         synchronized (pagedInMessages) {
0:                             pagedInMessages.remove(ref.getMessageId());
0:                         }
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             if (ref.isExpired()) {
/////////////////////////////////////////////////////////////////////////
0:             getDestinationStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
0:                         getDestinationStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {      
commit:dbe847e
/////////////////////////////////////////////////////////////////////////
0:                             messageExpired(createConnectionContext(), createMessageReference(message));
0:                             // drop message will decrement so counter balance here
0:                             destinationStatistics.getMessages().increment();
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
0:                             messageExpired(createConnectionContext(), message);
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("remove sub: " + sub + ", lastDeliveredSeqId: " + lastDeiveredSequenceId
0:                         + ", dequeues: " + getDestinationStatistics().getDequeues().getCount()
0:                         + ", dispatched: " + getDestinationStatistics().getDispatched().getCount()
0:                         + ", inflight: " + getDestinationStatistics().getInflight().getCount());
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Expiring messages ..");
0:         }
0:         
0:         List<Message> browsedMessages = new AbstractList<Message>() {
/////////////////////////////////////////////////////////////////////////
0:         doBrowse(true, browsedMessages, this.getMaxExpirePageSize());
/////////////////////////////////////////////////////////////////////////
0:                         messageExpired(connectionContext, ref);
/////////////////////////////////////////////////////////////////////////
0:                     messageExpired(connectionContext, ref);
/////////////////////////////////////////////////////////////////////////
0:                                                 createMessageReference(node.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:     public void messageExpired(ConnectionContext context,MessageReference reference) {
0:         messageExpired(context,null,reference);
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("message expired: " + reference);
0:         }
/////////////////////////////////////////////////////////////////////////
0:                                 messageExpired(createConnectionContext(), ref);
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
0: import java.util.AbstractList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
0:     private final Runnable expireMessagesTask = new Runnable() {
0:         public void run() {
1:             expireMessages();          
0:         }
0:     };
0:     private static final Scheduler scheduler = Scheduler.getInstance();
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (getExpireMessagesPeriod() > 0) {
0:             scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:                             messageExpired(createConnectionContext(), null, message, false);
/////////////////////////////////////////////////////////////////////////
0:                                         destinationStatistics.getExpired().increment();
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(this  + ", waiting for store space... msg: " + message);
/////////////////////////////////////////////////////////////////////////
0:                             destinationStatistics.getExpired().increment();
/////////////////////////////////////////////////////////////////////////
0:     
1:     private void expireMessages() {
0:         LOG.info("expiring messages...");
1:         // just track the insertion count
0:         List<Message> l = new AbstractList<Message>() {
0:             int size = 0;
0: 
0:             @Override
0:             public void add(int index, Message element) {
0:                 size++;
0:             }
0: 
0:             @Override
0:             public int size() {
0:                 return size;
0:             }
0: 
0:             @Override
0:             public Message get(int index) {
0:                 return null;
0:             }
0:         };
0:         doBrowse(true, l, getMaxBrowsePageSize());
0:     }
0: 
0:     public void gc(){
0:     }
/////////////////////////////////////////////////////////////////////////
0:         
0:         LOG.info(toString() + ", canceling expireMessagesTask");
0:         scheduler.cancel(expireMessagesTask);
0:         
/////////////////////////////////////////////////////////////////////////
0:     public Message[] browse() {    
0:         doBrowse(false, l, getMaxBrowsePageSize());
0:         return l.toArray(new Message[l.size()]);
0:     }
0:     
0:     public void doBrowse(boolean forcePageIn, List<Message> l, int max) {
1:         final ConnectionContext connectionContext = createConnectionContext();
0:             pageInMessages(forcePageIn);
0:             List<MessageReference> toExpire = new ArrayList<MessageReference>();
0:             dispatchLock.lock();
0:             try {
0:                 synchronized (pagedInPendingDispatch) {
0:                     addAll(pagedInPendingDispatch, l, max, toExpire);
0:                     for (MessageReference ref : toExpire) {
0:                         pagedInPendingDispatch.remove(ref);
0:                         messageExpired(connectionContext, ref, false);
0:                 toExpire.clear();
0:                 synchronized (pagedInMessages) {
0:                     addAll(pagedInMessages.values(), l, max, toExpire);   
0:                 }
0:                 for (MessageReference ref : toExpire) {
0:                     messageExpired(connectionContext, ref, false);
0:                 }
0:                 
0:                 if (l.size() < getMaxBrowsePageSize()) {
0:                     synchronized (messages) {
0:                         try {
0:                             messages.reset();
0:                             while (messages.hasNext() && l.size() < max) {
0:                                 MessageReference node = messages.next();
0:                                 messages.rollback(node.getMessageId());
0:                                 if (node != null) {
0:                                     if (broker.isExpired(node)) {
0:                                         messageExpired(connectionContext,
0:                                                 createMessageReference(node.getMessage()), false);
0:                                     } else if (l.contains(node.getMessage()) == false) {
0:                                         l.add(node.getMessage());
0:                                     }
0:                         } finally {
0:                             messages.release();
0:             } finally {
0:                 dispatchLock.unlock();
1:             LOG.error("Problem retrieving message for browse", e);
0:     }
0: 
0:     private void addAll(Collection<QueueMessageReference> refs,
0:             List<Message> l, int maxBrowsePageSize, List<MessageReference> toExpire) throws Exception {
0:         for (Iterator<QueueMessageReference> i = refs.iterator(); i.hasNext()
0:                 && l.size() < getMaxBrowsePageSize();) {
0:             QueueMessageReference ref = i.next();
0:             if (broker.isExpired(ref)) {
1:                 toExpire.add(ref);
0:             } else if (l.contains(ref.getMessage()) == false) {
1:                 l.add(ref.getMessage());
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public void messageExpired(ConnectionContext context,MessageReference reference, boolean dispatched) {
0:         messageExpired(context,null,reference, dispatched);
0:         messageExpired(context, subs, reference, true);
0:     }
0:     
0:     public void messageExpired(ConnectionContext context,Subscription subs, MessageReference reference, boolean dispatched) {
0:         destinationStatistics.getExpired().increment();
0:         if (dispatched) {
0:             destinationStatistics.getInflight().decrement();
0:         }
/////////////////////////////////////////////////////////////////////////
0:                                 messageExpired(createConnectionContext(), ref, false);
/////////////////////////////////////////////////////////////////////////
0: 
commit:1421317
/////////////////////////////////////////////////////////////////////////
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
0:          
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(destination.getPhysicalName() + " toPageIn: "  + toPageIn + ", Inflight: "
0:                         + destinationStatistics.getInflight().getCount()
0:                         + ", pagedInMessages.size " + pagedInMessages.size());
0:             }
0:             
commit:132f662
/////////////////////////////////////////////////////////////////////////
0:                     
0:                     public boolean isDuplicate(MessageId id) {
0:                         return false;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             // the original ack may be a ranged ack, but we are trying to delete a specific
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 this.taskRunner.wakeup();
0:             } catch (InterruptedException e) {
0:                 LOG.warn(getName() + " failed to wakeup task runner on usageChange: " + e);
commit:08aecbe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.Usage;
1: import org.apache.activemq.usage.UsageListener;
/////////////////////////////////////////////////////////////////////////
0: public class Queue extends BaseDestination implements Task, UsageListener {
/////////////////////////////////////////////////////////////////////////
0:     private QueueDispatchSelector dispatchSelector;
/////////////////////////////////////////////////////////////////////////
0:     // make the queue easily visible in the debugger from its task runner threads
1:     final class QueueThread extends Thread {
1:         final Queue queue;
0:         public QueueThread(Runnable runnable, String name,
0:                 Queue queue) {
1:             super(runnable, name);
1:             this.queue = queue;
0:         }
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:             final Queue queue = this;
0:                     Thread thread = new QueueThread(runnable, "QueueThread:"+destination, queue);
/////////////////////////////////////////////////////////////////////////
0:         systemUsage.getMemoryUsage().addUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:         
0:         systemUsage.getMemoryUsage().removeUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:             
1:             // do early to allow dispatch of these waiting messages
0:             synchronized(messagesWaitingForSpace) {
0:                 while (!messagesWaitingForSpace.isEmpty() && !memoryUsage.isFull()) {
0:                     Runnable op = messagesWaitingForSpace.removeFirst();
0:                     op.run();
0:                 }
0:             }
0:             
/////////////////////////////////////////////////////////////////////////
0: 	        return !messagesWaitingForSpace.isEmpty();
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
1:         if (oldPercentUsage > newPercentUsage) {
0:             synchronized(messagesWaitingForSpace) {
0:                 if (!messagesWaitingForSpace.isEmpty() && !memoryUsage.isFull()) {
0:                     try {
0:                         this.taskRunner.wakeup();
0:                     } catch (InterruptedException e) {
0:                         LOG.warn(getName() + " failed to wakeup task runner on usageChange: " + e);
0:                     }
0:                 }
0:             }
0:         }
0:     }
commit:f9d5449
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         boolean pageInMoreMessages = false;   
/////////////////////////////////////////////////////////////////////////
0:             
0:             if ((force || !consumers.isEmpty()) && toPageIn > 0) { 
0:                         messages.setMaxBatchSize(toPageIn);
/////////////////////////////////////////////////////////////////////////
0:             if (this.consumers.isEmpty() || isSlave()) {
1:                 // slave dispatch happens in processDispatchNotification
/////////////////////////////////////////////////////////////////////////
1:     /* 
0:      * In slave mode, dispatch is ignored till we get this notification as the dispatch
0:      * process is non deterministic between master and slave.
0:      * On a notification, the actual dispatch to the subscription (as chosen by the master) 
0:      * is completed. 
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.broker.region.BaseDestination#processDispatchNotification(org.apache.activemq.command.MessageDispatchNotification)
1:      */
0:     public void processDispatchNotification(
0:             MessageDispatchNotification messageDispatchNotification) throws Exception {
1:         // do dispatch
1:         Subscription sub = getMatchingSubscription(messageDispatchNotification);
1:         if (sub != null) {
1:             MessageReference message = getMatchingMessage(messageDispatchNotification);
1:             sub.add(message);   
1:             sub.processMessageDispatchNotification(messageDispatchNotification);
0:         }
0:     }
0: 
0:     private QueueMessageReference getMatchingMessage(MessageDispatchNotification messageDispatchNotification) throws Exception {
1:         QueueMessageReference message = null;
1:         MessageId messageId = messageDispatchNotification.getMessageId();
0:         
0:         dispatchLock.lock();
0:         try {
0:             synchronized (pagedInPendingDispatch) {
0:                for(QueueMessageReference ref : pagedInPendingDispatch) {
0:                    if (messageId.equals(ref.getMessageId())) {
0:                        message = ref;
0:                        pagedInPendingDispatch.remove(ref);
0:                        break;
0:                    }
0:                }
0:             }
0:     
1:             if (message == null) {
0:                 synchronized (pagedInMessages) {
0:                     message = pagedInMessages.get(messageId);
0:                 }
0:             }
0:             
1:             if (message == null) {            
0:                 synchronized (messages) {
0:                     try {
0:                         messages.setMaxBatchSize(getMaxPageSize());
0:                         messages.reset();
0:                         while (messages.hasNext()) {
0:                             MessageReference node = messages.next();
0:                             node.incrementReferenceCount();
0:                             messages.remove();
0:                             if (messageId.equals(node.getMessageId())) {
0:                                 message = this.createMessageReference(node.getMessage());
0:                                 break;
0:                             }
0:                         }
0:                     } finally {
0:                         messages.release();
0:                     }
0:                 }
0:             }
0:             
1:             if (message == null) {
0:                 Message msg = loadMessage(messageId);
0:                 if (msg != null) {
0:                     message = this.createMessageReference(msg);
0:                 }
0:             }          
0:             
0:         } finally {
0:             dispatchLock.unlock();        
0:         }
1:         if (message == null) {
0:             throw new JMSException(
0:                     "Slave broker out of sync with master - Message: "
0:                     + messageDispatchNotification.getMessageId()
0:                     + " on " + messageDispatchNotification.getDestination()
0:                     + " does not exist among pending(" + pagedInPendingDispatch.size() + ") for subscription: "
0:                     + messageDispatchNotification.getConsumerId());
0:         }
1:         return message;
0:     }
0: 
1:     /**
1:      * Find a consumer that matches the id in the message dispatch notification
1:      * @param messageDispatchNotification
1:      * @return sub or null if the subscription has been removed before dispatch
1:      * @throws JMSException
1:      */
0:     private Subscription getMatchingSubscription(MessageDispatchNotification messageDispatchNotification) throws JMSException {
1:         Subscription sub = null;
0:         synchronized (consumers) {
0:             for (Subscription s : consumers) {
1:                 if (messageDispatchNotification.getConsumerId().equals(s.getConsumerInfo().getConsumerId())) {
1:                     sub = s;
0:                     break;
0:                 }
0:             }
0:         }
1:         return sub;
0:     }
commit:184761a
/////////////////////////////////////////////////////////////////////////
1:                 getMessageGroupOwners().removeConsumer(consumerId);
/////////////////////////////////////////////////////////////////////////
0:                 if (!list.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1: 	            pageInMoreMessages |= !messages.isEmpty();
/////////////////////////////////////////////////////////////////////////
0:             if (this.consumers.isEmpty()) {
1:                 return list;
0:             }
0:         List<QueueMessageReference> rc = new ArrayList<QueueMessageReference>(list.size());
1:         Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());
0:         
commit:9216c18
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * Holder for subscription and pagedInMessages as a browser
0:      * needs access to existing messages in the queue that have
0:      * already been dispatched
1:      */
1:     class BrowserDispatch {
0:         ArrayList<QueueMessageReference> messages;
1:         QueueBrowserSubscription browser;
0:         
0:         public BrowserDispatch(QueueBrowserSubscription browserSubscription,
0:                 Collection<QueueMessageReference> values) {
0:             
0:             messages =  new ArrayList<QueueMessageReference>(values);
1:             browser = browserSubscription;
1:             browser.incrementQueueRef();
0:         }
0:         
0:         void done() {
0:             try {
1:                 browser.decrementQueueRef();
0:             } catch (Exception e) {
0:                 LOG.warn("decrement ref on browser: " + browser, e);
0:             }
0:         }
0: 
1:         public QueueBrowserSubscription getBrowser() {
1:             return browser;
0:         }
0:     LinkedList<BrowserDispatch> browserDispatches = new LinkedList<BrowserDispatch>();
/////////////////////////////////////////////////////////////////////////
0:             if (sub instanceof QueueBrowserSubscription ) { 
1:                 QueueBrowserSubscription browserSubscription = (QueueBrowserSubscription) sub;
0:             	
0:                 // do again in iterate to ensure new messages are dispatched
0:                 doPageIn(false);
0:             	    if (!pagedInMessages.isEmpty()) {
0:             	        BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription, pagedInMessages.values());
0:             	        browserDispatches.addLast(browserDispatch);
0:             	    }
/////////////////////////////////////////////////////////////////////////
0:     BrowserDispatch getNextBrowserDispatch() {
0:             if( browserDispatches.isEmpty() ) {
0:             return browserDispatches.removeFirst();
0:         boolean pageInMoreMessages = false;
0:             BrowserDispatch rd;
0: 	        while ((rd = getNextBrowserDispatch()) != null) {
0: 	            pageInMoreMessages = true;
0: 	            
0: 	                QueueBrowserSubscription browser = rd.getBrowser();
0: 	                    if (!node.isAcked()) {
0: 	                        if (browser.matches(node, msgContext)) {
0: 	                            browser.add(node);
0: 	                                    
0:                     rd.done();
0: 
0: 	                LOG.warn("exception on dispatch to browser: " + rd.getBrowser(), e);
/////////////////////////////////////////////////////////////////////////
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeiveredSequenceId)
/////////////////////////////////////////////////////////////////////////
0:                         // only increment redelivery if it was delivered or we have no delivery information
0:                         if (lastDeiveredSequenceId == 0 || qmr.getMessageId().getBrokerSequenceId() <= lastDeiveredSequenceId) {
0:                             qmr.incrementRedeliveryCounter();
0:                         }
commit:d7f34d9
/////////////////////////////////////////////////////////////////////////
0:         synchronized (messages) {
0:             messages.rollback(r.getMessageId());
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     moveMessageTo(context, ref.getMessage(), dest);
/////////////////////////////////////////////////////////////////////////
0:         if (ack.isPoisonAck()) {
1:             // message gone to DLQ, is ok to allow redelivery
0:             synchronized(messages) {
1:                 messages.rollback(reference.getMessageId());
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
commit:c48c23f
/////////////////////////////////////////////////////////////////////////
0:             if (!(this.optimizedDispatch || isSlave())) {
0:         if (this.optimizedDispatch || isSlave()) {
/////////////////////////////////////////////////////////////////////////
0:             if (!(this.optimizedDispatch || isSlave())) {
0:         if (this.optimizedDispatch || isSlave()) {
commit:ba16efd
/////////////////////////////////////////////////////////////////////////
0:         // synchronize with dispatch method so that no new messages are sent
1:         // while setting up a subscription. avoid out of order messages,
1:         // duplicates, etc.
/////////////////////////////////////////////////////////////////////////
0:             
0:             // any newly paged in messages that are not dispatched are added to pagedInPending in iterate()
0:             
0:                 wakeup();
0:             // Outside of dispatchLock() to maintain the lock hierarchy of
0:             // iteratingMutex -> dispatchLock. - see https://issues.apache.org/activemq/browse/AMQ-1878
/////////////////////////////////////////////////////////////////////////
0:         // synchronize with dispatch method so that no new messages are sent
1:         // while removing up a subscription.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	                        if (rd.subscription.matches(node, msgContext)) {
0: 	                            rd.subscription.add(node);
0: 	                        } else {
0: 	                            // make sure it gets queued for dispatched again
0: 	                            dispatchLock.lock();
0: 	                            try {
0: 	                                pagedInPendingDispatch.add(node);
0: 	                            } finally {
0: 	                                dispatchLock.unlock();
0: 	                        }
/////////////////////////////////////////////////////////////////////////
0: 	        boolean pageInMoreMessages = false;
0: 	            pageInMoreMessages = !messages.isEmpty();
0: 	            pageInMoreMessages |= !pagedInPendingDispatch.isEmpty();
0: 	        // !messages.isEmpty(), and then if !pagedInPendingDispatch.isEmpty()
0: 	        // then we do a dispatch.
0: 	        if (pageInMoreMessages) {
/////////////////////////////////////////////////////////////////////////
0:                 // Only page in the minimum number of messages which can be dispatched immediately.
0:                 toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3c32abd
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:                 if (pagedInPendingDispatch.isEmpty()) {
0:                     pagedInPendingDispatch.addAll(doActualDispatch(list));
0:                 } else {
0:                     pagedInPendingDispatch.addAll(list);
0:                 }
0:     
0:         Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());
/////////////////////////////////////////////////////////////////////////
0:                     if (!fullConsumers.contains(s)) {
0:                         if (!s.isFull()) {
0:                             // Dispatch it.
0:                             s.add(node);
0:                             //System.err.println(getName()+" Dispatched to "+s.getConsumerInfo().getConsumerId()+", "+node.getMessageId());
0:                             target = s;
0:                             break;
0:                         } else {
0:                             // no further dispatch of list to a full consumer to avoid out of order message receipt 
0:                             fullConsumers.add(s);
0:                         }
0:                     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e3fb8be
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                     if (!qmr.isDropped()) {
0:                         redeliveredWaitingDispatch.addMessageLast(qmr);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:         if (!reference.isDropped()) {
0:             reference.drop();
0:             destinationStatistics.getMessages().decrement();
0:             pagedInMessagesLock.writeLock().lock();
0:             try {
0:                 pagedInMessages.remove(reference.getMessageId());
0:             } finally {
0:                 pagedInMessagesLock.writeLock().unlock();
0:             }
commit:e1f170d
/////////////////////////////////////////////////////////////////////////
1:     public int retryMessages(ConnectionContext context, int maximumMessages) throws Exception {
1:         if (!isDLQ()) {
1:             throw new Exception("Retry of message is only possible on Dead Letter Queues!");
0:         }
1:         int restoredCounter = 0;
0:         Set<QueueMessageReference> set = new LinkedHashSet<QueueMessageReference>();
0:         do {
0:             doPageIn(true);
0:             pagedInMessagesLock.readLock().lock();
0:             try{
1:                 set.addAll(pagedInMessages.values());
0:             }finally {
0:                 pagedInMessagesLock.readLock().unlock();
0:             }
0:             List<QueueMessageReference> list = new ArrayList<QueueMessageReference>(set);
0:             for (QueueMessageReference ref : list) {
1:                 if (ref.getMessage().getOriginalDestination() != null) {
0: 
0:                     moveMessageTo(context, ref, ref.getMessage().getOriginalDestination());
1:                     set.remove(ref);
1:                     if (++restoredCounter >= maximumMessages && maximumMessages > 0) {
1:                         return restoredCounter;
0:                     }
0:                 }
0:             }
1:         } while (set.size() < this.destinationStatistics.getMessages().getCount() && set.size() < maximumMessages);
1:         return restoredCounter;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             messagesLock.writeLock().lock();
0:             try {
0:                 messages.rollback(reference.getMessageId());
0:             } finally {
0:                 messagesLock.writeLock().unlock();
0:             }
commit:5bfbc54
/////////////////////////////////////////////////////////////////////////
1:                             browserDispatches.remove(browserDispatch);
commit:db1e6d1
/////////////////////////////////////////////////////////////////////////
0:             pageInMessages(true);
commit:915333e
/////////////////////////////////////////////////////////////////////////
1:                 if (sub instanceof QueueBrowserSubscription) {
1:                     ((QueueBrowserSubscription)sub).decrementQueueRef();
1:                     browserDispatches.remove(sub);
0:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             boolean hasBrowsers = browserDispatches.size() > 0;
0: 
0:             if (pageInMoreMessages || hasBrowsers || !redeliveredWaitingDispatch.isEmpty()) {
0:                     pageInMessages(hasBrowsers);
1:             if (hasBrowsers) {
/////////////////////////////////////////////////////////////////////////
0: 
1:                 Iterator<BrowserDispatch> browsers = browserDispatches.iterator();
1:                 while (browsers.hasNext()) {
1:                     BrowserDispatch browserDispatch = browsers.next();
1:                         QueueBrowserSubscription browser = browserDispatch.getBrowser();
0: 
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("dispatch to browser: " + browser
0:                                     + ", already dispatched/paged count: " + alreadyDispatchedMessages.size());
0:                         }
1:                         boolean added = false;
0:                             if (!node.isAcked() && !browser.getPending().getMessageAudit().isDuplicate(node.getMessageId())) {
1:                                     added = true;
1:                         // are we done browsing? no new messages paged
0:                         if (!added) {
0:                             browser.decrementQueueRef();
0:                         }
0:                         LOG.warn("exception on dispatch to browser: " + browserDispatch.getBrowser(), e);
0:                 }
commit:44ef96e
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("found lastDeliveredSeqID: " + lastDeiveredSequenceId + ", message reference: " + ref.getMessageId());
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("expiring from pagedInPending: " + ref);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("expiring from pagedInMessages: " + ref);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                                     if (LOG.isDebugEnabled()) {
0:                                         LOG.debug("expiring from messages: " + node);
0:                                     }
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3da9f1c
/////////////////////////////////////////////////////////////////////////
1:         MDC.put("activemq.destination", getName());
/////////////////////////////////////////////////////////////////////////
1:             MDC.remove("activemq.destination");
commit:0de4f88
/////////////////////////////////////////////////////////////////////////
1:                     } else if (sub.getConsumerInfo().getPriority() == Byte.MAX_VALUE ||
1:                         sub.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority()) {
commit:2b456dd
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.MDC;
/////////////////////////////////////////////////////////////////////////
0:         MDC.put("destination", getName());
/////////////////////////////////////////////////////////////////////////
0:             MDC.remove("destination");
commit:99653c6
/////////////////////////////////////////////////////////////////////////
0:             } else {
0:                 // if there are already paged messages
0:                 // dispatch them
0:                 if (pagedInMessages.size() != 0) {
0:                     pagedInMessagesLock.writeLock().lock();
0:                     ArrayList paged = new ArrayList();
0:                     try {
0:                        paged.addAll(pagedInMessages.values());
0:                     } finally {
0:                        pagedInMessagesLock.writeLock().unlock();
0:                     }
0:                     try {
0:                         doDispatch(paged);
0:                     } catch (Exception e) {
0:                        LOG.error("Failed to dispatch already paged messages ", e);
0:                     }
0:                 }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected static final Logger LOG = LoggerFactory.getLogger(Queue.class);
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.error("Failed to add message to cursor", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error(e.toString());
/////////////////////////////////////////////////////////////////////////
1:     protected Logger getLog() {
commit:cb9f176
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(getName() + "Producer Flow Control Timeout Task is stopping");
/////////////////////////////////////////////////////////////////////////
0:         if (systemUsage.getStoreUsage() != null) {
0:             systemUsage.getStoreUsage().start();
0:         }
commit:ef1a3c1
/////////////////////////////////////////////////////////////////////////
0: 
0:             store.removeAsyncMessage(context, ack);
commit:5773796
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("Message " + msg.getMessageId() + " sent to " + this.destination);
0:         }
commit:227ed96
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0:                             if (assignMessageGroup(s, (QueueMessageReference)node)) {
0:                                 // Dispatch it.
0:                                 s.add(node);
0:                                 target = s;
0:                                 break;
0:                             }
/////////////////////////////////////////////////////////////////////////
1:     protected boolean assignMessageGroup(Subscription subscription, QueueMessageReference node) throws Exception {
0:         //QueueMessageReference node = (QueueMessageReference) m;
1:         boolean result = true;
1:         // Keep message groups together.
1:         String groupId = node.getGroupID();
1:         int sequence = node.getGroupSequence();
1:         if (groupId != null) {
0:             //MessageGroupMap messageGroupOwners = ((Queue) node
0:             //        .getRegionDestination()).getMessageGroupOwners();
0: 
1:             MessageGroupMap messageGroupOwners = getMessageGroupOwners();
1:             // If we can own the first, then no-one else should own the
1:             // rest.
1:             if (sequence == 1) {
1:                 assignGroup(subscription, messageGroupOwners, node, groupId);
0:             } else {
0: 
1:                 // Make sure that the previous owner is still valid, we may
1:                 // need to become the new owner.
1:                 ConsumerId groupOwner;
0: 
1:                 groupOwner = messageGroupOwners.get(groupId);
1:                 if (groupOwner == null) {
1:                     assignGroup(subscription, messageGroupOwners, node, groupId);
0:                 } else {
1:                     if (groupOwner.equals(subscription.getConsumerInfo().getConsumerId())) {
1:                         // A group sequence < 1 is an end of group signal.
1:                         if (sequence < 0) {
1:                             messageGroupOwners.removeGroup(groupId);
0:                         }
0:                     } else {
1:                         result = false;
0:                     }
0:                 }
0:             }
0:         }
0: 
0:         return result;
0: 
0:     }
0: 
1:     protected void assignGroup(Subscription subs, MessageGroupMap messageGroupOwners, MessageReference n, String groupId) throws IOException {
1:         messageGroupOwners.put(groupId, subs.getConsumerInfo().getConsumerId());
1:         Message message = n.getMessage();
0:         if (message instanceof ActiveMQMessage) {
0:             ActiveMQMessage activeMessage = (ActiveMQMessage) message;
0:             try {
0:                 activeMessage.setBooleanProperty("JMSXGroupFirstForConsumer", true, false);
0:             } catch (JMSException e) {
0:                 LOG.warn("Failed to set boolean header: " + e, e);
0:             }
0:         }
0:     }
0: 
commit:a3344e6
/////////////////////////////////////////////////////////////////////////
0:     private List<QueueMessageReference> redeliveredWaitingDispatch = new ArrayList<QueueMessageReference>();
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:                 
/////////////////////////////////////////////////////////////////////////
0:                     redeliveredWaitingDispatch.add(qmr);
0:                 if (!redeliveredWaitingDispatch.isEmpty()) {
0:                     doDispatch(new ArrayList());
/////////////////////////////////////////////////////////////////////////
0:             if (pageInMoreMessages || pendingBrowserDispatch != null || !redeliveredWaitingDispatch.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:                 if (!redeliveredWaitingDispatch.isEmpty()) {
0:                     // Try first to dispatch redelivered messages to keep an proper order
0:                     redeliveredWaitingDispatch = doActualDispatch(redeliveredWaitingDispatch);
0:                 }
0:                     // Next dispatch anything that had not been
commit:83128fc
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
1: import java.util.concurrent.DelayQueue;
1: import java.util.concurrent.Delayed;
1: import javax.jms.ResourceAllocationException;
/////////////////////////////////////////////////////////////////////////
0:     protected final Map<MessageId, Runnable> messagesWaitingForSpace = Collections.synchronizedMap(new LinkedHashMap<MessageId, Runnable>());
/////////////////////////////////////////////////////////////////////////
0:     
0:     
1:     class TimeoutMessage implements Delayed {
0: 
1:         Message message;
1:         ConnectionContext context;
1:         long trigger;
0:         
1:         public TimeoutMessage(Message message, ConnectionContext context, long delay) {
0:             this.message = message;
0:             this.context = context;
1:             this.trigger = System.currentTimeMillis() + delay;
0:         }
0:         
1:         public long getDelay(TimeUnit unit) {
1:             long n = trigger - System.currentTimeMillis();
1:             return unit.convert(n, TimeUnit.MILLISECONDS);
0:         }
0: 
1:         public int compareTo(Delayed delayed) {
0:             long other = ((TimeoutMessage)delayed).trigger;
1:             int returnValue;
1:             if (this.trigger < other) {
0:               returnValue = -1;
1:             } else if (this.trigger > other) {
0:               returnValue = 1;
0:             } else {
0:               returnValue = 0;
0:             }
1:             return returnValue;
0:         }
0:         
0:     }
0:     
1:     DelayQueue<TimeoutMessage> flowControlTimeoutMessages = new DelayQueue<TimeoutMessage>();
0:     
1:     class FlowControlTimeoutTask extends Thread {
0:         
0:         public void run() {
1:             TimeoutMessage timeout;
0:             try {
1:                 while (true) {
1:                     timeout = flowControlTimeoutMessages.take();
1:                     if (timeout != null) {
1:                         synchronized (messagesWaitingForSpace) {
1:                             if (messagesWaitingForSpace.remove(timeout.message.getMessageId()) != null) {
0:                                 ExceptionResponse response = new ExceptionResponse(new ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer (" + timeout.message.getProducerId() + ") to prevent flooding "
0:                                         + getActiveMQDestination().getQualifiedName() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info"));
1:                                 response.setCorrelationId(timeout.message.getCommandId());
1:                                 timeout.context.getConnection().dispatchAsync(response);
0:                             }
0:                         }
0:                     }
0:                 }
0:             } catch (InterruptedException e) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Producer Flow Control Timeout Task is stopping");
0:                 }
0:             }
0:         }
0:     };
0:     
1:     private final FlowControlTimeoutTask flowControlTimeoutTask = new FlowControlTimeoutTask();
0:     
/////////////////////////////////////////////////////////////////////////
0:                     throw new ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding "
/////////////////////////////////////////////////////////////////////////
1:                         messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:                         
0:                         if (systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
0:                             flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage.getSendFailIfNoSpaceAfterTimeout()));
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                         throw new ResourceAllocationException(logMessage);
/////////////////////////////////////////////////////////////////////////
0:         
0:         flowControlTimeoutTask.setName("Producer Flow Control Timeout Task");
0:         
0:         // Start flow control timeout task
0:         // Prevent trying to start it multiple times
0:         if (!flowControlTimeoutTask.isAlive()) {
0:             flowControlTimeoutTask.start();
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (flowControlTimeoutTask.isAlive()) {
0:             flowControlTimeoutTask.interrupt();
0:         }
/////////////////////////////////////////////////////////////////////////
1:                 Iterator<Runnable> it = messagesWaitingForSpace.values().iterator();
1:                 while (it.hasNext()) {
1:                         Runnable op = it.next();
1:                         it.remove();
/////////////////////////////////////////////////////////////////////////
0:                     throw new ResourceAllocationException(logMessage);
/////////////////////////////////////////////////////////////////////////
0:     private final void waitForSpace(ConnectionContext context, Usage<?> usage, String warning) throws IOException, InterruptedException, ResourceAllocationException {
0:         if (systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
0:             if (!usage.waitForSpace(systemUsage.getSendFailIfNoSpaceAfterTimeout())) {
0:                 throw new ResourceAllocationException(warning);
0:         } else {
0:             long start = System.currentTimeMillis();
0:             long nextWarn = start + blockedProducerWarningInterval;
0:             while (!usage.waitForSpace(1000)) {
0:                 if (context.getStopping().get()) {
0:                     throw new IOException("Connection closed, send aborted.");
0:                 }
0:     
0:                 long now = System.currentTimeMillis();
0:                 if (now >= nextWarn) {
0:                     LOG.info(warning + " (blocking for: " + (now - start) / 1000 + "s)");
0:                     nextWarn = now + blockedProducerWarningInterval;
0:                 }
commit:7dca53d
/////////////////////////////////////////////////////////////////////////
0:                 final String logMessage = "Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                 LOG.info(logMessage);
/////////////////////////////////////////////////////////////////////////
0:                 if (systemUsage.getStoreUsage().isFull()) {
0:                     final String logMessage = "Usage Manager Store is Full. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0:                             " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                     LOG.info(logMessage);
0:                     if (systemUsage.isSendFailIfNoSpace()) {
0:                         throw new javax.jms.ResourceAllocationException(logMessage);
0:                     }
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 final String logMessage = "Usage Manager Temp Store is Full. Stopping producer (" + msg.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                 LOG.info(logMessage);
0:                 if (systemUsage.isSendFailIfNoSpace()) {
0:                     throw new javax.jms.ResourceAllocationException(logMessage);
0:                 }
0:             }
commit:ab60046
/////////////////////////////////////////////////////////////////////////
0:             	final String logMessage = "Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0:     					" See http://activemq.apache.org/producer-flow-control.html for more info";
0:             	LOG.info(logMessage);
/////////////////////////////////////////////////////////////////////////
0:             	if (systemUsage.getStoreUsage().isFull()) {
0:                 	final String logMessage = "Usage Manager Store is Full. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0: 							" See http://activemq.apache.org/producer-flow-control.html for more info";
0:                 	LOG.info(logMessage);
0:             		if (systemUsage.isSendFailIfNoSpace()) {
0:             			throw new javax.jms.ResourceAllocationException(logMessage);
0:             		}
0:             	}
/////////////////////////////////////////////////////////////////////////
0:         	if (systemUsage.getTempUsage().isFull()) {
0:         		final String logMessage = "Usage Manager Temp Store is Full. Stopping producer (" + msg.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0: 						" See http://activemq.apache.org/producer-flow-control.html for more info";
0:         		LOG.info(logMessage);
0:         		if (systemUsage.isSendFailIfNoSpace()) {
0:         			throw new javax.jms.ResourceAllocationException(logMessage);
0:         		}
0:         	}
commit:538d07e
/////////////////////////////////////////////////////////////////////////
0:                 if (systemUsage.isSendFailIfNoSpace() && systemUsage.getStoreUsage().isFull()) {
0:                 	throw new javax.jms.ResourceAllocationException("Usage Manager Store is Full");
commit:f54713a
/////////////////////////////////////////////////////////////////////////
0:                 pageInMessages(false);
0:                 
/////////////////////////////////////////////////////////////////////////
1:             	if (s instanceof QueueBrowserSubscription) {
0:             		interestCount++;
0:             		continue;
0:             	}
commit:9ad6c08
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.state.ProducerState;
/////////////////////////////////////////////////////////////////////////
0:         synchronized (consumers) {
0:             if (consumers.isEmpty()) {
1:                 onMessageWithNoConsumers(context, msg);
0:             }
0:         }
commit:51f68fb
/////////////////////////////////////////////////////////////////////////
1:             		if (consumersBeforeDispatchStarts != 0) {
1:             			consumersBeforeStartsLatch = new CountDownLatch(consumersBeforeDispatchStarts - 1);
0:             		}
1:                 	if (consumersBeforeStartsLatch != null) {
1:                 		consumersBeforeStartsLatch.countDown();
0:                 	}
/////////////////////////////////////////////////////////////////////////
commit:a321204
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean firstConsumer = false;
1:     private int timeBeforeDispatchStarts = 0;
1:     private int consumersBeforeDispatchStarts = 0;
1:     private CountDownLatch consumersBeforeStartsLatch;
/////////////////////////////////////////////////////////////////////////
0:         // If we are cursoring to disk..it's not and issue because it does not block due 
/////////////////////////////////////////////////////////////////////////
0:             	
1:             	// set a flag if this is a first consumer
1:             	if (consumers.size() == 0) {
1:             		firstConsumer = true;
0:             	} else {
1:             		firstConsumer = false;
0:             	}
0:             	
0:             	if (consumersBeforeStartsLatch != null) {
0:             		consumersBeforeStartsLatch.countDown();
0:             	}
0:             	
/////////////////////////////////////////////////////////////////////////
1: 	public int getTimeBeforeDispatchStarts() {
1: 		return timeBeforeDispatchStarts;
0: 	}
0: 
1: 	public void setTimeBeforeDispatchStarts(int timeBeforeDispatchStarts) {
1: 		this.timeBeforeDispatchStarts = timeBeforeDispatchStarts;
0: 	}
0: 
1: 	public int getConsumersBeforeDispatchStarts() {
1: 		return consumersBeforeDispatchStarts;
0: 	}
0: 
1: 	public void setConsumersBeforeDispatchStarts(int consumersBeforeDispatchStarts) {
1: 		this.consumersBeforeDispatchStarts = consumersBeforeDispatchStarts;
0: 		consumersBeforeStartsLatch = new CountDownLatch(consumersBeforeDispatchStarts);
0: 	}
/////////////////////////////////////////////////////////////////////////
1: 	        if (firstConsumer) {
0: 	        	firstConsumer = false;
0: 	        	try {
1: 	        		if (consumersBeforeDispatchStarts > 0) {
0: 	        			int timeout = 1000; // wait one second by default if consumer count isn't reached  
1: 	        			if (timeBeforeDispatchStarts > 0) {
1: 	        				timeout = timeBeforeDispatchStarts;
0: 	        			}
1: 	        			if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {
0: 	        				if (LOG.isDebugEnabled()) {
0: 	        					LOG.debug(consumers.size() + " consumers subscribed. Starting dispatch.");
0: 	        				}
0: 	        			} else {
0: 	        				if (LOG.isDebugEnabled()) {
0: 	        					LOG.debug(timeout + " ms elapsed and " +  consumers.size() + " consumers subscribed. Starting dispatch.");
0: 	        				}
0: 	        			}
0: 	        		}	        		
1: 	        		if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {
1: 	        			iteratingMutex.wait(timeBeforeDispatchStarts);
0: 	        			if (LOG.isDebugEnabled()) {
0: 	        				LOG.debug(timeBeforeDispatchStarts + " ms elapsed. Starting dispatch.");
0: 	        			}
0: 	        		}
0: 	        	} catch (Exception e) {
0: 	        		LOG.error(e);
0: 	        	}
0: 	        }
0: 	        
commit:807f645
/////////////////////////////////////////////////////////////////////////
0:             // do recovery dispatch only if it is a browser subscription
0:             if(sub instanceof QueueBrowserSubscription ) { 
0:             	// any newly paged in messages that are not dispatched are added to pagedInPending in iterate()
0:             	doPageIn(false);
0:             	synchronized (pagedInMessages) {
0:             		RecoveryDispatch rd = new RecoveryDispatch();
0:             		rd.messages =  new ArrayList<QueueMessageReference>(pagedInMessages.values());
0:             		rd.subscription = sub;
0:             		recoveries.addLast(rd);
0:             	}
0:             
/////////////////////////////////////////////////////////////////////////
0:             //if it is a last consumer (and not a browser) dispatch all pagedIn messages
0:             if (consumers.isEmpty() && !(sub instanceof QueueBrowserSubscription)) {
0:             		List<QueueMessageReference> list = new ArrayList<QueueMessageReference>();
0:             		for (QueueMessageReference ref : pagedInMessages.values()) {
0:             			list.add(ref);
0:             		}
0:             		pagedInPendingDispatch.clear();
0:             		doDispatch(list);
/////////////////////////////////////////////////////////////////////////
0:             pageInMessages(false);
/////////////////////////////////////////////////////////////////////////
0:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:             doPageIn(true);
/////////////////////////////////////////////////////////////////////////
0: 	        
/////////////////////////////////////////////////////////////////////////
0:                         wakeup();
/////////////////////////////////////////////////////////////////////////
0:                 } else {
0:                 	// makes sure it gets dispatched again
0:                 	if (!node.isDropped() && !((QueueMessageReference)node).isAcked() && (!node.isDropped() || s.getConsumerInfo().isBrowser())) {
0:                 		interestCount++;
0:                 	}
0:             if ((target == null && interestCount>0) || consumers.size() == 0) {
0:                 // This means all subs were full or that there are no consumers...
/////////////////////////////////////////////////////////////////////////
author:Colin W Macnaughton
-------------------------------------------------------------------------------
commit:48764be
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected TaskRunner taskRunner;
0:     private final LinkedHashMap<MessageId, QueueMessageReference> pagedInMessages = new LinkedHashMap<MessageId, QueueMessageReference>();
/////////////////////////////////////////////////////////////////////////
1:     private boolean useConsumerPriority = true;
1:     private boolean strictOrderDispatch = false;
1:     private boolean optimizedDispatch = false;
0: 
/////////////////////////////////////////////////////////////////////////
0:             expireMessages();
0: 
0:     private static final Comparator<Subscription> orderedCompare = new Comparator<Subscription>() {
0:         }
0: 
0:     public Queue(BrokerService brokerService, final ActiveMQDestination destination, MessageStore store, DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
1:         this.taskFactory = taskFactory;
1:         this.dispatchSelector = new QueueDispatchSelector(destination);
/////////////////////////////////////////////////////////////////////////
0: 
1:         public QueueThread(Runnable runnable, String name, Queue queue) {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:         this.taskRunner = taskFactory.createTaskRunner(this, "Queue:" + destination.getPhysicalName());
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:      * Holder for subscription and pagedInMessages as a browser needs access to
0:      * existing messages in the queue that have already been dispatched
0: 
0:         public BrowserDispatch(QueueBrowserSubscription browserSubscription, Collection<QueueMessageReference> values) {
0: 
0:             messages = new ArrayList<QueueMessageReference>(values);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         synchronized (dispatchMutex) {
0: 
0: 
0:                 // set a flag if this is a first consumer
0:                 if (consumers.size() == 0) {
0:                     firstConsumer = true;
0:                     if (consumersBeforeDispatchStarts != 0) {
0:                         consumersBeforeStartsLatch = new CountDownLatch(consumersBeforeDispatchStarts - 1);
0:                     }
0:                 } else {
0:                     if (consumersBeforeStartsLatch != null) {
0:                         consumersBeforeStartsLatch.countDown();
0:                     }
0:                 }
0: 
1:                     if (exclusiveConsumer == null) {
1:                         exclusiveConsumer = sub;
0:                     } else if (sub.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority()) {
1:                         exclusiveConsumer = sub;
0: 
1:             if (sub instanceof QueueBrowserSubscription) {
0: 
0: 
0:                 synchronized (pagedInMessages) {
0:                     if (!pagedInMessages.isEmpty()) {
0:                         BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription, pagedInMessages.values());
0:                         browserDispatches.addLast(browserDispatch);
0:                     }
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeiveredSequenceId) throws Exception {
0:         synchronized (dispatchMutex) {
0:                 LOG.debug("remove sub: " + sub + ", lastDeliveredSeqId: " + lastDeiveredSequenceId + ", dequeues: " + getDestinationStatistics().getDequeues().getCount() + ", dispatched: "
0:                         + getDestinationStatistics().getDispatched().getCount() + ", inflight: " + getDestinationStatistics().getInflight().getCount());
1:                     Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();
0:                             if (s.getConsumerInfo().isExclusive() && (exclusiveConsumer == null || s.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority())) {
/////////////////////////////////////////////////////////////////////////
0: 
1:                     QueueMessageReference qmr = (QueueMessageReference) ref;
1:                     if (qmr.getLockOwner() == sub) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (memoryUsage.isFull()) {
0:                 if (warnOnProducerFlowControl) {
0:                     LOG.info("Usage Manager Memory Limit reached on " + getActiveMQDestination().getQualifiedName()
0:                             + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it."
0:                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding "
0:                             + getActiveMQDestination().getQualifiedName() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
0:                     final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:                     if (memoryUsage.isFull()) {
0:                         waitForSpace(context, memoryUsage, "Usage Manager Memory Limit is full. Producer (" + message.getProducerId() + ") stopped to prevent flooding "
0:                                 + getActiveMQDestination().getQualifiedName() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                     String logMessage = "Usage Manager Store is Full. Producer (" + message.getProducerId() + ") stopped to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
0:                             + " See http://activemq.apache.org/producer-flow-control.html for more info";
0: 
0: 
0:                     waitForSpace(context, systemUsage.getStoreUsage(), logMessage);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     public void gc() {
0: 
/////////////////////////////////////////////////////////////////////////
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size() + ", memory=" + memoryUsage.getPercentUsage() + "%, size=" + size + ", in flight groups="
0:                 + messageGroupOwners;
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception {
0: 
0: 
0: 
0:         if (store != null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public int getTimeBeforeDispatchStarts() {
0:         return timeBeforeDispatchStarts;
0:     }
0:     public void setTimeBeforeDispatchStarts(int timeBeforeDispatchStarts) {
0:         this.timeBeforeDispatchStarts = timeBeforeDispatchStarts;
0:     }
0:     public int getConsumersBeforeDispatchStarts() {
0:         return consumersBeforeDispatchStarts;
0:     }
0: 
0:     public void setConsumersBeforeDispatchStarts(int consumersBeforeDispatchStarts) {
0:         this.consumersBeforeDispatchStarts = consumersBeforeDispatchStarts;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public Message[] browse() {
0: 
0:             synchronized (dispatchMutex) {
/////////////////////////////////////////////////////////////////////////
0: 
0:                                 MessageReference node = messages.next();
0:                                         messageExpired(connectionContext, createMessageReference(node.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             }
0:         }
0:     private void addAll(Collection<QueueMessageReference> refs, List<Message> l, int maxBrowsePageSize, List<MessageReference> toExpire) throws Exception {
0:         for (Iterator<QueueMessageReference> i = refs.iterator(); i.hasNext() && l.size() < getMaxBrowsePageSize();) {
/////////////////////////////////////////////////////////////////////////
0:                             LOG.error("got an exception retrieving message " + id);
/////////////////////////////////////////////////////////////////////////
0:     public void purge() throws Exception {
0:         do {
/////////////////////////////////////////////////////////////////////////
0:                     removeMessage(c, (IndirectMessageReference) r);
0: 
/////////////////////////////////////////////////////////////////////////
1:             List<MessageReference> list = new ArrayList<MessageReference>(set);
1:                     if (++movedCounter >= maximumMessages && maximumMessages > 0) {
/////////////////////////////////////////////////////////////////////////
1:             int oldMaxSize = getMaxPageSize();
0:             List<MessageReference> list = new ArrayList<MessageReference>(set);
0: 
0:                     r.incrementReferenceCount();
1:                         if (++movedCounter >= maximumMessages && maximumMessages > 0) {
/////////////////////////////////////////////////////////////////////////
0: 
0:      * 
0:     public boolean moveMessageTo(ConnectionContext context, Message m, ActiveMQDestination dest) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         return moveMatchingMessagesTo(context, selector, dest, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
0:     public int moveMatchingMessagesTo(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                     if (++movedCounter >= maximumMessages && maximumMessages > 0) {
0:         } while (set.size() < this.destinationStatistics.getMessages().getCount() && set.size() < maximumMessages);
0: 
0:             if (browserDispatches.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:         boolean pageInMoreMessages = false;
1:         synchronized (iteratingMutex) {
0: 
0:             synchronized (messagesWaitingForSpace) {
0: 
0:             while ((rd = getNextBrowserDispatch()) != null) {
0:                 pageInMoreMessages = true;
0: 
0:                 try {
0:                     MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
0:                     msgContext.setDestination(destination);
0: 
0:                     QueueBrowserSubscription browser = rd.getBrowser();
0:                     for (QueueMessageReference node : rd.messages) {
0:                         if (!node.isAcked()) {
0:                             msgContext.setMessageReference(node);
0:                             if (browser.matches(node, msgContext)) {
0:                                 browser.add(node);
0:                             }
0:                         }
0:                     }
0: 
0:                 } catch (Exception e) {
0:                     LOG.warn("exception on dispatch to browser: " + rd.getBrowser(), e);
0:             }
0: 
0:             if (firstConsumer) {
0:                 firstConsumer = false;
0:                 try {
0:                     if (consumersBeforeDispatchStarts > 0) {
0:                         int timeout = 1000; // wait one second by default if consumer count isn't reached  
0:                         if (timeBeforeDispatchStarts > 0) {
0:                             timeout = timeBeforeDispatchStarts;
0:                         }
0:                         if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(consumers.size() + " consumers subscribed. Starting dispatch.");
0:                             }
0:                         } else {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(timeout + " ms elapsed and " + consumers.size() + " consumers subscribed. Starting dispatch.");
0:                             }
0:                         }
0:                     }
0:                     if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {
0:                         iteratingMutex.wait(timeBeforeDispatchStarts);
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug(timeBeforeDispatchStarts + " ms elapsed. Starting dispatch.");
0:                         }
0:                     }
0:                 } catch (Exception e) {
0:                     LOG.error(e);
0:                 }
0:             }
0: 
0:             synchronized (messages) {
0:                 pageInMoreMessages |= !messages.isEmpty();
0:             }
0: 
0:             // Kinda ugly.. but I think dispatchLock is the only mutex protecting the 
0:             // pagedInPendingDispatch variable. 	        
0:             synchronized (dispatchMutex) {
0:                 pageInMoreMessages |= !pagedInPendingDispatch.isEmpty();
0:             }
0: 
0:             // Perhaps we should page always into the pagedInPendingDispatch list if 
0:             // !messages.isEmpty(), and then if !pagedInPendingDispatch.isEmpty()
0:             // then we do a dispatch.
0:             if (pageInMoreMessages) {
0:                 try {
0:                     pageInMessages(false);
0: 
0:                 } catch (Throwable e) {
0:                     LOG.error("Failed to page in more queue messages ", e);
0:                 }
0:             }
0:             return pendingWakeups.decrementAndGet() > 0;
/////////////////////////////////////////////////////////////////////////
0: 
1:                 return "MessageIdFilter: " + messageId;
/////////////////////////////////////////////////////////////////////////
0:         synchronized (dispatchMutex) {
0: 
1:     protected void removeMessage(ConnectionContext c, Subscription subs, QueueMessageReference r) throws IOException {
0: 
0:     protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference, MessageAck ack) throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:             synchronized (messages) {
0: 
0:         synchronized (pagedInMessages) {
0: 
1:     public void messageExpired(ConnectionContext context, MessageReference reference) {
1:         messageExpired(context, null, reference);
0: 
1:     public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {
1:             removeMessage(context, subs, (QueueMessageReference) reference);
1:             LOG.error("Failed to remove expired Message from the store ", e);
0: 
/////////////////////////////////////////////////////////////////////////
0:             if (systemUsage.getTempUsage().isFull()) {
0:                 final String logMessage = "Usage Manager Temp Store is Full. Stopping producer (" + msg.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
0:                         + " See http://activemq.apache.org/producer-flow-control.html for more info";
0: 
0:                 waitForSpace(context, messages.getSystemUsage().getTempUsage(), logMessage);
0: 
0:         synchronized (messages) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             this.taskRunner.wakeup();
0: 
/////////////////////////////////////////////////////////////////////////
0:         synchronized (dispatchMutex) {
0:                 LOG.debug(destination.getPhysicalName() + " toPageIn: " + toPageIn + ", Inflight: " + destinationStatistics.getInflight().getCount() + ", pagedInMessages.size "
0:                         + pagedInMessages.size());
0: 
/////////////////////////////////////////////////////////////////////////
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                     for (QueueMessageReference ref : result) {
/////////////////////////////////////////////////////////////////////////
0:         synchronized (dispatchMutex) {
0: 
/////////////////////////////////////////////////////////////////////////
0:         }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             int interestCount = 0;
0:                 if (s instanceof QueueBrowserSubscription) {
0:                     interestCount++;
0:                     continue;
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                     // makes sure it gets dispatched again
0:                     if (!node.isDropped() && !((QueueMessageReference) node).isAcked() && (!node.isDropped() || s.getConsumerInfo().isBrowser())) {
0:                         interestCount++;
0:                     }
0: 
0:             if ((target == null && interestCount > 0) || consumers.size() == 0) {
0:                 rc.add((QueueMessageReference) node);
0:             if (target != null && !strictOrderDispatch && consumers.size() > 1 && !dispatchSelector.isExclusiveConsumer(target)) {
1:                     if (removeFromConsumerList(target)) {
/////////////////////////////////////////////////////////////////////////
0:         doDispatch(doPageIn(force));
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:                 zeroPrefetch |= s.getPrefetchSize() == 0;
0:                 int countBeforeFull = s.countBeforeFull();
0:         if (total == 0 && zeroPrefetch) {
0:             total = 1;
0:     /*
1:      * In slave mode, dispatch is ignored till we get this notification as the
1:      * dispatch process is non deterministic between master and slave. On a
1:      * notification, the actual dispatch to the subscription (as chosen by the
1:      * master) is completed. (non-Javadoc)
0:      * 
1:      * @see
1:      * org.apache.activemq.broker.region.BaseDestination#processDispatchNotification
1:      * (org.apache.activemq.command.MessageDispatchNotification)
1:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
0:             sub.add(message);
/////////////////////////////////////////////////////////////////////////
0: 
0:         synchronized (dispatchMutex) {
0:                 for (QueueMessageReference ref : pagedInPendingDispatch) {
0:                     if (messageId.equals(ref.getMessageId())) {
0:                         message = ref;
0:                         pagedInPendingDispatch.remove(ref);
0:                         break;
0:                     }
0:                 }
0: 
0: 
0:             if (message == null) {
/////////////////////////////////////////////////////////////////////////
0: 
0:             }
0: 
0:         }
0:             throw new JMSException("Slave broker out of sync with master - Message: " + messageDispatchNotification.getMessageId() + " on " + messageDispatchNotification.getDestination()
0:                     + " does not exist among pending(" + pagedInPendingDispatch.size() + ") for subscription: " + messageDispatchNotification.getConsumerId());
0:      * 
/////////////////////////////////////////////////////////////////////////
0: 
0:     private final void waitForSpace(ConnectionContext context, Usage<?> usage, String warning) throws IOException, InterruptedException {
0:         long start = System.currentTimeMillis();
0:         long nextWarn = start + blockedProducerWarningInterval;
0:         while (!usage.waitForSpace(1000)) {
0:             if (context.getStopping().get()) {
0:                 throw new IOException("Connection closed, send aborted.");
0:             }
0: 
0:             long now = System.currentTimeMillis();
0:             if (now >= nextWarn) {
0:                 LOG.info(warning + " (blocking for: " + (now - start) / 1000 + "s)");
0:                 nextWarn = now + blockedProducerWarningInterval;
0:             }
0:         }
0:     }
commit:4245c35
/////////////////////////////////////////////////////////////////////////
0:                 if(warnOnProducerFlowControl) {
0:                     warnOnProducerFlowControl = false;
0:                     LOG.info("Usage Manager memory limit reached on " +getActiveMQDestination().getQualifiedName() + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it." +
0:                             " See http://activemq.apache.org/producer-flow-control.html for more info");
0:                 }
0:                 
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " +getActiveMQDestination().getQualifiedName() + "." +
0:                             " See http://activemq.apache.org/producer-flow-control.html for more info");
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1ab76f7
/////////////////////////////////////////////////////////////////////////
1:         final BooleanExpression selectorExpression = SelectorParser.parse(selector);
author:David Jencks
-------------------------------------------------------------------------------
commit:07b6a38
/////////////////////////////////////////////////////////////////////////
0:      * @param context connection context
0:      * @param m message
0:      * @param dest ActiveMQDestination
author:James Strachan
-------------------------------------------------------------------------------
commit:947659c
/////////////////////////////////////////////////////////////////////////
0: 
1:     public List<Subscription> getConsumers() {
0:         synchronized (consumers) {
1:             return new ArrayList<Subscription>(consumers);
0:         }
0:     }
0: 
commit:9479de7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.BooleanExpression;
1: import org.apache.activemq.selector.SelectorParser;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public Queue(ActiveMQDestination destination, final UsageManager memoryManager, MessageStore store, DestinationStatistics parentStats,
0:             TaskRunnerFactory taskFactory) throws Exception {
0:         // Let the store know what usage manager we are using so that he can
0:         // flush messages to disk
0:         if (store != null) {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                 public void finished() {
/////////////////////////////////////////////////////////////////////////
0:                     }
0:                     catch (IOException e) {
0:         }
0:         finally {
/////////////////////////////////////////////////////////////////////////
0: 
0:                     // now lets dispatch from the copy of the collection to
0:                     // avoid deadlocks
/////////////////////////////////////////////////////////////////////////
0:         }
0:         finally {
/////////////////////////////////////////////////////////////////////////
0:             }
0:             else {
0:                 usageManager.waitForSpace();
0:             }
/////////////////////////////////////////////////////////////////////////
0:             }
0:             else {
0:         }
0:         finally {
/////////////////////////////////////////////////////////////////////////
0:             // the original ack may be a ranged ack, but we are trying to delete
0:             // a specific
0:             if (ack.getMessageCount() > 0) {
/////////////////////////////////////////////////////////////////////////
0:         return "Queue: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size() + ", memory=" + usageManager.getPercentUsage()
0:                 + "%, size=" + size + ", in flight groups=" + messageGroupOwners;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         }
0:         finally {
/////////////////////////////////////////////////////////////////////////
0:                     }
0:                     finally {
0:                 }
0:                 catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         }
0:                         finally {
0:                 }
0:                 catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
0:             ConnectionContext c = createConnectionContext();
0: 
0:                     if (r.lock(LockOwner.HIGH_PRIORITY_LOCK_OWNER)) {
/////////////////////////////////////////////////////////////////////////
0:                 }
0:                 catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Removes the message matching the given messageId
1:      */
1:     public boolean removeMessage(String messageId) throws Exception {
1:         return removeMatchingMessages(createMessageIdFilter(messageId), 1) > 0;
0:     }
0: 
1:     /**
1:      * Removes the messages matching the given selector
0:      * 
1:      * @return the number of messages removed
1:      */
1:     public int removeMatchingMessages(String selector) throws Exception {
1:         return removeMatchingMessages(selector, -1);
0:     }
0:     
1:     /**
0:      * Removes the messages matching the given selector up to the maximum number of matched messages
0:      * 
1:      * @return the number of messages removed
1:      */
1:     public int removeMatchingMessages(String selector, int maximumMessages) throws Exception {
1:         return removeMatchingMessages(createSelectorFilter(selector), maximumMessages);
0:     }
0: 
1:     /**
0:      * Removes the messages matching the given filter up to the maximum number of matched messages
0:      * 
1:      * @return the number of messages removed
1:      */
1:     public int removeMatchingMessages(MessageReferenceFilter filter, int maximumMessages) throws Exception {
0:         int counter = 0;
0:             ConnectionContext c = createConnectionContext();
0:                 IndirectMessageReference r = (IndirectMessageReference) iter.next();
0:                 if (filter.evaluate(c, r)) {
0:                     // We should only delete messages that can be locked.
0:                     if (lockMessage(r)) {
0:                         removeMessage(c, r);
0:                         if (++counter >= maximumMessages && maximumMessages > 0) {
0:                             break;
0:                         }
0:         return counter;
0:     }
0: 
1:     /**
1:      * Copies the message matching the given messageId
1:      */
0:     public boolean copyMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest) throws Exception {
1:         return copyMatchingMessages(context, createMessageIdFilter(messageId), dest, 1) > 0;
0:     }
0:     
1:     /**
1:      * Copies the messages matching the given selector
0:      * 
1:      * @return the number of messages copied
1:      */
0:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest) throws Exception {
1:         return copyMatchingMessagesTo(context, selector, dest, -1);
0:     }
0:     
1:     /**
0:      * Copies the messages matching the given selector up to the maximum number of matched messages
0:      * 
1:      * @return the number of messages copied
1:      */
0:     public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest, int maximumMessages) throws Exception {
1:         return copyMatchingMessages(context, createSelectorFilter(selector), dest, maximumMessages);
0:     }
0: 
1:     /**
0:      * Copies the messages matching the given filter up to the maximum number of matched messages
0:      * 
1:      * @return the number of messages copied
1:      */
0:     public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {
0:         int counter = 0;
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 MessageReference r = (MessageReference) iter.next();
1:                 if (filter.evaluate(context, r)) {
0:                     r.incrementReferenceCount();
0:                     try {
0:                         Message m = r.getMessage();
0:                         BrokerSupport.resend(context, m, dest);
0:                         if (++counter >= maximumMessages && maximumMessages > 0) {
0:                             break;
0:                         }
0:                     }
0:                     finally {
0:                         r.decrementReferenceCount();
0:                     }
0:                 }
0:             }
0:         }
0:         return counter;
0:     }
0: 
1:     /**
1:      * Moves the message matching the given messageId
1:      */
0:     public boolean moveMessageTo(ConnectionContext context, String messageId, ActiveMQDestination dest) throws Exception {
1:         return moveMatchingMessagesTo(context, createMessageIdFilter(messageId), dest, 1) > 0;
0:     }
0:     
1:     /**
1:      * Moves the messages matching the given selector
0:      * 
1:      * @return the number of messages removed
1:      */
0:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest) throws Exception {
0:         return moveMatchingMessagesTo(context, selector, dest, -1);
0:     }
0:     
1:     /**
0:      * Moves the messages matching the given selector up to the maximum number of matched messages
1:      */
0:     public int moveMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest, int maximumMessages) throws Exception {
1:         return moveMatchingMessagesTo(context, createSelectorFilter(selector), dest, maximumMessages);
0:     }
0: 
1:     /**
0:      * Moves the messages matching the given filter up to the maximum number of matched messages
1:      */
0:     public int moveMatchingMessagesTo(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {
0:         int counter = 0;
0:         synchronized (messages) {
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 IndirectMessageReference r = (IndirectMessageReference) iter.next();
1:                 if (filter.evaluate(context, r)) {
1:                     // We should only move messages that can be locked.
0:                     if (lockMessage(r)) {
0:                         r.incrementReferenceCount();
0:                         try {
0:                             Message m = r.getMessage();
0:                             BrokerSupport.resend(context, m, dest);
0:                             removeMessage(context, r);
0:                             if (++counter >= maximumMessages && maximumMessages > 0) {
0:                                 break;
0:                             }
0:                         }
0:                         finally {
0:                             r.decrementReferenceCount();
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         return counter;
0:     }
0: 
1:     protected MessageReferenceFilter createMessageIdFilter(final String messageId) {
1:         return new MessageReferenceFilter() {
1:             public boolean evaluate(ConnectionContext context, MessageReference r) {
1:                 return messageId.equals(r.getMessageId().toString());
0:             }
0:         };
0:     }
0:     
1:     protected MessageReferenceFilter createSelectorFilter(String selector) throws InvalidSelectorException {
0:         final BooleanExpression selectorExpression = new SelectorParser().parse(selector);
0: 
1:         return new MessageReferenceFilter() {
1:             public boolean evaluate(ConnectionContext context, MessageReference r) throws JMSException {
1:                 MessageEvaluationContext messageEvaluationContext = context.getMessageEvaluationContext();
0:                 
1:                 messageEvaluationContext.setMessageReference(r);
1:                 if (messageEvaluationContext.getDestination() == null) {
1:                     messageEvaluationContext.setDestination(getActiveMQDestination());
0:                 }
0:                 
1:                 return selectorExpression.matches(messageEvaluationContext);
0:             }
0:         };
0:     }
0: 
0:     protected void removeMessage(ConnectionContext c, IndirectMessageReference r) throws IOException {
0:         MessageAck ack = new MessageAck();
0:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:         ack.setDestination(destination);
0:         ack.setMessageID(r.getMessageId());
0:         acknowledge(c, null, ack, r);
0:         r.drop();
0:         dropEvent();
0:     }
0: 
0:     protected boolean lockMessage(IndirectMessageReference r) {
0:         return r.lock(LockOwner.HIGH_PRIORITY_LOCK_OWNER);
0:     }
0: 
0:     protected ConnectionContext createConnectionContext() {
0:         ConnectionContext answer = new ConnectionContext();
0:         answer.getMessageEvaluationContext().setDestination(getActiveMQDestination());
0:         return answer;
commit:b54ce41
/////////////////////////////////////////////////////////////////////////
0:         dropEvent(false);
0:     }
0: 
0:     public void dropEvent(boolean skipGc) {
0:             if (!skipGc && garbageSize > garbageSizeBeforeCollection) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         dropEvent(true);
0: 
0:             // Run gc() by hand. Had we run it in the loop it could be
0:             // quite expensive.
0:             gc();
commit:aa3b9ac
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl()) {
0:             if (usageManager.isSendFailIfNoSpace() && usageManager.isFull()) {
0:                 throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached");
0:             } else {
0:             }    
0:         }
/////////////////////////////////////////////////////////////////////////
commit:e7e15b5
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory;
1: import org.apache.activemq.broker.region.group.MessageGroupMapFactory;
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private MessageGroupMapFactory messageGroupMapFactory = new MessageGroupHashBucketFactory();
0:     
/////////////////////////////////////////////////////////////////////////
1:             messageGroupOwners = getMessageGroupMapFactory().createMessageGroupMap();
/////////////////////////////////////////////////////////////////////////
1:     public MessageGroupMapFactory getMessageGroupMapFactory() {
1:         return messageGroupMapFactory;
1:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory) {
1:         this.messageGroupMapFactory = messageGroupMapFactory;
0: 
commit:44493e4
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void resetStatistics() {
0:         getDestinationStatistics().reset();
0:     }
0:     public String getName() {
0:         return getActiveMQDestination().getPhysicalName();
0:     }
0: 
0:     public long getEnqueueCount() {
0:         return getDestinationStatistics().getEnqueues().getCount();
0:     }
0: 
0:     public long getDequeueCount() {
0:         return getDestinationStatistics().getDequeues().getCount();
0:     }
0: 
0:     public long getConsumerCount() {
0:         return getDestinationStatistics().getConsumers().getCount();
0:     }
0: 
0:     public long getQueueSize() {
0:         return getDestinationStatistics().getMessages().getCount();
0:     }
0: 
0:     public long getMessagesCached() {
0:         return getDestinationStatistics().getMessagesCached().getCount();
0:     }
0: 
0:     public int getMemoryPercentageUsed() {
0:         return getUsageManager().getPercentUsage();
0:     }
0: 
0:     public long getMemoryLimit() {
0:         return getUsageManager().getLimit();
0:     }
0: 
0:     public void setMemoryLimit(long limit) {
0:         getUsageManager().setLimit(limit);
0:     }
0:     
0:     
commit:d680ba1
/////////////////////////////////////////////////////////////////////////
0:     public String getDestination() {
0:         return destination.getPhysicalName();
0:     }
0:     
commit:217e0c8
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList messages = new LinkedList();
/////////////////////////////////////////////////////////////////////////
0:             size = messages.size();
commit:2ed21ce
/////////////////////////////////////////////////////////////////////////
0:                     synchronized (messages) {
0:                         messages.add(reference);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:         int size = 0;
0:         synchronized (messages) {
0:             size = message.size();
0:         }
0:                 + ", memory=" + usageManager.getPercentUsage() + "%, size=" + size + ", in flight groups="
commit:dba97b7
/////////////////////////////////////////////////////////////////////////
0:             if (!sub.getConsumerInfo().isBrowser()) {
0:                 MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:                 try {
0:                     msgContext.setDestination(destination);
0:                     // lets copy the messages to dispatch to avoid deadlock
0:                     List messagesToDispatch = new ArrayList();
0:                     synchronized (messages) {
/////////////////////////////////////////////////////////////////////////
0:                             if (node.getLockOwner() == sub || wasExclusiveOwner || (groupID != null && ownedGroups.contains(groupID))) {
0:                                 messagesToDispatch.add(node);
0:                     }
0:                     
0:                     // now lets dispatch from the copy of the collection to avoid deadlocks
0:                     for (Iterator iter = messagesToDispatch.iterator(); iter.hasNext();) {
0:                         IndirectMessageReference node = (IndirectMessageReference) iter.next();
0:                         node.incrementRedeliveryCounter();
0:                         node.unlock();
0:                         msgContext.setMessageReference(node);
0:                         dispatchPolicy.dispatch(context, node, msgContext, consumers);
0:                 finally {
0:                     msgContext.clear();
0:                 }
commit:d7f9146
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.group.MessageGroupHashBucket;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private MessageGroupMap messageGroupOwners;
0:     private int messageGroupHashBucketCount = 1024;
/////////////////////////////////////////////////////////////////////////
0:             MessageGroupSet ownedGroups = getMessageGroupOwners().removeConsumer(consumerId);
/////////////////////////////////////////////////////////////////////////
1:         if (messageGroupOwners == null) {
0:             messageGroupOwners = new MessageGroupHashBucket(messageGroupHashBucketCount );
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public int getMessageGroupHashBucketCount() {
0:         return messageGroupHashBucketCount;
0:     }
0: 
0:     public void setMessageGroupHashBucketCount(int messageGroupHashBucketCount) {
0:         this.messageGroupHashBucketCount = messageGroupHashBucketCount;
0:     }
0:     
0: 
commit:e1d4780
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
1: import org.apache.activemq.broker.region.group.MessageGroupMap;
0: import org.apache.activemq.broker.region.group.MessageGroupSet;
0: import org.apache.activemq.broker.region.group.SimpleMessageGroupMap;
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private final MessageGroupMap messageGroupOwners = new SimpleMessageGroupMap();
/////////////////////////////////////////////////////////////////////////
0:             MessageGroupSet ownedGroups = messageGroupOwners.removeConsumer(consumerId);
/////////////////////////////////////////////////////////////////////////
0:                 + "%, size=" + messages.size() + ", in flight groups=" + messageGroupOwners;
/////////////////////////////////////////////////////////////////////////
1:     public MessageGroupMap getMessageGroupOwners() {
commit:88203ae
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
0: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0:     private DeadLetterStrategy deadLetterStrategy = new SharedDeadLetterStrategy();
/////////////////////////////////////////////////////////////////////////
0:     public DeadLetterStrategy getDeadLetterStrategy() {
0:         return deadLetterStrategy;
0:     }
0: 
0:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
0:         this.deadLetterStrategy = deadLetterStrategy;
0:     }
0: 
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:b743552
/////////////////////////////////////////////////////////////////////////
0:                 while( !usageManager.waitForSpace(1000) ) {
0:                     if( context.getStopping().get() )
0:                         throw new IOException("Connection closed, send aborted.");
0:                 }
commit:49ea0ed
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl() && !context.isNetworkConnection()) {
commit:ccf3f3c
/////////////////////////////////////////////////////////////////////////
0:         //let's copy the enabled property from the parent DestinationStatistics
0:         this.destinationStatistics.setEnabled(parentStats.isEnabled());
commit:36de58b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             destinationStatistics.getEnqueues().increment();
0: 	    destinationStatistics.getMessages().increment();
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:a8f4f69
/////////////////////////////////////////////////////////////////////////
0:     protected int highestSubscriptionPriority = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
0:                 }
0: 
0:                 if (sub.getConsumerInfo().getPriority() > highestSubscriptionPriority) {
0:                     highestSubscriptionPriority = sub.getConsumerInfo().getPriority();
0:                 }
0:             //highestSubscriptionPriority = calcHighestSubscriptionPriority();
commit:8951023
/////////////////////////////////////////////////////////////////////////
0:                 if (sub.getConsumerInfo().isExclusive()) {
0:                     // Add to front of list to ensure that an exclusive consumer gets all messages
0:                     // before non-exclusive consumers
0:                     consumers.add(0, sub);
0:                 } else {
0:                     consumers.add(sub);
============================================================================