1:8b23e07: /*
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:734fb7d:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:734fb7d:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
2:7d1e6bc:  */
1:7d1e6bc: package org.apache.activemq.broker.region.cursors;
1:0f1ef01: 
1:7d1e6bc: import java.io.IOException;
1:8b23e07: import java.util.ArrayList;
1:4eef609: import java.util.Iterator;
1:9359e9f: import java.util.LinkedList;
1:8b23e07: import java.util.List;
1:a110604: import java.util.concurrent.atomic.AtomicBoolean;
1:0c0be94: import java.util.concurrent.atomic.AtomicLong;
1:8b23e07: 
1:23cda2d: import org.apache.activemq.broker.Broker;
1:23cda2d: import org.apache.activemq.broker.ConnectionContext;
1:7d1e6bc: import org.apache.activemq.broker.region.Destination;
1:e6a9ae2: import org.apache.activemq.broker.region.IndirectMessageReference;
1:7d1e6bc: import org.apache.activemq.broker.region.MessageReference;
1:393a861: import org.apache.activemq.broker.region.QueueMessageReference;
1:7d1e6bc: import org.apache.activemq.command.Message;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:7d1e6bc: import org.apache.activemq.openwire.OpenWireFormat;
1:d5dd937: import org.apache.activemq.store.PList;
1:d5dd937: import org.apache.activemq.store.PListEntry;
1:8b23e07: import org.apache.activemq.store.PListStore;
1:2b063ef: import org.apache.activemq.usage.SystemUsage;
1:6d8e2c5: import org.apache.activemq.usage.Usage;
1:6d8e2c5: import org.apache.activemq.usage.UsageListener;
1:8b23e07: import org.apache.activemq.util.ByteSequence;
1:ee55abb: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:0f1ef01: 
3:7d1e6bc: /**
1:230a86c:  * persist pending messages pending message (messages awaiting dispatch to a
1:230a86c:  * consumer) cursor
1:7d1e6bc:  */
1:230a86c: public class FilePendingMessageCursor extends AbstractPendingMessageCursor implements UsageListener {
1:8b23e07: 
1:8bf987b:     static final Logger LOG = LoggerFactory.getLogger(FilePendingMessageCursor.class);
1:8b23e07: 
1:fc00993:     private static final AtomicLong NAME_COUNT = new AtomicLong();
1:8b23e07: 
1:23cda2d:     protected Broker broker;
1:ee55abb:     private final PListStore store;
1:ee55abb:     private final String name;
1:3557361:     private PendingList memoryList;
1:ee55abb:     private PList diskList;
1:23cda2d:     private Iterator<MessageReference> iter;
1:7d1e6bc:     private Destination regionDestination;
1:0cda6b0:     private boolean iterating;
1:a110604:     private boolean flushRequired;
1:ee55abb:     private final AtomicBoolean started = new AtomicBoolean();
1:ee55abb:     private final WireFormat wireFormat = new OpenWireFormat();
1:8b23e07: 
1:7d1e6bc:     /**
1:ee55abb:      * @param broker
1:7d1e6bc:      * @param name
1:aad7e73:      * @param prioritizedMessages
1:7d1e6bc:      */
1:00879cf:     public FilePendingMessageCursor(Broker broker, String name, boolean prioritizedMessages) {
1:00879cf:         super(prioritizedMessages);
1:3557361:         if (this.prioritizedMessages) {
1:3557361:             this.memoryList = new PrioritizedPendingList();
1:3557361:         } else {
1:3557361:             this.memoryList = new OrderedPendingList();
1:3557361:         }
1:23cda2d:         this.broker = broker;
1:ee55abb:         // the store can be null if the BrokerService has persistence
1:ee55abb:         // turned off
1:ee55abb:         this.store = broker.getTempDataStore();
1:fc00993:         this.name = NAME_COUNT.incrementAndGet() + "_" + name;
1:ee55abb:     }
1:8b23e07: 
1:734fb7d:     @Override
1:1ee0017:     public void start() throws Exception {
1:230a86c:         if (started.compareAndSet(false, true)) {
1:ec9975c:             if( this.broker != null) {
1:ec9975c:                 wireFormat.setVersion(this.broker.getBrokerService().getStoreOpenWireVersion());
1:ec9975c:             }
1:1ee0017:             super.start();
1:6d8e2c5:             if (systemUsage != null) {
1:6d8e2c5:                 systemUsage.getMemoryUsage().addUsageListener(this);
1:ee55abb:             }
1:07cb724:         }
1:8ab5f45:     }
1:ae7de6c: 
1:734fb7d:     @Override
1:1ee0017:     public void stop() throws Exception {
1:230a86c:         if (started.compareAndSet(true, false)) {
1:1ee0017:             super.stop();
1:6d8e2c5:             if (systemUsage != null) {
1:6d8e2c5:                 systemUsage.getMemoryUsage().removeUsageListener(this);
1:8ab5f45:             }
1:8ab5f45:         }
1:23cda2d:     }
1:fc00993: 
1:0f1ef01:     /**
1:7d1e6bc:      * @return true if there are no pending messages
1:0f1ef01:      */
1:00879cf:     @Override
1:230a86c:     public synchronized boolean isEmpty() {
1:ee55abb:         if (memoryList.isEmpty() && isDiskListEmpty()) {
1:0f1ef01:             return true;
1:0f1ef01:         }
1:3557361:         for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:3557361:             MessageReference node = iterator.next();
1:ee55abb:             if (node == QueueMessageReference.NULL_MESSAGE) {
1:0f1ef01:                 continue;
1:8ab5f45:             }
1:0f1ef01:             if (!node.isDropped()) {
1:f42c91f:                 return false;
1:8ab5f45:             }
1:0f1ef01:             // We can remove dropped references.
1:5eb274d:             iterator.remove();
1:07cb724:         }
1:393a861:         return isDiskListEmpty();
1:23cda2d:     }
1:ae7de6c: 
1:7d1e6bc:     /**
1:7d1e6bc:      * reset the cursor
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized void reset() {
1:230a86c:         iterating = true;
1:0f1ef01:         last = null;
1:ee55abb:         if (isDiskListEmpty()) {
1:ee55abb:             this.iter = this.memoryList.iterator();
1:ee55abb:         } else {
1:ee55abb:             this.iter = new DiskIterator();
1:ee55abb:         }
1:0f1ef01:     }
1:ee55abb: 
1:ee55abb:     @Override
1:230a86c:     public synchronized void release() {
1:230a86c:         iterating = false;
1:bf59b7d:         if (iter instanceof DiskIterator) {
1:bf59b7d:            ((DiskIterator)iter).release();
1:bf59b7d:         };
1:230a86c:         if (flushRequired) {
1:230a86c:             flushRequired = false;
1:2b10259:             if (!hasSpace()) {
1:2b10259:                 flushToDisk();
1:2b10259:             }
1:8ab5f45:         }
1:109cbe0:         // ensure any memory ref is released
1:109cbe0:         iter = null;
1:8ab5f45:     }
1:ee55abb: 
1:ee55abb:     @Override
1:0f1ef01:     public synchronized void destroy() throws Exception {
1:0f1ef01:         stop();
1:933eb2f:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext();) {
1:30a9fe1:             MessageReference node = i.next();
1:e6a9ae2:             node.decrementReferenceCount();
1:0f1ef01:         }
1:0f1ef01:         memoryList.clear();
1:5eb274d:         destroyDiskList();
1:5eb274d:     }
1:5eb274d: 
1:07cb724:     private void destroyDiskList() throws Exception {
1:2b10259:         if (diskList != null) {
1:ee55abb:             store.removePList(name);
1:2b10259:             diskList = null;
1:ee55abb:         }
1:8ab5f45:     }
1:ee55abb: 
1:ee55abb:     @Override
1:933eb2f:     public synchronized LinkedList<MessageReference> pageInList(int maxItems) {
1:933eb2f:         LinkedList<MessageReference> result = new LinkedList<MessageReference>();
1:230a86c:         int count = 0;
1:933eb2f:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext() && count < maxItems;) {
1:ee55abb:             MessageReference ref = i.next();
1:5619cd0:             ref.incrementReferenceCount();
1:ee55abb:             result.add(ref);
1:0f1ef01:             count++;
1:0f1ef01:         }
1:230a86c:         if (count < maxItems && !isDiskListEmpty()) {
1:ee55abb:             for (Iterator<MessageReference> i = new DiskIterator(); i.hasNext() && count < maxItems;) {
1:ee55abb:                 Message message = (Message) i.next();
1:0f1ef01:                 message.setRegionDestination(regionDestination);
1:0f1ef01:                 message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
1:5619cd0:                 message.incrementReferenceCount();
1:0f1ef01:                 result.add(message);
1:8ab5f45:                 count++;
1:8ab5f45:             }
1:8ab5f45:         }
1:8ab5f45:         return result;
1:23cda2d:     }
1:ee55abb: 
1:7d1e6bc:     /**
1:0f1ef01:      * add message to await dispatch
1:734fb7d:      *
1:0f1ef01:      * @param node
1:734fb7d:      * @throws Exception
1:7d1e6bc:      */
1:ee55abb:     @Override
1:f42c91f:     public synchronized boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {
1:23cda2d:         if (!node.isExpired()) {
1:230a86c:             try {
1:9a8f6e4:                 regionDestination = (Destination) node.getMessage().getRegionDestination();
1:0f1ef01:                 if (isDiskListEmpty()) {
1:ee55abb:                     if (hasSpace() || this.store == null) {
1:3557361:                         memoryList.addMessageLast(node);
1:0f1ef01:                         node.incrementReferenceCount();
1:cb96783:                         setCacheEnabled(true);
1:f42c91f:                         return true;
1:f42c91f:                     }
1:ee55abb:                 }
1:0f1ef01:                 if (!hasSpace()) {
1:8ab5f45:                     if (isDiskListEmpty()) {
1:2b10259:                         expireOldMessages();
1:0f1ef01:                         if (hasSpace()) {
1:3557361:                             memoryList.addMessageLast(node);
1:8ab5f45:                             node.incrementReferenceCount();
1:f42c91f:                             return true;
1:230a86c:                         } else {
1:0f1ef01:                             flushToDisk();
1:0f1ef01:                         }
1:0f1ef01:                     }
1:8ab5f45:                 }
1:f42c91f:                 if (systemUsage.getTempUsage().waitForSpace(maxWaitTime)) {
1:f42c91f:                     ByteSequence bs = getByteSequence(node.getMessage());
1:f42c91f:                     getDiskList().addLast(node.getMessageId().toString(), bs);
1:f42c91f:                     return true;
1:f42c91f:                 }
1:f42c91f:                 return false;
1:734fb7d: 
1:23cda2d:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Caught an Exception adding a message: {} first to FilePendingMessageCursor ", node, e);
1:23cda2d:                 throw new RuntimeException(e);
1:8ab5f45:             }
1:ee55abb:         } else {
1:e6a9ae2:             discardExpiredMessage(node);
1:8ab5f45:         }
1:cee683f:         //message expired
1:cee683f:         return true;
1:8ab5f45:     }
1:f42c91f: 
1:7d1e6bc:     /**
2:7d1e6bc:      * add message to await dispatch
1:734fb7d:      *
2:7d1e6bc:      * @param node
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized void addMessageFirst(MessageReference node) {
1:0f1ef01:         if (!node.isExpired()) {
1:230a86c:             try {
1:9a8f6e4:                 regionDestination = (Destination) node.getMessage().getRegionDestination();
1:0f1ef01:                 if (isDiskListEmpty()) {
1:0f1ef01:                     if (hasSpace()) {
1:3557361:                         memoryList.addMessageFirst(node);
1:0f1ef01:                         node.incrementReferenceCount();
1:cb96783:                         setCacheEnabled(true);
1:0f1ef01:                         return;
1:0f1ef01:                     }
1:0f1ef01:                 }
1:0f1ef01:                 if (!hasSpace()) {
1:0f1ef01:                     if (isDiskListEmpty()) {
1:0f1ef01:                         expireOldMessages();
1:0f1ef01:                         if (hasSpace()) {
1:3557361:                             memoryList.addMessageFirst(node);
1:0f1ef01:                             node.incrementReferenceCount();
2:0f1ef01:                             return;
1:230a86c:                         } else {
1:0f1ef01:                             flushToDisk();
1:0f1ef01:                         }
1:0f1ef01:                     }
1:8ab5f45:                 }
1:2b0024c:                 systemUsage.getTempUsage().waitForSpace();
1:0f1ef01:                 node.decrementReferenceCount();
1:ee55abb:                 ByteSequence bs = getByteSequence(node.getMessage());
1:32e63dc:                 Object locator = getDiskList().addFirst(node.getMessageId().toString(), bs);
1:32e63dc:                 node.getMessageId().setPlistLocator(locator);
1:ee55abb: 
1:0f1ef01:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Caught an Exception adding a message: {} first to FilePendingMessageCursor ", node, e);
1:0f1ef01:                 throw new RuntimeException(e);
1:0f1ef01:             }
1:0f1ef01:         } else {
1:e6a9ae2:             discardExpiredMessage(node);
1:0f1ef01:         }
1:0f1ef01:     }
1:ee55abb: 
1:7d1e6bc:     /**
1:7d1e6bc:      * @return true if there pending messages to dispatch
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized boolean hasNext() {
1:0f1ef01:         return iter.hasNext();
1:8ab5f45:     }
1:07cb724: 
1:7d1e6bc:     /**
1:7d1e6bc:      * @return the next pending message
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized MessageReference next() {
1:fe31092:         MessageReference reference = iter.next();
1:fe31092:         last = reference;
1:230a86c:         if (!isDiskListEmpty()) {
1:0f1ef01:             // got from disk
1:fe31092:             reference.getMessage().setRegionDestination(regionDestination);
1:fe31092:             reference.getMessage().setMemoryUsage(this.getSystemUsage().getMemoryUsage());
1:5eb274d:         }
1:fe31092:         reference.incrementReferenceCount();
1:fe31092:         return reference;
1:8ab5f45:     }
1:0f1ef01: 
1:7d1e6bc:     /**
1:7d1e6bc:      * remove the message at the cursor position
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized void remove() {
1:0f1ef01:         iter.remove();
1:0f1ef01:         if (last != null) {
1:ee55abb:             last.decrementReferenceCount();
1:8ab5f45:         }
1:8ab5f45:     }
1:0f1ef01: 
1:9359e9f:     /**
1:9359e9f:      * @param node
1:9359e9f:      * @see org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor#remove(org.apache.activemq.broker.region.MessageReference)
1:9359e9f:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized void remove(MessageReference node) {
1:3557361:         if (memoryList.remove(node) != null) {
1:ee55abb:             node.decrementReferenceCount();
1:0f1ef01:         }
1:230a86c:         if (!isDiskListEmpty()) {
1:ee55abb:             try {
1:32e63dc:                 getDiskList().remove(node.getMessageId().getPlistLocator());
1:230a86c:             } catch (IOException e) {
1:ee55abb:                 throw new RuntimeException(e);
1:ee55abb:             }
1:ee55abb:         }
1:8ab5f45:     }
1:ee55abb: 
1:7d1e6bc:     /**
1:7d1e6bc:      * @return the number of pending messages
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized int size() {
1:2b10259:         return memoryList.size() + (isDiskListEmpty() ? 0 : (int)getDiskList().size());
1:8ab5f45:     }
1:0f1ef01: 
1:734fb7d:     @Override
1:734fb7d:     public synchronized long messageSize() {
1:d635a36:         return memoryList.messageSize() + (isDiskListEmpty() ? 0 : getDiskList().messageSize());
1:734fb7d:     }
1:734fb7d: 
1:7d1e6bc:     /**
1:7d1e6bc:      * clear all pending messages
1:7d1e6bc:      */
1:ee55abb:     @Override
1:230a86c:     public synchronized void clear() {
1:0f1ef01:         memoryList.clear();
1:230a86c:         if (!isDiskListEmpty()) {
1:ee55abb:             try {
1:ee55abb:                 getDiskList().destroy();
1:230a86c:             } catch (IOException e) {
1:ee55abb:                 throw new RuntimeException(e);
1:ee55abb:             }
1:8ab5f45:         }
1:ee55abb:         last = null;
1:8ab5f45:     }
1:8ab5f45: 
1:ee55abb:     @Override
1:230a86c:     public synchronized boolean isFull() {
1:7e13a81:         return super.isFull() || (!isDiskListEmpty() && systemUsage != null && systemUsage.getTempUsage().isFull());
1:ee55abb:     }
1:07cb724: 
1:ee55abb:     @Override
1:230a86c:     public boolean hasMessagesBufferedToDeliver() {
1:e5efc58:         return !isEmpty();
1:8ab5f45:     }
1:8ab5f45: 
1:ee55abb:     @Override
1:6d8e2c5:     public void setSystemUsage(SystemUsage usageManager) {
1:6d8e2c5:         super.setSystemUsage(usageManager);
1:8ab5f45:     }
1:23cda2d: 
1:734fb7d:     @Override
1:ee55abb:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
1:230a86c:         if (newPercentUsage >= getMemoryUsageHighWaterMark()) {
1:8b23e07:             List<MessageReference> expiredMessages = null;
1:230a86c:             synchronized (this) {
1:4f50d25:                 if (!flushRequired && size() != 0) {
1:2b10259:                     flushRequired =true;
1:230a86c:                     if (!iterating) {
1:8b23e07:                         expiredMessages = expireOldMessages();
1:2b10259:                         if (!hasSpace()) {
1:2b10259:                             flushToDisk();
1:230a86c:                             flushRequired = false;
1:2b10259:                         }
1:8ab5f45:                     }
1:8ab5f45:                 }
1:8ab5f45:             }
1:23cda2d: 
1:8b23e07:             if (expiredMessages != null) {
1:8b23e07:                 for (MessageReference node : expiredMessages) {
1:8b23e07:                     discardExpiredMessage(node);
1:8b23e07:                 }
1:8b23e07:             }
1:23cda2d:         }
1:23cda2d:     }
1:23cda2d: 
1:ee55abb:     @Override
1:36486fe:     public boolean isTransient() {
1:8ab5f45:         return true;
1:23cda2d:     }
1:23cda2d: 
1:8b23e07:     private synchronized List<MessageReference> expireOldMessages() {
1:8b23e07:         List<MessageReference> expired = new ArrayList<MessageReference>();
1:230a86c:         if (!memoryList.isEmpty()) {
1:0f1ef01:             for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:0f1ef01:                 MessageReference node = iterator.next();
1:0f1ef01:                 if (node.isExpired()) {
1:0f1ef01:                     node.decrementReferenceCount();
1:8b23e07:                     expired.add(node);
1:3557361:                     iterator.remove();
1:0f1ef01:                 }
1:8ab5f45:             }
1:8ab5f45:         }
1:8b23e07: 
1:8b23e07:         return expired;
1:8ab5f45:     }
1:0f1ef01: 
1:230a86c:     protected synchronized void flushToDisk() {
1:bf59b7d:         if (!memoryList.isEmpty() && store != null) {
1:2b10259:             long start = 0;
1:8b23e07:             if (LOG.isTraceEnabled()) {
1:2b10259:                 start = System.currentTimeMillis();
1:8b23e07:                 LOG.trace("{}, flushToDisk() mem list size: {} {}", new Object[] { name, memoryList.size(),
1:8b23e07:                     (systemUsage != null ? systemUsage.getMemoryUsage() : "") });
1:8b23e07:             }
1:3557361:             for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:3557361:                 MessageReference node = iterator.next();
1:0f1ef01:                 node.decrementReferenceCount();
1:ee55abb:                 ByteSequence bs;
1:ee55abb:                 try {
1:ee55abb:                     bs = getByteSequence(node.getMessage());
1:ee55abb:                     getDiskList().addLast(node.getMessageId().toString(), bs);
1:ee55abb:                 } catch (IOException e) {
1:ee55abb:                     LOG.error("Failed to write to disk list", e);
1:ee55abb:                     throw new RuntimeException(e);
1:2b10259:                 }
1:ee55abb: 
1:ee55abb:             }
1:0f1ef01:             memoryList.clear();
1:cb96783:             setCacheEnabled(false);
1:e1bbde7:             LOG.trace("{}, flushToDisk() done - {} ms {}", new Object[]{ name, (System.currentTimeMillis() - start), (systemUsage != null ? systemUsage.getMemoryUsage() : "") });
1:2b10259:         }
1:23cda2d:     }
1:23cda2d: 
1:230a86c:     protected boolean isDiskListEmpty() {
1:230a86c:         return diskList == null || diskList.isEmpty();
1:23cda2d:     }
1:23cda2d: 
1:d5dd937:     public PList getDiskList() {
1:230a86c:         if (diskList == null) {
1:230a86c:             try {
1:ee55abb:                 diskList = store.getPList(name);
1:ee55abb:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Caught an IO Exception getting the DiskList {}", name, e);
1:ee55abb:                 throw new RuntimeException(e);
1:23cda2d:             }
1:23cda2d:         }
1:9359e9f:         return diskList;
1:23cda2d:     }
1:ee55abb: 
1:e6a9ae2:     private void discardExpiredMessage(MessageReference reference) {
1:e1bbde7:         LOG.debug("Discarding expired message {}", reference);
1:6cc2c11:         if (reference.isExpired() && broker.isExpired(reference)) {
1:50d27e7:             ConnectionContext context = new ConnectionContext();
1:e6a9ae2:             context.setBroker(broker);
1:9a8f6e4:             ((Destination)reference.getRegionDestination()).messageExpired(context, null, new IndirectMessageReference(reference.getMessage()));
1:e6a9ae2:         }
4:23cda2d:     }
1:23cda2d: 
1:ee55abb:     protected ByteSequence getByteSequence(Message message) throws IOException {
1:ee55abb:         org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:ee55abb:         return new ByteSequence(packet.data, packet.offset, packet.length);
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     protected Message getMessage(ByteSequence bs) throws IOException {
1:ee55abb:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(bs.getData(), bs
1:ee55abb:                 .getOffset(), bs.getLength());
1:ee55abb:         return (Message) this.wireFormat.unmarshal(packet);
1:ee55abb: 
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     final class DiskIterator implements Iterator<MessageReference> {
1:bf59b7d:         private final PList.PListIterator iterator;
1:ee55abb:         DiskIterator() {
2:ee55abb:             try {
1:2b10259:                 iterator = getDiskList().iterator();
1:ee55abb:             } catch (Exception e) {
1:ee55abb:                 throw new RuntimeException(e);
1:ee55abb:             }
1:ee55abb:         }
1:ee55abb: 
1:ee55abb:         @Override
1:ee55abb:         public boolean hasNext() {
1:2b10259:             return iterator.hasNext();
1:ee55abb:         }
1:ee55abb: 
1:734fb7d:         @Override
1:ee55abb:         public MessageReference next() {
1:ee55abb:             try {
1:2b10259:                 PListEntry entry = iterator.next();
1:32e63dc:                 Message message = getMessage(entry.getByteSequence());
1:32e63dc:                 message.getMessageId().setPlistLocator(entry.getLocator());
1:32e63dc:                 return message;
1:230a86c:             } catch (IOException e) {
2:ee55abb:                 LOG.error("I/O error", e);
1:ee55abb:                 throw new RuntimeException(e);
1:ee55abb:             }
1:ee55abb:         }
1:ee55abb: 
1:ee55abb:         @Override
1:ee55abb:         public void remove() {
1:2b10259:             iterator.remove();
1:ee55abb:         }
1:ee55abb: 
1:bf59b7d:         public void release() {
1:bf59b7d:             iterator.release();
1:bf59b7d:         }
1:ee55abb:     }
1:ee55abb: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:50d27e7
/////////////////////////////////////////////////////////////////////////
1:             ConnectionContext context = new ConnectionContext();
commit:6cc2c11
/////////////////////////////////////////////////////////////////////////
1:         if (reference.isExpired() && broker.isExpired(reference)) {
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean addMessageLast(MessageReference node) throws Exception {
0:         return tryAddMessageLast(node, 0);
commit:a64976a
/////////////////////////////////////////////////////////////////////////
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:d635a36
/////////////////////////////////////////////////////////////////////////
1:         return memoryList.messageSize() + (isDiskListEmpty() ? 0 : getDiskList().messageSize());
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws Exception
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public synchronized long messageSize() {
0:         return memoryList.messageSize() + (isDiskListEmpty() ? 0 : (int)getDiskList().messageSize());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8b23e07
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PListStore;
1: import org.apache.activemq.util.ByteSequence;
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             List<MessageReference> expiredMessages = null;
1:                         expiredMessages = expireOldMessages();
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (expiredMessages != null) {
1:                 for (MessageReference node : expiredMessages) {
1:                     discardExpiredMessage(node);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private synchronized List<MessageReference> expireOldMessages() {
1:         List<MessageReference> expired = new ArrayList<MessageReference>();
1:                     expired.add(node);
1: 
1:         return expired;
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("{}, flushToDisk() mem list size: {} {}", new Object[] { name, memoryList.size(),
1:                     (systemUsage != null ? systemUsage.getMemoryUsage() : "") });
1:             }
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Caught an Exception adding a message: {} first to FilePendingMessageCursor ", node, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Caught an Exception adding a message: {} first to FilePendingMessageCursor ", node, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("{}, flushToDisk() mem list size: {} {}", new Object[]{ name, memoryList.size(), (systemUsage != null ? systemUsage.getMemoryUsage() : "") });
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("{}, flushToDisk() done - {} ms {}", new Object[]{ name, (System.currentTimeMillis() - start), (systemUsage != null ? systemUsage.getMemoryUsage() : "") });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Caught an IO Exception getting the DiskList {}", name, e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Discarding expired message {}", reference);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1:             if( this.broker != null) {
1:                 wireFormat.setVersion(this.broker.getBrokerService().getStoreOpenWireVersion());
1:             }
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
1:                 Object locator = getDiskList().addFirst(node.getMessageId().toString(), bs);
1:                 node.getMessageId().setPlistLocator(locator);
/////////////////////////////////////////////////////////////////////////
1:                 getDiskList().remove(node.getMessageId().getPlistLocator());
/////////////////////////////////////////////////////////////////////////
1:                 Message message = getMessage(entry.getByteSequence());
1:                 message.getMessageId().setPlistLocator(entry.getLocator());
1:                 return message;
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:                 regionDestination = (Destination) node.getMessage().getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                 regionDestination = (Destination) node.getMessage().getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:             ((Destination)reference.getRegionDestination()).messageExpired(context, null, new IndirectMessageReference(reference.getMessage()));
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PList;
0: import org.apache.activemq.store.PListStore;
1: import org.apache.activemq.store.PListEntry;
/////////////////////////////////////////////////////////////////////////
1:     public PList getDiskList() {
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ByteSequence;
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
1:     
1:     
commit:01ab56f
/////////////////////////////////////////////////////////////////////////
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
1:                 systemUsage.getTempUsage().waitForSpace();
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getTempUsage().waitForSpace();
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private LinkedList<MessageReference> memoryList = new LinkedList<MessageReference>();
0:     private ListContainer<MessageReference> diskList;
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized LinkedList<MessageReference> pageInList(int maxItems) {
1:         LinkedList<MessageReference> result = new LinkedList<MessageReference>();
1:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext() && count < maxItems;) {
0:             for (Iterator<MessageReference> i = getDiskList().iterator(); i.hasNext() && count < maxItems;) {
/////////////////////////////////////////////////////////////////////////
0:                 MessageReference node = memoryList.removeFirst();
/////////////////////////////////////////////////////////////////////////
0:     protected ListContainer<MessageReference> getDiskList() {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(FilePendingMessageCursor.class);
1:     private static final AtomicLong NAME_COUNT = new AtomicLong();
1:     
/////////////////////////////////////////////////////////////////////////
1:         this.name = NAME_COUNT.incrementAndGet() + "_" + name;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1:  * persist pending messages pending message (messages awaiting dispatch to a
1:  * consumer) cursor
1: public class FilePendingMessageCursor extends AbstractPendingMessageCursor implements UsageListener {
0:     static private final Log LOG = LogFactory.getLog(FilePendingMessageCursor.class);
0:     private LinkedList memoryList = new LinkedList();
0:     private Iterator iter;
0:     private AtomicBoolean started = new AtomicBoolean();
0:     public FilePendingMessageCursor(String name, Store store) {
0:         this.name = nameCount.incrementAndGet() + "_" + name;
0:         this.store = store;
0:     public void start() {
1:         if (started.compareAndSet(false, true)) {
0:             if (usageManager != null) {
0:     public void stop() {
1:         if (started.compareAndSet(true, false)) {
0:             if (usageManager != null) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isEmpty() {
0:         return memoryList.isEmpty() && isDiskListEmpty();
1:     public synchronized void reset() {
1:         iterating = true;
0:         iter = isDiskListEmpty() ? memoryList.iterator() : getDiskList().listIterator();
1:     public synchronized void release() {
1:         iterating = false;
1:         if (flushRequired) {
1:             flushRequired = false;
0:     public synchronized void destroy() {
0:         for (Iterator i = memoryList.iterator(); i.hasNext();) {
0:             Message node = (Message)i.next();
1:         if (!isDiskListEmpty()) {
0:     public synchronized LinkedList pageInList(int maxItems) {
0:         LinkedList result = new LinkedList();
1:         int count = 0;
0:         for (Iterator i = memoryList.iterator(); i.hasNext() && count < maxItems;) {
1:         if (count < maxItems && !isDiskListEmpty()) {
0:             for (Iterator i = getDiskList().iterator(); i.hasNext() && count < maxItems;) {
0:                 Message message = (Message)i.next();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageLast(MessageReference node) {
1:         try {
0:             regionDestination = node.getMessage().getRegionDestination();
0:             if (isSpaceInMemoryList()) {
1:             } else {
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addMessageFirst(MessageReference node) {
1:         try {
0:             regionDestination = node.getMessage().getRegionDestination();
0:             if (isSpaceInMemoryList()) {
1:             } else {
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean hasNext() {
1:     public synchronized MessageReference next() {
0:         Message message = (Message)iter.next();
1:         if (!isDiskListEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void remove() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void remove(MessageReference node) {
1:         if (!isDiskListEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized int size() {
0:         return memoryList.size() + (isDiskListEmpty() ? 0 : getDiskList().size());
1:     public synchronized void clear() {
0:         if (!isDiskListEmpty()) {
1:     public synchronized boolean isFull() {
1:     public boolean hasMessagesBufferedToDeliver() {
0:     public void setUsageManager(UsageManager usageManager) {
0:     public void onMemoryUseChanged(UsageManager memoryManager, int oldPercentUsage, int newPercentUsage) {
1:         if (newPercentUsage >= getMemoryUsageHighWaterMark()) {
1:             synchronized (this) {
0:                 flushRequired = true;
1:                 if (!iterating) {
1:                     flushRequired = false;
0:     protected boolean isSpaceInMemoryList() {
0:         return hasSpace() && isDiskListEmpty();
1:     protected synchronized void flushToDisk() {
1:         if (!memoryList.isEmpty()) {
0:             while (!memoryList.isEmpty()) {
0:                 MessageReference node = (MessageReference)memoryList.removeFirst();
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isDiskListEmpty() {
1:         return diskList == null || diskList.isEmpty();
0:     protected ListContainer getDiskList() {
1:         if (diskList == null) {
1:             try {
0:                 diskList = store.getListContainer(name, "TopicSubscription", true);
1:             } catch (IOException e) {
author:Gary Tully
-------------------------------------------------------------------------------
commit:30a9fe1
/////////////////////////////////////////////////////////////////////////
1:             MessageReference node = i.next();
commit:109cbe0
/////////////////////////////////////////////////////////////////////////
1:         // ensure any memory ref is released
1:         iter = null;
commit:3557361
/////////////////////////////////////////////////////////////////////////
1:     private PendingList memoryList;
/////////////////////////////////////////////////////////////////////////
1:         if (this.prioritizedMessages) {
1:             this.memoryList = new PrioritizedPendingList();
1:         } else {
1:             this.memoryList = new OrderedPendingList();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                         memoryList.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
1:                             memoryList.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
1:                         memoryList.addMessageFirst(node);
/////////////////////////////////////////////////////////////////////////
1:                             memoryList.addMessageFirst(node);
/////////////////////////////////////////////////////////////////////////
1:         if (memoryList.remove(node) != null) {
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:                 MessageReference node = iterator.next();
1:                     iterator.remove();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:                 MessageReference node = iterator.next();
commit:e6a9ae2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.IndirectMessageReference;
/////////////////////////////////////////////////////////////////////////
1:             discardExpiredMessage(node);
/////////////////////////////////////////////////////////////////////////
1:             discardExpiredMessage(node);
/////////////////////////////////////////////////////////////////////////
1:                     node.decrementReferenceCount();
0:                     discardExpiredMessage(node);
/////////////////////////////////////////////////////////////////////////
1:     private void discardExpiredMessage(MessageReference reference) {
0:             LOG.debug("Discarding expired message " + reference);
0:         if (broker.isExpired(reference)) {
0:             ConnectionContext context = new ConnectionContext(new NonCachedMessageEvaluationContext());
1:             context.setBroker(broker);
0:             reference.getRegionDestination().messageExpired(context, null, new IndirectMessageReference(reference.getMessage()));
1:         }
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
1:         if (iter instanceof DiskIterator) {
1:            ((DiskIterator)iter).release();
1:         };
/////////////////////////////////////////////////////////////////////////
1:         if (!memoryList.isEmpty() && store != null) {
/////////////////////////////////////////////////////////////////////////
1:         private final PList.PListIterator iterator;
/////////////////////////////////////////////////////////////////////////
1:         public void release() {
1:             iterator.release();
1:         }
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1:             if (!hasSpace()) {
1:                 flushToDisk();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (diskList != null) {
1:             diskList = null;
/////////////////////////////////////////////////////////////////////////
1:         return memoryList.size() + (isDiskListEmpty() ? 0 : (int)getDiskList().size());
/////////////////////////////////////////////////////////////////////////
0:                 if (!flushRequired) {
1:                     flushRequired =true;
0:                     if (!iterating) {
1:                         expireOldMessages();
1:                         if (!hasSpace()) {
1:                             flushToDisk();
0:                             flushRequired = false;
1:                         }
/////////////////////////////////////////////////////////////////////////
1:             long start = 0;
0:              if (LOG.isTraceEnabled()) {
1:                 start = System.currentTimeMillis();
0:                 LOG.trace("" + name + ", flushToDisk() mem list size: " +memoryList.size()  + " " +  (systemUsage != null ? systemUsage.getMemoryUsage() : "") );
1:              }
/////////////////////////////////////////////////////////////////////////
0:              if (LOG.isTraceEnabled()) {
0:                 LOG.trace("" + name + ", flushToDisk() done - " + (System.currentTimeMillis() - start) + "ms " + (systemUsage != null ? systemUsage.getMemoryUsage() : ""));
1:              }
/////////////////////////////////////////////////////////////////////////
0:         private final Iterator<PListEntry> iterator;
1:                 iterator = getDiskList().iterator();
1:             return iterator.hasNext();
1:                 PListEntry entry = iterator.next();
0:                 return getMessage(entry.getByteSequence());
/////////////////////////////////////////////////////////////////////////
1:             iterator.remove();
commit:7e13a81
/////////////////////////////////////////////////////////////////////////
1:         return super.isFull() || (!isDiskListEmpty() && systemUsage != null && systemUsage.getTempUsage().isFull());
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:         MessageReference reference = iter.next();
1:         last = reference;
1:             reference.getMessage().setRegionDestination(regionDestination);
1:             reference.getMessage().setMemoryUsage(this.getSystemUsage().getMemoryUsage());
1:         reference.incrementReferenceCount();
1:         return reference;
commit:27c1719
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(new ConnectionContext(new NonCachedMessageEvaluationContext()),
0:                 message, null);
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1:                         setCacheEnabled(true);
/////////////////////////////////////////////////////////////////////////
1:                         setCacheEnabled(true);
/////////////////////////////////////////////////////////////////////////
1:             setCacheEnabled(false);
commit:aad7e73
/////////////////////////////////////////////////////////////////////////
1:      * @param prioritizedMessages
/////////////////////////////////////////////////////////////////////////
0:                         cacheEnabled = true;
/////////////////////////////////////////////////////////////////////////
0:                         cacheEnabled = true;
/////////////////////////////////////////////////////////////////////////
0:             cacheEnabled = false;
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1:             ref.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
1:         message.incrementReferenceCount();
commit:9b260dc
/////////////////////////////////////////////////////////////////////////
commit:5eb274d
/////////////////////////////////////////////////////////////////////////
1:         destroyDiskList();
1:     }
1: 
0:     private void destroyDiskList() {
0:             Iterator<MessageReference> iterator = diskList.iterator();
0:             while (iterator.hasNext()) {
0:                 iterator.next();
1:                 iterator.remove();
1:             }
0:             diskList.clear();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Caught an IO Exception getting the DiskList " + name, e);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:4f50d25
/////////////////////////////////////////////////////////////////////////
1:                 if (!flushRequired && size() != 0) {
commit:625f5e3
/////////////////////////////////////////////////////////////////////////
0:         ConnectionContext ctx = new ConnectionContext(new NonCachedMessageEvaluationContext());
0:         ctx.setBroker(broker);
0:         broker.getRoot().sendToDeadLetterQueue(ctx, message, null);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     static final Logger LOG = LoggerFactory.getLogger(FilePendingMessageCursor.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:cee683f
/////////////////////////////////////////////////////////////////////////
1:         //message expired
1:         return true;
commit:00879cf
/////////////////////////////////////////////////////////////////////////
0:      * @param prioritizedMessages 
1:     public FilePendingMessageCursor(Broker broker, String name, boolean prioritizedMessages) {
1:         super(prioritizedMessages);
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:f42c91f
/////////////////////////////////////////////////////////////////////////
0:      * @throws Exception 
0:     public synchronized void addMessageLast(MessageReference node) throws Exception {
0:         tryAddMessageLast(node, 0);
1:     }
1:     
1:     public synchronized boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                         return true;
/////////////////////////////////////////////////////////////////////////
1:                             return true;
1:                 if (systemUsage.getTempUsage().waitForSpace(maxWaitTime)) {
1:                     ByteSequence bs = getByteSequence(node.getMessage());
1:                     getDiskList().addLast(node.getMessageId().toString(), bs);
1:                     return true;
1:                 }
1:                 return false;
/////////////////////////////////////////////////////////////////////////
1:         return false;
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.plist.PList;
0: import org.apache.activemq.store.kahadb.plist.PListEntry;
0: import org.apache.activemq.store.kahadb.plist.PListStore;
1: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.kahadb.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
0:     static final Log LOG = LogFactory.getLog(FilePendingMessageCursor.class);
1:     private final PListStore store;
1:     private final String name;
1:     private PList diskList;
1:     private final AtomicBoolean started = new AtomicBoolean();
1:     private final WireFormat wireFormat = new OpenWireFormat();
1:      * @param broker
0:     public FilePendingMessageCursor(Broker broker, String name) {
0:         this.useCache = false;
1:         // the store can be null if the BrokerService has persistence
1:         // turned off
1:         this.store = broker.getTempDataStore();
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         if (memoryList.isEmpty() && isDiskListEmpty()) {
1:             if (node == QueueMessageReference.NULL_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         if (isDiskListEmpty()) {
1:             this.iter = this.memoryList.iterator();
1:         } else {
1:             this.iter = new DiskIterator();
1:         }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:             Message node = (Message) i.next();
/////////////////////////////////////////////////////////////////////////
1:             store.removePList(name);
1:         }
1:     @Override
1:             MessageReference ref = i.next();
1:             result.add(ref);
1:             for (Iterator<MessageReference> i = new DiskIterator(); i.hasNext() && count < maxItems;) {
1:                 Message message = (Message) i.next();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                     if (hasSpace() || this.store == null) {
/////////////////////////////////////////////////////////////////////////
1:                 ByteSequence bs = getByteSequence(node.getMessage());
1:                 getDiskList().addLast(node.getMessageId().toString(), bs);
0:                 LOG.error("Caught an Exception adding a message: " + node + " first to FilePendingMessageCursor ", e);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                 ByteSequence bs = getByteSequence(node.getMessage());
0:                 getDiskList().addFirst(node.getMessageId().toString(), bs);
0:                 LOG.error("Caught an Exception adding a message: " + node + " first to FilePendingMessageCursor ", e);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         Message message = (Message) iter.next();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             last.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             node.decrementReferenceCount();
1:             try {
0:                 getDiskList().remove(node.getMessageId().toString());
1:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             try {
1:                 getDiskList().destroy();
0:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             }
1:         last = null;
1:     @Override
0:     public synchronized boolean isFull() {
0:         return super.isFull() || (systemUsage != null && systemUsage.getTempUsage().isFull());
1:     }
1:     @Override
1:     @Override
1:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                 }
1: 
1:                 ByteSequence bs;
1:                 try {
1:                     bs = getByteSequence(node.getMessage());
0:                     getDiskList().addLast(node.getMessageId().toString(), bs);
0:                 } catch (IOException e) {
1:                     LOG.error("Failed to write to disk list", e);
1:                     throw new RuntimeException(e);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected PList getDiskList() {
1:                 diskList = store.getPList(name);
1:             } catch (Exception e) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected ByteSequence getByteSequence(Message message) throws IOException {
1:         org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:         return new ByteSequence(packet.data, packet.offset, packet.length);
1:     }
1: 
1:     protected Message getMessage(ByteSequence bs) throws IOException {
1:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(bs.getData(), bs
1:                 .getOffset(), bs.getLength());
1:         return (Message) this.wireFormat.unmarshal(packet);
1: 
1:     }
1: 
1:     final class DiskIterator implements Iterator<MessageReference> {
0:         private PListEntry next = null;
0:         private PListEntry current = null;
0:         PList list;
1: 
1:         DiskIterator() {
1:             try {
0:                 this.list = getDiskList();
0:                 synchronized (this.list) {
0:                     this.current = this.list.getFirst();
0:                     this.next = this.current;
1:                 }
1:             } catch (Exception e) {
1:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
1:         public boolean hasNext() {
0:             return this.next != null;
1:         }
1: 
1:         public MessageReference next() {
0:             this.current = next;
1:             try {
0:                 ByteSequence bs = this.current.getByteSequence();
0:                 synchronized (this.list) {
0:                     this.current = this.list.refresh(this.current);
0:                     this.next = this.list.getNext(this.current);
1:                 }
0:                 return getMessage(bs);
0:             } catch (IOException e) {
1:                 LOG.error("I/O error", e);
1:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
1:         public void remove() {
1:             try {
0:                 synchronized (this.list) {
0:                     this.current = this.list.refresh(this.current);
0:                     this.list.remove(this.current);
1:                 }
1: 
0:             } catch (IOException e) {
1:                 LOG.error("I/O error", e);
1:                 throw new RuntimeException(e);
1:             }
1: 
1:         }
1: 
1:     }
commit:07cb724
/////////////////////////////////////////////////////////////////////////
1:     private void destroyDiskList() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         }   
0: 	    store.deleteListContainer(name, "TopicSubscription");
/////////////////////////////////////////////////////////////////////////
0: 	public synchronized boolean isFull() {
1: 
0: 		return super.isFull()
0: 				|| (systemUsage != null && systemUsage.getTempUsage().isFull());
1: 
1: 	}
commit:f2fc864
/////////////////////////////////////////////////////////////////////////
0:         this.useCache=false;
commit:0f1ef01
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isEmpty() {
0:         if(memoryList.isEmpty() && isDiskListEmpty()){
1:             return true;
1:         }
1:         for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
1:             MessageReference node = iterator.next();
0:             if (node== QueueMessageReference.NULL_MESSAGE){
1:                 continue;
1:             if (!node.isDropped()) {
0:                 return false;
1:             // We can remove dropped references.
0:             iterator.remove();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void reset() {
0:         iterating = true;
1:         last = null;
0:         iter = isDiskListEmpty() ? memoryList.iterator() : getDiskList().listIterator();
1:     }
1: 
0:     public synchronized void release() {
0:         iterating = false;
0:         if (flushRequired) {
0:             flushRequired = false;
1:             flushToDisk();
1:     public synchronized void destroy() throws Exception {
1:         stop();
0:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext();) {
0:             Message node = (Message)i.next();
1:             node.decrementReferenceCount();
1:         }
1:         memoryList.clear();
0:         if (!isDiskListEmpty()) {
0:             getDiskList().clear();
0:     public synchronized LinkedList<MessageReference> pageInList(int maxItems) {
0:         int count = 0;
0:         for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext() && count < maxItems;) {
0:             result.add(i.next());
1:             count++;
1:         }
0:         if (count < maxItems && !isDiskListEmpty()) {
0:             for (Iterator<MessageReference> i = getDiskList().iterator(); i.hasNext() && count < maxItems;) {
0:                 Message message = (Message)i.next();
1:                 message.setRegionDestination(regionDestination);
1:                 message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:                 message.incrementReferenceCount();
1:                 result.add(message);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageLast(MessageReference node) {
0:                 regionDestination = node.getMessage().getRegionDestination();
1:                 if (isDiskListEmpty()) {
0:                     if (hasSpace() || this.store==null) {
0:                         memoryList.add(node);
1:                         node.incrementReferenceCount();
1:                         return;
1:                 }
1:                 if (!hasSpace()) {
1:                         expireOldMessages();
1:                         if (hasSpace()) {
1:                         } else {
1:                             flushToDisk();
0:                 systemUsage.getTempUsage().waitForSpace();
0:                 getDiskList().add(node);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * add message to await dispatch
0:      * 
1:      * @param node
1:      */
0:     public synchronized void addMessageFirst(MessageReference node) {
1:         if (!node.isExpired()) {
0:             try {
0:                 regionDestination = node.getMessage().getRegionDestination();
1:                 if (isDiskListEmpty()) {
1:                     if (hasSpace()) {
0:                         memoryList.addFirst(node);
1:                         node.incrementReferenceCount();
1:                         return;
1:                     }
1:                 }
1:                 if (!hasSpace()) {
1:                     if (isDiskListEmpty()) {
0:                         expireOldMessages();
1:                         if (hasSpace()) {
0:                             memoryList.addFirst(node);
1:                             node.incrementReferenceCount();
1:                             return;
0:                         } else {
0:                             flushToDisk();
1:                         }
1:                     }
1:                 }
0:                 systemUsage.getTempUsage().waitForSpace();
1:                 node.decrementReferenceCount();
0:                 getDiskList().addFirst(node);
1: 
1:             } catch (Exception e) {
0:                 LOG.error("Caught an Exception adding a message: " + node
0:                         + " first to FilePendingMessageCursor ", e);
1:                 throw new RuntimeException(e);
1:             }
0:         } else {
0:             discard(node);
1:         }
1:     }
1: 
0:     public synchronized boolean hasNext() {
1:         return iter.hasNext();
0:     public synchronized MessageReference next() {
0:         Message message = (Message)iter.next();
0:         last = message;
0:         if (!isDiskListEmpty()) {
1:             // got from disk
0:             message.setRegionDestination(regionDestination);
0:             message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:             message.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void remove() {
1:         iter.remove();
1:         if (last != null) {
0:         	last.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void remove(MessageReference node) {
0:         if (memoryList.remove(node)) {
1:         	node.decrementReferenceCount();
1:         }
0:         if (!isDiskListEmpty()) {
0:             getDiskList().remove(node);
0:     public synchronized int size() {
0:         return memoryList.size() + (isDiskListEmpty() ? 0 : getDiskList().size());
0:     public synchronized void clear() {
1:         memoryList.clear();
0:         if (!isDiskListEmpty()) {
0:             getDiskList().clear();
0:         last=null;
0:     public synchronized boolean isFull() {
0:         // we always have space - as we can persist to disk
0:         return false;
/////////////////////////////////////////////////////////////////////////
0:             synchronized (this) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void expireOldMessages() {
0:         if (!memoryList.isEmpty()) {
0:             LinkedList<MessageReference> tmpList = new LinkedList<MessageReference>(this.memoryList);
0:             this.memoryList = new LinkedList<MessageReference>();
0:             while (!tmpList.isEmpty()) {
0:                 MessageReference node = tmpList.removeFirst();
1:                 if (node.isExpired()) {
0:                     discard(node);
0:                 }else {
0:                     memoryList.add(node);
1:                 }               
1: 
0:     protected synchronized void flushToDisk() {
1:        
0:         if (!memoryList.isEmpty()) {
0:             while (!memoryList.isEmpty()) {
0:                 MessageReference node = memoryList.removeFirst();
0:                 node.decrementReferenceCount();
0:                 getDiskList().addLast(node);
1:             memoryList.clear();
commit:8ab5f45
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
0:     private ReentrantLock lock = new ReentrantLock(true);
/////////////////////////////////////////////////////////////////////////
0:     public boolean isEmpty() {
0:         lock.lock();
0:         try {
0:             if(memoryList.isEmpty() && isDiskListEmpty()){
1:                 return true;
0:             for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
0:                 MessageReference node = iterator.next();
0:                 if (node== QueueMessageReference.NULL_MESSAGE){
0:                     continue;
1:                 }
0:                 if (!node.isDropped()) {
0:                     return false;
1:                 }
0:                 // We can remove dropped references.
0:                 iterator.remove();
0:         } finally {
0:             lock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     public void reset() {
0:         lock.lock();
0:         try {
0:             iterating = true;
0:             last = null;
0:             iter = isDiskListEmpty() ? memoryList.iterator() : getDiskList().listIterator();
0:         } finally {
0:             lock.unlock();
0:     public void release() {
0:         lock.lock();
0:         try {
0:             synchronized(this) {
0:                 iterating = false;
0:                 this.notifyAll();
1:             }
0:             if (flushRequired) {
0:                 flushRequired = false;
0:                 flushToDisk();
1:             }
0:         } finally {
0:             lock.unlock();
0:     public void destroy() throws Exception {
0:         lock.lock();
0:         try {
0:             stop();
0:             for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext();) {
0:                 Message node = (Message)i.next();
0:                 node.decrementReferenceCount();
1:             }
0:             memoryList.clear();
0:             if (!isDiskListEmpty()) {
0:                 getDiskList().clear();
1:             }
0:         } finally {
0:             lock.unlock();
1:         }
1:     }
1: 
0:     public LinkedList<MessageReference> pageInList(int maxItems) {
0:         LinkedList<MessageReference> result = new LinkedList<MessageReference>();
0:         lock.lock();
0:         try {
0:             for (Iterator<MessageReference> i = memoryList.iterator(); i.hasNext() && count < maxItems;) {
0:                 result.add(i.next());
0:             if (count < maxItems && !isDiskListEmpty()) {
0:                 for (Iterator<MessageReference> i = getDiskList().iterator(); i.hasNext() && count < maxItems;) {
0:                     Message message = (Message)i.next();
0:                     message.setRegionDestination(regionDestination);
0:                     message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:                     message.incrementReferenceCount();
0:                     result.add(message);
1:                     count++;
1:                 }
1:             }
0:         } finally {
0:             lock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     public void addMessageLast(MessageReference node) {
0:                 lock.lock();
0:                 try {
0:                     while (iterating) {
0:                         lock.unlock();
0:                         synchronized(this) {
0:                             try {
0:                                 this.wait();
0:                             } catch (InterruptedException ie) {}
1:                         }
0:                         lock.lock();
0:                     regionDestination = node.getMessage().getRegionDestination();
0:                         if (hasSpace() || this.store==null) {
0:                     if (!hasSpace()) {
1:                         if (isDiskListEmpty()) {
0:                             expireOldMessages();
0:                             if (hasSpace()) {
0:                                 memoryList.add(node);
1:                                 node.incrementReferenceCount();
0:                                 return;
0:                             } else {
0:                                 flushToDisk();
1:                             }
1:                         }
1:                     }
0:                     if (systemUsage.getTempUsage().isFull()) {
0:                         lock.unlock();
0:                         systemUsage.getTempUsage().waitForSpace();
0:                         lock.lock();
1:                     }
0:                     getDiskList().add(node);
0:                 } finally {
0:                     lock.unlock();
0:                         + " last to FilePendingMessageCursor ", e);
/////////////////////////////////////////////////////////////////////////
0:     public void addMessageFirst(MessageReference node) {
0:                 lock.lock();
0:                 try {
0:                     while (iterating) {
0:                         lock.unlock();
0:                         synchronized(this) {
0:                             try {
0:                                 this.wait();
0:                             } catch (InterruptedException ie) {}
1:                         }
0:                         lock.lock();
0:                     regionDestination = node.getMessage().getRegionDestination();
0:                     if (!hasSpace()) {
0:                         if (isDiskListEmpty()) {
0:                             expireOldMessages();
0:                             if (hasSpace()) {
0:                                 memoryList.addFirst(node);
0:                                 node.incrementReferenceCount();
0:                                 return;
0:                             } else {
0:                                 flushToDisk();
1:                             }
1:                         }
1:                     }
0:                     if (systemUsage.getTempUsage().isFull()) {
0:                         lock.unlock();
0:                         systemUsage.getTempUsage().waitForSpace();
0:                         lock.lock();
1:                     }
0:                     node.decrementReferenceCount();
0:                     getDiskList().addFirst(node);
0:                 } finally {
0:                     lock.unlock();
/////////////////////////////////////////////////////////////////////////
1:     
0:     public boolean hasNext() {
0:         boolean result;
0:         lock.lock();
0:         try {
0:             result = iter.hasNext();
0:         } finally {
0:             lock.unlock();
1:         }
1:         return result;
0:     public MessageReference next() {
0:         Message message;
0:         lock.lock();
0:         try {
0:             message = (Message)iter.next();
0:             last = message;
0:             if (!isDiskListEmpty()) {
0:                 // got from disk
0:                 message.setRegionDestination(regionDestination);
0:                 message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:                 message.incrementReferenceCount();
1:             }
0:         } finally {
0:             lock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     public void remove() {
0:         lock.lock();
0:         try {
0:             iter.remove();
0:             if (last != null) {
0:                 last.decrementReferenceCount();
1:             }
0:         } finally {
0:             lock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     public void remove(MessageReference node) {
0:         lock.lock();
0:         try {
0:             if (memoryList.remove(node)) {
0:                 node.decrementReferenceCount();
1:             }
0:             if (!isDiskListEmpty()) {
0:                 getDiskList().remove(node);
1:             }
0:         } finally {
0:             lock.unlock();
0:     public int size() {
0:         int result;
0:         lock.lock();
0:         try {
0:             result = memoryList.size() + (isDiskListEmpty() ? 0 : getDiskList().size());
0:         } finally {
0:             lock.unlock();
1:         }
0:         return result;
0:     public void clear() {
0:         lock.lock();
0:         try {
0:             memoryList.clear();
0:             if (!isDiskListEmpty()) {
0:                 getDiskList().clear();
1:             }
0:             last=null;
0:         } finally {
0:             lock.unlock();
0:     public boolean isFull() {
0:         boolean result;
0:         lock.lock();
0:         try {
0:             // we always have space - as we can persist to disk
0:             // TODO: not necessarily true.
0:             result = false;
0:         } finally {
0:             lock.unlock();
1:         }
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:             lock.lock();
0:             try {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
0:                 lock.unlock();
/////////////////////////////////////////////////////////////////////////
0:     protected void expireOldMessages() {
0:         lock.lock();
0:         try {
0:             if (!memoryList.isEmpty()) {
0:                 LinkedList<MessageReference> tmpList = new LinkedList<MessageReference>(this.memoryList);
0:                 this.memoryList = new LinkedList<MessageReference>();
0:                 while (!tmpList.isEmpty()) {
0:                     MessageReference node = tmpList.removeFirst();
0:                     if (node.isExpired()) {
0:                         discard(node);
0:                     }else {
0:                         memoryList.add(node);
1:                     }               
1:                 }
0:         } finally {
0:             lock.unlock();
0:     protected void flushToDisk() {
0:         lock.lock();
0:         try {
0:             if (!memoryList.isEmpty()) {
0:                 while (!memoryList.isEmpty()) {
0:                     MessageReference node = memoryList.removeFirst();
0:                     node.decrementReferenceCount();
0:                     getDiskList().addLast(node);
1:                 }
0:                 memoryList.clear();
0:         } finally {
0:             lock.unlock();
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(new ConnectionContext(new NonCachedMessageEvaluationContext()), message);
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:         //the store can be null if the BrokerService has persistence 
0:         //turned off
/////////////////////////////////////////////////////////////////////////
0:                     if (hasSpace() || this.store==null) {
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.ConnectionContext;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(FilePendingMessageCursor.class);
1:     protected Broker broker;
1:     private Iterator<MessageReference> iter;
/////////////////////////////////////////////////////////////////////////
0:     public FilePendingMessageCursor(Broker broker,String name) {
1:         this.broker = broker;
0:         this.store= broker.getTempDataStore();
/////////////////////////////////////////////////////////////////////////
1:         if (!node.isExpired()) {
0:             try {
0:                 regionDestination = node.getMessage().getRegionDestination();
0:                 if (isDiskListEmpty()) {
0:                     if (hasSpace()) {
0:                         memoryList.add(node);
0:                         node.incrementReferenceCount();
0:                         return;
1:                     }
1:                 }
0:                 if (!hasSpace()) {
0:                     if (isDiskListEmpty()) {
0:                         expireOldMessages();
0:                         if (hasSpace()) {
0:                             memoryList.add(node);
0:                             node.incrementReferenceCount();
0:                             return;
0:                         } else {
0:                             flushToDisk();
1:                         }
1:                     }
1:                 }
0:                 node.decrementReferenceCount();
0:                 getDiskList().add(node);
1: 
1:             } catch (Exception e) {
0:                 LOG.error("Caught an Exception adding a message: " + node
0:                         + " first to FilePendingMessageCursor ", e);
1:                 throw new RuntimeException(e);
0:         } else {
0:             discard(node);
/////////////////////////////////////////////////////////////////////////
0:         if (!node.isExpired()) {
0:             try {
0:                 regionDestination = node.getMessage().getRegionDestination();
0:                 if (isDiskListEmpty()) {
0:                     if (hasSpace()) {
0:                         memoryList.addFirst(node);
0:                         node.incrementReferenceCount();
0:                         return;
1:                     }
1:                 }
0:                 if (!hasSpace()) {
0:                     if (isDiskListEmpty()) {
0:                         expireOldMessages();
0:                         if (hasSpace()) {
0:                             memoryList.addFirst(node);
0:                             node.incrementReferenceCount();
0:                             return;
0:                         } else {
0:                             flushToDisk();
1:                         }
1:                     }
1:                 }
1: 
0:             } catch (Exception e) {
0:                 LOG.error("Caught an Exception adding a message: " + node
0:                         + " first to FilePendingMessageCursor ", e);
0:                 throw new RuntimeException(e);
0:         } else {
0:             discard(node);
/////////////////////////////////////////////////////////////////////////
0:     public void onUsageChanged(Usage usage, int oldPercentUsage,
0:             int newPercentUsage) {
0:                     expireOldMessages();
0:                     if (!hasSpace()) {
0:                         flushToDisk();
0:                         flushRequired = false;
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected synchronized void expireOldMessages() {
0:         if (!memoryList.isEmpty()) {
0:             LinkedList<MessageReference> tmpList = new LinkedList<MessageReference>(this.memoryList);
0:             this.memoryList = new LinkedList<MessageReference>();
0:             while (!tmpList.isEmpty()) {
0:                 MessageReference node = tmpList.removeFirst();
0:                 if (node.isExpired()) {
0:                     discard(node);
0:                 }else {
0:                     memoryList.add(node);
1:                 }               
1:             }
1:         }
1: 
1:     }
1:        
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Caught an IO Exception getting the DiskList ",e);
1:     
0:     protected void discard(MessageReference message) {
0:         message.decrementReferenceCount();
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Discarding message " + message);
0:         }
0:         broker.getRoot().sendToDeadLetterQueue(new ConnectionContext(), message);
0:     }
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:                 message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
/////////////////////////////////////////////////////////////////////////
0:             message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
commit:36486fe
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isTransient() {
0:         return true;
0:     }
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws Exception {
1:             super.start();
1:     public void stop() throws Exception {
1:             super.stop();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void destroy() throws Exception {
commit:393a861
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.QueueMessageReference;
/////////////////////////////////////////////////////////////////////////
0:         if(memoryList.isEmpty() && isDiskListEmpty()){
0:             return true;
0:         }
0:         for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {
0:             MessageReference node = iterator.next();
0:             if (node== QueueMessageReference.NULL_MESSAGE){
0:                 continue;
0:             }
0:             if (!node.isDropped()) {
0:                 return false;
0:             }
0:             // We can remove dropped references.
0:             iterator.remove();
0:         }
1:         return isDiskListEmpty();
commit:3c1a847
/////////////////////////////////////////////////////////////////////////
commit:2b063ef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private MessageReference last = null;
/////////////////////////////////////////////////////////////////////////
0:         boolean result =  memoryList.isEmpty() && isDiskListEmpty();
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:         last = null;
/////////////////////////////////////////////////////////////////////////
0:                 node.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                 node.incrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:         last = message;
/////////////////////////////////////////////////////////////////////////
0:         if (last != null) {
0:         	last.decrementReferenceCount();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (memoryList.remove(node)) {
0:         	node.decrementReferenceCount();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         last=null;
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.Usage;
1: import org.apache.activemq.usage.UsageListener;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:             if (systemUsage != null) {
1:                 systemUsage.getMemoryUsage().addUsageListener(this);
/////////////////////////////////////////////////////////////////////////
1:             if (systemUsage != null) {
1:                 systemUsage.getMemoryUsage().removeUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getTempDiskUsage().waitForSpace();
0:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getTempDiskUsage().waitForSpace();
0:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:     public void setSystemUsage(SystemUsage usageManager) {
1:         super.setSystemUsage(usageManager);
0:         usageManager.getMemoryUsage().addUsageListener(this);
0:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
commit:0cda6b0
/////////////////////////////////////////////////////////////////////////
1:     private boolean iterating;
/////////////////////////////////////////////////////////////////////////
0:         iterating=true;
0:         iterating=false;
/////////////////////////////////////////////////////////////////////////
0:             synchronized(this){
0:                 if(!iterating){
commit:6e7e3ab
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.CommandMarshaller;
commit:0859f30
/////////////////////////////////////////////////////////////////////////
0:                 diskList=store.getListContainer(name,"TopicSubscription",true);
commit:5b49189
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 diskList=store.getListContainer(name,"TopicSubscription",Store.IndexType.PERSISTENT);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0:     static private final AtomicLong nameCount = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0:         this.name=nameCount.incrementAndGet() + "_"+name;
commit:b036d4d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.IndexTypes;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean started=new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:     public void start(){
0:         if(started.compareAndSet(false,true)){
0:             if(usageManager!=null){
0:                 usageManager.addUsageListener(this);
0:             }
0:         }
0:     }
0: 
0:     public void stop(){
0:         if(started.compareAndSet(true,false)){
0:             gc();
0:             if(usageManager!=null){
0:                 usageManager.removeUsageListener(this);
0:             }
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         stop();
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean hasMessagesBufferedToDeliver(){
/////////////////////////////////////////////////////////////////////////
0:         if(newPercentUsage>=getMemoryUsageHighWaterMark()){
/////////////////////////////////////////////////////////////////////////
0:         if(!memoryList.isEmpty()){
0:             while(!memoryList.isEmpty()){
0:                 MessageReference node=(MessageReference)memoryList.removeFirst();
0:                 node.decrementReferenceCount();
0:                 getDiskList().addLast(node);
0:             }
0:             memoryList.clear();
/////////////////////////////////////////////////////////////////////////
0:                 diskList=store.getListContainer(name,"TopicSubscription",IndexTypes.DISK_INDEX);
0:                 e.printStackTrace();
commit:e5efc58
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean hasMessagesBufferedToDeliver() {
1:         return !isEmpty();
0:     }
commit:a110604
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean iterating=new AtomicBoolean();
1:     private boolean flushRequired;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void reset(){
0:         synchronized(iterating){
0:             iterating.set(true);
0:         iter=isDiskListEmpty()?memoryList.iterator():getDiskList().listIterator();
0:     public synchronized void release(){
0:         iterating.set(false);
0:         if(flushRequired){
0:             flushRequired=false;
0:             flushToDisk();
0:         }
/////////////////////////////////////////////////////////////////////////
0:             synchronized(iterating){
0:                 flushRequired=true;
0:                 if(!iterating.get()){
0:                     flushRequired=false;
commit:ec63977
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     private ReentrantLock iterLock=new ReentrantLock();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isEmpty(){
0:         return memoryList.isEmpty()&&isDiskListEmpty();
/////////////////////////////////////////////////////////////////////////
0:         try{
0:             iterLock.lockInterruptibly();
0:             iter=isDiskListEmpty()?memoryList.iterator():getDiskList().listIterator();
0:         }catch(InterruptedException e){
0:             log.warn("Failed to get lock ",e);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void destroy(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized LinkedList pageInList(int maxItems){
0:         int count=0;
0:         for(Iterator i=memoryList.iterator();i.hasNext()&&count<maxItems;){
0:             result.add(i.next());
0:             count++;
0:         }
0:         if(count<maxItems&&!isDiskListEmpty()){
0:             for(Iterator i=getDiskList().iterator();i.hasNext()&&count<maxItems;){
0:                 Message message=(Message)i.next();
0:                 message.setRegionDestination(regionDestination);
0:                 message.incrementReferenceCount();
0:                 result.add(message);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageLast(MessageReference node){
0:         try{
0:             regionDestination=node.getMessage().getRegionDestination();
0:             if(isSpaceInMemoryList()){
0:                 memoryList.add(node);
0:             }else{
0:                 flushToDisk();
0:                 node.decrementReferenceCount();
0:                 getDiskList().addLast(node);
0:         }catch(IOException e){
0:             throw new RuntimeException(e);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageFirst(MessageReference node){
0:         try{
0:             regionDestination=node.getMessage().getRegionDestination();
0:             if(isSpaceInMemoryList()){
0:                 memoryList.addFirst(node);
0:             }else{
0:                 flushToDisk();
0:                 node.decrementReferenceCount();
0:                 getDiskList().addFirst(node);
0:         }catch(IOException e){
0:             throw new RuntimeException(e);
0:     public synchronized boolean hasNext(){
0:         return iter.hasNext();
0:     public synchronized MessageReference next(){
0:         Message message=(Message)iter.next();
0:         if(!isDiskListEmpty()){
0:             // got from disk
0:             message.setRegionDestination(regionDestination);
0:             message.incrementReferenceCount();
0:         return message;
0:     public synchronized void remove(){
0:         iter.remove();
0:     public synchronized void remove(MessageReference node){
0:         memoryList.remove(node);
0:         if(!isDiskListEmpty()){
0:             getDiskList().remove(node);
0:     public synchronized int size(){
0:         return memoryList.size()+(isDiskListEmpty()?0:getDiskList().size());
0:     public synchronized void clear(){
0:         memoryList.clear();
0:         if(!isDiskListEmpty()){
0:             getDiskList().clear();
0:     public synchronized boolean isFull(){
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void flushToDisk(){
0:         for(Iterator i=memoryList.iterator();i.hasNext();){
0:             MessageReference node=(MessageReference)i.next();
0:             node.decrementReferenceCount();
0:             getDiskList().addLast(node);
0:         memoryList.clear();
commit:9359e9f
/////////////////////////////////////////////////////////////////////////
0: 
1: import java.util.LinkedList;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.locks.Lock;
0: import java.util.concurrent.locks.ReentrantLock;
0: import org.apache.activemq.memory.UsageListener;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0:  * 
0: public class FilePendingMessageCursor extends AbstractPendingMessageCursor implements UsageListener{
0:     static private final Log log=LogFactory.getLog(FilePendingMessageCursor.class);
0:     private Store store;
0:     private String name;
0:     private LinkedList memoryList=new LinkedList();
0:     private ListContainer diskList;
0:     private Lock iterLock=new ReentrantLock();
0:     private Object mutex=new Object();
0:         this.name=name;
0:         this.store=store;
0:         synchronized(mutex){
0:             return memoryList.isEmpty()&&isDiskListEmpty();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         iterLock.lock();
0:         synchronized(mutex){
0:             iter=isSpaceInMemoryList()?memoryList.iterator():diskList.listIterator();
0:         }
0:     }
0: 
0:     public void release(){
0:         iterLock.unlock();
0:     }
0: 
0:     public void destroy(){
0:         for(Iterator i=memoryList.iterator();i.hasNext();){
0:             Message node=(Message)i.next();
0:             node.decrementReferenceCount();
0:         }
0:         memoryList.clear();
0:         if(!isDiskListEmpty()){
0:             getDiskList().clear();
0:         }
0:     }
0: 
0:     public LinkedList pageInList(int maxItems){
0:         LinkedList result=new LinkedList();
0:         synchronized(mutex){
0:             int count=0;
0:             for(Iterator i=memoryList.iterator();i.hasNext()&&count<maxItems;){
0:                 result.add(i.next());
0:                 count++;
0:             }
0:             if(count<maxItems&&!isDiskListEmpty()){
0:                 for(Iterator i=getDiskList().iterator();i.hasNext()&&count<maxItems;){
0:                     Message message=(Message)i.next();
0:                     message.setRegionDestination(regionDestination);
0:                     message.incrementReferenceCount();
0:                     result.add(message);
0:                     count++;
0:                 }
0:             }
0:         }
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:         synchronized(mutex){
0:             try{
0:                 regionDestination=node.getMessage().getRegionDestination();
0:                 if(isSpaceInMemoryList()){
0:                     memoryList.add(node);
0:                 }else{
0:                     flushToDisk();
0:                     node.decrementReferenceCount();
0:                     getDiskList().addLast(node);
0:                 }
0:             }catch(IOException e){
0:                 throw new RuntimeException(e);
0:             }
0:         synchronized(mutex){
0:             try{
0:                 regionDestination=node.getMessage().getRegionDestination();
0:                 if(isSpaceInMemoryList()){
0:                     memoryList.addFirst(node);
0:                 }else{
0:                     flushToDisk();
0:                     node.decrementReferenceCount();
0:                     getDiskList().addFirst(node);
0:                 }
0:             }catch(IOException e){
0:                 throw new RuntimeException(e);
0:             }
0:         synchronized(mutex){
0:             return iter.hasNext();
0:         }
0:         synchronized(mutex){
0:             Message message=(Message)iter.next();
0:             if(!isDiskListEmpty()){
0:                 // got from disk
0:                 message.setRegionDestination(regionDestination);
0:                 message.incrementReferenceCount();
0:             }
0:             return message;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         synchronized(mutex){
0:             iter.remove();
0:         }
0: 
1:     /**
1:      * @param node
1:      * @see org.apache.activemq.broker.region.cursors.AbstractPendingMessageCursor#remove(org.apache.activemq.broker.region.MessageReference)
1:      */
0:         synchronized(mutex){
0:             memoryList.remove(node);
0:             if(!isDiskListEmpty()){
0:                 getDiskList().remove(node);
0:             }
0:         }
0: 
0:         synchronized(mutex){
0:             return memoryList.size()+(isDiskListEmpty()?0:getDiskList().size());
0:         }
/////////////////////////////////////////////////////////////////////////
0:         synchronized(mutex){
0:             memoryList.clear();
0:             if(!isDiskListEmpty()){
0:                 getDiskList().clear();
0:             }
0:         }
0:     }
0: 
0:     public boolean isFull(){
0:         // we always have space - as we can persist to disk
0:         return false;
0:     }
0: 
0:     public void setUsageManager(UsageManager usageManager){
0:         super.setUsageManager(usageManager);
0:         usageManager.addUsageListener(this);
0:     }
0: 
0:     public void onMemoryUseChanged(UsageManager memoryManager,int oldPercentUsage,int newPercentUsage){
0:         if(newPercentUsage>=100){
0:             try{
0:                 if(iterLock.tryLock(500,TimeUnit.MILLISECONDS)){
0:                     flushToDisk();
0:                     iterLock.unlock();
0:                 }
0:             }catch(InterruptedException e){
0:                 log.warn("caught an exception aquiring lock",e);
0:             }
0:         }
0:     }
0: 
0:     protected boolean isSpaceInMemoryList(){
0:         return hasSpace()&&isDiskListEmpty();
0:     }
0: 
0:     protected void flushToDisk(){
0:         synchronized(mutex){
0:             for(Iterator i=memoryList.iterator();i.hasNext();){
0:                 MessageReference node=(MessageReference)i.next();
0:                 node.decrementReferenceCount();
0:                 getDiskList().addLast(node);
0:             }
0:             memoryList.clear();
0:         }
0:     }
0: 
0:     protected boolean isDiskListEmpty(){
0:         return diskList==null||diskList.isEmpty();
0:     }
0: 
0:     protected ListContainer getDiskList(){
0:         if(diskList==null){
0:             try{
0:                 diskList=store.getListContainer(name);
0:                 diskList.setMarshaller(new CommandMarshaller(new OpenWireFormat()));
0:                 diskList.setMaximumCacheSize(0);
0:             }catch(IOException e){
0:                 throw new RuntimeException(e);
0:             }
0:         }
1:         return diskList;
commit:6895d00
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void remove(MessageReference node){
0:         list.remove(node);
0:     }
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0:  *
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0: 
1: import java.util.Iterator;
0: import org.apache.activemq.kaha.ListContainer;
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0: public class FilePendingMessageCursor extends AbstractPendingMessageCursor{
0:     private Iterator iter=null;
0: 
0:     public FilePendingMessageCursor(String name,Store store){
0:             list=store.getListContainer(name);
0: 
/////////////////////////////////////////////////////////////////////////
0:      * 
0:         iter=list.listIterator();
0: 
/////////////////////////////////////////////////////////////////////////
0:             regionDestination=node.getMessage().getRegionDestination();
0:             throw new RuntimeException(e);
0: 
0:      * 
0:      * @param position
0:             regionDestination=node.getMessage().getRegionDestination();
0:             throw new RuntimeException(e);
0:         return iter.hasNext();
0:         Message message=(Message) iter.next();
commit:7d1e6bc
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
1: import java.io.IOException;
0: import java.util.*;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.command.Message;
0: import org.apache.activemq.kaha.*;
1: import org.apache.activemq.openwire.OpenWireFormat;
0: import org.apache.activemq.store.kahadaptor.CommandMarshaller;
1: /**
0:  * perist pending messages pending message (messages awaiting disptach to a consumer) cursor
0:  * 
0:  * @version $Revision$
1:  */
0: public class FilePendingMessageCursor implements PendingMessageCursor{
0:     private ListContainer list;
0:     private Iterator iter = null;
1:     private Destination regionDestination;
0:     
1:     /**
1:      * @param name
0:      * @param store
0:      * @throws IOException
1:      */
0:     public FilePendingMessageCursor(String name, Store store) {
0:         try{
0:             list = store.getListContainer(name);
0:             list.setMarshaller(new CommandMarshaller(new OpenWireFormat()));
0:             list.setMaximumCacheSize(0);
0:         }catch(IOException e){
0:             throw new RuntimeException(e);
0:         }
0:     }
1:     /**
1:      * @return true if there are no pending messages
1:      */
0:     public boolean isEmpty(){
0:         return list.isEmpty();
0:     }
0: 
1:     /**
1:      * reset the cursor
0:      *
1:      */
0:     public void reset(){
0:         iter = list.listIterator();
0:     }
0:     
1:     /**
1:      * add message to await dispatch
0:      * 
1:      * @param node
1:      */
0:     public void addMessageLast(MessageReference node){
0:         try{
0:             regionDestination = node.getMessage().getRegionDestination();
0:             node.decrementReferenceCount();
0:         }catch(IOException e){
0:            throw new RuntimeException(e);
0:         }
0:         list.addLast(node);
0:     }
0:     
1:     /**
1:      * add message to await dispatch
0:      * @param position 
1:      * @param node
1:      */
0:     public void addMessageFirst(MessageReference node){
0:         try{
0:             regionDestination = node.getMessage().getRegionDestination();
0:             node.decrementReferenceCount();
0:         }catch(IOException e){
0:            throw new RuntimeException(e);
0:         }
0:         list.addFirst(node);
0:     }
0: 
0: 
1:     /**
1:      * @return true if there pending messages to dispatch
1:      */
0:     public boolean hasNext(){
0:        return iter.hasNext();
0:     }
0: 
1:     /**
1:      * @return the next pending message
1:      */
0:     public MessageReference next(){
0:         Message message = (Message) iter.next();
0:         message.setRegionDestination(regionDestination);
0:         message.incrementReferenceCount();
0:         return message;
0:     }
0: 
1:     /**
1:      * remove the message at the cursor position
0:      * 
1:      */
0:     public void remove(){
0:         iter.remove();
0:     }
0: 
1:     /**
1:      * @return the number of pending messages
1:      */
0:     public int size(){
0:         return list.size();
0:     }
0: 
1:     /**
1:      * clear all pending messages
0:      * 
1:      */
0:     public void clear(){
0:         list.clear();
0:     }
0: }
============================================================================