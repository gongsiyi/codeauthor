1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.vm;
1:fe8bc33: 
1:d29ca2a: import java.io.IOException;
1:fe8bc33: import java.io.InterruptedIOException;
1:d29ca2a: import java.net.URI;
1:31c55f7: import java.security.cert.X509Certificate;
1:ad585dc: import java.util.concurrent.BlockingQueue;
1:86cbdfd: import java.util.concurrent.LinkedBlockingQueue;
1:8bff980: import java.util.concurrent.TimeUnit;
1:fe8bc33: import java.util.concurrent.atomic.AtomicBoolean;
1:86cbdfd: import java.util.concurrent.atomic.AtomicLong;
1:fe8bc33: 
1:c4911bd: import org.apache.activemq.command.ShutdownInfo;
1:aaccbd3: import org.apache.activemq.thread.Task;
1:aaccbd3: import org.apache.activemq.thread.TaskRunner;
1:8a01c5d: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transport.FutureResponse;
1:84fd773: import org.apache.activemq.transport.ResponseCallback;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:aaccbd3: import org.apache.activemq.transport.TransportDisposedIOException;
1:d29ca2a: import org.apache.activemq.transport.TransportListener;
1:729766e: import org.apache.activemq.util.IOExceptionSupport;
1:31c55f7: import org.apache.activemq.wireformat.WireFormat;
1:a3701fc: import org.slf4j.Logger;
1:a3701fc: import org.slf4j.LoggerFactory;
1:3a7c673: 
1:d29ca2a: /**
1:d29ca2a:  * A Transport implementation that uses direct method invocations.
1:d29ca2a:  */
1:f812e34: public class VMTransport implements Transport, Task {
1:a3701fc:     protected static final Logger LOG = LoggerFactory.getLogger(VMTransport.class);
4:d29ca2a: 
1:fc00993:     private static final AtomicLong NEXT_ID = new AtomicLong(0);
1:d29ca2a: 
1:ad585dc:     // Transport Configuration
1:d29ca2a:     protected VMTransport peer;
1:d29ca2a:     protected TransportListener transportListener;
1:d29ca2a:     protected boolean marshal;
1:f812e34:     protected boolean async = true;
1:f812e34:     protected int asyncQueueDepth = 2000;
1:d29ca2a:     protected final URI location;
1:d29ca2a:     protected final long id;
1:5a74d56: 
1:ad585dc:     // Implementation
1:e99c814:     private volatile LinkedBlockingQueue<Object> messageQueue;
1:e99c814:     private volatile TaskRunnerFactory taskRunnerFactory;
1:e99c814:     private volatile TaskRunner taskRunner;
1:bc8441b: 
1:ad585dc:     // Transport State
1:bc8441b:     protected final AtomicBoolean started = new AtomicBoolean();
1:bc8441b:     protected final AtomicBoolean disposed = new AtomicBoolean();
1:5a74d56: 
1:5a74d56:     private volatile int receiveCounter;
1:5a74d56: 
1:f812e34:     public VMTransport(URI location) {
1:f812e34:         this.location = location;
1:fc00993:         this.id = NEXT_ID.getAndIncrement();
1:ea74731:     }
1:bc8441b: 
1:f812e34:     public void setPeer(VMTransport peer) {
1:fe8bc33:         this.peer = peer;
1:ada47fb:     }
1:bc8441b: 
1:307005a:     @Override
1:f812e34:     public void oneway(Object command) throws IOException {
1:bc8441b: 
1:bc8441b:         if (disposed.get()) {
1:aaccbd3:             throw new TransportDisposedIOException("Transport disposed.");
1:f812e34:         }
1:bc8441b: 
1:fc00993:         if (peer == null) {
1:d29ca2a:             throw new IOException("Peer not connected.");
1:fc00993:         }
1:e4ee0b2: 
1:58b9a83:         try {
1:ada47fb: 
1:ad585dc:             if (peer.disposed.get()) {
1:f812e34:                 throw new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed.");
1:f812e34:             }
1:bc8441b: 
1:c89bb7a:             if (peer.async) {
2:fe8bc33:                 peer.getMessageQueue().put(command);
1:bc8441b:                 peer.wakeup();
1:ad585dc:                 return;
1:bc8441b:             }
1:ada47fb: 
1:c89bb7a:             if (!peer.started.get()) {
1:c89bb7a:                 LinkedBlockingQueue<Object> pending = peer.getMessageQueue();
1:b8a20e9:                 int sleepTimeMillis;
1:c89bb7a:                 boolean accepted = false;
1:c89bb7a:                 do {
1:b8a20e9:                     sleepTimeMillis = 0;
1:b8a20e9:                     // the pending queue is drained on start so we need to ensure we add before
1:b8a20e9:                     // the drain commences, otherwise we never get the command dispatched!
1:c89bb7a:                     synchronized (peer.started) {
1:b8a20e9:                         if (!peer.started.get()) {
1:b8a20e9:                             accepted = pending.offer(command);
1:b8a20e9:                             if (!accepted) {
1:b8a20e9:                                 sleepTimeMillis = 500;
1:b8a20e9:                             }
1:b8a20e9:                         }
1:c89bb7a:                     }
1:b8a20e9:                     // give start thread a chance if we will loop
1:b8a20e9:                     TimeUnit.MILLISECONDS.sleep(sleepTimeMillis);
1:b8a20e9: 
1:c89bb7a:                 } while (!accepted && !peer.started.get());
1:c89bb7a:                 if (accepted) {
1:c89bb7a:                     return;
1:c89bb7a:                 }
1:c89bb7a:             }
2:fe8bc33:         } catch (InterruptedException e) {
1:0a12bcb:             Thread.currentThread().interrupt();
1:909c1c3:             InterruptedIOException iioe = new InterruptedIOException(e.getMessage());
1:909c1c3:             iioe.initCause(e);
1:909c1c3:             throw iioe;
1:bc8441b:         }
1:bc8441b: 
1:ad585dc:         dispatch(peer, peer.messageQueue, command);
1:bc8441b:     }
1:fe8bc33: 
1:ad585dc:     public void dispatch(VMTransport transport, BlockingQueue<Object> pending, Object command) {
1:ad585dc:         TransportListener transportListener = transport.getTransportListener();
1:bc8441b:         if (transportListener != null) {
1:e0bb36b:             // Lock here on the target transport's started since we want to wait for its start()
1:e0bb36b:             // method to finish dispatching out of the queue before we do our own.
1:e0bb36b:             synchronized (transport.started) {
1:fe8bc33: 
1:ad585dc:                 // Ensure that no additional commands entered the queue in the small time window
1:ad585dc:                 // before the start method locks the dispatch lock and the oneway method was in
1:ad585dc:                 // an put operation.
1:ad585dc:                 while(pending != null && !pending.isEmpty() && !transport.isDisposed()) {
1:ad585dc:                     doDispatch(transport, transportListener, pending.poll());
1:fe8bc33:                 }
1:f812e34: 
1:ad585dc:                 // We are now in sync mode and won't enqueue any more commands to the target
1:ad585dc:                 // transport so lets clean up its resources.
1:ad585dc:                 transport.messageQueue = null;
1:f812e34: 
1:ad585dc:                 // Don't dispatch if either end was disposed already.
1:ad585dc:                 if (command != null && !this.disposed.get() && !transport.isDisposed()) {
1:ad585dc:                     doDispatch(transport, transportListener, command);
1:fe8bc33:                 }
1:fe8bc33:             }
1:fe8bc33:         }
1:f812e34:     }
1:f812e34: 
1:ad585dc:     public void doDispatch(VMTransport transport, TransportListener transportListener, Object command) {
1:a3701fc:         transport.receiveCounter++;
1:a3701fc:         transportListener.onCommand(command);
1:e4ee0b2:     }
1:ea74731: 
1:307005a:     @Override
1:fe8bc33:     public void start() throws Exception {
1:ea74731: 
1:bc8441b:         if (transportListener == null) {
1:bc8441b:             throw new IOException("TransportListener not set.");
1:bc8441b:         }
1:bc8441b: 
1:ad585dc:         // If we are not in async mode we lock the dispatch lock here and then start to
1:ad585dc:         // prevent any sync dispatches from occurring until we dispatch the pending messages
1:ad585dc:         // to maintain delivery order.  When async this happens automatically so just set
1:ad585dc:         // started and wakeup the task runner.
1:ad585dc:         if (!async) {
2:ad585dc:             synchronized (started) {
1:ad585dc:                 if (started.compareAndSet(false, true)) {
1:fe8bc33:                     LinkedBlockingQueue<Object> mq = getMessageQueue();
1:fe8bc33:                     Object command;
1:ad585dc:                     while ((command = mq.poll()) != null && !disposed.get() ) {
1:8978ac0:                         receiveCounter++;
1:ad585dc:                         doDispatch(this, transportListener, command);
1:fe8bc33:                     }
1:fe8bc33:                 }
1:fe8bc33:             }
1:bc8441b:         } else {
1:ad585dc:             if (started.compareAndSet(false, true)) {
1:e901d2f:                 wakeup();
1:bc8441b:             }
1:bc8441b:         }
1:e4ee0b2:     }
1:bc8441b: 
1:307005a:     @Override
1:fe8bc33:     public void stop() throws Exception {
1:ad585dc:         // Only need to do this once, all future oneway calls will now
1:ad585dc:         // fail as will any asnyc jobs in the task runner.
1:243db1c:         if (disposed.compareAndSet(false, true)) {
1:bc8441b: 
1:ad585dc:             TaskRunner tr = taskRunner;
1:ad585dc:             LinkedBlockingQueue<Object> mq = this.messageQueue;
1:bc8441b: 
2:bc8441b:             taskRunner = null;
1:bc8441b:             messageQueue = null;
1:fe8bc33: 
1:ad585dc:             if (mq != null) {
1:ad585dc:                 mq.clear();
1:2edad74:             }
1:fe8bc33: 
1:db084ef:             // don't wait for completion
1:ada47fb:             if (tr != null) {
1:e901d2f:                 try {
1:db084ef:                     tr.shutdown(1);
1:ad585dc:                 } catch(Exception e) {
1:ada47fb:                 }
1:307005a:                 tr = null;
1:ada47fb:             }
1:fe8bc33: 
1:243db1c:             if (peer.transportListener != null) {
1:b60bfbb:                 // let the peer know that we are disconnecting after attempting
1:b60bfbb:                 // to cleanly shutdown the async tasks so that this is the last
1:b60bfbb:                 // command it see's.
1:b60bfbb:                 try {
1:b60bfbb:                     peer.transportListener.onCommand(new ShutdownInfo());
1:b60bfbb:                 } catch (Exception ignore) {
1:b60bfbb:                 }
1:b60bfbb: 
1:b60bfbb:                 // let any requests pending a response see an exception
1:243db1c:                 try {
1:243db1c:                     peer.transportListener.onException(new TransportDisposedIOException("peer (" + this + ") stopped."));
2:243db1c:                 } catch (Exception ignore) {
1:243db1c:                 }
1:243db1c:             }
1:58b9a83: 
1:8a01c5d:             // shutdown task runner factory
1:8a01c5d:             if (taskRunnerFactory != null) {
1:8a01c5d:                 taskRunnerFactory.shutdownNow();
1:8a01c5d:                 taskRunnerFactory = null;
1:58b9a83:             }
1:bc8441b:         }
1:bc8441b:     }
1:bc8441b: 
1:f812e34:     protected void wakeup() {
1:ad585dc:         if (async && started.get()) {
1:243db1c:             try {
1:ad585dc:                 getTaskRunner().wakeup();
1:fe8bc33:             } catch (InterruptedException e) {
1:ad585dc:                 Thread.currentThread().interrupt();
1:ad585dc:             } catch (TransportDisposedIOException e) {
1:2edad74:             }
1:fe8bc33:         }
1:fe8bc33:     }
1:2edad74: 
1:fe8bc33:     /**
1:fe8bc33:      * @see org.apache.activemq.thread.Task#iterate()
1:fe8bc33:      */
1:307005a:     @Override
1:fe8bc33:     public boolean iterate() {
1:bc8441b: 
1:ad585dc:         final TransportListener tl = transportListener;
1:fe8bc33: 
1:ad585dc:         LinkedBlockingQueue<Object> mq;
1:2edad74:         try {
1:ad585dc:             mq = getMessageQueue();
1:ad585dc:         } catch (TransportDisposedIOException e) {
1:fe8bc33:             return false;
1:fe8bc33:         }
1:fe8bc33: 
1:2edad74:         Object command = mq.poll();
1:ad585dc:         if (command != null && !disposed.get()) {
1:729766e:             try {
1:729766e:                 tl.onCommand(command);
1:729766e:             } catch (Exception e) {
1:729766e:                 try {
1:729766e:                     peer.transportListener.onException(IOExceptionSupport.create(e));
1:729766e:                 } catch (Exception ignore) {
1:729766e:                 }
1:729766e:             }
1:ad585dc:             return !mq.isEmpty() && !disposed.get();
1:bc8441b:         } else {
1:ad585dc:             if(disposed.get()) {
1:ad585dc:                 mq.clear();
1:2edad74:             }
1:fe8bc33:             return false;
1:fe8bc33:         }
1:fe8bc33:     }
1:fe8bc33: 
1:307005a:     @Override
1:fe8bc33:     public void setTransportListener(TransportListener commandListener) {
1:bc8441b:         this.transportListener = commandListener;
1:e901d2f:     }
1:fe8bc33: 
1:ad585dc:     public LinkedBlockingQueue<Object> getMessageQueue() throws TransportDisposedIOException {
1:ad585dc:         LinkedBlockingQueue<Object> result = messageQueue;
1:ad585dc:         if (result == null) {
2:ad585dc:             synchronized (this) {
1:ad585dc:                 result = messageQueue;
1:ad585dc:                 if (result == null) {
1:ad585dc:                     if (disposed.get()) {
1:ad585dc:                         throw new TransportDisposedIOException("The Transport has been disposed");
1:fe8bc33:                     }
1:ea74731: 
1:ad585dc:                     messageQueue = result = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);
1:fe8bc33:                 }
1:fe8bc33:             }
1:fe8bc33:         }
1:ad585dc:         return result;
1:fe8bc33:     }
1:ea74731: 
1:ad585dc:     protected TaskRunner getTaskRunner() throws TransportDisposedIOException {
1:ad585dc:         TaskRunner result = taskRunner;
1:ad585dc:         if (result == null) {
1:ad585dc:             synchronized (this) {
1:ad585dc:                 result = taskRunner;
1:ad585dc:                 if (result == null) {
1:ad585dc:                     if (disposed.get()) {
1:ad585dc:                         throw new TransportDisposedIOException("The Transport has been disposed");
1:fe8bc33:                     }
1:ea74731: 
1:4e19892:                     String name = "ActiveMQ VMTransport: " + toString();
1:8a01c5d:                     if (taskRunnerFactory == null) {
1:4e19892:                         taskRunnerFactory = new TaskRunnerFactory(name);
1:8a01c5d:                         taskRunnerFactory.init();
1:fe8bc33:                     }
1:4e19892:                     taskRunner = result = taskRunnerFactory.createTaskRunner(this, name);
1:fc00993:                 }
1:fc00993:             }
1:f812e34:         }
1:ad585dc:         return result;
1:f812e34:     }
1:ea74731: 
1:307005a:     @Override
1:f812e34:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:f812e34:     }
1:d29ca2a: 
1:307005a:     @Override
1:f812e34:     public Object request(Object command) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:f812e34:     }
1:d29ca2a: 
1:307005a:     @Override
1:f812e34:     public Object request(Object command, int timeout) throws IOException {
1:5fe0a4c:         throw new AssertionError("Unsupported Method");
1:f812e34:     }
1:f812e34: 
1:307005a:     @Override
1:f812e34:     public TransportListener getTransportListener() {
1:fe8bc33:         return transportListener;
1:f812e34:     }
1:f812e34: 
1:307005a:     @Override
1:933eb2f:     public <T> T narrow(Class<T> target) {
1:f812e34:         if (target.isAssignableFrom(getClass())) {
1:933eb2f:             return target.cast(this);
1:f812e34:         }
1:d29ca2a:         return null;
1:f812e34:     }
1:31c55f7: 
1:f812e34:     public boolean isMarshal() {
1:d29ca2a:         return marshal;
1:f812e34:     }
1:d29ca2a: 
1:f812e34:     public void setMarshal(boolean marshal) {
1:f812e34:         this.marshal = marshal;
1:5ad4732:     }
1:d29ca2a: 
1:f392884:     @Override
1:f812e34:     public String toString() {
1:f812e34:         return location + "#" + id;
1:ea74731:     }
1:d29ca2a: 
1:307005a:     @Override
1:f812e34:     public String getRemoteAddress() {
1:f812e34:         if (peer != null) {
1:aaccbd3:             return peer.toString();
1:ea74731:         }
1:aaccbd3:         return null;
1:ea74731:     }
1:d29ca2a: 
1:bc005fd:     /**
1:aaccbd3:      * @return the async
1:bc005fd:      */
1:f812e34:     public boolean isAsync() {
1:aaccbd3:         return async;
1:ea74731:     }
1:d29ca2a: 
2:aaccbd3:     /**
1:aaccbd3:      * @param async the async to set
2:aaccbd3:      */
1:f812e34:     public void setAsync(boolean async) {
1:f812e34:         this.async = async;
1:ea74731:     }
1:d29ca2a: 
1:aaccbd3:     /**
1:aaccbd3:      * @return the asyncQueueDepth
1:aaccbd3:      */
1:f812e34:     public int getAsyncQueueDepth() {
1:aaccbd3:         return asyncQueueDepth;
1:ea74731:     }
1:d29ca2a: 
1:aaccbd3:     /**
1:aaccbd3:      * @param asyncQueueDepth the asyncQueueDepth to set
1:aaccbd3:      */
1:f812e34:     public void setAsyncQueueDepth(int asyncQueueDepth) {
1:f812e34:         this.asyncQueueDepth = asyncQueueDepth;
1:ea74731:     }
1:d29ca2a: 
1:307005a:     @Override
1:f812e34:     public boolean isFaultTolerant() {
1:fe8bc33:         return false;
1:ea74731:     }
1:d29ca2a: 
1:307005a:     @Override
1:bc8441b:     public boolean isDisposed() {
1:bc8441b:         return disposed.get();
1:bc8441b:     }
1:d29ca2a: 
1:307005a:     @Override
1:bc8441b:     public boolean isConnected() {
1:ad585dc:         return !disposed.get();
1:bc8441b:     }
1:bc8441b: 
1:307005a:     @Override
1:bc8441b:     public void reconnect(URI uri) throws IOException {
1:ad585dc:         throw new IOException("Transport reconnect is not supported");
1:ea74731:     }
1:8978ac0: 
1:307005a:     @Override
1:f392884:     public boolean isReconnectSupported() {
1:f812e34:         return false;
1:ea74731:     }
1:d29ca2a: 
1:307005a:     @Override
1:f392884:     public boolean isUpdateURIsSupported() {
1:f812e34:         return false;
1:3a7c673:     }
1:bc8441b: 
1:307005a:     @Override
1:ad585dc:     public void updateURIs(boolean reblance,URI[] uris) throws IOException {
1:ad585dc:         throw new IOException("URI update feature not supported");
1:3a7c673:     }
1:d29ca2a: 
1:307005a:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         return receiveCounter;
1:8978ac0:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         return null;
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7: 
1:31c55f7:     }
1:d29ca2a: 
1:31c55f7:     @Override
1:31c55f7:     public WireFormat getWireFormat() {
1:31c55f7:         return null;
1:31c55f7:     }
4:3a7c673: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:729766e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 tl.onCommand(command);
1:             } catch (Exception e) {
1:                 try {
1:                     peer.transportListener.onException(IOExceptionSupport.create(e));
1:                 } catch (Exception ignore) {
1:                 }
1:             }
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
1:             Thread.currentThread().interrupt();
commit:3100909
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b8a20e9
/////////////////////////////////////////////////////////////////////////
1:                 int sleepTimeMillis;
1:                     sleepTimeMillis = 0;
1:                     // the pending queue is drained on start so we need to ensure we add before
1:                     // the drain commences, otherwise we never get the command dispatched!
1:                         if (!peer.started.get()) {
1:                             accepted = pending.offer(command);
1:                             if (!accepted) {
1:                                 sleepTimeMillis = 500;
1:                             }
1:                         }
1:                     // give start thread a chance if we will loop
1:                     TimeUnit.MILLISECONDS.sleep(sleepTimeMillis);
1: 
commit:c89bb7a
/////////////////////////////////////////////////////////////////////////
1:             if (peer.async) {
1:             if (!peer.started.get()) {
1:                 LinkedBlockingQueue<Object> pending = peer.getMessageQueue();
1:                 boolean accepted = false;
1:                 do {
1:                     synchronized (peer.started) {
0:                         accepted = pending.offer(command);
1:                     }
1:                 } while (!accepted && !peer.started.get());
1:                 if (accepted) {
1:                     return;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
commit:db084ef
/////////////////////////////////////////////////////////////////////////
1:             // don't wait for completion
1:                     tr.shutdown(1);
commit:b60bfbb
/////////////////////////////////////////////////////////////////////////
1:                 // let the peer know that we are disconnecting after attempting
1:                 // to cleanly shutdown the async tasks so that this is the last
1:                 // command it see's.
1:                 try {
1:                     peer.transportListener.onCommand(new ShutdownInfo());
1:                 } catch (Exception ignore) {
1:                 }
1: 
1:                 // let any requests pending a response see an exception
commit:8cf98a0
/////////////////////////////////////////////////////////////////////////
0:                 // let any requests pending a response see an exception and shutdown
commit:243db1c
/////////////////////////////////////////////////////////////////////////
1:         if (disposed.compareAndSet(false, true)) {
/////////////////////////////////////////////////////////////////////////
1:             if (peer.transportListener != null) {
0:                 // let the peer know that we are disconnecting after attempting
0:                 // to cleanly shutdown the async tasks so that this is the last
0:                 // command it see's.
1:                 try {
0:                     peer.transportListener.onCommand(new ShutdownInfo());
1:                 } catch (Exception ignore) {
1:                 }
0:                 // let any requests pending a response see an exception
1:                 try {
1:                     peer.transportListener.onException(new TransportDisposedIOException("peer (" + this + ") stopped."));
1:                 } catch (Exception ignore) {
1:                 }
commit:a56996d
/////////////////////////////////////////////////////////////////////////
0:         if (disposed.compareAndSet(false, true) && started.get()) {
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1: 
1:     }
1: 
1:     @Override
1:     public WireFormat getWireFormat() {
1:         return null;
1:     }
commit:307005a
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 tr = null;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:e99c814
/////////////////////////////////////////////////////////////////////////
1:     private volatile LinkedBlockingQueue<Object> messageQueue;
1:     private volatile TaskRunnerFactory taskRunnerFactory;
1:     private volatile TaskRunner taskRunner;
author:Kevin Earls
-------------------------------------------------------------------------------
commit:a3701fc
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     protected static final Logger LOG = LoggerFactory.getLogger(VMTransport.class);
/////////////////////////////////////////////////////////////////////////
1:         transport.receiveCounter++;
1:         transportListener.onCommand(command);
/////////////////////////////////////////////////////////////////////////
0:             tl.onCommand(command);
author:Gary Tully
-------------------------------------------------------------------------------
commit:58b9a83
/////////////////////////////////////////////////////////////////////////
0:             // let any requests pending a response see an exception
1:             try {
0:                 peer.transportListener.onException(new TransportDisposedIOException("peer (" + this + ") stopped."));
0:             } catch (Exception ignore) {
1:             }
1: 
commit:8bff980
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
commit:5a74d56
/////////////////////////////////////////////////////////////////////////
0:     // thread can be eager, so initialisation needs to be last  so that partial state is not visible
0:     protected TaskRunner taskRunner = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(this, "VMTransport: " + toString());
1: 
1:     private volatile int receiveCounter;
1: 
1: 
commit:bc8441b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected LinkedBlockingQueue<Object> messageQueue = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);
0:     private TaskRunner taskRunner = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(this, "VMTransport: " + toString());
1: 
1: 
0:     // Managed Sate access protected by locks.
0:     protected final AtomicBoolean stopping = new AtomicBoolean();
1:     protected final AtomicBoolean started = new AtomicBoolean();
0:     protected final AtomicBoolean starting = new AtomicBoolean();
1:     protected final AtomicBoolean disposed = new AtomicBoolean();
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (disposed.get()) {
0:         TransportListener transportListener = null;
0:             if (peer.disposed.get() || peer.stopping.get()) {
1: 
0:             if (peer.started.get()) {
0:                     peer.messageQueue.put(command);
0:                 peer.messageQueue.put(command);
0:                 synchronized (peer.starting) {
0:                     if (peer.started.get() && !peer.messageQueue.isEmpty()) {
0:                         // we missed the pending dispatch during start
0:                         if (peer.async) {
1:                             peer.wakeup();
1:                         } else {
0:                             transportListener = peer.transportListener;
1:                         }
1:                     }
1:                 }
1: 
1:         if (transportListener != null) {
0:             if (command == DISCONNECT) {
0:                 transportListener.onException(
0:                         new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (starting.compareAndSet(false, true)) {
1: 
1:             if (transportListener == null) {
1:                 throw new IOException("TransportListener not set.");
1:             }
1: 
0:             // ensure there is no missed dispatch during start, sync with oneway
0:             synchronized (peer.starting) {
0:                 while ((command = messageQueue.poll()) != null && !stopping.get()) {
1: 
0:                 if (!disposed.get()) {
1: 
0:                     started.set(true);
1: 
0:                     if (async) {
0:                         taskRunner.wakeup();
1:                     } else {
0:                         messageQueue.clear();
1:                         messageQueue = null;
0:                         taskRunner.shutdown();
1:                         taskRunner = null;
1:                     }
1:                 }
0:         if (disposed.compareAndSet(false, true)) {
0:             stopping.set(true);
0:             if (messageQueue != null) {
0:                 messageQueue.clear();
1:             }
0:             if (taskRunner != null) {
0:                 taskRunner.shutdown(1000);
1:                 taskRunner = null;
1:             }
1: 
1: 
0:         if (disposed.get() || stopping.get()) {
0:         LinkedBlockingQueue<Object> mq = messageQueue;
0:             if (command == DISCONNECT) {
0:                 transportListener.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:                 transportListener.onCommand(command);
1:         this.transportListener = commandListener;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDisposed() {
1:         return disposed.get();
1:     }
1:     public boolean isConnected() {
0:         return started.get();
1:     }
1: 
1:     public void reconnect(URI uri) throws IOException {
0:         throw new IOException("reconnection Not supported by this transport.");
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void updateURIs(boolean reblance, URI[] uris) throws IOException {
commit:e901d2f
/////////////////////////////////////////////////////////////////////////
0:             // enqueue can block on blocking queue, preventing turnOff
0:             // so avoid in that case: https://issues.apache.org/jira/browse/AMQ-3684
0:             if (async && getMessageQueue().remainingCapacity() == 0) {
0:                 // enqueue blocked or will be
0:             } else {
1:                 try {
0:                     enqueueValve.turnOff();
0:                     this.transportListener = commandListener;
1:                     wakeup();
0:                 } finally {
0:                     enqueueValve.turnOn();
1:                 }
commit:6348481
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     taskRunner = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(this, "VMTransport: " + toString());
commit:c4911bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ShutdownInfo;
/////////////////////////////////////////////////////////////////////////
0:                 peer.transportListener.onCommand(new ShutdownInfo());
commit:c808beb
/////////////////////////////////////////////////////////////////////////
0:     // still possible to configure dedicated task runner through system property but not programmatically
0:     private static final TaskRunnerFactory TASK_RUNNER_FACTORY = new TaskRunnerFactory("VMTransport", Thread.NORM_PRIORITY, true, 1000, false);
commit:4213e42
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
0:     private volatile int receiveCounter;
/////////////////////////////////////////////////////////////////////////
0:                 peer.receiveCounter++;
/////////////////////////////////////////////////////////////////////////
1:                     receiveCounter++;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getReceiveCounter() {
1:         return receiveCounter;
1:     }
commit:e4ee0b2
/////////////////////////////////////////////////////////////////////////
1:         
0:         TransportListener transportListener=null;
/////////////////////////////////////////////////////////////////////////
0:                     transportListener = peer.transportListener;
/////////////////////////////////////////////////////////////////////////
0:         if( transportListener!=null ) {
0:             if( command == DISCONNECT ) {
0:                 transportListener.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:             } else {
0:                 transportListener.onCommand(command);
1:             }
1:         }
commit:2edad74
/////////////////////////////////////////////////////////////////////////
0:     private static final Object DISCONNECT = new Object();
/////////////////////////////////////////////////////////////////////////
0:                     if( command == DISCONNECT ) {
0:                         peer.transportListener.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:                     } else {
0:                         peer.transportListener.onCommand(command);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:             // let the peer know that we are disconnecting..
1:             try {
0:                 oneway(DISCONNECT);
0:             } catch (Exception ignore) {
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         Object command = mq.poll();
0:             if( command == DISCONNECT ) {
0:                 tl.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:             } else {
0:                 tl.onCommand(command);
1:             }
commit:ada47fb
/////////////////////////////////////////////////////////////////////////
0:                 while ((command = messageQueue.poll()) != null && !stopping.get() ) {
/////////////////////////////////////////////////////////////////////////
0:         // If we get stopped while starting up, then do the actual stop now 
0:         // that the enqueueValve is back on.
0:         if( stopping.get() ) {
0:             stop();
1:         }
0:         stopping.set(true);
1:         
0:         // If stop() is called while being start()ed.. then we can't stop until we return to the start() method.
0:         if( enqueueValve.isOn() ) {
1:             
0:             TaskRunner tr = null;
0:             try {
0:                 enqueueValve.turnOff();
0:                 if (!disposed) {
0:                     started = false;
0:                     disposed = true;
0:                     if (taskRunner != null) {
0:                         tr = taskRunner;
0:                         taskRunner = null;
1:                     }
0:             } finally {
0:                 stopping.set(false);
0:                 enqueueValve.turnOn();
1:             if (tr != null) {
0:                 tr.shutdown(1000);
1:             }
commit:fe8bc33
/////////////////////////////////////////////////////////////////////////
1: import java.io.InterruptedIOException;
1: import java.util.concurrent.atomic.AtomicBoolean;
0: import org.apache.activemq.thread.Valve;
/////////////////////////////////////////////////////////////////////////
0:     private final Object lazyInitMutext = new Object();
0:     private final Valve enqueueValve = new Valve(true);
0:     private final AtomicBoolean stopping = new AtomicBoolean();
1:     
1:         this.peer = peer;
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             // Disable the peer from changing his state while we try to enqueue onto him.
0:             peer.enqueueValve.increment();
1:         
0:             if (peer.disposed || peer.stopping.get()) {
1:             
1:                     peer.getMessageQueue().put(command);
0:                     peer.transportListener.onCommand(command);
0:                 enqueueValve.decrement();
1:                 peer.getMessageQueue().put(command);
1:             
1:         } catch (InterruptedException e) {
0:             throw IOExceptionSupport.create(e);
0:         } finally {
0:             // Allow the peer to change state again...
0:             peer.enqueueValve.decrement();
1:     public void start() throws Exception {
0:         if (transportListener == null) {
0:             throw new IOException("TransportListener not set.");
1:         }
0:             enqueueValve.turnOff();
0:             if (messageQueue != null && !async) {
1:                 Object command;
0:                 while ((command = messageQueue.poll()) != null) {
0:                     transportListener.onCommand(command);
1:                 }
1:             }
0:             started = true;
0:             wakeup();
0:         } finally {
0:             enqueueValve.turnOn();
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
0:         TaskRunner tr = null;
0:         try {
0:             stopping.set(true);
0:             enqueueValve.turnOff();
0:             if (!disposed) {
0:                 started = false;
0:                 disposed = true;
0:                 if (taskRunner != null) {
0:                     tr = taskRunner;
0:                     taskRunner = null;
1:                 }
1:             }
0:         } finally {
0:             stopping.set(false);
0:             enqueueValve.turnOn();
1:         }
0:         if (tr != null) {
0:             tr.shutdown(1000);
1:         }
1:     }
1:     
1:     /**
1:      * @see org.apache.activemq.thread.Task#iterate()
1:      */
1:     public boolean iterate() {
1:         
0:         final TransportListener tl;
0:         try {
0:             // Disable changing the state variables while we are running... 
0:             enqueueValve.increment();
0:             tl = transportListener;
0:             if (!started || disposed || tl == null || stopping.get()) {
0:                 if( stopping.get() ) {
0:                     // drain the queue it since folks could be blocked putting on to
0:                     // it and that would not allow the stop() method for finishing up.
0:                     getMessageQueue().clear();  
1:                 }
1:                 return false;
1:             }
1:         } catch (InterruptedException e) {
1:             return false;
0:         } finally {
0:             enqueueValve.decrement();
1:         }
1: 
1:         LinkedBlockingQueue<Object> mq = getMessageQueue();
0:         Command command = (Command)mq.poll();
0:         if (command != null) {
0:             tl.onCommand(command);
0:             return !mq.isEmpty();
0:         } else {
1:             return false;
1:         }
1:         
1:     }
1: 
1:     public void setTransportListener(TransportListener commandListener) {
0:         try {
0:             try {
0:                 enqueueValve.turnOff();
0:                 this.transportListener = commandListener;
0:                 wakeup();
0:             } finally {
0:                 enqueueValve.turnOn();
1:             }
1:         } catch (InterruptedException e) {
0:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:     private LinkedBlockingQueue<Object> getMessageQueue() {
0:         synchronized (lazyInitMutext) {
0:             if (messageQueue == null) {
0:                 messageQueue = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);
1:             }
0:             return messageQueue;
/////////////////////////////////////////////////////////////////////////
1:         return transportListener;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             synchronized (lazyInitMutext) {
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected LinkedBlockingQueue<Object> messageQueue;
/////////////////////////////////////////////////////////////////////////
0:     private LinkedBlockingQueue<Object> getMessageQueue() {
0:                 messageQueue = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);
/////////////////////////////////////////////////////////////////////////
1:     public <T> T narrow(Class<T> target) {
1:             return target.cast(this);
/////////////////////////////////////////////////////////////////////////
0:         LinkedBlockingQueue<Object> mq = getMessageQueue();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(VMTransport.class);
1:     private static final AtomicLong NEXT_ID = new AtomicLong(0);
0:     private static final TaskRunnerFactory TASK_RUNNER_FACTORY = new TaskRunnerFactory("VMTransport", Thread.NORM_PRIORITY, true, 1000);
/////////////////////////////////////////////////////////////////////////
0:     protected LinkedBlockingQueue messageQueue;
/////////////////////////////////////////////////////////////////////////
1:         this.id = NEXT_ID.getAndIncrement();
/////////////////////////////////////////////////////////////////////////
1:         if (peer == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (transportListener == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (!started || disposed || tl == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     taskRunner = TASK_RUNNER_FACTORY.createTaskRunner(this, "VMTransport: " + toString());
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: public class VMTransport implements Transport, Task {
0:     private static final Log log = LogFactory.getLog(VMTransport.class);
0:     private static final AtomicLong nextId = new AtomicLong(0);
0:     private static final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory("VMTransport", Thread.NORM_PRIORITY, true, 1000);
1:     protected boolean async = true;
1:     protected int asyncQueueDepth = 2000;
0:     protected LinkedBlockingQueue messageQueue = null;
0:     private final Object mutex = new Object();
1:     public VMTransport(URI location) {
1:         this.location = location;
0:         this.id = nextId.getAndIncrement();
0:     public VMTransport getPeer() {
0:         synchronized (mutex) {
1:     public void setPeer(VMTransport peer) {
0:         synchronized (mutex) {
0:             this.peer = peer;
1:     public void oneway(Object command) throws IOException {
0:         if (disposed) {
0:         if (peer == null)
0:         TransportListener tl = null;
0:         synchronized (peer.mutex) {
0:             if (peer.disposed) {
1:                 throw new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed.");
1:             }
0:             if (peer.started) {
0:                 if (peer.async) {
0:                     peer.wakeup();
0:                     tl = peer.transportListener;
0:             } else {
0:                 peer.enqueue(command);
1:             }
1:         }
1: 
0:         if (tl != null) {
0:             tl.onCommand(command);
1:         }
1: 
0:     private void enqueue(Object command) throws IOException {
0:         try {
0:             getMessageQueue().put(command);
0:         } catch (final InterruptedException e) {
0:             throw IOExceptionSupport.create(e);
1:         }
1:     }
1:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:     public Object request(Object command) throws IOException {
1:     public Object request(Object command, int timeout) throws IOException {
1:     public TransportListener getTransportListener() {
0:         synchronized (mutex) {
0:     public void setTransportListener(TransportListener commandListener) {
0:         synchronized (mutex) {
0:             this.transportListener = commandListener;
0:         synchronized (mutex) {
0:             if (messageQueue == null) {
0:                 messageQueue = new LinkedBlockingQueue(this.asyncQueueDepth);
1:             }
0:             return messageQueue;
1:         }
1: 
0:     public void start() throws Exception {
0:         if (transportListener == null)
1: 
0:         synchronized (mutex) {
0:             if (messageQueue != null) {
0:                 Object command;
0:                 while ((command = messageQueue.poll()) != null) {
0:                     transportListener.onCommand(command);
1:                 }
1:             }
0:             started = true;
0:     public void stop() throws Exception {
0:         TaskRunner tr = null;
0:         synchronized (mutex) {
0:             if (!disposed) {
0:                 started = false;
0:                 disposed = true;
0:                 if (taskRunner != null) {
0:                     tr = taskRunner;
0:                     taskRunner = null;
0:         if (tr != null) {
0:             tr.shutdown(1000);
1:         }
0:     public Object narrow(Class target) {
1:         if (target.isAssignableFrom(getClass())) {
1:     public boolean isMarshal() {
1:     public void setMarshal(boolean marshal) {
1:         this.marshal = marshal;
0:     public boolean isNetwork() {
0:     public void setNetwork(boolean network) {
0:         this.network = network;
1:     public String toString() {
1:         return location + "#" + id;
1:     public String getRemoteAddress() {
1:         if (peer != null) {
/////////////////////////////////////////////////////////////////////////
0:     public boolean iterate() {
0:         synchronized (mutex) {
0:             tl = transportListener;
0:             if (!started || disposed || tl == null)
1:                 return false;
1: 
0:         final Command command = (Command)mq.poll();
0:         if (command != null) {
1:             return false;
1:         }
1:     public boolean isAsync() {
1:     public void setAsync(boolean async) {
1:         this.async = async;
1:     public int getAsyncQueueDepth() {
1:     public void setAsyncQueueDepth(int asyncQueueDepth) {
1:         this.asyncQueueDepth = asyncQueueDepth;
1:     protected void wakeup() {
0:         if (async) {
0:             synchronized (mutex) {
0:                 if (taskRunner == null) {
0:                     taskRunner = taskRunnerFactory.createTaskRunner(this, "VMTransport: " + toString());
0:             try {
0:             } catch (InterruptedException e) {
1:     public boolean isFaultTolerant() {
commit:5ad4732
/////////////////////////////////////////////////////////////////////////
0:     	TaskRunner tr=null;
0:                 	tr = taskRunner;
0:     	if( tr !=null ) {
0:     		tr.shutdown(1000);
1:     	}
commit:ea74731
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	synchronized(peer.mutex) {
0:     		if( peer.disposed ) {
0:     			throw new TransportDisposedIOException("Peer ("+peer.toString()+") disposed.");
1:     		}
0:                 if(peer.async){
0:                     peer.enqueue(command);
0:         		    peer.wakeup();
0:                 } else {
0:                     tl = peer.transportListener;                   
1:                 }
0:         	} else {
0:         		peer.enqueue(command);
1:     	
0:     		tl.onCommand(command);
1:     	}
1:         
0: 	private void enqueue(Object command) throws IOException {
0: 		try{
0: 			getMessageQueue().put(command);
0: 		}catch(final InterruptedException e){
0: 		    throw IOExceptionSupport.create(e);
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
0:             wakeup();
0:     private LinkedBlockingQueue getMessageQueue() {
0:     	synchronized(mutex) {
0: 	        if( messageQueue==null ) {
0: 	            messageQueue=new LinkedBlockingQueue(this.asyncQueueDepth);
1: 	        }
0: 	        return messageQueue;
1:     	}
1:     }
1:     
1:     
1:         
0:         synchronized(mutex) {
0:         	if( messageQueue!=null ) {
0: 	           Object command;
0: 	           while( (command = messageQueue.poll()) !=null ) {
0: 	        	   transportListener.onCommand(command);
1: 	           }
1:         	}
0:             wakeup();
0:     	synchronized(mutex) {
/////////////////////////////////////////////////////////////////////////
0:         final TransportListener tl;
0:         	tl = transportListener;
0:         	if( !started || disposed || tl==null )
0:         		return false;
1:         
0:         LinkedBlockingQueue mq = getMessageQueue();
0:         final Command command = (Command)mq.poll();                
0:         if( command!=null ) {
0:             return !mq.isEmpty();
0:         } else {
0:         	return false;
1:     	}        
commit:3a7c673
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected boolean started;
0:     protected final Object startMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:     	TransportListener tl=null;
0:     	synchronized(peer.startMutex){
0:         	if( peer.started ) {
0:                 tl = peer.transportListener;
0:         	} else if(!peer.disposed) {
0:                 peer.prePeerSetQueue.add(command);
1:         	}
1:     	}
0:     	if( tl!=null ) {
/////////////////////////////////////////////////////////////////////////
0:         if(transportListener==null)
0:             throw new IOException("TransportListener not set.");
0:         synchronized(startMutex) {
0: 	        if( !prePeerSetQueue.isEmpty() ) {
0: 	            for(Iterator iter=prePeerSetQueue.iterator();iter.hasNext();){
0: 	                Command command=(Command)iter.next();
0: 	                transportListener.onCommand(command);
1: 	            }
0: 	            prePeerSetQueue.clear();
1: 	        } 
0: 	        started = true;
0: 	        if( isAsync() ) {
0: 	            peer.wakeup();
0: 	            wakeup();
1: 	        }
0:     	synchronized(startMutex) {
0:     	        started=false;
0:                 if(taskRunner!=null){
0:                     taskRunner.shutdown(1000);
0:                     taskRunner=null;
1:                 }
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.atomic.AtomicLong;
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void oneway(Object command) throws IOException{
/////////////////////////////////////////////////////////////////////////
0:     protected void syncOneWay(Object command){
/////////////////////////////////////////////////////////////////////////
0:     protected void asyncOneWay(Object command) throws IOException{
/////////////////////////////////////////////////////////////////////////
0:     public FutureResponse asyncRequest(Object command,ResponseCallback responseCallback) throws IOException{
0:     public Object request(Object command) throws IOException{
0:     public Object request(Object command,int timeout) throws IOException{
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:40958b6
/////////////////////////////////////////////////////////////////////////
0:         } else {
0:             throw new IOException("Peer disconnected.");
commit:84fd773
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.ResponseCallback;
/////////////////////////////////////////////////////////////////////////
0:     public FutureResponse asyncRequest(Command command, ResponseCallback responseCallback) throws IOException{
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.vm;
1: 
1: import java.io.IOException;
1: import java.net.URI;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
1: 
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.Response;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicLong;
1: /**
1:  * A Transport implementation that uses direct method invocations.
0:  * 
0:  * @version $Revision$
1:  */
0: public class VMTransport implements Transport{
0:     private static final Log log=LogFactory.getLog(VMTransport.class);
0:     private static final AtomicLong nextId = new AtomicLong(0);
1:     
1:     protected VMTransport peer;
1:     protected TransportListener transportListener;
0:     protected boolean disposed;
1:     protected boolean marshal;
0:     protected boolean network;
0:     protected List queue = Collections.synchronizedList(new LinkedList());
1:     protected final URI location;
1:     protected final long id;
1:     
0:     public VMTransport(URI location) {
0:         this.location = location;
0:         this.id=nextId.getAndIncrement();
0:     }
1: 
0:     synchronized public VMTransport getPeer(){
0:         return peer;
0:     }
1: 
0:     synchronized public void setPeer(VMTransport peer){
0:         this.peer=peer;
0:     }
1: 
0:     public void oneway(Command command) throws IOException{
0:         if(disposed)
0:             throw new IOException("Transport disposed.");
0:         if(peer==null)
1:             throw new IOException("Peer not connected.");
0:         if (!peer.disposed){
0:             TransportListener tl = peer.transportListener;
0:             queue = peer.queue;
0:             if (tl != null){
0:                 tl.onCommand(command);
0:             }else {
0:                 queue.add(command);
0:             }
0:         }
0:     }
1: 
0:     public FutureResponse asyncRequest(Command command) throws IOException{
1:         throw new AssertionError("Unsupported Method");
0:     }
1: 
0:     public Response request(Command command) throws IOException{
1:         throw new AssertionError("Unsupported Method");
0:     }
1: 
0:     synchronized public void setTransportListener(TransportListener commandListener){
0:         this.transportListener=commandListener;
0:     }
1: 
0:     public synchronized void start() throws Exception{
0:         if(transportListener==null)
0:             throw new IOException("TransportListener not set.");
0:         for (Iterator iter = queue.iterator(); iter.hasNext();) {
0:             Command command = (Command) iter.next();
0:             transportListener.onCommand(command);
0:             iter.remove();
0:         }
0:     }
1: 
0:     public void stop() throws Exception{
0:         if(!disposed){
0:             disposed=true;
0:         }
0:     }
1: 
0:     public Object narrow(Class target){
0:         if(target.isAssignableFrom(getClass())){
0:             return this;
0:         }
1:         return null;
0:     }
1: 
0:     public boolean isMarshal(){
1:         return marshal;
0:     }
1: 
0:     public void setMarshal(boolean marshal){
0:         this.marshal=marshal;
0:     }
1: 
0:     public boolean isNetwork(){
0:         return network;
0:     }
1: 
0:     public void setNetwork(boolean network){
0:         this.network=network;
0:     }
1:     
0:     public String toString() {
0:         return location+"#"+id;
0:     }
1: 
0: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:4e19892
/////////////////////////////////////////////////////////////////////////
1:                     String name = "ActiveMQ VMTransport: " + toString();
1:                         taskRunnerFactory = new TaskRunnerFactory(name);
1:                     taskRunner = result = taskRunnerFactory.createTaskRunner(this, name);
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private TaskRunnerFactory taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:                 taskRunner = null;
/////////////////////////////////////////////////////////////////////////
0: 
1:             // shutdown task runner factory
1:             if (taskRunnerFactory != null) {
1:                 taskRunnerFactory.shutdownNow();
1:                 taskRunnerFactory = null;
0:             }
/////////////////////////////////////////////////////////////////////////
1:                     if (taskRunnerFactory == null) {
0:                         taskRunnerFactory = new TaskRunnerFactory("ActiveMQ VMTransport: " + toString());
1:                         taskRunnerFactory.init();
0:                     }
0:                     taskRunner = result = taskRunnerFactory.createTaskRunner(this, "VMTransport: " + toString());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:e0bb36b
/////////////////////////////////////////////////////////////////////////
1:             // Lock here on the target transport's started since we want to wait for its start()
1:             // method to finish dispatching out of the queue before we do our own.
1:             synchronized (transport.started) {
commit:ad585dc
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.BlockingQueue;
0: 
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     // Transport Configuration
/////////////////////////////////////////////////////////////////////////
1:     // Implementation
0:     private LinkedBlockingQueue<Object> messageQueue;
0:     private TaskRunner taskRunner;
0: 
1:     // Transport State
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
1:             if (peer.disposed.get()) {
0:             if (peer.async || !peer.started.get()) {
0:                 peer.getMessageQueue().put(command);
0:                 peer.wakeup();
1:                 return;
0: 
0: 
1:         dispatch(peer, peer.messageQueue, command);
1:     public void dispatch(VMTransport transport, BlockingQueue<Object> pending, Object command) {
1:         TransportListener transportListener = transport.getTransportListener();
1:             synchronized (started) {
0: 
1:                 // Ensure that no additional commands entered the queue in the small time window
1:                 // before the start method locks the dispatch lock and the oneway method was in
1:                 // an put operation.
1:                 while(pending != null && !pending.isEmpty() && !transport.isDisposed()) {
1:                     doDispatch(transport, transportListener, pending.poll());
0:                 }
0: 
1:                 // We are now in sync mode and won't enqueue any more commands to the target
1:                 // transport so lets clean up its resources.
1:                 transport.messageQueue = null;
0: 
1:                 // Don't dispatch if either end was disposed already.
1:                 if (command != null && !this.disposed.get() && !transport.isDisposed()) {
1:                     doDispatch(transport, transportListener, command);
0:                 }
1:     public void doDispatch(VMTransport transport, TransportListener transportListener, Object command) {
0:         if (command == DISCONNECT) {
0:             transportListener.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:         } else {
0:             transport.receiveCounter++;
0:             transportListener.onCommand(command);
0:         }
0:     }
0: 
0:         if (transportListener == null) {
0:             throw new IOException("TransportListener not set.");
0:         }
1:         // If we are not in async mode we lock the dispatch lock here and then start to
1:         // prevent any sync dispatches from occurring until we dispatch the pending messages
1:         // to maintain delivery order.  When async this happens automatically so just set
1:         // started and wakeup the task runner.
1:         if (!async) {
1:             synchronized (started) {
1:                 if (started.compareAndSet(false, true)) {
0:                     LinkedBlockingQueue<Object> mq = getMessageQueue();
0:                     Object command;
1:                     while ((command = mq.poll()) != null && !disposed.get() ) {
0:                         receiveCounter++;
1:                         doDispatch(this, transportListener, command);
0:         } else {
1:             if (started.compareAndSet(false, true)) {
0:                 wakeup();
0:             }
1:         // Only need to do this once, all future oneway calls will now
1:         // fail as will any asnyc jobs in the task runner.
0: 
1:             TaskRunner tr = taskRunner;
1:             LinkedBlockingQueue<Object> mq = this.messageQueue;
0: 
0:             taskRunner = null;
0:             messageQueue = null;
0: 
1:             if (mq != null) {
1:                 mq.clear();
0:             }
0: 
0:             // Allow pending deliveries to finish up, but don't wait
0:             // forever in case of an stalled onCommand.
0:             if (tr != null) {
0:                 try {
0:                     tr.shutdown(TimeUnit.SECONDS.toMillis(1));
1:                 } catch(Exception e) {
0:                 }
0:             }
0: 
0:             // let the peer know that we are disconnecting after attempting
0:             // to cleanly shutdown the async tasks so that this is the last
0:             // command it see's.
0:         }
0:     }
0:     protected void wakeup() {
1:         if (async && started.get()) {
0:             try {
1:                 getTaskRunner().wakeup();
0:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
1:             } catch (TransportDisposedIOException e) {
/////////////////////////////////////////////////////////////////////////
1:         final TransportListener tl = transportListener;
0: 
1:         LinkedBlockingQueue<Object> mq;
0:         try {
1:             mq = getMessageQueue();
1:         } catch (TransportDisposedIOException e) {
1:         if (command != null && !disposed.get()) {
0:             if( command == DISCONNECT ) {
0:                 tl.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:                 tl.onCommand(command);
1:             return !mq.isEmpty() && !disposed.get();
1:             if(disposed.get()) {
1:                 mq.clear();
0:             }
/////////////////////////////////////////////////////////////////////////
0:     public void setMessageQueue(LinkedBlockingQueue<Object> asyncQueue) {
1:         synchronized (this) {
0:             if (messageQueue == null) {
0:                 messageQueue = asyncQueue;
0:             }
0:         }
0:     }
0: 
1:     public LinkedBlockingQueue<Object> getMessageQueue() throws TransportDisposedIOException {
1:         LinkedBlockingQueue<Object> result = messageQueue;
1:         if (result == null) {
1:             synchronized (this) {
1:                 result = messageQueue;
1:                 if (result == null) {
1:                     if (disposed.get()) {
1:                         throw new TransportDisposedIOException("The Transport has been disposed");
0:                     }
0: 
1:                     messageQueue = result = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);
0:                 }
0:             }
0:         }
1:         return result;
0:     }
0: 
1:     protected TaskRunner getTaskRunner() throws TransportDisposedIOException {
1:         TaskRunner result = taskRunner;
1:         if (result == null) {
1:             synchronized (this) {
1:                 result = taskRunner;
1:                 if (result == null) {
1:                     if (disposed.get()) {
1:                         throw new TransportDisposedIOException("The Transport has been disposed");
0:                     }
0: 
0:                     taskRunner = result = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(this, "VMTransport: " + toString());
0:                 }
0:             }
0:         }
1:         return result;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return !disposed.get();
1:         throw new IOException("Transport reconnect is not supported");
/////////////////////////////////////////////////////////////////////////
1:     public void updateURIs(boolean reblance,URI[] uris) throws IOException {
1:         throw new IOException("URI update feature not supported");
commit:6595dc4
/////////////////////////////////////////////////////////////////////////
0:     protected final AtomicBoolean stopping = new AtomicBoolean();
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:80a7ec5
/////////////////////////////////////////////////////////////////////////
0:         dispatch(peer, transportListener, command);
0:     }
0:     
0:     public void dispatch(VMTransport transport, TransportListener transportListener, Object command) {
0:                 transport.receiveCounter++;
/////////////////////////////////////////////////////////////////////////
0:                     dispatch(this, transportListener, command);
/////////////////////////////////////////////////////////////////////////
0:         	
0:             // let the peer know that we are disconnecting..
0:             try {
0:             	peer.transportListener.onException(new TransportDisposedIOException("Peer (" + peer.toString() + ") disposed."));
0:             } catch (Exception ignore) {
0:             }
0:         	
0:         	
/////////////////////////////////////////////////////////////////////////
0:             
0: 
0:         
commit:a5ac040
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // let the peer know that we are disconnecting..
0:             try {
0:                 oneway(DISCONNECT);
0:             } catch (Exception ignore) {
0:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:909c1c3
/////////////////////////////////////////////////////////////////////////
0: import java.io.InterruptedIOException;
/////////////////////////////////////////////////////////////////////////
1:             InterruptedIOException iioe = new InterruptedIOException(e.getMessage());
1:             iioe.initCause(e);
1:             throw iioe;
commit:f392884
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         throw new IOException("Not supported");
0:     }
0: 
1:     public boolean isReconnectSupported() {
0:         return false;
0:     }
0: 
1:     public boolean isUpdateURIsSupported() {
0:         return false;
0:     }
0:     public void updateURIs(boolean reblance,URI[] uris) throws IOException {
0:         throw new IOException("Not supported");
0:     }
commit:ecc87ea
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	public boolean isConnected() {
0: 	    return started;
0: 	}
commit:3ac0537
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public boolean isDisposed() {
0: 		return disposed;
0: 	}
0: 
0: 	public void reconnect(URI uri) throws IOException {
0: 		throw new IOException("Not supported");
0: 	}
commit:6b7055a
/////////////////////////////////////////////////////////////////////////
0: 
commit:c7469c4
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean isFaultTolerant(){
0:         return false;
0:     }
commit:da13d59
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean async=true;
0:     protected AtomicBoolean started=new AtomicBoolean();
0:     private final Object mutex=new Object();
0:     public VMTransport getPeer(){
0:         synchronized(mutex){
0:             return peer;
0:         }
0:     public void setPeer(VMTransport peer){
0:         synchronized(mutex){
0:             this.peer=peer;
0:         }
/////////////////////////////////////////////////////////////////////////
0:     protected void asyncOneWay(Object command) throws IOException{
0:             synchronized(mutex){
0:                 if(messageQueue==null){
0:                     messageQueue=new LinkedBlockingQueue(this.asyncQueueDepth);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     public TransportListener getTransportListener(){
0:         synchronized(mutex){
0:             return transportListener;
0:         }
0:     public void setTransportListener(TransportListener commandListener){
0:         synchronized(mutex){
0:             this.transportListener=commandListener;
0:         }
0:     public void start() throws Exception{
0:         if(started.compareAndSet(false,true)){
0:             if(transportListener==null)
0:                 throw new IOException("TransportListener not set.");
0:             if(!async){
0:                 for(Iterator iter=prePeerSetQueue.iterator();iter.hasNext();){
0:                     Command command=(Command)iter.next();
0:                     transportListener.onCommand(command);
0:                     iter.remove();
0:                 }
0:             }else{
0:                 peer.wakeup();
0:                 wakeup();
0:     public void stop() throws Exception{
0:         if(started.compareAndSet(true,false)){
0:             if(!disposed){
0:                 disposed=true;
0:             }
0:             if(taskRunner!=null){
0:                 taskRunner.shutdown(1000);
0:                 taskRunner=null;
0:             }
/////////////////////////////////////////////////////////////////////////
0:         synchronized(mutex){
0:             if(messageQueue!=null&&!disposed&&!peer.disposed&&tl!=null&&!messageQueue.isEmpty()){
0:         if(tl!=null&&command!=null){
0:             tl.onCommand(command);
0:         }
0:         boolean result=messageQueue!=null&&!messageQueue.isEmpty()&&!peer.disposed;
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:     protected void wakeup(){
0:             synchronized(mutex){
0:                 if(taskRunner==null){
0:                     taskRunner=taskRunnerFactory.createTaskRunner(this,"VMTransport: "+toString());
0:                 }
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:55fa954
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Message;
/////////////////////////////////////////////////////////////////////////
0:         if (command instanceof Message) {
0:             command = ((Message)command).copy();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (command instanceof Message) {
0:             command = ((Message)command).copy();
0:         }
commit:8613f58
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
commit:f19a3a6
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerStoppedException;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             true,1000);
/////////////////////////////////////////////////////////////////////////
0:     protected LinkedBlockingQueue messageQueue=null;
/////////////////////////////////////////////////////////////////////////
0:                 asyncOneWay(command);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected synchronized void asyncOneWay(Object command) throws IOException{
0:             if(messageQueue==null){
0:                 messageQueue=new LinkedBlockingQueue(this.asyncQueueDepth);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 Command command=(Command)iter.next();
0:             wakeup();
0:     public synchronized void stop() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:         Command command=null;
0:         // if(!disposed && !messageQueue.isEmpty()&&!peer.disposed&&tl!=null){
0:         synchronized(this){
0:             if(messageQueue!=null&&!disposed&&!peer.disposed&&tl!=null &&!messageQueue.isEmpty()){
0:                 command=(Command)messageQueue.poll();
0:                 if (command != null) {
0:                     tl.onCommand(command);
0:                 }
0:             }
0:         return messageQueue!=null&&!messageQueue.isEmpty()&&!peer.disposed;
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void wakeup(){
0:         if(async){
/////////////////////////////////////////////////////////////////////////
commit:bc005fd
/////////////////////////////////////////////////////////////////////////
0:            
0:             if(async){
0:                asyncOneWay(command); 
0:                 syncOneWay(command);
0:     
0:     protected void syncOneWay(Command command){
0:         final TransportListener tl=peer.transportListener;
0:         prePeerSetQueue=peer.prePeerSetQueue;
0:         if(tl==null){
0:             prePeerSetQueue.add(command);
0:         }else{
0:             tl.onCommand(command);
0:         }
0:     }
0:     
0:     protected void asyncOneWay(Command command) throws IOException{
0:         messageQueue=getMessageQueue();
0:         try{
0:             messageQueue.put(command);
0:             wakeup();
0:         }catch(final InterruptedException e){
0:             log.error("messageQueue interupted",e);
0:             throw new IOException(e.getMessage());
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
0:         peer.wakeup();
0:         if(!async){
0:             for(Iterator iter=prePeerSetQueue.iterator();iter.hasNext();){
0:                 Command command=(Command) iter.next();
0:                 transportListener.onCommand(command);
0:                 iter.remove();
0:             }
0:         }else{
0:             wakeup();
0:             peer.wakeup();
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @see org.apache.activemq.thread.Task#iterate()
1:      */
0:         final TransportListener tl=peer.transportListener;
0:             final Command command=(Command) messageQueue.poll();
0:             tl.onCommand(command);
commit:aaccbd3
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
0: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.transport.TransportDisposedIOException;
0: import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
0: public class VMTransport implements Transport,Task{
0:     private static final AtomicLong nextId=new AtomicLong(0);
0:     private static final TaskRunnerFactory taskRunnerFactory=new TaskRunnerFactory("VMTransport",Thread.NORM_PRIORITY,
0:                     true,1000);
0:     protected boolean async=false;
0:     protected boolean started=false;
0:     protected int asyncQueueDepth=2000;
0:     protected List prePeerSetQueue=Collections.synchronizedList(new LinkedList());
0:     protected LinkedBlockingQueue messageQueue;
0:     private TaskRunner taskRunner;
0: 
0:     public VMTransport(URI location){
0:         this.location=location;
/////////////////////////////////////////////////////////////////////////
0:         if(disposed){
1:             throw new TransportDisposedIOException("Transport disposed.");
0:         }
0:         if(!peer.disposed){
0:             final TransportListener tl=peer.transportListener;
0:             messageQueue=getMessageQueue();
0:             prePeerSetQueue=peer.prePeerSetQueue;
0:             if(tl==null){
0:                 prePeerSetQueue.add(command);
0:             }else if(!async){
0:             }else{
0:                 try{
0:                     messageQueue.put(command);
0:                     wakeup();
0:                 }catch(final InterruptedException e){
0:                     log.error("messageQueue interuppted",e);
0:                     throw new IOException(e.getMessage());
0:                 }
0:         }else{
0:             throw new TransportDisposedIOException("Peer ("+peer.toString()+") disposed.");
0:     public FutureResponse asyncRequest(Command command,ResponseCallback responseCallback) throws IOException{
0: 
0:     public Response request(Command command,int timeout) throws IOException{
0:     public synchronized TransportListener getTransportListener(){
0:         wakeup();
0:         started=true;
0:         for(Iterator iter=prePeerSetQueue.iterator();iter.hasNext();){
0:             Command command=(Command) iter.next();
0:         wakeup();
0:         started=false;
0:         if(taskRunner!=null){
0:             taskRunner.shutdown();
0:             taskRunner=null;
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public String toString(){
0:     public String getRemoteAddress(){
0:         if(peer!=null){
1:             return peer.toString();
0:         }
1:         return null;
0:     }
0:     // task implementation
0:     public boolean iterate(){
0:         TransportListener tl=peer.transportListener;
0:         if(!messageQueue.isEmpty()&&!peer.disposed&&tl!=null){
0:             Command command=(Command) messageQueue.poll();
0:             if(tl!=null){
0:                 tl.onCommand(command);
0:             }
0:         }
0:         return !messageQueue.isEmpty()&&!peer.disposed&&!(peer.transportListener==null);
0:     }
0: 
1:     /**
1:      * @return the async
1:      */
0:     public boolean isAsync(){
1:         return async;
0:     }
0: 
1:     /**
1:      * @param async the async to set
1:      */
0:     public void setAsync(boolean async){
0:         this.async=async;
0:     }
0: 
1:     /**
1:      * @return the asyncQueueDepth
1:      */
0:     public int getAsyncQueueDepth(){
1:         return asyncQueueDepth;
0:     }
0: 
1:     /**
1:      * @param asyncQueueDepth the asyncQueueDepth to set
1:      */
0:     public void setAsyncQueueDepth(int asyncQueueDepth){
0:         this.asyncQueueDepth=asyncQueueDepth;
0:     }
0: 
0:     protected void wakeup(){
0:         if(async&&messageQueue!=null&&!messageQueue.isEmpty()){
0:             if(taskRunner==null){
0:                 taskRunner=taskRunnerFactory.createTaskRunner(this,"VMTransport: "+toString());
0:             }
0:             try{
0:                 taskRunner.wakeup();
0:             }catch(InterruptedException e){
0:                 Thread.currentThread().interrupt();
0:             }
0:         }
0:     }
0: 
0:     protected synchronized LinkedBlockingQueue getMessageQueue(){
0:         if(messageQueue==null){
0:             messageQueue=new LinkedBlockingQueue(this.asyncQueueDepth);
0:         }
0:         return messageQueue;
0:     }
commit:5fe0a4c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Response request(Command command,int timeout) throws IOException {
1:         throw new AssertionError("Unsupported Method");
0:     }
author:David Jencks
-------------------------------------------------------------------------------
commit:e585aae
/////////////////////////////////////////////////////////////////////////
author:James Strachan
-------------------------------------------------------------------------------
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
0: 	public String getRemoteAddress() {
0: 		if(peer != null){
0: 			return peer.toString();
0: 		}
0: 		return null;
0: 	}
0: 
commit:436fe42
/////////////////////////////////////////////////////////////////////////
0:     public synchronized TransportListener getTransportListener() {
0:         return transportListener;
0:     }
0: 
============================================================================