1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
4:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.command;
30:d29ca2a: 
1:74a7a8b: import java.io.Externalizable;
1:74a7a8b: import java.io.IOException;
1:74a7a8b: import java.io.ObjectInput;
1:74a7a8b: import java.io.ObjectOutput;
1:74a7a8b: import java.net.URISyntaxException;
1:74a7a8b: import java.util.ArrayList;
1:be919fb: import java.util.HashMap;
1:f8b0c22: import java.util.HashSet;
1:ecf89a6: import java.util.List;
1:74a7a8b: import java.util.Map;
1:74a7a8b: import java.util.Properties;
1:f8b0c22: import java.util.Set;
1:74a7a8b: import java.util.StringTokenizer;
1:d29ca2a: 
1:d29ca2a: import javax.jms.Destination;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.Queue;
1:d29ca2a: import javax.jms.TemporaryQueue;
1:d29ca2a: import javax.jms.TemporaryTopic;
1:d29ca2a: import javax.jms.Topic;
1:74a7a8b: 
1:ee4672b: import org.apache.activemq.filter.AnyDestination;
1:ee4672b: import org.apache.activemq.filter.DestinationFilter;
1:74a7a8b: import org.apache.activemq.jndi.JNDIBaseStorable;
1:74a7a8b: import org.apache.activemq.util.IntrospectionSupport;
1:74a7a8b: import org.apache.activemq.util.URISupport;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * @openwire:marshaller
1:d29ca2a:  */
1:f220607: public abstract class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination, Externalizable, Comparable<Object> {
1:d29ca2a: 
1:d29ca2a:     public static final String PATH_SEPERATOR = ".";
1:477fc85:     public static final char COMPOSITE_SEPERATOR = ',';
1:230a86c: 
1:230a86c:     public static final byte QUEUE_TYPE = 0x01;
1:230a86c:     public static final byte TOPIC_TYPE = 0x02;
1:230a86c:     public static final byte TEMP_MASK = 0x04;
1:d29ca2a:     public static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK;
1:d29ca2a:     public static final byte TEMP_QUEUE_TYPE = QUEUE_TYPE | TEMP_MASK;
1:230a86c: 
1:230a86c:     public static final String QUEUE_QUALIFIED_PREFIX = "queue://";
1:230a86c:     public static final String TOPIC_QUALIFIED_PREFIX = "topic://";
1:230a86c:     public static final String TEMP_QUEUE_QUALIFED_PREFIX = "temp-queue://";
1:d29ca2a:     public static final String TEMP_TOPIC_QUALIFED_PREFIX = "temp-topic://";
1:be919fb:     public static final String IS_DLQ = "isDLQ";
1:d29ca2a: 
1:0eae288:     public static final String TEMP_DESTINATION_NAME_PREFIX = "ID:";
1:d29ca2a: 
1:ecf89a6:     private static final long serialVersionUID = -3885260014960795889L;
1:ecf89a6: 
1:d29ca2a:     protected String physicalName;
1:230a86c: 
1:fc00993:     protected transient ActiveMQDestination[] compositeDestinations;
1:fc00993:     protected transient String[] destinationPaths;
1:fc00993:     protected transient boolean isPattern;
1:fc00993:     protected transient int hashValue;
1:ecf89a6:     protected Map<String, String> options;
1:ecf89a6: 
1:713dcaa:     protected static UnresolvedDestinationTransformer unresolvableDestinationTransformer = new DefaultUnresolvedDestinationTransformer();
1:230a86c: 
1:ecf89a6:     public ActiveMQDestination() {
1:ecf89a6:     }
1:ecf89a6: 
1:ecf89a6:     protected ActiveMQDestination(String name) {
1:ecf89a6:         setPhysicalName(name);
1:ecf89a6:     }
1:ecf89a6: 
1:ecf89a6:     public ActiveMQDestination(ActiveMQDestination composites[]) {
1:ecf89a6:         setCompositeDestinations(composites);
1:ecf89a6:     }
1:ecf89a6: 
1:8f22cfa:     // static helper methods for working with destinations
1:8f22cfa:     // -------------------------------------------------------------------------
1:fc00993:     public static ActiveMQDestination createDestination(String name, byte defaultType) {
1:230a86c:         if (name.startsWith(QUEUE_QUALIFIED_PREFIX)) {
1:d29ca2a:             return new ActiveMQQueue(name.substring(QUEUE_QUALIFIED_PREFIX.length()));
1:230a86c:         } else if (name.startsWith(TOPIC_QUALIFIED_PREFIX)) {
1:d29ca2a:             return new ActiveMQTopic(name.substring(TOPIC_QUALIFIED_PREFIX.length()));
1:230a86c:         } else if (name.startsWith(TEMP_QUEUE_QUALIFED_PREFIX)) {
1:d29ca2a:             return new ActiveMQTempQueue(name.substring(TEMP_QUEUE_QUALIFED_PREFIX.length()));
1:230a86c:         } else if (name.startsWith(TEMP_TOPIC_QUALIFED_PREFIX)) {
1:d29ca2a:             return new ActiveMQTempTopic(name.substring(TEMP_TOPIC_QUALIFED_PREFIX.length()));
1:ecf89a6:         }
1:230a86c: 
1:230a86c:         switch (defaultType) {
1:b1d46e4:             case QUEUE_TYPE:
1:b1d46e4:                 return new ActiveMQQueue(name);
1:b1d46e4:             case TOPIC_TYPE:
1:b1d46e4:                 return new ActiveMQTopic(name);
1:b1d46e4:             case TEMP_QUEUE_TYPE:
1:b1d46e4:                 return new ActiveMQTempQueue(name);
1:b1d46e4:             case TEMP_TOPIC_TYPE:
1:b1d46e4:                 return new ActiveMQTempTopic(name);
1:b1d46e4:             default:
1:b1d46e4:                 throw new IllegalArgumentException("Invalid default destination type: " + defaultType);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public static ActiveMQDestination transform(Destination dest) throws JMSException {
1:ecf89a6:         if (dest == null) {
1:d29ca2a:             return null;
1:ecf89a6:         }
1:ecf89a6:         if (dest instanceof ActiveMQDestination) {
1:b1d46e4:             return (ActiveMQDestination) dest;
1:ecf89a6:         }
1:230a86c: 
1:f33e219:         if (dest instanceof Queue && dest instanceof Topic) {
1:f33e219:             String queueName = ((Queue) dest).getQueueName();
1:f33e219:             String topicName = ((Topic) dest).getTopicName();
1:f33e219:             if (queueName != null && topicName == null) {
1:f33e219:                 return new ActiveMQQueue(queueName);
1:f33e219:             } else if (queueName == null && topicName != null) {
1:f33e219:                 return new ActiveMQTopic(topicName);
1:d29ca2a:             } else {
1:713dcaa:                 return unresolvableDestinationTransformer.transform(dest);
1:d29ca2a:             }
1:d29ca2a:         }
1:ecf89a6:         if (dest instanceof TemporaryQueue) {
1:b1d46e4:             return new ActiveMQTempQueue(((TemporaryQueue) dest).getQueueName());
1:ecf89a6:         }
1:ecf89a6:         if (dest instanceof TemporaryTopic) {
1:b1d46e4:             return new ActiveMQTempTopic(((TemporaryTopic) dest).getTopicName());
1:ecf89a6:         }
1:ecf89a6:         if (dest instanceof Queue) {
1:b1d46e4:             return new ActiveMQQueue(((Queue) dest).getQueueName());
1:ecf89a6:         }
1:ecf89a6:         if (dest instanceof Topic) {
1:b1d46e4:             return new ActiveMQTopic(((Topic) dest).getTopicName());
1:ecf89a6:         }
1:230a86c:         throw new JMSException("Could not transform the destination into a ActiveMQ destination: " + dest);
1:f33e219:     }
1:230a86c: 
1:8f22cfa:     public static int compare(ActiveMQDestination destination, ActiveMQDestination destination2) {
1:8f22cfa:         if (destination == destination2) {
1:8f22cfa:             return 0;
1:f33e219:         }
1:ee4672b:         if (destination == null || destination2 instanceof AnyDestination) {
1:8f22cfa:             return -1;
1:ee4672b:         } else if (destination2 == null || destination instanceof AnyDestination) {
1:8f22cfa:             return 1;
1:230a86c:         } else {
1:ee4672b:             if (destination.getDestinationType() == destination2.getDestinationType()) {
1:679db08: 
1:679db08:                 if (destination.isPattern() && destination2.isPattern() ) {
1:679db08:                     if (destination.getPhysicalName().compareTo(destination2.getPhysicalName()) == 0) {
1:679db08:                         return 0;
1:679db08:                     }
1:679db08:                 }
1:ee4672b:                 if (destination.isPattern()) {
1:ee4672b:                     DestinationFilter filter = DestinationFilter.parseFilter(destination);
1:ee4672b:                     if (filter.matches(destination2)) {
1:ee4672b:                         return 1;
1:ee4672b:                     }
1:ee4672b:                 }
1:ee4672b:                 if (destination2.isPattern()) {
1:ee4672b:                     DestinationFilter filter = DestinationFilter.parseFilter(destination2);
1:ee4672b:                     if (filter.matches(destination)) {
1:ee4672b:                         return -1;
1:ee4672b:                     }
1:ee4672b:                 }
1:8f22cfa:                 return destination.getPhysicalName().compareTo(destination2.getPhysicalName());
1:ee4672b: 
1:230a86c:             } else {
1:8f22cfa:                 return destination.isQueue() ? -1 : 1;
4:8f22cfa:             }
1:8f22cfa:         }
1:8f22cfa:     }
1:230a86c: 
1:f220607:     @Override
1:8f22cfa:     public int compareTo(Object that) {
1:8f22cfa:         if (that instanceof ActiveMQDestination) {
1:b1d46e4:             return compare(this, (ActiveMQDestination) that);
1:8f22cfa:         }
1:8f22cfa:         if (that == null) {
1:8f22cfa:             return 1;
1:230a86c:         } else {
1:8f22cfa:             return getClass().getName().compareTo(that.getClass().getName());
1:8f22cfa:         }
1:8f22cfa:     }
1:230a86c: 
1:d29ca2a:     public boolean isComposite() {
1:230a86c:         return compositeDestinations != null;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public ActiveMQDestination[] getCompositeDestinations() {
1:d29ca2a:         return compositeDestinations;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setCompositeDestinations(ActiveMQDestination[] destinations) {
1:230a86c:         this.compositeDestinations = destinations;
1:230a86c:         this.destinationPaths = null;
1:230a86c:         this.hashValue = 0;
1:230a86c:         this.isPattern = false;
1:230a86c: 
1:230a86c:         StringBuffer sb = new StringBuffer();
1:d29ca2a:         for (int i = 0; i < destinations.length; i++) {
1:ecf89a6:             if (i != 0) {
1:d29ca2a:                 sb.append(COMPOSITE_SEPERATOR);
1:ecf89a6:             }
1:230a86c:             if (getDestinationType() == destinations[i].getDestinationType()) {
1:b2039fb:                 sb.append(destinations[i].getPhysicalName());
1:d29ca2a:             } else {
2:d29ca2a:                 sb.append(destinations[i].getQualifiedName());
1:230a86c:             }
1:d29ca2a:         }
1:d29ca2a:         physicalName = sb.toString();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public String getQualifiedName() {
1:ecf89a6:         if (isComposite()) {
1:d29ca2a:             return physicalName;
1:ecf89a6:         }
1:230a86c:         return getQualifiedPrefix() + physicalName;
1:d29ca2a:     }
1:230a86c: 
1:fc00993:     protected abstract String getQualifiedPrefix();
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public String getPhysicalName() {
1:d29ca2a:         return physicalName;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void setPhysicalName(String physicalName) {
1:f220607:         physicalName = physicalName.trim();
1:b1d46e4:         final int length = physicalName.length();
1:b1d46e4: 
1:b1d46e4:         if (physicalName.isEmpty()) {
1:b1d46e4:             throw new IllegalArgumentException("Invalid destination name: a non-empty name is required");
1:b1d46e4:         }
1:b1d46e4: 
1:f812e34:         // options offset
1:f812e34:         int p = -1;
1:230a86c:         boolean composite = false;
1:b1d46e4:         for (int i = 0; i < length; i++) {
1:230a86c:             char c = physicalName.charAt(i);
1:230a86c:             if (c == '?') {
1:230a86c:                 p = i;
1:477fc85:                 break;
1:d29ca2a:             }
1:230a86c:             if (c == COMPOSITE_SEPERATOR) {
1:477fc85:                 // won't be wild card
1:230a86c:                 isPattern = false;
1:230a86c:                 composite = true;
1:230a86c:             } else if (!composite && (c == '*' || c == '>')) {
1:230a86c:                 isPattern = true;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         // Strip off any options
1:230a86c:         if (p >= 0) {
1:230a86c:             String optstring = physicalName.substring(p + 1);
1:230a86c:             physicalName = physicalName.substring(0, p);
1:230a86c:             try {
1:230a86c:                 options = URISupport.parseQuery(optstring);
1:230a86c:             } catch (URISyntaxException e) {
1:ecf89a6:                 throw new IllegalArgumentException("Invalid destination name: " + physicalName + ", it's options are not encoded properly: " + e);
1:d29ca2a:             }
1:d29ca2a:         }
1:230a86c:         this.physicalName = physicalName;
1:230a86c:         this.destinationPaths = null;
1:230a86c:         this.hashValue = 0;
1:230a86c:         if (composite) {
1:d29ca2a:             // Check to see if it is a composite.
1:f8b0c22:             Set<String> l = new HashSet<String>();
1:230a86c:             StringTokenizer iter = new StringTokenizer(physicalName, "" + COMPOSITE_SEPERATOR);
1:230a86c:             while (iter.hasMoreTokens()) {
1:230a86c:                 String name = iter.nextToken().trim();
1:ecf89a6:                 if (name.length() == 0) {
2:d29ca2a:                     continue;
1:ecf89a6:                 }
2:d29ca2a:                 l.add(name);
1:d29ca2a:             }
1:230a86c:             compositeDestinations = new ActiveMQDestination[l.size()];
1:230a86c:             int counter = 0;
1:230a86c:             for (String dest : l) {
1:230a86c:                 compositeDestinations[counter++] = createDestination(dest);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public ActiveMQDestination createDestination(String name) {
1:d29ca2a:         return createDestination(name, getDestinationType());
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public String[] getDestinationPaths() {
1:d29ca2a: 
1:ecf89a6:         if (destinationPaths != null) {
2:d29ca2a:             return destinationPaths;
1:d29ca2a:         }
1:230a86c: 
1:ecf89a6:         List<String> l = new ArrayList<String>();
1:e7e317d:         StringBuilder level = new StringBuilder();
1:e7e317d:         final char separator = PATH_SEPERATOR.charAt(0);
1:e7e317d:         for (char c : physicalName.toCharArray()) {
1:e7e317d:             if (c == separator) {
1:e7e317d:                 l.add(level.toString());
1:e7e317d:                 level.delete(0, level.length());
1:e7e317d:             } else {
1:e7e317d:                 level.append(c);
1:ecf89a6:             }
1:d29ca2a:         }
1:e7e317d:         l.add(level.toString());
1:d29ca2a: 
1:d29ca2a:         destinationPaths = new String[l.size()];
1:d29ca2a:         l.toArray(destinationPaths);
1:230a86c:         return destinationPaths;
1:d29ca2a:     }
1:230a86c: 
1:fc00993:     public abstract byte getDestinationType();
1:230a86c: 
1:d29ca2a:     public boolean isQueue() {
1:d29ca2a:         return false;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public boolean isTopic() {
1:d29ca2a:         return false;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public boolean isTemporary() {
1:d29ca2a:         return false;
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:d29ca2a:     public boolean equals(Object o) {
1:ecf89a6:         if (this == o) {
1:d29ca2a:             return true;
1:ecf89a6:         }
1:ecf89a6:         if (o == null || getClass() != o.getClass()) {
1:d29ca2a:             return false;
1:ecf89a6:         }
1:230a86c: 
1:b1d46e4:         ActiveMQDestination d = (ActiveMQDestination) o;
1:d29ca2a:         return physicalName.equals(d.physicalName);
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:d29ca2a:     public int hashCode() {
1:230a86c:         if (hashValue == 0) {
1:d29ca2a:             hashValue = physicalName.hashCode();
1:d29ca2a:         }
1:d29ca2a:         return hashValue;
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:d29ca2a:     public String toString() {
1:d29ca2a:         return getQualifiedName();
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:d29ca2a:     public void writeExternal(ObjectOutput out) throws IOException {
1:d29ca2a:         out.writeUTF(this.getPhysicalName());
1:d29ca2a:         out.writeObject(options);
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:933eb2f:     @SuppressWarnings("unchecked")
1:d29ca2a:     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
1:d29ca2a:         this.setPhysicalName(in.readUTF());
1:b1d46e4:         this.options = (Map<String, String>) in.readObject();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public String getDestinationTypeAsString() {
1:230a86c:         switch (getDestinationType()) {
1:b1d46e4:             case QUEUE_TYPE:
1:b1d46e4:                 return "Queue";
1:b1d46e4:             case TOPIC_TYPE:
1:b1d46e4:                 return "Topic";
1:b1d46e4:             case TEMP_QUEUE_TYPE:
1:b1d46e4:                 return "TempQueue";
1:b1d46e4:             case TEMP_TOPIC_TYPE:
1:b1d46e4:                 return "TempTopic";
1:b1d46e4:             default:
1:b1d46e4:                 throw new IllegalArgumentException("Invalid destination type: " + getDestinationType());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ecf89a6:     public Map<String, String> getOptions() {
1:d29ca2a:         return options;
1:d29ca2a:     }
1:230a86c: 
1:b1d46e4:     @Override
1:d29ca2a:     public boolean isMarshallAware() {
1:d29ca2a:         return false;
1:d29ca2a:     }
1:d29ca2a: 
1:b1d46e4:     @Override
1:b9a4dee:     public void buildFromProperties(Properties properties) {
1:b9a4dee:         if (properties == null) {
1:b9a4dee:             properties = new Properties();
1:d29ca2a:         }
1:d29ca2a: 
1:b9a4dee:         IntrospectionSupport.setProperties(this, properties);
1:d29ca2a:     }
1:d29ca2a: 
1:b1d46e4:     @Override
1:b9a4dee:     public void populateProperties(Properties props) {
1:b9a4dee:         props.setProperty("physicalName", getPhysicalName());
1:8f22cfa:     }
1:618d1d5: 
1:618d1d5:     public boolean isPattern() {
1:618d1d5:         return isPattern;
1:618d1d5:     }
1:d29ca2a: 
1:be919fb:     public boolean isDLQ() {
1:be919fb:         return options != null && options.containsKey(IS_DLQ);
1:be919fb:     }
1:be919fb: 
1:d2c0edd:     public void setDLQ(boolean val) {
1:be919fb:         if (options == null) {
1:be919fb:             options = new HashMap<String, String>();
1:be919fb:         }
1:d2c0edd:         options.put(IS_DLQ, String.valueOf(val));
1:be919fb:     }
1:be919fb: 
1:713dcaa:     public static UnresolvedDestinationTransformer getUnresolvableDestinationTransformer() {
1:713dcaa:         return unresolvableDestinationTransformer;
1:713dcaa:     }
1:d29ca2a: 
1:713dcaa:     public static void setUnresolvableDestinationTransformer(UnresolvedDestinationTransformer unresolvableDestinationTransformer) {
1:713dcaa:         ActiveMQDestination.unresolvableDestinationTransformer = unresolvableDestinationTransformer;
1:713dcaa:     }
1:8f22cfa: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:d2c0edd
/////////////////////////////////////////////////////////////////////////
1:     public void setDLQ(boolean val) {
1:         options.put(IS_DLQ, String.valueOf(val));
commit:679db08
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (destination.isPattern() && destination2.isPattern() ) {
1:                     if (destination.getPhysicalName().compareTo(destination2.getPhysicalName()) == 0) {
1:                         return 0;
1:                     }
1:                 }
commit:be919fb
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     public static final String IS_DLQ = "isDLQ";
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDLQ() {
1:         return options != null && options.containsKey(IS_DLQ);
1:     }
1: 
0:     public void setDLQ() {
1:         if (options == null) {
1:             options = new HashMap<String, String>();
1:         }
0:         options.put(IS_DLQ, String.valueOf(true));
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:ee4672b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.AnyDestination;
1: import org.apache.activemq.filter.DestinationFilter;
/////////////////////////////////////////////////////////////////////////
1:         if (destination == null || destination2 instanceof AnyDestination) {
1:         } else if (destination2 == null || destination instanceof AnyDestination) {
1:             if (destination.getDestinationType() == destination2.getDestinationType()) {
1:                 if (destination.isPattern()) {
1:                     DestinationFilter filter = DestinationFilter.parseFilter(destination);
1:                     if (filter.matches(destination2)) {
1:                         return 1;
1:                     }
1:                 }
1:                 if (destination2.isPattern()) {
1:                     DestinationFilter filter = DestinationFilter.parseFilter(destination2);
1:                     if (filter.matches(destination)) {
1:                         return -1;
1:                     }
1:                 }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:b1d46e4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             case QUEUE_TYPE:
1:                 return new ActiveMQQueue(name);
1:             case TOPIC_TYPE:
1:                 return new ActiveMQTopic(name);
1:             case TEMP_QUEUE_TYPE:
1:                 return new ActiveMQTempQueue(name);
1:             case TEMP_TOPIC_TYPE:
1:                 return new ActiveMQTempTopic(name);
1:             default:
1:                 throw new IllegalArgumentException("Invalid default destination type: " + defaultType);
/////////////////////////////////////////////////////////////////////////
1:             return (ActiveMQDestination) dest;
/////////////////////////////////////////////////////////////////////////
1:             return new ActiveMQTempQueue(((TemporaryQueue) dest).getQueueName());
1:             return new ActiveMQTempTopic(((TemporaryTopic) dest).getTopicName());
1:             return new ActiveMQQueue(((Queue) dest).getQueueName());
1:             return new ActiveMQTopic(((Topic) dest).getTopicName());
/////////////////////////////////////////////////////////////////////////
1:             return compare(this, (ActiveMQDestination) that);
/////////////////////////////////////////////////////////////////////////
1:         final int length = physicalName.length();
1: 
1:         if (physicalName.isEmpty()) {
1:             throw new IllegalArgumentException("Invalid destination name: a non-empty name is required");
1:         }
1: 
1:         for (int i = 0; i < length; i++) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination d = (ActiveMQDestination) o;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:         this.options = (Map<String, String>) in.readObject();
1:             case QUEUE_TYPE:
1:                 return "Queue";
1:             case TOPIC_TYPE:
1:                 return "Topic";
1:             case TEMP_QUEUE_TYPE:
1:                 return "TempQueue";
1:             case TEMP_TOPIC_TYPE:
1:                 return "TempTopic";
1:             default:
1:                 throw new IllegalArgumentException("Invalid destination type: " + getDestinationType());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:e7e317d
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder level = new StringBuilder();
1:         final char separator = PATH_SEPERATOR.charAt(0);
1:         for (char c : physicalName.toCharArray()) {
1:             if (c == separator) {
1:                 l.add(level.toString());
1:                 level.delete(0, level.length());
1:             } else {
1:                 level.append(c);
1:         l.add(level.toString());
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:37423d6
/////////////////////////////////////////////////////////////////////////
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
0:         this.options = (Map<String, String>)in.readObject();
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: public abstract class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination, Externalizable, Comparable {
/////////////////////////////////////////////////////////////////////////
1:     private static final long serialVersionUID = -3885260014960795889L;
1: 
1:     protected Map<String, String> options;
1:     
1:     public ActiveMQDestination() {
1:     }
1: 
1:     protected ActiveMQDestination(String name) {
1:         setPhysicalName(name);
1:     }
1: 
1:     public ActiveMQDestination(ActiveMQDestination composites[]) {
1:         setCompositeDestinations(composites);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (dest == null) {
1:         }
1:         if (dest instanceof ActiveMQDestination) {
1:         }
1:         if (dest instanceof TemporaryQueue) {
1:         }
1:         if (dest instanceof TemporaryTopic) {
1:         }
1:         if (dest instanceof Queue) {
1:         }
1:         if (dest instanceof Topic) {
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (i != 0) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (isComposite()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 throw new IllegalArgumentException("Invalid destination name: " + physicalName + ", it's options are not encoded properly: " + e);
/////////////////////////////////////////////////////////////////////////
1:             List<String> l = new ArrayList<String>();
1:                 if (name.length() == 0) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (destinationPaths != null) {
1:         }
0:         List<String> l = new ArrayList<String>();
0:             if (name.length() == 0) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (this == o) {
1:         }
1:         if (o == null || getClass() != o.getClass()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, String> getOptions() {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0: public abstract class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination,
/////////////////////////////////////////////////////////////////////////
1:     protected transient ActiveMQDestination[] compositeDestinations;
1:     protected transient String[] destinationPaths;
1:     protected transient boolean isPattern;
1:     protected transient int hashValue;
1:     public static ActiveMQDestination createDestination(String name, byte defaultType) {
/////////////////////////////////////////////////////////////////////////
1:     protected abstract String getQualifiedPrefix();
/////////////////////////////////////////////////////////////////////////
1:     public abstract byte getDestinationType();
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.io.Externalizable;
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Map;
1: import java.util.Properties;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.jndi.JNDIBaseStorable;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.URISupport;
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0: abstract public class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination,
0:     Externalizable, Comparable {
/////////////////////////////////////////////////////////////////////////
1:         // options offset
1:         int p = -1;
/////////////////////////////////////////////////////////////////////////
0:                 throw new IllegalArgumentException("Invalid destination name: " + physicalName
0:                                                    + ", it's options are not encoded properly: " + e);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static final byte QUEUE_TYPE = 0x01;
1:     public static final byte TOPIC_TYPE = 0x02;
1:     public static final byte TEMP_MASK = 0x04;
1: 
1:     public static final String QUEUE_QUALIFIED_PREFIX = "queue://";
1:     public static final String TOPIC_QUALIFIED_PREFIX = "topic://";
1:     public static final String TEMP_QUEUE_QUALIFED_PREFIX = "temp-queue://";
1: 
1: 
1:         if (name.startsWith(QUEUE_QUALIFIED_PREFIX)) {
1:         } else if (name.startsWith(TOPIC_QUALIFIED_PREFIX)) {
1:         } else if (name.startsWith(TEMP_QUEUE_QUALIFED_PREFIX)) {
1:         } else if (name.startsWith(TEMP_TOPIC_QUALIFED_PREFIX)) {
1: 
1:         switch (defaultType) {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalArgumentException("Invalid default destination type: " + defaultType);
1: 
0:         if (dest == null)
0:         if (dest instanceof ActiveMQDestination)
0:             return (ActiveMQDestination)dest;
0:         if (dest instanceof TemporaryQueue)
0:         if (dest instanceof TemporaryTopic)
0:         if (dest instanceof Queue)
0:         if (dest instanceof Topic)
1:         throw new JMSException("Could not transform the destination into a ActiveMQ destination: " + dest);
/////////////////////////////////////////////////////////////////////////
0:         } else if (destination2 == null) {
1:         } else {
1:             } else {
1: 
1: 
0:             return compare(this, (ActiveMQDestination)that);
1:         } else {
1:         return compositeDestinations != null;
1: 
1: 
1:         this.compositeDestinations = destinations;
1:         this.destinationPaths = null;
1:         this.hashValue = 0;
1:         this.isPattern = false;
1: 
1:         StringBuffer sb = new StringBuffer();
0:             if (i != 0)
1:             if (getDestinationType() == destinations[i].getDestinationType()) {
1:         }
0:         if (isComposite())
1:         return getQualifiedPrefix() + physicalName;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setPhysicalName(String physicalName) {
0:         final int len = physicalName.length();
0:         int p = -1;// options offset
1:         boolean composite = false;
0:         for (int i = 0; i < len; i++) {
1:             char c = physicalName.charAt(i);
1:             if (c == '?') {
1:                 p = i;
1:             if (c == COMPOSITE_SEPERATOR) {
1:                 isPattern = false;
1:                 composite = true;
1:             } else if (!composite && (c == '*' || c == '>')) {
1:                 isPattern = true;
1:         if (p >= 0) {
1:             String optstring = physicalName.substring(p + 1);
1:             physicalName = physicalName.substring(0, p);
1:             try {
1:                 options = URISupport.parseQuery(optstring);
1:             } catch (URISyntaxException e) {
0:                 throw new IllegalArgumentException("Invalid destination name: " + physicalName + ", it's options are not encoded properly: " + e);
1:         this.physicalName = physicalName;
1:         this.destinationPaths = null;
1:         this.hashValue = 0;
1:         if (composite) {
0:             ArrayList<String> l = new ArrayList<String>();
1:             StringTokenizer iter = new StringTokenizer(physicalName, "" + COMPOSITE_SEPERATOR);
1:             while (iter.hasMoreTokens()) {
1:                 String name = iter.nextToken().trim();
0:                 if (name.length() == 0)
0:             if (l.size() > 1) {
1:                 compositeDestinations = new ActiveMQDestination[l.size()];
1:                 int counter = 0;
1:                 for (String dest : l) {
1:                     compositeDestinations[counter++] = createDestination(dest);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String[] getDestinationPaths() {
1: 
0:         if (destinationPaths != null)
1: 
0:             if (name.length() == 0)
1: 
1:         return destinationPaths;
1: 
1: 
1: 
1: 
1: 
0:         if (this == o)
0:         if (o == null || getClass() != o.getClass())
1: 
0:         ActiveMQDestination d = (ActiveMQDestination)o;
1: 
1:         if (hashValue == 0) {
1: 
1: 
1: 
0:         this.options = (Map)in.readObject();
1:         switch (getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalArgumentException("Invalid destination type: " + getDestinationType());
1: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:618d1d5
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isPattern() {
1:         return isPattern;
1:     }
commit:b2039fb
/////////////////////////////////////////////////////////////////////////
1:                 sb.append(destinations[i].getPhysicalName());
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.command;
1: 
0: import java.io.Externalizable;
0: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.StringTokenizer;
1: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Queue;
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TemporaryTopic;
1: import javax.jms.Topic;
1: 
0: import org.apache.activemq.util.URISupport;
1: 
1: /**
1:  * @openwire:marshaller
0:  * @version $Revision: 1.10 $
1:  */
0: abstract public class ActiveMQDestination implements DataStructure, Destination, Externalizable {
1: 
0:     private static final long serialVersionUID = -3885260014960795889L;
1: 
1:     public static final String PATH_SEPERATOR = ".";
0:     public static final String COMPOSITE_SEPERATOR = ",";
1:     
0:     public static final byte QUEUE_TYPE = 0x01; 
0:     public static final byte TOPIC_TYPE = 0x02; 
0:     public static final byte TEMP_MASK  = 0x04; 
1:     public static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK;
1:     public static final byte TEMP_QUEUE_TYPE = QUEUE_TYPE | TEMP_MASK;
1:     
0:     public static final String QUEUE_QUALIFIED_PREFIX = "queue://"; 
0:     public static final String TOPIC_QUALIFIED_PREFIX = "topic://"; 
0:     public static final String TEMP_QUEUE_QUALIFED_PREFIX= "temp-queue://"; 
1:     public static final String TEMP_TOPIC_QUALIFED_PREFIX = "temp-topic://";
1:             
1:     protected String physicalName;
1:     
0:     transient protected ActiveMQDestination[] compositeDestinations;
0:     transient protected String[] destinationPaths;
0:     transient protected boolean isPattern;
0:     transient protected int hashValue;
0:     protected Map options;
1: 
0:     public ActiveMQDestination() {
1:     }
1:     
0:     protected ActiveMQDestination(String name) {
0:         setPhysicalName(name);
1:     }
1:     
0:     public ActiveMQDestination(ActiveMQDestination composites[]) {
0:         setCompositeDestinations(composites);
1:     }
1: 
1:     public boolean isComposite() {
0:         return compositeDestinations!=null;
1:     }
1:     public ActiveMQDestination[] getCompositeDestinations() {
1:         return compositeDestinations;
1:     }
1:     
1:     public void setCompositeDestinations(ActiveMQDestination[] destinations) {
0:         this.compositeDestinations=destinations;
0:         this.destinationPaths=null;
0:         this.hashValue=0;
0:         this.isPattern=false;
1:         
0:         StringBuffer sb = new StringBuffer(); 
1:         for (int i = 0; i < destinations.length; i++) {
0:             if( i!=0 )
1:                 sb.append(COMPOSITE_SEPERATOR);
0:             if( getDestinationType()==destinations[i].getDestinationType()) {
1:                 sb.append(destinations[i].getQualifiedName());
1:             } else {
1:                 sb.append(destinations[i].getQualifiedName());
1:             }
1:         }        
1:         physicalName = sb.toString();
1:     }
1: 
1:     public String getQualifiedName() {
0:         if( isComposite() )
1:             return physicalName;
0:         return getQualifiedPrefix()+physicalName;
1:     }
1:     
0:     abstract protected String getQualifiedPrefix();
1:     
1:     /**
1:      * @openwire:property version=1
1:      */
1:     public String getPhysicalName() {
1:         return physicalName;
1:     }
1: 
0:     public void setPhysicalName(String physicalName) {
1: 
1:         // Strip off any options
0:         int p = physicalName.indexOf("?");
0:         if( p >= 0 ) {
0:             String optstring = physicalName.substring(p+1);
0:             physicalName = physicalName.substring(0, p);
0:             try {
0:                 options = URISupport.parseQuery(optstring);
0:             } catch (URISyntaxException e) {
0:                 throw new IllegalArgumentException("Invalid destination name: "+physicalName+", it's options are not encoded properly: "+e);
1:             }
1:         }
1:         
0:         this.physicalName = physicalName;
0:         this.destinationPaths=null;
0:         this.hashValue=0;
0:         this.isPattern = false;
1:         
1:         // Check to see if it is a composite.
0:         ArrayList l = new ArrayList();
0:         StringTokenizer iter = new StringTokenizer(physicalName, COMPOSITE_SEPERATOR);
0:         while (iter.hasMoreTokens()) {
0:             String name = iter.nextToken().trim();
0:             if( name.length() == 0 )
1:                 continue;
1:             l.add(name);
1:         }
1:         
0:         if( l.size()>1 ) {
0:             compositeDestinations = new ActiveMQDestination[l.size()];
0:             int counter=0;
0:             for (Iterator iterator = l.iterator(); iterator.hasNext();) {
0:                 compositeDestinations[counter++] =createDestination((String) iterator.next());
1:             }
1:         } else {            
0:             compositeDestinations=null;
0:             // If this is a pattern destination.
0:             if( !isTemporary() && (
0:                     physicalName.indexOf("*")>=0 ||
0:                     physicalName.indexOf("<")>=0 ) ) {
0:                 isPattern = true;
1:             }
1:         }
1:     }
1: 
1:     public ActiveMQDestination createDestination(String name) {
1:         return createDestination(name, getDestinationType());
1:     }
1:     
0:     static public ActiveMQDestination createDestination(String name, byte defaultType) {
1:         
0:         if( name.startsWith(QUEUE_QUALIFIED_PREFIX) ) {
1:             return new ActiveMQQueue(name.substring(QUEUE_QUALIFIED_PREFIX.length()));
0:         } else if( name.startsWith(TOPIC_QUALIFIED_PREFIX) ) {            
1:             return new ActiveMQTopic(name.substring(TOPIC_QUALIFIED_PREFIX.length()));
0:         } else if( name.startsWith(TEMP_QUEUE_QUALIFED_PREFIX) ) {            
1:             return new ActiveMQTempQueue(name.substring(TEMP_QUEUE_QUALIFED_PREFIX.length()));
0:         } else if( name.startsWith(TEMP_TOPIC_QUALIFED_PREFIX) ) {            
1:             return new ActiveMQTempTopic(name.substring(TEMP_TOPIC_QUALIFED_PREFIX.length()));
1:         }
1:         
0:         switch(defaultType) {
0:         case QUEUE_TYPE:
0:             return new ActiveMQQueue(name);
0:         case TOPIC_TYPE:
0:             return new ActiveMQTopic(name);
0:         case TEMP_QUEUE_TYPE:
0:             return new ActiveMQTempQueue(name);
0:         case TEMP_TOPIC_TYPE:
0:             return new ActiveMQTempTopic(name);
0:         default:
0:             throw new IllegalArgumentException("Invalid default destination type: "+defaultType);
1:         }
1:     }
1:     
0:     public String[] getDestinationPaths() {  
1:         
0:         if( destinationPaths!=null )
1:             return destinationPaths;
1:         
0:         ArrayList l = new ArrayList();
0:         StringTokenizer iter = new StringTokenizer(physicalName, PATH_SEPERATOR);
0:         while (iter.hasMoreTokens()) {
0:             String name = iter.nextToken().trim();
0:             if( name.length() == 0 )
1:                 continue;
1:             l.add(name);
1:         }
1:         
1:         destinationPaths = new String[l.size()];
1:         l.toArray(destinationPaths);
1:         return destinationPaths;        
1:     }
1:     
0:     abstract public byte getDestinationType();
1:     
1:     public boolean isQueue() {
1:         return false;
1:     }
1:     
1:     public boolean isTopic() {
1:         return false;
1:     }
1:     
1:     public boolean isTemporary() {
1:         return false;
1:     }
1:     
1:     public boolean equals(Object o) {
0:         if( this == o )
1:             return true;
0:         if( o==null || getClass()!=o.getClass() )
1:             return false;
1:         
0:         ActiveMQDestination d = (ActiveMQDestination) o;
1:         return physicalName.equals(d.physicalName);
1:     }
1:     
1:     public int hashCode() {
0:         if( hashValue==0 ) {
1:             hashValue = physicalName.hashCode();
1:         }
1:         return hashValue;
1:     }
1: 
1:     public static ActiveMQDestination transform(Destination dest) throws JMSException {
0:         if( dest == null )
1:             return null;
0:         if( dest instanceof ActiveMQDestination )
0:             return (ActiveMQDestination) dest;
0:         if( dest instanceof TemporaryQueue )
0:             return new ActiveMQTempQueue(((TemporaryQueue)dest).getQueueName());
0:         if( dest instanceof TemporaryTopic )
0:             return new ActiveMQTempTopic(((TemporaryTopic)dest).getTopicName());
0:         if( dest instanceof Queue )
0:             return new ActiveMQQueue(((Queue)dest).getQueueName());
0:         if( dest instanceof Topic )
0:             return new ActiveMQTopic(((Topic)dest).getTopicName());
0:         throw new JMSException("Could not transform the destination into a ActiveMQ destination: "+dest);
1:     }
1:     
1:     public String toString() {
1:         return getQualifiedName();
1:     }
1:     
1:     public void writeExternal(ObjectOutput out) throws IOException {
1:         out.writeUTF(this.getPhysicalName());
1:         out.writeObject(options);
1:     }
1:     
1:     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
1:         this.setPhysicalName(in.readUTF());
0:         this.options = (Map) in.readObject();
1:     }
1: 
1:     public String getDestinationTypeAsString() {
0:         switch(getDestinationType()) {
0:         case QUEUE_TYPE:
0:             return "Queue";
0:         case TOPIC_TYPE:
0:             return "Topic";
0:         case TEMP_QUEUE_TYPE:
0:             return "TempQueue";
0:         case TEMP_TOPIC_TYPE:
0:             return "TempTopic";
0:         default:
0:             throw new IllegalArgumentException("Invalid destination type: "+getDestinationType());
1:         }
1:     }
1: 
0:     public Map getOptions() {
1:         return options;
1:     }
1:     
1:     public boolean isMarshallAware() {
1:         return false;
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:f220607
/////////////////////////////////////////////////////////////////////////
0:  *
1: public abstract class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination, Externalizable, Comparable<Object> {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         physicalName = physicalName.trim();
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:713dcaa
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected static UnresolvedDestinationTransformer unresolvableDestinationTransformer = new DefaultUnresolvedDestinationTransformer();
/////////////////////////////////////////////////////////////////////////
0:             } else {
1:                 return unresolvableDestinationTransformer.transform(dest);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public static UnresolvedDestinationTransformer getUnresolvableDestinationTransformer() {
1:         return unresolvableDestinationTransformer;
1:     }
0: 
1:     public static void setUnresolvableDestinationTransformer(UnresolvedDestinationTransformer unresolvableDestinationTransformer) {
1:         ActiveMQDestination.unresolvableDestinationTransformer = unresolvableDestinationTransformer;
1:     }
commit:f8b0c22
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:             Set<String> l = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
0:             compositeDestinations = new ActiveMQDestination[l.size()];
0:             int counter = 0;
0:             for (String dest : l) {
0:                 compositeDestinations[counter++] = createDestination(dest);
author:Gary Tully
-------------------------------------------------------------------------------
commit:f33e219
/////////////////////////////////////////////////////////////////////////
0:         
1:         if (dest instanceof Queue && dest instanceof Topic) {
1:             String queueName = ((Queue) dest).getQueueName();
1:             String topicName = ((Topic) dest).getTopicName();
1:             if (queueName != null && topicName == null) {
1:                 return new ActiveMQQueue(queueName);
1:             } else if (queueName == null && topicName != null) {
1:                 return new ActiveMQTopic(topicName);
1:             }
0:             throw new JMSException("Could no disambiguate on queue|Topic-name totransform pollymorphic destination into a ActiveMQ destination: " + dest);
1:         }
author:James Strachan
-------------------------------------------------------------------------------
commit:0eae288
/////////////////////////////////////////////////////////////////////////
0: 
1:     public static final String TEMP_DESTINATION_NAME_PREFIX = "ID:";
0: 
commit:800fba7
/////////////////////////////////////////////////////////////////////////
0:             }else if(!composite&&(c=='*'||c=='>')){
commit:b77d70a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.jndi.JNDIBaseStorable;
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.URISupport;
0: 
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Queue;
0: import javax.jms.TemporaryQueue;
0: import javax.jms.TemporaryTopic;
0: import javax.jms.Topic;
/////////////////////////////////////////////////////////////////////////
0: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0:     
0:         return getQualifiedName();
commit:bca88fe
/////////////////////////////////////////////////////////////////////////
0:         // TODO we should use the physical name by default for easier operation
0:         // with other software like StompConnect
0:         return physicalName;
commit:8f22cfa
/////////////////////////////////////////////////////////////////////////
0: abstract public class ActiveMQDestination implements DataStructure, Destination, Externalizable, Comparable {
/////////////////////////////////////////////////////////////////////////
0:     
1:     // static helper methods for working with destinations
1:     // -------------------------------------------------------------------------
0:     static public ActiveMQDestination createDestination(String name, byte defaultType) {
0:         
0:         if( name.startsWith(QUEUE_QUALIFIED_PREFIX) ) {
0:             return new ActiveMQQueue(name.substring(QUEUE_QUALIFIED_PREFIX.length()));
0:         } else if( name.startsWith(TOPIC_QUALIFIED_PREFIX) ) {            
0:             return new ActiveMQTopic(name.substring(TOPIC_QUALIFIED_PREFIX.length()));
0:         } else if( name.startsWith(TEMP_QUEUE_QUALIFED_PREFIX) ) {            
0:             return new ActiveMQTempQueue(name.substring(TEMP_QUEUE_QUALIFED_PREFIX.length()));
0:         } else if( name.startsWith(TEMP_TOPIC_QUALIFED_PREFIX) ) {            
0:             return new ActiveMQTempTopic(name.substring(TEMP_TOPIC_QUALIFED_PREFIX.length()));
1:         }
0:         
0:         switch(defaultType) {
0:         case QUEUE_TYPE:
0:             return new ActiveMQQueue(name);
0:         case TOPIC_TYPE:
0:             return new ActiveMQTopic(name);
0:         case TEMP_QUEUE_TYPE:
0:             return new ActiveMQTempQueue(name);
0:         case TEMP_TOPIC_TYPE:
0:             return new ActiveMQTempTopic(name);
0:         default:
0:             throw new IllegalArgumentException("Invalid default destination type: "+defaultType);
1:         }
1:     }
0:     
0:     public static ActiveMQDestination transform(Destination dest) throws JMSException {
0:         if( dest == null )
0:             return null;
0:         if( dest instanceof ActiveMQDestination )
0:             return (ActiveMQDestination) dest;
0:         if( dest instanceof TemporaryQueue )
0:             return new ActiveMQTempQueue(((TemporaryQueue)dest).getQueueName());
0:         if( dest instanceof TemporaryTopic )
0:             return new ActiveMQTempTopic(((TemporaryTopic)dest).getTopicName());
0:         if( dest instanceof Queue )
0:             return new ActiveMQQueue(((Queue)dest).getQueueName());
0:         if( dest instanceof Topic )
0:             return new ActiveMQTopic(((Topic)dest).getTopicName());
0:         throw new JMSException("Could not transform the destination into a ActiveMQ destination: "+dest);
1:     }
0: 
1:     public static int compare(ActiveMQDestination destination, ActiveMQDestination destination2) {
1:         if (destination == destination2) {
1:             return 0;
1:         }
0:         if (destination == null) {
1:             return -1;
1:         }
0:         else if (destination2 == null) {
1:             return 1;
1:         }
0:         else {
0:             if (destination.isQueue() == destination2.isQueue()) {
1:                 return destination.getPhysicalName().compareTo(destination2.getPhysicalName());
1:             }
0:             else {
1:                 return destination.isQueue() ? -1 : 1;
1:             }
1:         }
1:     }
0: 
0:     
/////////////////////////////////////////////////////////////////////////
1:     public int compareTo(Object that) {
1:         if (that instanceof ActiveMQDestination) {
0:             return compare(this, (ActiveMQDestination) that);
0:         }
1:         if (that == null) {
1:             return 1;
0:         }
0:         else {
1:             return getClass().getName().compareTo(that.getClass().getName());
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Robert Davies
-------------------------------------------------------------------------------
commit:477fc85
/////////////////////////////////////////////////////////////////////////
1:     public static final char COMPOSITE_SEPERATOR = ',';
/////////////////////////////////////////////////////////////////////////
0:     public void setPhysicalName(String physicalName){
0:         final int len=physicalName.length();
0:         int p=-1;//options offset
0:         boolean composite=false;
0:         for(int i=0;i<len;i++){
0:             char c=physicalName.charAt(i);
0:             if(c=='?'){
0:                 p=i;
1:                 break;
0:             }
0:             if(c==COMPOSITE_SEPERATOR){
1:                 // won't be wild card
0:                 isPattern=false;
0:                 composite=true;
0:             }else if(!composite&&(c=='*'||c=='.')){
0:                 isPattern=true;
0:         // Strip off any options
0:         if(p>=0){
0:             String optstring=physicalName.substring(p+1);
0:             physicalName=physicalName.substring(0,p);
0:             try{
0:                 options=URISupport.parseQuery(optstring);
0:             }catch(URISyntaxException e){
0:                 throw new IllegalArgumentException("Invalid destination name: "+physicalName
0:                         +", it's options are not encoded properly: "+e);
0:             }
0:         }
0:         this.physicalName=physicalName;
0:         if(composite){
0:             // Check to see if it is a composite.
0:             ArrayList<String> l=new ArrayList<String>();
0:             StringTokenizer iter=new StringTokenizer(physicalName,""+COMPOSITE_SEPERATOR);
0:             while(iter.hasMoreTokens()){
0:                 String name=iter.nextToken().trim();
0:                 if(name.length()==0)
0:                     continue;
0:                 l.add(name);
0:             if(l.size()>1){
0:                 compositeDestinations=new ActiveMQDestination[l.size()];
0:                 int counter=0;
0:                 for (String dest:l) {
0:                     compositeDestinations[counter++]=createDestination(dest);
0:                 }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:b9a4dee
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.jndi.JNDIBaseStorable;
0: abstract public class ActiveMQDestination extends JNDIBaseStorable implements DataStructure, Destination, Externalizable, Comparable {
/////////////////////////////////////////////////////////////////////////
1:     public void buildFromProperties(Properties properties) {
1:         if (properties == null) {
1:             properties = new Properties();
0:         }
1:         IntrospectionSupport.setProperties(this, properties);
1:     public void populateProperties(Properties props) {
1:         props.setProperty("physicalName", getPhysicalName());
commit:2ddd372
/////////////////////////////////////////////////////////////////////////
0: import java.util.Properties;
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
0: import javax.naming.Reference;
0: import javax.naming.NamingException;
0: import javax.naming.Referenceable;
/////////////////////////////////////////////////////////////////////////
0: abstract public class ActiveMQDestination implements DataStructure, Destination, Externalizable, Comparable, Referenceable {
/////////////////////////////////////////////////////////////////////////
0:     public Properties getProperties() {
0:         Properties props = new Properties();
0: 
0:         props.setProperty("composite", Boolean.toString(isComposite()));
0:         props.setProperty("destinationType", Byte.toString(getDestinationType()));
0:         props.setProperty("destinationTypeAsString", getDestinationTypeAsString());
0:         props.setProperty("marshallAware", Boolean.toString(isMarshallAware()));
0:         props.setProperty("physicalName", getPhysicalName());
0:         props.setProperty("qualifiedName", getQualifiedName());
0:         props.setProperty("qualifiedPrefix", getQualifiedPrefix());
0:         props.setProperty("queue", Boolean.toString(isQueue()));
0:         props.setProperty("temporary", Boolean.toString(isTemporary()));
0:         props.setProperty("topic", Boolean.toString(isTopic()));
0: 
0:         return props;
0:     }
0: 
0:     /**
0:      * Retrieve a Reference for this instance to store in JNDI
0:      *
0:      * @return the built Reference
0:      * @throws javax.naming.NamingException if error on building Reference
0:      */
0:     public Reference getReference() throws NamingException {
0:         Reference ref = new Reference(this.getClass().getName());
0: 
0:         try {
0:             Properties props = getProperties();
0:             for (Enumeration iter = props.propertyNames(); iter.hasMoreElements();) {
0:                 String key = (String) iter.nextElement();
0:                 String value = props.getProperty(key);
0:                 javax.naming.StringRefAddr addr = new javax.naming.StringRefAddr(key, value);
0:                 ref.add(addr);
0:             }
0:         } catch (Exception e) {
0:             throw new NamingException(e.getMessage());
0:         }
0:         return ref;
0:     }
============================================================================