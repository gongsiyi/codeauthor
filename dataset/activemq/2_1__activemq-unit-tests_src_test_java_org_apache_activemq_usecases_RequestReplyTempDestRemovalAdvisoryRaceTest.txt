1:8012f28: /**
1:8012f28:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8012f28:  * contributor license agreements.  See the NOTICE file distributed with
1:8012f28:  * this work for additional information regarding copyright ownership.
1:8012f28:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8012f28:  * (the "License"); you may not use this file except in compliance with
1:8012f28:  * the License.  You may obtain a copy of the License at
1:8012f28:  *
1:8012f28:  * http://www.apache.org/licenses/LICENSE-2.0
1:8012f28:  *
1:8012f28:  * Unless required by applicable law or agreed to in writing, software
1:8012f28:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8012f28:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8012f28:  * See the License for the specific language governing permissions and
1:8012f28:  * limitations under the License.
1:8012f28:  */
1:8012f28: package org.apache.activemq.usecases;
1:8012f28: 
1:8012f28: import java.net.URI;
1:8012f28: import java.util.Arrays;
1:8012f28: import java.util.HashSet;
1:8012f28: import java.util.Random;
1:8012f28: import java.util.concurrent.CountDownLatch;
1:8012f28: import java.util.concurrent.ExecutorService;
1:8012f28: import java.util.concurrent.Executors;
1:8012f28: import java.util.concurrent.TimeUnit;
1:8012f28: import java.util.concurrent.atomic.AtomicBoolean;
1:8012f28: import java.util.concurrent.atomic.AtomicLong;
1:8012f28: import javax.jms.Connection;
1:8012f28: import javax.jms.DeliveryMode;
1:8012f28: import javax.jms.Destination;
1:8012f28: import javax.jms.JMSException;
1:8012f28: import javax.jms.Message;
1:8012f28: import javax.jms.MessageConsumer;
1:8012f28: import javax.jms.MessageListener;
1:8012f28: import javax.jms.MessageProducer;
1:8012f28: import javax.jms.Session;
1:8012f28: import javax.jms.TextMessage;
1:8012f28: import junit.framework.Test;
1:8012f28: import org.apache.activemq.ActiveMQConnectionFactory;
1:8012f28: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:8012f28: import org.apache.activemq.advisory.AdvisorySupport;
1:8012f28: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1:8012f28: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:8012f28: import org.apache.activemq.broker.region.policy.PolicyMap;
1:8012f28: import org.apache.activemq.broker.region.policy.PriorityDispatchPolicy;
1:8012f28: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
1:8012f28: import org.apache.activemq.command.ActiveMQQueue;
1:8012f28: import org.apache.activemq.command.ActiveMQTempTopic;
1:8012f28: import org.apache.activemq.command.ActiveMQTextMessage;
1:8012f28: import org.apache.activemq.network.DemandForwardingBridgeSupport;
1:8012f28: import org.apache.activemq.network.NetworkBridge;
1:8012f28: import org.apache.activemq.network.NetworkConnector;
1:8012f28: import org.apache.activemq.util.DefaultTestAppender;
1:8012f28: import org.apache.log4j.Appender;
1:8012f28: import org.apache.log4j.Level;
1:8012f28: import org.apache.log4j.spi.LoggingEvent;
1:8012f28: import org.slf4j.Logger;
1:8012f28: import org.slf4j.LoggerFactory;
1:8012f28: 
1:8012f28: /**
1:8012f28:  * @author <a href="http://www.christianposta.com/blog">Christian Posta</a>
1:8012f28:  */
1:8012f28: public class RequestReplyTempDestRemovalAdvisoryRaceTest extends JmsMultipleBrokersTestSupport {
1:8012f28:     private static final Logger LOG = LoggerFactory.getLogger(RequestReplyTempDestRemovalAdvisoryRaceTest.class);
1:8012f28: 
1:8012f28:     private static final String BROKER_A = "BrokerA";
1:8012f28:     private static final String BROKER_B = "BrokerB";
1:8012f28:     private static final String BROKER_C = "BrokerC";
1:8012f28: 
1:8012f28:     private static final int NUM_RESPONDENTS = 1;
1:8012f28:     private static final int NUM_SENDS = 1;
1:8012f28:     private static final int RANDOM_SLEEP_FOR_RESPONDENT_MS = 0;
1:8012f28:     private static final int RANDOM_SLEEP_FOR_SENDER_MS = 1;
1:8012f28:     private static final String QUEUE_NAME = "foo.queue";
1:8012f28:     private static String[] TEST_ITERATIONS = new String[]{QUEUE_NAME+"0", QUEUE_NAME+"1", QUEUE_NAME+"2", QUEUE_NAME+"3"};
1:8012f28: 
1:8012f28:     final AtomicLong messageCount = new AtomicLong(0);
1:8012f28:     final AtomicLong respondentSendError = new AtomicLong(0);
1:8012f28:     final AtomicLong responseReceived = new AtomicLong(0);
1:8012f28:     final AtomicLong sendsWithNoConsumers = new AtomicLong(0);
1:8012f28:     final AtomicLong forwardFailures = new AtomicLong(0);
1:8012f28: 
1:8012f28: 
1:8012f28:     protected final AtomicBoolean shutdown = new AtomicBoolean(false);
1:8012f28:     HashSet<NetworkConnector> networkConnectors = new HashSet<NetworkConnector>();
1:8012f28:     HashSet<Connection> advisoryConsumerConnections = new HashSet<Connection>();
1:8012f28:     Appender slowDownAppender;
1:8012f28: 
1:8012f28:     CountDownLatch consumerDemandExists;
1:8012f28: 
1:8012f28:     protected boolean useDuplex = false;
1:8012f28: 
1:8012f28:     public static Test suite() {
1:8012f28:         return suite(RequestReplyTempDestRemovalAdvisoryRaceTest.class);
1:8012f28:     }
1:8012f28: 
1:8012f28:     /**
1:8012f28:      * Notes: to reliably reproduce use debugger... set a "thread" breakpoint at line 679 in DemandForwardingBridgeSupport,
1:8012f28:      * and only break on the "2nd" pass (broker C's bridge). Allow debugging to continue shortly after hitting
1:8012f28:      * the breakpoint, for this test we use a logging appender to implement the pause,
1:8012f28:      * it fails most of the time, hence the combos
1:8012f28:      */
1:8012f28:     public void initCombos() {
1:8012f28:         addCombinationValues("QUEUE_NAME", TEST_ITERATIONS);
1:8012f28:     }
1:8012f28: 
1:8012f28:     public void testTempDestRaceDuplex() throws Exception {
1:8012f28:         // duplex
1:8012f28:         useDuplex = true;
1:8012f28:         bridgeBrokers(BROKER_A, BROKER_B, false, 3);
1:8012f28:         bridgeBrokers(BROKER_B, BROKER_C, false, 3);
1:8012f28: 
1:8012f28:         startAllBrokers();
1:8012f28: 
1:8012f28:         waitForBridgeFormation(1);
1:8012f28: 
1:8012f28:         HashSet<NetworkBridge> bridgesStart = new HashSet<NetworkBridge>();
1:8012f28:         for (NetworkConnector networkConnector : networkConnectors) {
1:8012f28:             bridgesStart.addAll(networkConnector.activeBridges());
1:8012f28:         }
1:8012f28:         LOG.info("Bridges start:" + bridgesStart);
1:8012f28: 
1:8012f28:         slowDownAdvisoryDispatch();
1:8012f28:         noConsumerAdvisory();
1:8012f28:         forwardFailureAdvisory();
1:8012f28: 
1:8012f28:         // set up respondents
1:8012f28:         ExecutorService respondentThreadPool = Executors.newFixedThreadPool(50);
1:8012f28:         BrokerItem brokerA = brokers.get(BROKER_A);
1:8012f28:         ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                 + "?jms.watchTopicAdvisories=false");
1:8012f28:         brokerAFactory.setAlwaysSyncSend(true);
1:8012f28:         for (int i = 0; i < NUM_RESPONDENTS; i++) {
1:8012f28:             respondentThreadPool.execute(new EchoRespondent(brokerAFactory));
1:8012f28:         }
1:8012f28: 
1:8012f28:         // fire off sends
1:8012f28:         ExecutorService senderThreadPool = Executors.newCachedThreadPool();
1:8012f28:         BrokerItem brokerC = brokers.get(BROKER_C);
1:8012f28:         ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                 + "?jms.watchTopicAdvisories=false");
1:8012f28:         for (int i = 0; i < NUM_SENDS; i++) {
1:8012f28:             senderThreadPool.execute(new MessageSender(brokerCFactory));
1:8012f28:         }
1:8012f28: 
1:8012f28:         senderThreadPool.shutdown();
1:8012f28:         senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);
1:8012f28:         TimeUnit.SECONDS.sleep(15);
1:8012f28:         LOG.info("shutting down");
1:8012f28:         shutdown.compareAndSet(false, true);
1:8012f28: 
1:8012f28:         HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();
1:8012f28:         for (NetworkConnector networkConnector : networkConnectors) {
1:8012f28:             bridgesEnd.addAll(networkConnector.activeBridges());
1:8012f28:         }
1:8012f28:         LOG.info("Bridges end:" + bridgesEnd);
1:8012f28: 
1:8012f28:         assertEquals("no new bridges created", bridgesStart, bridgesEnd);
1:8012f28: 
1:8012f28:         // validate success or error of dlq
1:8012f28:         LOG.info("received: " + responseReceived.get() + ", respondent error: " + respondentSendError.get()
1:8012f28:                 + ", noConsumerCount: " + sendsWithNoConsumers.get()
1:8012f28:                 + ", forwardFailures: " + forwardFailures.get());
1:8012f28:         assertEquals("success or error", NUM_SENDS, respondentSendError.get() + forwardFailures.get()
1:8012f28:                 + responseReceived.get() + sendsWithNoConsumers.get());
1:8012f28: 
1:8012f28:     }
1:8012f28: 
1:8012f28:     private void forwardFailureAdvisory() throws JMSException {
1:8012f28:         for (BrokerItem item : brokers.values()) {
1:8012f28:             ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(item.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                     + "?jms.watchTopicAdvisories=false");
1:8012f28:             Connection connection = brokerAFactory.createConnection();
1:8012f28:             connection.start();
1:8012f28:             connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(
1:8012f28:                     AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic()).setMessageListener(new MessageListener() {
1:8012f28:                 @Override
1:8012f28:                 public void onMessage(Message message) {
1:8012f28:                     forwardFailures.incrementAndGet();
1:8012f28:                 }
1:8012f28:             });
1:8012f28:         }
1:8012f28:     }
1:8012f28: 
1:8012f28:     private void noConsumerAdvisory() throws JMSException {
1:8012f28:         for (BrokerItem item : brokers.values()) {
1:8012f28:             ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(item.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                     + "?jms.watchTopicAdvisories=false");
1:8012f28:             Connection connection = brokerAFactory.createConnection();
1:8012f28:             connection.start();
1:8012f28:             connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(
1:8012f28:                     AdvisorySupport.getNoTopicConsumersAdvisoryTopic(new ActiveMQTempTopic(">"))).setMessageListener(new MessageListener() {
1:8012f28:                 @Override
1:8012f28:                 public void onMessage(Message message) {
1:8012f28:                     sendsWithNoConsumers.incrementAndGet();
1:8012f28:                 }
1:8012f28:             });
1:8012f28:         }
1:8012f28:     }
1:8012f28: 
1:8012f28: 
1:8012f28:     public void testTempDestRace() throws Exception {
1:8012f28:         // non duplex
1:8012f28:         bridgeBrokers(BROKER_A, BROKER_B, false, 3);
1:8012f28:         bridgeBrokers(BROKER_B, BROKER_A, false, 3);
1:8012f28:         bridgeBrokers(BROKER_B, BROKER_C, false, 3);
1:8012f28:         bridgeBrokers(BROKER_C, BROKER_B, false, 3);
1:8012f28: 
1:8012f28:         startAllBrokers();
1:8012f28: 
1:8012f28:         waitForBridgeFormation(1);
1:8012f28: 
1:8012f28:         HashSet<NetworkBridge> bridgesStart = new HashSet<NetworkBridge>();
1:8012f28:         for (NetworkConnector networkConnector : networkConnectors) {
1:8012f28:             bridgesStart.addAll(networkConnector.activeBridges());
1:8012f28:         }
1:8012f28: 
1:8012f28:         slowDownAdvisoryDispatch();
1:8012f28:         noConsumerAdvisory();
1:8012f28:         forwardFailureAdvisory();
1:8012f28: 
1:8012f28: 
1:8012f28:         // set up respondents
1:8012f28:         ExecutorService respondentThreadPool = Executors.newFixedThreadPool(50);
1:8012f28:         BrokerItem brokerA = brokers.get(BROKER_A);
1:8012f28:         ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                 + "?jms.watchTopicAdvisories=false");
1:8012f28:         brokerAFactory.setAlwaysSyncSend(true);
1:8012f28:         for (int i = 0; i < NUM_RESPONDENTS; i++) {
1:8012f28:             respondentThreadPool.execute(new EchoRespondent(brokerAFactory));
1:8012f28:         }
1:8012f28: 
1:8012f28:         // fire off sends
1:8012f28:         ExecutorService senderThreadPool = Executors.newCachedThreadPool();
1:8012f28:         BrokerItem brokerC = brokers.get(BROKER_C);
1:8012f28:         ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName()
1:8012f28:                 + "?jms.watchTopicAdvisories=false");
1:8012f28:         for (int i = 0; i < NUM_SENDS; i++) {
1:8012f28:             senderThreadPool.execute(new MessageSender(brokerCFactory));
1:8012f28:         }
1:8012f28: 
1:8012f28:         senderThreadPool.shutdown();
1:8012f28:         senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);
1:8012f28:         TimeUnit.SECONDS.sleep(10);
1:8012f28:         LOG.info("shutting down");
1:8012f28:         shutdown.compareAndSet(false, true);
1:8012f28: 
1:8012f28:         HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();
1:8012f28:         for (NetworkConnector networkConnector : networkConnectors) {
1:8012f28:             bridgesEnd.addAll(networkConnector.activeBridges());
1:8012f28:         }
1:8012f28:         assertEquals("no new bridges created", bridgesStart, bridgesEnd);
1:8012f28: 
1:8012f28:         // validate success or error or dlq
1:8012f28:         LOG.info("received: " + responseReceived.get() + ", respondent error: " + respondentSendError.get()
1:8012f28:                 + ", noConsumerCount: " + sendsWithNoConsumers.get()
1:8012f28:                 + ", forwardFailures: " + forwardFailures.get());
1:8012f28:         assertEquals("success or error", NUM_SENDS, respondentSendError.get() + forwardFailures.get()
1:8012f28:                 + responseReceived.get() + sendsWithNoConsumers.get());
1:8012f28: 
1:8012f28:     }
1:8012f28: 
1:8012f28:     private void slowDownAdvisoryDispatch() throws Exception {
1:8012f28: 
1:8012f28:         org.apache.log4j.Logger.getLogger(DemandForwardingBridgeSupport.class).setLevel(Level.DEBUG);
1:8012f28: 
1:8012f28:         // instrument a logger to block the processing of a remove sub advisory
1:8012f28:         // simulate a slow thread
1:8012f28:         slowDownAppender = new DefaultTestAppender() {
1:8012f28:             @Override
1:8012f28:             public void doAppend(LoggingEvent loggingEvent) {
1:8012f28:                 if (Level.DEBUG.equals(loggingEvent.getLevel())) {
1:8012f28:                     String message = loggingEvent.getMessage().toString();
1:8012f28:                     if (message.startsWith("BrokerB") && message.contains("remove local subscription")) {
1:8012f28:                         // sleep for a bit
1:8012f28:                         try {
1:8012f28:                             consumerDemandExists.countDown();
1:8012f28:                             System.err.println("Sleeping on receipt of remove info debug message: " + message);
1:8012f28:                             TimeUnit.SECONDS.sleep(2);
1:8012f28:                         } catch (Exception ignored) {
1:8012f28:                         }
1:8012f28:                     }
1:8012f28: 
1:8012f28:                 }
1:8012f28:             }
1:8012f28:         };
1:8012f28: 
1:8012f28:         org.apache.log4j.Logger.getRootLogger().addAppender(slowDownAppender);
1:8012f28:     }
1:8012f28: 
1:8012f28:     @Override
1:8012f28:     protected void setUp() throws Exception {
1:8012f28:         super.setUp();
1:8012f28:         responseReceived.set(0);
1:8012f28:         respondentSendError.set(0);
1:8012f28:         forwardFailures.set(0);
1:8012f28:         sendsWithNoConsumers.set(0);
1:8012f28:         networkConnectors.clear();
1:8012f28:         advisoryConsumerConnections.clear();
1:8012f28:         consumerDemandExists = new CountDownLatch(1);
1:8012f28:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_A + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1:8012f28:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_B + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1:8012f28:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_C + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1:8012f28: 
1:8012f28:         PolicyMap map = new PolicyMap();
1:8012f28:         PolicyEntry defaultEntry = new PolicyEntry();
1:8012f28:         defaultEntry.setSendAdvisoryIfNoConsumers(true);
1:8012f28:         DeadLetterStrategy deadletterStrategy = new SharedDeadLetterStrategy();
1:8012f28:         deadletterStrategy.setProcessNonPersistent(true);
1:8012f28:         defaultEntry.setDeadLetterStrategy(deadletterStrategy);
1:8012f28:         defaultEntry.setDispatchPolicy(new PriorityDispatchPolicy());
1:8012f28:         map.put(new ActiveMQTempTopic(">"), defaultEntry);
1:8012f28: 
1:8012f28:         for (BrokerItem item : brokers.values()) {
1:8012f28:             item.broker.setDestinationPolicy(map);
1:8012f28:         }
1:8012f28:     }
1:8012f28: 
1:8012f28:     @Override
1:8012f28:     protected void tearDown() throws Exception {
1:8012f28:         if (slowDownAppender != null) {
1:8012f28:             org.apache.log4j.Logger.getRootLogger().removeAppender(slowDownAppender);
1:8012f28:         }
1:8012f28:         for (Connection connection : advisoryConsumerConnections) {
1:8012f28:             connection.close();
1:8012f28:         }
1:8012f28:         super.tearDown();
1:8012f28:     }
1:8012f28: 
1:8012f28:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly, int networkTTL) throws Exception {
1:8012f28:         NetworkConnector connector = super.bridgeBrokers(localBrokerName, remoteBrokerName, dynamicOnly, networkTTL, true);
1:8012f28:         connector.setBridgeTempDestinations(true);
1:8012f28:         connector.setAdvisoryForFailedForward(true);
1:8012f28:         connector.setDuplex(useDuplex);
1:8012f28:         connector.setAlwaysSyncSend(true);
1:8012f28:         networkConnectors.add(connector);
1:8012f28:         return connector;
1:8012f28:     }
1:8012f28: 
1:8012f28:     abstract class MessageClient {
1:8012f28:         protected Connection connection;
1:8012f28:         protected Session session;
1:8012f28:         protected MessageConsumer consumer;
1:8012f28:         protected MessageProducer producer;
1:8012f28:         protected Random random;
1:8012f28:         protected int timeToSleep;
1:8012f28: 
1:8012f28:         // set up the connection and session
1:8012f28:         public MessageClient(ActiveMQConnectionFactory factory, int timeToSleep) throws Exception {
1:8012f28:             this.connection = factory.createConnection();
1:8012f28:             this.session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8012f28:             this.timeToSleep = timeToSleep;
1:8012f28:             this.random = new Random(System.currentTimeMillis());
1:8012f28:             preInit();
1:8012f28:             initProducer();
1:8012f28:             initConsumer();
1:8012f28:             this.connection.start();
1:8012f28:         }
1:8012f28: 
1:8012f28:         protected void preInit() throws JMSException {
1:8012f28: 
1:8012f28:         }
1:8012f28: 
1:8012f28:         abstract protected void initProducer() throws JMSException;
1:8012f28: 
1:8012f28:         abstract protected void initConsumer() throws JMSException;
1:8012f28:     }
1:8012f28: 
1:8012f28:     class MessageSender extends MessageClient implements Runnable {
1:8012f28: 
1:8012f28: 
1:8012f28:         protected Destination tempDest;
1:8012f28: 
1:8012f28:         public MessageSender(ActiveMQConnectionFactory factory) throws Exception {
1:8012f28:             super(factory, RANDOM_SLEEP_FOR_SENDER_MS);
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         public void run() {
1:8012f28:             // create a message
1:8012f28:             try {
1:8012f28:                 TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());
1:8012f28:                 message.setJMSReplyTo(tempDest);
1:8012f28:                 producer.send(message);
1:8012f28:                 LOG.info("SENDER: Message [" + message.getText() + "] has been sent.");
1:8012f28: 
1:8012f28:                 Message incomingMessage = consumer.receive(timeToSleep);
1:8012f28:                 if (incomingMessage instanceof TextMessage) {
1:8012f28:                     try {
1:8012f28:                         LOG.info("SENDER: Got a response from echo service!" + ((TextMessage) incomingMessage).getText());
1:8012f28:                         responseReceived.incrementAndGet();
1:8012f28:                     } catch (JMSException e) {
1:8012f28:                         LOG.error("SENDER: might want to see why i'm getting non-text messages..." + incomingMessage, e);
1:8012f28:                     }
1:8012f28:                 } else {
1:8012f28:                     LOG.info("SENDER: Did not get a response this time");
1:8012f28:                 }
1:8012f28: 
1:8012f28: 
1:8012f28:             } catch (JMSException e) {
1:8012f28:                 LOG.error("SENDER: Could not complete message sending properly: " + e.getMessage());
1:8012f28:             } finally {
1:8012f28:                 try {
1:8012f28:                     producer.close();
1:8012f28:                     consumer.close();
1:8012f28:                     session.close();
1:8012f28:                     connection.close();
1:8012f28:                 } catch (JMSException e) {
1:8012f28:                     e.printStackTrace();
1:8012f28:                 }
1:8012f28:             }
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         protected void preInit() throws JMSException {
1:8012f28:             this.tempDest = session.createTemporaryTopic();
1:8012f28: 
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         protected void initProducer() throws JMSException {
1:8012f28:             this.producer = session.createProducer(new ActiveMQQueue(QUEUE_NAME));
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         protected void initConsumer() throws JMSException {
1:8012f28:             this.consumer = session.createConsumer(tempDest);
1:8012f28:             LOG.info("consumer for: " + tempDest + ", " + consumer);
1:8012f28: 
1:8012f28:         }
1:8012f28: 
1:8012f28:     }
1:8012f28: 
1:8012f28:     class EchoRespondent extends MessageClient implements Runnable {
1:8012f28: 
1:8012f28:         public EchoRespondent(ActiveMQConnectionFactory factory) throws Exception {
1:8012f28:             super(factory, RANDOM_SLEEP_FOR_RESPONDENT_MS);
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         public void run() {
1:8012f28:             try {
1:8012f28:                 LOG.info("RESPONDENT LISTENING");
1:8012f28:                 while (!shutdown.get()) {
1:8012f28:                     Message incomingMessage = consumer.receive(1000);
1:8012f28:                     if (incomingMessage instanceof TextMessage) {
1:8012f28:                         ActiveMQTextMessage textMessage = (ActiveMQTextMessage) incomingMessage;
1:8012f28:                         try {
1:8012f28:                             LOG.info("RESPONDENT: Received a message: [" + textMessage.getText() + "]" + Arrays.asList(textMessage.getBrokerPath()));
1:8012f28:                             Message message = session.createTextMessage("reply: " + textMessage.getText());
1:8012f28:                             Destination replyTo = incomingMessage.getJMSReplyTo();
1:8012f28:                             TimeUnit.MILLISECONDS.sleep(timeToSleep);
1:8012f28:                             consumerDemandExists.await(5, TimeUnit.SECONDS);
1:8012f28:                             try {
1:8012f28:                                 producer.send(replyTo, message);
1:8012f28:                                 LOG.info("RESPONDENT: sent reply:" + message.getJMSMessageID() + " back to: " + replyTo);
1:8012f28:                             } catch (JMSException e) {
1:8012f28:                                 LOG.error("RESPONDENT: could not send reply message: " + e.getLocalizedMessage(), e);
1:8012f28:                                 respondentSendError.incrementAndGet();
1:8012f28:                             }
1:8012f28:                         } catch (JMSException e) {
1:8012f28:                             LOG.error("RESPONDENT: could not create the reply message: " + e.getLocalizedMessage(), e);
1:8012f28:                         } catch (InterruptedException e) {
1:8012f28:                             LOG.info("RESPONDENT could not generate a random number");
1:8012f28:                         }
1:8012f28:                     }
1:8012f28:                 }
1:8012f28:             } catch (JMSException e) {
1:8012f28:                 LOG.info("RESPONDENT: Could not set the message listener on the respondent");
1:8012f28:             }
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         protected void initProducer() throws JMSException {
1:8012f28:             this.producer = session.createProducer(null);
1:8012f28:             // so that we can get an advisory on sending with no consumers
1:8012f28:             this.producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:8012f28:         }
1:8012f28: 
1:8012f28:         @Override
1:8012f28:         protected void initConsumer() throws JMSException {
1:8012f28:             this.consumer = session.createConsumer(new ActiveMQQueue(QUEUE_NAME));
1:8012f28:         }
1:8012f28:     }
1:8012f28: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:8012f28
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import java.net.URI;
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Random;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicLong;
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import junit.framework.Test;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.region.policy.PriorityDispatchPolicy;
1: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.network.DemandForwardingBridgeSupport;
1: import org.apache.activemq.network.NetworkBridge;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.util.DefaultTestAppender;
1: import org.apache.log4j.Appender;
1: import org.apache.log4j.Level;
1: import org.apache.log4j.spi.LoggingEvent;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * @author <a href="http://www.christianposta.com/blog">Christian Posta</a>
1:  */
1: public class RequestReplyTempDestRemovalAdvisoryRaceTest extends JmsMultipleBrokersTestSupport {
1:     private static final Logger LOG = LoggerFactory.getLogger(RequestReplyTempDestRemovalAdvisoryRaceTest.class);
1: 
1:     private static final String BROKER_A = "BrokerA";
1:     private static final String BROKER_B = "BrokerB";
1:     private static final String BROKER_C = "BrokerC";
1: 
1:     private static final int NUM_RESPONDENTS = 1;
1:     private static final int NUM_SENDS = 1;
1:     private static final int RANDOM_SLEEP_FOR_RESPONDENT_MS = 0;
1:     private static final int RANDOM_SLEEP_FOR_SENDER_MS = 1;
1:     private static final String QUEUE_NAME = "foo.queue";
1:     private static String[] TEST_ITERATIONS = new String[]{QUEUE_NAME+"0", QUEUE_NAME+"1", QUEUE_NAME+"2", QUEUE_NAME+"3"};
1: 
1:     final AtomicLong messageCount = new AtomicLong(0);
1:     final AtomicLong respondentSendError = new AtomicLong(0);
1:     final AtomicLong responseReceived = new AtomicLong(0);
1:     final AtomicLong sendsWithNoConsumers = new AtomicLong(0);
1:     final AtomicLong forwardFailures = new AtomicLong(0);
1: 
1: 
1:     protected final AtomicBoolean shutdown = new AtomicBoolean(false);
1:     HashSet<NetworkConnector> networkConnectors = new HashSet<NetworkConnector>();
1:     HashSet<Connection> advisoryConsumerConnections = new HashSet<Connection>();
1:     Appender slowDownAppender;
1: 
1:     CountDownLatch consumerDemandExists;
1: 
1:     protected boolean useDuplex = false;
1: 
1:     public static Test suite() {
1:         return suite(RequestReplyTempDestRemovalAdvisoryRaceTest.class);
1:     }
1: 
1:     /**
1:      * Notes: to reliably reproduce use debugger... set a "thread" breakpoint at line 679 in DemandForwardingBridgeSupport,
1:      * and only break on the "2nd" pass (broker C's bridge). Allow debugging to continue shortly after hitting
1:      * the breakpoint, for this test we use a logging appender to implement the pause,
1:      * it fails most of the time, hence the combos
1:      */
1:     public void initCombos() {
1:         addCombinationValues("QUEUE_NAME", TEST_ITERATIONS);
1:     }
1: 
1:     public void testTempDestRaceDuplex() throws Exception {
1:         // duplex
1:         useDuplex = true;
1:         bridgeBrokers(BROKER_A, BROKER_B, false, 3);
1:         bridgeBrokers(BROKER_B, BROKER_C, false, 3);
1: 
1:         startAllBrokers();
1: 
1:         waitForBridgeFormation(1);
1: 
1:         HashSet<NetworkBridge> bridgesStart = new HashSet<NetworkBridge>();
1:         for (NetworkConnector networkConnector : networkConnectors) {
1:             bridgesStart.addAll(networkConnector.activeBridges());
1:         }
1:         LOG.info("Bridges start:" + bridgesStart);
1: 
1:         slowDownAdvisoryDispatch();
1:         noConsumerAdvisory();
1:         forwardFailureAdvisory();
1: 
1:         // set up respondents
1:         ExecutorService respondentThreadPool = Executors.newFixedThreadPool(50);
1:         BrokerItem brokerA = brokers.get(BROKER_A);
1:         ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme("tcp").getName()
1:                 + "?jms.watchTopicAdvisories=false");
1:         brokerAFactory.setAlwaysSyncSend(true);
1:         for (int i = 0; i < NUM_RESPONDENTS; i++) {
1:             respondentThreadPool.execute(new EchoRespondent(brokerAFactory));
1:         }
1: 
1:         // fire off sends
1:         ExecutorService senderThreadPool = Executors.newCachedThreadPool();
1:         BrokerItem brokerC = brokers.get(BROKER_C);
1:         ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName()
1:                 + "?jms.watchTopicAdvisories=false");
1:         for (int i = 0; i < NUM_SENDS; i++) {
1:             senderThreadPool.execute(new MessageSender(brokerCFactory));
1:         }
1: 
1:         senderThreadPool.shutdown();
1:         senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);
1:         TimeUnit.SECONDS.sleep(15);
1:         LOG.info("shutting down");
1:         shutdown.compareAndSet(false, true);
1: 
1:         HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();
1:         for (NetworkConnector networkConnector : networkConnectors) {
1:             bridgesEnd.addAll(networkConnector.activeBridges());
1:         }
1:         LOG.info("Bridges end:" + bridgesEnd);
1: 
1:         assertEquals("no new bridges created", bridgesStart, bridgesEnd);
1: 
1:         // validate success or error of dlq
1:         LOG.info("received: " + responseReceived.get() + ", respondent error: " + respondentSendError.get()
1:                 + ", noConsumerCount: " + sendsWithNoConsumers.get()
1:                 + ", forwardFailures: " + forwardFailures.get());
1:         assertEquals("success or error", NUM_SENDS, respondentSendError.get() + forwardFailures.get()
1:                 + responseReceived.get() + sendsWithNoConsumers.get());
1: 
1:     }
1: 
1:     private void forwardFailureAdvisory() throws JMSException {
1:         for (BrokerItem item : brokers.values()) {
1:             ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(item.broker.getTransportConnectorByScheme("tcp").getName()
1:                     + "?jms.watchTopicAdvisories=false");
1:             Connection connection = brokerAFactory.createConnection();
1:             connection.start();
1:             connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(
1:                     AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic()).setMessageListener(new MessageListener() {
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     forwardFailures.incrementAndGet();
1:                 }
1:             });
1:         }
1:     }
1: 
1:     private void noConsumerAdvisory() throws JMSException {
1:         for (BrokerItem item : brokers.values()) {
1:             ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(item.broker.getTransportConnectorByScheme("tcp").getName()
1:                     + "?jms.watchTopicAdvisories=false");
1:             Connection connection = brokerAFactory.createConnection();
1:             connection.start();
1:             connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(
1:                     AdvisorySupport.getNoTopicConsumersAdvisoryTopic(new ActiveMQTempTopic(">"))).setMessageListener(new MessageListener() {
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     sendsWithNoConsumers.incrementAndGet();
1:                 }
1:             });
1:         }
1:     }
1: 
1: 
1:     public void testTempDestRace() throws Exception {
1:         // non duplex
1:         bridgeBrokers(BROKER_A, BROKER_B, false, 3);
1:         bridgeBrokers(BROKER_B, BROKER_A, false, 3);
1:         bridgeBrokers(BROKER_B, BROKER_C, false, 3);
1:         bridgeBrokers(BROKER_C, BROKER_B, false, 3);
1: 
1:         startAllBrokers();
1: 
1:         waitForBridgeFormation(1);
1: 
1:         HashSet<NetworkBridge> bridgesStart = new HashSet<NetworkBridge>();
1:         for (NetworkConnector networkConnector : networkConnectors) {
1:             bridgesStart.addAll(networkConnector.activeBridges());
1:         }
1: 
1:         slowDownAdvisoryDispatch();
1:         noConsumerAdvisory();
1:         forwardFailureAdvisory();
1: 
1: 
1:         // set up respondents
1:         ExecutorService respondentThreadPool = Executors.newFixedThreadPool(50);
1:         BrokerItem brokerA = brokers.get(BROKER_A);
1:         ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme("tcp").getName()
1:                 + "?jms.watchTopicAdvisories=false");
1:         brokerAFactory.setAlwaysSyncSend(true);
1:         for (int i = 0; i < NUM_RESPONDENTS; i++) {
1:             respondentThreadPool.execute(new EchoRespondent(brokerAFactory));
1:         }
1: 
1:         // fire off sends
1:         ExecutorService senderThreadPool = Executors.newCachedThreadPool();
1:         BrokerItem brokerC = brokers.get(BROKER_C);
1:         ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName()
1:                 + "?jms.watchTopicAdvisories=false");
1:         for (int i = 0; i < NUM_SENDS; i++) {
1:             senderThreadPool.execute(new MessageSender(brokerCFactory));
1:         }
1: 
1:         senderThreadPool.shutdown();
1:         senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);
1:         TimeUnit.SECONDS.sleep(10);
1:         LOG.info("shutting down");
1:         shutdown.compareAndSet(false, true);
1: 
1:         HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();
1:         for (NetworkConnector networkConnector : networkConnectors) {
1:             bridgesEnd.addAll(networkConnector.activeBridges());
1:         }
1:         assertEquals("no new bridges created", bridgesStart, bridgesEnd);
1: 
1:         // validate success or error or dlq
1:         LOG.info("received: " + responseReceived.get() + ", respondent error: " + respondentSendError.get()
1:                 + ", noConsumerCount: " + sendsWithNoConsumers.get()
1:                 + ", forwardFailures: " + forwardFailures.get());
1:         assertEquals("success or error", NUM_SENDS, respondentSendError.get() + forwardFailures.get()
1:                 + responseReceived.get() + sendsWithNoConsumers.get());
1: 
1:     }
1: 
1:     private void slowDownAdvisoryDispatch() throws Exception {
1: 
1:         org.apache.log4j.Logger.getLogger(DemandForwardingBridgeSupport.class).setLevel(Level.DEBUG);
1: 
1:         // instrument a logger to block the processing of a remove sub advisory
1:         // simulate a slow thread
1:         slowDownAppender = new DefaultTestAppender() {
1:             @Override
1:             public void doAppend(LoggingEvent loggingEvent) {
1:                 if (Level.DEBUG.equals(loggingEvent.getLevel())) {
1:                     String message = loggingEvent.getMessage().toString();
1:                     if (message.startsWith("BrokerB") && message.contains("remove local subscription")) {
1:                         // sleep for a bit
1:                         try {
1:                             consumerDemandExists.countDown();
1:                             System.err.println("Sleeping on receipt of remove info debug message: " + message);
1:                             TimeUnit.SECONDS.sleep(2);
1:                         } catch (Exception ignored) {
1:                         }
1:                     }
1: 
1:                 }
1:             }
1:         };
1: 
1:         org.apache.log4j.Logger.getRootLogger().addAppender(slowDownAppender);
1:     }
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         responseReceived.set(0);
1:         respondentSendError.set(0);
1:         forwardFailures.set(0);
1:         sendsWithNoConsumers.set(0);
1:         networkConnectors.clear();
1:         advisoryConsumerConnections.clear();
1:         consumerDemandExists = new CountDownLatch(1);
1:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_A + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_B + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1:         createBroker(new URI("broker:(tcp://localhost:0)/" + BROKER_C + "?persistent=false&useJmx=false")).setDedicatedTaskRunner(false);
1: 
1:         PolicyMap map = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setSendAdvisoryIfNoConsumers(true);
1:         DeadLetterStrategy deadletterStrategy = new SharedDeadLetterStrategy();
1:         deadletterStrategy.setProcessNonPersistent(true);
1:         defaultEntry.setDeadLetterStrategy(deadletterStrategy);
1:         defaultEntry.setDispatchPolicy(new PriorityDispatchPolicy());
1:         map.put(new ActiveMQTempTopic(">"), defaultEntry);
1: 
1:         for (BrokerItem item : brokers.values()) {
1:             item.broker.setDestinationPolicy(map);
1:         }
1:     }
1: 
1:     @Override
1:     protected void tearDown() throws Exception {
1:         if (slowDownAppender != null) {
1:             org.apache.log4j.Logger.getRootLogger().removeAppender(slowDownAppender);
1:         }
1:         for (Connection connection : advisoryConsumerConnections) {
1:             connection.close();
1:         }
1:         super.tearDown();
1:     }
1: 
1:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly, int networkTTL) throws Exception {
1:         NetworkConnector connector = super.bridgeBrokers(localBrokerName, remoteBrokerName, dynamicOnly, networkTTL, true);
1:         connector.setBridgeTempDestinations(true);
1:         connector.setAdvisoryForFailedForward(true);
1:         connector.setDuplex(useDuplex);
1:         connector.setAlwaysSyncSend(true);
1:         networkConnectors.add(connector);
1:         return connector;
1:     }
1: 
1:     abstract class MessageClient {
1:         protected Connection connection;
1:         protected Session session;
1:         protected MessageConsumer consumer;
1:         protected MessageProducer producer;
1:         protected Random random;
1:         protected int timeToSleep;
1: 
1:         // set up the connection and session
1:         public MessageClient(ActiveMQConnectionFactory factory, int timeToSleep) throws Exception {
1:             this.connection = factory.createConnection();
1:             this.session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             this.timeToSleep = timeToSleep;
1:             this.random = new Random(System.currentTimeMillis());
1:             preInit();
1:             initProducer();
1:             initConsumer();
1:             this.connection.start();
1:         }
1: 
1:         protected void preInit() throws JMSException {
1: 
1:         }
1: 
1:         abstract protected void initProducer() throws JMSException;
1: 
1:         abstract protected void initConsumer() throws JMSException;
1:     }
1: 
1:     class MessageSender extends MessageClient implements Runnable {
1: 
1: 
1:         protected Destination tempDest;
1: 
1:         public MessageSender(ActiveMQConnectionFactory factory) throws Exception {
1:             super(factory, RANDOM_SLEEP_FOR_SENDER_MS);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             // create a message
1:             try {
1:                 TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());
1:                 message.setJMSReplyTo(tempDest);
1:                 producer.send(message);
1:                 LOG.info("SENDER: Message [" + message.getText() + "] has been sent.");
1: 
1:                 Message incomingMessage = consumer.receive(timeToSleep);
1:                 if (incomingMessage instanceof TextMessage) {
1:                     try {
1:                         LOG.info("SENDER: Got a response from echo service!" + ((TextMessage) incomingMessage).getText());
1:                         responseReceived.incrementAndGet();
1:                     } catch (JMSException e) {
1:                         LOG.error("SENDER: might want to see why i'm getting non-text messages..." + incomingMessage, e);
1:                     }
1:                 } else {
1:                     LOG.info("SENDER: Did not get a response this time");
1:                 }
1: 
1: 
1:             } catch (JMSException e) {
1:                 LOG.error("SENDER: Could not complete message sending properly: " + e.getMessage());
1:             } finally {
1:                 try {
1:                     producer.close();
1:                     consumer.close();
1:                     session.close();
1:                     connection.close();
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }
1: 
1:         @Override
1:         protected void preInit() throws JMSException {
1:             this.tempDest = session.createTemporaryTopic();
1: 
1:         }
1: 
1:         @Override
1:         protected void initProducer() throws JMSException {
1:             this.producer = session.createProducer(new ActiveMQQueue(QUEUE_NAME));
1:         }
1: 
1:         @Override
1:         protected void initConsumer() throws JMSException {
1:             this.consumer = session.createConsumer(tempDest);
1:             LOG.info("consumer for: " + tempDest + ", " + consumer);
1: 
1:         }
1: 
1:     }
1: 
1:     class EchoRespondent extends MessageClient implements Runnable {
1: 
1:         public EchoRespondent(ActiveMQConnectionFactory factory) throws Exception {
1:             super(factory, RANDOM_SLEEP_FOR_RESPONDENT_MS);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 LOG.info("RESPONDENT LISTENING");
1:                 while (!shutdown.get()) {
1:                     Message incomingMessage = consumer.receive(1000);
1:                     if (incomingMessage instanceof TextMessage) {
1:                         ActiveMQTextMessage textMessage = (ActiveMQTextMessage) incomingMessage;
1:                         try {
1:                             LOG.info("RESPONDENT: Received a message: [" + textMessage.getText() + "]" + Arrays.asList(textMessage.getBrokerPath()));
1:                             Message message = session.createTextMessage("reply: " + textMessage.getText());
1:                             Destination replyTo = incomingMessage.getJMSReplyTo();
1:                             TimeUnit.MILLISECONDS.sleep(timeToSleep);
1:                             consumerDemandExists.await(5, TimeUnit.SECONDS);
1:                             try {
1:                                 producer.send(replyTo, message);
1:                                 LOG.info("RESPONDENT: sent reply:" + message.getJMSMessageID() + " back to: " + replyTo);
1:                             } catch (JMSException e) {
1:                                 LOG.error("RESPONDENT: could not send reply message: " + e.getLocalizedMessage(), e);
1:                                 respondentSendError.incrementAndGet();
1:                             }
1:                         } catch (JMSException e) {
1:                             LOG.error("RESPONDENT: could not create the reply message: " + e.getLocalizedMessage(), e);
1:                         } catch (InterruptedException e) {
1:                             LOG.info("RESPONDENT could not generate a random number");
1:                         }
1:                     }
1:                 }
1:             } catch (JMSException e) {
1:                 LOG.info("RESPONDENT: Could not set the message listener on the respondent");
1:             }
1:         }
1: 
1:         @Override
1:         protected void initProducer() throws JMSException {
1:             this.producer = session.createProducer(null);
1:             // so that we can get an advisory on sending with no consumers
1:             this.producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         }
1: 
1:         @Override
1:         protected void initConsumer() throws JMSException {
1:             this.consumer = session.createConsumer(new ActiveMQQueue(QUEUE_NAME));
1:         }
1:     }
1: }
============================================================================