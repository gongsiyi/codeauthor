1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
43:d29ca2a: 
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Arrays;
1:e6254c2: import java.util.HashMap;
1:ecf89a6: import java.util.List;
1:d29ca2a: 
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.TransactionInProgressException;
1:62daac4: import javax.jms.TransactionRolledBackException;
1:d29ca2a: import javax.transaction.xa.XAException;
1:d29ca2a: import javax.transaction.xa.XAResource;
1:d29ca2a: import javax.transaction.xa.Xid;
1:d29ca2a: 
1:d29ca2a: import org.apache.activemq.command.ConnectionId;
1:d29ca2a: import org.apache.activemq.command.DataArrayResponse;
1:74a7a8b: import org.apache.activemq.command.DataStructure;
1:d29ca2a: import org.apache.activemq.command.IntegerResponse;
1:d29ca2a: import org.apache.activemq.command.LocalTransactionId;
1:d29ca2a: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.command.TransactionInfo;
1:d29ca2a: import org.apache.activemq.command.XATransactionId;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:d29ca2a: import org.apache.activemq.util.JMSExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.LongSequenceGenerator;
1:8e7556f: import org.apache.activemq.util.XASupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * A TransactionContext provides the means to control a JMS transaction. It
1:230a86c:  * provides a local transaction interface and also an XAResource interface. <p/>
1:230a86c:  * An application server controls the transactional assignment of an XASession
1:230a86c:  * by obtaining its XAResource. It uses the XAResource to assign the session to
1:230a86c:  * a transaction, prepare and commit work on the transaction, and so on. <p/> An
1:230a86c:  * XAResource provides some fairly sophisticated facilities for interleaving
1:230a86c:  * work on multiple transactions, recovering a list of transactions in progress,
1:230a86c:  * and so on. A JTA aware JMS provider must fully implement this functionality.
1:230a86c:  * This could be done by using the services of a database that supports XA, or a
1:230a86c:  * JMS provider may choose to implement this functionality from scratch. <p/>
1:b0c2a40:  *
1:d29ca2a:  *
1:d29ca2a:  * @see javax.jms.Session
1:d29ca2a:  * @see javax.jms.QueueSession
1:d29ca2a:  * @see javax.jms.TopicSession
1:d29ca2a:  * @see javax.jms.XASession
1:d29ca2a:  */
1:d29ca2a: public class TransactionContext implements XAResource {
1:230a86c: 
1:ab1e9c7:     public static final String xaErrorCodeMarker = "xaErrorCode:";
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TransactionContext.class);
1:d29ca2a: 
1:d29ca2a:     // XATransactionId -> ArrayList of TransactionContext objects
1:e6254c2:     private final static HashMap<TransactionId, List<TransactionContext>> ENDED_XA_TRANSACTION_CONTEXTS =
1:8e7556f:             new HashMap<TransactionId, List<TransactionContext>>();
1:d29ca2a: 
1:e8818fa:     private ActiveMQConnection connection;
1:d29ca2a:     private final LongSequenceGenerator localTransactionIdGenerator;
1:185711e:     private List<Synchronization> synchronizations;
1:d29ca2a: 
1:d29ca2a:     // To track XA transactions.
1:d29ca2a:     private Xid associatedXid;
1:d29ca2a:     private TransactionId transactionId;
1:d29ca2a:     private LocalTransactionEventListener localTransactionEventListener;
1:39d0717:     private int beforeEndIndex;
1:8d98247:     private volatile boolean rollbackOnly;
1:d29ca2a: 
1:e8818fa:     // for RAR recovery
1:e8818fa:     public TransactionContext() {
1:e8818fa:         localTransactionIdGenerator = null;
1:e8818fa:     }
1:e8818fa: 
1:d29ca2a:     public TransactionContext(ActiveMQConnection connection) {
1:d29ca2a:         this.connection = connection;
1:d29ca2a:         this.localTransactionIdGenerator = connection.getLocalTransactionIdGenerator();
1:ecf89a6:     }
1:05586ed: 
1:d29ca2a:     public boolean isInXATransaction() {
1:e6254c2:         if (transactionId != null && transactionId.isXATransaction()) {
1:8e7556f:             return true;
1:d29ca2a:         } else {
1:9a78bc6:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                 for(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {
1:9a78bc6:                       if (transactions.contains(this)) {
1:9a78bc6:                           return true;
1:9a78bc6:                       }
1:8e7556f:                 }
1:8e7556f:             }
1:8e7556f:         }
1:d29ca2a: 
1:e6254c2:         return false;
1:8e7556f:     }
1:d29ca2a: 
1:8d98247:     public void setRollbackOnly(boolean val) {
1:8d98247:         rollbackOnly = val;
1:8d98247:     }
1:8d98247: 
1:d29ca2a:     public boolean isInLocalTransaction() {
1:d29ca2a:         return transactionId != null && transactionId.isLocalTransaction();
1:ecf89a6:     }
1:d29ca2a: 
1:4046599:     public boolean isInTransaction() {
1:4046599:         return transactionId != null;
1:4046599:     }
1:4046599: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the localTransactionEventListener.
1:d29ca2a:      */
1:d29ca2a:     public LocalTransactionEventListener getLocalTransactionEventListener() {
1:d29ca2a:         return localTransactionEventListener;
1:ecf89a6:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Used by the resource adapter to listen to transaction events.
1:d29ca2a:      *
1:230a86c:      * @param localTransactionEventListener The localTransactionEventListener to
1:230a86c:      *                set.
1:d29ca2a:      */
1:d29ca2a:     public void setLocalTransactionEventListener(LocalTransactionEventListener localTransactionEventListener) {
1:d29ca2a:         this.localTransactionEventListener = localTransactionEventListener;
1:ecf89a6:     }
1:d29ca2a: 
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a:     //
1:230a86c:     // Methods that work with the Synchronization objects registered with
1:d29ca2a:     // the transaction.
1:d29ca2a:     //
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:230a86c: 
1:d29ca2a:     public void addSynchronization(Synchronization s) {
1:185711e:         if (synchronizations == null) {
1:185711e:             synchronizations = new ArrayList<Synchronization>(10);
1:ecf89a6:         }
1:185711e:         synchronizations.add(s);
1:fc00993:     }
1:230a86c: 
1:d29ca2a:     private void afterRollback() throws JMSException {
1:185711e:         if (synchronizations == null) {
1:d29ca2a:             return;
1:ecf89a6:         }
1:230a86c: 
1:101e711:         Throwable firstException = null;
1:185711e:         int size = synchronizations.size();
1:101e711:         for (int i = 0; i < size; i++) {
1:8e7556f:             try {
1:185711e:                 synchronizations.get(i).afterRollback();
1:101e711:             } catch (Throwable t) {
1:8e7556f:                 LOG.debug("Exception from afterRollback on {}", synchronizations.get(i), t);
1:101e711:                 if (firstException == null) {
1:101e711:                     firstException = t;
1:101e711:                 }
1:101e711:             }
1:ecf89a6:         }
1:101e711:         synchronizations = null;
1:101e711:         if (firstException != null) {
1:101e711:             throw JMSExceptionSupport.create(firstException);
1:86cbdfd:         }
43:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void afterCommit() throws JMSException {
1:185711e:         if (synchronizations == null) {
1:d29ca2a:             return;
1:ecf89a6:         }
1:d29ca2a: 
1:101e711:         Throwable firstException = null;
1:185711e:         int size = synchronizations.size();
1:101e711:         for (int i = 0; i < size; i++) {
1:101e711:             try {
1:185711e:                 synchronizations.get(i).afterCommit();
1:101e711:             } catch (Throwable t) {
1:8e7556f:                 LOG.debug("Exception from afterCommit on {}", synchronizations.get(i), t);
1:101e711:                 if (firstException == null) {
1:101e711:                     firstException = t;
1:101e711:                 }
1:101e711:             }
1:d29ca2a:         }
1:101e711:         synchronizations = null;
1:101e711:         if (firstException != null) {
1:101e711:             throw JMSExceptionSupport.create(firstException);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void beforeEnd() throws JMSException {
1:185711e:         if (synchronizations == null) {
1:d29ca2a:             return;
1:d29ca2a:         }
1:d29ca2a: 
1:185711e:         int size = synchronizations.size();
1:101e711:         try {
1:39d0717:             for (;beforeEndIndex < size;) {
1:39d0717:                 synchronizations.get(beforeEndIndex++).beforeEnd();
1:d29ca2a:             }
7:d29ca2a:         } catch (JMSException e) {
3:d29ca2a:             throw e;
3:d29ca2a:         } catch (Throwable e) {
3:d29ca2a:             throw JMSExceptionSupport.create(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public TransactionId getTransactionId() {
1:d29ca2a:         return transactionId;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Local transaction interface.
1:d29ca2a:     //
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Start a local transaction.
1:185711e:      * @throws javax.jms.JMSException on internal error
1:d29ca2a:      */
1:d29ca2a:     public void begin() throws JMSException {
1:d29ca2a: 
1:ecf89a6:         if (isInXATransaction()) {
1:230a86c:             throw new TransactionInProgressException("Cannot start local transaction.  XA transaction is already in progress.");
1:ecf89a6:         }
1:ecf89a6: 
1:230a86c:         if (transactionId == null) {
2:185711e:             synchronizations = null;
1:39d0717:             beforeEndIndex = 0;
1:8d98247:             setRollbackOnly(false);
1:e8818fa:             this.transactionId = new LocalTransactionId(getConnectionId(), localTransactionIdGenerator.getNextSequenceId());
1:d29ca2a:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);
1:230a86c:             this.connection.ensureConnectionInfoSent();
2:d29ca2a:             this.connection.asyncSendPacket(info);
1:05586ed: 
1:d29ca2a:             // Notify the listener that the tx was started.
2:d29ca2a:             if (localTransactionEventListener != null) {
1:d29ca2a:                 localTransactionEventListener.beginEvent();
1:d29ca2a:             }
1:d29ca2a: 
1:8e7556f:             LOG.debug("Begin:{}", transactionId);
1:8e7556f:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Rolls back any work done in this transaction and releases any locks
1:d29ca2a:      * currently held.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to roll back the
1:230a86c:      *                 transaction due to some internal error.
1:230a86c:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:230a86c:      *                 transacted session.
1:d29ca2a:      */
1:d29ca2a:     public void rollback() throws JMSException {
1:ecf89a6:         if (isInXATransaction()) {
1:d29ca2a:             throw new TransactionInProgressException("Cannot rollback() if an XA transaction is already in progress ");
1:ecf89a6:         }
1:ecf89a6: 
1:101e711:         try {
1:62daac4:             beforeEnd();
1:62daac4:         } catch (TransactionRolledBackException canOcurrOnFailover) {
1:62daac4:             LOG.warn("rollback processing error", canOcurrOnFailover);
1:62daac4:         }
1:230a86c:         if (transactionId != null) {
1:8e7556f:             LOG.debug("Rollback: {} syncCount: {}",
1:8e7556f:                 transactionId, (synchronizations != null ? synchronizations.size() : 0));
1:132f662: 
1:d29ca2a:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.ROLLBACK);
1:d29ca2a:             this.transactionId = null;
1:612437c:             //make this synchronous - see https://issues.apache.org/activemq/browse/AMQ-2364
1:a65f5e7:             this.connection.syncSendPacket(info, this.connection.isClosing() ? this.connection.getCloseTimeout() : 0);
1:d29ca2a:             // Notify the listener that the tx was rolled back
1:d29ca2a:             if (localTransactionEventListener != null) {
1:d29ca2a:                 localTransactionEventListener.rollbackEvent();
1:132f662:             }
1:132f662:         }
1:230a86c: 
1:d29ca2a:         afterRollback();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Commits all work done in this transaction and releases any locks
1:d29ca2a:      * currently held.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to commit the transaction
1:230a86c:      *                 due to some internal error.
1:230a86c:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:230a86c:      *                 transacted session.
1:d29ca2a:      */
1:d29ca2a:     public void commit() throws JMSException {
1:ecf89a6:         if (isInXATransaction()) {
1:d29ca2a:             throw new TransactionInProgressException("Cannot commit() if an XA transaction is already in progress ");
1:ecf89a6:         }
1:ecf89a6: 
1:31c01f8:         try {
1:62daac4:             beforeEnd();
1:62daac4:         } catch (JMSException e) {
1:62daac4:             rollback();
1:62daac4:             throw e;
1:62daac4:         }
1:230a86c: 
1:fc25535:         if (transactionId != null && rollbackOnly) {
1:8d98247:             final String message = "Commit of " + transactionId + "  failed due to rollback only request; typically due to failover with pending acks";
1:8d98247:             try {
1:8d98247:                 rollback();
1:8d98247:             } finally {
1:8d98247:                 LOG.warn(message);
1:8d98247:                 throw new TransactionRolledBackException(message);
1:8d98247:             }
1:8d98247:         }
1:8d98247: 
1:d29ca2a:         // Only send commit if the transaction was started.
1:230a86c:         if (transactionId != null) {
1:8e7556f:             LOG.debug("Commit: {} syncCount: {}",
1:8e7556f:                 transactionId, (synchronizations != null ? synchronizations.size() : 0));
1:132f662: 
1:d29ca2a:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.COMMIT_ONE_PHASE);
1:d29ca2a:             this.transactionId = null;
1:d29ca2a:             // Notify the listener that the tx was committed back
1:eedda6f:             try {
1:0a12bcb:                 this.connection.syncSendPacket(info);
1:b836af8:                 if (localTransactionEventListener != null) {
1:b836af8:                     localTransactionEventListener.commitEvent();
1:b836af8:                 }
1:b836af8:                 afterCommit();
1:b836af8:             } catch (JMSException cause) {
1:8e7556f:                 LOG.info("commit failed for transaction {}", info.getTransactionId(), cause);
1:b836af8:                 if (localTransactionEventListener != null) {
1:b836af8:                     localTransactionEventListener.rollbackEvent();
1:b836af8:                 }
1:b836af8:                 afterRollback();
1:b836af8:                 throw cause;
1:d29ca2a:             }
1:b836af8: 
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // XAResource Implementation
1:d29ca2a:     //
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a:     /**
1:d29ca2a:      * Associates a transaction with the resource.
1:d29ca2a:      */
1:8e7556f:     @Override
1:d29ca2a:     public void start(Xid xid, int flags) throws XAException {
1:230a86c: 
1:8e7556f:         LOG.debug("Start: {}, flags: {}", xid, XASupport.toString(flags));
1:8e7556f: 
1:fc00993:         if (isInLocalTransaction()) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:fc00993:         }
1:d29ca2a:         // Are we already associated?
1:d29ca2a:         if (associatedXid != null) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:230a86c:         }
1:230a86c: 
1:230a86c:         // if ((flags & TMJOIN) == TMJOIN) {
1:4411ff6:         // TODO: verify that the server has seen the xid
1:c9c6e62:         // // }
1:8e7556f:         // if ((flags & TMRESUME) == TMRESUME) {
1:230a86c:         // // TODO: verify that the xid was suspended.
2:230a86c:         // }
1:d29ca2a: 
1:d29ca2a:         // associate
1:c9c6e62:         synchronizations = null;
1:39d0717:         beforeEndIndex = 0;
1:8d98247:         setRollbackOnly(false);
1:d29ca2a:         setXid(xid);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:185711e:      * @return connectionId for connection
1:d29ca2a:      */
1:d29ca2a:     private ConnectionId getConnectionId() {
1:d29ca2a:         return connection.getConnectionInfo().getConnectionId();
1:d29ca2a:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public void end(Xid xid, int flags) throws XAException {
1:ecf89a6: 
1:8e7556f:         LOG.debug("End: {}, flags: {}", xid, XASupport.toString(flags));
1:ecf89a6: 
1:ecf89a6:         if (isInLocalTransaction()) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:ecf89a6:         }
1:230a86c: 
1:230a86c:         if ((flags & (TMSUSPEND | TMFAIL)) != 0) {
1:d29ca2a:             // You can only suspend the associated xid.
1:d29ca2a:             if (!equals(associatedXid, xid)) {
1:d29ca2a:                 throw new XAException(XAException.XAER_PROTO);
1:d29ca2a:             }
1:0a12bcb:             invokeBeforeEnd();
1:d29ca2a:         } else if ((flags & TMSUCCESS) == TMSUCCESS) {
1:d29ca2a:             // set to null if this is the current xid.
1:d29ca2a:             // otherwise this could be an asynchronous success call
1:d29ca2a:             if (equals(associatedXid, xid)) {
1:0a12bcb:                 invokeBeforeEnd();
1:d29ca2a:             }
1:d29ca2a:         } else {
1:d29ca2a:             throw new XAException(XAException.XAER_INVAL);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:0a12bcb:     private void invokeBeforeEnd() throws XAException {
1:0a12bcb:         boolean throwingException = false;
1:0a12bcb:         try {
1:0a12bcb:             beforeEnd();
1:0a12bcb:         } catch (JMSException e) {
1:0a12bcb:             throwingException = true;
1:0a12bcb:             throw toXAException(e);
1:0a12bcb:         } finally {
1:0a12bcb:             try {
1:0a12bcb:                 setXid(null);
1:0a12bcb:             } catch (XAException ignoreIfWillMask){
1:0a12bcb:                 if (!throwingException) {
1:0a12bcb:                     throw ignoreIfWillMask;
1:0a12bcb:                 }
1:0a12bcb:             }
1:0a12bcb:         }
1:0a12bcb:     }
1:0a12bcb: 
1:d29ca2a:     private boolean equals(Xid xid1, Xid xid2) {
1:ecf89a6:         if (xid1 == xid2) {
1:8e7556f:             return true;
1:ecf89a6:         }
1:ecf89a6:         if (xid1 == null ^ xid2 == null) {
1:d29ca2a:             return false;
1:ecf89a6:         }
1:230a86c:         return xid1.getFormatId() == xid2.getFormatId() && Arrays.equals(xid1.getBranchQualifier(), xid2.getBranchQualifier())
1:230a86c:                && Arrays.equals(xid1.getGlobalTransactionId(), xid2.getGlobalTransactionId());
1:ecf89a6:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public int prepare(Xid xid) throws XAException {
1:8e7556f:         LOG.debug("Prepare: {}", xid);
1:ecf89a6: 
1:d29ca2a:         // We allow interleaving multiple transactions, so
1:d29ca2a:         // we don't limit prepare to the associated xid.
1:d29ca2a:         XATransactionId x;
1:d29ca2a:         // THIS SHOULD NEVER HAPPEN because end(xid, TMSUCCESS) should have been
1:d29ca2a:         // called first
1:230a86c:         if (xid == null || (equals(associatedXid, xid))) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:d29ca2a:         } else {
1:d29ca2a:             // TODO: cache the known xids so we don't keep recreating this one??
1:d29ca2a:             x = new XATransactionId(xid);
1:230a86c:         }
1:d29ca2a: 
1:8d98247:         if (rollbackOnly) {
1:8d98247:             LOG.warn("prepare of: " + x + " failed because it was marked rollback only; typically due to failover with pending acks");
1:8d98247:             throw new XAException(XAException.XA_RBINTEGRITY);
1:8d98247:         }
1:8d98247: 
1:e5896c0:         try {
1:d29ca2a:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.PREPARE);
1:230a86c: 
1:d29ca2a:             // Find out if the server wants to commit or rollback.
1:0a12bcb:             IntegerResponse response = (IntegerResponse)this.connection.syncSendPacket(info);
1:4eafccc:             if (XAResource.XA_RDONLY == response.getResult()) {
1:4eafccc:                 // transaction stops now, may be syncs that need a callback
1:9a78bc6:                 List<TransactionContext> l;
1:8e7556f:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                     l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:9a78bc6:                 }
1:9a78bc6:                 // After commit may be expensive and can deadlock, do it outside global synch block
1:9a78bc6:                 // No risk for concurrent updates as we own the list now
1:9a78bc6:                 if (l != null) {
1:9a78bc6:                     if(! l.isEmpty()) {
1:8e7556f:                         LOG.debug("firing afterCommit callbacks on XA_RDONLY from prepare: {}", xid);
1:9a78bc6:                         for (TransactionContext ctx : l) {
1:9a78bc6:                             ctx.afterCommit();
1:9a78bc6:                         }
1:8e7556f:                     }
1:8e7556f:                 }
1:8e7556f:             }
1:d29ca2a:             return response.getResult();
1:230a86c: 
1:d29ca2a:         } catch (JMSException e) {
1:eedda6f:             LOG.warn("prepare of: " + x + " failed with: " + e, e);
1:9a78bc6:             List<TransactionContext> l;
1:8e7556f:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:9a78bc6:             }
1:9a78bc6:             // After rollback may be expensive and can deadlock, do it outside global synch block
1:9a78bc6:             // No risk for concurrent updates as we own the list now
1:9a78bc6:             if (l != null) {
1:9a78bc6:                 for (TransactionContext ctx : l) {
1:9a78bc6:                     try {
1:9a78bc6:                         ctx.afterRollback();
1:9a78bc6:                     } catch (Throwable ignored) {
1:9a78bc6:                         LOG.debug("failed to firing afterRollback callbacks on prepare " +
1:9a78bc6:                                   "failure, txid: {}, context: {}", x, ctx, ignored);
1:8e7556f:                     }
1:8e7556f:                 }
1:8e7556f:             }
5:d29ca2a:             throw toXAException(e);
1:8e7556f:         }
1:8e7556f:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public void rollback(Xid xid) throws XAException {
1:230a86c: 
1:31c01f8:         if (LOG.isDebugEnabled()) {
1:fc00993:             LOG.debug("Rollback: " + xid);
1:eedda6f:         }
1:e45bb06: 
1:d29ca2a:         // We allow interleaving multiple transactions, so
1:d29ca2a:         // we don't limit rollback to the associated xid.
1:d29ca2a:         XATransactionId x;
1:230a86c:         if (xid == null) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:eedda6f:         }
1:d29ca2a:         if (equals(associatedXid, xid)) {
1:d29ca2a:             // I think this can happen even without an end(xid) call. Need to
1:d29ca2a:             // check spec.
1:230a86c:             x = (XATransactionId)transactionId;
1:d29ca2a:         } else {
1:d29ca2a:             x = new XATransactionId(xid);
1:eedda6f:         }
1:ecf89a6: 
1:9a78bc6:         try {
1:230a86c:             this.connection.checkClosedOrFailed();
1:230a86c:             this.connection.ensureConnectionInfoSent();
1:230a86c: 
1:d29ca2a:             // Let the server know that the tx is rollback.
1:d29ca2a:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.ROLLBACK);
1:0a12bcb:             this.connection.syncSendPacket(info);
1:230a86c: 
1:9a78bc6:             List<TransactionContext> l;
1:8e7556f:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:9a78bc6:             }
1:9a78bc6:             // After rollback may be expensive and can deadlock, do it outside global synch block
1:9a78bc6:             // No risk for concurrent updates as we own the list now
1:9a78bc6:             if (l != null) {
1:9a78bc6:                 for (TransactionContext ctx : l) {
1:9a78bc6:                     ctx.afterRollback();
1:9a78bc6:                 }                  
1:8e7556f:             }
1:05586ed:         } catch (JMSException e) {
1:05586ed:             throw toXAException(e);
1:8e7556f:         }
1:8e7556f:     }
1:05586ed: 
1:d29ca2a:     // XAResource interface
1:8e7556f:     @Override
1:d29ca2a:     public void commit(Xid xid, boolean onePhase) throws XAException {
1:ecf89a6: 
1:8e7556f:         LOG.debug("Commit: {}, onePhase={}", xid, onePhase);
1:230a86c: 
1:d29ca2a:         // We allow interleaving multiple transactions, so
1:d29ca2a:         // we don't limit commit to the associated xid.
1:d29ca2a:         XATransactionId x;
1:230a86c:         if (xid == null || (equals(associatedXid, xid))) {
1:d29ca2a:             // should never happen, end(xid,TMSUCCESS) must have been previously
1:d29ca2a:             // called
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:d29ca2a:         } else {
1:d29ca2a:             x = new XATransactionId(xid);
1:eedda6f:         }
1:d29ca2a: 
1:8d98247:         if (rollbackOnly) {
1:8d98247:              LOG.warn("commit of: " + x + " failed because it was marked rollback only; typically due to failover with pending acks");
1:8d98247:              throw new XAException(XAException.XA_RBINTEGRITY);
1:8d98247:          }
1:8d98247: 
1:8e7556f:         try {
1:230a86c:             this.connection.checkClosedOrFailed();
1:230a86c:             this.connection.ensureConnectionInfoSent();
1:d29ca2a: 
1:d29ca2a:             // Notify the server that the tx was committed back
1:230a86c:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, onePhase ? TransactionInfo.COMMIT_ONE_PHASE : TransactionInfo.COMMIT_TWO_PHASE);
1:230a86c: 
1:0a12bcb:             this.connection.syncSendPacket(info);
1:230a86c: 
1:9a78bc6:             List<TransactionContext> l;
1:8e7556f:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:4eafccc:             }
1:9a78bc6:             // After commit may be expensive and can deadlock, do it outside global synch block
1:9a78bc6:             // No risk for concurrent updates as we own the list now
1:9a78bc6:             if (l != null) {
2:8e7556f:                 for (TransactionContext ctx : l) {
1:8e7556f:                     try {
1:8e7556f:                         ctx.afterCommit();
1:9a78bc6:                     } catch (Exception ignored) {
1:9a78bc6:                         LOG.debug("ignoring exception from after completion on ended transaction: {}", ignored, ignored);
1:8e7556f:                     }
1:8e7556f:                 }
1:8e7556f:             }
1:230a86c: 
1:d29ca2a:         } catch (JMSException e) {
1:e5896c0:             LOG.warn("commit of: " + x + " failed with: " + e, e);
1:31c01f8:             if (onePhase) {
1:9a78bc6:                 List<TransactionContext> l;
1:8e7556f:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                     l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:9a78bc6:                 }
1:9a78bc6:                 // After rollback may be expensive and can deadlock, do it outside global synch block
1:9a78bc6:                 // No risk for concurrent updates as we own the list now
1:9a78bc6:                 if (l != null) {
1:9a78bc6:                     for (TransactionContext ctx : l) {
1:9a78bc6:                         try {
1:9a78bc6:                             ctx.afterRollback();
1:9a78bc6:                         } catch (Throwable ignored) {
1:9a78bc6:                             LOG.debug("failed to firing afterRollback callbacks commit failure, txid: {}, context: {}", x, ctx, ignored);
1:8e7556f:                         }
1:8e7556f:                     }
1:8e7556f:                 }
1:8e7556f:             }
1:d29ca2a:             throw toXAException(e);
1:101e711:         }
1:31c01f8:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public void forget(Xid xid) throws XAException {
1:8e7556f:         LOG.debug("Forget: {}", xid);
1:ecf89a6: 
1:d29ca2a:         // We allow interleaving multiple transactions, so
1:d29ca2a:         // we don't limit forget to the associated xid.
1:d29ca2a:         XATransactionId x;
1:230a86c:         if (xid == null) {
1:d29ca2a:             throw new XAException(XAException.XAER_PROTO);
1:e5896c0:         }
1:d29ca2a:         if (equals(associatedXid, xid)) {
1:d29ca2a:             // TODO determine if this can happen... I think not.
1:230a86c:             x = (XATransactionId)transactionId;
1:d29ca2a:         } else {
1:d29ca2a:             x = new XATransactionId(xid);
1:e5896c0:         }
1:d29ca2a: 
1:d29ca2a:         TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.FORGET);
1:230a86c: 
1:b836af8:         try {
1:d29ca2a:             // Tell the server to forget the transaction.
1:0a12bcb:             this.connection.syncSendPacket(info);
1:d29ca2a:         } catch (JMSException e) {
1:d29ca2a:             throw toXAException(e);
1:e5896c0:         }
1:8e7556f:         synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:8e7556f:             ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:8e7556f:         }
1:e5896c0:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public boolean isSameRM(XAResource xaResource) throws XAException {
1:d29ca2a:         if (xaResource == null) {
1:d29ca2a:             return false;
1:4eafccc:         }
1:d29ca2a:         if (!(xaResource instanceof TransactionContext)) {
1:d29ca2a:             return false;
1:4eafccc:         }
1:230a86c:         TransactionContext xar = (TransactionContext)xaResource;
1:62daac4:         try {
1:d29ca2a:             return getResourceManagerId().equals(xar.getResourceManagerId());
1:d29ca2a:         } catch (Throwable e) {
1:230a86c:             throw (XAException)new XAException("Could not get resource manager id.").initCause(e);
1:4eafccc:         }
1:e45bb06:     }
1:230a86c: 
1:8e7556f:     @Override
1:d29ca2a:     public Xid[] recover(int flag) throws XAException {
1:207d4cd:         LOG.debug("recover({})", flag);
1:16bc0f0:         XATransactionId[] answer;
1:ecf89a6: 
1:16bc0f0:         if (XAResource.TMNOFLAGS == flag) {
1:16bc0f0:             // signal next in cursor scan, which for us is always the end b/c we don't maintain any cursor state
1:16bc0f0:             // allows looping scan to complete
1:16bc0f0:             answer = new XATransactionId[0];
1:16bc0f0:         } else {
1:16bc0f0:             TransactionInfo info = new TransactionInfo(getConnectionId(), null, TransactionInfo.RECOVER);
1:16bc0f0:             try {
1:16bc0f0:                 this.connection.checkClosedOrFailed();
1:16bc0f0:                 this.connection.ensureConnectionInfoSent();
1:05586ed: 
1:16bc0f0:                 DataArrayResponse receipt = (DataArrayResponse) this.connection.syncSendPacket(info);
1:16bc0f0:                 DataStructure[] data = receipt.getData();
1:16bc0f0:                 if (data instanceof XATransactionId[]) {
1:16bc0f0:                     answer = (XATransactionId[]) data;
1:16bc0f0:                 } else {
1:16bc0f0:                     answer = new XATransactionId[data.length];
1:16bc0f0:                     System.arraycopy(data, 0, answer, 0, data.length);
1:16bc0f0:                 }
1:16bc0f0:             } catch (JMSException e) {
1:16bc0f0:                 throw toXAException(e);
1:e8818fa:             }
1:132f662:         }
1:16bc0f0:         LOG.debug("recover({})={}", flag, answer);
1:16bc0f0:         return answer;
1:ecf89a6:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public int getTransactionTimeout() throws XAException {
1:d29ca2a:         return 0;
1:ecf89a6:     }
1:d29ca2a: 
1:8e7556f:     @Override
1:d29ca2a:     public boolean setTransactionTimeout(int seconds) throws XAException {
1:d29ca2a:         return false;
1:ecf89a6:     }
1:d29ca2a: 
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Helper methods.
1:d29ca2a:     //
1:d29ca2a:     // ///////////////////////////////////////////////////////////
1:e8818fa:     protected String getResourceManagerId() throws JMSException {
1:d29ca2a:         return this.connection.getResourceManagerId();
1:05586ed:     }
1:d29ca2a: 
1:d29ca2a:     private void setXid(Xid xid) throws XAException {
1:230a86c: 
1:62daac4:         try {
1:230a86c:             this.connection.checkClosedOrFailed();
1:230a86c:             this.connection.ensureConnectionInfoSent();
1:230a86c:         } catch (JMSException e) {
1:c387522:             disassociate();
1:230a86c:             throw toXAException(e);
1:230a86c:         }
1:05586ed: 
1:230a86c:         if (xid != null) {
1:d29ca2a:             // associate
1:d29ca2a:             associatedXid = xid;
1:d29ca2a:             transactionId = new XATransactionId(xid);
1:230a86c: 
1:e8818fa:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);
1:230a86c:             try {
1:d29ca2a:                 this.connection.asyncSendPacket(info);
1:8e7556f:                 LOG.debug("{} started XA transaction {}", this, transactionId);
1:d29ca2a:             } catch (JMSException e) {
1:c387522:                 disassociate();
1:d29ca2a:                 throw toXAException(e);
1:d29ca2a:             }
1:230a86c: 
1:230a86c:         } else {
1:230a86c: 
1:230a86c:             if (transactionId != null) {
1:e8818fa:                 TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.END);
1:05586ed:                 try {
1:0a12bcb:                     this.connection.syncSendPacket(info);
1:e8818fa:                     LOG.debug("{} ended XA transaction {}", this, transactionId);
1:d29ca2a:                 } catch (JMSException e) {
1:c387522:                     disassociate();
1:d29ca2a:                     throw toXAException(e);
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 // Add our self to the list of contexts that are interested in
1:d29ca2a:                 // post commit/rollback events.
1:9a78bc6:                 List<TransactionContext> l;
1:8e7556f:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:9a78bc6:                     l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
1:8e7556f:                     if (l == null) {
1:8e7556f:                         l = new ArrayList<TransactionContext>(3);
1:8e7556f:                         ENDED_XA_TRANSACTION_CONTEXTS.put(transactionId, l);
1:9a78bc6:                     }
1:9a78bc6:                     if (!l.contains(this)) {
2:8e7556f:                         l.add(this);
1:8e7556f:                     }
1:8e7556f:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:c387522:             disassociate();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:c387522:     private void disassociate() {
1:c387522:          // dis-associate
1:c387522:          associatedXid = null;
1:c387522:          transactionId = null;
1:c387522:     }
1:c387522: 
1:d29ca2a:     /**
1:d29ca2a:      * Converts a JMSException from the server to an XAException. if the
1:d29ca2a:      * JMSException contained a linked XAException that is returned instead.
1:d29ca2a:      *
1:185711e:      * @param e JMSException to convert
1:185711e:      * @return XAException wrapping original exception or its message
1:d29ca2a:      */
1:d29ca2a:     private XAException toXAException(JMSException e) {
1:d29ca2a:         if (e.getCause() != null && e.getCause() instanceof XAException) {
1:230a86c:             XAException original = (XAException)e.getCause();
1:d29ca2a:             XAException xae = new XAException(original.getMessage());
1:d29ca2a:             xae.errorCode = original.errorCode;
1:f155083:             if (xae.errorCode == XA_OK) {
1:f155083:                 // detail not unmarshalled see: org.apache.activemq.openwire.v1.BaseDataStreamMarshaller.createThrowable
1:ab1e9c7:                 xae.errorCode = parseFromMessageOr(original.getMessage(), XAException.XAER_RMERR);
1:f155083:             }
1:d29ca2a:             xae.initCause(original);
1:d29ca2a:             return xae;
1:d29ca2a:         }
1:31c01f8: 
1:d29ca2a:         XAException xae = new XAException(e.getMessage());
1:d29ca2a:         xae.errorCode = XAException.XAER_RMFAIL;
1:d29ca2a:         xae.initCause(e);
1:d29ca2a:         return xae;
1:d29ca2a:     }
1:d29ca2a: 
1:ab1e9c7:     private int parseFromMessageOr(String message, int fallbackCode) {
1:ab1e9c7:         final String marker = "xaErrorCode:";
1:ab1e9c7:         final int index = message.lastIndexOf(marker);
1:ab1e9c7:         if (index > -1) {
1:ab1e9c7:             try {
1:ab1e9c7:                 return Integer.parseInt(message.substring(index + marker.length()));
1:ab1e9c7:             } catch (Exception ignored) {}
1:ab1e9c7:         }
1:ab1e9c7:         return fallbackCode;
1:ab1e9c7:     }
1:ab1e9c7: 
1:d29ca2a:     public ActiveMQConnection getConnection() {
1:d29ca2a:         return connection;
1:d29ca2a:     }
1:e8818fa: 
1:e8818fa:     // for RAR xa recovery where xaresource connection is per request
1:e8818fa:     public ActiveMQConnection setConnection(ActiveMQConnection connection) {
1:e8818fa:         ActiveMQConnection existing = this.connection;
1:e8818fa:         this.connection = connection;
1:e8818fa:         return existing;
1:e8818fa:     }
1:e8818fa: 
1:d29ca2a:     public void cleanup() {
1:230a86c:         associatedXid = null;
1:230a86c:         transactionId = null;
1:d29ca2a:     }
1:d29ca2a: 
1:31c01f8:     @Override
1:31c01f8:     public String toString() {
1:31c01f8:         return "TransactionContext{" +
1:31c01f8:                 "transactionId=" + transactionId +
1:e1cd19e:                 ",connection=" + connection +
1:31c01f8:                 '}';
1:31c01f8:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:a65f5e7
/////////////////////////////////////////////////////////////////////////
1:             this.connection.syncSendPacket(info, this.connection.isClosing() ? this.connection.getCloseTimeout() : 0);
commit:530c1a8
/////////////////////////////////////////////////////////////////////////
0:             this.connection.doSyncSendPacket(info, this.connection.isClosing() ? this.connection.getCloseTimeout() : 0);
commit:77d46dc
/////////////////////////////////////////////////////////////////////////
0:             this.connection.doSyncSendPacket(info, this.connection.getSendTimeout() > 0 && this.connection.isClosing() ? this.connection.getSendTimeout() : 0);
commit:16bc0f0
/////////////////////////////////////////////////////////////////////////
1:         XATransactionId[] answer;
1:         if (XAResource.TMNOFLAGS == flag) {
1:             // signal next in cursor scan, which for us is always the end b/c we don't maintain any cursor state
1:             // allows looping scan to complete
1:             answer = new XATransactionId[0];
1:         } else {
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), null, TransactionInfo.RECOVER);
1:             try {
1:                 this.connection.checkClosedOrFailed();
1:                 this.connection.ensureConnectionInfoSent();
1:                 DataArrayResponse receipt = (DataArrayResponse) this.connection.syncSendPacket(info);
1:                 DataStructure[] data = receipt.getData();
1:                 if (data instanceof XATransactionId[]) {
1:                     answer = (XATransactionId[]) data;
1:                 } else {
1:                     answer = new XATransactionId[data.length];
1:                     System.arraycopy(data, 0, answer, 0, data.length);
1:                 }
1:             } catch (JMSException e) {
1:                 throw toXAException(e);
1:         LOG.debug("recover({})={}", flag, answer);
1:         return answer;
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:             invokeBeforeEnd();
1:                 invokeBeforeEnd();
1:     private void invokeBeforeEnd() throws XAException {
1:         boolean throwingException = false;
1:         try {
1:             beforeEnd();
1:         } catch (JMSException e) {
1:             throwingException = true;
1:             throw toXAException(e);
1:         } finally {
1:             try {
1:                 setXid(null);
1:             } catch (XAException ignoreIfWillMask){
1:                 if (!throwingException) {
1:                     throw ignoreIfWillMask;
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             IntegerResponse response = (IntegerResponse)this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:             this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:             this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:             this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:                     this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
commit:fc25535
/////////////////////////////////////////////////////////////////////////
1:         if (transactionId != null && rollbackOnly) {
commit:8d98247
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean rollbackOnly;
/////////////////////////////////////////////////////////////////////////
1:     public void setRollbackOnly(boolean val) {
1:         rollbackOnly = val;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             setRollbackOnly(false);
/////////////////////////////////////////////////////////////////////////
1:         if (rollbackOnly) {
1:             final String message = "Commit of " + transactionId + "  failed due to rollback only request; typically due to failover with pending acks";
1:             try {
1:                 rollback();
1:             } finally {
1:                 LOG.warn(message);
1:                 throw new TransactionRolledBackException(message);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         setRollbackOnly(false);
/////////////////////////////////////////////////////////////////////////
1:         if (rollbackOnly) {
1:             LOG.warn("prepare of: " + x + " failed because it was marked rollback only; typically due to failover with pending acks");
1:             throw new XAException(XAException.XA_RBINTEGRITY);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (rollbackOnly) {
1:              LOG.warn("commit of: " + x + " failed because it was marked rollback only; typically due to failover with pending acks");
1:              throw new XAException(XAException.XA_RBINTEGRITY);
1:          }
1: 
commit:ab1e9c7
/////////////////////////////////////////////////////////////////////////
1:     public static final String xaErrorCodeMarker = "xaErrorCode:";
/////////////////////////////////////////////////////////////////////////
1:                 xae.errorCode = parseFromMessageOr(original.getMessage(), XAException.XAER_RMERR);
/////////////////////////////////////////////////////////////////////////
1:     private int parseFromMessageOr(String message, int fallbackCode) {
1:         final String marker = "xaErrorCode:";
1:         final int index = message.lastIndexOf(marker);
1:         if (index > -1) {
1:             try {
1:                 return Integer.parseInt(message.substring(index + marker.length()));
1:             } catch (Exception ignored) {}
1:         }
1:         return fallbackCode;
1:     }
1: 
commit:207d4cd
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("recover({})", flag);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("recover({})={}", flag, answer);
commit:e1cd19e
/////////////////////////////////////////////////////////////////////////
0:                 XAException xaException = new XAException("Failover transport not connected: " + this.getConnection());
/////////////////////////////////////////////////////////////////////////
1:                 ",connection=" + connection +
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.failover.FailoverTransport;
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQConnection connection;
/////////////////////////////////////////////////////////////////////////
1:     // for RAR recovery
1:     public TransactionContext() {
1:         localTransactionIdGenerator = null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.transactionId = new LocalTransactionId(getConnectionId(), localTransactionIdGenerator.getNextSequenceId());
/////////////////////////////////////////////////////////////////////////
0:             final FailoverTransport failoverTransport = this.connection.getTransport().narrow(FailoverTransport.class);
0:             if (failoverTransport != null && !failoverTransport.isConnected()) {
0:                 // otherwise call will block on reconnect forfeting any app level periodic check
0:                 XAException xaException = new XAException("Failover transport not connected: " + this.getConnection().getTransport());
0:                 xaException.errorCode = XAException.XAER_RMERR;
0:                 throw xaException;
1:             }
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("recover({})={}", flag, answer);
/////////////////////////////////////////////////////////////////////////
1:     protected String getResourceManagerId() throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);
0:                     LOG.debug("{} started XA transaction {} ", this, transactionId);
/////////////////////////////////////////////////////////////////////////
1:                 TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.END);
1:                         LOG.debug("{} ended XA transaction {}", this, transactionId);
/////////////////////////////////////////////////////////////////////////
1: 
1:     // for RAR xa recovery where xaresource connection is per request
1:     public ActiveMQConnection setConnection(ActiveMQConnection connection) {
1:         ActiveMQConnection existing = this.connection;
1:         this.connection = connection;
1:         return existing;
1:     }
1: 
commit:40c09ed
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Start: " + xid + ", flags:" + flags);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("End: " + xid + ", flags:" + flags);
commit:c387522
/////////////////////////////////////////////////////////////////////////
0:             } finally {
0:                 setXid(null);
/////////////////////////////////////////////////////////////////////////
0:                 } finally {
0:                     setXid(null);
/////////////////////////////////////////////////////////////////////////
1:             disassociate();
/////////////////////////////////////////////////////////////////////////
1:                 disassociate();
/////////////////////////////////////////////////////////////////////////
1:                     disassociate();
/////////////////////////////////////////////////////////////////////////
1:             disassociate();
1:     private void disassociate() {
1:          // dis-associate
1:          associatedXid = null;
1:          transactionId = null;
1:     }
1: 
author:erik-wramner
-------------------------------------------------------------------------------
commit:9a78bc6
/////////////////////////////////////////////////////////////////////////
1:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:                 for(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {
1:                       if (transactions.contains(this)) {
1:                           return true;
1:                       }
/////////////////////////////////////////////////////////////////////////
1:                 List<TransactionContext> l;
1:                     l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:                 }
1:                 // After commit may be expensive and can deadlock, do it outside global synch block
1:                 // No risk for concurrent updates as we own the list now
1:                 if (l != null) {
1:                     if(! l.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:             List<TransactionContext> l;
1:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:             }
1:             // After rollback may be expensive and can deadlock, do it outside global synch block
1:             // No risk for concurrent updates as we own the list now
1:             if (l != null) {
1:                 for (TransactionContext ctx : l) {
1:                     try {
1:                         ctx.afterRollback();
1:                     } catch (Throwable ignored) {
1:                         LOG.debug("failed to firing afterRollback callbacks on prepare " +
1:                                   "failure, txid: {}, context: {}", x, ctx, ignored);
/////////////////////////////////////////////////////////////////////////
1:             List<TransactionContext> l;
1:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:             }
1:             // After rollback may be expensive and can deadlock, do it outside global synch block
1:             // No risk for concurrent updates as we own the list now
1:             if (l != null) {
1:                 for (TransactionContext ctx : l) {
1:                     ctx.afterRollback();
1:                 }                  
/////////////////////////////////////////////////////////////////////////
1:             List<TransactionContext> l;
1:                 l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:             }
1:             // After commit may be expensive and can deadlock, do it outside global synch block
1:             // No risk for concurrent updates as we own the list now
1:             if (l != null) {
1:                 for (TransactionContext ctx : l) {
1:                     try {
1:                         ctx.afterCommit();
1:                     } catch (Exception ignored) {
1:                         LOG.debug("ignoring exception from after completion on ended transaction: {}", ignored, ignored);
/////////////////////////////////////////////////////////////////////////
1:                 List<TransactionContext> l;
1:                     l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:                 }
1:                 // After rollback may be expensive and can deadlock, do it outside global synch block
1:                 // No risk for concurrent updates as we own the list now
1:                 if (l != null) {
1:                     for (TransactionContext ctx : l) {
1:                         try {
1:                             ctx.afterRollback();
1:                         } catch (Throwable ignored) {
1:                             LOG.debug("failed to firing afterRollback callbacks commit failure, txid: {}, context: {}", x, ctx, ignored);
/////////////////////////////////////////////////////////////////////////
1:                 List<TransactionContext> l;
1:                     l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
1:                     }
1:                     if (!l.contains(this)) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8e7556f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.XASupport;
/////////////////////////////////////////////////////////////////////////
1:             new HashMap<TransactionId, List<TransactionContext>>();
/////////////////////////////////////////////////////////////////////////
1:             return true;
0:             if (!ENDED_XA_TRANSACTION_CONTEXTS.isEmpty()) {
1:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                     for(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {
0:                         if (transactions.contains(this)) {
1:                             return true;
1:                         }
1:                     }
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Exception from afterRollback on {}", synchronizations.get(i), t);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Exception from afterCommit on {}", synchronizations.get(i), t);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Begin:{}", transactionId);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Rollback: {} syncCount: {}",
1:                 transactionId, (synchronizations != null ? synchronizations.size() : 0));
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Commit: {} syncCount: {}",
1:                 transactionId, (synchronizations != null ? synchronizations.size() : 0));
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("commit failed for transaction {}", info.getTransactionId(), cause);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         LOG.debug("Start: {}, flags: {}", xid, XASupport.toString(flags));
1: 
/////////////////////////////////////////////////////////////////////////
1:         // if ((flags & TMRESUME) == TMRESUME) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         LOG.debug("End: {}, flags: {}", xid, XASupport.toString(flags));
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         LOG.debug("Prepare: {}", xid);
/////////////////////////////////////////////////////////////////////////
1:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                     List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                     if (l != null && !l.isEmpty()) {
1:                         LOG.debug("firing afterCommit callbacks on XA_RDONLY from prepare: {}", xid);
1:                         for (TransactionContext ctx : l) {
1:                             ctx.afterCommit();
1:                         }
1:                     }
1:                 }
1:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 if (l != null && !l.isEmpty()) {
1:                     for (TransactionContext ctx : l) {
1:                         try {
0:                             ctx.afterRollback();
0:                         } catch (Throwable ignored) {
0:                             LOG.debug("failed to firing afterRollback callbacks on prepare " +
0:                                       "failure, txid: {}, context: {}", x, ctx, ignored);
1:                         }
1:                     }
1:                 }
1:             }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 if (l != null && !l.isEmpty()) {
0:                     for (TransactionContext ctx : l) {
0:                         ctx.afterRollback();
1:                     }
1:                 }
1:             }
1:     @Override
1:         LOG.debug("Commit: {}, onePhase={}", xid, onePhase);
/////////////////////////////////////////////////////////////////////////
1:             synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 if (l != null && !l.isEmpty()) {
0:                     for (TransactionContext ctx : l) {
1:                         try {
0:                             ctx.afterCommit();
0:                         } catch (Exception ignored) {
0:                             LOG.debug("ignoring exception from after completion on ended transaction: {}", ignored, ignored);
1:                         }
1:                     }
1:                 }
1:             }
1:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                     List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                     if (l != null && !l.isEmpty()) {
0:                         for (TransactionContext ctx : l) {
1:                             try {
0:                                 ctx.afterRollback();
0:                             } catch (Throwable ignored) {
0:                                 LOG.debug("failed to firing afterRollback callbacks commit failure, txid: {}, context: {}", x, ctx, ignored);
1:                             }
1:                         }
1:                     }
1:                 }
1:     @Override
1:         LOG.debug("Forget: {}", xid);
/////////////////////////////////////////////////////////////////////////
1:         synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
1:             ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
1:         }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("{} started XA transaction {}", this, transactionId);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("{} ended XA transaction {}", this, transactionId);
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:                     List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
1:                     if (l == null) {
1:                         l = new ArrayList<TransactionContext>(3);
1:                         ENDED_XA_TRANSACTION_CONTEXTS.put(transactionId, l);
1:                         l.add(this);
0:                     } else if (!l.contains(this)) {
1:                         l.add(this);
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:f155083
/////////////////////////////////////////////////////////////////////////
1:             if (xae.errorCode == XA_OK) {
1:                 // detail not unmarshalled see: org.apache.activemq.openwire.v1.BaseDataStreamMarshaller.createThrowable
0:                 // so use a valid generic error code in place of ok
0:                 xae.errorCode = XAException.XAER_RMERR;
1:             }
commit:101e711
/////////////////////////////////////////////////////////////////////////
1:         Throwable firstException = null;
1:         for (int i = 0; i < size; i++) {
1:             try {
1:             } catch (Throwable t) {
0:                 LOG.debug("Exception from afterRollback on " + synchronizations.get(i), t);
1:                 if (firstException == null) {
1:                     firstException = t;
1:                 }
1:         }
1:         synchronizations = null;
1:         if (firstException != null) {
1:             throw JMSExceptionSupport.create(firstException);
/////////////////////////////////////////////////////////////////////////
1:         Throwable firstException = null;
1:         for (int i = 0; i < size; i++) {
1:             try {
1:             } catch (Throwable t) {
0:                 LOG.debug("Exception from afterCommit on " + synchronizations.get(i), t);
1:                 if (firstException == null) {
1:                     firstException = t;
1:                 }
1:         }
1:         synchronizations = null;
1:         if (firstException != null) {
1:             throw JMSExceptionSupport.create(firstException);
/////////////////////////////////////////////////////////////////////////
1:                     try {
0:                         ctx.afterCommit();
0:                     } catch (Exception ignored) {
0:                         LOG.debug("ignoring exception from after completion on ended transaction: " + ignored, ignored);
1:                     }
commit:aae3ea2
/////////////////////////////////////////////////////////////////////////
0:         return (transactionId != null && transactionId.isXATransaction()) || !ENDED_XA_TRANSACTION_CONTEXTS.isEmpty();
/////////////////////////////////////////////////////////////////////////
0:         ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
commit:31c01f8
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Commit: " + xid + ", onePhase=" + onePhase);
/////////////////////////////////////////////////////////////////////////
1:             if (onePhase) {
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 if (l != null && !l.isEmpty()) {
0:                     for (TransactionContext ctx : l) {
1:                         try {
0:                             ctx.afterRollback();
0:                         } catch (Throwable ignored) {
1:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("failed to firing afterRollback callbacks commit failure, txid: " + x + ", context: " + ctx, ignored);
1:                             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public String toString() {
1:         return "TransactionContext{" +
1:                 "transactionId=" + transactionId +
1:                 '}';
1:     }
commit:eedda6f
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("prepare of: " + x + " failed with: " + e, e);
0:             List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:             if (l != null && !l.isEmpty()) {
0:                 for (TransactionContext ctx : l) {
1:                     try {
0:                         ctx.afterRollback();
0:                     } catch (Throwable ignored) {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("failed to firing afterRollback callbacks on prepare failure, txid: " + x + ", context: " + ctx, ignored);
1:                         }
1:                     }
1:                 }
1:             }
commit:e5896c0
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("commit of: " + x + " failed with: " + e, e);
0:             List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:             if (l != null && !l.isEmpty()) {
0:                 for (TransactionContext ctx : l) {
1:                     try {
0:                         ctx.afterRollback();
0:                     } catch (Throwable ignored) {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("failed to firing afterRollback callbacks commit failure, txid: " + x + ", context: " + ctx, ignored);
1:                         }
1:                     }
1:                 }
1:             }
commit:4eafccc
/////////////////////////////////////////////////////////////////////////
1:             if (XAResource.XA_RDONLY == response.getResult()) {
1:                 // transaction stops now, may be syncs that need a callback
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 if (l != null && !l.isEmpty()) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("firing afterCommit callbacks on XA_RDONLY from prepare: " + xid);
1:                     }
0:                     for (TransactionContext ctx : l) {
0:                         ctx.afterCommit();
1:                     }
1:                 }
1:             }
commit:39d0717
/////////////////////////////////////////////////////////////////////////
1:     private int beforeEndIndex;
/////////////////////////////////////////////////////////////////////////
1:             for (;beforeEndIndex < size;) {
1:                 synchronizations.get(beforeEndIndex++).beforeEnd();
/////////////////////////////////////////////////////////////////////////
1:             beforeEndIndex = 0;
/////////////////////////////////////////////////////////////////////////
1:         beforeEndIndex = 0;
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 syncSendPacketWithInterruptionHandling(info);
1:                 if (localTransactionEventListener != null) {
1:                     localTransactionEventListener.commitEvent();
1:                 }
1:                 afterCommit();
1:             } catch (JMSException cause) {
0:                 LOG.info("commit failed for transaction " + info.getTransactionId(), cause);
1:                 if (localTransactionEventListener != null) {
1:                     localTransactionEventListener.rollbackEvent();
1:                 }
1:                 afterRollback();
1:                 throw cause;
1:             
commit:62daac4
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TransactionRolledBackException;
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             beforeEnd();
1:         } catch (TransactionRolledBackException canOcurrOnFailover) {
1:             LOG.warn("rollback processing error", canOcurrOnFailover);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             beforeEnd();
1:         } catch (JMSException e) {
1:             rollback();
1:             throw e;
1:         }
commit:d88004f
/////////////////////////////////////////////////////////////////////////
0:     private final static ConcurrentHashMap<TransactionId, List<TransactionContext>> ENDED_XA_TRANSACTION_CONTEXTS = new ConcurrentHashMap<TransactionId, List<TransactionContext>>();
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Begin:" + transactionId);
1:             }
1:         
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Rollback: "  + transactionId
0:                 + " syncCount: " 
0:                 + (synchronizations != null ? synchronizations.size() : 0));
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Commit: "  + transactionId
0:                         + " syncCount: " 
0:                         + (synchronizations != null ? synchronizations.size() : 0));
commit:132f662
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Being:" + transactionId);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Rollback:" + transactionId);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Commit:" + transactionId);
1:             }
1: 
commit:4046599
/////////////////////////////////////////////////////////////////////////
1:     public boolean isInTransaction() {
1:         return transactionId != null;
1:     }
1:     
commit:50a98e3
/////////////////////////////////////////////////////////////////////////
0:         beforeEnd();
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:edb21db
/////////////////////////////////////////////////////////////////////////
0:         } finally {
0:             synchornizations = null;
/////////////////////////////////////////////////////////////////////////
commit:b135f8a
/////////////////////////////////////////////////////////////////////////
0:         } finally {
0:         	synchornizations = null;
/////////////////////////////////////////////////////////////////////////
0:         } finally {
0:         	synchornizations = null;
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private static final ConcurrentHashMap<TransactionId, List<TransactionContext>> ENDED_XA_TRANSACTION_CONTEXTS = new ConcurrentHashMap<TransactionId, List<TransactionContext>>();
0:     private List<Synchronization> synchornizations;
/////////////////////////////////////////////////////////////////////////
0:         if (synchornizations == null) {
0:             synchornizations = new ArrayList<Synchronization>(10);
1:         }
0:         if (synchornizations == null) {
1:         }
0:                 synchornizations.get(i).afterRollback();
/////////////////////////////////////////////////////////////////////////
0:         if (synchornizations == null) {
1:         }
0:                 synchornizations.get(i).afterCommit();
/////////////////////////////////////////////////////////////////////////
0:         if (synchornizations == null) {
1:         }
0:                 synchornizations.get(i).beforeEnd();
/////////////////////////////////////////////////////////////////////////
1:         if (isInXATransaction()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         if (isInXATransaction()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         if (isInXATransaction()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
1:         if (isInLocalTransaction()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         if (xid1 == xid2) {
1:         }
1:         if (xid1 == null ^ xid2 == null) {
1:         }
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:             List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:                 for (Iterator<TransactionContext> iter = l.iterator(); iter.hasNext();) {
0:                     TransactionContext ctx = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:             List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
1:                     }
0:                 List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
0:                     l = new ArrayList<TransactionContext>(3);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TransactionContext.class);
0:     private static final ConcurrentHashMap ENDED_XA_TRANSACTION_CONTEXTS = new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Start: " + xid);
1:         }
1:         if (isInLocalTransaction()) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
0:             LOG.debug("End: " + xid);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
0:             LOG.debug("Prepare: " + xid);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
1:             LOG.debug("Rollback: " + xid);
/////////////////////////////////////////////////////////////////////////
0:             ArrayList l = (ArrayList)ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
0:             LOG.debug("Commit: " + xid);
/////////////////////////////////////////////////////////////////////////
0:             ArrayList l = (ArrayList)ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
0:             LOG.debug("Forget: " + xid);
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled())
0:             LOG.debug("Recover: " + flag);
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug("Started XA transaction: " + transactionId);
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled())
0:                         LOG.debug("Ended XA transaction: " + transactionId);
0:                 ArrayList l = (ArrayList)ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
0:                     ENDED_XA_TRANSACTION_CONTEXTS.put(transactionId, l);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.DataStructure;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * provides a local transaction interface and also an XAResource interface. <p/>
1:  * An application server controls the transactional assignment of an XASession
1:  * by obtaining its XAResource. It uses the XAResource to assign the session to
1:  * a transaction, prepare and commit work on the transaction, and so on. <p/> An
1:  * XAResource provides some fairly sophisticated facilities for interleaving
1:  * work on multiple transactions, recovering a list of transactions in progress,
1:  * and so on. A JTA aware JMS provider must fully implement this functionality.
1:  * This could be done by using the services of a database that supports XA, or a
1:  * JMS provider may choose to implement this functionality from scratch. <p/>
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param localTransactionEventListener The localTransactionEventListener to
1:      *                set.
/////////////////////////////////////////////////////////////////////////
1:     // Methods that work with the Synchronization objects registered with
1: 
0:         if (synchornizations == null)
1: 
0:         if (synchornizations == null)
1: 
0:                 ((Synchronization)synchornizations.get(i)).afterRollback();
/////////////////////////////////////////////////////////////////////////
0:         if (synchornizations == null)
0:                 ((Synchronization)synchornizations.get(i)).afterCommit();
/////////////////////////////////////////////////////////////////////////
0:         if (synchornizations == null)
0:                 ((Synchronization)synchornizations.get(i)).beforeEnd();
/////////////////////////////////////////////////////////////////////////
1:             throw new TransactionInProgressException("Cannot start local transaction.  XA transaction is already in progress.");
1:         if (transactionId == null) {
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to roll back the
1:      *                 transaction due to some internal error.
1:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:      *                 transacted session.
1:         if (transactionId != null) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to commit the transaction
1:      *                 due to some internal error.
0:      * @throws TransactionRolledBackException if the transaction is rolled back
0:      *                 due to some internal error during commit.
1:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:      *                 transacted session.
1: 
1:         if (transactionId != null) {
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (log.isDebugEnabled())
0:             log.debug("Start: " + xid);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // if ((flags & TMJOIN) == TMJOIN) {
0:         // // TODO: verify that the server has seen the xid
1:         // }
0:         // if ((flags & TMJOIN) == TMRESUME) {
1:         // // TODO: verify that the xid was suspended.
1:         // }
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (log.isDebugEnabled())
0:             log.debug("End: " + xid);
1:         if ((flags & (TMSUSPEND | TMFAIL)) != 0) {
/////////////////////////////////////////////////////////////////////////
0:         if (xid1 == xid2)
0:             return true;
0:         if (xid1 == null ^ xid2 == null)
1:         return xid1.getFormatId() == xid2.getFormatId() && Arrays.equals(xid1.getBranchQualifier(), xid2.getBranchQualifier())
1:                && Arrays.equals(xid1.getGlobalTransactionId(), xid2.getGlobalTransactionId());
0:         if (log.isDebugEnabled())
0:             log.debug("Prepare: " + xid);
1:         if (xid == null || (equals(associatedXid, xid))) {
/////////////////////////////////////////////////////////////////////////
1: 
0:             IntegerResponse response = (IntegerResponse)this.connection.syncSendPacket(info);
1: 
1: 
0:         if (log.isDebugEnabled())
0:             log.debug("Rollback: " + xid);
1:         if (xid == null) {
1:         }
1:             x = (XATransactionId)transactionId;
1:             this.connection.checkClosedOrFailed();
1:             this.connection.ensureConnectionInfoSent();
0:             ArrayList l = (ArrayList)endedXATransactionContexts.remove(x);
0:             if (l != null && !l.isEmpty()) {
0:                     TransactionContext ctx = (TransactionContext)iter.next();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (log.isDebugEnabled())
0:             log.debug("Commit: " + xid);
1:         if (xid == null || (equals(associatedXid, xid))) {
/////////////////////////////////////////////////////////////////////////
1:             this.connection.checkClosedOrFailed();
1:             this.connection.ensureConnectionInfoSent();
1: 
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, onePhase ? TransactionInfo.COMMIT_ONE_PHASE : TransactionInfo.COMMIT_TWO_PHASE);
1: 
1: 
0:             ArrayList l = (ArrayList)endedXATransactionContexts.remove(x);
0:             if (l != null && !l.isEmpty()) {
0:                     TransactionContext ctx = (TransactionContext)iter.next();
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (log.isDebugEnabled())
0:             log.debug("Forget: " + xid);
1:         if (xid == null) {
1:         }
1:             x = (XATransactionId)transactionId;
1: 
/////////////////////////////////////////////////////////////////////////
1:         TransactionContext xar = (TransactionContext)xaResource;
1:             throw (XAException)new XAException("Could not get resource manager id.").initCause(e);
0:         if (log.isDebugEnabled())
0:             log.debug("Recover: " + flag);
1: 
1:             this.connection.checkClosedOrFailed();
1:             this.connection.ensureConnectionInfoSent();
0:             DataArrayResponse receipt = (DataArrayResponse)this.connection.syncSendPacket(info);
0:                 answer = (XATransactionId[])data;
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             this.connection.checkClosedOrFailed();
1:             this.connection.ensureConnectionInfoSent();
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1: 
1:         if (xid != null) {
1: 
0:             TransactionInfo info = new TransactionInfo(connectionId, transactionId, TransactionInfo.BEGIN);
0:                 if (log.isDebugEnabled())
0:                     log.debug("Started XA transaction: " + transactionId);
1: 
1:             if (transactionId != null) {
0:                 TransactionInfo info = new TransactionInfo(connectionId, transactionId, TransactionInfo.END);
0:                     if (log.isDebugEnabled())
0:                         log.debug("Ended XA transaction: " + transactionId);
1: 
0:                 ArrayList l = (ArrayList)endedXATransactionContexts.get(transactionId);
0:                 if (l == null) {
0:                     l.add(this);
/////////////////////////////////////////////////////////////////////////
1:             XAException original = (XAException)e.getCause();
/////////////////////////////////////////////////////////////////////////
1:         associatedXid = null;
1:         transactionId = null;
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1: }
commit:05586ed
/////////////////////////////////////////////////////////////////////////
1:     	
0: 		if( log.isDebugEnabled() )
/////////////////////////////////////////////////////////////////////////
0: 			this.connection.checkClosedOrFailed();
0: 			this.connection.ensureConnectionInfoSent();
1: 
/////////////////////////////////////////////////////////////////////////
0: 			this.connection.checkClosedOrFailed();
0: 			this.connection.ensureConnectionInfoSent();
/////////////////////////////////////////////////////////////////////////
0: 			this.connection.checkClosedOrFailed();
0: 			this.connection.ensureConnectionInfoSent();
1: 
0: 			DataArrayResponse receipt = (DataArrayResponse) this.connection.syncSendPacket(info);
/////////////////////////////////////////////////////////////////////////
1:     	
1:     	try {
0: 			this.connection.checkClosedOrFailed();
0: 			this.connection.ensureConnectionInfoSent();
1: 		} catch (JMSException e) {
1:             throw toXAException(e);
1: 		}
1: 
0:     	if (xid != null) {
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
0: import java.util.Iterator;
1: 
1: import javax.jms.JMSException;
1: import javax.jms.TransactionInProgressException;
0: import javax.jms.TransactionRolledBackException;
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.DataArrayResponse;
1: import org.apache.activemq.command.IntegerResponse;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.TransactionInfo;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.transaction.Synchronization;
1: import org.apache.activemq.util.JMSExceptionSupport;
1: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
1: /**
1:  * A TransactionContext provides the means to control a JMS transaction. It
0:  * provides a local transaction interface and also an XAResource interface.
1:  * 
0:  * <p/> An application server controls the transactional assignment of an
0:  * XASession by obtaining its XAResource. It uses the XAResource to assign the
0:  * session to a transaction, prepare and commit work on the transaction, and so
0:  * on. <p/> An XAResource provides some fairly sophisticated facilities for
0:  * interleaving work on multiple transactions, recovering a list of transactions
0:  * in progress, and so on. A JTA aware JMS provider must fully implement this
0:  * functionality. This could be done by using the services of a database that
0:  * supports XA, or a JMS provider may choose to implement this functionality
0:  * from scratch. <p/>
1:  * 
0:  * @version $Revision: 1.10 $
1:  * @see javax.jms.Session
1:  * @see javax.jms.QueueSession
1:  * @see javax.jms.TopicSession
1:  * @see javax.jms.XASession
1:  */
1: public class TransactionContext implements XAResource {
1: 
0:     static final private Log log = LogFactory.getLog(TransactionContext.class);
1:     
1:     // XATransactionId -> ArrayList of TransactionContext objects
0:     private static final ConcurrentHashMap endedXATransactionContexts = new ConcurrentHashMap();
1: 
0:     private final ActiveMQConnection connection;
1:     private final LongSequenceGenerator localTransactionIdGenerator;
0:     private final ConnectionId connectionId;
0:     private ArrayList synchornizations;
1: 
1:     // To track XA transactions.
1:     private Xid associatedXid;
1:     private TransactionId transactionId;
1:     private LocalTransactionEventListener localTransactionEventListener;
1:     
1: 
1:     public TransactionContext(ActiveMQConnection connection) {
1:         this.connection = connection;
1:         this.localTransactionIdGenerator = connection.getLocalTransactionIdGenerator();
0:         this.connectionId = connection.getConnectionInfo().getConnectionId();
1:     }
1: 
1:     public boolean isInXATransaction() {
0:         return transactionId != null && transactionId.isXATransaction();
1:     }
1: 
1:     public boolean isInLocalTransaction() {
1:         return transactionId != null && transactionId.isLocalTransaction();
1:     }
1: 
1:     /**
1:      * @return Returns the localTransactionEventListener.
1:      */
1:     public LocalTransactionEventListener getLocalTransactionEventListener() {
1:         return localTransactionEventListener;
1:     }
1: 
1:     /**
1:      * Used by the resource adapter to listen to transaction events.
1:      * 
0:      * @param localTransactionEventListener
0:      *            The localTransactionEventListener to set.
1:      */
1:     public void setLocalTransactionEventListener(LocalTransactionEventListener localTransactionEventListener) {
1:         this.localTransactionEventListener = localTransactionEventListener;
1:     }
1: 
1:     // ///////////////////////////////////////////////////////////
1:     //
0:     // Methods that work with the Synchronization objects registered with 
1:     // the transaction.
1:     //
1:     // ///////////////////////////////////////////////////////////
1:     
1:     public void addSynchronization(Synchronization s) {
0:         if( synchornizations == null )
0:             synchornizations = new ArrayList(10);
0:         synchornizations.add(s);
1:     }
1:     
1:     private void afterRollback() throws JMSException {
0:         if( synchornizations == null )
1:             return;
1:         
0:         int size = synchornizations.size();
0:         try {
0:             for (int i = 0; i < size; i++) {
0:                 ((Synchronization) synchornizations.get(i)).afterRollback();
1:             }
1:         } catch (JMSException e) {
1:             throw e;
1:         } catch (Throwable e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     private void afterCommit() throws JMSException {
0:         if( synchornizations == null )
1:             return;
1: 
0:         int size = synchornizations.size();
0:         try {
0:             for (int i = 0; i < size; i++) {
0:                 ((Synchronization) synchornizations.get(i)).afterCommit();
1:             }
1:         } catch (JMSException e) {
1:             throw e;
1:         } catch (Throwable e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     private void beforeEnd() throws JMSException {
0:         if( synchornizations == null )
1:             return;
1: 
0:         int size = synchornizations.size();
0:         try {
0:             for (int i = 0; i < size; i++) {
0:                 ((Synchronization) synchornizations.get(i)).beforeEnd();
1:             }
1:         } catch (JMSException e) {
1:             throw e;
1:         } catch (Throwable e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     public TransactionId getTransactionId() {
1:         return transactionId;
1:     }
1: 
1:     // ///////////////////////////////////////////////////////////
1:     //
1:     // Local transaction interface.
1:     //
1:     // ///////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Start a local transaction.
1:      */
1:     public void begin() throws JMSException {
1: 
0:         if (isInXATransaction())
0:             throw new TransactionInProgressException(
0:                     "Cannot start local transaction.  XA transaction is already in progress.");
1: 
0:         if (transactionId==null) {
0:             synchornizations = null;
0:             this.transactionId = new LocalTransactionId(connectionId, localTransactionIdGenerator.getNextSequenceId());
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);
0:             this.connection.ensureConnectionInfoSent();
1:             this.connection.asyncSendPacket(info);
1: 
1:             // Notify the listener that the tx was started.
1:             if (localTransactionEventListener != null) {
1:                 localTransactionEventListener.beginEvent();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Rolls back any work done in this transaction and releases any locks
1:      * currently held.
1:      * 
0:      * @throws JMSException
0:      *             if the JMS provider fails to roll back the transaction due to
0:      *             some internal error.
0:      * @throws javax.jms.IllegalStateException
0:      *             if the method is not called by a transacted session.
1:      */
1:     public void rollback() throws JMSException {
0:         if (isInXATransaction())
1:             throw new TransactionInProgressException("Cannot rollback() if an XA transaction is already in progress ");
1: 
0:         if (transactionId!=null) {
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.ROLLBACK);
1:             this.transactionId = null;
1:             this.connection.asyncSendPacket(info);
1:             // Notify the listener that the tx was rolled back
1:             if (localTransactionEventListener != null) {
1:                 localTransactionEventListener.rollbackEvent();
1:             }
1:         }
1:         
1:         afterRollback();
1:     }
1: 
1:     /**
1:      * Commits all work done in this transaction and releases any locks
1:      * currently held.
1:      * 
0:      * @throws JMSException
0:      *             if the JMS provider fails to commit the transaction due to
0:      *             some internal error.
0:      * @throws TransactionRolledBackException
0:      *             if the transaction is rolled back due to some internal error
0:      *             during commit.
0:      * @throws javax.jms.IllegalStateException
0:      *             if the method is not called by a transacted session.
1:      */
1:     public void commit() throws JMSException {
0:         if (isInXATransaction())
1:             throw new TransactionInProgressException("Cannot commit() if an XA transaction is already in progress ");
1: 
0:         beforeEnd();
1:         
1:         // Only send commit if the transaction was started.
0:         if (transactionId!=null) {
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.COMMIT_ONE_PHASE);
1:             this.transactionId = null;
1:             // Notify the listener that the tx was committed back
0:             this.connection.syncSendPacket(info);
1:             if (localTransactionEventListener != null) {
0:                 localTransactionEventListener.commitEvent();
1:             }
0:             afterCommit();
1:         }
1:     }
1: 
1:     // ///////////////////////////////////////////////////////////
1:     //
1:     // XAResource Implementation
1:     //
1:     // ///////////////////////////////////////////////////////////
1:     /**
1:      * Associates a transaction with the resource.
1:      */
1:     public void start(Xid xid, int flags) throws XAException {
1:         
0:         if( log.isDebugEnabled() )
0:             log.debug("Start: "+xid);
1:         
0:         if (isInLocalTransaction())
1:             throw new XAException(XAException.XAER_PROTO);
1: 
1:         // Are we already associated?
1:         if (associatedXid != null) {
1:             throw new XAException(XAException.XAER_PROTO);
1:         }
1: 
0: //        if ((flags & TMJOIN) == TMJOIN) {
0: //            // TODO: verify that the server has seen the xid
0: //        }
0: //        if ((flags & TMJOIN) == TMRESUME) {
0: //            // TODO: verify that the xid was suspended.
0: //        }
1: 
1:         // associate
0:         synchornizations = null;
1:         setXid(xid);
1:     }
1: 
1:     /**
0:      * @return
1:      */
1:     private ConnectionId getConnectionId() {
1:         return connection.getConnectionInfo().getConnectionId();
1:     }
1: 
1:     public void end(Xid xid, int flags) throws XAException {
1:         
0:         if( log.isDebugEnabled() )
0:             log.debug("End: "+xid);
1: 
0:         if (isInLocalTransaction())
1:             throw new XAException(XAException.XAER_PROTO);
1: 
0:         if ((flags & (TMSUSPEND|TMFAIL)) !=0 ) {
1:             // You can only suspend the associated xid.
1:             if (!equals(associatedXid, xid)) {
1:                 throw new XAException(XAException.XAER_PROTO);
1:             }
1: 
0:             // TODO: we may want to put the xid in a suspended list.
0:             try {
0:                 beforeEnd();
1:             } catch (JMSException e) {
1:                 throw toXAException(e);
1:             }
0:             setXid(null);
1:         } else if ((flags & TMSUCCESS) == TMSUCCESS) {
1:             // set to null if this is the current xid.
1:             // otherwise this could be an asynchronous success call
1:             if (equals(associatedXid, xid)) {
0:                 try {
0:                     beforeEnd();
1:                 } catch (JMSException e) {
1:                     throw toXAException(e);
1:                 }
0:                 setXid(null);
1:             }
1:         } else {
1:             throw new XAException(XAException.XAER_INVAL);
1:         }
1:     }
1: 
1:     private boolean equals(Xid xid1, Xid xid2) {
0:         if( xid1 == xid2 )
0:             return true;  
0:         if( xid1==null ^ xid2==null )
1:             return false;
0:         return xid1.getFormatId()==xid2.getFormatId() && 
0:                 Arrays.equals(xid1.getBranchQualifier(), xid2.getBranchQualifier()) && 
0:                 Arrays.equals(xid1.getGlobalTransactionId(), xid2.getGlobalTransactionId());
1:     }
1: 
1:     public int prepare(Xid xid) throws XAException {
0:         if( log.isDebugEnabled() )
0:             log.debug("Prepare: "+xid);
1: 
1:         // We allow interleaving multiple transactions, so
1:         // we don't limit prepare to the associated xid.
1:         XATransactionId x;
1:         // THIS SHOULD NEVER HAPPEN because end(xid, TMSUCCESS) should have been
1:         // called first
0:         if (xid==null || (equals(associatedXid, xid)) ) {
1:             throw new XAException(XAException.XAER_PROTO);
1:         } else {
1:             // TODO: cache the known xids so we don't keep recreating this one??
1:             x = new XATransactionId(xid);
1:         }
1: 
0:         try {
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.PREPARE);
1:             
1:             // Find out if the server wants to commit or rollback.
0:             IntegerResponse response = (IntegerResponse) this.connection.syncSendPacket(info);
1:             return response.getResult();
1:             
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1:     }
1: 
1:     public void rollback(Xid xid) throws XAException {
0:         if( log.isDebugEnabled() )
0:             log.debug("Rollback: "+xid);
1: 
1:         // We allow interleaving multiple transactions, so
1:         // we don't limit rollback to the associated xid.
1:         XATransactionId x;
0:         if (xid==null) {
1:             throw new XAException(XAException.XAER_PROTO);
1:         }        
1:         if (equals(associatedXid, xid)) {
1:             // I think this can happen even without an end(xid) call. Need to
1:             // check spec.
0:             x = (XATransactionId) transactionId;
1:         } else {
1:             x = new XATransactionId(xid);
1:         }
1: 
0:         try {
1:             // Let the server know that the tx is rollback.
1:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.ROLLBACK);
0:             this.connection.syncSendPacket(info);
1: 
0:             ArrayList l = (ArrayList) endedXATransactionContexts.remove(x);
0:             if( l!=null && !l.isEmpty()) {
0:                 for (Iterator iter = l.iterator(); iter.hasNext();) {
0:                     TransactionContext ctx = (TransactionContext) iter.next();
0:                     ctx.afterRollback();
1:                 }
1:             }
1:             
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1:     }
1: 
1:     // XAResource interface
1:     public void commit(Xid xid, boolean onePhase) throws XAException {
1:         
0:         if( log.isDebugEnabled() )
0:             log.debug("Commit: "+xid);
1: 
1:         // We allow interleaving multiple transactions, so
1:         // we don't limit commit to the associated xid.
1:         XATransactionId x;
0:         if (xid==null || (equals(associatedXid, xid)) ) {
1:             // should never happen, end(xid,TMSUCCESS) must have been previously
1:             // called
1:             throw new XAException(XAException.XAER_PROTO);
1:         } else {
1:             x = new XATransactionId(xid);
1:         }
1: 
1: 
0:         try {
1:             
1:             // Notify the server that the tx was committed back
0:             TransactionInfo info = new TransactionInfo(getConnectionId(), x, 
0:                     onePhase ? TransactionInfo.COMMIT_ONE_PHASE : TransactionInfo.COMMIT_TWO_PHASE);
1:             
0:             this.connection.syncSendPacket(info);
1:             
0:             ArrayList l = (ArrayList) endedXATransactionContexts.remove(x);
0:             if( l!=null && !l.isEmpty()) {
0:                 for (Iterator iter = l.iterator(); iter.hasNext();) {
0:                     TransactionContext ctx = (TransactionContext) iter.next();
0:                     ctx.afterCommit();
1:                 }
1:             }
1:             
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1: 
1:     }
1: 
1:     public void forget(Xid xid) throws XAException {
0:         if( log.isDebugEnabled() )
0:             log.debug("Forget: "+xid);
1: 
1:         // We allow interleaving multiple transactions, so
1:         // we don't limit forget to the associated xid.
1:         XATransactionId x;
0:         if (xid==null) {
1:             throw new XAException(XAException.XAER_PROTO);
1:         }        
1:         if (equals(associatedXid, xid)) {
1:             // TODO determine if this can happen... I think not.
0:             x = (XATransactionId) transactionId;
1:         } else {
1:             x = new XATransactionId(xid);
1:         }
1: 
1:         TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.FORGET);
1:         
0:         try {
1:             // Tell the server to forget the transaction.
0:             this.connection.syncSendPacket(info);
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1:     }
1: 
1:     public boolean isSameRM(XAResource xaResource) throws XAException {
1:         if (xaResource == null) {
1:             return false;
1:         }
1:         if (!(xaResource instanceof TransactionContext)) {
1:             return false;
1:         }
0:         TransactionContext xar = (TransactionContext) xaResource;
0:         try {
1:             return getResourceManagerId().equals(xar.getResourceManagerId());
1:         } catch (Throwable e) {
0:             throw (XAException) new XAException("Could not get resource manager id.").initCause(e);
1:         }
1:     }
1: 
1:     public Xid[] recover(int flag) throws XAException {
0:         if( log.isDebugEnabled() )
0:             log.debug("Recover: "+flag);
1:         
0:         TransactionInfo info = new TransactionInfo(getConnectionId(), null, TransactionInfo.RECOVER);
0:         try {
0:             DataArrayResponse receipt = (DataArrayResponse) this.connection.syncSendPacket(info);
0:             return (XATransactionId[]) receipt.getData();
1:         } catch (JMSException e) {
1:             throw toXAException(e);
1:         }
1:     }
1: 
1:     public int getTransactionTimeout() throws XAException {
1:         return 0;
1:     }
1: 
1:     public boolean setTransactionTimeout(int seconds) throws XAException {
1:         return false;
1:     }
1: 
1:     // ///////////////////////////////////////////////////////////
1:     //
1:     // Helper methods.
1:     //
1:     // ///////////////////////////////////////////////////////////
0:     private String getResourceManagerId() throws JMSException {
1:         return this.connection.getResourceManagerId();
1:     }
1: 
1:     private void setXid(Xid xid) throws XAException {
0:         if (xid != null) {
1:             // associate
1:             associatedXid = xid;
1:             transactionId = new XATransactionId(xid);
1:             
0:             TransactionInfo info = new TransactionInfo(connectionId,transactionId,TransactionInfo.BEGIN);
0:             try {
1:                 this.connection.asyncSendPacket(info);
0:                 if( log.isDebugEnabled() )
0:                     log.debug("Started XA transaction: "+transactionId);
1:             } catch (JMSException e) {
1:                 throw toXAException(e);
1:             }
1: 
1:         } else {
1:             
0:             if( transactionId!=null ) {
0:                 TransactionInfo info = new TransactionInfo(connectionId,transactionId,TransactionInfo.END);
0:                 try {
0:                     this.connection.syncSendPacket(info);
0:                     if( log.isDebugEnabled() )
0:                         log.debug("Ended XA transaction: "+transactionId);
1:                 } catch (JMSException e) {
1:                     throw toXAException(e);
1:                 }
1:                 
1:                 // Add our self to the list of contexts that are interested in
1:                 // post commit/rollback events.
0:                 ArrayList l = (ArrayList) endedXATransactionContexts.get(transactionId);
0:                 if( l==null ) {
0:                     l = new ArrayList(3);
0:                     endedXATransactionContexts.put(transactionId, l);
1:                 }  
0:                 l.add(this);
1:             }
1: 
0:             // dis-associate
0:             associatedXid = null;
0:             transactionId = null;
1:         }
1:     }
1: 
1:     /**
1:      * Converts a JMSException from the server to an XAException. if the
1:      * JMSException contained a linked XAException that is returned instead.
1:      * 
0:      * @param e
0:      * @return
1:      */
1:     private XAException toXAException(JMSException e) {
1:         if (e.getCause() != null && e.getCause() instanceof XAException) {
0:             XAException original = (XAException) e.getCause();
1:             XAException xae = new XAException(original.getMessage());
1:             xae.errorCode = original.errorCode;
1:             xae.initCause(original);
1:             return xae;
1:         }
1: 
1:         XAException xae = new XAException(e.getMessage());
1:         xae.errorCode = XAException.XAER_RMFAIL;
1:         xae.initCause(e);
1:         return xae;
1:     }
1: 
1:     public ActiveMQConnection getConnection() {
1:         return connection;
1:     }
1: 
1:     public void cleanup() {
0:         associatedXid=null;
0:         transactionId=null;        
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:e6254c2
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     private final static HashMap<TransactionId, List<TransactionContext>> ENDED_XA_TRANSACTION_CONTEXTS =
0:     		new HashMap<TransactionId, List<TransactionContext>>();
/////////////////////////////////////////////////////////////////////////
1:         if (transactionId != null && transactionId.isXATransaction()) {
0:         	return true;
0:         } else {
0:     		if (!ENDED_XA_TRANSACTION_CONTEXTS.isEmpty()) {
0: 	        	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:         			for(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {
0:         				if (transactions.contains(this)) {
0:         					return true;
0:         				}
0:         			}
0:         		}
0:     		}
0:         }
0: 
1:         return false;
/////////////////////////////////////////////////////////////////////////
0: 	        	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	                List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0: 	                if (l != null && !l.isEmpty()) {
0: 	                    if (LOG.isDebugEnabled()) {
0: 	                        LOG.debug("firing afterCommit callbacks on XA_RDONLY from prepare: " + xid);
0: 	                    }
0: 	                    for (TransactionContext ctx : l) {
0: 	                        ctx.afterCommit();
0: 	                    }
0: 	                }
0: 	        	}
0:         	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	            List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0: 	            if (l != null && !l.isEmpty()) {
0: 	                for (TransactionContext ctx : l) {
0: 	                    try {
0: 	                        ctx.afterRollback();
0: 	                    } catch (Throwable ignored) {
0: 	                        if (LOG.isDebugEnabled()) {
0: 	                            LOG.debug("failed to firing afterRollback callbacks on prepare failure, txid: " +
0: 	                            		  x + ", context: " + ctx, ignored);
0: 	                        }
0: 	                    }
0: 	                }
0: 	            }
0:         	}
/////////////////////////////////////////////////////////////////////////
0:         	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	            List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0: 	            if (l != null && !l.isEmpty()) {
0: 	                for (TransactionContext ctx : l) {
0: 	                    ctx.afterRollback();
0: 	                }
0: 	            }
0:         	}
/////////////////////////////////////////////////////////////////////////
0:         	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	            List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0: 	            if (l != null && !l.isEmpty()) {
0: 	                for (TransactionContext ctx : l) {
0: 	                    try {
0: 	                        ctx.afterCommit();
0: 	                    } catch (Exception ignored) {
0: 	                        LOG.debug("ignoring exception from after completion on ended transaction: " + ignored, ignored);
0: 	                    }
0: 	                }
0: 	            }
0:         	}
0: 	        	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	                List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0: 	                if (l != null && !l.isEmpty()) {
0: 	                    for (TransactionContext ctx : l) {
0: 	                        try {
0: 	                            ctx.afterRollback();
0: 	                        } catch (Throwable ignored) {
0: 	                            if (LOG.isDebugEnabled()) {
0: 	                                LOG.debug("failed to firing afterRollback callbacks commit failure, txid: " + x + ", context: " + ctx, ignored);
0: 	                            }
0: 	                        }
0: 	                    }
0: 	                }
0: 	        	}
/////////////////////////////////////////////////////////////////////////
0:     	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0:     		ENDED_XA_TRANSACTION_CONTEXTS.remove(x);
0:     	}
/////////////////////////////////////////////////////////////////////////
0: 	        	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {
0: 	                List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);
0: 	                if (l == null) {
0: 	                    l = new ArrayList<TransactionContext>(3);
0: 	                    ENDED_XA_TRANSACTION_CONTEXTS.put(transactionId, l);
0: 	                    l.add(this);
0: 	                } else if (!l.contains(this)) {
0: 	                    l.add(this);
0: 	                }
0: 	        	}
commit:d717a49
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0:         return (transactionId != null && transactionId.isXATransaction()) ||
0:                (!ENDED_XA_TRANSACTION_CONTEXTS.isEmpty() && ENDED_XA_TRANSACTION_CONTEXTS.containsValue(this));
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 + " syncCount: "
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                         + " syncCount: "
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      * If interruption occurred, set the interruption state of the current
0:      * after performing the action again.
0:      *
/////////////////////////////////////////////////////////////////////////
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TransactionContext.class);
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:c9c6e62
/////////////////////////////////////////////////////////////////////////
1:             synchronizations = null;
/////////////////////////////////////////////////////////////////////////
0:         // if ((flags & TMJOIN) == TMJOIN) {
1:         // // }
0:         // if ((flags & TMJOIN) == TMRESUME) {
0:         // // TODO: verify that the xid was suspended.
0:         // }
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             return this.connection.syncSendPacket(command);
0:         } catch (JMSException e) {
0:             if (e.getLinkedException() instanceof InterruptedIOException) {
0:                 try {
0:                     Thread.interrupted();
0:                     return this.connection.syncSendPacket(command);
0:                 } finally {
0:                     Thread.currentThread().interrupt();
0:                 }               
0:             }
0:             
0:             throw e;
0:         }
commit:4411ff6
/////////////////////////////////////////////////////////////////////////
0:         String txSuspendResumeNotSupportMsg = "The suspend/resume of a transaction " 
0:         	+ "is not supported. Instead it is recommended that a new JMS session be created.";
0:         
0:         if ((flags & TMJOIN) == TMJOIN) {
0:         	throw new XAException(txSuspendResumeNotSupportMsg);
1:         // TODO: verify that the server has seen the xid
0:         }
0:         if ((flags & TMRESUME) == TMRESUME) {
0:         	throw new XAException(txSuspendResumeNotSupportMsg);
0:         // TODO: verify that the xid was suspended.
0:         }
author:Robert Davies
-------------------------------------------------------------------------------
commit:e01acf4
/////////////////////////////////////////////////////////////////////////
0: import java.io.InterruptedIOException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:             syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:             IntegerResponse response = (IntegerResponse)syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:             syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:             syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:             syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:                     syncSendPacketWithInterruptionHandling(info);
/////////////////////////////////////////////////////////////////////////
0:      * Sends the given command. Also sends the command in case of interruption,
0:      * so that important commands like rollback and commit are never interrupted.
0:      * If interruption occurred, set the interruption state of the current 
0:      * after performing the action again. 
0:      * 
0:      * @return the response
0:      */
0:     private Response syncSendPacketWithInterruptionHandling(Command command) throws JMSException {
0:     	try {
0: 			return this.connection.syncSendPacket(command);
0: 		} catch (JMSException e) {
0: 			if (e.getLinkedException() instanceof InterruptedIOException) {
0: 				try {
0: 					Thread.interrupted();
0: 					return this.connection.syncSendPacket(command);
0: 				} finally {
0: 					Thread.currentThread().interrupt();
0: 				}				
0: 			}
0: 			
0: 			throw e;
0: 		}
0:     }
0: 
0:     /**
commit:612437c
/////////////////////////////////////////////////////////////////////////
1:             //make this synchronous - see https://issues.apache.org/activemq/browse/AMQ-2364
0:             this.connection.syncSendPacket(info);
commit:595d95b
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<TransactionId, List<TransactionContext>> ENDED_XA_TRANSACTION_CONTEXTS = new ConcurrentHashMap<TransactionId, List<TransactionContext>>();
author:David Jencks
-------------------------------------------------------------------------------
commit:185711e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private List<Synchronization> synchronizations;
/////////////////////////////////////////////////////////////////////////
1:         if (synchronizations == null) {
1:             synchronizations = new ArrayList<Synchronization>(10);
1:         synchronizations.add(s);
1:         if (synchronizations == null) {
1:         int size = synchronizations.size();
1:                 synchronizations.get(i).afterRollback();
1:             synchronizations = null;
1:         if (synchronizations == null) {
1:         int size = synchronizations.size();
1:                 synchronizations.get(i).afterCommit();
1:         	synchronizations = null;
1:         if (synchronizations == null) {
1:         int size = synchronizations.size();
0:                 synchronizations.get(i).beforeEnd();
/////////////////////////////////////////////////////////////////////////
1:      * @throws javax.jms.JMSException on internal error
/////////////////////////////////////////////////////////////////////////
0:             synchronizations = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         synchronizations = null;
1:      * @return connectionId for connection
/////////////////////////////////////////////////////////////////////////
0:                 for (TransactionContext ctx : l) {
/////////////////////////////////////////////////////////////////////////
0:                 for (TransactionContext ctx : l) {
/////////////////////////////////////////////////////////////////////////
0:             XATransactionId[] answer;
/////////////////////////////////////////////////////////////////////////
1:      * @param e JMSException to convert
1:      * @return XAException wrapping original exception or its message
author:James Strachan
-------------------------------------------------------------------------------
commit:935fde0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.DataStructure;
/////////////////////////////////////////////////////////////////////////
0:             DataStructure[] data = receipt.getData();
0:             XATransactionId[] answer = null;
0:             if (data instanceof XATransactionId[]) {
0:                 answer = (XATransactionId[]) data;
0:             }
0:             else {
0:                 answer = new XATransactionId[data.length];
0:                 System.arraycopy(data, 0, answer, 0, data.length);
0:             }
0:             return answer;
commit:37e3387
/////////////////////////////////////////////////////////////////////////
0:                 } else if (!l.contains(this)) {
0:                     l.add(this);
0:                 }
============================================================================