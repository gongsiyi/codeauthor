1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:230a86c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:97ae323: 
1:39d0717: import java.io.IOException;
1:39d0717: import java.util.ArrayList;
1:2aff82c: import java.util.Collections;
1:39d0717: import java.util.HashMap;
1:39d0717: import java.util.Iterator;
1:39d0717: import java.util.LinkedList;
1:39d0717: import java.util.List;
1:39d0717: import java.util.Map;
1:39d0717: import java.util.Map.Entry;
1:39d0717: import java.util.concurrent.ExecutorService;
1:39d0717: import java.util.concurrent.Executors;
1:39d0717: import java.util.concurrent.atomic.AtomicBoolean;
1:dc258ab: import java.util.concurrent.atomic.AtomicInteger;
1:39d0717: import java.util.concurrent.atomic.AtomicReference;
1:39d0717: 
1:39d0717: import javax.jms.IllegalStateException;
1:39d0717: import javax.jms.InvalidDestinationException;
1:39d0717: import javax.jms.JMSException;
1:39d0717: import javax.jms.Message;
1:39d0717: import javax.jms.MessageConsumer;
1:39d0717: import javax.jms.MessageListener;
1:39d0717: import javax.jms.TransactionRolledBackException;
1:39d0717: 
1:b08ae50: import org.apache.activemq.blob.BlobDownloader;
1:9287055: import org.apache.activemq.command.ActiveMQBlobMessage;
1:9287055: import org.apache.activemq.command.ActiveMQDestination;
1:9287055: import org.apache.activemq.command.ActiveMQMessage;
1:9287055: import org.apache.activemq.command.ActiveMQObjectMessage;
1:9287055: import org.apache.activemq.command.ActiveMQTempDestination;
1:9287055: import org.apache.activemq.command.CommandTypes;
1:9287055: import org.apache.activemq.command.ConsumerId;
1:9287055: import org.apache.activemq.command.ConsumerInfo;
1:9287055: import org.apache.activemq.command.MessageAck;
1:9287055: import org.apache.activemq.command.MessageDispatch;
1:9287055: import org.apache.activemq.command.MessageId;
1:9287055: import org.apache.activemq.command.MessagePull;
1:9287055: import org.apache.activemq.command.RemoveInfo;
1:9287055: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.management.JMSConsumerStatsImpl;
1:d29ca2a: import org.apache.activemq.management.StatsCapable;
1:d29ca2a: import org.apache.activemq.management.StatsImpl;
1:d29ca2a: import org.apache.activemq.selector.SelectorParser;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:d29ca2a: import org.apache.activemq.util.Callback;
1:d29ca2a: import org.apache.activemq.util.IntrospectionSupport;
1:d29ca2a: import org.apache.activemq.util.JMSExceptionSupport;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:97ae323: 
1:d29ca2a: /**
1:d29ca2a:  * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:d29ca2a:  * from a destination. A <CODE> MessageConsumer</CODE> object is created by
1:d29ca2a:  * passing a <CODE>Destination</CODE> object to a message-consumer creation
1:d29ca2a:  * method supplied by a session.
1:d29ca2a:  * <P>
1:d29ca2a:  * <CODE>MessageConsumer</CODE> is the parent interface for all message
1:d29ca2a:  * consumers.
1:d29ca2a:  * <P>
1:d29ca2a:  * A message consumer can be created with a message selector. A message selector
1:d29ca2a:  * allows the client to restrict the messages delivered to the message consumer
1:d29ca2a:  * to those that match the selector.
1:d29ca2a:  * <P>
1:d29ca2a:  * A client may either synchronously receive a message consumer's messages or
1:d29ca2a:  * have the consumer asynchronously deliver them as they arrive.
1:d29ca2a:  * <P>
1:d29ca2a:  * For synchronous receipt, a client can request the next message from a message
1:d29ca2a:  * consumer using one of its <CODE> receive</CODE> methods. There are several
1:d29ca2a:  * variations of <CODE>receive</CODE> that allow a client to poll or wait for
1:d29ca2a:  * the next message.
1:d29ca2a:  * <P>
1:230a86c:  * For asynchronous delivery, a client can register a
1:230a86c:  * <CODE>MessageListener</CODE> object with a message consumer. As messages
1:230a86c:  * arrive at the message consumer, it delivers them by calling the
1:230a86c:  * <CODE>MessageListener</CODE>'s<CODE>
1:d29ca2a:  * onMessage</CODE> method.
1:d29ca2a:  * <P>
1:d29ca2a:  * It is a client programming error for a <CODE>MessageListener</CODE> to
1:d29ca2a:  * throw an exception.
1:88f6058:  *
1:88f6058:  *
1:d29ca2a:  * @see javax.jms.MessageConsumer
1:d29ca2a:  * @see javax.jms.QueueReceiver
1:d29ca2a:  * @see javax.jms.TopicSubscriber
1:d29ca2a:  * @see javax.jms.Session
1:d29ca2a:  */
1:d29ca2a: public class ActiveMQMessageConsumer implements MessageAvailableConsumer, StatsCapable, ActiveMQDispatcher {
1:13f9ec8: 
1:39d0717:     @SuppressWarnings("serial")
1:39d0717:     class PreviouslyDeliveredMap<K, V> extends HashMap<K, V> {
1:39d0717:         final TransactionId transactionId;
1:39d0717:         public PreviouslyDeliveredMap(TransactionId transactionId) {
1:39d0717:             this.transactionId = transactionId;
1:39d0717:         }
1:c38a61d:     }
1:dc0291b: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQMessageConsumer.class);
1:d29ca2a:     protected final ActiveMQSession session;
1:d29ca2a:     protected final ConsumerInfo info;
1:c38a61d: 
1:d29ca2a:     // These are the messages waiting to be delivered to the client
1:c14dc3a:     protected final MessageDispatchChannel unconsumedMessages;
1:39d0717: 
1:d29ca2a:     // The are the messages that were delivered to the consumer but that have
1:d29ca2a:     // not been acknowledged. It's kept in reverse order since we
1:3b08860:     // Always walk list in reverse order.
1:82c4ab8:     protected final LinkedList<MessageDispatch> deliveredMessages = new LinkedList<MessageDispatch>();
1:b836af8:     // track duplicate deliveries in a transaction such that the tx integrity can be validated
1:39d0717:     private PreviouslyDeliveredMap<MessageId, Boolean> previouslyDeliveredMessages;
1:230a86c:     private int deliveredCounter;
1:230a86c:     private int additionalWindowSize;
1:230a86c:     private long redeliveryDelay;
1:230a86c:     private int ackCounter;
1:230a86c:     private int dispatchedCount;
1:76ac758:     private final AtomicReference<MessageListener> messageListener = new AtomicReference<MessageListener>();
1:1a5ad28:     private final JMSConsumerStatsImpl stats;
1:8a75d96: 
1:d29ca2a:     private final String selector;
1:230a86c:     private boolean synchronizationRegistered;
1:1a5ad28:     private final AtomicBoolean started = new AtomicBoolean(false);
1:0b6bf7e: 
1:d29ca2a:     private MessageAvailableListener availableListener;
1:88f6058: 
1:f0454b1:     private RedeliveryPolicy redeliveryPolicy;
1:6eaea6f:     private boolean optimizeAcknowledge;
1:1a5ad28:     private final AtomicBoolean deliveryingAcknowledgements = new AtomicBoolean();
1:230a86c:     private ExecutorService executorService;
1:86faaef:     private MessageTransformer transformer;
1:82c4ab8:     private boolean clearDeliveredList;
1:dc258ab:     AtomicInteger inProgressClearRequiredFlag = new AtomicInteger(0);
1:88f6058: 
1:3856c39:     private MessageAck pendingAck;
1:dbb1d8b:     private long lastDeliveredSequenceId = -1;
1:e45bb06: 
1:f8ef7ff:     private IOException failureError;
1:88f6058: 
1:13f9ec8:     private long optimizeAckTimestamp = System.currentTimeMillis();
1:975fc55:     private long optimizeAcknowledgeTimeOut = 0;
1:3d5a758:     private long optimizedAckScheduledAckInterval = 0;
1:3d5a758:     private Runnable optimizedAckTask;
1:b836af8:     private long failoverRedeliveryWaitPeriod = 0;
1:2030097:     private boolean transactedIndividualAck = false;
1:0b6bf7e:     private boolean nonBlockingRedelivery = false;
1:642cc43:     private boolean consumerExpiryCheckEnabled = true;
1:88f6058: 
1:da5139c:     /**
1:d29ca2a:      * Create a MessageConsumer
1:88f6058:      *
1:d29ca2a:      * @param session
1:d29ca2a:      * @param dest
1:d29ca2a:      * @param name
1:d29ca2a:      * @param selector
1:d29ca2a:      * @param prefetch
1:62daac4:      * @param maximumPendingMessageCount
1:d29ca2a:      * @param noLocal
1:d29ca2a:      * @param browser
1:d29ca2a:      * @param dispatchAsync
1:fba0742:      * @param messageListener
1:230a86c:      * @throws JMSException
1:62daac4:      */
1:933eb2f:     public ActiveMQMessageConsumer(ActiveMQSession session, ConsumerId consumerId, ActiveMQDestination dest,
1:933eb2f:             String name, String selector, int prefetch,
1:933eb2f:             int maximumPendingMessageCount, boolean noLocal, boolean browser,
1:fba0742:             boolean dispatchAsync, MessageListener messageListener) throws JMSException {
1:d29ca2a:         if (dest == null) {
1:d29ca2a:             throw new InvalidDestinationException("Don't understand null destinations");
1:d29ca2a:         } else if (dest.getPhysicalName() == null) {
1:230a86c:             throw new InvalidDestinationException("The destination object was not given a physical name.");
1:d29ca2a:         } else if (dest.isTemporary()) {
1:d29ca2a:             String physicalName = dest.getPhysicalName();
1:13f9ec8: 
1:d29ca2a:             if (physicalName == null) {
1:d29ca2a:                 throw new IllegalArgumentException("Physical name of Destination should be valid: " + dest);
1:9e54516:             }
1:f8ef7ff: 
1:c59246d:             String connectionID = session.connection.getConnectionInfo().getConnectionId().getValue();
1:f8ef7ff: 
1:d29ca2a:             if (physicalName.indexOf(connectionID) < 0) {
1:3d5a758:                 throw new InvalidDestinationException("Cannot use a Temporary destination from another Connection");
1:39d0717:             }
1:efdf8ce: 
1:d29ca2a:             if (session.connection.isDeleted(dest)) {
1:3d5a758:                 throw new InvalidDestinationException("Cannot use a Temporary destination that has been deleted");
1:862cd71:             }
1:b4c3a30:             if (prefetch < 0) {
1:b4c3a30:                 throw new JMSException("Cannot have a prefetch size less than zero");
1:8a75d96:             }
1:88f6058:         }
1:c14dc3a:         if (session.connection.isMessagePrioritySupported()) {
1:c14dc3a:             this.unconsumedMessages = new SimplePriorityMessageDispatchChannel();
1:c14dc3a:         }else {
1:c14dc3a:             this.unconsumedMessages = new FifoMessageDispatchChannel();
1:f8ef7ff:         }
1:efdf8ce: 
1:d29ca2a:         this.session = session;
1:a3836b5:         this.redeliveryPolicy = session.connection.getRedeliveryPolicyMap().getEntryFor(dest);
1:9287055:         if (this.redeliveryPolicy == null) {
1:9287055:             this.redeliveryPolicy = new RedeliveryPolicy();
1:9287055:         }
1:86faaef:         setTransformer(session.getTransformer());
1:c256dcf: 
1:d29ca2a:         this.info = new ConsumerInfo(consumerId);
1:3d862f0:         this.info.setExclusive(this.session.connection.isExclusiveConsumer());
1:620523a:         this.info.setClientId(this.session.connection.getClientID());
1:333158a:         this.info.setSubscriptionName(name);
1:d29ca2a:         this.info.setPrefetchSize(prefetch);
1:6eaea6f:         this.info.setCurrentPrefetchSize(prefetch);
1:bed10aa:         this.info.setMaximumPendingMessageLimit(maximumPendingMessageCount);
1:d29ca2a:         this.info.setNoLocal(noLocal);
1:d29ca2a:         this.info.setDispatchAsync(dispatchAsync);
1:d29ca2a:         this.info.setRetroactive(this.session.connection.isUseRetroactiveConsumer());
1:d29ca2a:         this.info.setSelector(null);
1:c256dcf: 
1:d29ca2a:         // Allows the options on the destination to configure the consumerInfo
1:d29ca2a:         if (dest.getOptions() != null) {
1:6c4bcb3:             Map<String, Object> options = IntrospectionSupport.extractProperties(
1:6c4bcb3:                 new HashMap<String, Object>(dest.getOptions()), "consumer.");
1:56272fa:             IntrospectionSupport.setProperties(this.info, options);
1:88f6058:             if (options.size() > 0) {
1:88f6058:                 String msg = "There are " + options.size()
1:88f6058:                     + " consumer options that couldn't be set on the consumer."
1:88f6058:                     + " Check the options are spelled correctly."
1:88f6058:                     + " Unknown parameters=[" + options + "]."
1:88f6058:                     + " This consumer cannot be started.";
1:88f6058:                 LOG.warn(msg);
1:88f6058:                 throw new ConfigurationException(msg);
1:88f6058:             }
1:f8ef7ff:         }
1:c256dcf: 
1:d29ca2a:         this.info.setDestination(dest);
1:d29ca2a:         this.info.setBrowser(browser);
1:d29ca2a:         if (selector != null && selector.trim().length() != 0) {
1:87d15d6:             // Validate the selector
1:1ab76f7:             SelectorParser.parse(selector);
1:d29ca2a:             this.info.setSelector(selector);
1:d29ca2a:             this.selector = selector;
1:87d15d6:         } else if (info.getSelector() != null) {
1:87d15d6:             // Validate the selector
1:1ab76f7:             SelectorParser.parse(this.info.getSelector());
1:87d15d6:             this.selector = this.info.getSelector();
1:184761a:         } else {
1:87d15d6:             this.selector = null;
1:88f6058:         }
1:74a7a8b: 
1:d29ca2a:         this.stats = new JMSConsumerStatsImpl(session.getSessionStats(), dest);
1:933eb2f:         this.optimizeAcknowledge = session.connection.isOptimizeAcknowledge() && session.isAutoAcknowledge()
1:933eb2f:                                    && !info.isBrowser();
1:975fc55:         if (this.optimizeAcknowledge) {
1:975fc55:             this.optimizeAcknowledgeTimeOut = session.connection.getOptimizeAcknowledgeTimeOut();
1:3d5a758:             setOptimizedAckScheduledAckInterval(session.connection.getOptimizedAckScheduledAckInterval());
1:975fc55:         }
1:3d5a758: 
1:6eaea6f:         this.info.setOptimizedAcknowledge(this.optimizeAcknowledge);
1:b836af8:         this.failoverRedeliveryWaitPeriod = session.connection.getConsumerFailoverRedeliveryWaitPeriod();
1:0b6bf7e:         this.nonBlockingRedelivery = session.connection.isNonBlockingRedelivery();
1:bbb2acc:         this.transactedIndividualAck = session.connection.isTransactedIndividualAck()
1:bbb2acc:                         || this.nonBlockingRedelivery
1:bbb2acc:                         || session.connection.isMessagePrioritySupported();
1:642cc43:         this.consumerExpiryCheckEnabled = session.connection.isConsumerExpiryCheckEnabled();
1:230a86c:         if (messageListener != null) {
1:fba0742:             setMessageListener(messageListener);
1:88f6058:         }
1:230a86c:         try {
1:d29ca2a:             this.session.addConsumer(this);
1:d29ca2a:             this.session.syncSendPacket(info);
1:230a86c:         } catch (JMSException e) {
2:d29ca2a:             this.session.removeConsumer(this);
1:d29ca2a:             throw e;
27:d29ca2a:         }
1:74a7a8b: 
1:ecf89a6:         if (session.connection.isStarted()) {
2:230a86c:             start();
1:ecf89a6:         }
1:d29ca2a:     }
1:88f6058: 
1:ec82141:     private boolean isAutoAcknowledgeEach() {
1:ec82141:         return session.isAutoAcknowledge() || ( session.isDupsOkAcknowledge() && getDestination().isQueue() );
1:ec82141:     }
1:ec82141: 
1:ec82141:     private boolean isAutoAcknowledgeBatch() {
1:ec82141:         return session.isDupsOkAcknowledge() && !getDestination().isQueue() ;
1:ec82141:     }
1:ec82141: 
1:2aff82c:     @Override
1:d29ca2a:     public StatsImpl getStats() {
1:d29ca2a:         return stats;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public JMSConsumerStatsImpl getConsumerStats() {
1:d29ca2a:         return stats;
1:d29ca2a:     }
1:230a86c: 
1:f0454b1:     public RedeliveryPolicy getRedeliveryPolicy() {
1:f0454b1:         return redeliveryPolicy;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:f0454b1:      * Sets the redelivery policy used when messages are redelivered
1:da5139c:      */
1:f0454b1:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
1:f0454b1:         this.redeliveryPolicy = redeliveryPolicy;
1:d29ca2a:     }
1:230a86c: 
1:86faaef:     public MessageTransformer getTransformer() {
1:86faaef:         return transformer;
1:d29ca2a:     }
1:da5139c: 
1:d29ca2a:     /**
1:230a86c:      * Sets the transformer used to transform messages before they are sent on
1:230a86c:      * to the JMS bus
1:d29ca2a:      */
1:86faaef:     public void setTransformer(MessageTransformer transformer) {
1:86faaef:         this.transformer = transformer;
1:d29ca2a:     }
1:da5139c: 
1:9ce91fa:     /**
1:c59246d:      * @return Returns the value.
1:d29ca2a:      */
1:b52624e:     public ConsumerId getConsumerId() {
1:d29ca2a:         return info.getConsumerId();
1:d29ca2a:     }
1:da5139c: 
1:d29ca2a:     /**
1:d29ca2a:      * @return the consumer name - used for durable consumers
1:d29ca2a:      */
1:b52624e:     public String getConsumerName() {
1:333158a:         return this.info.getSubscriptionName();
1:d29ca2a:     }
1:da5139c: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if this consumer does not accept locally produced messages
1:d29ca2a:      */
1:d29ca2a:     protected boolean isNoLocal() {
1:d29ca2a:         return info.isNoLocal();
1:d29ca2a:     }
70:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Retrieve is a browser
1:88f6058:      *
1:d29ca2a:      * @return true if a browser
1:d29ca2a:      */
1:d29ca2a:     protected boolean isBrowser() {
1:d29ca2a:         return info.isBrowser();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return ActiveMQDestination
1:d29ca2a:      */
1:d29ca2a:     protected ActiveMQDestination getDestination() {
1:d29ca2a:         return info.getDestination();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the prefetchNumber.
1:d29ca2a:      */
1:d29ca2a:     public int getPrefetchNumber() {
1:d29ca2a:         return info.getPrefetchSize();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if this is a durable topic subscriber
1:d29ca2a:      */
1:d29ca2a:     public boolean isDurableSubscriber() {
1:230a86c:         return info.getSubscriptionName() != null && info.getDestination().isTopic();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets this message consumer's message selector expression.
1:88f6058:      *
1:d29ca2a:      * @return this message consumer's message selector, or null if no message
1:d29ca2a:      *         selector exists for the message consumer (that is, if the message
1:d29ca2a:      *         selector was not set or was set to null or the empty string)
1:230a86c:      * @throws JMSException if the JMS provider fails to receive the next
1:230a86c:      *                 message due to some internal error.
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public String getMessageSelector() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return selector;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets the message consumer's <CODE>MessageListener</CODE>.
1:88f6058:      *
1:d29ca2a:      * @return the listener for the message consumer, or null if no listener is
1:d29ca2a:      *         set
1:230a86c:      * @throws JMSException if the JMS provider fails to get the message
1:230a86c:      *                 listener due to some internal error.
1:d29ca2a:      * @see javax.jms.MessageConsumer#setMessageListener(javax.jms.MessageListener)
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public MessageListener getMessageListener() throws JMSException {
1:d29ca2a:         checkClosed();
1:76ac758:         return this.messageListener.get();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the message consumer's <CODE>MessageListener</CODE>.
1:d29ca2a:      * <P>
1:d29ca2a:      * Setting the message listener to null is the equivalent of unsetting the
1:d29ca2a:      * message listener for the message consumer.
1:d29ca2a:      * <P>
1:d29ca2a:      * The effect of calling <CODE>MessageConsumer.setMessageListener</CODE>
1:d29ca2a:      * while messages are being consumed by an existing listener or the consumer
1:d29ca2a:      * is being used to consume messages synchronously is undefined.
1:88f6058:      *
1:230a86c:      * @param listener the listener to which the messages are to be delivered
1:230a86c:      * @throws JMSException if the JMS provider fails to receive the next
1:230a86c:      *                 message due to some internal error.
1:d29ca2a:      * @see javax.jms.MessageConsumer#getMessageListener
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public void setMessageListener(MessageListener listener) throws JMSException {
1:d29ca2a:         checkClosed();
1:6e3a634:         if (info.getPrefetchSize() == 0) {
1:3d5a758:             throw new JMSException("Illegal prefetch size of zero. This setting is not supported for asynchronous consumers please set a value of at least 1");
1:d29ca2a:         }
1:230a86c:         if (listener != null) {
1:d29ca2a:             boolean wasRunning = session.isRunning();
1:ecf89a6:             if (wasRunning) {
1:d29ca2a:                 session.stop();
1:ecf89a6:             }
1:d29ca2a: 
1:76ac758:             this.messageListener.set(listener);
1:230a86c:             session.redispatch(this, unconsumedMessages);
1:d29ca2a: 
1:ecf89a6:             if (wasRunning) {
1:d29ca2a:                 session.start();
1:ecf89a6:             }
1:9f548bb:         } else {
1:76ac758:             this.messageListener.set(null);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:2aff82c:     @Override
1:d29ca2a:     public MessageAvailableListener getAvailableListener() {
1:d29ca2a:         return availableListener;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sets the listener used to notify synchronous consumers that there is a
1:230a86c:      * message available so that the {@link MessageConsumer#receiveNoWait()} can
1:230a86c:      * be called.
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public void setAvailableListener(MessageAvailableListener availableListener) {
1:d29ca2a:         this.availableListener = availableListener;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Used to get an enqueued message from the unconsumedMessages list. The
1:d29ca2a:      * amount of time this method blocks is based on the timeout value. - if
1:d29ca2a:      * timeout==-1 then it blocks until a message is received. - if timeout==0
1:d29ca2a:      * then it it tries to not block at all, it returns a message if it is
1:d29ca2a:      * available - if timeout>0 then it blocks up to timeout amount of time.
1:d29ca2a:      * Expired messages will consumed by this method.
1:88f6058:      *
1:da5139c:      * @throws JMSException
1:d29ca2a:      * @return null if we timeout or if the consumer is closed.
1:d29ca2a:      */
1:d29ca2a:     private MessageDispatch dequeue(long timeout) throws JMSException {
1:230a86c:         try {
1:d29ca2a:             long deadline = 0;
1:d29ca2a:             if (timeout > 0) {
1:d29ca2a:                 deadline = System.currentTimeMillis() + timeout;
1:d29ca2a:             }
1:d29ca2a:             while (true) {
1:d29ca2a:                 MessageDispatch md = unconsumedMessages.dequeue(timeout);
1:d29ca2a:                 if (md == null) {
1:d29ca2a:                     if (timeout > 0 && !unconsumedMessages.isClosed()) {
1:d29ca2a:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
1:88f6058:                     } else {
1:88f6058:                         if (failureError != null) {
1:88f6058:                             throw JMSExceptionSupport.create(failureError);
1:88f6058:                         } else {
1:88f6058:                             return null;
1:b84413a:                         }
1:88f6058:                     }
1:230a86c:                 } else if (md.getMessage() == null) {
1:f8ef7ff:                     return null;
1:c38a61d:                 } else if (consumeExpiredMessage(md)) {
1:c38a61d:                     LOG.debug("{} received expired message: {}", getConsumerId(), md);
1:230a86c:                     beforeMessageIsConsumed(md);
1:d29ca2a:                     afterMessageIsConsumed(md, true);
1:d29ca2a:                     if (timeout > 0) {
1:d29ca2a:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
1:f8ef7ff:                     }
1:3348ade:                     sendPullCommand(timeout);
1:fad1dd0:                 } else if (redeliveryExceeded(md)) {
1:c38a61d:                     LOG.debug("{} received with excessive redelivered: {}", getConsumerId(), md);
1:b6bca39:                     posionAck(md, "Dispatch[" + md.getRedeliveryCounter() + "] to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
1:b84413a:                     if (timeout > 0) {
1:b84413a:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
1:fad1dd0:                     }
1:b84413a:                     sendPullCommand(timeout);
1:f8ef7ff:                 } else {
1:82c4ab8:                     if (LOG.isTraceEnabled()) {
1:e45bb06:                         LOG.trace(getConsumerId() + " received message: " + md);
1:d29ca2a:                     }
1:d29ca2a:                     return md;
1:d29ca2a:                 }
1:d29ca2a:             }
1:230a86c:         } catch (InterruptedException e) {
1:0a66b79:             Thread.currentThread().interrupt();
1:d29ca2a:             throw JMSExceptionSupport.create(e);
1:3d5a758:         }
1:3d5a758:     }
1:50a98e3: 
1:c38a61d:     private boolean consumeExpiredMessage(MessageDispatch dispatch) {
1:a3a5a1a:         return isConsumerExpiryCheckEnabled() && dispatch.getMessage().isExpired();
1:c38a61d:     }
1:c38a61d: 
1:fad1dd0:     private void posionAck(MessageDispatch md, String cause) throws JMSException {
1:fad1dd0:         MessageAck posionAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:fad1dd0:         posionAck.setFirstMessageId(md.getMessage().getMessageId());
1:fad1dd0:         posionAck.setPoisonCause(new Throwable(cause));
1:fad1dd0:         session.sendAck(posionAck);
1:fad1dd0:     }
1:fad1dd0: 
1:fad1dd0:     private boolean redeliveryExceeded(MessageDispatch md) {
1:fad1dd0:         try {
1:f70dc74:             return session.getTransacted()
1:f70dc74:                     && redeliveryPolicy != null
1:b6bca39:                     && redeliveryPolicy.isPreDispatchCheck()
1:fad1dd0:                     && redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
1:fad1dd0:                     && md.getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()
1:fad1dd0:                     // redeliveryCounter > x expected after resend via brokerRedeliveryPlugin
1:fad1dd0:                     && md.getMessage().getProperty("redeliveryDelay") == null;
1:f70dc74:         } catch (Exception ignored) {
1:fad1dd0:             return false;
1:fad1dd0:         }
1:fad1dd0:     }
1:fad1dd0: 
1:d29ca2a:     /**
1:d29ca2a:      * Receives the next message produced for this message consumer.
1:d29ca2a:      * <P>
1:d29ca2a:      * This call blocks indefinitely until a message is produced or until this
1:d29ca2a:      * message consumer is closed.
1:d29ca2a:      * <P>
1:d29ca2a:      * If this <CODE>receive</CODE> is done within a transaction, the consumer
1:d29ca2a:      * retains the message until the transaction commits.
1:88f6058:      *
1:d29ca2a:      * @return the next message produced for this message consumer, or null if
1:d29ca2a:      *         this message consumer is concurrently closed
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public Message receive() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         checkMessageListener();
1:88f6058: 
1:2e08bc7:         sendPullCommand(0);
1:d29ca2a:         MessageDispatch md = dequeue(-1);
1:ecf89a6:         if (md == null) {
1:230a86c:             return null;
1:ecf89a6:         }
1:a19bfd4: 
1:da5139c:         beforeMessageIsConsumed(md);
1:230a86c:         afterMessageIsConsumed(md, false);
1:a19bfd4: 
1:d29ca2a:         return createActiveMQMessage(md);
1:91720da:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param md
1:61b2f6b:      *      the MessageDispatch that arrived from the Broker.
1:61b2f6b:      *
1:61b2f6b:      * @return an ActiveMQMessage initialized from the Message in the dispatch.
1:d29ca2a:      */
1:86faaef:     private ActiveMQMessage createActiveMQMessage(final MessageDispatch md) throws JMSException {
1:230a86c:         ActiveMQMessage m = (ActiveMQMessage)md.getMessage().copy();
1:b08ae50:         if (m.getDataStructureType()==CommandTypes.ACTIVEMQ_BLOB_MESSAGE) {
1:88f6058:             ((ActiveMQBlobMessage)m).setBlobDownloader(new BlobDownloader(session.getBlobTransferPolicy()));
1:d29ca2a:         }
1:94446e5:         if (m.getDataStructureType() == CommandTypes.ACTIVEMQ_OBJECT_MESSAGE) {
1:94446e5:             ((ActiveMQObjectMessage)m).setTrustAllPackages(session.getConnection().isTrustAllPackages());
1:94446e5:             ((ActiveMQObjectMessage)m).setTrustedPackages(session.getConnection().getTrustedPackages());
1:94446e5:         }
1:86faaef:         if (transformer != null) {
1:86faaef:             Message transformedMessage = transformer.consumerTransform(session, this, m);
1:86faaef:             if (transformedMessage != null) {
1:86faaef:                 m = ActiveMQMessageTransformation.transformMessage(transformedMessage, session.connection);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         if (session.isClientAcknowledge()) {
1:d29ca2a:             m.setAcknowledgeCallback(new Callback() {
1:2aff82c:                 @Override
1:7f5213b:                 public void execute() throws Exception {
1:e91f5c8:                     checkClosed();
1:d29ca2a:                     session.checkClosed();
1:d29ca2a:                     session.acknowledge();
1:d29ca2a:                 }
1:d29ca2a:             });
1:3d5a758:         } else if (session.isIndividualAcknowledge()) {
1:4ddb3e3:             m.setAcknowledgeCallback(new Callback() {
1:2aff82c:                 @Override
1:4ddb3e3:                 public void execute() throws Exception {
1:e91f5c8:                     checkClosed();
1:4ddb3e3:                     session.checkClosed();
1:0bc545b:                     acknowledge(md);
1:d29ca2a:                 }
1:4ddb3e3:             });
1:d29ca2a:         }
1:d29ca2a:         return m;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Receives the next message that arrives within the specified timeout
1:d29ca2a:      * interval.
1:d29ca2a:      * <P>
1:d29ca2a:      * This call blocks until a message arrives, the timeout expires, or this
1:d29ca2a:      * message consumer is closed. A <CODE>timeout</CODE> of zero never
1:d29ca2a:      * expires, and the call blocks indefinitely.
1:88f6058:      *
1:230a86c:      * @param timeout the timeout value (in milliseconds), a time out of zero
1:230a86c:      *                never expires.
1:d29ca2a:      * @return the next message produced for this message consumer, or null if
1:d29ca2a:      *         the timeout expires or this message consumer is concurrently
1:d29ca2a:      *         closed
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public Message receive(long timeout) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         checkMessageListener();
1:d29ca2a:         if (timeout == 0) {
1:d29ca2a:             return this.receive();
1:d29ca2a:         }
1:230a86c: 
1:a19bfd4:         sendPullCommand(timeout);
1:d29ca2a:         while (timeout > 0) {
1:230a86c: 
1:a19bfd4:             MessageDispatch md;
1:a19bfd4:             if (info.getPrefetchSize() == 0) {
1:39d0717:                 md = dequeue(-1); // We let the broker let us know when we timeout.
1:efdf8ce:             } else {
1:230a86c:                 md = dequeue(timeout);
1:ecf89a6:             }
1:a19bfd4: 
1:ecf89a6:             if (md == null) {
1:a19bfd4:                 return null;
1:a19bfd4:             }
1:a19bfd4: 
1:da5139c:             beforeMessageIsConsumed(md);
1:230a86c:             afterMessageIsConsumed(md, false);
1:d29ca2a:             return createActiveMQMessage(md);
1:d29ca2a:         }
4:d29ca2a:         return null;
1:d29ca2a:     }
1:a19bfd4: 
1:d29ca2a:     /**
1:d29ca2a:      * Receives the next message if one is immediately available.
1:88f6058:      *
1:d29ca2a:      * @return the next message produced for this message consumer, or null if
1:d29ca2a:      *         one is not available
1:230a86c:      * @throws JMSException if the JMS provider fails to receive the next
1:230a86c:      *                 message due to some internal error.
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public Message receiveNoWait() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         checkMessageListener();
1:a19bfd4:         sendPullCommand(-1);
1:230a86c: 
1:a19bfd4:         MessageDispatch md;
1:a19bfd4:         if (info.getPrefetchSize() == 0) {
1:230a86c:             md = dequeue(-1); // We let the broker let us know when we
1:230a86c:             // timeout.
1:a2101b7:         } else {
1:230a86c:             md = dequeue(0);
1:ecf89a6:         }
1:230a86c: 
1:ecf89a6:         if (md == null) {
1:d29ca2a:             return null;
1:a19bfd4:         }
1:a19bfd4: 
6:d29ca2a:         beforeMessageIsConsumed(md);
2:da5139c:         afterMessageIsConsumed(md, false);
1:d29ca2a:         return createActiveMQMessage(md);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Closes the message consumer.
1:d29ca2a:      * <P>
1:d29ca2a:      * Since a provider may allocate some resources on behalf of a <CODE>
1:230a86c:      * MessageConsumer</CODE>
1:230a86c:      * outside the Java virtual machine, clients should close them when they are
1:230a86c:      * not needed. Relying on garbage collection to eventually reclaim these
1:230a86c:      * resources may not be timely enough.
1:d29ca2a:      * <P>
1:d29ca2a:      * This call blocks until a <CODE>receive</CODE> or message listener in
1:d29ca2a:      * progress has completed. A blocked message consumer <CODE>receive </CODE>
1:d29ca2a:      * call returns null when this message consumer is closed.
1:88f6058:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to close the consumer due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:2aff82c:     @Override
1:d29ca2a:     public void close() throws JMSException {
1:da5139c:         if (!unconsumedMessages.isClosed()) {
1:163ad5d:             if (!deliveredMessages.isEmpty() && session.getTransactionContext().isInTransaction()) {
1:50a98e3:                 session.getTransactionContext().addSynchronization(new Synchronization() {
1:2aff82c:                     @Override
1:50a98e3:                     public void afterCommit() throws Exception {
1:50a98e3:                         doClose();
1:50a98e3:                     }
1:50a98e3: 
1:1a5ad28:                     @Override
1:50a98e3:                     public void afterRollback() throws Exception {
1:50a98e3:                         doClose();
1:50a98e3:                     }
1:50a98e3:                 });
1:50a98e3:             } else {
1:50a98e3:                 doClose();
1:50a98e3:             }
1:88f6058:         }
1:d29ca2a:     }
1:c256dcf: 
1:50a98e3:     void doClose() throws JMSException {
1:50a98e3:         dispose();
1:3b08860:         RemoveInfo removeCommand = info.createRemoveCommand();
1:c38a61d:         LOG.debug("remove: {}, lastDeliveredSequenceId: {}", getConsumerId(), lastDeliveredSequenceId);
1:3b08860:         removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:3b08860:         this.session.asyncSendPacket(removeCommand);
1:383d12e:     }
1:50a98e3: 
1:9e54516:     void inProgressClearRequired() {
1:dc258ab:         inProgressClearRequiredFlag.incrementAndGet();
1:62daac4:         // deal with delivered messages async to avoid lock contention with in progress acks
1:82c4ab8:         clearDeliveredList = true;
1:8d98247:         // force a rollback if we will be acking in a transaction after/during failover
1:8d98247:         // bc acks are async they may not get there reliably on reconnect and the consumer
1:8d98247:         // may not be aware of the reconnect in a timely fashion if in onMessage
1:8d98247:         if (!deliveredMessages.isEmpty() && session.getTransactionContext().isInTransaction()) {
1:8d98247:             session.getTransactionContext().setRollbackOnly(true);
1:8d98247:         }
1:9e54516:     }
1:9e54516: 
1:9e54516:     void clearMessagesInProgress() {
1:dc258ab:         if (inProgressClearRequiredFlag.get() > 0) {
1:9e54516:             synchronized (unconsumedMessages.getMutex()) {
1:dc258ab:                 if (inProgressClearRequiredFlag.get() > 0) {
1:c38a61d:                     LOG.debug("{} clearing unconsumed list ({}) on transport interrupt", getConsumerId(), unconsumedMessages.size());
1:9e54516:                     // ensure unconsumed are rolledback up front as they may get redelivered to another consumer
1:9e54516:                     List<MessageDispatch> list = unconsumedMessages.removeAll();
1:9e54516:                     if (!this.info.isBrowser()) {
1:9e54516:                         for (MessageDispatch old : list) {
1:9e54516:                             session.connection.rollbackDuplicate(this, old.getMessage());
1:82c4ab8:                         }
1:9e54516:                     }
1:9e54516:                     // allow dispatch on this connection to resume
1:9e54516:                     session.connection.transportInterruptionProcessingComplete();
1:dc258ab:                     inProgressClearRequiredFlag.decrementAndGet();
1:0227c08: 
1:0227c08:                     // Wake up any blockers and allow them to recheck state.
1:0227c08:                     unconsumedMessages.getMutex().notifyAll();
1:9e54516:                 }
1:862cd71:             }
1:862cd71:         }
1:82c4ab8:         clearDeliveredList();
1:862cd71:     }
1:88f6058: 
1:230a86c:     void deliverAcks() {
1:230a86c:         MessageAck ack = null;
1:230a86c:         if (deliveryingAcknowledgements.compareAndSet(false, true)) {
1:c02bc64:             synchronized(deliveredMessages) {
1:c02bc64:                 if (isAutoAcknowledgeEach()) {
1:e45bb06:                     ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:e45bb06:                     if (ack != null) {
1:e45bb06:                         deliveredMessages.clear();
1:e45bb06:                         ackCounter = 0;
1:7a59d28:                     } else {
2:3856c39:                         ack = pendingAck;
1:0bc545b:                         pendingAck = null;
1:62eb5cf:                     }
1:c02bc64:                 } else if (pendingAck != null && pendingAck.isStandardAck()) {
1:c02bc64:                     ack = pendingAck;
1:c02bc64:                     pendingAck = null;
1:0bc545b:                 }
1:9f548bb:             }
1:230a86c:             if (ack != null) {
1:230a86c:                 final MessageAck ackToSend = ack;
1:e45bb06: 
1:230a86c:                 if (executorService == null) {
1:230a86c:                     executorService = Executors.newSingleThreadExecutor();
1:9f548bb:                 }
1:230a86c:                 executorService.submit(new Runnable() {
1:2aff82c:                     @Override
1:230a86c:                     public void run() {
1:230a86c:                         try {
1:d8b5d5c:                             session.sendAck(ackToSend,true);
1:230a86c:                         } catch (JMSException e) {
1:5829d70:                             LOG.error(getConsumerId() + " failed to delivered acknowledgements", e);
1:230a86c:                         } finally {
1:caf7a7c:                             deliveryingAcknowledgements.set(false);
1:50a98e3:                         }
1:ecf89a6:                     }
1:d29ca2a:                 });
1:0b6bf7e:             } else {
2:6eaea6f:                 deliveryingAcknowledgements.set(false);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:88f6058: 
1:230a86c:     public void dispose() throws JMSException {
1:230a86c:         if (!unconsumedMessages.isClosed()) {
1:88f6058: 
1:d29ca2a:             // Do we have any acks we need to send out before closing?
1:50a98e3:             // Ack any delivered messages now.
1:4046599:             if (!session.getTransacted()) {
1:50a98e3:                 deliverAcks();
1:ec82141:                 if (isAutoAcknowledgeBatch()) {
1:50a98e3:                     acknowledge();
1:50a98e3:                 }
1:50a98e3:             }
1:230a86c:             if (executorService != null) {
1:6c1676b:                 ThreadPoolUtils.shutdownGraceful(executorService, 60000L);
1:6c1676b:                 executorService = null;
1:d29ca2a:             }
1:3d5a758:             if (optimizedAckTask != null) {
1:3d5a758:                 this.session.connection.getScheduler().cancel(optimizedAckTask);
1:3d5a758:                 optimizedAckTask = null;
1:3d5a758:             }
1:c256dcf: 
1:b9b27b9:             if (session.isClientAcknowledge() || session.isIndividualAcknowledge()) {
1:862cd71:                 if (!this.info.isBrowser()) {
1:cbaa58b:                     // rollback duplicates that aren't acknowledged
1:586ea12:                     List<MessageDispatch> tmp = null;
1:586ea12:                     synchronized (this.deliveredMessages) {
1:586ea12:                         tmp = new ArrayList<MessageDispatch>(this.deliveredMessages);
1:d29ca2a:                     }
1:586ea12:                     for (MessageDispatch old : tmp) {
1:586ea12:                         this.session.connection.rollbackDuplicate(this, old.getMessage());
1:d29ca2a:                     }
1:586ea12:                     tmp.clear();
1:d29ca2a:                 }
1:d29ca2a:             }
1:62daac4:             if (!session.isTransacted()) {
1:e45bb06:                 synchronized(deliveredMessages) {
1:4229aee:                     deliveredMessages.clear();
1:62daac4:                 }
1:4229aee:             }
1:7ceb4cb:             unconsumedMessages.close();
1:7ceb4cb:             this.session.removeConsumer(this);
1:862cd71:             List<MessageDispatch> list = unconsumedMessages.removeAll();
1:0bc545b:             if (!this.info.isBrowser()) {
1:862cd71:                 for (MessageDispatch old : list) {
1:0bc545b:                     // ensure we don't filter this as a duplicate
1:aaecdff:                     if (old.getMessage() != null) {
1:aaecdff:                         LOG.debug("on close, rollback duplicate: {}", old.getMessage().getMessageId());
1:aaecdff:                     }
1:862cd71:                     session.connection.rollbackDuplicate(this, old.getMessage());
1:0bc545b:                 }
1:0bc545b:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:0bc545b: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws IllegalStateException
1:d29ca2a:      */
1:d29ca2a:     protected void checkClosed() throws IllegalStateException {
1:da5139c:         if (unconsumedMessages.isClosed()) {
1:d29ca2a:             throw new IllegalStateException("The Consumer is closed");
1:ecf89a6:         }
1:d29ca2a:     }
1:230a86c: 
1:86faaef:     /**
1:230a86c:      * If we have a zero prefetch specified then send a pull command to the
1:230a86c:      * broker to pull a message we are about to receive
1:86faaef:      */
1:a19bfd4:     protected void sendPullCommand(long timeout) throws JMSException {
1:82c4ab8:         clearDeliveredList();
1:95e6d60:         if (info.getCurrentPrefetchSize() == 0 && unconsumedMessages.isEmpty()) {
1:6e3a634:             MessagePull messagePull = new MessagePull();
1:6e3a634:             messagePull.configure(info);
1:230a86c:             messagePull.setTimeout(timeout);
1:6e3a634:             session.asyncSendPacket(messagePull);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:d86f77f:     protected void checkMessageListener() throws JMSException {
1:d86f77f:         session.checkMessageListener();
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     protected void setOptimizeAcknowledge(boolean value) {
1:230a86c:         if (optimizeAcknowledge && !value) {
1:230a86c:             deliverAcks();
1:d29ca2a:         }
1:230a86c:         optimizeAcknowledge = value;
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     protected void setPrefetchSize(int prefetch) {
2:ef0734b:         deliverAcks();
1:6eaea6f:         this.info.setCurrentPrefetchSize(prefetch);
1:d29ca2a:     }
1:d29ca2a: 
1:b708fd3:     private void beforeMessageIsConsumed(MessageDispatch md) throws JMSException {
1:d29ca2a:         md.setDeliverySequenceId(session.getNextDeliveryId());
1:3b08860:         lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();
1:ec82141:         if (!isAutoAcknowledgeBatch()) {
1:4229aee:             synchronized(deliveredMessages) {
1:d29ca2a:                 deliveredMessages.addFirst(md);
1:b708fd3:             }
1:4046599:             if (session.getTransacted()) {
1:2030097:                 if (transactedIndividualAck) {
1:2030097:                     immediateIndividualTransactedAck(md);
1:2030097:                 } else {
1:2030097:                     ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:2030097:                 }
1:2030097:             }
1:88f6058:         }
1:b708fd3:     }
1:2030097: 
1:2030097:     private void immediateIndividualTransactedAck(MessageDispatch md) throws JMSException {
1:2030097:         // acks accumulate on the broker pending transaction completion to indicate
1:2030097:         // delivery status
1:2030097:         registerSync();
1:6778a49:         MessageAck ack = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
1:2030097:         ack.setTransactionId(session.getTransactionContext().getTransactionId());
1:c78eddc:         session.sendAck(ack);
1:2030097:     }
1:2030097: 
1:230a86c:     private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {
1:ecf89a6:         if (unconsumedMessages.isClosed()) {
1:461af7c:             return;
1:62daac4:         }
1:230a86c:         if (messageExpired) {
1:b136df1:             acknowledge(md, MessageAck.EXPIRED_ACK_TYPE);
1:b997d25:             stats.getExpiredMessageCount().increment();
1:2030097:         } else {
1:d29ca2a:             stats.onMessage();
1:4046599:             if (session.getTransacted()) {
1:ecf89a6:                 // Do nothing.
1:ec82141:             } else if (isAutoAcknowledgeEach()) {
1:184761a:                 if (deliveryingAcknowledgements.compareAndSet(false, true)) {
1:62daac4:                     synchronized (deliveredMessages) {
1:62daac4:                         if (!deliveredMessages.isEmpty()) {
1:184761a:                             if (optimizeAcknowledge) {
1:caf7a7c:                                 ackCounter++;
1:0bc545b: 
1:3d5a758:                                 // AMQ-3956 evaluate both expired and normal msgs as
1:39e20d0:                                 // otherwise consumer may get stalled
1:39e20d0:                                 if (ackCounter + deliveredCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
1:184761a:                                     MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:88f6058:                                     if (ack != null) {
1:862cd71:                                         deliveredMessages.clear();
1:88f6058:                                         ackCounter = 0;
1:2030097:                                         session.sendAck(ack);
1:88f6058:                                         optimizeAckTimestamp = System.currentTimeMillis();
1:82c4ab8:                                     }
1:3d5a758:                                     // AMQ-3956 - as further optimization send
1:39e20d0:                                     // ack for expired msgs when there are any.
1:39e20d0:                                     // This resets the deliveredCounter to 0 so that
1:39e20d0:                                     // we won't sent standard acks with every msg just
1:3d5a758:                                     // because the deliveredCounter just below
1:39e20d0:                                     // 0.5 * prefetch as used in ackLater()
1:3856c39:                                     if (pendingAck != null && deliveredCounter > 0) {
1:3856c39:                                         session.sendAck(pendingAck);
1:862cd71:                                         pendingAck = null;
1:a707594:                                         deliveredCounter = 0;
1:62daac4:                                     }
1:62daac4:                                 }
1:b836af8:                             } else {
1:88f6058:                                 MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:184761a:                                 if (ack!=null) {
1:0bc545b:                                     deliveredMessages.clear();
1:62daac4:                                     session.sendAck(ack);
1:862cd71:                                 }
1:0bc545b:                             }
1:0bc545b:                         }
1:0bc545b:                     }
1:184761a:                     deliveryingAcknowledgements.set(false);
1:b997d25:                 }
1:ec82141:             } else if (isAutoAcknowledgeBatch()) {
1:230a86c:                 ackLater(md, MessageAck.STANDARD_ACK_TYPE);
1:4ddb3e3:             } else if (session.isClientAcknowledge()||session.isIndividualAcknowledge()) {
1:83df5ce:                 boolean messageUnackedByConsumer = false;
1:62daac4:                 synchronized (deliveredMessages) {
1:83df5ce:                     messageUnackedByConsumer = deliveredMessages.contains(md);
1:83df5ce:                 }
1:83df5ce:                 if (messageUnackedByConsumer) {
1:2030097:                     ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:83df5ce:                 }
1:184761a:             }
1:2076f45:             else {
1:d29ca2a:                 throw new IllegalStateException("Invalid session state.");
1:88f6058:             }
1:13f9ec8:         }
1:230a86c:     }
1:e45bb06: 
1:6e3a634:     /**
1:9ce91fa:      * Creates a MessageAck for all messages contained in deliveredMessages.
1:9ce91fa:      * Caller should hold the lock for deliveredMessages.
1:88f6058:      *
1:88f6058:      * @param type Ack-Type (i.e. MessageAck.STANDARD_ACK_TYPE)
1:9ce91fa:      * @return <code>null</code> if nothing to ack.
1:9ce91fa:      */
1:88f6058:     private MessageAck makeAckForAllDeliveredMessages(byte type) {
1:862cd71:         synchronized (deliveredMessages) {
1:c38a61d:             if (deliveredMessages.isEmpty()) {
1:88f6058:                 return null;
1:c38a61d:             }
1:c02acbd: 
1:88f6058:             MessageDispatch md = deliveredMessages.getFirst();
1:88f6058:             MessageAck ack = new MessageAck(md, type, deliveredMessages.size());
1:88f6058:             ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());
1:88f6058:             return ack;
1:88f6058:         }
1:88f6058:     }
1:3d5a758: 
1:d29ca2a:     private void ackLater(MessageDispatch md, byte ackType) throws JMSException {
1:88f6058: 
1:d29ca2a:         // Don't acknowledge now, but we may need to let the broker know the
1:e45bb06:         // consumer got the message to expand the pre-fetch window
1:4046599:         if (session.getTransacted()) {
1:2030097:             registerSync();
1:a2101b7:         }
1:88f6058: 
1:d29ca2a:         deliveredCounter++;
1:6bfa13b: 
1:c02bc64:         synchronized(deliveredMessages) {
1:c02bc64:             MessageAck oldPendingAck = pendingAck;
1:c02bc64:             pendingAck = new MessageAck(md, ackType, deliveredCounter);
1:c02bc64:             pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
1:c02bc64:             if( oldPendingAck==null ) {
1:c02bc64:                 pendingAck.setFirstMessageId(pendingAck.getLastMessageId());
1:c02bc64:             } else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {
1:c02bc64:                 pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());
1:62daac4:             } else {
1:c02bc64:                 // old pending ack being superseded by ack of another type, if is is not a delivered
1:c02bc64:                 // ack and hence important, send it now so it is not lost.
1:c38a61d:                 if (!oldPendingAck.isDeliveredAck()) {
1:c38a61d:                     LOG.debug("Sending old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:c02bc64:                     session.sendAck(oldPendingAck);
1:c02bc64:                 } else {
1:c38a61d:                     LOG.debug("dropping old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:c02bc64:                 }
1:e45bb06:             }
1:c02bc64:             // AMQ-3956 evaluate both expired and normal msgs as
1:c02bc64:             // otherwise consumer may get stalled
1:c02bc64:             if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter + ackCounter - additionalWindowSize)) {
1:c38a61d:                 LOG.debug("ackLater: sending: {}", pendingAck);
1:c02bc64:                 session.sendAck(pendingAck);
1:c02bc64:                 pendingAck=null;
1:c02bc64:                 deliveredCounter = 0;
1:c02bc64:                 additionalWindowSize = 0;
1:c02bc64:             }
1:e45bb06:         }
1:e45bb06:     }
1:e45bb06: 
1:2030097:     private void registerSync() throws JMSException {
1:2030097:         session.doStartTransaction();
1:2030097:         if (!synchronizationRegistered) {
1:2030097:             synchronizationRegistered = true;
1:2030097:             session.getTransactionContext().addSynchronization(new Synchronization() {
1:2030097:                 @Override
1:2030097:                 public void beforeEnd() throws Exception {
1:2030097:                     if (transactedIndividualAck) {
1:82c4ab8:                         clearDeliveredList();
1:2030097:                         waitForRedeliveries();
1:2030097:                         synchronized(deliveredMessages) {
1:2030097:                             rollbackOnFailedRecoveryRedelivery();
1:2030097:                         }
1:2030097:                     } else {
1:2030097:                         acknowledge();
1:2030097:                     }
1:2030097:                     synchronizationRegistered = false;
1:2030097:                 }
1:2030097: 
1:2030097:                 @Override
1:2030097:                 public void afterCommit() throws Exception {
1:2030097:                     commit();
1:2030097:                     synchronizationRegistered = false;
1:2030097:                 }
1:2030097: 
1:2030097:                 @Override
1:2030097:                 public void afterRollback() throws Exception {
1:2030097:                     rollback();
1:2030097:                     synchronizationRegistered = false;
1:2030097:                 }
1:2030097:             });
1:2030097:         }
1:2030097:     }
1:2030097: 
1:d29ca2a:     /**
1:132f662:      * Acknowledge all the messages that have been delivered to the client up to
1:d29ca2a:      * this point.
1:88f6058:      *
7:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void acknowledge() throws JMSException {
1:82c4ab8:         clearDeliveredList();
1:b836af8:         waitForRedeliveries();
1:9ce91fa:         synchronized(deliveredMessages) {
1:9ce91fa:             // Acknowledge all messages so far.
2:9ce91fa:             MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:c38a61d:             if (ack == null) {
1:88f6058:                 return; // no msgs
1:c38a61d:             }
1:88f6058: 
1:4046599:             if (session.getTransacted()) {
1:62daac4:                 rollbackOnFailedRecoveryRedelivery();
2:d29ca2a:                 session.doStartTransaction();
2:d29ca2a:                 ack.setTransactionId(session.getTransactionContext().getTransactionId());
1:c02acbd:             }
1:88f6058: 
1:6bfa13b:             pendingAck = null;
1:184761a:             session.sendAck(ack);
1:88f6058: 
2:d29ca2a:             // Adjust the counters
1:e45bb06:             deliveredCounter = Math.max(0, deliveredCounter - deliveredMessages.size());
2:d29ca2a:             additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
1:e45bb06: 
1:e45bb06:             if (!session.getTransacted()) {
1:184761a:                 deliveredMessages.clear();
1:e45bb06:             }
1:88f6058:         }
1:efdf8ce:     }
1:88f6058: 
1:b836af8:     private void waitForRedeliveries() {
1:b836af8:         if (failoverRedeliveryWaitPeriod > 0 && previouslyDeliveredMessages != null) {
1:b836af8:             long expiry = System.currentTimeMillis() + failoverRedeliveryWaitPeriod;
1:b836af8:             int numberNotReplayed;
1:b836af8:             do {
1:b836af8:                 numberNotReplayed = 0;
1:b836af8:                 synchronized(deliveredMessages) {
1:b836af8:                     if (previouslyDeliveredMessages != null) {
1:b836af8:                         for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:b836af8:                             if (!entry.getValue()) {
1:b836af8:                                 numberNotReplayed++;
1:82c4ab8:                             }
1:b836af8:                         }
1:b836af8:                     }
1:b836af8:                 }
1:b836af8:                 if (numberNotReplayed > 0) {
1:c38a61d:                     LOG.info("waiting for redelivery of {} in transaction: {}, to consumer: {}",
1:c38a61d:                              numberNotReplayed, this.getConsumerId(), previouslyDeliveredMessages.transactionId);
1:b836af8:                     try {
1:b836af8:                         Thread.sleep(Math.max(500, failoverRedeliveryWaitPeriod/4));
1:b836af8:                     } catch (InterruptedException outOfhere) {
1:b836af8:                         break;
1:b836af8:                     }
1:b836af8:                 }
1:5b1412d:             } while (numberNotReplayed > 0 && expiry - System.currentTimeMillis() < 0);
1:b836af8:         }
1:b836af8:     }
1:b836af8: 
1:62daac4:     /*
1:62daac4:      * called with deliveredMessages locked
1:62daac4:      */
1:62daac4:     private void rollbackOnFailedRecoveryRedelivery() throws JMSException {
1:62daac4:         if (previouslyDeliveredMessages != null) {
1:62daac4:             // if any previously delivered messages was not re-delivered, transaction is invalid and must rollback
1:62daac4:             // as messages have been dispatched else where.
1:62daac4:             int numberNotReplayed = 0;
1:62daac4:             for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:62daac4:                 if (!entry.getValue()) {
1:62daac4:                     numberNotReplayed++;
1:c38a61d:                     LOG.debug("previously delivered message has not been replayed in transaction: {}, messageId: {}",
1:c38a61d:                               previouslyDeliveredMessages.transactionId, entry.getKey());
1:b836af8:                 }
1:b836af8:             }
1:62daac4:             if (numberNotReplayed > 0) {
1:39d0717:                 String message = "rolling back transaction ("
1:39d0717:                     + previouslyDeliveredMessages.transactionId + ") post failover recovery. " + numberNotReplayed
1:62daac4:                     + " previously delivered message(s) not replayed to consumer: " + this.getConsumerId();
1:62daac4:                 LOG.warn(message);
1:39d0717:                 throw new TransactionRolledBackException(message);
1:62daac4:             }
1:62daac4:         }
1:62daac4:     }
1:62daac4: 
1:4ddb3e3:     void acknowledge(MessageDispatch md) throws JMSException {
1:8a75d96:         acknowledge(md, MessageAck.INDIVIDUAL_ACK_TYPE);
1:62daac4:     }
1:62daac4: 
1:8a75d96:     void acknowledge(MessageDispatch md, byte ackType) throws JMSException {
1:8a75d96:         MessageAck ack = new MessageAck(md, ackType, 1);
1:f10aab6:         if (ack.isExpiredAck()) {
1:f10aab6:             ack.setFirstMessageId(ack.getLastMessageId());
1:f10aab6:         }
1:c02acbd:         session.sendAck(ack);
1:4ddb3e3:         synchronized(deliveredMessages){
1:b997d25:             deliveredMessages.remove(md);
1:62daac4:         }
1:62daac4:     }
1:efdf8ce: 
1:d29ca2a:     public void commit() throws JMSException {
1:0bc545b:         synchronized (deliveredMessages) {
1:88f6058:             deliveredMessages.clear();
1:62daac4:             clearPreviouslyDelivered();
1:933eb2f:         }
1:80f5e0c:         redeliveryDelay = 0;
1:ecf89a6:     }
1:62daac4: 
1:230a86c:     public void rollback() throws JMSException {
1:82c4ab8:         clearDeliveredList();
1:862cd71:         synchronized (unconsumedMessages.getMutex()) {
1:230a86c:             if (optimizeAcknowledge) {
1:230a86c:                 // remove messages read but not acked at the broker yet through
1:230a86c:                 // optimizeAcknowledge
2:230a86c:                 if (!this.info.isBrowser()) {
1:3eb0610:                     synchronized(deliveredMessages) {
1:230a86c:                         for (int i = 0; (i < deliveredMessages.size()) && (i < ackCounter); i++) {
1:230a86c:                             // ensure we don't filter this as a duplicate
1:230a86c:                             MessageDispatch md = deliveredMessages.removeLast();
1:18adfef:                             session.connection.rollbackDuplicate(this, md.getMessage());
1:ecf89a6:                         }
1:ecf89a6:                     }
1:da5139c:                 }
1:d29ca2a:             }
1:caf7a7c:             synchronized(deliveredMessages) {
1:b836af8:                 rollbackPreviouslyDeliveredAndNotRedelivered();
1:ecf89a6:                 if (deliveredMessages.isEmpty()) {
1:b836af8:                     return;
1:d29ca2a:                 }
1:230a86c: 
1:c23f9e6:                 // use initial delay for first redelivery
1:c256dcf:                 MessageDispatch lastMd = deliveredMessages.getFirst();
1:4229aee:                 final int currentRedeliveryCount = lastMd.getMessage().getRedeliveryCounter();
1:4229aee:                 if (currentRedeliveryCount > 0) {
1:c23f9e6:                     redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);
1:c23f9e6:                 } else {
1:c23f9e6:                     redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
1:c256dcf:                 }
1:9ce91fa:                 MessageId firstMsgId = deliveredMessages.getLast().getMessage().getMessageId();
1:88f6058: 
1:4229aee:                 for (Iterator<MessageDispatch> iter = deliveredMessages.iterator(); iter.hasNext();) {
1:4229aee:                     MessageDispatch md = iter.next();
1:c256dcf:                     md.getMessage().onMessageRolledBack();
1:4229aee:                     // ensure we don't filter this as a duplicate
1:4229aee:                     session.connection.rollbackDuplicate(this, md.getMessage());
1:d29ca2a:                 }
1:88f6058: 
1:933eb2f:                 if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
1:c256dcf:                     && lastMd.getMessage().getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()) {
1:d29ca2a:                     // We need to NACK the messages so that they get sent to the
1:d29ca2a:                     // DLQ.
2:d29ca2a:                     // Acknowledge the last message.
1:88f6058: 
1:230a86c:                     MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());
1:88f6058:                     ack.setFirstMessageId(firstMsgId);
1:b6bca39:                     ack.setPoisonCause(new Throwable("Delivery[" + lastMd.getMessage().getRedeliveryCounter()  + "] exceeds redelivery policy limit:" + redeliveryPolicy
1:20f384c:                             + ", cause:" + lastMd.getRollbackCause(), lastMd.getRollbackCause()));
1:d8b5d5c:                     session.sendAck(ack,true);
1:80f5e0c:                     // Adjust the window size.
1:230a86c:                     additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
1:230a86c:                     redeliveryDelay = 0;
1:2aff82c: 
1:2aff82c:                     deliveredCounter -= deliveredMessages.size();
1:2aff82c:                     deliveredMessages.clear();
1:2aff82c: 
1:62daac4:                 } else {
1:88f6058: 
1:4229aee:                     // only redelivery_ack after first delivery
1:4229aee:                     if (currentRedeliveryCount > 0) {
1:4229aee:                         MessageAck ack = new MessageAck(lastMd, MessageAck.REDELIVERED_ACK_TYPE, deliveredMessages.size());
1:4229aee:                         ack.setFirstMessageId(firstMsgId);
1:4229aee:                         session.sendAck(ack,true);
1:4229aee:                     }
1:88f6058: 
1:d29ca2a:                     // stop the delivery of messages.
1:0b6bf7e:                     if (nonBlockingRedelivery) {
1:0b6bf7e:                         if (!unconsumedMessages.isClosed()) {
1:88f6058: 
1:0b6bf7e:                             final LinkedList<MessageDispatch> pendingRedeliveries =
1:0b6bf7e:                                 new LinkedList<MessageDispatch>(deliveredMessages);
1:88f6058: 
1:2aff82c:                             Collections.reverse(pendingRedeliveries);
1:2aff82c: 
1:2aff82c:                             deliveredCounter -= deliveredMessages.size();
1:2aff82c:                             deliveredMessages.clear();
1:2aff82c: 
1:0b6bf7e:                             // Start up the delivery again a little later.
1:97ae323:                             session.getScheduler().executeAfterDelay(new Runnable() {
1:2aff82c:                                 @Override
1:0b6bf7e:                                 public void run() {
1:0b6bf7e:                                     try {
1:0b6bf7e:                                         if (!unconsumedMessages.isClosed()) {
1:0b6bf7e:                                             for(MessageDispatch dispatch : pendingRedeliveries) {
1:0b6bf7e:                                                 session.dispatch(dispatch);
1:0b6bf7e:                                             }
1:0b6bf7e:                                         }
1:0b6bf7e:                                     } catch (Exception e) {
1:0b6bf7e:                                         session.connection.onAsyncException(e);
1:230a86c:                                     }
1:230a86c:                                 }
1:0b6bf7e:                             }, redeliveryDelay);
1:0b6bf7e:                         }
1:c256dcf: 
1:e45bb06:                     } else {
1:0b6bf7e:                         unconsumedMessages.stop();
1:0b6bf7e: 
1:0b6bf7e:                         for (MessageDispatch md : deliveredMessages) {
1:0b6bf7e:                             unconsumedMessages.enqueueFirst(md);
1:0b6bf7e:                         }
1:2aff82c: 
1:2aff82c:                         deliveredCounter -= deliveredMessages.size();
1:2aff82c:                         deliveredMessages.clear();
1:0b6bf7e: 
1:4229aee:                         if (redeliveryDelay > 0 && !unconsumedMessages.isClosed()) {
1:0b6bf7e:                             // Start up the delivery again a little later.
1:97ae323:                             session.getScheduler().executeAfterDelay(new Runnable() {
1:2aff82c:                                 @Override
1:0b6bf7e:                                 public void run() {
1:0b6bf7e:                                     try {
1:0b6bf7e:                                         if (started.get()) {
1:0b6bf7e:                                             start();
1:0b6bf7e:                                         }
1:0b6bf7e:                                     } catch (JMSException e) {
1:0b6bf7e:                                         session.connection.onAsyncException(e);
1:0b6bf7e:                                     }
1:0b6bf7e:                                 }
1:0b6bf7e:                             }, redeliveryDelay);
1:e45bb06:                         } else {
1:0b6bf7e:                             start();
1:0b6bf7e:                         }
1:0b6bf7e:                     }
1:da5139c:                 }
1:da5139c:             }
1:da5139c:         }
1:8e98b13:         if (messageListener.get() != null) {
1:230a86c:             session.redispatch(this, unconsumedMessages);
1:d29ca2a:         }
1:d29ca2a:     }
1:c256dcf: 
1:62daac4:     /*
1:b836af8:      * called with unconsumedMessages && deliveredMessages locked
1:b836af8:      * remove any message not re-delivered as they can't be replayed to this
1:b836af8:      * consumer on rollback
1:b836af8:      */
1:b836af8:     private void rollbackPreviouslyDeliveredAndNotRedelivered() {
1:b836af8:         if (previouslyDeliveredMessages != null) {
1:b836af8:             for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:b836af8:                 if (!entry.getValue()) {
1:c38a61d:                     LOG.trace("rollback non redelivered: {}" + entry.getKey());
1:b836af8:                     removeFromDeliveredMessages(entry.getKey());
1:b836af8:                 }
1:b836af8:             }
1:b836af8:             clearPreviouslyDelivered();
1:b836af8:         }
1:b836af8:     }
1:b836af8: 
1:b836af8:     /*
1:b836af8:      * called with deliveredMessages locked
1:b836af8:      */
1:b836af8:     private void removeFromDeliveredMessages(MessageId key) {
1:39d0717:         Iterator<MessageDispatch> iterator = deliveredMessages.iterator();
1:39d0717:         while (iterator.hasNext()) {
1:39d0717:             MessageDispatch candidate = iterator.next();
1:b836af8:             if (key.equals(candidate.getMessage().getMessageId())) {
1:b836af8:                 session.connection.rollbackDuplicate(this, candidate.getMessage());
1:b836af8:                 iterator.remove();
1:b836af8:                 break;
1:b836af8:             }
1:b836af8:         }
1:b836af8:     }
1:62daac4: 
1:b836af8:     /*
1:62daac4:      * called with deliveredMessages locked
1:62daac4:      */
1:62daac4:     private void clearPreviouslyDelivered() {
1:62daac4:         if (previouslyDeliveredMessages != null) {
1:62daac4:             previouslyDeliveredMessages.clear();
1:62daac4:             previouslyDeliveredMessages = null;
1:62daac4:         }
1:62daac4:     }
1:62daac4: 
1:1a5ad28:     @Override
1:230a86c:     public void dispatch(MessageDispatch md) {
1:76ac758:         MessageListener listener = this.messageListener.get();
1:230a86c:         try {
1:9e54516:             clearMessagesInProgress();
1:82c4ab8:             clearDeliveredList();
1:62eb5cf:             synchronized (unconsumedMessages.getMutex()) {
1:230a86c:                 if (!unconsumedMessages.isClosed()) {
1:74a7a8b:                     if (this.info.isBrowser() || !session.connection.isDuplicate(this, md.getMessage())) {
1:230a86c:                         if (listener != null && unconsumedMessages.isRunning()) {
1:fad1dd0:                             if (redeliveryExceeded(md)) {
1:b6bca39:                                 posionAck(md, "listener dispatch[" + md.getRedeliveryCounter() + "] to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
1:fad1dd0:                                 return;
1:fad1dd0:                             }
1:230a86c:                             ActiveMQMessage message = createActiveMQMessage(md);
1:3dfda80:                             beforeMessageIsConsumed(md);
1:230a86c:                             try {
1:642cc43:                                 boolean expired = isConsumerExpiryCheckEnabled() && message.isExpired();
1:230a86c:                                 if (!expired) {
1:230a86c:                                     listener.onMessage(message);
1:62daac4:                                 }
1:230a86c:                                 afterMessageIsConsumed(md, expired);
1:230a86c:                             } catch (RuntimeException e) {
1:c38a61d:                                 LOG.error("{} Exception while processing message: {}", getConsumerId(), md.getMessage().getMessageId(), e);
1:4a27b72:                                 md.setRollbackCause(e);
1:ec82141:                                 if (isAutoAcknowledgeBatch() || isAutoAcknowledgeEach() || session.isIndividualAcknowledge()) {
1:7f8c822:                                     // schedual redelivery and possible dlq processing
1:7f8c822:                                     rollback();
1:0b6bf7e:                                 } else {
1:4a27b72:                                     // Transacted or Client ack: Deliver the next message.
1:3dfda80:                                     afterMessageIsConsumed(md, false);
1:62daac4:                                 }
1:62daac4:                             }
1:efdf8ce:                         } else {
1:7f0ced9:                             if (!unconsumedMessages.isRunning()) {
1:7f0ced9:                                 // delayed redelivery, ensure it can be re delivered
1:7f0ced9:                                 session.connection.rollbackDuplicate(this, md.getMessage());
1:7f0ced9:                             }
1:a3a5a1a: 
1:a3a5a1a:                             if (md.getMessage() == null) {
1:a3a5a1a:                                 // End of browse or pull request timeout.
1:3dfda80:                                 unconsumedMessages.enqueue(md);
1:76ac758:                             } else {
1:a3a5a1a:                                 if (!consumeExpiredMessage(md)) {
1:a3a5a1a:                                     unconsumedMessages.enqueue(md);
1:a3a5a1a:                                     if (availableListener != null) {
1:a3a5a1a:                                         availableListener.onMessageAvailable(this);
1:a3a5a1a:                                     }
1:a3a5a1a:                                 } else {
1:a3a5a1a:                                     beforeMessageIsConsumed(md);
1:a3a5a1a:                                     afterMessageIsConsumed(md, true);
1:a3a5a1a: 
1:a3a5a1a:                                     // Pull consumer needs to check if pull timed out and send
1:a3a5a1a:                                     // a new pull command if not.
1:a3a5a1a:                                     if (info.getCurrentPrefetchSize() == 0) {
1:a3a5a1a:                                         unconsumedMessages.enqueue(null);
1:a3a5a1a:                                     }
1:a3a5a1a:                                 }
1:3dfda80:                             }
1:da5139c:                         }
1:3dfda80:                     } else {
1:c34851f:                         // deal with duplicate delivery
1:c34851f:                         ConsumerId consumerWithPendingTransaction;
1:c34851f:                         if (redeliveryExpectedInCurrentTransaction(md, true)) {
1:c34851f:                             LOG.debug("{} tracking transacted redelivery {}", getConsumerId(), md.getMessage());
1:c34851f:                             if (transactedIndividualAck) {
1:c34851f:                                 immediateIndividualTransactedAck(md);
1:230a86c:                             } else {
1:c34851f:                                 session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));
1:da5139c:                             }
1:c34851f:                         } else if ((consumerWithPendingTransaction = redeliveryPendingInCompetingTransaction(md)) != null) {
1:c34851f:                             LOG.warn("{} delivering duplicate {}, pending transaction completion on {} will rollback", getConsumerId(), md.getMessage(), consumerWithPendingTransaction);
1:c34851f:                             session.getConnection().rollbackDuplicate(this, md.getMessage());
1:c34851f:                             dispatch(md);
1:c34851f:                         } else {
1:c34851f:                             LOG.warn("{} suppressing duplicate delivery on connection, poison acking: {}", getConsumerId(), md);
1:c34851f:                             posionAck(md, "Suppressing duplicate delivery on connection, consumer " + getConsumerId());
1:da5139c:                         }
1:da5139c:                     }
1:da5139c:                 }
1:da5139c:             }
1:230a86c:             if (++dispatchedCount % 1000 == 0) {
1:230a86c:                 dispatchedCount = 0;
1:cbaa58b:                 Thread.yield();
1:da5139c:             }
1:230a86c:         } catch (Exception e) {
1:0acf545:             session.connection.onClientInternalException(e);
1:d86f77f:         }
1:d86f77f:     }
1:da5139c: 
1:c34851f:     private boolean redeliveryExpectedInCurrentTransaction(MessageDispatch md, boolean markReceipt) {
1:c34851f:         if (session.isTransacted()) {
1:c34851f:             synchronized (deliveredMessages) {
1:c34851f:                 if (previouslyDeliveredMessages != null) {
1:c34851f:                     if (previouslyDeliveredMessages.containsKey(md.getMessage().getMessageId())) {
1:c34851f:                         if (markReceipt) {
1:c34851f:                             previouslyDeliveredMessages.put(md.getMessage().getMessageId(), true);
1:c34851f:                         }
1:c34851f:                         return true;
1:c34851f:                     }
1:c34851f:                 }
1:c34851f:             }
1:c34851f:         }
1:c34851f:         return false;
1:c34851f:     }
1:c34851f: 
1:c34851f:     private ConsumerId redeliveryPendingInCompetingTransaction(MessageDispatch md) {
1:c34851f:         for (ActiveMQSession activeMQSession: session.connection.getSessions()) {
1:c34851f:             for (ActiveMQMessageConsumer activeMQMessageConsumer : activeMQSession.consumers) {
1:c34851f:                 if (activeMQMessageConsumer.redeliveryExpectedInCurrentTransaction(md, false)) {
1:c34851f:                     return activeMQMessageConsumer.getConsumerId();
1:c34851f:                 }
1:c34851f:             }
1:c34851f:         }
1:c34851f:         return null;
1:c34851f:     }
1:c34851f: 
1:b836af8:     // async (on next call) clear or track delivered as they may be flagged as duplicates if they arrive again
1:82c4ab8:     private void clearDeliveredList() {
1:82c4ab8:         if (clearDeliveredList) {
1:83df5ce:             synchronized (deliveredMessages) {
1:82c4ab8:                 if (clearDeliveredList) {
1:184761a:                     if (!deliveredMessages.isEmpty()) {
1:62daac4:                         if (session.isTransacted()) {
1:82c4ab8: 
1:62daac4:                             if (previouslyDeliveredMessages == null) {
1:39d0717:                                 previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());
1:82c4ab8:                             }
1:62daac4:                             for (MessageDispatch delivered : deliveredMessages) {
1:62daac4:                                 previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);
1:82c4ab8:                             }
1:c38a61d:                             LOG.debug("{} tracking existing transacted {} delivered list ({}) on transport interrupt",
1:c38a61d:                                       getConsumerId(), previouslyDeliveredMessages.transactionId, deliveredMessages.size());
1:b836af8:                         } else {
1:82c4ab8:                             if (session.isClientAcknowledge()) {
1:c38a61d:                                 LOG.debug("{} rolling back delivered list ({}) on transport interrupt", getConsumerId(), deliveredMessages.size());
1:82c4ab8:                                 // allow redelivery
1:82c4ab8:                                 if (!this.info.isBrowser()) {
1:82c4ab8:                                     for (MessageDispatch md: deliveredMessages) {
1:82c4ab8:                                         this.session.connection.rollbackDuplicate(this, md.getMessage());
1:82c4ab8:                                     }
1:82c4ab8:                                 }
1:82c4ab8:                             }
1:c38a61d:                             LOG.debug("{} clearing delivered list ({}) on transport interrupt", getConsumerId(), deliveredMessages.size());
1:62daac4:                             deliveredMessages.clear();
1:62daac4:                             pendingAck = null;
1:b836af8:                         }
1:62daac4:                     }
1:82c4ab8:                     clearDeliveredList = false;
1:62daac4:                 }
1:62daac4:             }
1:62daac4:         }
1:62daac4:     }
1:80f5e0c: 
1:d29ca2a:     public int getMessageSize() {
1:d29ca2a:         return unconsumedMessages.size();
1:62daac4:     }
1:d29ca2a: 
1:d29ca2a:     public void start() throws JMSException {
1:230a86c:         if (unconsumedMessages.isClosed()) {
1:230a86c:             return;
1:9f548bb:         }
1:d29ca2a:         started.set(true);
1:d29ca2a:         unconsumedMessages.start();
1:da5139c:         session.executor.wakeup();
1:da5139c:     }
1:d29ca2a: 
1:d29ca2a:     public void stop() {
1:d29ca2a:         started.set(false);
2:d29ca2a:         unconsumedMessages.stop();
1:da5139c:     }
1:d29ca2a: 
3:1a5ad28:     @Override
1:d29ca2a:     public String toString() {
1:933eb2f:         return "ActiveMQMessageConsumer { value=" + info.getConsumerId() + ", started=" + started.get()
1:933eb2f:                + " }";
1:230a86c:     }
1:d29ca2a: 
1:f0454b1:     /**
1:da5139c:      * Delivers a message to the message listener.
1:88f6058:      *
1:61b2f6b:      * @return true if another execution is needed.
1:61b2f6b:      *
1:d29ca2a:      * @throws JMSException
1:6e3a634:      */
1:230a86c:     public boolean iterate() {
1:76ac758:         MessageListener listener = this.messageListener.get();
1:d29ca2a:         if (listener != null) {
1:230a86c:             MessageDispatch md = unconsumedMessages.dequeueNoWait();
1:230a86c:             if (md != null) {
1:7f8c822:                 dispatch(md);
1:230a86c:                 return true;
1:230a86c:             }
1:230a86c:         }
1:c38a61d:         return false;
1:230a86c:     }
1:230a86c: 
1:230a86c:     public boolean isInUse(ActiveMQTempDestination destination) {
1:230a86c:         return info.getDestination().equals(destination);
1:230a86c:     }
1:da5139c: 
1:3b08860:     public long getLastDeliveredSequenceId() {
1:3b08860:         return lastDeliveredSequenceId;
1:e45bb06:     }
1:e45bb06: 
1:88f6058:     public IOException getFailureError() {
1:88f6058:         return failureError;
1:3b08860:     }
1:3b08860: 
1:88f6058:     public void setFailureError(IOException failureError) {
1:88f6058:         this.failureError = failureError;
1:3d5a758:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * @return the optimizedAckScheduledAckInterval
1:3d5a758:      */
1:3d5a758:     public long getOptimizedAckScheduledAckInterval() {
1:3d5a758:         return optimizedAckScheduledAckInterval;
1:3d5a758:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * @param optimizedAckScheduledAckInterval the optimizedAckScheduledAckInterval to set
1:3d5a758:      */
1:3d5a758:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) throws JMSException {
1:3d5a758:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1:3d5a758: 
1:3d5a758:         if (this.optimizedAckTask != null) {
1:3d5a758:             try {
1:3d5a758:                 this.session.connection.getScheduler().cancel(optimizedAckTask);
1:3d5a758:             } catch (JMSException e) {
1:3d5a758:                 LOG.debug("Caught exception while cancelling old optimized ack task", e);
1:3d5a758:                 throw e;
1:3d5a758:             }
1:3d5a758:             this.optimizedAckTask = null;
1:3d5a758:         }
1:3d5a758: 
1:3d5a758:         // Should we periodically send out all outstanding acks.
1:3d5a758:         if (this.optimizeAcknowledge && this.optimizedAckScheduledAckInterval > 0) {
1:3d5a758:             this.optimizedAckTask = new Runnable() {
1:3d5a758: 
1:3d5a758:                 @Override
1:3d5a758:                 public void run() {
1:3d5a758:                     try {
1:3d5a758:                         if (optimizeAcknowledge && !unconsumedMessages.isClosed()) {
1:c38a61d:                             LOG.info("Consumer:{} is performing scheduled delivery of outstanding optimized Acks", info.getConsumerId());
1:3d5a758:                             deliverAcks();
1:3d5a758:                         }
1:3d5a758:                     } catch (Exception e) {
1:3d5a758:                         LOG.debug("Optimized Ack Task caught exception during ack", e);
1:3d5a758:                     }
1:3d5a758:                 }
1:3d5a758:             };
1:3d5a758: 
1:3d5a758:             try {
1:3d5a758:                 this.session.connection.getScheduler().executePeriodically(optimizedAckTask, optimizedAckScheduledAckInterval);
1:3d5a758:             } catch (JMSException e) {
1:3d5a758:                 LOG.debug("Caught exception while scheduling new optimized ack task", e);
1:3d5a758:                 throw e;
1:3d5a758:             }
1:3d5a758:         }
1:3d5a758:     }
1:f8ef7ff: 
1:dc0291b:     public boolean hasMessageListener() {
1:dc0291b:         return messageListener.get() != null;
1:dc0291b:     }
1:642cc43: 
1:642cc43:     public boolean isConsumerExpiryCheckEnabled() {
1:642cc43:         return consumerExpiryCheckEnabled;
1:642cc43:     }
1:642cc43: 
1:642cc43:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:642cc43:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:642cc43:     }
1:88f6058: }
============================================================================
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:             } while (numberNotReplayed > 0 && expiry - System.currentTimeMillis() < 0);
author:gtully
-------------------------------------------------------------------------------
commit:b6bca39
/////////////////////////////////////////////////////////////////////////
1:                     posionAck(md, "Dispatch[" + md.getRedeliveryCounter() + "] to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
/////////////////////////////////////////////////////////////////////////
1:                     && redeliveryPolicy.isPreDispatchCheck()
/////////////////////////////////////////////////////////////////////////
1:                     ack.setPoisonCause(new Throwable("Delivery[" + lastMd.getMessage().getRedeliveryCounter()  + "] exceeds redelivery policy limit:" + redeliveryPolicy
/////////////////////////////////////////////////////////////////////////
1:                                 posionAck(md, "listener dispatch[" + md.getRedeliveryCounter() + "] to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
commit:e91f5c8
/////////////////////////////////////////////////////////////////////////
1:                     checkClosed();
/////////////////////////////////////////////////////////////////////////
1:                     checkClosed();
commit:c78eddc
/////////////////////////////////////////////////////////////////////////
1:         session.sendAck(ack);
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
commit:8d98247
/////////////////////////////////////////////////////////////////////////
1:         // force a rollback if we will be acking in a transaction after/during failover
1:         // bc acks are async they may not get there reliably on reconnect and the consumer
1:         // may not be aware of the reconnect in a timely fashion if in onMessage
1:         if (!deliveredMessages.isEmpty() && session.getTransactionContext().isInTransaction()) {
1:             session.getTransactionContext().setRollbackOnly(true);
1:         }
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
1:     private long lastDeliveredSequenceId = -1;
commit:bbb2acc
/////////////////////////////////////////////////////////////////////////
1:         this.transactedIndividualAck = session.connection.isTransactedIndividualAck()
1:                         || this.nonBlockingRedelivery
1:                         || session.connection.isMessagePrioritySupported();
commit:c34851f
/////////////////////////////////////////////////////////////////////////
1:                         // deal with duplicate delivery
1:                         ConsumerId consumerWithPendingTransaction;
1:                         if (redeliveryExpectedInCurrentTransaction(md, true)) {
1:                                 LOG.debug("{} tracking transacted redelivery {}", getConsumerId(), md.getMessage());
1:                             if (transactedIndividualAck) {
1:                                 immediateIndividualTransactedAck(md);
1:                                 session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));
1:                         } else if ((consumerWithPendingTransaction = redeliveryPendingInCompetingTransaction(md)) != null) {
1:                             LOG.warn("{} delivering duplicate {}, pending transaction completion on {} will rollback", getConsumerId(), md.getMessage(), consumerWithPendingTransaction);
1:                             session.getConnection().rollbackDuplicate(this, md.getMessage());
1:                             dispatch(md);
1:                         } else {
1:                             LOG.warn("{} suppressing duplicate delivery on connection, poison acking: {}", getConsumerId(), md);
1:                             posionAck(md, "Suppressing duplicate delivery on connection, consumer " + getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:     private boolean redeliveryExpectedInCurrentTransaction(MessageDispatch md, boolean markReceipt) {
1:         if (session.isTransacted()) {
1:             synchronized (deliveredMessages) {
1:                 if (previouslyDeliveredMessages != null) {
1:                     if (previouslyDeliveredMessages.containsKey(md.getMessage().getMessageId())) {
1:                         if (markReceipt) {
1:                             previouslyDeliveredMessages.put(md.getMessage().getMessageId(), true);
1:                         }
1:                         return true;
1:                     }
1:                 }
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     private ConsumerId redeliveryPendingInCompetingTransaction(MessageDispatch md) {
1:         for (ActiveMQSession activeMQSession: session.connection.getSessions()) {
1:             for (ActiveMQMessageConsumer activeMQMessageConsumer : activeMQSession.consumers) {
1:                 if (activeMQMessageConsumer.redeliveryExpectedInCurrentTransaction(md, false)) {
1:                     return activeMQMessageConsumer.getConsumerId();
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
commit:f70dc74
/////////////////////////////////////////////////////////////////////////
1:             return session.getTransacted()
1:                     && redeliveryPolicy != null
1:         } catch (Exception ignored) {
commit:fad1dd0
/////////////////////////////////////////////////////////////////////////
1:                 } else if (redeliveryExceeded(md)) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(getConsumerId() + " received with excessive redelivered: " + md);
1:                     }
0:                     posionAck(md, "dispatch to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
/////////////////////////////////////////////////////////////////////////
1:     private void posionAck(MessageDispatch md, String cause) throws JMSException {
1:         MessageAck posionAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:         posionAck.setFirstMessageId(md.getMessage().getMessageId());
1:         posionAck.setPoisonCause(new Throwable(cause));
1:         session.sendAck(posionAck);
1:     }
1: 
1:     private boolean redeliveryExceeded(MessageDispatch md) {
1:         try {
0:             return redeliveryPolicy != null
1:                     && redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
1:                     && md.getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()
1:                     // redeliveryCounter > x expected after resend via brokerRedeliveryPlugin
1:                     && md.getMessage().getProperty("redeliveryDelay") == null;
0:         } catch (IOException ignored) {
1:             return false;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                             if (redeliveryExceeded(md)) {
0:                                 posionAck(md, "dispatch to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);
1:                                 return;
1:                             }
/////////////////////////////////////////////////////////////////////////
0:                             posionAck(md, "Duplicate non transacted delivery to " + getConsumerId());
/////////////////////////////////////////////////////////////////////////
0:                                         + failoverRedeliveryWaitPeriod + ". Message: " + md);
0:                                 posionAck(md, "Duplicate dispatch with transacted redeliver pending on another consumer, connection: "
0:                                         + session.getConnection().getConnectionInfo().getConnectionId());
commit:b136df1
/////////////////////////////////////////////////////////////////////////
1:             acknowledge(md, MessageAck.EXPIRED_ACK_TYPE);
commit:dc0291b
/////////////////////////////////////////////////////////////////////////
0:         // throw InterruptedException and we ensure that resources are cleaned up.
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean hasMessageListener() {
1:         return messageListener.get() != null;
1:     }
commit:c387522
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("on close, rollback duplicate: " + old.getMessage().getMessageId());
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:a3a5a1a
/////////////////////////////////////////////////////////////////////////
1:         return isConsumerExpiryCheckEnabled() && dispatch.getMessage().isExpired();
/////////////////////////////////////////////////////////////////////////
1: 
1:                             if (md.getMessage() == null) {
1:                                 // End of browse or pull request timeout.
1:                                 if (!consumeExpiredMessage(md)) {
1:                                     unconsumedMessages.enqueue(md);
1:                                     if (availableListener != null) {
1:                                         availableListener.onMessageAvailable(this);
1:                                     }
1:                                 } else {
1:                                     beforeMessageIsConsumed(md);
1:                                     afterMessageIsConsumed(md, true);
1: 
1:                                     // Pull consumer needs to check if pull timed out and send
1:                                     // a new pull command if not.
1:                                     if (info.getCurrentPrefetchSize() == 0) {
1:                                         unconsumedMessages.enqueue(null);
1:                                     }
1:                                 }
commit:aaecdff
/////////////////////////////////////////////////////////////////////////
1:                     if (old.getMessage() != null) {
1:                         LOG.debug("on close, rollback duplicate: {}", old.getMessage().getMessageId());
1:                     }
commit:9287055
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQBlobMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQObjectMessage;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.CommandTypes;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
1:         if (this.redeliveryPolicy == null) {
1:             this.redeliveryPolicy = new RedeliveryPolicy();
1:         }
commit:4a27b72
/////////////////////////////////////////////////////////////////////////
1:                                 md.setRollbackCause(e);
1:                                     // Transacted or Client ack: Deliver the next message.
commit:61b2f6b
/////////////////////////////////////////////////////////////////////////
1:      *      the MessageDispatch that arrived from the Broker.
1:      *
1:      * @return an ActiveMQMessage initialized from the Message in the dispatch.
/////////////////////////////////////////////////////////////////////////
1:      * @return true if another execution is needed.
1:      *
commit:3348ade
/////////////////////////////////////////////////////////////////////////
1:                     sendPullCommand(timeout);
commit:b84413a
/////////////////////////////////////////////////////////////////////////
1:                     if (timeout > 0) {
1:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
1:                     }
1:                     sendPullCommand(timeout);
commit:b9b27b9
/////////////////////////////////////////////////////////////////////////
1:             if (session.isClientAcknowledge() || session.isIndividualAcknowledge()) {
commit:c38a61d
/////////////////////////////////////////////////////////////////////////
1:                 } else if (consumeExpiredMessage(md)) {
1:                     LOG.debug("{} received expired message: {}", getConsumerId(), md);
1:                     LOG.debug("{} received with excessive redelivered: {}", getConsumerId(), md);
/////////////////////////////////////////////////////////////////////////
1:     private boolean consumeExpiredMessage(MessageDispatch dispatch) {
0:         if (dispatch.getMessage().isExpired()) {
0:             return !isBrowser() && isConsumerExpiryCheckEnabled();
1:         }
1: 
1:         return false;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("remove: {}, lastDeliveredSequenceId: {}", getConsumerId(), lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("{} clearing unconsumed list ({}) on transport interrupt", getConsumerId(), unconsumedMessages.size());
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("on close, rollback duplicate: {}", old.getMessage().getMessageId());
/////////////////////////////////////////////////////////////////////////
1:             if (deliveredMessages.isEmpty()) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (!oldPendingAck.isDeliveredAck()) {
1:                 LOG.debug("Sending old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:                 LOG.debug("dropping old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:             LOG.debug("ackLater: sending: {}", pendingAck);
/////////////////////////////////////////////////////////////////////////
1:             if (ack == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("waiting for redelivery of {} in transaction: {}, to consumer: {}",
1:                              numberNotReplayed, this.getConsumerId(), previouslyDeliveredMessages.transactionId);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("previously delivered message has not been replayed in transaction: {}, messageId: {}",
1:                               previouslyDeliveredMessages.transactionId, entry.getKey());
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("rollback non redelivered: {}" + entry.getKey());
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.error("{} Exception while processing message: {}", getConsumerId(), md.getMessage().getMessageId(), e);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("{} tracking transacted redelivery {}", getConsumerId(), md.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("{} tracking existing transacted {} delivered list ({}) on transport interrupt",
1:                                       getConsumerId(), previouslyDeliveredMessages.transactionId, deliveredMessages.size());
1:                                 LOG.debug("{} rolling back delivered list ({}) on transport interrupt", getConsumerId(), deliveredMessages.size());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("{} clearing delivered list ({}) on transport interrupt", getConsumerId(), deliveredMessages.size());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.info("Consumer:{} is performing scheduled delivery of outstanding optimized Acks", info.getConsumerId());
commit:642cc43
/////////////////////////////////////////////////////////////////////////
1:     private boolean consumerExpiryCheckEnabled = true;
/////////////////////////////////////////////////////////////////////////
1:         this.consumerExpiryCheckEnabled = session.connection.isConsumerExpiryCheckEnabled();
/////////////////////////////////////////////////////////////////////////
0:                 } else if (isConsumerExpiryCheckEnabled() && md.getMessage().isExpired()) {
/////////////////////////////////////////////////////////////////////////
1:                                 boolean expired = isConsumerExpiryCheckEnabled() && message.isExpired();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isConsumerExpiryCheckEnabled() {
1:         return consumerExpiryCheckEnabled;
1:     }
1: 
1:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:     }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:c02bc64
/////////////////////////////////////////////////////////////////////////
1:             synchronized(deliveredMessages) {
1:                 if (isAutoAcknowledgeEach()) {
/////////////////////////////////////////////////////////////////////////
1:                 } else if (pendingAck != null && pendingAck.isStandardAck()) {
1:                     ack = pendingAck;
1:                     pendingAck = null;
/////////////////////////////////////////////////////////////////////////
1:         synchronized(deliveredMessages) {
1:             MessageAck oldPendingAck = pendingAck;
1:             pendingAck = new MessageAck(md, ackType, deliveredCounter);
1:             pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
1:             if( oldPendingAck==null ) {
1:                 pendingAck.setFirstMessageId(pendingAck.getLastMessageId());
1:             } else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {
1:                 pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());
1:                 // old pending ack being superseded by ack of another type, if is is not a delivered
1:                 // ack and hence important, send it now so it is not lost.
0:                 if (!oldPendingAck.isDeliveredAck()) {
0:                     LOG.debug("Sending old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:                     session.sendAck(oldPendingAck);
1:                 } else {
0:                     LOG.debug("dropping old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
1:                 }
1:             // AMQ-3956 evaluate both expired and normal msgs as
1:             // otherwise consumer may get stalled
1:             if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter + ackCounter - additionalWindowSize)) {
0:                 LOG.debug("ackLater: sending: {}", pendingAck);
1:                 session.sendAck(pendingAck);
1:                 pendingAck=null;
1:                 deliveredCounter = 0;
1:                 additionalWindowSize = 0;
1:             }
commit:3856c39
/////////////////////////////////////////////////////////////////////////
1:     private MessageAck pendingAck;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         ack = pendingAck;
0:             } else if (pendingAck != null && pendingAck.isStandardAck()) {
1:                 ack = pendingAck;
/////////////////////////////////////////////////////////////////////////
1:                                     if (pendingAck != null && deliveredCounter > 0) {
1:                                         session.sendAck(pendingAck);
/////////////////////////////////////////////////////////////////////////
0:         MessageAck oldPendingAck = pendingAck;
0:         pendingAck = new MessageAck(md, ackType, deliveredCounter);
0:         pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
0:         if( oldPendingAck==null ) {
0:             pendingAck.setFirstMessageId(pendingAck.getLastMessageId());
0:         } else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {
0:             pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());
0:                 LOG.debug("Sending old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
0:                 LOG.debug("dropping old pending ack {}, new pending: {}", oldPendingAck, pendingAck);
0:             LOG.debug("ackLater: sending: {}", pendingAck);
0:             session.sendAck(pendingAck);
0:             pendingAck=null;
commit:6bfa13b
/////////////////////////////////////////////////////////////////////////
0:     private volatile MessageAck pendingAck;
/////////////////////////////////////////////////////////////////////////
0:             //Capture the pendingAck reference in case the optimizeAcknowledge dispatch
0:             //thread mutates it
0:             final MessageAck oldPendingAck = pendingAck;
/////////////////////////////////////////////////////////////////////////
0:                         ack = oldPendingAck;
0:             } else if (oldPendingAck != null && oldPendingAck.isStandardAck()) {
0:                 ack = oldPendingAck;
/////////////////////////////////////////////////////////////////////////
0:                                     final MessageAck oldPendingAck = pendingAck;
0:                                     if (oldPendingAck != null && deliveredCounter > 0) {
0:                                         session.sendAck(oldPendingAck);
/////////////////////////////////////////////////////////////////////////
0:         final MessageAck oldPendingAck = pendingAck;
0:         final MessageAck newPendingAck = new MessageAck(md, ackType, deliveredCounter);
0:         newPendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
0:         if (oldPendingAck == null) {
0:             newPendingAck.setFirstMessageId(newPendingAck.getLastMessageId());
0:         } else if (oldPendingAck.getAckType() == newPendingAck.getAckType()) {
0:             newPendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());
0:                 LOG.debug("Sending old pending ack {}, new pending: {}", oldPendingAck, newPendingAck);
0:                 LOG.debug("dropping old pending ack {}, new pending: {}", oldPendingAck, newPendingAck);
0:         pendingAck = newPendingAck;
1: 
0:             LOG.debug("ackLater: sending: {}", newPendingAck);
0:             session.sendAck(newPendingAck);
1:             pendingAck = null;
commit:f10aab6
/////////////////////////////////////////////////////////////////////////
1:         if (ack.isExpiredAck()) {
1:             ack.setFirstMessageId(ack.getLastMessageId());
1:         }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:3dfda80
/////////////////////////////////////////////////////////////////////////
0:                             if (!(md.getMessage() != null && md.getMessage().isExpired())) {
1:                                 unconsumedMessages.enqueue(md);
0:                                 if (availableListener != null) {
0:                                     availableListener.onMessageAvailable(this);
1:                                 }
1:                             } else {
1:                                 beforeMessageIsConsumed(md);
1:                                 afterMessageIsConsumed(md, false);
commit:94446e5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:         if (m.getDataStructureType() == CommandTypes.ACTIVEMQ_OBJECT_MESSAGE) {
1:             ((ActiveMQObjectMessage)m).setTrustAllPackages(session.getConnection().isTrustAllPackages());
1:             ((ActiveMQObjectMessage)m).setTrustedPackages(session.getConnection().getTrustedPackages());
1:         }
author:Christopher L. Shannon
-------------------------------------------------------------------------------
commit:174dcbf
/////////////////////////////////////////////////////////////////////////
0:                 //AMQ-5340 - only check for expired if not a browser
0:                 } else if (!isBrowser() && isConsumerExpiryCheckEnabled() && md.getMessage().isExpired()) {
author:Gary Tully
-------------------------------------------------------------------------------
commit:82c4ab8
/////////////////////////////////////////////////////////////////////////
1:     protected final LinkedList<MessageDispatch> deliveredMessages = new LinkedList<MessageDispatch>();
/////////////////////////////////////////////////////////////////////////
1:     private boolean clearDeliveredList;
/////////////////////////////////////////////////////////////////////////
1:         clearDeliveredList = true;
/////////////////////////////////////////////////////////////////////////
1:         clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("on close, rollback: " + old.getMessage().getMessageId());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("ackLater: sending: " + pendingAck);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
1:         clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
1:         clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
1:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("rollback non redelivered: " + entry.getKey());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             clearDeliveredList();
/////////////////////////////////////////////////////////////////////////
0:                             LOG.warn("Duplicate non transacted dispatch to consumer: "  + getConsumerId() + ", poison acking: " + md);
0:                             MessageAck poisonAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
0:                             poisonAck.setFirstMessageId(md.getMessage().getMessageId());
0:                             poisonAck.setPoisonCause(new Throwable("Duplicate non transacted delivery to " + getConsumerId()));
0:                             session.sendAck(poisonAck);
/////////////////////////////////////////////////////////////////////////
1:     private void clearDeliveredList() {
1:         if (clearDeliveredList) {
1:                 if (clearDeliveredList) {
1: 
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(getConsumerId() + " tracking existing transacted " + previouslyDeliveredMessages.transactionId +
0:                                         " delivered list (" + deliveredMessages.size() + ") on transport interrupt");
1:                             }
1:                             if (session.isClientAcknowledge()) {
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug(getConsumerId() + " rolling back delivered list (" + deliveredMessages.size() + ") on transport interrupt");
1:                                 }
1:                                 // allow redelivery
1:                                 if (!this.info.isBrowser()) {
1:                                     for (MessageDispatch md: deliveredMessages) {
1:                                         this.session.connection.rollbackDuplicate(this, md.getMessage());
1:                                     }
1:                                 }
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                     clearDeliveredList = false;
commit:13bbe52
/////////////////////////////////////////////////////////////////////////
0:         clearDispatchList();
commit:20f384c
/////////////////////////////////////////////////////////////////////////
0:                     ack.setPoisonCause(new Throwable("Exceeded redelivery policy limit:" + redeliveryPolicy
1:                             + ", cause:" + lastMd.getRollbackCause(), lastMd.getRollbackCause()));
commit:a971b64
/////////////////////////////////////////////////////////////////////////
0:                     ack.setPoisonCause(new Throwable("Exceeded redelivery policy limit:" + redeliveryPolicy));
commit:bac1243
/////////////////////////////////////////////////////////////////////////
0:                                     session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));
commit:95e6d60
/////////////////////////////////////////////////////////////////////////
1:         if (info.getCurrentPrefetchSize() == 0 && unconsumedMessages.isEmpty()) {
commit:dc258ab
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:     AtomicInteger inProgressClearRequiredFlag = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
1:         inProgressClearRequiredFlag.incrementAndGet();
1:         if (inProgressClearRequiredFlag.get() > 0) {
1:                 if (inProgressClearRequiredFlag.get() > 0) {
/////////////////////////////////////////////////////////////////////////
1:                     inProgressClearRequiredFlag.decrementAndGet();
commit:9ee2967
/////////////////////////////////////////////////////////////////////////
0:         session.syncSendPacket(ack);
commit:6778a49
/////////////////////////////////////////////////////////////////////////
0:                             LOG.warn("Duplicate dispatch on connection: " + session.getConnection().getConnectionInfo().getConnectionId()
0:                                     + " to consumer: "  + getConsumerId() + ", ignoring (auto acking) duplicate: " + md);
1:                             MessageAck ack = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
/////////////////////////////////////////////////////////////////////////
0:                                 poisonAck.setPoisonCause(new JMSException("Duplicate dispatch with transacted redeliver pending on another consumer, connection: "
0:                                         + session.getConnection().getConnectionInfo().getConnectionId()));
0:                                 LOG.warn("acking duplicate delivery as poison, redelivery must be pending to another"
0:                                         + " consumer on this connection, failoverRedeliveryWaitPeriod="
0:                                         + failoverRedeliveryWaitPeriod + ". Message: " + md + ", poisonAck: " + poisonAck);
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:     private boolean transactedIndividualAck = false;
/////////////////////////////////////////////////////////////////////////
0:         this.transactedIndividualAck = session.connection.isTransactedIndividualAck();
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(getConsumerId() + " clearing unconsumed list (" + unconsumedMessages.size() + ") on transport interrupt");
/////////////////////////////////////////////////////////////////////////
1:                 if (transactedIndividualAck) {
1:                     immediateIndividualTransactedAck(md);
1:                 } else {
1:                     ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:                 }
1: 
1:     private void immediateIndividualTransactedAck(MessageDispatch md) throws JMSException {
1:         // acks accumulate on the broker pending transaction completion to indicate
1:         // delivery status
1:         registerSync();
0:         MessageAck ack = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
1:         ack.setTransactionId(session.getTransactionContext().getTransactionId());
1:         session.sendAck(ack);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             registerSync();
/////////////////////////////////////////////////////////////////////////
1:     private void registerSync() throws JMSException {
1:         session.doStartTransaction();
1:         if (!synchronizationRegistered) {
1:             synchronizationRegistered = true;
1:             session.getTransactionContext().addSynchronization(new Synchronization() {
1:                 @Override
1:                 public void beforeEnd() throws Exception {
1:                     if (transactedIndividualAck) {
0:                         clearDispatchList();
1:                         waitForRedeliveries();
1:                         synchronized(deliveredMessages) {
1:                             rollbackOnFailedRecoveryRedelivery();
1:                         }
1:                     } else {
1:                         acknowledge();
1:                     }
1:                     synchronizationRegistered = false;
1:                 }
1: 
1:                 @Override
1:                 public void afterCommit() throws Exception {
1:                     commit();
1:                     synchronizationRegistered = false;
1:                 }
1: 
1:                 @Override
1:                 public void afterRollback() throws Exception {
1:                     rollback();
1:                     synchronizationRegistered = false;
1:                 }
1:             });
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                                 if (transactedIndividualAck) {
0:                                     immediateIndividualTransactedAck(md);
1:                                 } else {
1:                                     ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:                                 }
commit:975fc55
/////////////////////////////////////////////////////////////////////////
1:     private long optimizeAcknowledgeTimeOut = 0;
/////////////////////////////////////////////////////////////////////////
1:         if (this.optimizeAcknowledge) {
1:             this.optimizeAcknowledgeTimeOut = session.connection.getOptimizeAcknowledgeTimeOut();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                                 if (ackCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
0:                     ack.setPoisonCause(lastMd.getRollbackCause());
/////////////////////////////////////////////////////////////////////////
0:                                     md.setRollbackCause(e);
commit:2d121f4
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug(getConsumerId() + " tracking transacted redelivery of duplicate: " + md.getMessage());
commit:c23f9e6
/////////////////////////////////////////////////////////////////////////
1:                 // use initial delay for first redelivery
1:                     redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);
1:                 } else {
1:                     redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
commit:383d12e
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("remove: " + this.getConsumerId() + ", lastDeliveredSequenceId:" + lastDeliveredSequenceId);
1:         }
commit:7f0ced9
/////////////////////////////////////////////////////////////////////////
1:                             if (!unconsumedMessages.isRunning()) {
1:                                 // delayed redelivery, ensure it can be re delivered
1:                                 session.connection.rollbackDuplicate(this, md.getMessage());
1:                             }
commit:18adfef
/////////////////////////////////////////////////////////////////////////
1:                             session.connection.rollbackDuplicate(this, md.getMessage());
commit:9e54516
/////////////////////////////////////////////////////////////////////////
0:     boolean inProgressClearRequiredFlag;
/////////////////////////////////////////////////////////////////////////
1:     void inProgressClearRequired() {
0:         inProgressClearRequiredFlag = true;
1:     }
1:     
1:     void clearMessagesInProgress() {
0:         if (inProgressClearRequiredFlag) {
1:             synchronized (unconsumedMessages.getMutex()) {
0:                 if (inProgressClearRequiredFlag) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(getConsumerId() + " clearing dispatched list (" + unconsumedMessages.size() + ") on transport interrupt");
1:                     }
1:                     // ensure unconsumed are rolledback up front as they may get redelivered to another consumer
1:                     List<MessageDispatch> list = unconsumedMessages.removeAll();
1:                     if (!this.info.isBrowser()) {
1:                         for (MessageDispatch old : list) {
1:                             session.connection.rollbackDuplicate(this, old.getMessage());
1:                         }
1:                     }
1:                     // allow dispatch on this connection to resume
1:                     session.connection.transportInterruptionProcessingComplete();
0:                     inProgressClearRequiredFlag = false;
/////////////////////////////////////////////////////////////////////////
1:             clearMessagesInProgress();
commit:7f8c822
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("remove: " + this.getConsumerId() + ", lasteDeliveredSequenceId:" + lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.error(getConsumerId() + " Exception while processing message: " + md.getMessage().getMessageId(), e);
1:                                     // schedual redelivery and possible dlq processing
1:                                     rollback();
/////////////////////////////////////////////////////////////////////////
1:                 dispatch(md);
commit:39d0717
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import javax.jms.IllegalStateException;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.TransactionRolledBackException;
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("serial")
1:     class PreviouslyDeliveredMap<K, V> extends HashMap<K, V> {
1:         final TransactionId transactionId;
1:         public PreviouslyDeliveredMap(TransactionId transactionId) {
1:             this.transactionId = transactionId;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private PreviouslyDeliveredMap<MessageId, Boolean> previouslyDeliveredMessages;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 md = dequeue(-1); // We let the broker let us know when we timeout.
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("waiting for redelivery of " + numberNotReplayed + " in transaction: "
0:                             + previouslyDeliveredMessages.transactionId +  ", to consumer :" + this.getConsumerId());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("previously delivered message has not been replayed in transaction: "
0:                                 + previouslyDeliveredMessages.transactionId 
0:                                 + " , messageId: " + entry.getKey());
1:                 String message = "rolling back transaction (" 
1:                     + previouslyDeliveredMessages.transactionId + ") post failover recovery. " + numberNotReplayed
1:                 throw new TransactionRolledBackException(message);   
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Iterator<MessageDispatch> iterator = deliveredMessages.iterator();
1:         while (iterator.hasNext()) {
1:             MessageDispatch candidate = iterator.next();
/////////////////////////////////////////////////////////////////////////
0:                                     // delivery while pending redelivery to another consumer on the same connection
0:                                     // not waiting for redelivery will help here
0:                                 LOG.warn("acking duplicate delivery as poison, redelivery must be pending to another"
0:                                         + " consumer on this connection, failoverRedeliveryWaitPeriod=" 
0:                                         + failoverRedeliveryWaitPeriod + ". Message: " + md);
/////////////////////////////////////////////////////////////////////////
1:                                 previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1:     // track duplicate deliveries in a transaction such that the tx integrity can be validated
/////////////////////////////////////////////////////////////////////////
1:     private long failoverRedeliveryWaitPeriod = 0;
0:     private boolean rollbackInitiated;
/////////////////////////////////////////////////////////////////////////
1:         this.failoverRedeliveryWaitPeriod = session.connection.getConsumerFailoverRedeliveryWaitPeriod();
/////////////////////////////////////////////////////////////////////////
1:         waitForRedeliveries();
/////////////////////////////////////////////////////////////////////////
1:     private void waitForRedeliveries() {
1:         if (failoverRedeliveryWaitPeriod > 0 && previouslyDeliveredMessages != null) {
1:             long expiry = System.currentTimeMillis() + failoverRedeliveryWaitPeriod;
1:             int numberNotReplayed;
1:             do {
1:                 numberNotReplayed = 0;
1:                 synchronized(deliveredMessages) {
1:                     if (previouslyDeliveredMessages != null) { 
1:                         for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:                             if (!entry.getValue()) {
1:                                 numberNotReplayed++;
1:                             }
1:                         }
1:                     }
1:                 }
1:                 if (numberNotReplayed > 0) {
0:                     LOG.info("waiting for redelivery of " + numberNotReplayed + " to consumer :" + this.getConsumerId());
1:                     try {
1:                         Thread.sleep(Math.max(500, failoverRedeliveryWaitPeriod/4));
1:                     } catch (InterruptedException outOfhere) {
1:                         break;
1:                     }
1:                 }
0:             } while (numberNotReplayed > 0 && expiry < System.currentTimeMillis());
1:         }
1:     }
1: 
0:             if (rollbackInitiated) {
0:                 // second call from rollback, nothing more to do
0:                 // REVISIT - should beforeEnd be called again by transaction context?
0:                 rollbackInitiated = false;
1:                 return;
1:             }
0:                 rollbackInitiated = true;
/////////////////////////////////////////////////////////////////////////
1:                 rollbackPreviouslyDeliveredAndNotRedelivered();
/////////////////////////////////////////////////////////////////////////
1:      * called with unconsumedMessages && deliveredMessages locked
1:      * remove any message not re-delivered as they can't be replayed to this 
1:      * consumer on rollback
1:      */
1:     private void rollbackPreviouslyDeliveredAndNotRedelivered() {
1:         if (previouslyDeliveredMessages != null) {
1:             for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:                 if (!entry.getValue()) {              
1:                     removeFromDeliveredMessages(entry.getKey());
1:                 }
1:             }
0:             rollbackInitiated = false;
1:             clearPreviouslyDelivered();
1:         }
1:     }
1: 
1:     /*
1:      * called with deliveredMessages locked
1:      */
1:     private void removeFromDeliveredMessages(MessageId key) {
0:         ListIterator<MessageDispatch> iterator = deliveredMessages.listIterator(deliveredMessages.size());
0:         while (iterator.hasPrevious()) {
0:             MessageDispatch candidate = iterator.previous();
1:             if (key.equals(candidate.getMessage().getMessageId())) {
1:                 session.connection.rollbackDuplicate(this, candidate.getMessage());
1:                 iterator.remove();
1:                 break;
1:             }
1:         }
1:     }
1:     /*
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug(getConsumerId() + " ignoring (auto acking) duplicate: " + md.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                             boolean needsPoisonAck = false;
1:                                 } else {
0:                                     // existing transaction gone but still a duplicate!, lets mark as poison ftm,
0:                                     // possibly could allow redelivery..
0:                                     needsPoisonAck = true;
0:                             if (needsPoisonAck) {
0:                                 LOG.warn("acking as poison, duplicate transacted delivery but no recovering transaction for: " + md);
0:                                 MessageAck poisonAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
0:                                 poisonAck.setFirstMessageId(md.getMessage().getMessageId());
0:                                 session.sendAck(poisonAck);
1:                             } else {
0:                                 ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:                             }
/////////////////////////////////////////////////////////////////////////
1:     // async (on next call) clear or track delivered as they may be flagged as duplicates if they arrive again
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug(getConsumerId() + " tracking existing transacted delivered list (" + deliveredMessages.size() + ") on transport interrupt");
commit:62daac4
/////////////////////////////////////////////////////////////////////////
0: import java.util.ListIterator;
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.TransactionRolledBackException;
/////////////////////////////////////////////////////////////////////////
0:     private HashMap<MessageId, Boolean> previouslyDeliveredMessages;
/////////////////////////////////////////////////////////////////////////
1:      * @param maximumPendingMessageCount
/////////////////////////////////////////////////////////////////////////
1:         // deal with delivered messages async to avoid lock contention with in progress acks
/////////////////////////////////////////////////////////////////////////
1:                 rollbackOnFailedRecoveryRedelivery();
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * called with deliveredMessages locked
1:      */
1:     private void rollbackOnFailedRecoveryRedelivery() throws JMSException {
1:         if (previouslyDeliveredMessages != null) {
1:             // if any previously delivered messages was not re-delivered, transaction is invalid and must rollback
1:             // as messages have been dispatched else where.
1:             int numberNotReplayed = 0;
1:             for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {
1:                 if (!entry.getValue()) {
1:                     numberNotReplayed++;
0:                     // allow outstanding messages to get delivered again
0:                     removeFromDeliveredMessages(entry.getKey());
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("previously delivered message has not been replayed in transaction, id: " + entry.getKey());
1:                     }
1:                 }
1:             }
1:             clearPreviouslyDelivered();
1:             
1:             if (numberNotReplayed > 0) {
0:                 String message = "rolling back transaction post failover recovery. " + numberNotReplayed
1:                     + " previously delivered message(s) not replayed to consumer: " + this.getConsumerId();
1:                 LOG.warn(message);
0:                 throw new TransactionRolledBackException(message);
1:             }
1:         }
1:         
1:     }
1: 
1:     /*
1:      * called with deliveredMessages locked
1:      */
0:     private void removeFromDeliveredMessages(MessageId key) {
0:         ListIterator<MessageDispatch> iterator = deliveredMessages.listIterator(deliveredMessages.size());
0:         while (iterator.hasPrevious()) {
0:             MessageDispatch candidate = iterator.previous();
0:             if (key.equals(candidate.getMessage().getMessageId())) {
0:                 session.connection.rollbackDuplicate(this, candidate.getMessage());
0:                 iterator.remove();
0:                 break;
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             clearPreviouslyDelivered();
/////////////////////////////////////////////////////////////////////////
0:                 clearPreviouslyDelivered();
/////////////////////////////////////////////////////////////////////////
0:     /*
0:      * called with deliveredMessages locked
1:      */
1:     private void clearPreviouslyDelivered() {
1:         if (previouslyDeliveredMessages != null) {
1:             previouslyDeliveredMessages.clear();
1:             previouslyDeliveredMessages = null;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         if (!session.isTransacted()) {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(getConsumerId() + " ignoring(auto acking) duplicate: " + md.getMessage());
1:                             }
0:                             MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
1:                             session.sendAck(ack);
1:                         } else {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(getConsumerId() + " tracking transacted redlivery of duplicate: " + md.getMessage());
1:                             }
1:                             synchronized (deliveredMessages) {
0:                                 if (previouslyDeliveredMessages != null) {
0:                                     previouslyDeliveredMessages.put(md.getMessage().getMessageId(), true);
1:                                 }
1:                             }
0:                             ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
1:             synchronized (deliveredMessages) {  
1:                     if (!deliveredMessages.isEmpty()) {
1:                         if (session.isTransacted()) {    
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(getConsumerId() + " tracking delivered list (" + deliveredMessages.size() + ") on transport interrupt");
1:                             }
1:                             if (previouslyDeliveredMessages == null) {
0:                                 previouslyDeliveredMessages = new HashMap<MessageId, Boolean>();
1:                             }
1:                             for (MessageDispatch delivered : deliveredMessages) {
1:                                 previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);
1:                             }
1:                         } else {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(getConsumerId() + " clearing delivered list (" + deliveredMessages.size() + ") on transport interrupt");
1:                             }
1:                             deliveredMessages.clear();
1:                             pendingAck = null;
1:                         }
1:                     }
commit:862cd71
/////////////////////////////////////////////////////////////////////////
0:     protected final MessageDispatchChannel unconsumedMessages = new MessageDispatchChannel();
/////////////////////////////////////////////////////////////////////////
0:         // deal with delivered messages async to avoid lock contention with in pogress acks
1:         synchronized (unconsumedMessages.getMutex()) {            
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(getConsumerId() + " clearing dispatched list (" + unconsumedMessages.size() + ") on transport interrupt");
1:             }
0:             // ensure unconsumed are rolledback up front as they may get redelivered to another consumer
1:             List<MessageDispatch> list = unconsumedMessages.removeAll();
1:             if (!this.info.isBrowser()) {
1:                 for (MessageDispatch old : list) {
1:                     session.connection.rollbackDuplicate(this, old.getMessage());
1:                 }
1:             }
1:         }
0:         // allow dispatch on this connection to resume
0:         session.connection.transportInterruptionProcessingComplete();
/////////////////////////////////////////////////////////////////////////
0:         clearDispatchList();
/////////////////////////////////////////////////////////////////////////
0:         clearDispatchList();
/////////////////////////////////////////////////////////////////////////
0:             clearDispatchList();
/////////////////////////////////////////////////////////////////////////
0:     // async (on next call) clear delivered as they will be auto-acked as duplicates if they arrive again
0:     private void clearDispatchList() {
1:             synchronized (deliveredMessages) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(getConsumerId() + " async clearing delivered list (" + deliveredMessages.size() + ") on transport interrupt");
1:                 }
0:                 if (clearDispatchList) {
1:                     deliveredMessages.clear();
1:                     pendingAck = null;
0:                     clearDispatchList = false;
commit:7ceb4cb
/////////////////////////////////////////////////////////////////////////
1:             unconsumedMessages.close();
1:             this.session.removeConsumer(this);
/////////////////////////////////////////////////////////////////////////
commit:62eb5cf
/////////////////////////////////////////////////////////////////////////
1:         synchronized (unconsumedMessages.getMutex()) {
0:             clearDispatchListOnReconnect();
1:         }
commit:0bc545b
/////////////////////////////////////////////////////////////////////////
0:         synchronized (unconsumedMessages.getMutex()) {
0:             clearDispatchListOnReconnect();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 clearDispatchListOnReconnect();
/////////////////////////////////////////////////////////////////////////
1:                         acknowledge(md);
/////////////////////////////////////////////////////////////////////////
0:     // called holding unconsumedMessages.getMutex()
0:     private void clearDispatchListOnReconnect() {
0:         if (clearDispatchList) {
0:             // we are reconnecting so lets flush the in progress
0:             // messages
0:             clearDispatchList = false;
0:             List<MessageDispatch> list = unconsumedMessages.removeAll();
1:             if (!this.info.isBrowser()) {
0:                 for (MessageDispatch old : list) {
1:                     // ensure we don't filter this as a duplicate
0:                     session.connection.rollbackDuplicate(this, old.getMessage());
1:                 }
1:             }
1:            
0:             // clean, so we don't have duplicates with optimizeAcknowledge 
1:             synchronized (deliveredMessages) {
1:                 deliveredMessages.clear();        
1:             }
1:             pendingAck = null;
1:         }
1:     }
1: 
commit:83df5ce
/////////////////////////////////////////////////////////////////////////
1:                 boolean messageUnackedByConsumer = false;
1:                 synchronized (deliveredMessages) {
1:                     messageUnackedByConsumer = deliveredMessages.contains(md);
1:                 }
1:                 if (messageUnackedByConsumer) {
0:                     ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:                 }
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
1:             		} else {
0:             		    ack = pendingAck;
0:             		    pendingAck = null;
commit:a707594
/////////////////////////////////////////////////////////////////////////
1:             deliveredCounter = 0;
0:             additionalWindowSize = 0;
commit:b997d25
/////////////////////////////////////////////////////////////////////////
0:             synchronized (deliveredMessages) {
1:                 deliveredMessages.remove(md);
1:             }
1:             stats.getExpiredMessageCount().increment();
0:             ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
commit:9f548bb
/////////////////////////////////////////////////////////////////////////
0:                     if (pendingAck != null && pendingAck.isDeliveredAck()) {
0:                         // on resumption a pending delivered ack will be out of sync with
0:                         // re deliveries.
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("removing pending delivered ack on transport interupt: " + pendingAck);
1:                         }   
0:                         pendingAck = null;
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug(getConsumerId() + " ignoring(auto acking) duplicate: " + md.getMessage());
0:                         if (session.isTransacted()) {
0:                             ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:                         } else {
0:                             acknowledge(md);
1:                         }
/////////////////////////////////////////////////////////////////////////
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isTraceEnabled()) {
1:                         LOG.trace(getConsumerId() + " received message: " + md);
/////////////////////////////////////////////////////////////////////////
1:                 synchronized(deliveredMessages) {
1:                     ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:                     if (ack != null) {
1:                         deliveredMessages.clear();
1:                         ackCounter = 0;
0:                 pendingAck = null;
1:                 
/////////////////////////////////////////////////////////////////////////
1:         // consumer got the message to expand the pre-fetch window
/////////////////////////////////////////////////////////////////////////
0:         pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
0:         } else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {
1:         } else {
0:             // old pending ack being superseded by ack of another type, if is is not a delivered
0:             // ack and hence important, send it now so it is not lost.
0:             if ( !oldPendingAck.isDeliveredAck()) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Sending old pending ack " + oldPendingAck + ", new pending: " + pendingAck);
1:                 }
0:                 session.sendAck(oldPendingAck);
1:             } else {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("dropping old pending ack " + oldPendingAck + ", new pending: " + pendingAck);
1:                 }
1:             }
1:         
/////////////////////////////////////////////////////////////////////////
1:             
1:             deliveredCounter = Math.max(0, deliveredCounter - deliveredMessages.size());
1:             
1:             if (!session.getTransacted()) {  
1:             } 
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug(getConsumerId() + " ignoring duplicate: " + md.getMessage());
0:                         // in a transaction ack delivery of duplicates to ensure prefetch extension kicks in.
0:                         // the normal ack will happen in the transaction.
0:                         ackLater(md, session.isTransacted() ? 
0:                                 MessageAck.DELIVERED_ACK_TYPE : MessageAck.STANDARD_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
0:     // on resumption re deliveries will percolate acks in their own good time
0:     public void transportResumed() {
0:         pendingAck = null; 
0:         additionalWindowSize = 0;
0:         deliveredCounter = 0;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:132f662
/////////////////////////////////////////////////////////////////////////
1:      * Acknowledge all the messages that have been delivered to the client up to
/////////////////////////////////////////////////////////////////////////
0:                         acknowledge(md);
commit:184761a
/////////////////////////////////////////////////////////////////////////
0:             if (session.isAutoAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (deliveryingAcknowledgements.compareAndSet(false, true)) {
0:                     synchronized (deliveredMessages) {
1:                         if (!deliveredMessages.isEmpty()) {
1:                             if (optimizeAcknowledge) {
0:                                 if (ackCounter >= (info.getCurrentPrefetchSize() * .65)) {
/////////////////////////////////////////////////////////////////////////
1:                             } else {
1:                                 MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:                                 if (ack!=null) {
1:                                     deliveredMessages.clear();
1:                                     session.sendAck(ack);
1:                                 }
1:                     deliveryingAcknowledgements.set(false);
commit:4046599
/////////////////////////////////////////////////////////////////////////
0:             if (session.getTransactionContext().isInTransaction()) {
/////////////////////////////////////////////////////////////////////////
1:             if (!session.getTransacted()) { 
/////////////////////////////////////////////////////////////////////////
1:             if (session.getTransacted()) {
/////////////////////////////////////////////////////////////////////////
1:             if (session.getTransacted()) {
/////////////////////////////////////////////////////////////////////////
1:         if (session.getTransacted()) {
/////////////////////////////////////////////////////////////////////////
1:             if (session.getTransacted()) {
/////////////////////////////////////////////////////////////////////////
0:             if (!session.getTransacted()) {
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
1:     // Always walk list in reverse order.
/////////////////////////////////////////////////////////////////////////
0:     private long lastDeliveredSequenceId;
/////////////////////////////////////////////////////////////////////////
1:         RemoveInfo removeCommand = info.createRemoveCommand();
1:         removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:         this.session.asyncSendPacket(removeCommand);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();
/////////////////////////////////////////////////////////////////////////
1:     public long getLastDeliveredSequenceId() {
1:         return lastDeliveredSequenceId;
1:     }
1: 
commit:50a98e3
/////////////////////////////////////////////////////////////////////////
0:             if (session.isTransacted() && session.getTransactionContext().getTransactionId() != null) {
1:                 session.getTransactionContext().addSynchronization(new Synchronization() {
1:                     public void afterCommit() throws Exception {
1:                         doClose();
1:                     }
1: 
1:                     public void afterRollback() throws Exception {
1:                         doClose();
1:                     }
1:                 });
1:             } else {
1:                 doClose();
1:             } 
1:     void doClose() throws JMSException {
1:         dispose();
0:         this.session.asyncSendPacket(info.createRemoveCommand());
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:             // Ack any delivered messages now.
0:             if (!session.isTransacted()) { 
1:                 deliverAcks();
0:                 if (session.isDupsOkAcknowledge()) {
1:                     acknowledge();
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:             
commit:4229aee
/////////////////////////////////////////////////////////////////////////
0:             if (!session.isTransacted()) {
1:                 synchronized(deliveredMessages) {
1:                     deliveredMessages.clear();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 // Only increase the redelivery delay after the first redelivery..
1:                 final int currentRedeliveryCount = lastMd.getMessage().getRedeliveryCounter();
1:                 if (currentRedeliveryCount > 0) {
1:                 for (Iterator<MessageDispatch> iter = deliveredMessages.iterator(); iter.hasNext();) {
1:                     MessageDispatch md = iter.next();
1:                     // ensure we don't filter this as a duplicate
1:                     session.connection.rollbackDuplicate(this, md.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                     // only redelivery_ack after first delivery
1:                     if (currentRedeliveryCount > 0) {
1:                         MessageAck ack = new MessageAck(lastMd, MessageAck.REDELIVERED_ACK_TYPE, deliveredMessages.size());
1:                         ack.setFirstMessageId(firstMsgId);
1:                         session.sendAck(ack,true);
1:                     }
0:                     for (Iterator<MessageDispatch> iter = deliveredMessages.iterator(); iter.hasNext();) {
0:                         MessageDispatch md = iter.next();
1:                     if (redeliveryDelay > 0 && !unconsumedMessages.isClosed()) {
commit:2b2b35e
/////////////////////////////////////////////////////////////////////////
0:     protected static final Scheduler scheduler = Scheduler.getInstance();
/////////////////////////////////////////////////////////////////////////
0:                         scheduler.executeAfterDelay(new Runnable() {
commit:e53668e
/////////////////////////////////////////////////////////////////////////
0:             } else if (pendingAck != null && pendingAck.isStandardAck()) {
commit:4d6043a
/////////////////////////////////////////////////////////////////////////
0:             pendingAck = null;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0826fdc
/////////////////////////////////////////////////////////////////////////
commit:2aff82c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:                     deliveredCounter -= deliveredMessages.size();
1:                     deliveredMessages.clear();
1: 
/////////////////////////////////////////////////////////////////////////
1:                             Collections.reverse(pendingRedeliveries);
1: 
1:                             deliveredCounter -= deliveredMessages.size();
1:                             deliveredMessages.clear();
1: 
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:                         deliveredCounter -= deliveredMessages.size();
1:                         deliveredMessages.clear();
1: 
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:8a75d96
/////////////////////////////////////////////////////////////////////////
0:             acknowledge(md, MessageAck.DELIVERED_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         acknowledge(md, MessageAck.INDIVIDUAL_ACK_TYPE);
1:     }
1: 
1:     void acknowledge(MessageDispatch md, byte ackType) throws JMSException {
1:         MessageAck ack = new MessageAck(md, ackType, 1);
commit:c02acbd
/////////////////////////////////////////////////////////////////////////
1: 
0:             // if there is a pending delivered ack then we need to send that since there
0:             // could be expired Messages in the ack which haven't been acked yet and the
0:             // ack for all deliveries might not include those in its range of acks.  The
0:             // pending standard acks will be included in the ack for all deliveries.
0:             if (pendingAck != null && pendingAck.isDeliveredAck()) {
0:                 session.sendAck(pendingAck);
1:             }
1:             session.sendAck(ack);
commit:3d5a758
/////////////////////////////////////////////////////////////////////////
1:     private long optimizedAckScheduledAckInterval = 0;
1:     private Runnable optimizedAckTask;
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidDestinationException("Cannot use a Temporary destination from another Connection");
1:                 throw new InvalidDestinationException("Cannot use a Temporary destination that has been deleted");
/////////////////////////////////////////////////////////////////////////
1:             setOptimizedAckScheduledAckInterval(session.connection.getOptimizedAckScheduledAckInterval());
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new JMSException("Illegal prefetch size of zero. This setting is not supported for asynchronous consumers please set a value of at least 1");
/////////////////////////////////////////////////////////////////////////
1:         } else if (session.isIndividualAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:             if (optimizedAckTask != null) {
1:                 this.session.connection.getScheduler().cancel(optimizedAckTask);
1:                 optimizedAckTask = null;
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:                                 // AMQ-3956 evaluate both expired and normal msgs as
/////////////////////////////////////////////////////////////////////////
1:                                     // AMQ-3956 - as further optimization send
1:                                     // because the deliveredCounter just below
0:                                         session.sendAck(pendingAck);
0:                                         pendingAck = null;
0:                                         deliveredCounter = 0;
/////////////////////////////////////////////////////////////////////////
0:         // AMQ-3956 evaluate both expired and normal msgs as
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the optimizedAckScheduledAckInterval
1:      */
1:     public long getOptimizedAckScheduledAckInterval() {
1:         return optimizedAckScheduledAckInterval;
1:     }
1: 
1:     /**
1:      * @param optimizedAckScheduledAckInterval the optimizedAckScheduledAckInterval to set
1:      */
1:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) throws JMSException {
1:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1: 
1:         if (this.optimizedAckTask != null) {
1:             try {
1:                 this.session.connection.getScheduler().cancel(optimizedAckTask);
1:             } catch (JMSException e) {
1:                 LOG.debug("Caught exception while cancelling old optimized ack task", e);
1:                 throw e;
1:             }
1:             this.optimizedAckTask = null;
1:         }
1: 
1:         // Should we periodically send out all outstanding acks.
1:         if (this.optimizeAcknowledge && this.optimizedAckScheduledAckInterval > 0) {
1:             this.optimizedAckTask = new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         if (optimizeAcknowledge && !unconsumedMessages.isClosed()) {
0:                             if (LOG.isInfoEnabled()) {
0:                                 LOG.info("Consumer:{} is performing scheduled delivery of outstanding optimized Acks", info.getConsumerId());
1:                             }
1:                             deliverAcks();
1:                         }
1:                     } catch (Exception e) {
1:                         LOG.debug("Optimized Ack Task caught exception during ack", e);
1:                     }
1:                 }
1:             };
1: 
1:             try {
1:                 this.session.connection.getScheduler().executePeriodically(optimizedAckTask, optimizedAckScheduledAckInterval);
1:             } catch (JMSException e) {
1:                 LOG.debug("Caught exception while scheduling new optimized ack task", e);
1:                 throw e;
1:             }
1:         }
1:     }
commit:0227c08
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // Wake up any blockers and allow them to recheck state.
1:                     unconsumedMessages.getMutex().notifyAll();
commit:a3836b5
/////////////////////////////////////////////////////////////////////////
1:         this.redeliveryPolicy = session.connection.getRedeliveryPolicyMap().getEntryFor(dest);
commit:97ae323
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             session.getScheduler().executeAfterDelay(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                             session.getScheduler().executeAfterDelay(new Runnable() {
commit:0b6bf7e
/////////////////////////////////////////////////////////////////////////
1:     private boolean nonBlockingRedelivery = false;
/////////////////////////////////////////////////////////////////////////
1:         this.nonBlockingRedelivery = session.connection.isNonBlockingRedelivery();
0:         this.transactedIndividualAck = session.connection.isTransactedIndividualAck() || this.nonBlockingRedelivery;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     if (nonBlockingRedelivery) {
1:                         if (!unconsumedMessages.isClosed()) {
1:                             final LinkedList<MessageDispatch> pendingRedeliveries =
1:                                 new LinkedList<MessageDispatch>(deliveredMessages);
1:                             // Start up the delivery again a little later.
0:                             scheduler.executeAfterDelay(new Runnable() {
1:                                 public void run() {
1:                                     try {
1:                                         if (!unconsumedMessages.isClosed()) {
1:                                             for(MessageDispatch dispatch : pendingRedeliveries) {
1:                                                 session.dispatch(dispatch);
1:                                             }
1:                                         }
1:                                     } catch (Exception e) {
1:                                         session.connection.onAsyncException(e);
1:                             }, redeliveryDelay);
1:                         }
1:                     } else {
1:                         unconsumedMessages.stop();
1: 
1:                         for (MessageDispatch md : deliveredMessages) {
1:                             unconsumedMessages.enqueueFirst(md);
1:                         }
1: 
0:                         if (redeliveryDelay > 0 && !unconsumedMessages.isClosed()) {
1:                             // Start up the delivery again a little later.
0:                             scheduler.executeAfterDelay(new Runnable() {
1:                                 public void run() {
1:                                     try {
1:                                         if (started.get()) {
1:                                             start();
1:                                         }
1:                                     } catch (JMSException e) {
1:                                         session.connection.onAsyncException(e);
1:                                     }
1:                                 }
1:                             }, redeliveryDelay);
1:                         } else {
1:                             start();
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
commit:0a66b79
/////////////////////////////////////////////////////////////////////////
0:         // Store interrupted state and clear so that Transport operations don't
0:         // throw InterruptedException and we ensure that resources are clened up.
0:         boolean interrupted = Thread.interrupted();
/////////////////////////////////////////////////////////////////////////
0:         if (interrupted) {
1:             Thread.currentThread().interrupt();
0:         }    }
commit:6c4bcb3
/////////////////////////////////////////////////////////////////////////
1:             Map<String, Object> options = IntrospectionSupport.extractProperties(
1:                 new HashMap<String, Object>(dest.getOptions()), "consumer.");
commit:b7f2808
/////////////////////////////////////////////////////////////////////////
0:             Map<String, Object> options = IntrospectionSupport.extractProperties(dest.getOptions(), "consumer.");
commit:56272fa
/////////////////////////////////////////////////////////////////////////
0:             Map<String, Object> options = IntrospectionSupport.extractProperties(dest.getOptions(), "producer.");
1:             IntrospectionSupport.setProperties(this.info, options);
commit:88f6058
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             if (options.size() > 0) {
1:                 String msg = "There are " + options.size()
1:                     + " consumer options that couldn't be set on the consumer."
1:                     + " Check the options are spelled correctly."
1:                     + " Unknown parameters=[" + options + "]."
1:                     + " This consumer cannot be started.";
1:                 LOG.warn(msg);
1:                 throw new ConfigurationException(msg);
1:             }
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                         if (failureError != null) {
1:                             throw JMSExceptionSupport.create(failureError);
1:                         } else {
1:                             return null;
1:                         }
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             ((ActiveMQBlobMessage)m).setBlobDownloader(new BlobDownloader(session.getBlobTransferPolicy()));
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     } else {
0:                         ack = pendingAck;
0:                         pendingAck = null;
1:                     }
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (!session.getTransacted()) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                                     MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
1:                                     if (ack != null) {
1:                                         deliveredMessages.clear();
1:                                         ackCounter = 0;
0:                                         session.sendAck(ack);
1:                                         optimizeAckTimestamp = System.currentTimeMillis();
1:                                     }
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param type Ack-Type (i.e. MessageAck.STANDARD_ACK_TYPE)
1:     private MessageAck makeAckForAllDeliveredMessages(byte type) {
0:         synchronized (deliveredMessages) {
0:             if (deliveredMessages.isEmpty())
1:                 return null;
1: 
1:             MessageDispatch md = deliveredMessages.getFirst();
1:             MessageAck ack = new MessageAck(md, type, deliveredMessages.size());
1:             ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());
1:             return ack;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                 return; // no msgs
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:             if (!session.getTransacted()) {
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (previouslyDeliveredMessages != null) {
/////////////////////////////////////////////////////////////////////////
0:                                 + previouslyDeliveredMessages.transactionId
0:                 String message = "rolling back transaction ("
0:                 throw new TransactionRolledBackException(message);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:                     ack.setFirstMessageId(firstMsgId);
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:      * remove any message not re-delivered as they can't be replayed to this
0:                 if (!entry.getValue()) {
/////////////////////////////////////////////////////////////////////////
0:                                         + " consumer on this connection, failoverRedeliveryWaitPeriod="
/////////////////////////////////////////////////////////////////////////
0:             synchronized (deliveredMessages) {
0:                         if (session.isTransacted()) {
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     public IOException getFailureError() {
1:         return failureError;
1:     }
1:     public void setFailureError(IOException failureError) {
1:         this.failureError = failureError;
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:620523a
/////////////////////////////////////////////////////////////////////////
1:         this.info.setClientId(this.session.connection.getClientID());
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQMessageConsumer.class);
commit:13f9ec8
/////////////////////////////////////////////////////////////////////////
1:     
1:     private long optimizeAckTimestamp = System.currentTimeMillis();
0:     private long optimizeAckTimeout = 300;
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:                                 if (ackCounter >= (info.getPrefetchSize() * .65) || System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAckTimeout)) {
0:                             		    optimizeAckTimestamp = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:                     if (!session.isTransacted()) {
0:                         // clean, so we don't have duplicates with optimizeAcknowledge 
0:                         synchronized (deliveredMessages) {
0:                             deliveredMessages.clear();
1:                         }
0:                     pendingAck = null;
commit:461af7c
/////////////////////////////////////////////////////////////////////////
0:         	// do nothing since STANDARD_ACK will be sent
1:             return;
commit:f8ef7ff
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.MessageConsumer;
/////////////////////////////////////////////////////////////////////////
1:     
1:     private IOException failureError;
/////////////////////////////////////////////////////////////////////////
0:                     	if (failureError != null) {
0:                     		throw JMSExceptionSupport.create(failureError);
1:                     	} else {
1:                     		return null;
1:                     	}
/////////////////////////////////////////////////////////////////////////
0: 	public IOException getFailureError() {
0: 		return failureError;
1: 	}
1: 
0: 	public void setFailureError(IOException failureError) {
0: 		this.failureError = failureError;
1: 	}
1:     
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:163ad5d
/////////////////////////////////////////////////////////////////////////
1:             if (!deliveredMessages.isEmpty() && session.getTransactionContext().isInTransaction()) {
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ec82141
/////////////////////////////////////////////////////////////////////////
1:     private boolean isAutoAcknowledgeEach() {
1:         return session.isAutoAcknowledge() || ( session.isDupsOkAcknowledge() && getDestination().isQueue() );
1:     }
1: 
1:     private boolean isAutoAcknowledgeBatch() {
1:         return session.isDupsOkAcknowledge() && !getDestination().isQueue() ;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (isAutoAcknowledgeEach()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (isAutoAcknowledgeBatch()) {
/////////////////////////////////////////////////////////////////////////
1:         if (!isAutoAcknowledgeBatch()) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (isAutoAcknowledgeEach()) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (isAutoAcknowledgeBatch()) {
/////////////////////////////////////////////////////////////////////////
1:                                 if (isAutoAcknowledgeBatch() || isAutoAcknowledgeEach() || session.isIndividualAcknowledge()) {
commit:efdf8ce
/////////////////////////////////////////////////////////////////////////
0:     private MessageAck pendingAck;
1: 
/////////////////////////////////////////////////////////////////////////
1:             } else {
0:                 ack = pendingAck;
/////////////////////////////////////////////////////////////////////////
1:         
0:         MessageAck oldPendingAck = pendingAck;
0:         pendingAck = new MessageAck(md, ackType, deliveredCounter);
0:         if( oldPendingAck==null ) {
0:             pendingAck.setFirstMessageId(pendingAck.getLastMessageId());
1:         } else {
0:             pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());
1:         }
0:         pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());
1: 
0:             session.sendAck(pendingAck);
0:             pendingAck=null;
commit:93439b2
/////////////////////////////////////////////////////////////////////////
0:             if( !deliveredMessages.isEmpty() ) {
commit:a2101b7
/////////////////////////////////////////////////////////////////////////
0:             if( deliveredMessages.isEmpty() ) {
0:             	ack.setFirstMessageId(ack.getLastMessageId());
1:             } else {
0:             	ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());
1:             }
commit:8e98b13
/////////////////////////////////////////////////////////////////////////
1:         if (messageListener.get() != null) {
commit:76ac758
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicReference<MessageListener> messageListener = new AtomicReference<MessageListener>();
/////////////////////////////////////////////////////////////////////////
1:         return this.messageListener.get();
/////////////////////////////////////////////////////////////////////////
1:             this.messageListener.set(listener);
1:         } else {
1:             this.messageListener.set(null);
/////////////////////////////////////////////////////////////////////////
1:         MessageListener listener = this.messageListener.get();
/////////////////////////////////////////////////////////////////////////
1:         MessageListener listener = this.messageListener.get();
commit:c256dcf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
0: //            if ( !deliveredMessages.isEmpty() ) {
0: //                // We need to let the broker know how many times that message
0: //                // was rolled back.
0: //                rollbackCounter++;
0: //                MessageDispatch lastMd = deliveredMessages.get(0);
0: //            }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             MessageDispatch lastMd = deliveredMessages.getFirst();
0:             if (lastMd.getMessage().getRedeliveryCounter() > 0) {
1: 
0:             for (Iterator iter = deliveredMessages.iterator(); iter.hasNext();) {
0:                 MessageDispatch md = (MessageDispatch)iter.next();
1:                 md.getMessage().onMessageRolledBack();
1:             }
1: 
1:                 && lastMd.getMessage().getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()) {
1:                 
1:                 
0:                 MessageAck ack = new MessageAck(lastMd, MessageAck.REDELIVERED_ACK_TYPE, deliveredMessages.size());
0:                 session.asyncSendPacket(ack);
1: 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQMessageConsumer(ActiveMQSession session, ConsumerId consumerId, ActiveMQDestination dest,
1:                                    String name, String selector, int prefetch,
1:                                    int maximumPendingMessageCount, boolean noLocal, boolean browser,
0:                                    boolean dispatchAsync) throws JMSException {
/////////////////////////////////////////////////////////////////////////
0:                 throw new InvalidDestinationException(
0:                                                       "Cannot use a Temporary destination from another Connection");
0:                 throw new InvalidDestinationException(
0:                                                       "Cannot use a Temporary destination that has been deleted");
/////////////////////////////////////////////////////////////////////////
1:         this.optimizeAcknowledge = session.connection.isOptimizeAcknowledge() && session.isAutoAcknowledge()
1:                                    && !info.isBrowser();
/////////////////////////////////////////////////////////////////////////
0:             throw new JMSException(
0:                                    "Illegal prefetch size of zero. This setting is not supported for asynchronous consumers please set a value of at least 1");
/////////////////////////////////////////////////////////////////////////
0:             if (session.isTransacted()) {
0:             } else if (session.isAutoAcknowledge()) {
0:                                 MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE,
0:                                                                 deliveredMessages.size());
/////////////////////////////////////////////////////////////////////////
0:                         MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages
0:                             .size());
/////////////////////////////////////////////////////////////////////////
1:             }
1:             if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:                 && rollbackCounter > redeliveryPolicy.getMaximumRedeliveries()) {
/////////////////////////////////////////////////////////////////////////
1:         return "ActiveMQMessageConsumer { value=" + info.getConsumerId() + ", started=" + started.get()
1:                + " }";
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> options = new HashMap<String, String>(dest.getOptions());
/////////////////////////////////////////////////////////////////////////
1:         if (session.connection.isStarted()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (wasRunning) {
1:             }
1:             if (wasRunning) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (md == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (md == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (md == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (unconsumedMessages.isClosed()) {
1:         }
0:             if( session.isTransacted() ) {
1:                 // Do nothing.
0:             } else if(session.isAutoAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
0:                 deliveredCounter = 0;
0:                 additionalWindowSize = 0;
/////////////////////////////////////////////////////////////////////////
1:         if (deliveredMessages.isEmpty()) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (deliveredMessages.isEmpty()) {
1:             } 
0:             if (rollbackCounter > 0) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                                 if (started.get()) {
1:                                 }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageListener;
1: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (session.isTransacted() || session.isDupsOkAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
1:                     if (this.info.isBrowser() || !session.connection.isDuplicate(this, md.getMessage())) {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * For asynchronous delivery, a client can register a
1:  * <CODE>MessageListener</CODE> object with a message consumer. As messages
1:  * arrive at the message consumer, it delivers them by calling the
1:  * <CODE>MessageListener</CODE>'s<CODE>
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ActiveMQMessageConsumer.class);
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList<MessageDispatch> deliveredMessages = new LinkedList<MessageDispatch>();
1:     private int deliveredCounter;
1:     private int additionalWindowSize;
0:     private int rollbackCounter;
1:     private long redeliveryDelay;
1:     private int ackCounter;
1:     private int dispatchedCount;
1:     private boolean synchronizationRegistered;
/////////////////////////////////////////////////////////////////////////
1:     private ExecutorService executorService;
/////////////////////////////////////////////////////////////////////////
0:     public ActiveMQMessageConsumer(ActiveMQSession session, ConsumerId consumerId, ActiveMQDestination dest, String name, String selector, int prefetch,
0:                                    int maximumPendingMessageCount, boolean noLocal, boolean browser, boolean dispatchAsync) throws JMSException {
1:             throw new InvalidDestinationException("The destination object was not given a physical name.");
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge = session.connection.isOptimizeAcknowledge() && session.isAutoAcknowledge() && !info.isBrowser();
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (session.connection.isStarted())
/////////////////////////////////////////////////////////////////////////
1:      * Sets the transformer used to transform messages before they are sent on
1:      * to the JMS bus
/////////////////////////////////////////////////////////////////////////
1:         return info.getSubscriptionName() != null && info.getDestination().isTopic();
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to receive the next
1:      *                 message due to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to get the message
1:      *                 listener due to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @param listener the listener to which the messages are to be delivered
1:      * @throws JMSException if the JMS provider fails to receive the next
1:      *                 message due to some internal error.
/////////////////////////////////////////////////////////////////////////
1:             session.redispatch(this, unconsumedMessages);
/////////////////////////////////////////////////////////////////////////
1:      * Sets the listener used to notify synchronous consumers that there is a
1:      * message available so that the {@link MessageConsumer#receiveNoWait()} can
1:      * be called.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 } else if (md.getMessage() == null) {
1:                     return null;
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Received expired message: " + md);
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Received message: " + md);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQMessage m = (ActiveMQMessage)md.getMessage().copy();
/////////////////////////////////////////////////////////////////////////
1:      * @param timeout the timeout value (in milliseconds), a time out of zero
1:      *                never expires.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                 md = dequeue(-1); // We let the broker let us know when we
1:                 // timeout.
1:                 md = dequeue(timeout);
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to receive the next
1:      *                 message due to some internal error.
1: 
0:             md = dequeue(-1); // We let the broker let us know when we
0:             // timeout.
1:             md = dequeue(0);
1: 
/////////////////////////////////////////////////////////////////////////
1:      * MessageConsumer</CODE>
1:      * outside the Java virtual machine, clients should close them when they are
1:      * not needed. Relying on garbage collection to eventually reclaim these
1:      * resources may not be timely enough.
1:      * @throws JMSException if the JMS provider fails to close the consumer due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1: 
0:     void clearMessagesInProgress() {
/////////////////////////////////////////////////////////////////////////
0:         clearDispatchList = true;
1: 
1:     void deliverAcks() {
1:         MessageAck ack = null;
1:         if (deliveryingAcknowledgements.compareAndSet(false, true)) {
0:             if (this.optimizeAcknowledge) {
0:                 if (!deliveredMessages.isEmpty()) {
0:                     MessageDispatch md = deliveredMessages.getFirst();
0:                     ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:                     ackCounter = 0;
1:             if (ack != null) {
1:                 final MessageAck ackToSend = ack;
1:                 if (executorService == null) {
1:                     executorService = Executors.newSingleThreadExecutor();
1:                 executorService.submit(new Runnable() {
1:                     public void run() {
1:                         try {
1:                         } catch (JMSException e) {
0:                             LOG.error("Failed to delivered acknowledgements", e);
1:                         } finally {
1:             } else {
1:     public void dispose() throws JMSException {
1:         if (!unconsumedMessages.isClosed()) {
0:             // only processes optimized acknowledgements
1:             deliverAcks();
1:             if (executorService != null) {
1:                 try {
0:                     executorService.awaitTermination(60, TimeUnit.SECONDS);
1:                 } catch (InterruptedException e) {
0:             if ((session.isTransacted() || session.isDupsOkAcknowledge())) {
1:                 if (!this.info.isBrowser()) {
0:                     for (MessageDispatch old : deliveredMessages) {
0:                         session.connection.rollbackDuplicate(this, old.getMessage());
0:             List<MessageDispatch> list = unconsumedMessages.removeAll();
1:             if (!this.info.isBrowser()) {
0:                 for (MessageDispatch old : list) {
0:                     session.connection.rollbackDuplicate(this, old.getMessage());
/////////////////////////////////////////////////////////////////////////
1: 
1:      * If we have a zero prefetch specified then send a pull command to the
1:      * broker to pull a message we are about to receive
1:             messagePull.setTimeout(timeout);
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void setOptimizeAcknowledge(boolean value) {
1:         if (optimizeAcknowledge && !value) {
1:         optimizeAcknowledge = value;
1: 
1:     protected void setPrefetchSize(int prefetch) {
/////////////////////////////////////////////////////////////////////////
0:             if (session.isTransacted()) {
0:                 ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
1:     private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {
0:         if (unconsumedMessages.isClosed())
1:         if (messageExpired) {
0:             ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
0:         } else {
0:             if (session.isTransacted()) {
0:             } else if (session.isAutoAcknowledge()) {
0:                 if (!deliveredMessages.isEmpty()) {
1:                     if (optimizeAcknowledge) {
0:                         if (deliveryingAcknowledgements.compareAndSet(false, true)) {
0:                             if (ackCounter >= (info.getCurrentPrefetchSize() * .65)) {
0:                                 MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:                                 ackCounter = 0;
0:                     } else {
0:                         MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:             } else if (session.isDupsOkAcknowledge()) {
1:                 ackLater(md, MessageAck.STANDARD_ACK_TYPE);
0:             } else if (session.isClientAcknowledge()) {
0:                 ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
0:             } else {
/////////////////////////////////////////////////////////////////////////
1:     public void rollback() throws JMSException {
0:         synchronized (unconsumedMessages.getMutex()) {
0:             if (optimizeAcknowledge) {
1:                 // remove messages read but not acked at the broker yet through
1:                 // optimizeAcknowledge
0:                 if (!this.info.isBrowser()) {
1:                     for (int i = 0; (i < deliveredMessages.size()) && (i < ackCounter); i++) {
1:                         MessageDispatch md = deliveredMessages.removeLast();
0:                         session.connection.rollbackDuplicate(this, md.getMessage());
0:             if (deliveredMessages.isEmpty())
0:             if (rollbackCounter > 0)
0:                 redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
0:             if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES && rollbackCounter > redeliveryPolicy.getMaximumRedeliveries()) {
0:                 MessageDispatch lastMd = deliveredMessages.get(0);
1:                 MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());
1:                 // ensure we don't filter this as a duplicate
0:                 session.connection.rollbackDuplicate(this, lastMd.getMessage());
1:                 additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
0:                 rollbackCounter = 0;
1:                 redeliveryDelay = 0;
0:             } else {
1: 
0:                 for (Iterator iter = deliveredMessages.iterator(); iter.hasNext();) {
0:                     MessageDispatch md = (MessageDispatch)iter.next();
1: 
0:                 if (redeliveryDelay > 0) {
0:                     Scheduler.executeAfterDelay(new Runnable() {
0:                         public void run() {
1:                             try {
0:                                 if (started.get())
1:                                     start();
1:                             } catch (JMSException e) {
0:                                 session.connection.onAsyncException(e);
1:                             }
1:                         }
0:                     }, redeliveryDelay);
1:                     start();
0:             deliveredCounter -= deliveredMessages.size();
1:         if (messageListener != null) {
1:             session.redispatch(this, unconsumedMessages);
1:     public void dispatch(MessageDispatch md) {
0:         MessageListener listener = this.messageListener;
1:         try {
0:             synchronized (unconsumedMessages.getMutex()) {
0:                 if (clearDispatchList) {
0:                     // we are reconnecting so lets flush the in progress
0:                     // messages
0:                     clearDispatchList = false;
0:                     List<MessageDispatch> list = unconsumedMessages.removeAll();
0:                     if (!this.info.isBrowser()) {
0:                         for (MessageDispatch old : list) {
0:                             session.connection.rollbackDuplicate(this, old.getMessage());
1:                 if (!unconsumedMessages.isClosed()) {
0:                     if (this.info.isBrowser() || session.connection.isDuplicate(this, md.getMessage()) == false) {
1:                         if (listener != null && unconsumedMessages.isRunning()) {
1:                             ActiveMQMessage message = createActiveMQMessage(md);
1:                             try {
0:                                 boolean expired = message.isExpired();
1:                                 if (!expired) {
1:                                 afterMessageIsConsumed(md, expired);
1:                             } catch (RuntimeException e) {
0:                                 if (session.isDupsOkAcknowledge() || session.isAutoAcknowledge()) {
0:                                 } else {
0:                                     // Transacted or Client ack: Deliver the
0:                                     // next message.
1:                                     afterMessageIsConsumed(md, false);
0:                                 LOG.error("Exception while processing message: " + e, e);
0:                         } else {
0:                             if (availableListener != null) {
0:                     } else {
0:                         // ignore duplicate
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Ignoring Duplicate: " + md.getMessage());
0:                         ackLater(md, MessageAck.STANDARD_ACK_TYPE);
1:             if (++dispatchedCount % 1000 == 0) {
1:                 dispatchedCount = 0;
1:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:         if (unconsumedMessages.isClosed()) {
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:         return "ActiveMQMessageConsumer { value=" + info.getConsumerId() + ", started=" + started.get() + " }";
1:      * 
1:      * @throws JMSException
1:     public boolean iterate() {
0:         MessageListener listener = this.messageListener;
1:         if (listener != null) {
1:             MessageDispatch md = unconsumedMessages.dequeueNoWait();
1:             if (md != null) {
0:                 try {
0:                     ActiveMQMessage message = createActiveMQMessage(md);
1:                     beforeMessageIsConsumed(md);
1:                     listener.onMessage(message);
1:                     afterMessageIsConsumed(md, false);
0:                 } catch (JMSException e) {
0:                     session.connection.onAsyncException(e);
1:                 }
1:                 return true;
1:             }
1:         }
0:         return false;
1:     }
1: 
1:     public boolean isInUse(ActiveMQTempDestination destination) {
1:         return info.getDestination().equals(destination);
1:     }
commit:ecb5023
/////////////////////////////////////////////////////////////////////////
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:da5139c
/////////////////////////////////////////////////////////////////////////
1: 
0:             // Only increase the redlivery delay after the first redelivery..
0:             if( rollbackCounter > 0 )
0:             	redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 
1:                                 
0:                 if( redeliveryDelay > 0 ) {
0:                     // Start up the delivery again a little later.
0: 	                Scheduler.executeAfterDelay(new Runnable(){
0: 	                    public void run(){
0: 	                        try{
0: 	                            if(started.get())
0: 	                                start();
0: 	                        }catch(JMSException e){
0: 	                            session.connection.onAsyncException(e);
1: 	                        }
1: 	                    }
0: 	                },redeliveryDelay);
0:                 } else {
0:                 	start();
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:             synchronized(unconsumedMessages.getMutex()){
1: 	            if (!unconsumedMessages.isClosed()) {
0: 	                if (listener != null && unconsumedMessages.isRunning() ) {
0: 	                    ActiveMQMessage message = createActiveMQMessage(md);
1: 	                    beforeMessageIsConsumed(md);
0: 	                    try {
0: 	                        listener.onMessage(message);
1: 	                        afterMessageIsConsumed(md, false);
0: 	                    } catch (RuntimeException e) {
0: 	                        if ( session.isDupsOkAcknowledge() || session.isAutoAcknowledge() ) {
0: 	                            // Redeliver the message
0: 	                        } else {
0: 	                            // Transacted or Client ack: Deliver the next message.
1: 	                            afterMessageIsConsumed(md, false);
1: 	                        }
0: 	                        log.warn("Exception while processing message: " + e, e);
1: 	                    }
0: 	                } else {
0: 	                    unconsumedMessages.enqueue(md);
0: 	                    if (availableListener != null) {
0: 	                        availableListener.onMessageAvailable(this);
1: 	                    }
1: 	                }
1: 	            }
0:         	session.connection.onAsyncException(e);
/////////////////////////////////////////////////////////////////////////
1:     	if (unconsumedMessages.isClosed()) {
0:     		return;
1:     	}    	
1:         session.executor.wakeup();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Delivers a message to the message listener.
0:      * @return
1:      * @throws JMSException 
1:      */
0: 	public boolean iterate() {
0: 		MessageListener listener = this.messageListener;
0: 		if( listener!=null ) {
0: 		    MessageDispatch md = unconsumedMessages.dequeueNoWait();
0: 		    if( md!=null ) {
0: 		        try {
0: 			        ActiveMQMessage message = createActiveMQMessage(md);
1: 			        beforeMessageIsConsumed(md);
0: 			        listener.onMessage(message);
0: 			        afterMessageIsConsumed(md, false);
0: 				} catch (JMSException e) {
0: 		        	session.connection.onAsyncException(e);
1: 				}
0: 		        return true;
1: 		    }
1: 		}
0:     	return false;
1: 	}
1: 
commit:333158a
/////////////////////////////////////////////////////////////////////////
1:         this.info.setSubscriptionName(name);
/////////////////////////////////////////////////////////////////////////
1:         return this.info.getSubscriptionName();
/////////////////////////////////////////////////////////////////////////
0:         return info.getSubscriptionName()!=null && info.getDestination().isTopic();
commit:2e08bc7
/////////////////////////////////////////////////////////////////////////
1:         sendPullCommand(0);
commit:62f798a
/////////////////////////////////////////////////////////////////////////
0:         if (info.getPrefetchSize() == 0 && unconsumedMessages.isEmpty()) {
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
0:             Thread.currentThread().interrupt();
commit:a19bfd4
/////////////////////////////////////////////////////////////////////////
0:                 } else if ( md.getMessage()==null ) {
1:                 	return null;
/////////////////////////////////////////////////////////////////////////
1:         
1:         sendPullCommand(-1);
/////////////////////////////////////////////////////////////////////////
0:      *            the timeout value (in milliseconds), a time out of zero never expires.
1:         
1:         sendPullCommand(timeout);
1:         	
1:             MessageDispatch md;
1:             if (info.getPrefetchSize() == 0) {
0:             	md = dequeue(-1);  // We let the broker let us know when we timeout.
0:             } else {
0:             	md = dequeue(timeout);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:         sendPullCommand(-1);
1:         
1:         MessageDispatch md;
1:         if (info.getPrefetchSize() == 0) {
0:         	md = dequeue(-1);  // We let the broker let us know when we timeout.
0:         } else {
0:         	md = dequeue(0);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:     protected void sendPullCommand(long timeout) throws JMSException {
0:             messagePull.setTimeout(timeout);            
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f25e2ca
/////////////////////////////////////////////////////////////////////////
0:                 if (listener != null && unconsumedMessages.isRunning() ) {
commit:b708fd3
/////////////////////////////////////////////////////////////////////////
1:     private void beforeMessageIsConsumed(MessageDispatch md) throws JMSException {
0:         if (!session.isDupsOkAcknowledge()) {
0:             if( session.isTransacted() ) {
0:                 ackLater(md,MessageAck.DELIVERED_ACK_TYPE);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if( session.isTransacted() ) {
0:             } else if(session.isAutoAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
0:             } else if(session.isDupsOkAcknowledge()){
0:             } else if(session.isClientAcknowledge()){
0:             } else{
commit:91720da
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
0: import edu.emory.mathcs.backport.java.util.concurrent.Executors;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:                 try {
0:                     executorService.awaitTermination(60, TimeUnit.SECONDS);
0:                 } catch (InterruptedException e) {
0:                     Thread.currentThread().interrupt();
1:                 }
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:                 public void execute() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     public void beforeEnd() throws Exception {
0:                     public void afterCommit() throws Exception {
0:                     public void afterRollback() throws Exception {
commit:d86f77f
/////////////////////////////////////////////////////////////////////////
1:     protected void checkMessageListener() throws JMSException {
1:         session.checkMessageListener();
/////////////////////////////////////////////////////////////////////////
0:                     try {
0:                         listener.onMessage(message);
0:                         afterMessageIsConsumed(md, false);
0:                     } catch (RuntimeException e) {
0:                         if ( session.isDupsOkAcknowledge() || session.isAutoAcknowledge() ) {
0:                             // Redeliver the message
0:                         } else {
0:                             // Transacted or Client ack: Deliver the next message.
0:                             afterMessageIsConsumed(md, false);
1:                         }
1:                     }
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:      * @param value
/////////////////////////////////////////////////////////////////////////
1:             String connectionID = session.connection.getConnectionInfo().getConnectionId().getValue();
/////////////////////////////////////////////////////////////////////////
1:      * @return Returns the value.
/////////////////////////////////////////////////////////////////////////
0:         return "ActiveMQMessageConsumer { value=" +info.getConsumerId()+", started=" +started.get()+" }";
commit:80f5e0c
/////////////////////////////////////////////////////////////////////////
1:                 // Adjust the window size.
0:                 rollbackCounter = 0;
1:                 redeliveryDelay = 0;
1:                 
/////////////////////////////////////////////////////////////////////////
0:             deliveredCounter -= deliveredMessages.size();
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
1: 
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
1: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.RedeliveryPolicy;
1: import org.apache.activemq.management.JMSConsumerStatsImpl;
1: import org.apache.activemq.management.StatsCapable;
1: import org.apache.activemq.management.StatsImpl;
1: import org.apache.activemq.selector.SelectorParser;
0: import org.apache.activemq.thread.Scheduler;
1: import org.apache.activemq.transaction.Synchronization;
1: import org.apache.activemq.util.Callback;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: /**
1:  * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:  * from a destination. A <CODE> MessageConsumer</CODE> object is created by
1:  * passing a <CODE>Destination</CODE> object to a message-consumer creation
1:  * method supplied by a session.
1:  * <P>
1:  * <CODE>MessageConsumer</CODE> is the parent interface for all message
1:  * consumers.
1:  * <P>
1:  * A message consumer can be created with a message selector. A message selector
1:  * allows the client to restrict the messages delivered to the message consumer
1:  * to those that match the selector.
1:  * <P>
1:  * A client may either synchronously receive a message consumer's messages or
1:  * have the consumer asynchronously deliver them as they arrive.
1:  * <P>
1:  * For synchronous receipt, a client can request the next message from a message
1:  * consumer using one of its <CODE> receive</CODE> methods. There are several
1:  * variations of <CODE>receive</CODE> that allow a client to poll or wait for
1:  * the next message.
1:  * <P>
0:  * For asynchronous delivery, a client can register a <CODE>MessageListener</CODE>
0:  * object with a message consumer. As messages arrive at the message consumer,
0:  * it delivers them by calling the <CODE>MessageListener</CODE>'s<CODE>
1:  * onMessage</CODE> method.
1:  * <P>
1:  * It is a client programming error for a <CODE>MessageListener</CODE> to
1:  * throw an exception.
0:  * 
0:  * @version $Revision: 1.22 $
1:  * @see javax.jms.MessageConsumer
1:  * @see javax.jms.QueueReceiver
1:  * @see javax.jms.TopicSubscriber
1:  * @see javax.jms.Session
1:  */
1: public class ActiveMQMessageConsumer implements MessageAvailableConsumer, StatsCapable, ActiveMQDispatcher {
1: 
0:     private static final Log log = LogFactory.getLog(ActiveMQMessageConsumer.class);
1: 
1:     protected final ActiveMQSession session;
1:     protected final ConsumerInfo info;
1: 
1:     // These are the messages waiting to be delivered to the client
0:     private final MessageDispatchChannel unconsumedMessages = new MessageDispatchChannel();
1: 
1:     // The are the messages that were delivered to the consumer but that have
1:     // not been acknowledged. It's kept in reverse order since we
0:     // Always walk list in reverse order. Only used when session is client ack.
0:     private final LinkedList deliveredMessages = new LinkedList();
0:     private int deliveredCounter = 0;
0:     private int additionalWindowSize = 0;
0:     private int rollbackCounter = 0;
0:     private long redeliveryDelay = 0;
1: 
0:     private MessageListener messageListener;
0:     private JMSConsumerStatsImpl stats;
1: 
1:     private final String selector;
0:     private boolean synchronizationRegistered = false;
0:     private AtomicBoolean started = new AtomicBoolean(false);
1: 
1:     private MessageAvailableListener availableListener;
1: 
1:     /**
1:      * Create a MessageConsumer
0:      * 
1:      * @param session
0:      * @param consumerId
1:      * @param dest
1:      * @param name
1:      * @param selector
1:      * @param prefetch
1:      * @param noLocal
1:      * @param browser
1:      * @param dispatchAsync
1:      * @throws JMSException
1:      */
0:     public ActiveMQMessageConsumer(ActiveMQSession session, ConsumerId consumerId, ActiveMQDestination dest,
0:             String name, String selector, int prefetch, boolean noLocal, boolean browser, boolean dispatchAsync)
0:             throws JMSException {
1:         if (dest == null) {
1:             throw new InvalidDestinationException("Don't understand null destinations");
1:         } else if (dest.getPhysicalName() == null) {
0:                 throw new InvalidDestinationException("The destination object was not given a physical name.");
1:         } else if (dest.isTemporary()) {
1:             String physicalName = dest.getPhysicalName();
1: 
1:             if (physicalName == null) {
1:                 throw new IllegalArgumentException("Physical name of Destination should be valid: " + dest);
1:             }
1: 
0:             String connectionID = session.connection.getConnectionInfo().getConnectionId().getConnectionId();
1: 
1:             if (physicalName.indexOf(connectionID) < 0) {
0:                 throw new InvalidDestinationException("Cannot use a Temporary destination from another Connection");
1:             }
1: 
1:             if (session.connection.isDeleted(dest)) {
0:                 throw new InvalidDestinationException("Cannot use a Temporary destination that has been deleted");
1:             }
1:         }
1: 
1:         this.session = session;
1:         this.selector = selector;
1: 
1:         this.info = new ConsumerInfo(consumerId);
0:         this.info.setSubcriptionName(name);
1:         this.info.setPrefetchSize(prefetch);
1:         this.info.setNoLocal(noLocal);
1:         this.info.setDispatchAsync(dispatchAsync);
1:         this.info.setRetroactive(this.session.connection.isUseRetroactiveConsumer());
1: 
1:         // Allows the options on the destination to configure the consumerInfo
1:         if (dest.getOptions() != null) {
0:             HashMap options = new HashMap(dest.getOptions());
0:             IntrospectionSupport.setProperties(this.info, options, "consumer.");
1:         }
1: 
1:         this.info.setDestination(dest);
1:         this.info.setBrowser(browser);
1:         if (selector != null && selector.trim().length() != 0) {
0:             // Validate that the selector
0:             new SelectorParser().parse(selector);
1:             this.info.setSelector(selector);
0:         } else {
1:             this.info.setSelector(null);
1:         }
1: 
1:         this.stats = new JMSConsumerStatsImpl(session.getSessionStats(), dest);
0:         try {
1:             this.session.addConsumer(this);
1:             this.session.syncSendPacket(info);
0:         } catch (JMSException e) {
1:             this.session.removeConsumer(this);
1:             throw e;
1:         }
1: 
0:         if (session.connection.isStarted())
0:             start();
1:     }
1: 
1:     public StatsImpl getStats() {
1:         return stats;
1:     }
1: 
1:     public JMSConsumerStatsImpl getConsumerStats() {
1:         return stats;
1:     }
1: 
1:     /**
0:      * @return Returns the consumerId.
1:      */
0:     protected ConsumerId getConsumerId() {
1:         return info.getConsumerId();
1:     }
1: 
1:     /**
1:      * @return the consumer name - used for durable consumers
1:      */
0:     protected String getConsumerName() {
0:         return this.info.getSubcriptionName();
1:     }
1: 
1:     /**
1:      * @return true if this consumer does not accept locally produced messages
1:      */
1:     protected boolean isNoLocal() {
1:         return info.isNoLocal();
1:     }
1: 
1:     /**
1:      * Retrieve is a browser
0:      * 
1:      * @return true if a browser
1:      */
1:     protected boolean isBrowser() {
1:         return info.isBrowser();
1:     }
1: 
1:     /**
1:      * @return ActiveMQDestination
1:      */
1:     protected ActiveMQDestination getDestination() {
1:         return info.getDestination();
1:     }
1: 
1:     /**
1:      * @return Returns the prefetchNumber.
1:      */
1:     public int getPrefetchNumber() {
1:         return info.getPrefetchSize();
1:     }
1: 
1:     /**
1:      * @return true if this is a durable topic subscriber
1:      */
1:     public boolean isDurableSubscriber() {
0:         return info.getSubcriptionName()!=null && info.getDestination().isTopic();
1:     }
1: 
1:     /**
1:      * Gets this message consumer's message selector expression.
0:      * 
1:      * @return this message consumer's message selector, or null if no message
1:      *         selector exists for the message consumer (that is, if the message
1:      *         selector was not set or was set to null or the empty string)
1:      * @throws JMSException
0:      *             if the JMS provider fails to receive the next message due to
0:      *             some internal error.
1:      */
1:     public String getMessageSelector() throws JMSException {
1:         checkClosed();
1:         return selector;
1:     }
1: 
1:     /**
1:      * Gets the message consumer's <CODE>MessageListener</CODE>.
0:      * 
1:      * @return the listener for the message consumer, or null if no listener is
1:      *         set
1:      * @throws JMSException
0:      *             if the JMS provider fails to get the message listener due to
0:      *             some internal error.
1:      * @see javax.jms.MessageConsumer#setMessageListener(javax.jms.MessageListener)
1:      */
1:     public MessageListener getMessageListener() throws JMSException {
1:         checkClosed();
0:         return this.messageListener;
1:     }
1: 
1:     /**
1:      * Sets the message consumer's <CODE>MessageListener</CODE>.
1:      * <P>
1:      * Setting the message listener to null is the equivalent of unsetting the
1:      * message listener for the message consumer.
1:      * <P>
1:      * The effect of calling <CODE>MessageConsumer.setMessageListener</CODE>
1:      * while messages are being consumed by an existing listener or the consumer
1:      * is being used to consume messages synchronously is undefined.
0:      * 
0:      * @param listener
0:      *            the listener to which the messages are to be delivered
1:      * @throws JMSException
0:      *             if the JMS provider fails to receive the next message due to
0:      *             some internal error.
1:      * @see javax.jms.MessageConsumer#getMessageListener
1:      */
1:     public void setMessageListener(MessageListener listener) throws JMSException {
1:         checkClosed();
0:         this.messageListener = listener;
1:         if (listener != null) {
1:             boolean wasRunning = session.isRunning();
0:             if (wasRunning)
1:                 session.stop();
1: 
0:             session.redispatch(unconsumedMessages);
1: 
0:             if (wasRunning)
1:                 session.start();
1: 
1:         }
1:     }
1: 
1:     
1:     public MessageAvailableListener getAvailableListener() {
1:         return availableListener;
1:     }
1: 
1:     /**
0:      * Sets the listener used to notify synchronous consumers that there is a message
0:      * available so that the {@link MessageConsumer#receiveNoWait()} can be called.
1:      */
1:     public void setAvailableListener(MessageAvailableListener availableListener) {
1:         this.availableListener = availableListener;
1:     }
1: 
1:     /**
1:      * Used to get an enqueued message from the unconsumedMessages list. The
1:      * amount of time this method blocks is based on the timeout value. - if
1:      * timeout==-1 then it blocks until a message is received. - if timeout==0
1:      * then it it tries to not block at all, it returns a message if it is
1:      * available - if timeout>0 then it blocks up to timeout amount of time.
0:      * 
1:      * Expired messages will consumed by this method.
0:      * 
1:      * @throws JMSException
0:      * 
1:      * @return null if we timeout or if the consumer is closed.
1:      */
1:     private MessageDispatch dequeue(long timeout) throws JMSException {
0:         try {
1:             long deadline = 0;
1:             if (timeout > 0) {
1:                 deadline = System.currentTimeMillis() + timeout;
1:             }
1:             while (true) {
1:                 MessageDispatch md = unconsumedMessages.dequeue(timeout);
1:                 if (md == null) {
1:                     if (timeout > 0 && !unconsumedMessages.isClosed()) {
1:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
0:                     } else {
1:                         return null;
1:                     }
0:                 } else if (md.getMessage().isExpired()) {
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Received expired message: " + md);
1:                     }
1:                     beforeMessageIsConsumed(md);
1:                     afterMessageIsConsumed(md, true);
1:                     if (timeout > 0) {
1:                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
1:                     }
0:                 } else {
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Received message: " + md);
1:                     }
1:                     return md;
1:                 }
1:             }
0:         } catch (InterruptedException e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     /**
1:      * Receives the next message produced for this message consumer.
1:      * <P>
1:      * This call blocks indefinitely until a message is produced or until this
1:      * message consumer is closed.
1:      * <P>
1:      * If this <CODE>receive</CODE> is done within a transaction, the consumer
1:      * retains the message until the transaction commits.
0:      * 
1:      * @return the next message produced for this message consumer, or null if
1:      *         this message consumer is concurrently closed
1:      */
1:     public Message receive() throws JMSException {
1:         checkClosed();
1:         checkMessageListener();
1:         MessageDispatch md = dequeue(-1);
0:         if (md == null)
1:             return null;
1: 
1:         beforeMessageIsConsumed(md);
0:         afterMessageIsConsumed(md, false);
1: 
1:         return createActiveMQMessage(md);
1:     }
1: 
1:     /**
1:      * @param md
0:      * @return
1:      */
0:     private ActiveMQMessage createActiveMQMessage(final MessageDispatch md) {
0:         ActiveMQMessage m = (ActiveMQMessage) md.getMessage();
1:         if (session.isClientAcknowledge()) {
1:             m.setAcknowledgeCallback(new Callback() {
0:                 public void execute() throws Throwable {
1:                     session.checkClosed();
1:                     session.acknowledge();
1:                 }
1:             });
1:         }
1:         return m;
1:     }
1: 
1:     /**
1:      * Receives the next message that arrives within the specified timeout
1:      * interval.
1:      * <P>
1:      * This call blocks until a message arrives, the timeout expires, or this
1:      * message consumer is closed. A <CODE>timeout</CODE> of zero never
1:      * expires, and the call blocks indefinitely.
0:      * 
0:      * @param timeout
0:      *            the timeout value (in milliseconds)
1:      * @return the next message produced for this message consumer, or null if
1:      *         the timeout expires or this message consumer is concurrently
1:      *         closed
1:      */
1:     public Message receive(long timeout) throws JMSException {
1:         checkClosed();
1:         checkMessageListener();
1:         if (timeout == 0) {
1:             return this.receive();
1: 
1:         }
1: 
1:         while (timeout > 0) {
0:             MessageDispatch md = dequeue(timeout);
0:             if (md == null)
1:                 return null;
1: 
1:             beforeMessageIsConsumed(md);
0:             afterMessageIsConsumed(md, false);
1:             return createActiveMQMessage(md);
1:         }
1:         return null;
1:     }
1: 
1:     /**
1:      * Receives the next message if one is immediately available.
0:      * 
1:      * @return the next message produced for this message consumer, or null if
1:      *         one is not available
1:      * @throws JMSException
0:      *             if the JMS provider fails to receive the next message due to
0:      *             some internal error.
1:      */
1:     public Message receiveNoWait() throws JMSException {
1:         checkClosed();
1:         checkMessageListener();
0:         MessageDispatch md = dequeue(0);
0:         if (md == null)
1:             return null;
1: 
1:         beforeMessageIsConsumed(md);
0:         afterMessageIsConsumed(md, false);
1:         return createActiveMQMessage(md);
1:     }
1: 
1:     /**
1:      * Closes the message consumer.
1:      * <P>
1:      * Since a provider may allocate some resources on behalf of a <CODE>
0:      * MessageConsumer</CODE> outside the Java virtual machine, clients should
0:      * close them when they are not needed. Relying on garbage collection to
0:      * eventually reclaim these resources may not be timely enough.
1:      * <P>
1:      * This call blocks until a <CODE>receive</CODE> or message listener in
1:      * progress has completed. A blocked message consumer <CODE>receive </CODE>
1:      * call returns null when this message consumer is closed.
0:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to close the consumer due to some
0:      *             internal error.
1:      */
1:     public void close() throws JMSException {
0:         if (!unconsumedMessages.isClosed()) {
0:             dispose();
0:             this.session.syncSendPacket(info.createRemoveCommand());
1:         }
1:     }
1: 
0:     public void dispose() throws JMSException {
0:         if (!unconsumedMessages.isClosed()) {
1:             // Do we have any acks we need to send out before closing?
0:             // Ack any delivered messages now. (session may still
0:             // commit/rollback the acks).
0:             if ((session.isTransacted() || session.isDupsOkAcknowledge())) {
0:                 acknowledge();
1:             }
0:             deliveredMessages.clear();
0:             unconsumedMessages.close();
1:             this.session.removeConsumer(this);
1:         }
1:     }
1: 
1:     /**
1:      * @throws IllegalStateException
1:      */
1:     protected void checkClosed() throws IllegalStateException {
0:         if (unconsumedMessages.isClosed()) {
1:             throw new IllegalStateException("The Consumer is closed");
1:         }
1:     }
1: 
0:     protected void checkMessageListener() throws IllegalStateException {
0:         if (messageListener != null) {
0:             throw new IllegalStateException("Cannot synchronously receive a message when a MessageListener is set");
1:         }
1:     }
1: 
0:     private void beforeMessageIsConsumed(MessageDispatch md) {
1:         md.setDeliverySequenceId(session.getNextDeliveryId());
0:         if (!session.isDupsOkAcknowledge())
1:             deliveredMessages.addFirst(md);
1:     }
1: 
0:     private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {
0:         if (unconsumedMessages.isClosed())
0:             return;
1: 
0:         if (messageExpired) {
0:             ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
0:         } else {
1:             stats.onMessage();
0:             if (session.isTransacted()) {
0:                 ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
0:             } else if (session.isAutoAcknowledge()) {
0:                 if (!deliveredMessages.isEmpty()) {
0:                     MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:                     session.asyncSendPacket(ack);
0:                     deliveredMessages.clear();
1:                 }
0:             } else if (session.isDupsOkAcknowledge()) {
0:                 ackLater(md, MessageAck.STANDARD_ACK_TYPE);
0:             } else if (session.isClientAcknowledge()) {
0:                 ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
0:             } else {
1:                 throw new IllegalStateException("Invalid session state.");
1:             }
1:         }
1:     }
1: 
1:     private void ackLater(MessageDispatch md, byte ackType) throws JMSException {
1: 
1:         // Don't acknowledge now, but we may need to let the broker know the
0:         // consumer got the message
0:         // to expand the pre-fetch window
0:         if (session.isTransacted()) {
1:             session.doStartTransaction();
0:             if (!synchronizationRegistered) {
0:                 synchronizationRegistered = true;
0:                 session.getTransactionContext().addSynchronization(new Synchronization() {
0:                     public void beforeEnd() throws Throwable {
0:                         acknowledge();
0:                         synchronizationRegistered = false;
1:                     }
1: 
0:                     public void afterCommit() throws Throwable {
0:                         commit();
0:                         synchronizationRegistered = false;
1:                     }
1: 
0:                     public void afterRollback() throws Throwable {
0:                         rollback();
0:                         synchronizationRegistered = false;
1:                     }
1:                 });
1:             }
1:         }
1: 
0:         // The delivered message list is only needed for the recover method
0:         // which is only used with client ack.
1:         deliveredCounter++;
0:         if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter - additionalWindowSize)) {
0:             MessageAck ack = new MessageAck(md, ackType, deliveredCounter);
1:             ack.setTransactionId(session.getTransactionContext().getTransactionId());
0:             session.asyncSendPacket(ack);
0:             additionalWindowSize = deliveredCounter;
1: 
0:             // When using DUPS ok, we do a real ack.
0:             if (ackType == MessageAck.STANDARD_ACK_TYPE) {
0:                 deliveredCounter = additionalWindowSize = 0;
1:             }
1:         }
1:     }
1: 
1:     /**
0:      * Acknowledge all the messages that have been delivered to the client upto
1:      * this point.
0:      * 
0:      * @param deliverySequenceId
1:      * @throws JMSException
1:      */
1:     public void acknowledge() throws JMSException {
0:         if (deliveredMessages.isEmpty())
0:             return;
1: 
1:         // Acknowledge the last message.
0:         MessageDispatch lastMd = (MessageDispatch) deliveredMessages.get(0);
0:         MessageAck ack = new MessageAck(lastMd, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:         if (session.isTransacted()) {
1:             session.doStartTransaction();
1:             ack.setTransactionId(session.getTransactionContext().getTransactionId());
1:         }
0:         session.asyncSendPacket(ack);
1: 
1:         // Adjust the counters
0:         deliveredCounter -= deliveredMessages.size();
1:         additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
1: 
0:         if (!session.isTransacted()) {
0:             deliveredMessages.clear();
1:         }
1:     }
1: 
1:     public void commit() throws JMSException {
0:         deliveredMessages.clear();
0:         rollbackCounter = 0;
0:         redeliveryDelay = 0;
1:     }
1: 
0:     public void rollback() throws JMSException {
0:         synchronized (unconsumedMessages.getMutex()) {
0:             if (deliveredMessages.isEmpty())
0:                 return;
1: 
0:             rollbackCounter++;
0:             RedeliveryPolicy redeliveryPolicy = session.connection.getRedeliveryPolicy();
0:             if (rollbackCounter > redeliveryPolicy.getMaximumRedeliveries()) {
1:                 
1:                 // We need to NACK the messages so that they get sent to the
1:                 // DLQ.
1: 
1:                 // Acknowledge the last message.
0:                 MessageDispatch lastMd = (MessageDispatch) deliveredMessages.get(0);
0:                 MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());
0:                 session.asyncSendPacket(ack);
1: 
1:                 // Adjust the counters
0:                 deliveredCounter -= deliveredMessages.size();
1:                 additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
1: 
0:             } else {
1: 
1:                 // stop the delivery of messages.
1:                 unconsumedMessages.stop();
1: 
0:                 // Start up the delivery again a little later.
0:                 if (redeliveryDelay == 0) {
0:                     redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
0:                 } else {
0:                     if (redeliveryPolicy.isUseExponentialBackOff())
0:                         redeliveryDelay *= redeliveryPolicy.getBackOffMultiplier();
1:                 }
1: 
0:                 Scheduler.executeAfterDelay(new Runnable() {
0:                     public void run() {
0:                         try {
0:                             if (started.get())
0:                                 start();
0:                         } catch (JMSException e) {
0:                             session.connection.onAsyncException(e);
1:                         }
1:                     }
0:                 }, redeliveryDelay);
1:                 
0:                 for (Iterator iter = deliveredMessages.iterator(); iter.hasNext();) {
0:                     MessageDispatch md = (MessageDispatch) iter.next();
0:                     md.getMessage().incrementRedeliveryCounter();
0:                     unconsumedMessages.enqueueFirst(md);
1:                 }
1:             }
1: 
0:             deliveredMessages.clear();
1:         }
1: 
0:         if (messageListener != null) {
0:             session.redispatch(unconsumedMessages);
1:         }
1:     }
1: 
0:     public void dispatch(MessageDispatch md) {
0:         MessageListener listener = this.messageListener;
0:         try {
0:             if (!unconsumedMessages.isClosed()) {
0:                 if (listener != null && started.get()) {
0:                     ActiveMQMessage message = createActiveMQMessage(md);
1:                     beforeMessageIsConsumed(md);
0:                     listener.onMessage(message);
0:                     afterMessageIsConsumed(md, false);
0:                 } else {
0:                     if (availableListener != null) {
0:                         availableListener.onMessageAvailable(this);
1:                     }
0:                     unconsumedMessages.enqueue(md);
1:                 }
1:             }
0:         } catch (Exception e) {
0:             log.warn("could not process message: " + md, e);
1:         }
1:     }
1: 
1:     public int getMessageSize() {
1:         return unconsumedMessages.size();
1:     }
1: 
1:     public void start() throws JMSException {
1:         started.set(true);
1:         unconsumedMessages.start();
0:         MessageListener listener = this.messageListener;
0:         if( listener!=null ) {
0:             MessageDispatch md;
0:             while( (md = unconsumedMessages.dequeueNoWait())!=null ) {
0:                 ActiveMQMessage message = createActiveMQMessage(md);
1:                 beforeMessageIsConsumed(md);
0:                 listener.onMessage(message);
0:                 afterMessageIsConsumed(md, false);
1:             }
1:         }
1:     }
1: 
1:     public void stop() {
1:         started.set(false);
1:         unconsumedMessages.stop();
1:     }
1:     
1:     public String toString() {
0:         return "ActiveMQMessageConsumer { consumerId=" +info.getConsumerId()+", started=" +started.get()+" }";
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:                 ThreadPoolUtils.shutdownGraceful(executorService, 60000L);
1:                 executorService = null;
author:Torsten Mielke
-------------------------------------------------------------------------------
commit:39e20d0
/////////////////////////////////////////////////////////////////////////
0:                                 
0:                                 // AMQ-3956 evaluate both expired and normal msgs as 
1:                                 // otherwise consumer may get stalled
1:                                 if (ackCounter + deliveredCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
/////////////////////////////////////////////////////////////////////////
0:                                     // AMQ-3956 - as further optimization send 
1:                                     // ack for expired msgs when there are any.
1:                                     // This resets the deliveredCounter to 0 so that
1:                                     // we won't sent standard acks with every msg just
0:                                     // because the deliveredCounter just below 
1:                                     // 0.5 * prefetch as used in ackLater()
0:                                     if (pendingAck != null && deliveredCounter > 0) {
0:                                     	session.sendAck(pendingAck);
0:                                     	pendingAck = null;
0:                                     	deliveredCounter = 0;
0:                                     }
/////////////////////////////////////////////////////////////////////////
0:         // AMQ-3956 evaluate both expired and normal msgs as 
0:         // otherwise consumer may get stalled
0:         if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter + ackCounter - additionalWindowSize)) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:c14dc3a
/////////////////////////////////////////////////////////////////////////
1:     protected final MessageDispatchChannel unconsumedMessages;
/////////////////////////////////////////////////////////////////////////
1:         if (session.connection.isMessagePrioritySupported()) {
1:             this.unconsumedMessages = new SimplePriorityMessageDispatchChannel();
1:         }else {
1:             this.unconsumedMessages = new FifoMessageDispatchChannel();
0:         }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private final JMSConsumerStatsImpl stats;
1:     private final AtomicBoolean started = new AtomicBoolean(false);
1:     private final AtomicBoolean deliveryingAcknowledgements = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:     private final long optimizeAckTimeout = 300;
/////////////////////////////////////////////////////////////////////////
0:         this.scheduler = session.getScheduler();
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:b08ae50
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.blob.BlobDownloader;
0: import org.apache.activemq.command.ActiveMQBlobMessage;
0: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicReference;
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
1:         if (m.getDataStructureType()==CommandTypes.ACTIVEMQ_BLOB_MESSAGE) {
0:         	((ActiveMQBlobMessage)m).setBlobDownloader(new BlobDownloader(session.getBlobTransferPolicy()));
0:         }
commit:586ea12
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:                     List<MessageDispatch> tmp = null;
1:                     synchronized (this.deliveredMessages) {
1:                         tmp = new ArrayList<MessageDispatch>(this.deliveredMessages);
1:                     for (MessageDispatch old : tmp) {
1:                         this.session.connection.rollbackDuplicate(this, old.getMessage());
0:                     }
1:                     tmp.clear();
commit:9ce91fa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
1:             	synchronized(deliveredMessages) {
0:             		ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
0:             		if (ack != null) {
0:             			deliveredMessages.clear();
0:             			ackCounter = 0;
0:             		}
0:             	}
/////////////////////////////////////////////////////////////////////////
1:                                 	MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
0:                                 	if (ack != null) {
0:                             		    deliveredMessages.clear();
0:                             		    ackCounter = 0;
0:                             		    session.sendAck(ack);
0:                                 	}
1:                             MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
0:                             if (ack!=null) {
0:                             	deliveredMessages.clear();
0:                             	session.sendAck(ack);
0:                             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates a MessageAck for all messages contained in deliveredMessages.
1:      * Caller should hold the lock for deliveredMessages.
0:      * 
0:      * @param type Ack-Type (i.e. MessageAck.STANDARD_ACK_TYPE) 
1:      * @return <code>null</code> if nothing to ack.
1:      */
0: 	private MessageAck makeAckForAllDeliveredMessages(byte type) {
0: 		synchronized (deliveredMessages) {
0: 			if (deliveredMessages.isEmpty())
0: 				return null;
0: 			    
0: 			MessageDispatch md = deliveredMessages.getFirst();
0: 		    MessageAck ack = new MessageAck(md, type, deliveredMessages.size());
0: 		    ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());
0: 		    return ack;
0: 		}
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0:             ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());
/////////////////////////////////////////////////////////////////////////
1:             // Acknowledge all messages so far.
0:             MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
0:             if (ack == null)
0:             	return; // no msgs
0:             
/////////////////////////////////////////////////////////////////////////
1:                 MessageId firstMsgId = deliveredMessages.getLast().getMessage().getMessageId();
/////////////////////////////////////////////////////////////////////////
0: 					ack.setFirstMessageId(firstMsgId);
/////////////////////////////////////////////////////////////////////////
0:                     ack.setFirstMessageId(firstMsgId);
commit:b52624e
/////////////////////////////////////////////////////////////////////////
1:     public ConsumerId getConsumerId() {
1:     public String getConsumerName() {
commit:0acf545
/////////////////////////////////////////////////////////////////////////
1:             session.connection.onClientInternalException(e);
/////////////////////////////////////////////////////////////////////////
0:                     session.connection.onClientInternalException(e);
commit:d8b5d5c
/////////////////////////////////////////////////////////////////////////
1:                             session.sendAck(ackToSend,true);
/////////////////////////////////////////////////////////////////////////
0:                                     session.sendAck(ack);
/////////////////////////////////////////////////////////////////////////
0:                             session.sendAck(ack);
/////////////////////////////////////////////////////////////////////////
0:             session.sendAck(ack);
/////////////////////////////////////////////////////////////////////////
0:             session.sendAck(ack);
/////////////////////////////////////////////////////////////////////////
0:         session.sendAck(ack);
/////////////////////////////////////////////////////////////////////////
1:                     session.sendAck(ack,true);
/////////////////////////////////////////////////////////////////////////
0:                     session.sendAck(ack,true);
commit:ab3b155
/////////////////////////////////////////////////////////////////////////
0:         MessageAck ack = new MessageAck(md,MessageAck.INDIVIDUAL_ACK_TYPE,1);
commit:4ddb3e3
/////////////////////////////////////////////////////////////////////////
0:         if (session.isClientAcknowledge()) {
0:         }else if (session.isIndividualAcknowledge()) {
1:             m.setAcknowledgeCallback(new Callback() {
1:                 public void execute() throws Exception {
1:                     session.checkClosed();
0:                     acknowledge(md);
0:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:             } else if (session.isClientAcknowledge()||session.isIndividualAcknowledge()) {
0:             } 
/////////////////////////////////////////////////////////////////////////
0:     
1:     void acknowledge(MessageDispatch md) throws JMSException {
0:         MessageAck ack = new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:         session.asyncSendPacket(ack);
1:         synchronized(deliveredMessages){
0:             deliveredMessages.remove(md);
0:         }
0:     }
commit:2076f45
/////////////////////////////////////////////////////////////////////////
0:         if (session.isClientAcknowledge() || session.isIndividualAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
0:             } else if (session.isIndividualAcknowledge()){
0:             	MessageAck ack = new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                 session.asyncSendPacket(ack);
0:                 synchronized(deliveredMessages){
0: 	                deliveredMessages.remove(md);
0:                 }
0:             }
1:             else {
/////////////////////////////////////////////////////////////////////////
0:                                 if (session.isDupsOkAcknowledge() || session.isAutoAcknowledge() || session.isIndividualAcknowledge()) {
commit:b4c3a30
/////////////////////////////////////////////////////////////////////////
1:             if (prefetch < 0) {
1:                 throw new JMSException("Cannot have a prefetch size less than zero");
0:             }
commit:3eb0610
/////////////////////////////////////////////////////////////////////////
1:             synchronized(deliveredMessages) {
0:                 deliveredMessages.clear();
0:             }
commit:caf7a7c
/////////////////////////////////////////////////////////////////////////
1:                 synchronized(deliveredMessages) {
0:                     if (!deliveredMessages.isEmpty()) {
0:                         MessageDispatch md = deliveredMessages.getFirst();
0:                         ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:                         deliveredMessages.clear();
0:                         ackCounter = 0;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             synchronized(deliveredMessages) {
0:                 deliveredMessages.addFirst(md);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 synchronized (deliveredMessages) {
0:                     if (!deliveredMessages.isEmpty()) {
0:                         if (optimizeAcknowledge) {
0:                             if (deliveryingAcknowledgements.compareAndSet(
0:                                     false, true)) {
1:                                 ackCounter++;
0:                                 if (ackCounter >= (info
0:                                         .getCurrentPrefetchSize() * .65)) {
0:                                     MessageAck ack = new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                                     session.asyncSendPacket(ack);
0:                                     ackCounter = 0;
0:                                     deliveredMessages.clear();
0:                                 }
1:                                 deliveryingAcknowledgements.set(false);
0:                         } else {
0:                             MessageAck ack = new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                             session.asyncSendPacket(ack);
0:                             deliveredMessages.clear();
/////////////////////////////////////////////////////////////////////////
0:         synchronized(deliveredMessages) {
0:             if (deliveredMessages.isEmpty()) {
0:                 return;
0:             }
0:     
0:             // Acknowledge the last message.
0:             MessageDispatch lastMd = deliveredMessages.get(0);
0:             MessageAck ack = new MessageAck(lastMd, MessageAck.STANDARD_ACK_TYPE, deliveredMessages.size());
0:             if (session.isTransacted()) {
0:                 session.doStartTransaction();
0:                 ack.setTransactionId(session.getTransactionContext().getTransactionId());
0:             }
0:             session.asyncSendPacket(ack);
0:     
0:             // Adjust the counters
0:             deliveredCounter -= deliveredMessages.size();
0:             additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
0:     
0:             if (!session.isTransacted()) {
0:                 deliveredMessages.clear();
0:             }
0:         synchronized (deliveredMessages) {
0:             deliveredMessages.clear();
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     synchronized(deliveredMessages) {
0:                         for (int i = 0; (i < deliveredMessages.size()) && (i < ackCounter); i++) {
0:                             // ensure we don't filter this as a duplicate
0:                             MessageDispatch md = deliveredMessages.removeLast();
0:                             session.connection.rollbackDuplicate(this, md.getMessage());
0:                         }
0:             synchronized(deliveredMessages) {
0:                 if (deliveredMessages.isEmpty()) {
0:                     return;
0:                 }
0:     
0:                 // Only increase the redlivery delay after the first redelivery..
0:                 MessageDispatch lastMd = deliveredMessages.getFirst();
0:                 if (lastMd.getMessage().getRedeliveryCounter() > 0) {
0:                     redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
0:                 }
0:     
0:                     md.getMessage().onMessageRolledBack();
0:     
0:                 if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:                     && lastMd.getMessage().getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()) {
0:                     // We need to NACK the messages so that they get sent to the
0:                     // DLQ.
0:                     // Acknowledge the last message.
0:                     
0:                     MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());
0:                     session.asyncSendPacket(ack);
0:                     // ensure we don't filter this as a duplicate
0:                     session.connection.rollbackDuplicate(this, lastMd.getMessage());
0:                     // Adjust the window size.
0:                     additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());
0:                     redeliveryDelay = 0;
0:                     
0:                     MessageAck ack = new MessageAck(lastMd, MessageAck.REDELIVERED_ACK_TYPE, deliveredMessages.size());
0:                     session.asyncSendPacket(ack);
0:     
0:                     // stop the delivery of messages.
0:                     unconsumedMessages.stop();
0:     
0:                     for (Iterator iter = deliveredMessages.iterator(); iter.hasNext();) {
0:                         MessageDispatch md = (MessageDispatch)iter.next();
0:                         unconsumedMessages.enqueueFirst(md);
0:                     }
0:     
0:                     if (redeliveryDelay > 0) {
0:                         // Start up the delivery again a little later.
0:                         Scheduler.executeAfterDelay(new Runnable() {
0:                             public void run() {
0:                                 try {
0:                                     if (started.get()) {
0:                                         start();
0:                                     }
0:                                 } catch (JMSException e) {
0:                                     session.connection.onAsyncException(e);
0:                                 }
0:                             }
0:                         }, redeliveryDelay);
0:                     } else {
0:                         start();
0:                     }
0:     
0:                 deliveredCounter -= deliveredMessages.size();
0:                 deliveredMessages.clear();
commit:a401575
/////////////////////////////////////////////////////////////////////////
0:                                 boolean expired=message.isExpired();
0:                                 if(!expired){
0:                                     listener.onMessage(message);
0:                                 }
0:                                 afterMessageIsConsumed(md,expired);
commit:cbaa58b
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList <MessageDispatch>deliveredMessages = new LinkedList<MessageDispatch>();
/////////////////////////////////////////////////////////////////////////
0:             session.redispatch(this,unconsumedMessages);
/////////////////////////////////////////////////////////////////////////
0:                     MessageDispatch md=deliveredMessages.getFirst();
/////////////////////////////////////////////////////////////////////////
0:     public void dispose() throws JMSException{
0:         if(!unconsumedMessages.isClosed()){
0:             deliverAcks();// only processes optimized acknowledgements
0:             if(executorService!=null){
0:                 try{
0:                     executorService.awaitTermination(60,TimeUnit.SECONDS);
0:                 }catch(InterruptedException e){
0:             if((session.isTransacted()||session.isDupsOkAcknowledge())){
0:             if (session.isClientAcknowledge()) {
0:                 if(!this.info.isBrowser()){
1:                     // rollback duplicates that aren't acknowledged
0:                     for(MessageDispatch old:deliveredMessages){
0:                         session.connection.rollbackDuplicate(this,old.getMessage());
0:                     }
0:                 }
0:             }
0:             List<MessageDispatch> list=unconsumedMessages.removeAll();
0:             if(!this.info.isBrowser()){
0:                 for(MessageDispatch old:list){
0:                     // ensure we don't filter this as a duplicate
0:                     session.connection.rollbackDuplicate(this,old.getMessage());
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         MessageDispatch lastMd = deliveredMessages.get(0);
/////////////////////////////////////////////////////////////////////////
0:                 if(!this.info.isBrowser()){
0:                     for(int i=0;(i<deliveredMessages.size())&&(i<ackCounter);i++){
0:                         // ensure we don't filter this as a duplicate
0:                         MessageDispatch md=deliveredMessages.removeLast();
0:                         session.connection.rollbackDuplicate(this,md.getMessage());
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                 MessageDispatch lastMd=deliveredMessages.get(0);
0:                 //ensure we don't filter this as a duplicate
0:                 session.connection.rollbackDuplicate(this,lastMd.getMessage()); 
/////////////////////////////////////////////////////////////////////////
0:             session.redispatch(this,unconsumedMessages);
0:     public void dispatch(MessageDispatch md){
0:         MessageListener listener=this.messageListener;
0:         try{
0:                 if(clearDispatchList){
0:                     clearDispatchList=false;
0:                     List<MessageDispatch> list=unconsumedMessages.removeAll();
0:                     if(!this.info.isBrowser()){
0:                         for(MessageDispatch old:list){
0:                             // ensure we don't filter this as a duplicate
0:                             session.connection.rollbackDuplicate(this,old.getMessage());
0:                         }
0:                     }
0:                 if(!unconsumedMessages.isClosed()){
0:                     if(this.info.isBrowser() || session.connection.isDuplicate(this,md.getMessage())==false){
0:                         if(listener!=null&&unconsumedMessages.isRunning()){
0:                             ActiveMQMessage message=createActiveMQMessage(md);
0:                             beforeMessageIsConsumed(md);
0:                             try{
0:                                 listener.onMessage(message);
0:                                 afterMessageIsConsumed(md,false);
0:                             }catch(RuntimeException e){
0:                                 if(session.isDupsOkAcknowledge()||session.isAutoAcknowledge()){
0:                                     // Redeliver the message
0:                                 }else{
0:                                     // Transacted or Client ack: Deliver the next message.
0:                                     afterMessageIsConsumed(md,false);
0:                                 }
0:                                 log.error("Exception while processing message: "+e,e);
0:                             }
0:                         }else{
0:                             unconsumedMessages.enqueue(md);
0:                             if(availableListener!=null){
0:                                 availableListener.onMessageAvailable(this);
0:                             }
0:                         }
0:                     }else {
0:                         //ignore duplicate
0:                         if (log.isDebugEnabled()) {
0:                             log.debug("Ignoring Duplicate: " + md.getMessage());
0:                         }
0:                         ackLater(md,MessageAck.STANDARD_ACK_TYPE);
0:                     }
0:                 }
0:             if(++dispatchedCount%1000==0){
1:                 Thread.yield();
0:         }catch(Exception e){
0:             session.connection.onAsyncException(e);
commit:d7a9feb
/////////////////////////////////////////////////////////////////////////
0: 	                        log.error("Exception while processing message: " + e, e);
commit:e78a6f7
/////////////////////////////////////////////////////////////////////////
0:     private int dispatchedCount = 0;
/////////////////////////////////////////////////////////////////////////
0:             if (++dispatchedCount%1000==0) {
0:                 dispatchedCount=0;
0:             Thread.yield();
0:             }
commit:fa8b889
/////////////////////////////////////////////////////////////////////////
0:                             if(ackCounter>=(info.getCurrentPrefetchSize()*.65)){
commit:2c64bf9
/////////////////////////////////////////////////////////////////////////
0:                             if(ackCounter>=(info.getCurrentPrefetchSize()*.50)){
commit:6eaea6f
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.*;
/////////////////////////////////////////////////////////////////////////
1:     private boolean optimizeAcknowledge;
0:     private AtomicBoolean deliveryingAcknowledgements = new AtomicBoolean();
0:     private ExecutorService executorService = null;
/////////////////////////////////////////////////////////////////////////
1:         this.info.setCurrentPrefetchSize(prefetch);
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge=session.connection.isOptimizeAcknowledge()&&session.isAutoAcknowledge()
0:                         &&!info.isBrowser();
1:         this.info.setOptimizedAcknowledge(this.optimizeAcknowledge);
/////////////////////////////////////////////////////////////////////////
0:         MessageAck ack=null;
0:         if(deliveryingAcknowledgements.compareAndSet(false,true)){
0:             if(this.optimizeAcknowledge){
0:                     ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:             if(ack!=null){
0:                 final MessageAck ackToSend=ack;
0:                 if(executorService==null){
0:                     executorService=Executors.newSingleThreadExecutor();
0:                 }
0:                 executorService.submit(new Runnable(){
0:                     public void run(){
0:                         try{
0:                             session.asyncSendPacket(ackToSend);
0:                         }catch(JMSException e){
0:                             log.error("Failed to delivered acknowledgements",e);
0:                         }finally{
1:                             deliveryingAcknowledgements.set(false);
0:                         }
0:                     }
0:                 });
0:             }else{
1:                 deliveryingAcknowledgements.set(false);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (executorService!=null){
0:                 executorService.shutdown();
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (optimizeAcknowledge && !value){
0:         optimizeAcknowledge=value;
1:         this.info.setCurrentPrefetchSize(prefetch);
/////////////////////////////////////////////////////////////////////////
0:                     if(optimizeAcknowledge){
0:                         if(deliveryingAcknowledgements.compareAndSet(false,true)){
0:                             if(ackCounter>=(info.getCurrentPrefetchSize()*.75)){
0:                                 MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                             deliveryingAcknowledgements.set(false);
0:                     }else{
0:                         MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                         session.asyncSendPacket(ack);
0:                         deliveredMessages.clear();
/////////////////////////////////////////////////////////////////////////
0:             if(optimizeAcknowledge){
0:                 // remove messages read but not acked at the broker yet through optimizeAcknowledge
0:                 for(int i=0;(i<deliveredMessages.size())&&(i<ackCounter);i++){
0:                     deliveredMessages.removeLast();
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean optimizeAcknowledge = new AtomicBoolean();
0:    
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge.set(session.connection.isOptimizeAcknowledge()&&session.isAutoAcknowledge()
0:                         &&!info.isBrowser());
0:         this.info.setOptimizedAcknowledge(this.optimizeAcknowledge.get());
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0:     void clearMessagesInProgress(){
0:     
0:     void deliverAcks(){
0:         synchronized(optimizeAcknowledge){
0:             if(this.optimizeAcknowledge.get()){
0:                 if(!deliveredMessages.isEmpty()){
0:                     MessageDispatch md=(MessageDispatch) deliveredMessages.getFirst();
0:                     MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                     try{
0:                         session.asyncSendPacket(ack);
0:                     }catch(JMSException e){
0:                         log.error("Failed to delivered acknowledgements",e);
0:                     }
0:                     deliveredMessages.clear();
0:                     ackCounter=0;
0:                 }
0:             }
0:         }
0:     }
0:             deliverAcks();//only processes optimized acknowledgements
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void setOptimizeAcknowledge(boolean value){
0:         synchronized(optimizeAcknowledge){
1:             deliverAcks();
0:             optimizeAcknowledge.set(value);
0:         }
0:     }
0:     
0:     protected void setPrefetchSize(int prefetch){
1:         deliverAcks();
0:         this.info.setPrefetchSize(prefetch);
0:     }
/////////////////////////////////////////////////////////////////////////
0:                     synchronized(optimizeAcknowledge){
0:                         if(this.optimizeAcknowledge.get()){
0:                             ackCounter++;
0:                             if(ackCounter>=(info.getPrefetchSize()*.75)){
0:                                 MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,ackCounter);
0:                                 session.asyncSendPacket(ack);
0:                                 ackCounter=0;
0:                                 deliveredMessages.clear();
0:                             }
0:                         }else{
0:                             MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
/////////////////////////////////////////////////////////////////////////
0:             synchronized(optimizeAcknowledge){
0:                 if(optimizeAcknowledge.get()){
0:                     // remove messages read but not acked at the broker yet through optimizeAcknowledge
0:                     for(int i=0;(i<deliveredMessages.size())&&(i<ackCounter);i++){
0:                         deliveredMessages.removeLast();
0:                     }
commit:52ee976
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge=session.connection.isOptimizeAcknowledge()&&session.isAutoAcknowledge()
0:                         &&!info.isDurable()&&!info.getDestination().isQueue();
0:         if(session.connection.isStarted())
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void clearMessagesInProgress(){
0:         unconsumedMessages.clear();
0:     }
commit:00d054a
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge=session.connection.isOptimizeAcknowledge()&&session.isAutoAcknowledge();
commit:d964145
/////////////////////////////////////////////////////////////////////////
0:     private int ackCounter = 0;
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizeAcknowledge;
/////////////////////////////////////////////////////////////////////////
0:         this.optimizeAcknowledge=session.connection.isOptimizeAcknowledge()&&!info.isDurable()
0:                         &&!info.getDestination().isQueue()
0:                         &&session.isAutoAcknowledge();
/////////////////////////////////////////////////////////////////////////
0:     private void afterMessageIsConsumed(MessageDispatch md,boolean messageExpired) throws JMSException{
0:         if(unconsumedMessages.isClosed())
0:         if(messageExpired){
0:             ackLater(md,MessageAck.DELIVERED_ACK_TYPE);
0:         }else{
0:             if(session.isTransacted()){
0:                 ackLater(md,MessageAck.DELIVERED_ACK_TYPE);
0:             }else if(session.isAutoAcknowledge()){
0:                 if(!deliveredMessages.isEmpty()){
0:                     if(this.optimizeAcknowledge){
0:                         ackCounter++;
0:                         if(ackCounter>=(info.getPrefetchSize()*.75)){
0:                             MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,ackCounter);
0:                             session.asyncSendPacket(ack);
0:                             ackCounter=0;
0:                             deliveredMessages.clear();
0:                         }
0:                     }else{
0:                         MessageAck ack=new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,deliveredMessages.size());
0:                         session.asyncSendPacket(ack);
0:                         deliveredMessages.clear();
0:                     }
0:             }else if(session.isDupsOkAcknowledge()){
0:                 ackLater(md,MessageAck.STANDARD_ACK_TYPE);
0:             }else if(session.isClientAcknowledge()){
0:                 ackLater(md,MessageAck.DELIVERED_ACK_TYPE);
0:             }else{
/////////////////////////////////////////////////////////////////////////
0:     public void rollback() throws JMSException{
0:         synchronized(unconsumedMessages.getMutex()){
0:             if(optimizeAcknowledge){
0:                
0:                 // remove messages read but not acked at the broker yet through optimizeAcknowledge  
0:                 for(int i=0;(i<deliveredMessages.size())&&(i<ackCounter);i++){
0:                     deliveredMessages.removeLast();
0:                 }
0:             }
0:             if(deliveredMessages.isEmpty())
0:             if(rollbackCounter>redeliveryPolicy.getMaximumRedeliveries()){
0:                 MessageDispatch lastMd=(MessageDispatch) deliveredMessages.get(0);
0:                 MessageAck ack=new MessageAck(lastMd,MessageAck.POSION_ACK_TYPE,deliveredMessages.size());
0:                 additionalWindowSize=Math.max(0,additionalWindowSize-deliveredMessages.size());
0:                 rollbackCounter=0;
0:                 redeliveryDelay=0;
0:             }else{
0:                 if(redeliveryDelay==0){
0:                     redeliveryDelay=redeliveryPolicy.getInitialRedeliveryDelay();
0:                 }else{
0:                     if(redeliveryPolicy.isUseExponentialBackOff())
0:                         redeliveryDelay*=redeliveryPolicy.getBackOffMultiplier();
0:                 Scheduler.executeAfterDelay(new Runnable(){
0:                     public void run(){
0:                         try{
0:                             if(started.get())
0:                         }catch(JMSException e){
0:                 },redeliveryDelay);
0:                 for(Iterator iter=deliveredMessages.iterator();iter.hasNext();){
0:                     MessageDispatch md=(MessageDispatch) iter.next();
0:             deliveredCounter-=deliveredMessages.size();
0:         if(messageListener!=null){
commit:bf8f99b
/////////////////////////////////////////////////////////////////////////
commit:641140e
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQMessage m = (ActiveMQMessage) md.getMessage().copy();
/////////////////////////////////////////////////////////////////////////
0:         System.err.println(this + " ACKING " + lastMd.getMessage().getMessageId() + " size = " + deliveredMessages.size());
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1ab76f7
/////////////////////////////////////////////////////////////////////////
1:             SelectorParser.parse(selector);
1:             SelectorParser.parse(this.info.getSelector());
author:James Strachan
-------------------------------------------------------------------------------
commit:5829d70
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(getConsumerId() + " received expired message: " + md);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(getConsumerId() + " received message: " + md);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.error(getConsumerId() + " failed to delivered acknowledgements", e);
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.error(getConsumerId() + " Exception while processing message: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug(getConsumerId() + " Ignoring Duplicate: " + md.getMessage());
commit:fba0742
/////////////////////////////////////////////////////////////////////////
1:      * @param messageListener
0:             String name, String selector, int prefetch,
0:             int maximumPendingMessageCount, boolean noLocal, boolean browser,
1:             boolean dispatchAsync, MessageListener messageListener) throws JMSException {
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (messageListener != null) {
1:             setMessageListener(messageListener);
0:         }
commit:3d862f0
/////////////////////////////////////////////////////////////////////////
1:         this.info.setExclusive(this.session.connection.isExclusiveConsumer());
commit:419ed2e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.IllegalStateException;
0: import javax.jms.*;
0: import javax.jms.Message;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
0:     private boolean clearDispatchList;
/////////////////////////////////////////////////////////////////////////
0:         // we are called from inside the transport reconnection logic
0:         // which involves us clearing all the connections' consumers
0:         // dispatch lists and clearing them
0:         // so rather than trying to grab a mutex (which could be already
0:         // owned by the message listener calling the send) we will just set
0:         // a flag so that the list can be cleared as soon as the
0:         // dispatch thread is ready to flush the dispatch list
0:         clearDispatchList= true;
/////////////////////////////////////////////////////////////////////////
0:                 if (clearDispatchList) {
0:                     // we are reconnecting so lets flush the in progress messages
0:                     clearDispatchList = false;
0:                     unconsumedMessages.clear();
0:                 }
0: 
0:                 if (!unconsumedMessages.isClosed()) {
commit:86faaef
/////////////////////////////////////////////////////////////////////////
1:     private MessageTransformer transformer;
0: 
/////////////////////////////////////////////////////////////////////////
1:         setTransformer(session.getTransformer());
/////////////////////////////////////////////////////////////////////////
1:     public MessageTransformer getTransformer() {
1:         return transformer;
0:     }
0: 
1:     /**
0:      * Sets the transformer used to transform messages before they are sent on to the JMS bus
1:      */
1:     public void setTransformer(MessageTransformer transformer) {
1:         this.transformer = transformer;
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQMessage createActiveMQMessage(final MessageDispatch md) throws JMSException {
1:         if (transformer != null) {
1:             Message transformedMessage = transformer.consumerTransform(session, this, m);
1:             if (transformedMessage != null) {
1:                 m = ActiveMQMessageTransformation.transformMessage(transformedMessage, session.connection);
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:             this.session.asyncSendPacket(info.createRemoveCommand());
commit:d96a43d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6e3a634
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
1:         if (info.getPrefetchSize() == 0) {
0:             throw new JMSException("Illegal prefetch size of zero. This setting is not supported for asynchronous consumers please set a value of at least 1");
0:         }
/////////////////////////////////////////////////////////////////////////
0:         sendPullCommand();
/////////////////////////////////////////////////////////////////////////
0:         sendPullCommand();
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
0:      * If we have a zero prefetch specified then send a pull command to the broker to pull a message
0:      * we are about to receive
0:      *
1:      */
0:     protected void sendPullCommand() throws JMSException {
0:         if (info.getPrefetchSize() == 0) {
1:             MessagePull messagePull = new MessagePull();
1:             messagePull.configure(info);
1:             session.asyncSendPacket(messagePull);
0:         }
0:     }
commit:fb6af07
/////////////////////////////////////////////////////////////////////////
0:                         log.warn("Exception while processing message: " + e, e);
commit:4c4f86a
/////////////////////////////////////////////////////////////////////////
0:                 redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
commit:d9b9427
/////////////////////////////////////////////////////////////////////////
0:                     md.getMessage().onMessageRolledBack();
commit:bed10aa
/////////////////////////////////////////////////////////////////////////
0:      * @param maximumPendingMessageCount TODO
0:      * @param value
0:             String name, String selector, int prefetch, int maximumPendingMessageCount, boolean noLocal, boolean browser, boolean dispatchAsync)
/////////////////////////////////////////////////////////////////////////
1:         this.info.setMaximumPendingMessageLimit(maximumPendingMessageCount);
commit:f0454b1
/////////////////////////////////////////////////////////////////////////
1:     private RedeliveryPolicy redeliveryPolicy;
0: 
/////////////////////////////////////////////////////////////////////////
0:         this.redeliveryPolicy = session.connection.getRedeliveryPolicy();
/////////////////////////////////////////////////////////////////////////
1:     public RedeliveryPolicy getRedeliveryPolicy() {
1:         return redeliveryPolicy;
0:     }
0: 
1:     /**
1:      * Sets the redelivery policy used when messages are redelivered
0:      */
1:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
1:         this.redeliveryPolicy = redeliveryPolicy;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:c8d74e7
/////////////////////////////////////////////////////////////////////////
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	public boolean isInUse(ActiveMQTempDestination destination) {
0: 		return info.getDestination().equals(destination);
0: 	}  	
commit:979c5d5
/////////////////////////////////////////////////////////////////////////
0:             if(redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:             		&& rollbackCounter>redeliveryPolicy.getMaximumRedeliveries()){
commit:2510b08
/////////////////////////////////////////////////////////////////////////
0:             // yeild here so that a thread trying to stop unconsumedMessages has 
0:             // a chance of getting prioritized head of this thread that is in a dispatch loop.
0:             Thread.yield();            
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:87d15d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.info.setSelector(null);
/////////////////////////////////////////////////////////////////////////
1:             // Validate the selector
0:             this.selector = selector;
1:         } else if (info.getSelector() != null) {
1:             // Validate the selector
0:             new SelectorParser().parse(this.info.getSelector());
1:             this.selector = this.info.getSelector();
1:             this.selector = null;
author:Gregory John Wilkins
-------------------------------------------------------------------------------
commit:6a70920
/////////////////////////////////////////////////////////////////////////
0:                     unconsumedMessages.enqueue(md);
============================================================================