1:0da68b4: /**
1:0da68b4:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0da68b4:  * contributor license agreements.  See the NOTICE file distributed with
1:0da68b4:  * this work for additional information regarding copyright ownership.
1:0da68b4:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:0da68b4:  * (the "License"); you may not use this file except in compliance with
1:0da68b4:  * the License.  You may obtain a copy of the License at
1:0da68b4:  *
1:0da68b4:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0da68b4:  *
1:0da68b4:  * Unless required by applicable law or agreed to in writing, software
1:0da68b4:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0da68b4:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0da68b4:  * See the License for the specific language governing permissions and
1:0da68b4:  * limitations under the License.
1:0da68b4:  */
1:0da68b4: package org.apache.activemq.broker.region;
1:63e3f41: 
1:4b27e76: import java.io.IOException;
1:d55a392: import java.util.List;
1:2769298: import java.util.concurrent.atomic.AtomicBoolean;
1:b9fd189: 
1:a0d2282: import javax.jms.ResourceAllocationException;
1:b9fd189: 
1:9ad6c08: import org.apache.activemq.advisory.AdvisorySupport;
1:8d11f07: import org.apache.activemq.broker.Broker;
1:13829ef: import org.apache.activemq.broker.BrokerService;
1:634da7a: import org.apache.activemq.broker.ConnectionContext;
1:9ad6c08: import org.apache.activemq.broker.ProducerBrokerExchange;
1:0d85869: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1:1b6d397: import org.apache.activemq.broker.region.policy.SlowConsumerStrategy;
1:8d11f07: import org.apache.activemq.command.ActiveMQDestination;
1:9ad6c08: import org.apache.activemq.command.ActiveMQTopic;
1:9ad6c08: import org.apache.activemq.command.Message;
1:b07f31e: import org.apache.activemq.command.MessageAck;
1:f9d5449: import org.apache.activemq.command.MessageDispatchNotification;
1:634da7a: import org.apache.activemq.command.ProducerInfo;
1:ed3f61a: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:ed3f61a: import org.apache.activemq.security.SecurityContext;
1:9ad6c08: import org.apache.activemq.state.ProducerState;
1:8d11f07: import org.apache.activemq.store.MessageStore;
1:ed3f61a: import org.apache.activemq.thread.Scheduler;
1:8d11f07: import org.apache.activemq.usage.MemoryUsage;
1:8d11f07: import org.apache.activemq.usage.SystemUsage;
1:cdc2fd3: import org.apache.activemq.usage.Usage;
1:8bf987b: import org.slf4j.Logger;
1:0d85869: 
1:0da68b4: /**
1:b5a1916:  *
1:0da68b4:  */
1:0da68b4: public abstract class BaseDestination implements Destination {
1:cdc2fd3:     /**
1:48764be:      * The maximum number of messages to page in to the destination from
1:48764be:      * persistent storage
1:cdc2fd3:      */
1:63e3f41:     public static final int MAX_PAGE_SIZE = 200;
1:63e3f41:     public static final int MAX_BROWSE_PAGE_SIZE = MAX_PAGE_SIZE * 2;
1:48764be:     public static final long EXPIRE_MESSAGE_PERIOD = 30 * 1000;
1:2705e36:     public static final long DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC = 60 * 1000;
1:3ddb71c:     public static final int MAX_PRODUCERS_TO_AUDIT = 64;
1:97c127d:     public static final int MAX_AUDIT_DEPTH = 10000;
1:83c3dca: 
1:2769298:     protected final AtomicBoolean started = new AtomicBoolean();
1:8d11f07:     protected final ActiveMQDestination destination;
1:8d11f07:     protected final Broker broker;
1:8d11f07:     protected final MessageStore store;
1:13829ef:     protected SystemUsage systemUsage;
1:13829ef:     protected MemoryUsage memoryUsage;
1:785454a:     private boolean producerFlowControl = true;
1:fe63c29:     private boolean alwaysRetroactive = false;
1:01b1f7f:     protected long lastBlockedProducerWarnTime = 0l;
1:48764be:     protected long blockedProducerWarningInterval = DEFAULT_BLOCKED_PRODUCER_WARNING_INTERVAL;
1:8d11f07: 
1:63e3f41:     private int maxProducersToAudit = 1024;
1:63e3f41:     private int maxAuditDepth = 2048;
1:63e3f41:     private boolean enableAudit = true;
1:63e3f41:     private int maxPageSize = MAX_PAGE_SIZE;
1:63e3f41:     private int maxBrowsePageSize = MAX_BROWSE_PAGE_SIZE;
1:63e3f41:     private boolean useCache = true;
1:63e3f41:     private int minimumMessageSize = 1024;
1:63e3f41:     private boolean lazyDispatch = false;
1:cdc2fd3:     private boolean advisoryForSlowConsumers;
1:db1f6fe:     private boolean advisoryForFastProducers;
1:cdc2fd3:     private boolean advisoryForDiscardingMessages;
1:cdc2fd3:     private boolean advisoryWhenFull;
1:cdc2fd3:     private boolean advisoryForDelivery;
1:cdc2fd3:     private boolean advisoryForConsumed;
1:9ad6c08:     private boolean sendAdvisoryIfNoConsumers;
1:edacc2a:     private boolean includeBodyForAdvisory;
1:634da7a:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:13829ef:     protected final BrokerService brokerService;
1:dfcf776:     protected final Broker regionBroker;
1:0d85869:     protected DeadLetterStrategy deadLetterStrategy = DEFAULT_DEAD_LETTER_STRATEGY;
1:c6a485f:     protected long expireMessagesPeriod = EXPIRE_MESSAGE_PERIOD;
1:c6a485f:     private int maxExpirePageSize = MAX_BROWSE_PAGE_SIZE;
1:785454a:     protected int cursorMemoryHighWaterMark = 70;
1:a0d2282:     protected int storeUsageHighWaterMark = 100;
1:1b6d397:     private SlowConsumerStrategy slowConsumerStrategy;
1:00879cf:     private boolean prioritizedMessages;
1:b9fd189:     private long inactiveTimeoutBeforeGC = DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
1:2705e36:     private boolean gcIfInactive;
1:d55a392:     private boolean gcWithNetworkConsumers;
1:2705e36:     private long lastActiveTime=0l;
1:c1da3ac:     private boolean reduceMemoryFootprint = false;
1:ed3f61a:     protected final Scheduler scheduler;
1:b5a1916:     private boolean disposed = false;
1:f4d4c3b:     private boolean doOptimzeMessageStorage = true;
1:ca83305:     /*
1:ca83305:      * percentage of in-flight messages above which optimize message store is disabled
1:ca83305:      */
1:ca83305:     private int optimizeMessageStoreInFlightLimit = 10;
1:266d23e:     private boolean persistJMSRedelivered;
1:63e3f41: 
1:8d11f07:     /**
1:254d920:      * @param brokerService
1:63e3f41:      * @param store
1:8d11f07:      * @param destination
1:8d11f07:      * @param parentStats
1:63e3f41:      * @throws Exception
1:8d11f07:      */
1:48764be:     public BaseDestination(BrokerService brokerService, MessageStore store, ActiveMQDestination destination, DestinationStatistics parentStats) throws Exception {
1:13829ef:         this.brokerService = brokerService;
1:63e3f41:         this.broker = brokerService.getBroker();
1:63e3f41:         this.store = store;
1:63e3f41:         this.destination = destination;
1:8d11f07:         // let's copy the enabled property from the parent DestinationStatistics
1:8d11f07:         this.destinationStatistics.setEnabled(parentStats.isEnabled());
1:63e3f41:         this.destinationStatistics.setParent(parentStats);
1:db3a021:         this.systemUsage = new SystemUsage(brokerService.getProducerSystemUsage(), destination.toString());
1:db3a021:         this.memoryUsage = this.systemUsage.getMemoryUsage();
1:8d11f07:         this.memoryUsage.setUsagePortion(1.0f);
1:dfcf776:         this.regionBroker = brokerService.getRegionBroker();
1:ed3f61a:         this.scheduler = brokerService.getBroker().getScheduler();
1:dfcf776:     }
1:f92d45b: 
1:83c3dca:     /**
1:83c3dca:      * initialize the destination
1:63e3f41:      *
1:83c3dca:      * @throws Exception
1:83c3dca:      */
1:13829ef:     public void initialize() throws Exception {
1:8d11f07:         // Let the store know what usage manager we are using so that he can
1:8d11f07:         // flush messages to disk when usage gets high.
1:8d11f07:         if (store != null) {
1:8d11f07:             store.setMemoryUsage(this.memoryUsage);
1:63e3f41:         }
1:8d11f07:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @return the producerFlowControl
1:1ee0017:      */
1:b9fd189:     @Override
1:0da68b4:     public boolean isProducerFlowControl() {
1:1ee0017:         return producerFlowControl;
1:8d11f07:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @param producerFlowControl the producerFlowControl to set
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public void setProducerFlowControl(boolean producerFlowControl) {
1:1ee0017:         this.producerFlowControl = producerFlowControl;
1:1ee0017:     }
1:63e3f41: 
1:b9fd189:     @Override
1:fe63c29:     public boolean isAlwaysRetroactive() {
1:17995e6:         return alwaysRetroactive;
1:1ee0017:     }
1:63e3f41: 
1:b9fd189:     @Override
1:fe63c29:     public void setAlwaysRetroactive(boolean alwaysRetroactive) {
1:17995e6:         this.alwaysRetroactive = alwaysRetroactive;
1:0da68b4:     }
1:63e3f41: 
1:1ee0017:     /**
1:48764be:      * Set's the interval at which warnings about producers being blocked by
1:48764be:      * resource usage will be triggered. Values of 0 or less will disable
1:48764be:      * warnings
1:b5a1916:      *
1:48764be:      * @param blockedProducerWarningInterval the interval at which warning about
1:48764be:      *            blocked producers will be triggered.
1:48764be:      */
1:b9fd189:     @Override
1:48764be:     public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval) {
1:48764be:         this.blockedProducerWarningInterval = blockedProducerWarningInterval;
1:0da68b4:     }
1:47cfa55: 
1:48764be:     /**
1:b5a1916:      *
1:48764be:      * @return the interval at which warning about blocked producers will be
1:48764be:      *         triggered.
1:48764be:      */
1:b9fd189:     @Override
1:48764be:     public long getBlockedProducerWarningInterval() {
1:48764be:         return blockedProducerWarningInterval;
1:0da68b4:     }
1:4b27e76: 
1:48764be:     /**
1:1ee0017:      * @return the maxProducersToAudit
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public int getMaxProducersToAudit() {
1:1ee0017:         return maxProducersToAudit;
1:1ee0017:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @param maxProducersToAudit the maxProducersToAudit to set
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:1ee0017:         this.maxProducersToAudit = maxProducersToAudit;
1:1ee0017:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @return the maxAuditDepth
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public int getMaxAuditDepth() {
1:1ee0017:         return maxAuditDepth;
1:1ee0017:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @param maxAuditDepth the maxAuditDepth to set
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public void setMaxAuditDepth(int maxAuditDepth) {
1:1ee0017:         this.maxAuditDepth = maxAuditDepth;
1:1ee0017:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @return the enableAudit
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public boolean isEnableAudit() {
1:1ee0017:         return enableAudit;
1:1ee0017:     }
1:63e3f41: 
1:1ee0017:     /**
1:1ee0017:      * @param enableAudit the enableAudit to set
1:1ee0017:      */
1:b9fd189:     @Override
1:1ee0017:     public void setEnableAudit(boolean enableAudit) {
1:1ee0017:         this.enableAudit = enableAudit;
1:13829ef:     }
1:63e3f41: 
1:b9fd189:     @Override
1:63e3f41:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:634da7a:         destinationStatistics.getProducers().increment();
1:2705e36:         this.lastActiveTime=0l;
1:634da7a:     }
1:dfcf776: 
1:b9fd189:     @Override
1:63e3f41:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:634da7a:         destinationStatistics.getProducers().decrement();
1:634da7a:     }
1:2705e36: 
1:b9fd189:     @Override
1:2705e36:     public void addSubscription(ConnectionContext context, Subscription sub) throws Exception{
1:2705e36:         destinationStatistics.getConsumers().increment();
1:2705e36:         this.lastActiveTime=0l;
1:2705e36:     }
1:2705e36: 
1:b9fd189:     @Override
1:2705e36:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception{
1:2705e36:         destinationStatistics.getConsumers().decrement();
1:d86c98a:         this.lastActiveTime=0l;
1:2705e36:     }
1:2705e36: 
1:63e3f41: 
1:b9fd189:     @Override
1:83c3dca:     public final MemoryUsage getMemoryUsage() {
1:8d11f07:         return memoryUsage;
1:8d11f07:     }
1:8d11f07: 
1:b9fd189:     @Override
1:b9fd189:     public void setMemoryUsage(MemoryUsage memoryUsage) {
1:b9fd189:         this.memoryUsage = memoryUsage;
1:8d11f07:     }
1:8d11f07: 
1:b9fd189:     @Override
1:8d11f07:     public DestinationStatistics getDestinationStatistics() {
1:8d11f07:         return destinationStatistics;
1:8d11f07:     }
1:8d11f07: 
1:b9fd189:     @Override
1:8d11f07:     public ActiveMQDestination getActiveMQDestination() {
1:8d11f07:         return destination;
1:8d11f07:     }
1:23cda2d: 
1:b9fd189:     @Override
1:8d11f07:     public final String getName() {
1:8d11f07:         return getActiveMQDestination().getPhysicalName();
1:8d11f07:     }
1:63e3f41: 
1:b9fd189:     @Override
1:8d11f07:     public final MessageStore getMessageStore() {
1:8d11f07:         return store;
1:83c3dca:     }
1:63e3f41: 
1:b9fd189:     @Override
1:254d920:     public boolean isActive() {
1:d86c98a:         boolean isActive = destinationStatistics.getConsumers().getCount() > 0 ||
1:d86c98a:                            destinationStatistics.getProducers().getCount() > 0;
1:d86c98a:         if (isActive && isGcWithNetworkConsumers() && destinationStatistics.getConsumers().getCount() > 0) {
1:d55a392:             isActive = hasRegularConsumers(getConsumers());
1:8d11f07:         }
1:d55a392:         return isActive;
1:1898869:     }
1:63e3f41: 
1:b9fd189:     @Override
1:d0f3d4d:     public int getMaxPageSize() {
1:d0f3d4d:         return maxPageSize;
1:d0f3d4d:     }
1:d0f3d4d: 
1:b9fd189:     @Override
1:d0f3d4d:     public void setMaxPageSize(int maxPageSize) {
1:d0f3d4d:         this.maxPageSize = maxPageSize;
1:6d0c552:     }
1:63e3f41: 
1:b9fd189:     @Override
1:47cfa55:     public int getMaxBrowsePageSize() {
1:a3a8c1c:         return this.maxBrowsePageSize;
1:47cfa55:     }
1:47cfa55: 
1:b9fd189:     @Override
1:47cfa55:     public void setMaxBrowsePageSize(int maxPageSize) {
1:47cfa55:         this.maxBrowsePageSize = maxPageSize;
1:63e3f41:     }
1:6d0c552: 
1:c6a485f:     public int getMaxExpirePageSize() {
1:c6a485f:         return this.maxExpirePageSize;
1:47cfa55:     }
1:83c3dca: 
1:c6a485f:     public void setMaxExpirePageSize(int maxPageSize) {
1:48764be:         this.maxExpirePageSize = maxPageSize;
1:d0f3d4d:     }
1:8d11f07: 
1:c6a485f:     public void setExpireMessagesPeriod(long expireMessagesPeriod) {
1:c6a485f:         this.expireMessagesPeriod = expireMessagesPeriod;
1:13829ef:     }
1:8d11f07: 
1:c6a485f:     public long getExpireMessagesPeriod() {
1:c6a485f:         return expireMessagesPeriod;
1:fe63c29:     }
1:8d11f07: 
1:b9fd189:     @Override
1:6d0c552:     public boolean isUseCache() {
1:6d0c552:         return useCache;
1:6d0c552:     }
1:6d0c552: 
1:b9fd189:     @Override
1:6d0c552:     public void setUseCache(boolean useCache) {
1:6d0c552:         this.useCache = useCache;
1:6d0c552:     }
1:6d0c552: 
1:b9fd189:     @Override
1:6d0c552:     public int getMinimumMessageSize() {
1:6d0c552:         return minimumMessageSize;
1:6d0c552:     }
1:6d0c552: 
1:b9fd189:     @Override
1:6d0c552:     public void setMinimumMessageSize(int minimumMessageSize) {
1:6d0c552:         this.minimumMessageSize = minimumMessageSize;
1:044c07d:     }
1:044c07d: 
1:b9fd189:     @Override
1:044c07d:     public boolean isLazyDispatch() {
1:044c07d:         return lazyDispatch;
1:044c07d:     }
1:044c07d: 
1:b9fd189:     @Override
1:044c07d:     public void setLazyDispatch(boolean lazyDispatch) {
1:044c07d:         this.lazyDispatch = lazyDispatch;
1:63e3f41:     }
1:63e3f41: 
1:dfcf776:     protected long getDestinationSequenceId() {
1:dfcf776:         return regionBroker.getBrokerSequenceId();
1:dfcf776:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForSlowConsumers
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForSlowConsumers() {
1:cdc2fd3:         return advisoryForSlowConsumers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForSlowConsumers the advisoryForSlowConsumers to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForSlowConsumers(boolean advisoryForSlowConsumers) {
1:cdc2fd3:         this.advisoryForSlowConsumers = advisoryForSlowConsumers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForDiscardingMessages
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForDiscardingMessages() {
1:cdc2fd3:         return advisoryForDiscardingMessages;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:48764be:      * @param advisoryForDiscardingMessages the advisoryForDiscardingMessages to
1:48764be:      *            set
1:cdc2fd3:      */
1:63e3f41:     public void setAdvisoryForDiscardingMessages(boolean advisoryForDiscardingMessages) {
1:cdc2fd3:         this.advisoryForDiscardingMessages = advisoryForDiscardingMessages;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryWhenFull
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryWhenFull() {
1:cdc2fd3:         return advisoryWhenFull;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryWhenFull the advisoryWhenFull to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryWhenFull(boolean advisoryWhenFull) {
1:cdc2fd3:         this.advisoryWhenFull = advisoryWhenFull;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForDelivery
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForDelivery() {
1:cdc2fd3:         return advisoryForDelivery;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForDelivery the advisoryForDelivery to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForDelivery(boolean advisoryForDelivery) {
1:cdc2fd3:         this.advisoryForDelivery = advisoryForDelivery;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForConsumed
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForConsumed() {
1:cdc2fd3:         return advisoryForConsumed;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForConsumed the advisoryForConsumed to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForConsumed(boolean advisoryForConsumed) {
1:cdc2fd3:         this.advisoryForConsumed = advisoryForConsumed;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisdoryForFastProducers
1:cdc2fd3:      */
1:db1f6fe:     public boolean isAdvisoryForFastProducers() {
1:db1f6fe:         return advisoryForFastProducers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:db1f6fe:      * @param advisoryForFastProducers the advisdoryForFastProducers to set
1:cdc2fd3:      */
1:db1f6fe:     public void setAdvisoryForFastProducers(boolean advisoryForFastProducers) {
1:db1f6fe:         this.advisoryForFastProducers = advisoryForFastProducers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:9ad6c08:     public boolean isSendAdvisoryIfNoConsumers() {
1:9ad6c08:         return sendAdvisoryIfNoConsumers;
1:9ad6c08:     }
1:cdc2fd3: 
1:9ad6c08:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
1:9ad6c08:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
1:9ad6c08:     }
1:cdc2fd3: 
1:edacc2a:     public boolean isIncludeBodyForAdvisory() {
1:edacc2a:         return includeBodyForAdvisory;
1:edacc2a:     }
1:edacc2a: 
1:edacc2a:     public void setIncludeBodyForAdvisory(boolean includeBodyForAdvisory) {
1:edacc2a:         this.includeBodyForAdvisory = includeBodyForAdvisory;
1:edacc2a:     }
1:edacc2a: 
1:cdc2fd3:     /**
1:0d85869:      * @return the dead letter strategy
1:0d85869:      */
1:b9fd189:     @Override
1:0d85869:     public DeadLetterStrategy getDeadLetterStrategy() {
1:0d85869:         return deadLetterStrategy;
1:0d85869:     }
1:0d85869: 
1:0d85869:     /**
1:0d85869:      * set the dead letter strategy
1:63e3f41:      *
1:0d85869:      * @param deadLetterStrategy
1:0d85869:      */
1:0d85869:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
1:0d85869:         this.deadLetterStrategy = deadLetterStrategy;
1:0d85869:     }
1:785454a: 
1:b9fd189:     @Override
1:785454a:     public int getCursorMemoryHighWaterMark() {
1:785454a:         return this.cursorMemoryHighWaterMark;
1:785454a:     }
1:785454a: 
1:b9fd189:     @Override
1:785454a:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
1:785454a:         this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
1:785454a:     }
1:63e3f41: 
1:0d85869:     /**
1:cdc2fd3:      * called when message is consumed
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param messageReference
1:cdc2fd3:      */
1:b9fd189:     @Override
1:cdc2fd3:     public void messageConsumed(ConnectionContext context, MessageReference messageReference) {
1:cdc2fd3:         if (advisoryForConsumed) {
1:cdc2fd3:             broker.messageConsumed(context, messageReference);
1:cdc2fd3:         }
1:cdc2fd3:     }
1:63e3f41: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Called when message is delivered to the broker
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param messageReference
1:cdc2fd3:      */
1:b9fd189:     @Override
1:cdc2fd3:     public void messageDelivered(ConnectionContext context, MessageReference messageReference) {
1:552c0f0:         this.lastActiveTime = 0L;
1:63e3f41:         if (advisoryForDelivery) {
1:cdc2fd3:             broker.messageDelivered(context, messageReference);
1:cdc2fd3:         }
1:cdc2fd3:     }
1:63e3f41: 
1:cdc2fd3:     /**
1:48764be:      * Called when a message is discarded - e.g. running low on memory This will
1:48764be:      * happen only if the policy is enabled - e.g. non durable topics
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param messageReference
1:cdc2fd3:      */
1:b9fd189:     @Override
1:3e4fc0a:     public void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference) {
1:cdc2fd3:         if (advisoryForDiscardingMessages) {
1:3e4fc0a:             broker.messageDiscarded(context, sub, messageReference);
1:cdc2fd3:         }
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Called when there is a slow consumer
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param subs
1:cdc2fd3:      */
1:b9fd189:     @Override
1:cdc2fd3:     public void slowConsumer(ConnectionContext context, Subscription subs) {
1:63e3f41:         if (advisoryForSlowConsumers) {
1:cdc2fd3:             broker.slowConsumer(context, this, subs);
1:cdc2fd3:         }
1:1b6d397:         if (slowConsumerStrategy != null) {
1:1b6d397:             slowConsumerStrategy.slowConsumer(context, subs);
1:cdc2fd3:         }
1:fe63c29:     }
1:63e3f41: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Called to notify a producer is too fast
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param producerInfo
1:cdc2fd3:      */
1:b9fd189:     @Override
1:63e3f41:     public void fastProducer(ConnectionContext context, ProducerInfo producerInfo) {
1:db1f6fe:         if (advisoryForFastProducers) {
1:db1f6fe:             broker.fastProducer(context, producerInfo, getActiveMQDestination());
1:cdc2fd3:         }
1:cdc2fd3:     }
1:63e3f41: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Called when a Usage reaches a limit
1:63e3f41:      *
1:cdc2fd3:      * @param context
1:cdc2fd3:      * @param usage
1:cdc2fd3:      */
1:b9fd189:     @Override
1:17995e6:     public void isFull(ConnectionContext context, Usage<?> usage) {
1:63e3f41:         if (advisoryWhenFull) {
1:63e3f41:             broker.isFull(context, this, usage);
1:cdc2fd3:         }
1:cdc2fd3:     }
1:63e3f41: 
1:b9fd189:     @Override
1:4b27e76:     public void dispose(ConnectionContext context) throws IOException {
1:63e3f41:         if (this.store != null) {
1:e679067:             this.store.removeAllMessages(context);
1:63e3f41:             this.store.dispose(context);
1:63e3f41:         }
1:63e3f41:         this.destinationStatistics.setParent(null);
1:4b27e76:         this.memoryUsage.stop();
1:b5a1916:         this.disposed = true;
1:4b27e76:     }
1:cdc2fd3: 
1:b9fd189:     @Override
1:b5a1916:     public boolean isDisposed() {
1:b5a1916:         return this.disposed;
1:b5a1916:     }
1:cdc2fd3: 
1:9ad6c08:     /**
1:9ad6c08:      * Provides a hook to allow messages with no consumer to be processed in
1:9ad6c08:      * some way - such as to send to a dead letter queue or something..
1:9ad6c08:      */
1:27183f8:     protected void onMessageWithNoConsumers(ConnectionContext context, Message msg) throws Exception {
1:27183f8:         if (!msg.isPersistent()) {
1:9ad6c08:             if (isSendAdvisoryIfNoConsumers()) {
1:9ad6c08:                 // allow messages with no consumers to be dispatched to a dead
1:9ad6c08:                 // letter queue
1:9ad6c08:                 if (destination.isQueue() || !AdvisorySupport.isAdvisoryTopic(destination)) {
1:cdc2fd3: 
1:27183f8:                     Message message = msg.copy();
1:9ad6c08:                     // The original destination and transaction id do not get
1:9ad6c08:                     // filled when the message is first sent,
1:9ad6c08:                     // it is only populated if the message is routed to another
1:9ad6c08:                     // destination like the DLQ
1:9ad6c08:                     if (message.getOriginalDestination() != null) {
1:9ad6c08:                         message.setOriginalDestination(message.getDestination());
1:9ad6c08:                     }
1:9ad6c08:                     if (message.getOriginalTransactionId() != null) {
1:9ad6c08:                         message.setOriginalTransactionId(message.getTransactionId());
1:9ad6c08:                     }
1:8d11f07: 
1:9ad6c08:                     ActiveMQTopic advisoryTopic;
1:9ad6c08:                     if (destination.isQueue()) {
1:9ad6c08:                         advisoryTopic = AdvisorySupport.getNoQueueConsumersAdvisoryTopic(destination);
1:9ad6c08:                     } else {
1:9ad6c08:                         advisoryTopic = AdvisorySupport.getNoTopicConsumersAdvisoryTopic(destination);
1:9ad6c08:                     }
1:9ad6c08:                     message.setDestination(advisoryTopic);
1:9ad6c08:                     message.setTransactionId(null);
1:634da7a: 
1:9ad6c08:                     // Disable flow control for this since since we don't want
1:9ad6c08:                     // to block.
1:9ad6c08:                     boolean originalFlowControl = context.isProducerFlowControl();
1:f92d45b:                     try {
1:9ad6c08:                         context.setProducerFlowControl(false);
1:9ad6c08:                         ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:9ad6c08:                         producerExchange.setMutable(false);
1:9ad6c08:                         producerExchange.setConnectionContext(context);
1:9ad6c08:                         producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:9ad6c08:                         context.getBroker().send(producerExchange, message);
1:9ad6c08:                     } finally {
1:9ad6c08:                         context.setProducerFlowControl(originalFlowControl);
1:f92d45b:                     }
1:f92d45b: 
1:f92d45b:                 }
1:f92d45b:             }
1:9ad6c08:         }
1:9ad6c08:     }
1:634da7a: 
1:b9fd189:     @Override
1:48764be:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
1:9ad6c08:     }
1:634da7a: 
1:a0d2282:     public final int getStoreUsageHighWaterMark() {
1:a0d2282:         return this.storeUsageHighWaterMark;
1:9ad6c08:     }
1:1ee0017: 
1:a0d2282:     public void setStoreUsageHighWaterMark(int storeUsageHighWaterMark) {
1:a0d2282:         this.storeUsageHighWaterMark = storeUsageHighWaterMark;
1:9ad6c08:     }
1:0da68b4: 
1:0736953:     protected final void waitForSpace(ConnectionContext context,ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, String warning) throws IOException, InterruptedException, ResourceAllocationException {
1:0736953:         waitForSpace(context, producerBrokerExchange, usage, 100, warning);
1:d55a392:     }
1:0da68b4: 
1:0736953:     protected final void waitForSpace(ConnectionContext context, ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {
1:8ce0778:         if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
1:151e17a:             if (isFlowControlLogRequired()) {
1:151e17a:                 getLog().info("sendFailIfNoSpace, forcing exception on send, usage: {}: {}", usage, warning);
1:151e17a:             } else {
1:151e17a:                 getLog().debug("sendFailIfNoSpace, forcing exception on send, usage: {}: {}", usage, warning);
1:151e17a:             }
1:fb591e7:             throw new ResourceAllocationException(warning);
1:fb591e7:         }
1:8ce0778:         if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
1:a0d2282:             if (!usage.waitForSpace(systemUsage.getSendFailIfNoSpaceAfterTimeout(), highWaterMark)) {
1:151e17a:                 if (isFlowControlLogRequired()) {
1:151e17a:                     getLog().info("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: {}: {}", usage, warning);
1:151e17a:                 } else {
1:151e17a:                     getLog().debug("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: {}: {}", usage, warning);
1:151e17a:                 }
1:a0d2282:                 throw new ResourceAllocationException(warning);
1:1b6d397:             }
1:a0d2282:         } else {
1:a0d2282:             long start = System.currentTimeMillis();
1:0736953:             producerBrokerExchange.blockingOnFlowControl(true);
1:0736953:             destinationStatistics.getBlockedSends().increment();
1:a0d2282:             while (!usage.waitForSpace(1000, highWaterMark)) {
1:a0d2282:                 if (context.getStopping().get()) {
1:a0d2282:                     throw new IOException("Connection closed, send aborted.");
4:a0d2282:                 }
1:0da68b4: 
1:01b1f7f:                 if (isFlowControlLogRequired()) {
1:0608175:                     getLog().warn("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((System.currentTimeMillis() - start) / 1000))});
1:0608175:                 } else {
1:0608175:                     getLog().debug("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((System.currentTimeMillis() - start) / 1000))});
1:a0d2282:                 }
1:a0d2282:             }
1:0736953:             long finish = System.currentTimeMillis();
1:0736953:             long totalTimeBlocked = finish - start;
1:0736953:             destinationStatistics.getBlockedTime().addTime(totalTimeBlocked);
1:0736953:             producerBrokerExchange.incrementTimeBlocked(this,totalTimeBlocked);
1:0736953:             producerBrokerExchange.blockingOnFlowControl(false);
1:a0d2282:         }
1:a0d2282:     }
1:0da68b4: 
1:01b1f7f:     protected boolean isFlowControlLogRequired() {
1:01b1f7f:         boolean answer = false;
1:01b1f7f:         if (blockedProducerWarningInterval > 0) {
1:01b1f7f:             long now = System.currentTimeMillis();
1:01b1f7f:             if (lastBlockedProducerWarnTime + blockedProducerWarningInterval <= now) {
1:01b1f7f:                 lastBlockedProducerWarnTime = now;
1:01b1f7f:                 answer = true;
1:01b1f7f:             }
1:01b1f7f:         }
1:01b1f7f:         return answer;
1:01b1f7f:     }
1:01b1f7f: 
1:8bf987b:     protected abstract Logger getLog();
1:0da68b4: 
1:1b6d397:     public void setSlowConsumerStrategy(SlowConsumerStrategy slowConsumerStrategy) {
1:1b6d397:         this.slowConsumerStrategy = slowConsumerStrategy;
1:1b6d397:     }
1:00879cf: 
1:b9fd189:     @Override
1:383d12e:     public SlowConsumerStrategy getSlowConsumerStrategy() {
1:383d12e:         return this.slowConsumerStrategy;
1:383d12e:     }
1:00879cf: 
1:9ad6c08: 
1:b9fd189:     @Override
1:00879cf:     public boolean isPrioritizedMessages() {
1:00879cf:         return this.prioritizedMessages;
1:00879cf:     }
1:00879cf: 
1:00879cf:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:00879cf:         this.prioritizedMessages = prioritizedMessages;
1:03f38ae:         if (store != null) {
1:03f38ae:             store.setPrioritizedMessages(prioritizedMessages);
1:2705e36:         }
1:2705e36:     }
1:2705e36: 
1:2705e36:     /**
1:b9fd189:      * @return the inactiveTimeoutBeforeGC
1:2705e36:      */
1:b9fd189:     @Override
1:b9fd189:     public long getInactiveTimeoutBeforeGC() {
1:b9fd189:         return this.inactiveTimeoutBeforeGC;
1:00879cf:     }
1:2705e36: 
1:2705e36:     /**
1:b9fd189:      * @param inactiveTimeoutBeforeGC the inactiveTimeoutBeforeGC to set
1:2705e36:      */
1:b9fd189:     public void setInactiveTimeoutBeforeGC(long inactiveTimeoutBeforeGC) {
1:b9fd189:         this.inactiveTimeoutBeforeGC = inactiveTimeoutBeforeGC;
1:03f38ae:     }
1:2705e36: 
1:2705e36:     /**
1:2705e36:      * @return the gcIfInactive
1:2705e36:      */
1:2705e36:     public boolean isGcIfInactive() {
1:2705e36:         return this.gcIfInactive;
1:2705e36:     }
1:2705e36: 
1:2705e36:     /**
1:2705e36:      * @param gcIfInactive the gcIfInactive to set
1:2705e36:      */
1:2705e36:     public void setGcIfInactive(boolean gcIfInactive) {
1:2705e36:         this.gcIfInactive = gcIfInactive;
1:2705e36:     }
1:2705e36: 
1:d55a392:     /**
1:d55a392:      * Indicate if it is ok to gc destinations that have only network consumers
1:d55a392:      * @param gcWithNetworkConsumers
1:d55a392:      */
1:d55a392:     public void setGcWithNetworkConsumers(boolean gcWithNetworkConsumers) {
1:d55a392:         this.gcWithNetworkConsumers = gcWithNetworkConsumers;
1:d55a392:     }
1:9ad6c08: 
1:d55a392:     public boolean isGcWithNetworkConsumers() {
1:d55a392:         return gcWithNetworkConsumers;
1:d55a392:     }
1:9ad6c08: 
1:b9fd189:     @Override
1:2705e36:     public void markForGC(long timeStamp) {
1:2705e36:         if (isGcIfInactive() && this.lastActiveTime == 0 && isActive() == false
1:b9fd189:                 && destinationStatistics.messages.getCount() == 0 && getInactiveTimeoutBeforeGC() > 0l) {
1:2705e36:             this.lastActiveTime = timeStamp;
1:2705e36:         }
1:2705e36:     }
1:2705e36: 
1:b9fd189:     @Override
1:2705e36:     public boolean canGC() {
1:2705e36:         boolean result = false;
1:e415d29:         final long currentLastActiveTime = this.lastActiveTime;
1:e415d29:         if (isGcIfInactive() && currentLastActiveTime != 0l && destinationStatistics.messages.getCount() == 0L ) {
1:e415d29:             if ((System.currentTimeMillis() - currentLastActiveTime) >= getInactiveTimeoutBeforeGC()) {
1:2705e36:                 result = true;
1:2705e36:             }
1:2705e36:         }
1:2705e36:         return result;
1:2705e36:     }
1:9ad6c08: 
1:c1da3ac:     public void setReduceMemoryFootprint(boolean reduceMemoryFootprint) {
1:c1da3ac:         this.reduceMemoryFootprint = reduceMemoryFootprint;
1:c1da3ac:     }
1:9ad6c08: 
1:c5506f5:     public boolean isReduceMemoryFootprint() {
1:c1da3ac:         return this.reduceMemoryFootprint;
1:c1da3ac:     }
1:9ad6c08: 
1:b9fd189:     @Override
1:f4d4c3b:     public boolean isDoOptimzeMessageStorage() {
1:f4d4c3b:         return doOptimzeMessageStorage;
1:f4d4c3b:     }
1:f4d4c3b: 
1:b9fd189:     @Override
1:f4d4c3b:     public void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage) {
1:f4d4c3b:         this.doOptimzeMessageStorage = doOptimzeMessageStorage;
1:f4d4c3b:     }
1:f4d4c3b: 
1:ca83305:     public int getOptimizeMessageStoreInFlightLimit() {
1:ca83305:         return optimizeMessageStoreInFlightLimit;
1:ca83305:     }
1:ca83305: 
1:ca83305:     public void setOptimizeMessageStoreInFlightLimit(int optimizeMessageStoreInFlightLimit) {
1:ca83305:         this.optimizeMessageStoreInFlightLimit = optimizeMessageStoreInFlightLimit;
1:ca83305:     }
1:ca83305: 
1:f4d4c3b: 
1:b9fd189:     @Override
1:d55a392:     public abstract List<Subscription> getConsumers();
1:9ad6c08: 
1:d55a392:     protected boolean hasRegularConsumers(List<Subscription> consumers) {
1:254d920:         boolean hasRegularConsumers = false;
1:254d920:         for (Subscription subscription: consumers) {
1:254d920:             if (!subscription.getConsumerInfo().isNetworkSubscription()) {
1:254d920:                 hasRegularConsumers = true;
1:254d920:                 break;
1:254d920:             }
1:254d920:         }
1:254d920:         return hasRegularConsumers;
1:254d920:     }
1:ed3f61a: 
1:f92d45b:     public ConnectionContext createConnectionContext() {
1:50d27e7:         ConnectionContext answer = new ConnectionContext();
1:ed3f61a:         answer.setBroker(this.broker);
1:ed3f61a:         answer.getMessageEvaluationContext().setDestination(getActiveMQDestination());
1:ed3f61a:         answer.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
1:ed3f61a:         return answer;
1:ed3f61a:     }
1:9ad6c08: 
1:b07f31e:     protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {
1:b07f31e:         // the original ack may be a ranged ack, but we are trying to delete
1:b07f31e:         // a specific
1:b07f31e:         // message store here so we need to convert to a non ranged ack.
1:b07f31e:         if (ack.getMessageCount() > 0) {
1:b07f31e:             // Dup the ack
1:b07f31e:             MessageAck a = new MessageAck();
1:b07f31e:             ack.copy(a);
1:b07f31e:             ack = a;
1:b07f31e:             // Convert to non-ranged.
1:b07f31e:             ack.setMessageCount(1);
1:a0d2282:         }
1:3b5d89a:         // always use node messageId so we can access entry/data Location
1:3b5d89a:         ack.setFirstMessageId(node.getMessageId());
1:3b5d89a:         ack.setLastMessageId(node.getMessageId());
1:b07f31e:         return ack;
1:e1f170d:     }
1:e1f170d: 
1:be919fb:     protected boolean isDLQ() {
1:be919fb:         return destination.isDLQ();
1:b07f31e:     }
1:1898869: 
2:b9fd189:     @Override
1:f92d45b:     public void duplicateFromStore(Message message, Subscription durableSub) {
1:f92d45b:         ConnectionContext connectionContext = createConnectionContext();
1:f92d45b:         getLog().warn("duplicate message from store {}, redirecting for dlq processing", message.getMessageId());
1:f92d45b:         Throwable cause = new Throwable("duplicate from store for " + destination);
1:f92d45b:         message.setRegionDestination(this);
1:f92d45b:         broker.getRoot().sendToDeadLetterQueue(connectionContext, message, null, cause);
1:f92d45b:         MessageAck messageAck = new MessageAck(message, MessageAck.POSION_ACK_TYPE, 1);
1:f92d45b:         messageAck.setPoisonCause(cause);
1:f92d45b:         try {
1:f92d45b:             acknowledge(connectionContext, durableSub, messageAck, message);
1:f92d45b:         } catch (IOException e) {
1:f92d45b:             getLog().error("Failed to acknowledge duplicate message {} from {} with {}", message.getMessageId(), destination, messageAck);
1:f92d45b:         }
1:f92d45b:     }
1:f92d45b: 
1:266d23e:     public void setPersistJMSRedelivered(boolean persistJMSRedelivered) {
1:266d23e:         this.persistJMSRedelivered = persistJMSRedelivered;
1:266d23e:     }
1:266d23e: 
1:266d23e:     public boolean isPersistJMSRedelivered() {
1:266d23e:         return persistJMSRedelivered;
1:266d23e:     }
1:0ae90c0: 
1:0ae90c0:     public SystemUsage getSystemUsage() {
1:0ae90c0:         return systemUsage;
1:0ae90c0:     }
1:b07f31e: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:50d27e7
/////////////////////////////////////////////////////////////////////////
1:         ConnectionContext answer = new ConnectionContext();
commit:0608175
/////////////////////////////////////////////////////////////////////////
1:                     getLog().warn("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((System.currentTimeMillis() - start) / 1000))});
1:                 } else {
1:                     getLog().debug("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((System.currentTimeMillis() - start) / 1000))});
commit:151e17a
/////////////////////////////////////////////////////////////////////////
1:             if (isFlowControlLogRequired()) {
1:                 getLog().info("sendFailIfNoSpace, forcing exception on send, usage: {}: {}", usage, warning);
1:             } else {
1:                 getLog().debug("sendFailIfNoSpace, forcing exception on send, usage: {}: {}", usage, warning);
1:             }
1:                 if (isFlowControlLogRequired()) {
1:                     getLog().info("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: {}: {}", usage, warning);
1:                 } else {
1:                     getLog().debug("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: {}: {}", usage, warning);
1:                 }
commit:01b1f7f
/////////////////////////////////////////////////////////////////////////
1:     protected long lastBlockedProducerWarnTime = 0l;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (isFlowControlLogRequired()) {
0:                     getLog().info("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((System.currentTimeMillis() - start) / 1000))});
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isFlowControlLogRequired() {
1:         boolean answer = false;
1:         if (blockedProducerWarningInterval > 0) {
1:             long now = System.currentTimeMillis();
1:             if (lastBlockedProducerWarnTime + blockedProducerWarningInterval <= now) {
1:                 lastBlockedProducerWarnTime = now;
1:                 answer = true;
1:             }
1:         }
1:         return answer;
1:     }
1: 
commit:d86c98a
/////////////////////////////////////////////////////////////////////////
1:         this.lastActiveTime=0l;
/////////////////////////////////////////////////////////////////////////
1:         boolean isActive = destinationStatistics.getConsumers().getCount() > 0 ||
1:                            destinationStatistics.getProducers().getCount() > 0;
1:         if (isActive && isGcWithNetworkConsumers() && destinationStatistics.getConsumers().getCount() > 0) {
commit:e415d29
/////////////////////////////////////////////////////////////////////////
1:         final long currentLastActiveTime = this.lastActiveTime;
1:         if (isGcIfInactive() && currentLastActiveTime != 0l && destinationStatistics.messages.getCount() == 0L ) {
1:             if ((System.currentTimeMillis() - currentLastActiveTime) >= getInactiveTimeoutBeforeGC()) {
commit:0ae90c0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public SystemUsage getSystemUsage() {
1:         return systemUsage;
1:     }
commit:a3a8c1c
/////////////////////////////////////////////////////////////////////////
1:         return this.maxBrowsePageSize;
commit:be919fb
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isDLQ() {
1:         return destination.isDLQ();
commit:97c127d
/////////////////////////////////////////////////////////////////////////
1:     public static final int MAX_AUDIT_DEPTH = 10000;
commit:3b5d89a
/////////////////////////////////////////////////////////////////////////
1:         // always use node messageId so we can access entry/data Location
1:         ack.setFirstMessageId(node.getMessageId());
1:         ack.setLastMessageId(node.getMessageId());
commit:266d23e
/////////////////////////////////////////////////////////////////////////
1:     private boolean persistJMSRedelivered;
/////////////////////////////////////////////////////////////////////////
1:     public void setPersistJMSRedelivered(boolean persistJMSRedelivered) {
1:         this.persistJMSRedelivered = persistJMSRedelivered;
1:     }
1: 
1:     public boolean isPersistJMSRedelivered() {
1:         return persistJMSRedelivered;
1:     }
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionContext createConnectionContext() {
/////////////////////////////////////////////////////////////////////////
1:     public void duplicateFromStore(Message message, Subscription durableSub) {
1:         ConnectionContext connectionContext = createConnectionContext();
1: 
0:         TransactionId transactionId = message.getTransactionId();
0:         if (transactionId != null && transactionId.isXATransaction()) {
1:             try {
0:                 List<TransactionId> preparedTx = Arrays.asList(broker.getRoot().getPreparedTransactions(connectionContext));
0:                 getLog().trace("processing duplicate in {}, prepared {} ", transactionId, preparedTx);
0:                 if (!preparedTx.contains(transactionId)) {
0:                     // duplicates from past transactions expected after org.apache.activemq.broker.region.Destination#clearPendingMessages
0:                     // till they are acked
0:                     getLog().debug("duplicate message from store {}, from historical transaction {}, ignoring", message.getMessageId(), transactionId);
0:                     return;
1:                 }
0:             } catch (Exception ignored) {
0:                 getLog().debug("failed to determine state of transaction {} on duplicate message {}", transactionId, message.getMessageId(), ignored);
1:             }
1:         }
1: 
1:         getLog().warn("duplicate message from store {}, redirecting for dlq processing", message.getMessageId());
1:         Throwable cause = new Throwable("duplicate from store for " + destination);
1:         message.setRegionDestination(this);
1:         broker.getRoot().sendToDeadLetterQueue(connectionContext, message, null, cause);
1:         MessageAck messageAck = new MessageAck(message, MessageAck.POSION_ACK_TYPE, 1);
1:         messageAck.setPoisonCause(cause);
1:         try {
1:             acknowledge(connectionContext, durableSub, messageAck, message);
1:         } catch (IOException e) {
1:             getLog().error("Failed to acknowledge duplicate message {} from {} with {}", message.getMessageId(), destination, messageAck);
1:         }
1:     }
1: 
commit:85bc9ce
/////////////////////////////////////////////////////////////////////////
0:         return this.maxBrowsePageSize > 0 ? this.maxBrowsePageSize : getMaxPageSize();
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:2769298
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     protected final AtomicBoolean started = new AtomicBoolean();
commit:c5506f5
/////////////////////////////////////////////////////////////////////////
1:     public boolean isReduceMemoryFootprint() {
commit:edacc2a
/////////////////////////////////////////////////////////////////////////
1:     private boolean includeBodyForAdvisory;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isIncludeBodyForAdvisory() {
1:         return includeBodyForAdvisory;
1:     }
1: 
1:     public void setIncludeBodyForAdvisory(boolean includeBodyForAdvisory) {
1:         this.includeBodyForAdvisory = includeBodyForAdvisory;
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Brian D. Johnson
-------------------------------------------------------------------------------
commit:552c0f0
/////////////////////////////////////////////////////////////////////////
1:         this.lastActiveTime = 0L;
/////////////////////////////////////////////////////////////////////////
0:         if (isGcIfInactive() && this.lastActiveTime != 0l && destinationStatistics.messages.getCount() == 0L ) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:b9fd189
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private long inactiveTimeoutBeforeGC = DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     public void setMemoryUsage(MemoryUsage memoryUsage) {
1:         this.memoryUsage = memoryUsage;
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      * @return the inactiveTimeoutBeforeGC
1:     @Override
1:     public long getInactiveTimeoutBeforeGC() {
1:         return this.inactiveTimeoutBeforeGC;
1:      * @param inactiveTimeoutBeforeGC the inactiveTimeoutBeforeGC to set
1:     public void setInactiveTimeoutBeforeGC(long inactiveTimeoutBeforeGC) {
1:         this.inactiveTimeoutBeforeGC = inactiveTimeoutBeforeGC;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 && destinationStatistics.messages.getCount() == 0 && getInactiveTimeoutBeforeGC() > 0l) {
1:     @Override
0:             if ((System.currentTimeMillis() - this.lastActiveTime) >= getInactiveTimeoutBeforeGC()) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:             getLog().debug("sendFailIfNoSpace, forcing exception on send, usage: {}: {}", usage, warning);
0:                 getLog().debug("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: {}: {}", usage, warning);
/////////////////////////////////////////////////////////////////////////
0:                     getLog().info("{}: {} (blocking for: {}s)", new Object[]{ usage, warning, new Long(((now - start) / 1000))});
author:Robert Davies
-------------------------------------------------------------------------------
commit:0736953
/////////////////////////////////////////////////////////////////////////
1:     protected final void waitForSpace(ConnectionContext context,ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, String warning) throws IOException, InterruptedException, ResourceAllocationException {
1:         waitForSpace(context, producerBrokerExchange, usage, 100, warning);
1:     protected final void waitForSpace(ConnectionContext context, ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {
/////////////////////////////////////////////////////////////////////////
1:             producerBrokerExchange.blockingOnFlowControl(true);
1:             destinationStatistics.getBlockedSends().increment();
/////////////////////////////////////////////////////////////////////////
1:             long finish = System.currentTimeMillis();
1:             long totalTimeBlocked = finish - start;
1:             destinationStatistics.getBlockedTime().addTime(totalTimeBlocked);
1:             producerBrokerExchange.incrementTimeBlocked(this,totalTimeBlocked);
1:             producerBrokerExchange.blockingOnFlowControl(false);
commit:ca83305
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * percentage of in-flight messages above which optimize message store is disabled
1:      */
1:     private int optimizeMessageStoreInFlightLimit = 10;
/////////////////////////////////////////////////////////////////////////
1:     public int getOptimizeMessageStoreInFlightLimit() {
1:         return optimizeMessageStoreInFlightLimit;
1:     }
1: 
1:     public void setOptimizeMessageStoreInFlightLimit(int optimizeMessageStoreInFlightLimit) {
1:         this.optimizeMessageStoreInFlightLimit = optimizeMessageStoreInFlightLimit;
1:     }
1: 
commit:f4d4c3b
/////////////////////////////////////////////////////////////////////////
1:     private boolean doOptimzeMessageStorage = true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDoOptimzeMessageStorage() {
1:         return doOptimzeMessageStorage;
1:     }
1: 
1:     public void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage) {
1:         this.doOptimzeMessageStorage = doOptimzeMessageStorage;
1:     }
1: 
1: 
commit:2705e36
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC = 60 * 1000;
/////////////////////////////////////////////////////////////////////////
0:     private long inactiveTimoutBeforeGC = DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
1:     private boolean gcIfInactive;
1:     private long lastActiveTime=0l;
/////////////////////////////////////////////////////////////////////////
1:         this.lastActiveTime=0l;
1:     
1:     public void addSubscription(ConnectionContext context, Subscription sub) throws Exception{
1:         destinationStatistics.getConsumers().increment();
1:         this.lastActiveTime=0l;
1:     }
1: 
1:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception{
1:         destinationStatistics.getConsumers().decrement();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * @return the inactiveTimoutBeforeGC
1:      */
0:     public long getInactiveTimoutBeforeGC() {
0:         return this.inactiveTimoutBeforeGC;
1:     }
1: 
1:     /**
0:      * @param inactiveTimoutBeforeGC the inactiveTimoutBeforeGC to set
1:      */
0:     public void setInactiveTimoutBeforeGC(long inactiveTimoutBeforeGC) {
0:         this.inactiveTimoutBeforeGC = inactiveTimoutBeforeGC;
1:     }
1: 
1:     /**
1:      * @return the gcIfInactive
1:      */
1:     public boolean isGcIfInactive() {
1:         return this.gcIfInactive;
1:     }
1: 
1:     /**
1:      * @param gcIfInactive the gcIfInactive to set
1:      */
1:     public void setGcIfInactive(boolean gcIfInactive) {
1:         this.gcIfInactive = gcIfInactive;
1:     }
1:     
1:     public void markForGC(long timeStamp) {
1:         if (isGcIfInactive() && this.lastActiveTime == 0 && isActive() == false
0:                 && destinationStatistics.messages.getCount() == 0 && getInactiveTimoutBeforeGC() > 0l) {
1:             this.lastActiveTime = timeStamp;
1:         }
1:     }
1: 
1:     public boolean canGC() {
1:         boolean result = false;
0:         if (isGcIfInactive()&& this.lastActiveTime != 0l) {
0:             if ((System.currentTimeMillis() - this.lastActiveTime) > getInactiveTimoutBeforeGC()) {
1:                 result = true;
1:             }
1:         }
1:         return result;
1:     }
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:     private boolean prioritizedMessages;
/////////////////////////////////////////////////////////////////////////
1: 
1:    
1:     public boolean isPrioritizedMessages() {
1:         return this.prioritizedMessages;
1:     }
1: 
1:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:         this.prioritizedMessages = prioritizedMessages;
1:     }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:     private boolean producerFlowControl = true;
/////////////////////////////////////////////////////////////////////////
1:     protected int cursorMemoryHighWaterMark = 70;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getCursorMemoryHighWaterMark() {
1: 		return this.cursorMemoryHighWaterMark;
1: 	}
1: 
1: 	public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
1: 		this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
1: 	}
/////////////////////////////////////////////////////////////////////////
commit:5a0da57
/////////////////////////////////////////////////////////////////////////
0:     private boolean producerFlowControl = false;
commit:63e3f41
/////////////////////////////////////////////////////////////////////////
0:      * The maximum number of messages to page in to the destination from persistent storage
1:     public static final int MAX_PAGE_SIZE = 200;
1:     public static final int MAX_BROWSE_PAGE_SIZE = MAX_PAGE_SIZE * 2;
1:     private int maxProducersToAudit = 1024;
1:     private int maxAuditDepth = 2048;
1:     private boolean enableAudit = true;
1:     private int maxPageSize = MAX_PAGE_SIZE;
1:     private int maxBrowsePageSize = MAX_BROWSE_PAGE_SIZE;
1:     private boolean useCache = true;
1:     private int minimumMessageSize = 1024;
1:     private boolean lazyDispatch = false;
/////////////////////////////////////////////////////////////////////////
1: 
0:      * @param broker
1:      * @param store
1:      * @throws Exception
0:     public BaseDestination(BrokerService brokerService, MessageStore store, ActiveMQDestination destination,
0:             DestinationStatistics parentStats) throws Exception {
1:         this.broker = brokerService.getBroker();
1:         this.store = store;
1:         this.destination = destination;
1:         this.destinationStatistics.setParent(parentStats);
1: 
1:      * 
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1: 
0:      * @param producerFlowControl
0:      *            the producerFlowControl to set
1: 
1: 
0:      * @param maxProducersToAudit
0:      *            the maxProducersToAudit to set
1: 
1: 
0:      * @param maxAuditDepth
0:      *            the maxAuditDepth to set
1: 
1: 
0:      * @param enableAudit
0:      *            the enableAudit to set
1: 
1:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         return destinationStatistics.getConsumers().getCount() != 0
0:                 || destinationStatistics.getProducers().getCount() != 0;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForSlowConsumers
0:      *            the advisoryForSlowConsumers to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForDiscardingMessages
0:      *            the advisoryForDiscardingMessages to set
1:     public void setAdvisoryForDiscardingMessages(boolean advisoryForDiscardingMessages) {
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryWhenFull
0:      *            the advisoryWhenFull to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForDelivery
0:      *            the advisoryForDelivery to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForConsumed
0:      *            the advisoryForConsumed to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisdoryForFastProducers
0:      *            the advisdoryForFastProducers to set
1: 
/////////////////////////////////////////////////////////////////////////
1:      * 
1: 
1:      * 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * 
1:         if (advisoryForDelivery) {
1: 
0:      * Called when a message is discarded - e.g. running low on memory This will happen only if the policy is enabled -
0:      * e.g. non durable topics
1:      * 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * 
1:         if (advisoryForSlowConsumers) {
1: 
1:      * 
1:     public void fastProducer(ConnectionContext context, ProducerInfo producerInfo) {
0:         if (advisdoryForFastProducers) {
1: 
1:      * 
0:     public void isFull(ConnectionContext context, Usage usage) {
1:         if (advisoryWhenFull) {
1:             broker.isFull(context, this, usage);
1: 
1:         if (this.store != null) {
1:             this.store.dispose(context);
1:         }
1:         this.destinationStatistics.setParent(null);
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
0:     public static final int MAX_BROWSE_PAGE_SIZE=MAX_PAGE_SIZE*2;
/////////////////////////////////////////////////////////////////////////
0:     private int maxBrowsePageSize=MAX_BROWSE_PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getMaxBrowsePageSize() {
0:         return this.maxBrowsePageSize;
1:     }
1: 
1:     public void setMaxBrowsePageSize(int maxPageSize) {
1:         this.maxBrowsePageSize = maxPageSize;
1:     } 
commit:c8bd57c
/////////////////////////////////////////////////////////////////////////
0:      * The maximum number of messages to page in to the destination
0:     public static final int MAX_PAGE_SIZE=200;
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=MAX_PAGE_SIZE;
commit:e2cafda
/////////////////////////////////////////////////////////////////////////
0:     public static final int DEFAULT_PAGE_SIZE=200;
commit:0d85869
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
1:    
/////////////////////////////////////////////////////////////////////////
1:     protected DeadLetterStrategy deadLetterStrategy = DEFAULT_DEAD_LETTER_STRATEGY;
/////////////////////////////////////////////////////////////////////////
1:      * @return the dead letter strategy
1:      */
1:     public DeadLetterStrategy getDeadLetterStrategy() {
1:         return deadLetterStrategy;
1:     }
1: 
1:     /**
1:      * set the dead letter strategy
1:      * @param deadLetterStrategy
1:      */
1:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
1:         this.deadLetterStrategy = deadLetterStrategy;
1:     }
1:     /**
commit:4b27e76
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void dispose(ConnectionContext context) throws IOException {
0:         destinationStatistics.setParent(null);
1:         this.memoryUsage.stop();
1:     }
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.Usage;
1:     /**
0:      * The default number of messages to page in to the destination
0:      * from persistent storage
1:      */
/////////////////////////////////////////////////////////////////////////
1:     private boolean advisoryForSlowConsumers;
0:     private boolean advisdoryForFastProducers;
1:     private boolean advisoryForDiscardingMessages;
1:     private boolean advisoryWhenFull;
1:     private boolean advisoryForDelivery;
1:     private boolean advisoryForConsumed;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the advisoryForSlowConsumers
1:      */
1:     public boolean isAdvisoryForSlowConsumers() {
1:         return advisoryForSlowConsumers;
1:     }
1: 
1:     /**
1:      * @param advisoryForSlowConsumers the advisoryForSlowConsumers to set
1:      */
1:     public void setAdvisoryForSlowConsumers(boolean advisoryForSlowConsumers) {
1:         this.advisoryForSlowConsumers = advisoryForSlowConsumers;
1:     }
1: 
1:     /**
1:      * @return the advisoryForDiscardingMessages
1:      */
1:     public boolean isAdvisoryForDiscardingMessages() {
1:         return advisoryForDiscardingMessages;
1:     }
1: 
1:     /**
0:      * @param advisoryForDiscardingMessages the advisoryForDiscardingMessages to set
1:      */
0:     public void setAdvisoryForDiscardingMessages(
0:             boolean advisoryForDiscardingMessages) {
1:         this.advisoryForDiscardingMessages = advisoryForDiscardingMessages;
1:     }
1: 
1:     /**
1:      * @return the advisoryWhenFull
1:      */
1:     public boolean isAdvisoryWhenFull() {
1:         return advisoryWhenFull;
1:     }
1: 
1:     /**
1:      * @param advisoryWhenFull the advisoryWhenFull to set
1:      */
1:     public void setAdvisoryWhenFull(boolean advisoryWhenFull) {
1:         this.advisoryWhenFull = advisoryWhenFull;
1:     }
1: 
1:     /**
1:      * @return the advisoryForDelivery
1:      */
1:     public boolean isAdvisoryForDelivery() {
1:         return advisoryForDelivery;
1:     }
1: 
1:     /**
1:      * @param advisoryForDelivery the advisoryForDelivery to set
1:      */
1:     public void setAdvisoryForDelivery(boolean advisoryForDelivery) {
1:         this.advisoryForDelivery = advisoryForDelivery;
1:     }
1: 
1:     /**
1:      * @return the advisoryForConsumed
1:      */
1:     public boolean isAdvisoryForConsumed() {
1:         return advisoryForConsumed;
1:     }
1: 
1:     /**
1:      * @param advisoryForConsumed the advisoryForConsumed to set
1:      */
1:     public void setAdvisoryForConsumed(boolean advisoryForConsumed) {
1:         this.advisoryForConsumed = advisoryForConsumed;
1:     }
1: 
1:     /**
1:      * @return the advisdoryForFastProducers
1:      */
0:     public boolean isAdvisdoryForFastProducers() {
0:         return advisdoryForFastProducers;
1:     }
1: 
1:     /**
0:      * @param advisdoryForFastProducers the advisdoryForFastProducers to set
1:      */
0:     public void setAdvisdoryForFastProducers(boolean advisdoryForFastProducers) {
0:         this.advisdoryForFastProducers = advisdoryForFastProducers;
1:     }
1:     
1:     /**
1:      * called when message is consumed
1:      * @param context
1:      * @param messageReference
1:      */
1:     public void messageConsumed(ConnectionContext context, MessageReference messageReference) {
1:         if (advisoryForConsumed) {
1:             broker.messageConsumed(context, messageReference);
1:         }
1:     }
1:     
1:     /**
1:      * Called when message is delivered to the broker
1:      * @param context
1:      * @param messageReference
1:      */
1:     public void messageDelivered(ConnectionContext context, MessageReference messageReference) {
0:         if(advisoryForDelivery) {
1:             broker.messageDelivered(context, messageReference);
1:         }
1:     }
1:     
1:     /**
0:      * Called when a message is discarded - e.g. running low on memory
0:      * This will happen only if the policy is enabled - e.g. non durable topics
1:      * @param context
1:      * @param messageReference
1:      */
0:     public void messageDiscarded(ConnectionContext context, MessageReference messageReference) {
1:         if (advisoryForDiscardingMessages) {
0:             broker.messageDiscarded(context, messageReference);
1:         }
1:     }
1:     
1:     /**
1:      * Called when there is a slow consumer
1:      * @param context
1:      * @param subs
1:      */
1:     public void slowConsumer(ConnectionContext context, Subscription subs) {
0:         if(advisoryForSlowConsumers) {
1:             broker.slowConsumer(context, this, subs);
1:         }
1:     }
1:     
1:     /**
1:      * Called to notify a producer is too fast
1:      * @param context
1:      * @param producerInfo
1:      */
0:     public void fastProducer(ConnectionContext context,ProducerInfo producerInfo) {
0:         if(advisdoryForFastProducers) {
0:             broker.fastProducer(context, producerInfo);
1:         }
1:     }
1:     
1:     /**
1:      * Called when a Usage reaches a limit
1:      * @param context
1:      * @param usage
1:      */
0:     public void isFull(ConnectionContext context,Usage usage) {
0:         if(advisoryWhenFull) {
0:             broker.isFull(context,this, usage);
1:         }
1:     }
1: 
commit:18f9773
/////////////////////////////////////////////////////////////////////////
0:     public static final int DEFAULT_PAGE_SIZE=100;
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=DEFAULT_PAGE_SIZE;
commit:dfcf776
/////////////////////////////////////////////////////////////////////////
1:     protected final Broker regionBroker;
/////////////////////////////////////////////////////////////////////////
1:         this.regionBroker = brokerService.getRegionBroker();
/////////////////////////////////////////////////////////////////////////
1:     } 
1:     
1:     protected long getDestinationSequenceId() {
1:         return regionBroker.getBrokerSequenceId();
1:     }
commit:ff7033f
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=100;
commit:7d70fec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private boolean lazyDispatch=true;
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:     private boolean lazyDispatch;
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public boolean isLazyDispatch() {
1:         return lazyDispatch;
1:     }
1: 
1:     public void setLazyDispatch(boolean lazyDispatch) {
1:         this.lazyDispatch = lazyDispatch;
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
0:     private int maxAuditDepth=2048;
0:     private boolean useCache=true;
0:     private int minimumMessageSize=1024;
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public boolean isUseCache() {
1:         return useCache;
1:     }
1: 
1:     public void setUseCache(boolean useCache) {
1:         this.useCache = useCache;
1:     }
1: 
1:     public int getMinimumMessageSize() {
1:         return minimumMessageSize;
1:     }
1: 
1:     public void setMinimumMessageSize(int minimumMessageSize) {
1:         this.minimumMessageSize = minimumMessageSize;
commit:d0f3d4d
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=1000;
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxPageSize() {
1:         return maxPageSize;
1:     }
1: 
1:     public void setMaxPageSize(int maxPageSize) {
1:         this.maxPageSize = maxPageSize;
1:     }      
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
1:         
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * initialize the destination
1:      * @throws Exception
1:      */
0:     public abstract void initialize() throws Exception;
/////////////////////////////////////////////////////////////////////////
1:     public final MemoryUsage getMemoryUsage() {
/////////////////////////////////////////////////////////////////////////
1:     
0:     public final boolean isActive() {
0:         return destinationStatistics.getConsumers().getCount() != 0 ||
0:             destinationStatistics.getProducers().getCount() != 0;
1:     }
commit:8d11f07
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.usage.MemoryUsage;
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected final ActiveMQDestination destination;
1:     protected final Broker broker;
1:     protected final MessageStore store;
0:     protected final SystemUsage systemUsage;
0:     protected final MemoryUsage memoryUsage;
1:     
1:     /**
0:      * @param broker 
0:      * @param store 
1:      * @param destination
0:      * @param systemUsage 
1:      * @param parentStats
1:      */
0:     public BaseDestination(Broker broker,MessageStore store,ActiveMQDestination destination, SystemUsage systemUsage,DestinationStatistics parentStats) {
0:         this.broker=broker;
0:         this.store=store;
0:         this.destination=destination;
0:         this.systemUsage=systemUsage;
0:         this.memoryUsage = new MemoryUsage(systemUsage.getMemoryUsage(), destination.toString());
1:         this.memoryUsage.setUsagePortion(1.0f);
1:         // Let the store know what usage manager we are using so that he can
1:         // flush messages to disk when usage gets high.
1:         if (store != null) {
1:             store.setMemoryUsage(this.memoryUsage);
1:         } 
1:         // let's copy the enabled property from the parent DestinationStatistics
1:         this.destinationStatistics.setEnabled(parentStats.isEnabled());
0:         this.destinationStatistics.setParent(parentStats);        
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
0:     public final MemoryUsage getBrokerMemoryUsage() {
1:         return memoryUsage;
1:     }
1: 
1:     public DestinationStatistics getDestinationStatistics() {
1:         return destinationStatistics;
1:     }
1: 
1:     public ActiveMQDestination getActiveMQDestination() {
1:         return destination;
1:     }
1: 
0:     public final String getDestination() {
0:         return destination.getPhysicalName();
1:     }
1:     
1:     public final String getName() {
1:         return getActiveMQDestination().getPhysicalName();
1:     }
1:     
1:     public final MessageStore getMessageStore() {
1:         return store;
1:     }
1: 
commit:634da7a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ProducerInfo;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception{
1:         destinationStatistics.getProducers().increment();
1:     }
1: 
0:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception{
1:         destinationStatistics.getProducers().decrement();
1:     }
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
0:     private int maxProducersToAudit=1024;
0:     private int maxAuditDepth=1;
0:     private boolean enableAudit=true;
1:     /**
1:      * @return the producerFlowControl
1:      */
1:         return producerFlowControl;
1:     }
1:     /**
1:      * @param producerFlowControl the producerFlowControl to set
1:      */
1:     public void setProducerFlowControl(boolean producerFlowControl) {
1:         this.producerFlowControl = producerFlowControl;
1:     }
1:     /**
1:      * @return the maxProducersToAudit
1:      */
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
1:     }
1:     /**
1:      * @param maxProducersToAudit the maxProducersToAudit to set
1:      */
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
1:     }
1:     /**
1:      * @return the maxAuditDepth
1:      */
1:     public int getMaxAuditDepth() {
1:         return maxAuditDepth;
1:     }
1:     /**
1:      * @param maxAuditDepth the maxAuditDepth to set
1:      */
1:     public void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
1:     }
1:     /**
1:      * @return the enableAudit
1:      */
1:     public boolean isEnableAudit() {
1:         return enableAudit;
1:     }
1:     /**
1:      * @param enableAudit the enableAudit to set
1:      */
1:     public void setEnableAudit(boolean enableAudit) {
1:         this.enableAudit = enableAudit;
1:     
commit:0da68b4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
1: 
1: 
1: /**
0:  * @version $Revision: 1.12 $
1:  */
1: public abstract class BaseDestination implements Destination {
1: 
0:     private boolean producerFlowControl = true;
1: 
1:     public boolean isProducerFlowControl() {
0:         return this.producerFlowControl;
1:     }
1: 
0:     public void setProducerFlowControl(boolean value) {
0:         this.producerFlowControl = value;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e1f170d
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDLQ() {
0:         return getDeadLetterStrategy().isDLQ(this.getActiveMQDestination());
1:     }
1: 
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1: import org.apache.activemq.security.SecurityContext;
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:     protected final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
1:         this.scheduler = brokerService.getBroker().getScheduler();
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected ConnectionContext createConnectionContext() {
0:         ConnectionContext answer = new ConnectionContext(new NonCachedMessageEvaluationContext());
1:         answer.setBroker(this.broker);
1:         answer.getMessageEvaluationContext().setDestination(getActiveMQDestination());
1:         answer.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
1:         return answer;
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
/////////////////////////////////////////////////////////////////////////
1:     protected abstract Logger getLog();
commit:a0a1e64
/////////////////////////////////////////////////////////////////////////
0:             if ((System.currentTimeMillis() - this.lastActiveTime) >= getInactiveTimoutBeforeGC()) {
commit:03f38ae
/////////////////////////////////////////////////////////////////////////
1:         if (store != null) {
1:             store.setPrioritizedMessages(prioritizedMessages);
1:         }
commit:27183f8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:     protected void onMessageWithNoConsumers(ConnectionContext context, Message msg) throws Exception {
1:     	if (!msg.isPersistent()) {
1:                     Message message = msg.copy();
commit:db3a021
/////////////////////////////////////////////////////////////////////////
1:         this.systemUsage = new SystemUsage(brokerService.getProducerSystemUsage(), destination.toString());
1:         this.memoryUsage = this.systemUsage.getMemoryUsage();
commit:e679067
/////////////////////////////////////////////////////////////////////////
1:         	this.store.removeAllMessages(context);
commit:9ad6c08
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.state.ProducerState;
/////////////////////////////////////////////////////////////////////////
1:     private boolean sendAdvisoryIfNoConsumers;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isSendAdvisoryIfNoConsumers() {
1:         return sendAdvisoryIfNoConsumers;
1:     }
1: 
1:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
1:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Provides a hook to allow messages with no consumer to be processed in
1:      * some way - such as to send to a dead letter queue or something..
1:      */
0:     protected void onMessageWithNoConsumers(ConnectionContext context, Message message) throws Exception { 	
0:     	if (!message.isPersistent()) {
1:             if (isSendAdvisoryIfNoConsumers()) {
1:                 // allow messages with no consumers to be dispatched to a dead
1:                 // letter queue
1:                 if (destination.isQueue() || !AdvisorySupport.isAdvisoryTopic(destination)) {
1: 
1:                     // The original destination and transaction id do not get
1:                     // filled when the message is first sent,
1:                     // it is only populated if the message is routed to another
1:                     // destination like the DLQ
1:                     if (message.getOriginalDestination() != null) {
1:                         message.setOriginalDestination(message.getDestination());
1:                     }
1:                     if (message.getOriginalTransactionId() != null) {
1:                         message.setOriginalTransactionId(message.getTransactionId());
1:                     }
1:                     
1:                     ActiveMQTopic advisoryTopic;
1:                     if (destination.isQueue()) {
1:                     	advisoryTopic = AdvisorySupport.getNoQueueConsumersAdvisoryTopic(destination);
1:                     } else {
1:                     	advisoryTopic = AdvisorySupport.getNoTopicConsumersAdvisoryTopic(destination);
1:                     }
1:                     message.setDestination(advisoryTopic);
1:                     message.setTransactionId(null);
1: 
1:                     // Disable flow control for this since since we don't want
1:                     // to block.
1:                     boolean originalFlowControl = context.isProducerFlowControl();
0:                     try {
1:                         context.setProducerFlowControl(false);
1:                         ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:                         producerExchange.setMutable(false);
1:                         producerExchange.setConnectionContext(context);
1:                         producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:                         context.getBroker().send(producerExchange, message);
1:                     } finally {
1:                         context.setProducerFlowControl(originalFlowControl);
1:                     }
1: 
1:                 }
1:             }
1:         }
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1898869
/////////////////////////////////////////////////////////////////////////
0: 	public void setMemoryUsage(MemoryUsage memoryUsage) {
0:     	this.memoryUsage = memoryUsage;
1:     }
1: 
commit:17995e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:         return alwaysRetroactive;
0: 
1:         this.alwaysRetroactive = alwaysRetroactive;
/////////////////////////////////////////////////////////////////////////
1:     public void isFull(ConnectionContext context, Usage<?> usage) {
commit:b5a1916
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     private boolean disposed = false;
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1:         this.disposed = true;
1:     }
0: 
1:     public boolean isDisposed() {
1:         return this.disposed;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:9e13dc6
/////////////////////////////////////////////////////////////////////////
0:     private boolean lazyDispatch=false;
commit:13829ef
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: 
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
1:     protected SystemUsage systemUsage;
1:     protected MemoryUsage memoryUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected final BrokerService brokerService;
0:      * @throws Exception 
0:     public BaseDestination(BrokerService brokerService,MessageStore store, ActiveMQDestination destination, DestinationStatistics parentStats) throws Exception {
1:         this.brokerService = brokerService;
0:         this.broker=brokerService.getBroker();
0: 
0:         this.systemUsage = brokerService.getProducerSystemUsage();
0:         this.memoryUsage = new MemoryUsage(systemUsage.getMemoryUsage(), destination.toString());
0:         this.memoryUsage.setUsagePortion(1.0f);
1:     public void initialize() throws Exception {
0:         // Let the store know what usage manager we are using so that he can
0:         // flush messages to disk when usage gets high.
0:         if (store != null) {
0:             store.setMemoryUsage(this.memoryUsage);
1:         } 
1:     }
0:     
author:Gary Tully
-------------------------------------------------------------------------------
commit:db1f6fe
/////////////////////////////////////////////////////////////////////////
1:     private boolean advisoryForFastProducers;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isAdvisoryForFastProducers() {
1:         return advisoryForFastProducers;
1:      * @param advisoryForFastProducers the advisdoryForFastProducers to set
1:     public void setAdvisoryForFastProducers(boolean advisoryForFastProducers) {
1:         this.advisoryForFastProducers = advisoryForFastProducers;
/////////////////////////////////////////////////////////////////////////
1:         if (advisoryForFastProducers) {
1:             broker.fastProducer(context, producerInfo, getActiveMQDestination());
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {
1:         // the original ack may be a ranged ack, but we are trying to delete
1:         // a specific
1:         // message store here so we need to convert to a non ranged ack.
1:         if (ack.getMessageCount() > 0) {
1:             // Dup the ack
1:             MessageAck a = new MessageAck();
1:             ack.copy(a);
1:             ack = a;
1:             // Convert to non-ranged.
0:             ack.setFirstMessageId(node.getMessageId());
0:             ack.setLastMessageId(node.getMessageId());
1:             ack.setMessageCount(1);
1:         }
1:         return ack;
1:     }
0: 
commit:8ce0778
/////////////////////////////////////////////////////////////////////////
1:         if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
1:         if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
commit:fe63c29
/////////////////////////////////////////////////////////////////////////
1:     private boolean alwaysRetroactive = false;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isAlwaysRetroactive() {
0:     	return alwaysRetroactive;
1:     }
0:     
1:     public void setAlwaysRetroactive(boolean alwaysRetroactive) {
0:     	this.alwaysRetroactive = alwaysRetroactive;
1:     }
commit:2b10259
/////////////////////////////////////////////////////////////////////////
0:             getLog().debug("sendFailIfNoSpace, forcing exception on send, usage:  " + usage + ": " + warning);
0:                 getLog().debug("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send, usage: " + usage + ": " + warning);
/////////////////////////////////////////////////////////////////////////
0:                     getLog().info("" + usage + ": " + warning + " (blocking for: " + (now - start) / 1000 + "s)");
commit:d55a392
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     private boolean gcWithNetworkConsumers;
/////////////////////////////////////////////////////////////////////////
0:         boolean isActive = destinationStatistics.getConsumers().getCount() != 0 ||
0:                            destinationStatistics.getProducers().getCount() != 0;
0:         if (isActive && isGcWithNetworkConsumers() && destinationStatistics.getConsumers().getCount() != 0) {
1:             isActive = hasRegularConsumers(getConsumers());
1:         }
1:         return isActive;
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Indicate if it is ok to gc destinations that have only network consumers
1:      * @param gcWithNetworkConsumers
1:      */
1:     public void setGcWithNetworkConsumers(boolean gcWithNetworkConsumers) {
1:         this.gcWithNetworkConsumers = gcWithNetworkConsumers;
1:     }
0: 
1:     public boolean isGcWithNetworkConsumers() {
1:         return gcWithNetworkConsumers;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public abstract List<Subscription> getConsumers();
0: 
1:     protected boolean hasRegularConsumers(List<Subscription> consumers) {
commit:254d920
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:      * @param brokerService
/////////////////////////////////////////////////////////////////////////
1:     public boolean isActive() {
/////////////////////////////////////////////////////////////////////////
0: 
0:    protected boolean hasRegularConsumers(Collection<Subscription> consumers) {
1:         boolean hasRegularConsumers = false;
1:         for (Subscription subscription: consumers) {
1:             if (!subscription.getConsumerInfo().isNetworkSubscription()) {
1:                 hasRegularConsumers = true;
1:                 break;
1:             }
1:         }
1:         return hasRegularConsumers;
1:     }
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     public static final int MAX_PRODUCERS_TO_AUDIT = 64;
0:     public static final int MAX_AUDIT_DEPTH = 2048;
0: 
commit:c1da3ac
/////////////////////////////////////////////////////////////////////////
1:     private boolean reduceMemoryFootprint = false;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void setReduceMemoryFootprint(boolean reduceMemoryFootprint) {
1:         this.reduceMemoryFootprint = reduceMemoryFootprint;
1:     }
0: 
0:     protected boolean isReduceMemoryFootprint() {
1:         return this.reduceMemoryFootprint;
1:     }
commit:383d12e
/////////////////////////////////////////////////////////////////////////
1:     public SlowConsumerStrategy getSlowConsumerStrategy() {
1:         return this.slowConsumerStrategy;
1:     }
0: 
commit:fb591e7
/////////////////////////////////////////////////////////////////////////
0:         if (systemUsage.isSendFailIfNoSpace()) {
0:             getLog().debug("sendFailIfNoSpace, forcing exception on send: " + warning);
1:             throw new ResourceAllocationException(warning);
1:         }
0:                 getLog().debug("sendFailIfNoSpaceAfterTimeout expired, forcing exception on send: " + warning);
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.SlowConsumerStrategy;
/////////////////////////////////////////////////////////////////////////
1:     private SlowConsumerStrategy slowConsumerStrategy;
/////////////////////////////////////////////////////////////////////////
1:         if (slowConsumerStrategy != null) {
1:             slowConsumerStrategy.slowConsumer(context, subs);
1:         }
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void setSlowConsumerStrategy(SlowConsumerStrategy slowConsumerStrategy) {
1:         this.slowConsumerStrategy = slowConsumerStrategy;
1:     }
commit:a0d2282
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.ResourceAllocationException;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
/////////////////////////////////////////////////////////////////////////
1:     protected int storeUsageHighWaterMark = 100;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public final int getStoreUsageHighWaterMark() {
1:         return this.storeUsageHighWaterMark;
1:     }
0: 
1:     public void setStoreUsageHighWaterMark(int storeUsageHighWaterMark) {
1:         this.storeUsageHighWaterMark = storeUsageHighWaterMark;
1:     }
0: 
0:     protected final void waitForSpace(ConnectionContext context, Usage<?> usage, String warning) throws IOException, InterruptedException, ResourceAllocationException {
0:         waitForSpace(context, usage, 100, warning);
1:     }
0:     protected final void waitForSpace(ConnectionContext context, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {
0:         if (systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {
1:             if (!usage.waitForSpace(systemUsage.getSendFailIfNoSpaceAfterTimeout(), highWaterMark)) {
1:                 throw new ResourceAllocationException(warning);
1:             }
1:         } else {
1:             long start = System.currentTimeMillis();
0:             long nextWarn = start;
1:             while (!usage.waitForSpace(1000, highWaterMark)) {
1:                 if (context.getStopping().get()) {
1:                     throw new IOException("Connection closed, send aborted.");
1:                 }
0:     
0:                 long now = System.currentTimeMillis();
0:                 if (now >= nextWarn) {
0:                     getLog().info(warning + " (blocking for: " + (now - start) / 1000 + "s)");
0:                     nextWarn = now + blockedProducerWarningInterval;
1:                 }
1:             }
1:         }
1:     }
0: 
0:     protected abstract Log getLog();
commit:3e4fc0a
/////////////////////////////////////////////////////////////////////////
1:     public void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference) {
1:             broker.messageDiscarded(context, sub, messageReference);
commit:3536b1e
/////////////////////////////////////////////////////////////////////////
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
0:     public static final long EXPIRE_MESSAGE_PERIOD = 30*1000;
/////////////////////////////////////////////////////////////////////////
1:     protected long expireMessagesPeriod = EXPIRE_MESSAGE_PERIOD;
1:     private int maxExpirePageSize = MAX_BROWSE_PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public int getMaxExpirePageSize() {
1:         return this.maxExpirePageSize;
0:     }
1:     public void setMaxExpirePageSize(int maxPageSize) {
0:         this.maxExpirePageSize  = maxPageSize;
0:     }
0: 
1:     public void setExpireMessagesPeriod(long expireMessagesPeriod) {
1:         this.expireMessagesPeriod = expireMessagesPeriod;
0:     }
0: 
1:     public long getExpireMessagesPeriod() {
1:         return expireMessagesPeriod;
0:     }
0:     
commit:132f662
/////////////////////////////////////////////////////////////////////////
commit:f9d5449
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.JMSException;
0: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void processDispatchNotification(
0:             MessageDispatchNotification messageDispatchNotification) throws Exception {
0:     }
0: 
author:Colin W Macnaughton
-------------------------------------------------------------------------------
commit:48764be
/////////////////////////////////////////////////////////////////////////
1:      * The maximum number of messages to page in to the destination from
1:      * persistent storage
1:     public static final long EXPIRE_MESSAGE_PERIOD = 30 * 1000;
0:     protected boolean warnOnProducerFlowControl = true;
1:     protected long blockedProducerWarningInterval = DEFAULT_BLOCKED_PRODUCER_WARNING_INTERVAL;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public BaseDestination(BrokerService brokerService, MessageStore store, ActiveMQDestination destination, DestinationStatistics parentStats) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:      * @param producerFlowControl the producerFlowControl to set
1:      * Set's the interval at which warnings about producers being blocked by
1:      * resource usage will be triggered. Values of 0 or less will disable
1:      * warnings
0:      * 
1:      * @param blockedProducerWarningInterval the interval at which warning about
1:      *            blocked producers will be triggered.
1:      */
1:     public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval) {
1:         this.blockedProducerWarningInterval = blockedProducerWarningInterval;
0:     }
0: 
1:     /**
0:      * 
1:      * @return the interval at which warning about blocked producers will be
1:      *         triggered.
1:      */
1:     public long getBlockedProducerWarningInterval() {
1:         return blockedProducerWarningInterval;
0:     }
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:      * @param maxProducersToAudit the maxProducersToAudit to set
/////////////////////////////////////////////////////////////////////////
0:      * @param maxAuditDepth the maxAuditDepth to set
/////////////////////////////////////////////////////////////////////////
0:      * @param enableAudit the enableAudit to set
/////////////////////////////////////////////////////////////////////////
0:         return destinationStatistics.getConsumers().getCount() != 0 || destinationStatistics.getProducers().getCount() != 0;
/////////////////////////////////////////////////////////////////////////
0: 
1:         this.maxExpirePageSize = maxPageSize;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForSlowConsumers the advisoryForSlowConsumers to set
/////////////////////////////////////////////////////////////////////////
1:      * @param advisoryForDiscardingMessages the advisoryForDiscardingMessages to
1:      *            set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryWhenFull the advisoryWhenFull to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForDelivery the advisoryForDelivery to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisoryForConsumed the advisoryForConsumed to set
/////////////////////////////////////////////////////////////////////////
0:      * @param advisdoryForFastProducers the advisdoryForFastProducers to set
0: 
/////////////////////////////////////////////////////////////////////////
0:     public int getCursorMemoryHighWaterMark() {
0:         return this.cursorMemoryHighWaterMark;
0:     }
0: 
0:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
0:         this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
0:     }
/////////////////////////////////////////////////////////////////////////
1:      * Called when a message is discarded - e.g. running low on memory This will
1:      * happen only if the policy is enabled - e.g. non durable topics
/////////////////////////////////////////////////////////////////////////
0:             this.store.removeAllMessages(context);
0: 
0:         if (!msg.isPersistent()) {
/////////////////////////////////////////////////////////////////////////
0: 
0:                         advisoryTopic = AdvisorySupport.getNoQueueConsumersAdvisoryTopic(destination);
0:                         advisoryTopic = AdvisorySupport.getNoTopicConsumersAdvisoryTopic(destination);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
0:     
0:     
commit:4245c35
/////////////////////////////////////////////////////////////////////////
0:     protected boolean warnOnProducerFlowControl = true; 
============================================================================