1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:230a86c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.openwire;
1:d671875: 
1:4821b9d: import java.io.DataInput;
1:4821b9d: import java.io.DataOutput;
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.lang.reflect.Method;
1:d29ca2a: import java.util.HashMap;
1:ecf89a6: import java.util.Map;
1:230a86c: 
1:1a3f54c: import org.apache.activemq.command.CommandTypes;
1:1a3f54c: import org.apache.activemq.command.DataStructure;
1:1a3f54c: import org.apache.activemq.command.WireFormatInfo;
1:1a3f54c: import org.apache.activemq.util.ByteSequence;
1:1a3f54c: import org.apache.activemq.util.ByteSequenceData;
1:1a3f54c: import org.apache.activemq.util.DataByteArrayInputStream;
1:1a3f54c: import org.apache.activemq.util.DataByteArrayOutputStream;
1:98165c4: import org.apache.activemq.util.IOExceptionSupport;
1:1a3f54c: import org.apache.activemq.wireformat.WireFormat;
1:230a86c: 
1:d29ca2a: /**
1:13044de:  *
1:13044de:  *
1:d29ca2a:  */
1:fc00993: public final class OpenWireFormat implements WireFormat {
1:230a86c: 
1:13044de:     public static final int DEFAULT_STORE_VERSION = CommandTypes.PROTOCOL_STORE_VERSION;
1:eb22a02:     public static final int DEFAULT_WIRE_VERSION = CommandTypes.PROTOCOL_VERSION;
1:13044de:     public static final int DEFAULT_LEGACY_VERSION = CommandTypes.PROTOCOL_LEGACY_STORE_VERSION;
1:c50c1f5:     public static final long DEFAULT_MAX_FRAME_SIZE = Long.MAX_VALUE;
1:230a86c: 
1:d29ca2a:     static final byte NULL_TYPE = CommandTypes.NULL;
1:230a86c:     private static final int MARSHAL_CACHE_SIZE = Short.MAX_VALUE / 2;
1:aa54a8b:     private static final int MARSHAL_CACHE_FREE_SPACE = 100;
1:230a86c: 
1:d29ca2a:     private DataStreamMarshaller dataMarshallers[];
1:d29ca2a:     private int version;
1:ecf89a6:     private boolean stackTraceEnabled;
1:ecf89a6:     private boolean tcpNoDelayEnabled;
1:ecf89a6:     private boolean cacheEnabled;
1:ecf89a6:     private boolean tightEncodingEnabled;
1:ecf89a6:     private boolean sizePrefixDisabled;
1:e5e99d7:     private long maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
1:1a3f54c: 
1:aa54a8b:     // The following fields are used for value caching
1:ecf89a6:     private short nextMarshallCacheIndex;
1:ecf89a6:     private short nextMarshallCacheEvictionIndex;
1:ecf89a6:     private Map<DataStructure, Short> marshallCacheMap = new HashMap<DataStructure, Short>();
1:5bd4b19:     private DataStructure marshallCache[] = null;
1:5bd4b19:     private DataStructure unmarshallCache[] = null;
1:4821b9d:     private DataByteArrayOutputStream bytesOut = new DataByteArrayOutputStream();
1:4821b9d:     private DataByteArrayInputStream bytesIn = new DataByteArrayInputStream();
1:230a86c:     private WireFormatInfo preferedWireFormatInfo;
1:13044de: 
1:230a86c:     public OpenWireFormat() {
1:13044de:         this(DEFAULT_STORE_VERSION);
1:aa54a8b:     }
1:230a86c: 
1:230a86c:     public OpenWireFormat(int i) {
1:230a86c:         setVersion(i);
1:230a86c:     }
1:230a86c: 
1:13044de:     @Override
1:230a86c:     public int hashCode() {
1:230a86c:         return version ^ (cacheEnabled ? 0x10000000 : 0x20000000)
1:230a86c:                ^ (stackTraceEnabled ? 0x01000000 : 0x02000000)
1:230a86c:                ^ (tightEncodingEnabled ? 0x00100000 : 0x00200000)
1:230a86c:                ^ (sizePrefixDisabled ? 0x00010000 : 0x00020000);
1:230a86c:     }
1:230a86c: 
1:22bb1bd:     public OpenWireFormat copy() {
1:3cce6b7:         OpenWireFormat answer = new OpenWireFormat(version);
1:22bb1bd:         answer.stackTraceEnabled = stackTraceEnabled;
1:22bb1bd:         answer.tcpNoDelayEnabled = tcpNoDelayEnabled;
1:22bb1bd:         answer.cacheEnabled = cacheEnabled;
1:22bb1bd:         answer.tightEncodingEnabled = tightEncodingEnabled;
1:22bb1bd:         answer.sizePrefixDisabled = sizePrefixDisabled;
1:4446d55:         answer.preferedWireFormatInfo = preferedWireFormatInfo;
1:8704338:         return answer;
1:6583ef1:     }
1:230a86c: 
1:13044de:     @Override
1:d29ca2a:     public boolean equals(Object object) {
1:ecf89a6:         if (object == null) {
1:d29ca2a:             return false;
1:ecf89a6:         }
1:230a86c:         OpenWireFormat o = (OpenWireFormat)object;
1:230a86c:         return o.stackTraceEnabled == stackTraceEnabled && o.cacheEnabled == cacheEnabled
1:230a86c:                && o.version == version && o.tightEncodingEnabled == tightEncodingEnabled
1:230a86c:                && o.sizePrefixDisabled == sizePrefixDisabled;
1:6583ef1:     }
1:230a86c: 
1:230a86c: 
1:13044de:     @Override
1:d29ca2a:     public String toString() {
1:230a86c:         return "OpenWireFormat{version=" + version + ", cacheEnabled=" + cacheEnabled + ", stackTraceEnabled=" + stackTraceEnabled + ", tightEncodingEnabled="
1:e5e99d7:                + tightEncodingEnabled + ", sizePrefixDisabled=" + sizePrefixDisabled +  ", maxFrameSize=" + maxFrameSize + "}";
1:230a86c:         // return "OpenWireFormat{id="+id+",
1:230a86c:         // tightEncodingEnabled="+tightEncodingEnabled+"}";
6:d29ca2a:     }
1:230a86c: 
1:13044de:     @Override
1:d29ca2a:     public int getVersion() {
1:d29ca2a:         return version;
1:d29ca2a:     }
1:230a86c: 
1:13044de:     @Override
1:4b5bc5e:     public synchronized ByteSequence marshal(Object command) throws IOException {
1:230a86c: 
1:230a86c:         if (cacheEnabled) {
1:b665f18:             runMarshallCacheEvictionSweep();
1:b665f18:         }
1:230a86c: 
1:230a86c:         ByteSequence sequence = null;
1:5e14eec:         int size = 1;
1:5e14eec:         if (command != null) {
1:230a86c: 
1:5e14eec:             DataStructure c = (DataStructure)command;
1:5e14eec:             byte type = c.getDataStructureType();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:5e14eec:             if (dsm == null) {
1:5e14eec:                 throw new IOException("Unknown data type: " + type);
1:5e14eec:             }
1:5e14eec:             if (tightEncodingEnabled) {
1:230a86c: 
1:5e14eec:                 BooleanStream bs = new BooleanStream();
1:5e14eec:                 size += dsm.tightMarshal1(this, c, bs);
1:5e14eec:                 size += bs.marshalledSize();
1:230a86c: 
1:5e14eec:                 bytesOut.restart(size);
1:5e14eec:                 if (!sizePrefixDisabled) {
1:5e14eec:                     bytesOut.writeInt(size);
1:ecf89a6:                 }
1:5e14eec:                 bytesOut.writeByte(type);
1:5e14eec:                 bs.marshal(bytesOut);
1:5e14eec:                 dsm.tightMarshal2(this, c, bytesOut, bs);
1:5e14eec:                 sequence = bytesOut.toByteSequence();
1:230a86c: 
1:aa54a8b:             } else {
1:5e14eec:                 bytesOut.restart();
1:5e14eec:                 if (!sizePrefixDisabled) {
1:5e14eec:                     bytesOut.writeInt(0); // we don't know the final size
1:5e14eec:                     // yet but write this here for
1:5e14eec:                     // now.
1:5e14eec:                 }
1:5e14eec:                 bytesOut.writeByte(type);
1:5e14eec:                 dsm.looseMarshal(this, c, bytesOut);
2:4821b9d:                 sequence = bytesOut.toByteSequence();
1:5e14eec: 
1:5e14eec:                 if (!sizePrefixDisabled) {
1:5e14eec:                     size = sequence.getLength() - 4;
1:5e14eec:                     int pos = sequence.offset;
1:5e14eec:                     ByteSequenceData.writeIntBig(sequence, size);
1:5e14eec:                     sequence.offset = pos;
1:5e14eec:                 }
1:ecf89a6:             }
1:230a86c: 
1:5e14eec:         } else {
1:5e14eec:             bytesOut.restart(5);
1:5e14eec:             bytesOut.writeInt(size);
1:5e14eec:             bytesOut.writeByte(NULL_TYPE);
1:5e14eec:             sequence = bytesOut.toByteSequence();
1:d671875:         }
1:5e14eec: 
1:88acb0e:         return sequence;
1:6583ef1:     }
1:230a86c: 
1:13044de:     @Override
1:4b5bc5e:     public synchronized Object unmarshal(ByteSequence sequence) throws IOException {
1:4821b9d:         bytesIn.restart(sequence);
1:230a86c:         // DataInputStream dis = new DataInputStream(new
1:230a86c:         // ByteArrayInputStream(sequence));
1:230a86c: 
1:747b2dd:         if (!sizePrefixDisabled) {
1:4821b9d:             int size = bytesIn.readInt();
1:230a86c:             if (sequence.getLength() - 4 != size) {
1:230a86c:                 // throw new IOException("Packet size does not match marshaled
1:230a86c:                 // size");
1:b665f18:             }
1:230a86c: 
1:a4b8c8e:             if (size > maxFrameSize) {
1:98165c4:                 throw IOExceptionSupport.createFrameSizeException(size, maxFrameSize);
1:33b73ac:             }
1:d29ca2a:         }
1:230a86c: 
1:4821b9d:         Object command = doUnmarshal(bytesIn);
1:230a86c:         // if( !cacheEnabled && ((DataStructure)command).isMarshallAware() ) {
1:230a86c:         // ((MarshallAware) command).setCachedMarshalledForm(this, sequence);
2:230a86c:         // }
1:d29ca2a:         return command;
1:d29ca2a:     }
1:230a86c: 
1:13044de:     @Override
1:4b5bc5e:     public synchronized void marshal(Object o, DataOutput dataOut) throws IOException {
1:230a86c: 
1:230a86c:         if (cacheEnabled) {
1:b665f18:             runMarshallCacheEvictionSweep();
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         int size = 1;
1:230a86c:         if (o != null) {
1:230a86c: 
1:230a86c:             DataStructure c = (DataStructure)o;
1:d29ca2a:             byte type = c.getDataStructureType();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + type);
1:ecf89a6:             }
2:230a86c:             if (tightEncodingEnabled) {
1:230a86c:                 BooleanStream bs = new BooleanStream();
1:230a86c:                 size += dsm.tightMarshal1(this, c, bs);
1:230a86c:                 size += bs.marshalledSize();
1:230a86c: 
3:230a86c:                 if (!sizePrefixDisabled) {
1:13044de:                     dataOut.writeInt(size);
1:747b2dd:                 }
1:230a86c: 
1:230a86c:                 dataOut.writeByte(type);
1:230a86c:                 bs.marshal(dataOut);
1:230a86c:                 dsm.tightMarshal2(this, c, dataOut, bs);
1:230a86c: 
1:230a86c:             } else {
1:230a86c:                 DataOutput looseOut = dataOut;
1:230a86c: 
1:230a86c:                 if (!sizePrefixDisabled) {
1:230a86c:                     bytesOut.restart();
1:230a86c:                     looseOut = bytesOut;
1:ecf89a6:                 }
1:230a86c: 
1:6583ef1:                 looseOut.writeByte(type);
1:6583ef1:                 dsm.looseMarshal(this, c, looseOut);
1:230a86c: 
1:230a86c:                 if (!sizePrefixDisabled) {
1:4821b9d:                     ByteSequence sequence = bytesOut.toByteSequence();
1:d671875:                     dataOut.writeInt(sequence.getLength());
1:6583ef1:                     dataOut.write(sequence.getData(), sequence.getOffset(), sequence.getLength());
1:ecf89a6:                 }
1:230a86c: 
1:6583ef1:             }
1:1a3f54c: 
1:6583ef1:         } else {
1:230a86c:             if (!sizePrefixDisabled) {
1:747b2dd:                 dataOut.writeInt(size);
1:6583ef1:             }
1:6583ef1:             dataOut.writeByte(NULL_TYPE);
1:d29ca2a:         }
1:d29ca2a:     }
1:1a3f54c: 
1:13044de:     @Override
1:4821b9d:     public Object unmarshal(DataInput dis) throws IOException {
1:4821b9d:         DataInput dataIn = dis;
1:230a86c:         if (!sizePrefixDisabled) {
1:230a86c:             int size = dis.readInt();
1:8a82119:             if (size > maxFrameSize) {
1:98165c4:                 throw IOExceptionSupport.createFrameSizeException(size, maxFrameSize);
1:6583ef1:             }
1:ecf89a6:             // int size = dis.readInt();
1:230a86c:             // byte[] data = new byte[size];
1:230a86c:             // dis.readFully(data);
1:230a86c:             // bytesIn.restart(data);
1:230a86c:             // dataIn = bytesIn;
1:33b73ac:         }
1:4821b9d:         return doUnmarshal(dataIn);
1:d29ca2a:     }
1:230a86c: 
1:f8e1c0e:     /**
1:f8e1c0e:      * Used by NIO or AIO transports
1:f8e1c0e:      */
1:f8e1c0e:     public int tightMarshal1(Object o, BooleanStream bs) throws IOException {
1:230a86c:         int size = 1;
1:230a86c:         if (o != null) {
1:230a86c:             DataStructure c = (DataStructure)o;
1:d29ca2a:             byte type = c.getDataStructureType();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + type);
1:d29ca2a:             }
1:1a3f54c: 
1:6583ef1:             size += dsm.tightMarshal1(this, c, bs);
1:230a86c:             size += bs.marshalledSize();
1:d29ca2a:         }
1:f8e1c0e:         return size;
1:d29ca2a:     }
1:230a86c: 
1:f8e1c0e:     /**
1:230a86c:      * Used by NIO or AIO transports; note that the size is not written as part
1:230a86c:      * of this method.
1:f8e1c0e:      */
1:4821b9d:     public void tightMarshal2(Object o, DataOutput ds, BooleanStream bs) throws IOException {
1:230a86c:         if (cacheEnabled) {
1:f8e1c0e:             runMarshallCacheEvictionSweep();
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         if (o != null) {
1:230a86c:             DataStructure c = (DataStructure)o;
1:230a86c:             byte type = c.getDataStructureType();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + type);
1:d29ca2a:             }
1:230a86c:             ds.writeByte(type);
1:33b73ac:             bs.marshal(ds);
1:230a86c:             dsm.tightMarshal2(this, c, ds, bs);
1:230a86c:         }
1:33b73ac:     }
1:a0e92d7: 
1:d29ca2a:     /**
1:230a86c:      * Allows you to dynamically switch the version of the openwire protocol
1:230a86c:      * being used.
1:13044de:      *
1:d29ca2a:      * @param version
1:d29ca2a:      */
1:13044de:     @Override
1:d29ca2a:     public void setVersion(int version) {
1:230a86c:         String mfName = "org.apache.activemq.openwire.v" + version + ".MarshallerFactory";
1:d29ca2a:         Class mfClass;
1:d29ca2a:         try {
1:27c87d2:             mfClass = Class.forName(mfName, false, getClass().getClassLoader());
1:d29ca2a:         } catch (ClassNotFoundException e) {
1:230a86c:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid version: " + version
1:230a86c:                                                                          + ", could not load " + mfName)
1:230a86c:                 .initCause(e);
1:33b73ac:         }
1:d29ca2a:         try {
1:230a86c:             Method method = mfClass.getMethod("createMarshallerMap", new Class[] {OpenWireFormat.class});
1:230a86c:             dataMarshallers = (DataStreamMarshaller[])method.invoke(null, new Object[] {this});
1:d29ca2a:         } catch (Throwable e) {
1:230a86c:             throw (IllegalArgumentException)new IllegalArgumentException(
1:230a86c:                                                                          "Invalid version: "
1:230a86c:                                                                              + version
1:230a86c:                                                                              + ", "
1:230a86c:                                                                              + mfName
1:230a86c:                                                                              + " does not properly implement the createMarshallerMap method.")
1:230a86c:                 .initCause(e);
1:33b73ac:         }
1:d29ca2a:         this.version = version;
1:d29ca2a:     }
1:230a86c: 
1:4821b9d:     public Object doUnmarshal(DataInput dis) throws IOException {
1:33b73ac:         byte dataType = dis.readByte();
1:230a86c:         if (dataType != NULL_TYPE) {
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + dataType);
1:ecf89a6:             }
1:d29ca2a:             Object data = dsm.createObject();
1:230a86c:             if (this.tightEncodingEnabled) {
1:6583ef1:                 BooleanStream bs = new BooleanStream();
1:33b73ac:                 bs.unmarshal(dis);
1:33b73ac:                 dsm.tightUnmarshal(this, data, dis, bs);
1:33b73ac:             } else {
1:33b73ac:                 dsm.looseUnmarshal(this, data, dis);
1:ecf89a6:             }
1:d29ca2a:             return data;
1:33b73ac:         } else {
1:d29ca2a:             return null;
1:ecf89a6:         }
1:33b73ac:     }
1:aa54a8b: 
1:230a86c:     // public void debug(String msg) {
1:230a86c:     // String t = (Thread.currentThread().getName()+" ").substring(0, 40);
1:230a86c:     // System.out.println(t+": "+msg);
1:230a86c:     // }
1:33b73ac:     public int tightMarshalNestedObject1(DataStructure o, BooleanStream bs) throws IOException {
1:d29ca2a:         bs.writeBoolean(o != null);
1:ecf89a6:         if (o == null) {
1:d29ca2a:             return 0;
1:ecf89a6:         }
1:aa54a8b: 
1:230a86c:         if (o.isMarshallAware()) {
1:ecf89a6:             // MarshallAware ma = (MarshallAware)o;
1:230a86c:             ByteSequence sequence = null;
1:230a86c:             // sequence=ma.getCachedMarshalledForm(this);
1:230a86c:             bs.writeBoolean(sequence != null);
1:230a86c:             if (sequence != null) {
1:230a86c:                 return 1 + sequence.getLength();
1:d29ca2a:             }
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         byte type = o.getDataStructureType();
1:13044de:         DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:         if (dsm == null) {
1:230a86c:             throw new IOException("Unknown data type: " + type);
1:ecf89a6:         }
1:33b73ac:         return 1 + dsm.tightMarshal1(this, o, bs);
1:ecf89a6:     }
1:230a86c: 
1:230a86c:     public void tightMarshalNestedObject2(DataStructure o, DataOutput ds, BooleanStream bs)
1:230a86c:         throws IOException {
1:ecf89a6:         if (!bs.readBoolean()) {
1:d29ca2a:             return;
1:ecf89a6:         }
1:230a86c: 
1:d29ca2a:         byte type = o.getDataStructureType();
2:33b73ac:         ds.writeByte(type);
1:aa54a8b: 
1:230a86c:         if (o.isMarshallAware() && bs.readBoolean()) {
1:d671875: 
1:230a86c:             // We should not be doing any caching
1:230a86c:             throw new IOException("Corrupted stream");
1:230a86c:             // MarshallAware ma = (MarshallAware) o;
1:230a86c:             // ByteSequence sequence=ma.getCachedMarshalledForm(this);
1:230a86c:             // ds.write(sequence.getData(), sequence.getOffset(),
1:230a86c:             // sequence.getLength());
1:230a86c: 
4:d29ca2a:         } else {
1:230a86c: 
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:             if (dsm == null) {
2:230a86c:                 throw new IOException("Unknown data type: " + type);
1:d29ca2a:             }
1:33b73ac:             dsm.tightMarshal2(this, o, ds, bs);
1:230a86c: 
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:4821b9d:     public DataStructure tightUnmarshalNestedObject(DataInput dis, BooleanStream bs) throws IOException {
1:230a86c:         if (bs.readBoolean()) {
1:230a86c: 
1:d29ca2a:             byte dataType = dis.readByte();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + dataType);
1:d29ca2a:             }
1:33b73ac:             DataStructure data = dsm.createObject();
1:d671875: 
1:230a86c:             if (data.isMarshallAware() && bs.readBoolean()) {
1:230a86c: 
1:ecf89a6:                 dis.readInt();
1:d29ca2a:                 dis.readByte();
1:230a86c: 
1:d29ca2a:                 BooleanStream bs2 = new BooleanStream();
1:d29ca2a:                 bs2.unmarshal(dis);
1:33b73ac:                 dsm.tightUnmarshal(this, data, dis, bs2);
1:230a86c: 
1:d29ca2a:                 // TODO: extract the sequence from the dis and associate it.
1:230a86c:                 // MarshallAware ma = (MarshallAware)data
1:230a86c:                 // ma.setCachedMarshalledForm(this, sequence);
1:230a86c: 
1:33b73ac:             } else {
1:33b73ac:                 dsm.tightUnmarshal(this, data, dis, bs);
1:6583ef1:             }
1:230a86c: 
1:33b73ac:             return data;
1:d29ca2a:         } else {
1:33b73ac:             return null;
1:33b73ac:         }
1:33b73ac:     }
1:230a86c: 
1:4821b9d:     public DataStructure looseUnmarshalNestedObject(DataInput dis) throws IOException {
1:230a86c:         if (dis.readBoolean()) {
1:230a86c: 
1:d29ca2a:             byte dataType = dis.readByte();
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + dataType);
1:d29ca2a:             }
1:d29ca2a:             DataStructure data = dsm.createObject();
1:33b73ac:             dsm.looseUnmarshal(this, data, dis);
1:d29ca2a:             return data;
1:f451ad0: 
1:d29ca2a:         } else {
1:d29ca2a:             return null;
1:d29ca2a:         }
1:d29ca2a:     }
1:6583ef1: 
1:4821b9d:     public void looseMarshalNestedObject(DataStructure o, DataOutput dataOut) throws IOException {
1:230a86c:         dataOut.writeBoolean(o != null);
1:230a86c:         if (o != null) {
1:33b73ac:             byte type = o.getDataStructureType();
1:6583ef1:             dataOut.writeByte(type);
1:13044de:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
1:ecf89a6:             if (dsm == null) {
1:230a86c:                 throw new IOException("Unknown data type: " + type);
1:d29ca2a:             }
1:33b73ac:             dsm.looseMarshal(this, o, dataOut);
1:33b73ac:         }
1:33b73ac:     }
1:6583ef1: 
1:b665f18:     public void runMarshallCacheEvictionSweep() {
1:b665f18:         // Do we need to start evicting??
1:230a86c:         while (marshallCacheMap.size() > marshallCache.length - MARSHAL_CACHE_FREE_SPACE) {
1:230a86c: 
1:b665f18:             marshallCacheMap.remove(marshallCache[nextMarshallCacheEvictionIndex]);
1:230a86c:             marshallCache[nextMarshallCacheEvictionIndex] = null;
1:6583ef1: 
1:b665f18:             nextMarshallCacheEvictionIndex++;
1:230a86c:             if (nextMarshallCacheEvictionIndex >= marshallCache.length) {
1:230a86c:                 nextMarshallCacheEvictionIndex = 0;
1:b665f18:             }
1:230a86c: 
1:b665f18:         }
1:b665f18:     }
1:230a86c: 
1:b665f18:     public Short getMarshallCacheIndex(DataStructure o) {
1:ecf89a6:         return marshallCacheMap.get(o);
1:d29ca2a:     }
1:230a86c: 
1:b665f18:     public Short addToMarshallCache(DataStructure o) {
1:b665f18:         short i = nextMarshallCacheIndex++;
1:230a86c:         if (nextMarshallCacheIndex >= marshallCache.length) {
1:230a86c:             nextMarshallCacheIndex = 0;
1:d29ca2a:         }
1:230a86c: 
1:db9144a:         // We can only cache that item if there is space left.
1:230a86c:         if (marshallCacheMap.size() < marshallCache.length) {
1:db9144a:             marshallCache[i] = o;
1:db9144a:             Short index = new Short(i);
1:db9144a:             marshallCacheMap.put(o, index);
1:db9144a:             return index;
1:db9144a:         } else {
1:230a86c:             // Use -1 to indicate that the value was not cached due to cache
1:230a86c:             // being full.
1:db9144a:             return new Short((short)-1);
1:db9144a:         }
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setInUnmarshallCache(short index, DataStructure o) {
1:230a86c: 
1:db9144a:         // There was no space left in the cache, so we can't
1:db9144a:         // put this in the cache.
1:ecf89a6:         if (index == -1) {
1:db9144a:             return;
1:ecf89a6:         }
1:230a86c: 
1:230a86c:         unmarshallCache[index] = o;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public DataStructure getFromUnmarshallCache(short index) {
1:d29ca2a:         return unmarshallCache[index];
1:d29ca2a:     }
1:6583ef1: 
1:d29ca2a:     public void setStackTraceEnabled(boolean b) {
1:d29ca2a:         stackTraceEnabled = b;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public boolean isStackTraceEnabled() {
1:d29ca2a:         return stackTraceEnabled;
1:d29ca2a:     }
1:6583ef1: 
1:d29ca2a:     public boolean isTcpNoDelayEnabled() {
1:d29ca2a:         return tcpNoDelayEnabled;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setTcpNoDelayEnabled(boolean tcpNoDelayEnabled) {
1:d29ca2a:         this.tcpNoDelayEnabled = tcpNoDelayEnabled;
1:d29ca2a:     }
1:6583ef1: 
1:d29ca2a:     public boolean isCacheEnabled() {
1:d29ca2a:         return cacheEnabled;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setCacheEnabled(boolean cacheEnabled) {
1:5bd4b19:         if(cacheEnabled){
1:5bd4b19:             marshallCache = new DataStructure[MARSHAL_CACHE_SIZE];
1:5bd4b19:             unmarshallCache = new DataStructure[MARSHAL_CACHE_SIZE];
1:d29ca2a:         }
1:d29ca2a:         this.cacheEnabled = cacheEnabled;
1:d29ca2a:     }
1:6583ef1: 
1:33b73ac:     public boolean isTightEncodingEnabled() {
1:33b73ac:         return tightEncodingEnabled;
1:33b73ac:     }
1:6583ef1: 
1:33b73ac:     public void setTightEncodingEnabled(boolean tightEncodingEnabled) {
1:33b73ac:         this.tightEncodingEnabled = tightEncodingEnabled;
1:33b73ac:     }
1:6583ef1: 
1:6583ef1:     public boolean isSizePrefixDisabled() {
1:6583ef1:         return sizePrefixDisabled;
1:33b73ac:     }
2:6583ef1: 
1:6583ef1:     public void setSizePrefixDisabled(boolean prefixPacketSize) {
1:6583ef1:         this.sizePrefixDisabled = prefixPacketSize;
1:6583ef1:     }
1:6583ef1: 
1:230a86c:     public void setPreferedWireFormatInfo(WireFormatInfo info) {
1:230a86c:         this.preferedWireFormatInfo = info;
1:230a86c:     }
1:6583ef1: 
1:230a86c:     public WireFormatInfo getPreferedWireFormatInfo() {
1:230a86c:         return preferedWireFormatInfo;
1:230a86c:     }
1:230a86c: 
1:e5e99d7:     public long getMaxFrameSize() {
1:e5e99d7:         return maxFrameSize;
1:6583ef1:     }
1:6583ef1: 
1:e5e99d7:     public void setMaxFrameSize(long maxFrameSize) {
1:e5e99d7:         this.maxFrameSize = maxFrameSize;
1:33b73ac:     }
1:6583ef1: 
1:230a86c:     public void renegotiateWireFormat(WireFormatInfo info) throws IOException {
1:230a86c: 
1:ecf89a6:         if (preferedWireFormatInfo == null) {
1:230a86c:             throw new IllegalStateException("Wireformat cannot not be renegotiated.");
1:ecf89a6:         }
1:230a86c: 
1:230a86c:         this.setVersion(min(preferedWireFormatInfo.getVersion(), info.getVersion()));
1:230a86c:         info.setVersion(this.getVersion());
1:230a86c: 
1:e5e99d7:         this.setMaxFrameSize(min(preferedWireFormatInfo.getMaxFrameSize(), info.getMaxFrameSize()));
1:e5e99d7:         info.setMaxFrameSize(this.getMaxFrameSize());
1:1a3f54c: 
1:230a86c:         this.stackTraceEnabled = info.isStackTraceEnabled() && preferedWireFormatInfo.isStackTraceEnabled();
1:230a86c:         info.setStackTraceEnabled(this.stackTraceEnabled);
1:230a86c: 
1:230a86c:         this.tcpNoDelayEnabled = info.isTcpNoDelayEnabled() && preferedWireFormatInfo.isTcpNoDelayEnabled();
1:230a86c:         info.setTcpNoDelayEnabled(this.tcpNoDelayEnabled);
1:230a86c: 
1:230a86c:         this.cacheEnabled = info.isCacheEnabled() && preferedWireFormatInfo.isCacheEnabled();
1:230a86c:         info.setCacheEnabled(this.cacheEnabled);
1:230a86c: 
1:230a86c:         this.tightEncodingEnabled = info.isTightEncodingEnabled()
1:230a86c:                                     && preferedWireFormatInfo.isTightEncodingEnabled();
1:230a86c:         info.setTightEncodingEnabled(this.tightEncodingEnabled);
1:230a86c: 
1:230a86c:         this.sizePrefixDisabled = info.isSizePrefixDisabled()
1:230a86c:                                   && preferedWireFormatInfo.isSizePrefixDisabled();
1:230a86c:         info.setSizePrefixDisabled(this.sizePrefixDisabled);
1:230a86c: 
1:230a86c:         if (cacheEnabled) {
1:230a86c: 
1:230a86c:             int size = Math.min(preferedWireFormatInfo.getCacheSize(), info.getCacheSize());
1:230a86c:             info.setCacheSize(size);
1:230a86c: 
1:230a86c:             if (size == 0) {
1:230a86c:                 size = MARSHAL_CACHE_SIZE;
1:230a86c:             }
1:230a86c: 
1:230a86c:             marshallCache = new DataStructure[size];
1:230a86c:             unmarshallCache = new DataStructure[size];
1:230a86c:             nextMarshallCacheIndex = 0;
1:230a86c:             nextMarshallCacheEvictionIndex = 0;
1:ecf89a6:             marshallCacheMap = new HashMap<DataStructure, Short>();
1:230a86c:         } else {
1:230a86c:             marshallCache = null;
1:230a86c:             unmarshallCache = null;
1:230a86c:             nextMarshallCacheIndex = 0;
1:230a86c:             nextMarshallCacheEvictionIndex = 0;
1:230a86c:             marshallCacheMap = null;
1:230a86c:         }
1:230a86c: 
1:230a86c:     }
1:1a3f54c: 
1:f6d4f9f:     protected int min(int version1, int version2) {
1:f6d4f9f:         if (version1 < version2 && version1 > 0 || version2 <= 0) {
1:f6d4f9f:             return version1;
1:aa54a8b:         }
1:f6d4f9f:         return version2;
1:6583ef1:     }
1:1a3f54c: 
1:e5e99d7:     protected long min(long version1, long version2) {
1:e5e99d7:         if (version1 < version2 && version1 > 0 || version2 <= 0) {
1:e5e99d7:             return version1;
1:d29ca2a:         }
1:e5e99d7:         return version2;
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:98165c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:                 throw IOExceptionSupport.createFrameSizeException(size, maxFrameSize);
/////////////////////////////////////////////////////////////////////////
1:                 throw IOExceptionSupport.createFrameSizeException(size, maxFrameSize);
commit:13044de
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:     public static final int DEFAULT_STORE_VERSION = CommandTypes.PROTOCOL_STORE_VERSION;
1:     public static final int DEFAULT_LEGACY_VERSION = CommandTypes.PROTOCOL_LEGACY_STORE_VERSION;
/////////////////////////////////////////////////////////////////////////
1: 
1:         this(DEFAULT_STORE_VERSION);
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:                 dataOut.writeInt(size);
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:      *
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:         DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[dataType & 0xFF];
/////////////////////////////////////////////////////////////////////////
1:             DataStreamMarshaller dsm = dataMarshallers[type & 0xFF];
author:Kevin Earls
-------------------------------------------------------------------------------
commit:5e14eec
/////////////////////////////////////////////////////////////////////////
1:         int size = 1;
1:         if (command != null) {
1:             DataStructure c = (DataStructure)command;
1:             byte type = c.getDataStructureType();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
1:             if (dsm == null) {
1:                 throw new IOException("Unknown data type: " + type);
1:             }
1:             if (tightEncodingEnabled) {
1:                 BooleanStream bs = new BooleanStream();
1:                 size += dsm.tightMarshal1(this, c, bs);
1:                 size += bs.marshalledSize();
1:                 bytesOut.restart(size);
1:                 if (!sizePrefixDisabled) {
1:                     bytesOut.writeInt(size);
1:                 bytesOut.writeByte(type);
1:                 bs.marshal(bytesOut);
1:                 dsm.tightMarshal2(this, c, bytesOut, bs);
1:                 sequence = bytesOut.toByteSequence();
1:                 bytesOut.restart();
1:                 if (!sizePrefixDisabled) {
1:                     bytesOut.writeInt(0); // we don't know the final size
1:                     // yet but write this here for
1:                     // now.
1:                 }
1:                 bytesOut.writeByte(type);
1:                 dsm.looseMarshal(this, c, bytesOut);
1: 
1:                 if (!sizePrefixDisabled) {
1:                     size = sequence.getLength() - 4;
1:                     int pos = sequence.offset;
1:                     ByteSequenceData.writeIntBig(sequence, size);
1:                     sequence.offset = pos;
1:                 }
1:         } else {
1:             bytesOut.restart(5);
1:             bytesOut.writeInt(size);
1:             bytesOut.writeByte(NULL_TYPE);
1:             sequence = bytesOut.toByteSequence();
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:747b2dd
/////////////////////////////////////////////////////////////////////////
1:             if (!sizePrefixDisabled) {
1:             	dataOut.writeInt(size);
1:             }
commit:27c87d2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             mfClass = Class.forName(mfName, false, getClass().getClassLoader());
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     private boolean stackTraceEnabled;
1:     private boolean tcpNoDelayEnabled;
1:     private boolean cacheEnabled;
1:     private boolean tightEncodingEnabled;
1:     private boolean sizePrefixDisabled;
1:     private short nextMarshallCacheIndex;
1:     private short nextMarshallCacheEvictionIndex;
1:     private Map<DataStructure, Short> marshallCacheMap = new HashMap<DataStructure, Short>();
/////////////////////////////////////////////////////////////////////////
1:         if (object == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0: //        MarshallAware ma = null;
0: //        // If not using value caching, then the marshaled form is always the
0: //        // same
0: //        if (!cacheEnabled && ((DataStructure)command).isMarshallAware()) {
0: //            ma = (MarshallAware)command;
0: //        }
/////////////////////////////////////////////////////////////////////////
1:                 if (dsm == null) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             dis.readInt();
1:             // int size = dis.readInt();
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (o == null) {
1:         }
1:             // MarshallAware ma = (MarshallAware)o;
/////////////////////////////////////////////////////////////////////////
1:         if (dsm == null) {
1:         }
1:         if (!bs.readBoolean()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (dsm == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         return marshallCacheMap.get(o);
/////////////////////////////////////////////////////////////////////////
1:         if (index == -1) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (preferedWireFormatInfo == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             marshallCacheMap = new HashMap<DataStructure, Short>();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: public final class OpenWireFormat implements WireFormat {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:     private static final int MARSHAL_CACHE_SIZE = Short.MAX_VALUE / 2;
1: 
0:     private boolean stackTraceEnabled = false;
0:     private boolean tcpNoDelayEnabled = false;
0:     private boolean cacheEnabled = false;
0:     private boolean tightEncodingEnabled = false;
0:     private boolean sizePrefixDisabled = false;
0:     private short nextMarshallCacheIndex = 0;
0:     private short nextMarshallCacheEvictionIndex = 0;
1:     private WireFormatInfo preferedWireFormatInfo;
1:     public OpenWireFormat() {
0:         this(DEFAULT_VERSION);
1: 
1:     public OpenWireFormat(int i) {
1:         setVersion(i);
1:     }
1: 
1:     public int hashCode() {
1:         return version ^ (cacheEnabled ? 0x10000000 : 0x20000000)
1:                ^ (stackTraceEnabled ? 0x01000000 : 0x02000000)
1:                ^ (tightEncodingEnabled ? 0x00100000 : 0x00200000)
1:                ^ (sizePrefixDisabled ? 0x00010000 : 0x00020000);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (object == null)
1:         OpenWireFormat o = (OpenWireFormat)object;
1:         return o.stackTraceEnabled == stackTraceEnabled && o.cacheEnabled == cacheEnabled
1:                && o.version == version && o.tightEncodingEnabled == tightEncodingEnabled
1:                && o.sizePrefixDisabled == sizePrefixDisabled;
1: 
1: 
1:         return "OpenWireFormat{version=" + version + ", cacheEnabled=" + cacheEnabled + ", stackTraceEnabled=" + stackTraceEnabled + ", tightEncodingEnabled="
0:                + tightEncodingEnabled + ", sizePrefixDisabled=" + sizePrefixDisabled + "}";
1:         // return "OpenWireFormat{id="+id+",
1:         // tightEncodingEnabled="+tightEncodingEnabled+"}";
1: 
1: 
1: 
1:         if (cacheEnabled) {
1: 
0:         MarshallAware ma = null;
0:         // If not using value caching, then the marshaled form is always the
0:         // same
0:         if (!cacheEnabled && ((DataStructure)command).isMarshallAware()) {
0:             ma = (MarshallAware)command;
1: 
1:         ByteSequence sequence = null;
0:         // if( ma!=null ) {
0:         // sequence = ma.getCachedMarshalledForm(this);
1:         // }
1: 
0:         if (sequence == null) {
1: 
1:             int size = 1;
0:             if (command != null) {
1: 
0:                 DataStructure c = (DataStructure)command;
0:                 DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:                 if (dsm == null)
1:                     throw new IOException("Unknown data type: " + type);
1: 
1:                 if (tightEncodingEnabled) {
1: 
1: 
1:                     if (!sizePrefixDisabled) {
0:                     dsm.tightMarshal2(this, c, bytesOut, bs);
1: 
1:                     if (!sizePrefixDisabled) {
0:                         bytesOut.writeInt(0); // we don't know the final size
0:                                                 // yet but write this here for
0:                                                 // now.
0:                     dsm.looseMarshal(this, c, bytesOut);
1: 
1:                     if (!sizePrefixDisabled) {
0:                         size = sequence.getLength() - 4;
1: 
1: 
0:             // if( ma!=null ) {
1:             // ma.setCachedMarshalledForm(this, sequence);
1:             // }
1: 
1:         // DataInputStream dis = new DataInputStream(new
1:         // ByteArrayInputStream(sequence));
1: 
1:         if (!sizePrefixDisabled) {
1:             if (sequence.getLength() - 4 != size) {
1:                 // throw new IOException("Packet size does not match marshaled
1:                 // size");
1: 
1:         // if( !cacheEnabled && ((DataStructure)command).isMarshallAware() ) {
1:         // ((MarshallAware) command).setCachedMarshalledForm(this, sequence);
1:         // }
1: 
1: 
1:         if (cacheEnabled) {
1: 
1:         int size = 1;
1:         if (o != null) {
1: 
1:             DataStructure c = (DataStructure)o;
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + type);
1:             if (tightEncodingEnabled) {
1:                 BooleanStream bs = new BooleanStream();
1:                 size += dsm.tightMarshal1(this, c, bs);
1:                 size += bs.marshalledSize();
1:                 if (!sizePrefixDisabled) {
1: 
1:                 dataOut.writeByte(type);
1:                 bs.marshal(dataOut);
1:                 dsm.tightMarshal2(this, c, dataOut, bs);
1: 
1:             } else {
1:                 DataOutput looseOut = dataOut;
1: 
1:                 if (!sizePrefixDisabled) {
1:                     bytesOut.restart();
1:                     looseOut = bytesOut;
1: 
1: 
1:                 if (!sizePrefixDisabled) {
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (!sizePrefixDisabled) {
1:             int size = dis.readInt();
1:             // byte[] data = new byte[size];
1:             // dis.readFully(data);
1:             // bytesIn.restart(data);
1:             // dataIn = bytesIn;
1: 
0:         int size = 1;
1:         if (o != null) {
1:             DataStructure c = (DataStructure)o;
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + type);
1:             size += bs.marshalledSize();
1: 
1:      * Used by NIO or AIO transports; note that the size is not written as part
1:      * of this method.
1:         if (cacheEnabled) {
1:         if (o != null) {
1:             DataStructure c = (DataStructure)o;
1:             byte type = c.getDataStructureType();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + type);
1: 
1:             ds.writeByte(type);
1:             dsm.tightMarshal2(this, c, ds, bs);
1:         }
1:      * Allows you to dynamically switch the version of the openwire protocol
1:      * being used.
1:      * 
1:         String mfName = "org.apache.activemq.openwire.v" + version + ".MarshallerFactory";
1:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid version: " + version
1:                                                                          + ", could not load " + mfName)
1:                 .initCause(e);
1:             Method method = mfClass.getMethod("createMarshallerMap", new Class[] {OpenWireFormat.class});
1:             dataMarshallers = (DataStreamMarshaller[])method.invoke(null, new Object[] {this});
1:             throw (IllegalArgumentException)new IllegalArgumentException(
1:                                                                          "Invalid version: "
1:                                                                              + version
1:                                                                              + ", "
1:                                                                              + mfName
1:                                                                              + " does not properly implement the createMarshallerMap method.")
1:                 .initCause(e);
1: 
1:         if (dataType != NULL_TYPE) {
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[dataType & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + dataType);
1:             if (this.tightEncodingEnabled) {
/////////////////////////////////////////////////////////////////////////
1:     // public void debug(String msg) {
1:     // String t = (Thread.currentThread().getName()+" ").substring(0, 40);
1:     // System.out.println(t+": "+msg);
0:     // }
0:         if (o == null)
1:         if (o.isMarshallAware()) {
0:             MarshallAware ma = (MarshallAware)o;
1:             ByteSequence sequence = null;
1:             // sequence=ma.getCachedMarshalledForm(this);
1:             bs.writeBoolean(sequence != null);
1:             if (sequence != null) {
1:                 return 1 + sequence.getLength();
1: 
0:         DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:         if (dsm == null)
1:             throw new IOException("Unknown data type: " + type);
1: 
1:     public void tightMarshalNestedObject2(DataStructure o, DataOutput ds, BooleanStream bs)
1:         throws IOException {
0:         if (!bs.readBoolean())
1: 
1:         if (o.isMarshallAware() && bs.readBoolean()) {
1:             // We should not be doing any caching
1:             throw new IOException("Corrupted stream");
1:             // MarshallAware ma = (MarshallAware) o;
1:             // ByteSequence sequence=ma.getCachedMarshalledForm(this);
1:             // ds.write(sequence.getData(), sequence.getOffset(),
1:             // sequence.getLength());
1: 
1: 
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + type);
1: 
1: 
1:         if (bs.readBoolean()) {
1: 
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[dataType & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + dataType);
1:             if (data.isMarshallAware() && bs.readBoolean()) {
1: 
1: 
1:                 // MarshallAware ma = (MarshallAware)data
0:                 // ma.setCachedMarshalledForm(this, sequence);
1: 
1: 
1: 
1:         if (dis.readBoolean()) {
1: 
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[dataType & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + dataType);
1: 
1:         dataOut.writeBoolean(o != null);
1:         if (o != null) {
0:             DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];
0:             if (dsm == null)
1:                 throw new IOException("Unknown data type: " + type);
1:         while (marshallCacheMap.size() > marshallCache.length - MARSHAL_CACHE_FREE_SPACE) {
1: 
1:             marshallCache[nextMarshallCacheEvictionIndex] = null;
1:             if (nextMarshallCacheEvictionIndex >= marshallCache.length) {
1:                 nextMarshallCacheEvictionIndex = 0;
1: 
1: 
0:         return (Short)marshallCacheMap.get(o);
1: 
1:         if (nextMarshallCacheIndex >= marshallCache.length) {
1:             nextMarshallCacheIndex = 0;
1: 
1:         if (marshallCacheMap.size() < marshallCache.length) {
1:             // Use -1 to indicate that the value was not cached due to cache
1:             // being full.
1: 
1: 
0:         if (index == -1)
1: 
1:         unmarshallCache[index] = o;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setPreferedWireFormatInfo(WireFormatInfo info) {
1:         this.preferedWireFormatInfo = info;
1:     }
1:     public WireFormatInfo getPreferedWireFormatInfo() {
1:         return preferedWireFormatInfo;
1:     }
1: 
1:     public void renegotiateWireFormat(WireFormatInfo info) throws IOException {
1: 
0:         if (preferedWireFormatInfo == null)
1:             throw new IllegalStateException("Wireformat cannot not be renegotiated.");
1: 
1:         this.setVersion(min(preferedWireFormatInfo.getVersion(), info.getVersion()));
1:         info.setVersion(this.getVersion());
1: 
1:         this.stackTraceEnabled = info.isStackTraceEnabled() && preferedWireFormatInfo.isStackTraceEnabled();
1:         info.setStackTraceEnabled(this.stackTraceEnabled);
1: 
1:         this.tcpNoDelayEnabled = info.isTcpNoDelayEnabled() && preferedWireFormatInfo.isTcpNoDelayEnabled();
1:         info.setTcpNoDelayEnabled(this.tcpNoDelayEnabled);
1: 
1:         this.cacheEnabled = info.isCacheEnabled() && preferedWireFormatInfo.isCacheEnabled();
1:         info.setCacheEnabled(this.cacheEnabled);
1: 
1:         this.tightEncodingEnabled = info.isTightEncodingEnabled()
1:                                     && preferedWireFormatInfo.isTightEncodingEnabled();
1:         info.setTightEncodingEnabled(this.tightEncodingEnabled);
1: 
1:         this.sizePrefixDisabled = info.isSizePrefixDisabled()
1:                                   && preferedWireFormatInfo.isSizePrefixDisabled();
1:         info.setSizePrefixDisabled(this.sizePrefixDisabled);
1: 
1:         if (cacheEnabled) {
1: 
1:             int size = Math.min(preferedWireFormatInfo.getCacheSize(), info.getCacheSize());
1:             info.setCacheSize(size);
1: 
1:             if (size == 0) {
1:                 size = MARSHAL_CACHE_SIZE;
1:             }
1: 
1:             marshallCache = new DataStructure[size];
1:             unmarshallCache = new DataStructure[size];
1:             nextMarshallCacheIndex = 0;
1:             nextMarshallCacheEvictionIndex = 0;
0:             marshallCacheMap = new HashMap();
1:         } else {
1:             marshallCache = null;
1:             unmarshallCache = null;
1:             nextMarshallCacheIndex = 0;
1:             nextMarshallCacheEvictionIndex = 0;
1:             marshallCacheMap = null;
1:         }
1: 
1:     }
commit:a0e92d7
/////////////////////////////////////////////////////////////////////////
0: //        if( ma!=null ) {
0: //             sequence = ma.getCachedMarshalledForm(this);
0: //        }
/////////////////////////////////////////////////////////////////////////
0: //            if( ma!=null ) {
0: //                ma.setCachedMarshalledForm(this, sequence);
0: //            }
/////////////////////////////////////////////////////////////////////////
0: //        if( !cacheEnabled && ((DataStructure)command).isMarshallAware() ) {
0: //            ((MarshallAware) command).setCachedMarshalledForm(this, sequence);
0: //        }
/////////////////////////////////////////////////////////////////////////
0:             ByteSequence sequence=null; 
0: //            sequence=ma.getCachedMarshalledForm(this);
/////////////////////////////////////////////////////////////////////////
1: 
0:         	// We should not be doing any caching
0:         	throw new IOException("Corrupted stream");
0: //            MarshallAware ma = (MarshallAware) o;
0: //            ByteSequence sequence=ma.getCachedMarshalledForm(this);
0: //            ds.write(sequence.getData(), sequence.getOffset(), sequence.getLength());
commit:1a3f54c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.CommandTypes;
1: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.MarshallAware;
1: import org.apache.activemq.command.WireFormatInfo;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.util.ByteSequenceData;
0: import org.apache.activemq.util.ClassLoading;
1: import org.apache.activemq.util.DataByteArrayInputStream;
1: import org.apache.activemq.util.DataByteArrayOutputStream;
0: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.wireformat.WireFormat;
1: 
0:     public static final int DEFAULT_VERSION = CommandTypes.PROTOCOL_VERSION;
/////////////////////////////////////////////////////////////////////////
0: 		info.setVersion(this.getVersion());
1: 		
0: 		info.setStackTraceEnabled(this.stackTraceEnabled);
1: 		
0: 		info.setTcpNoDelayEnabled(this.tcpNoDelayEnabled);
1: 		
0: 		info.setCacheEnabled(this.cacheEnabled);
1: 		
0: 		info.setTightEncodingEnabled(this.tightEncodingEnabled);
1: 		
0: 		info.setSizePrefixDisabled(this.sizePrefixDisabled);
0: 			info.setCacheSize(size);
1: 			
commit:4f70250
/////////////////////////////////////////////////////////////////////////
0:     private DataStructure marshallCache[] = new DataStructure[MARSHAL_CACHE_SIZE];
0:     private DataStructure unmarshallCache[] = new DataStructure[MARSHAL_CACHE_SIZE];
commit:aa54a8b
/////////////////////////////////////////////////////////////////////////
1:     private static final int MARSHAL_CACHE_FREE_SPACE = 100;
/////////////////////////////////////////////////////////////////////////
1:     // The following fields are used for value caching
0:     private short nextMarshallCacheEvictionIndex=0;    
0:     private HashMap marshallCacheMap = new HashMap();
0:     private DataStructure marshallCache[];
0:     private DataStructure unmarshallCache[];
/////////////////////////////////////////////////////////////////////////
0:         while( marshallCacheMap.size() > marshallCache.length - MARSHAL_CACHE_FREE_SPACE ) {
0:             if( nextMarshallCacheEvictionIndex >= marshallCache.length ) {
/////////////////////////////////////////////////////////////////////////
0:         if( nextMarshallCacheIndex >= marshallCache.length ) {
0:         if( marshallCacheMap.size() < marshallCache.length ) {
/////////////////////////////////////////////////////////////////////////
0: 		if( cacheEnabled ) {
1: 			
0: 			int size = Math.min(preferedWireFormatInfo.getCacheSize(), info.getCacheSize());
0: 			if( size == 0 ) {
0: 				size = MARSHAL_CACHE_SIZE;
1: 			}
1: 			
0: 		    marshallCache = new DataStructure[size];
0: 		    unmarshallCache = new DataStructure[size];			
0: 		    nextMarshallCacheIndex=0;    
0: 		    nextMarshallCacheEvictionIndex =0;
0: 		    marshallCacheMap = new HashMap();
1: 		} else {
0: 			marshallCache=null;
0: 			unmarshallCache=null;
0: 		    nextMarshallCacheIndex=0;    
0: 		    nextMarshallCacheEvictionIndex=0;    
0: 		    marshallCacheMap = null;
1: 		}
1: 		
commit:937de5b
/////////////////////////////////////////////////////////////////////////
0: 		this.setVersion(Math.min(preferedWireFormatInfo.getVersion(), info.getVersion()) );
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ByteArrayInputStream;
0: import org.apache.activemq.util.ByteArrayOutputStream;
0: import org.apache.activemq.util.ByteSequence;
0: import org.apache.activemq.util.ByteSequenceData;
0: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
0:     public ByteSequence marshal(Object command) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                         int pos = sequence.offset;
0:                         ByteSequenceData.writeIntBig(sequence, size);
0:                         sequence.offset = pos;
/////////////////////////////////////////////////////////////////////////
1:         return sequence;
0:     public Object unmarshal(ByteSequence sequence) throws IOException {
0:         DataInputStream dis = new DataInputStream(new ByteArrayInputStream(sequence));
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:e264e6f
/////////////////////////////////////////////////////////////////////////
0: 	public void renegotiateWireFormat(WireFormatInfo info) throws IOException {
0: 			throw new IllegalStateException("Wireformat cannot not be renegotiated.");
commit:d671875
/////////////////////////////////////////////////////////////////////////
1: 
0:                 if( !sizePrefixDisabled ) {
0:                     dataOut.writeInt(size);
1:                 }
1:                 
1:                 
/////////////////////////////////////////////////////////////////////////
1:                     dataOut.writeInt(sequence.getLength());
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.adapter.PacketToInputStream;
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.packet.ByteArrayPacket;
0: import org.apache.activeio.packet.ByteSequence;
0: import org.apache.activeio.packet.Packet;
0: import org.apache.activeio.packet.PacketData;
0: import org.apache.activeio.util.ByteArrayOutputStream;
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.MarshallAware;
0: import org.apache.activemq.command.WireFormatInfo;
0: import org.apache.activemq.util.ClassLoading;
0: import org.apache.activemq.util.IdGenerator;
1: 
commit:6583ef1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.WireFormatInfo;
0: import org.apache.activemq.util.IdGenerator;
/////////////////////////////////////////////////////////////////////////
0:     private boolean stackTraceEnabled=false;
0:     private boolean cacheEnabled=false;
0:     private boolean tightEncodingEnabled=false;
0:     private boolean sizePrefixDisabled=false;
/////////////////////////////////////////////////////////////////////////
0: 	private WireFormatInfo preferedWireFormatInfo;
1:             
0: 	public OpenWireFormat() {
0: 		this(1);
1: 	}
1: 	
0:     public OpenWireFormat(int i) {
0: 		setVersion(i);
1: 	}
1: 
0: 	public int hashCode() {
0:             ^ (sizePrefixDisabled     ? 0x00010000:0x00020000)
/////////////////////////////////////////////////////////////////////////
0:             o.sizePrefixDisabled == sizePrefixDisabled 
0:     static IdGenerator g = new IdGenerator();
0:     String id = g.generateId();
0:         //return "OpenWireFormat{version="+version+", cacheEnabled="+cacheEnabled+", stackTraceEnabled="+stackTraceEnabled+", tightEncodingEnabled="+tightEncodingEnabled+", sizePrefixDisabled="+sizePrefixDisabled+"}";
0:         return "OpenWireFormat{id="+id+", tightEncodingEnabled="+tightEncodingEnabled+"}";
/////////////////////////////////////////////////////////////////////////
0:                     if( !sizePrefixDisabled ) {
/////////////////////////////////////////////////////////////////////////
0:                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
0:                     if( !sizePrefixDisabled ) {
/////////////////////////////////////////////////////////////////////////
0:                     if( !sizePrefixDisabled ) {
/////////////////////////////////////////////////////////////////////////
0:         if( !sizePrefixDisabled ) {
0:             if( sequence.getLength()-4 != size ) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:     public void marshal(Object o, DataOutputStream dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         	
0:             if( tightEncodingEnabled ) {
1: 	            BooleanStream bs = new BooleanStream();
1: 	            size += dsm.tightMarshal1(this, c, bs);
0: 	            size += bs.marshalledSize(); 
1: 	
0: 	            dataOut.writeInt(size);
1: 	            dataOut.writeByte(type);            
0: 	            bs.marshal(dataOut);
0: 	            dsm.tightMarshal2(this, c, dataOut, bs);
1:             } else {            	
0:             	DataOutputStream looseOut = dataOut;
0:             	ByteArrayOutputStream baos=null;
1:             	
0:             	if( !sizePrefixDisabled ) {
0: 	                baos = new ByteArrayOutputStream();
0: 	                looseOut = new DataOutputStream(baos);
1:                 }
1:                 
1:                 looseOut.writeByte(type);
1:                 dsm.looseMarshal(this, c, looseOut);
1:                 
0:                 if( !sizePrefixDisabled ) {
0:                     looseOut.close();
0:                     ByteSequence sequence = baos.toByteSequence();
0:                     dataOut.writeInt(sequence.getLength()-4);
1:                     dataOut.write(sequence.getData(), sequence.getOffset(), sequence.getLength());
1:                 }
1:             }
1:             
0:             dataOut.writeInt(size);
1:             dataOut.writeByte(NULL_TYPE);
0:         if( !sizePrefixDisabled ) {
0:         	dis.readInt();
1:         }
/////////////////////////////////////////////////////////////////////////
0: //    public void debug(String msg) {
0: //    	String t = (Thread.currentThread().getName()+"                                         ").substring(0, 40);
0: //    	System.out.println(t+": "+msg);
0: //    }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isSizePrefixDisabled() {
1:         return sizePrefixDisabled;
1:     public void setSizePrefixDisabled(boolean prefixPacketSize) {
1:         this.sizePrefixDisabled = prefixPacketSize;
1: 
0: 	public void setPreferedWireFormatInfo(WireFormatInfo info) {
0: 		this.preferedWireFormatInfo = info;		
1: 	}
0: 	public WireFormatInfo getPreferedWireFormatInfo() {
0: 		return preferedWireFormatInfo;
1: 	}
1: 
0: 	public void renegociatWireFormat(WireFormatInfo info) throws IOException {
1: 		
0: 		if( preferedWireFormatInfo==null )
0: 			throw new IllegalStateException("Wireformat cannot not be renegociated.");
1: 		
0: 		this.setVersion(Math.max(preferedWireFormatInfo.getVersion(), info.getVersion()) );
0: 		this.stackTraceEnabled = info.isStackTraceEnabled() && preferedWireFormatInfo.isStackTraceEnabled();
0: 		this.tcpNoDelayEnabled = info.isTcpNoDelayEnabled() && preferedWireFormatInfo.isTcpNoDelayEnabled();
0: 		this.cacheEnabled = info.isCacheEnabled() && preferedWireFormatInfo.isCacheEnabled();
0: 		this.tightEncodingEnabled = info.isTightEncodingEnabled() && preferedWireFormatInfo.isTightEncodingEnabled();
0: 		this.sizePrefixDisabled = info.isSizePrefixDisabled() && preferedWireFormatInfo.isSizePrefixDisabled();
1: 		
1: 	}
1: 
commit:db9144a
/////////////////////////////////////////////////////////////////////////
1:         // We can only cache that item if there is space left.
0:         if( marshallCacheMap.size() < MARSHAL_CACHE_SIZE ) {
1:             marshallCache[i] = o;
1:             Short index = new Short(i);
1:             marshallCacheMap.put(o, index);
1:             return index;
1:         } else {
0:             // Use -1 to indicate that the value was not cached due to cache being full.
1:             return new Short((short)-1);
1:         }
0:         
1:         // There was no space left in the cache, so we can't
1:         // put this in the cache.
0:         if( index == -1 )
1:             return;
0:         
commit:c3e10f5
/////////////////////////////////////////////////////////////////////////
0:             ^ (tightEncodingEnabled ? 0x00100000:0x00200000)
0:             ^ (prefixPacketSize     ? 0x00010000:0x00020000)
0:             ;
/////////////////////////////////////////////////////////////////////////
0:             o.tightEncodingEnabled == tightEncodingEnabled && 
0:             o.prefixPacketSize == prefixPacketSize 
0:             ;
0:         return "OpenWireFormat{version="+version+", cacheEnabled="+cacheEnabled+", stackTraceEnabled="+stackTraceEnabled+", tightEncodingEnabled="+tightEncodingEnabled+", prefixPacketSize="+prefixPacketSize+"}";
commit:b665f18
/////////////////////////////////////////////////////////////////////////
0:     private static final int MARSHAL_CACHE_PREFERED_SIZE = MARSHAL_CACHE_SIZE-100;
0:     
/////////////////////////////////////////////////////////////////////////
0:     private short nextMarshallCacheEvictionIndex=0;
0:     
/////////////////////////////////////////////////////////////////////////
0:         if( cacheEnabled ) {
1:             runMarshallCacheEvictionSweep();
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         
0:         if( cacheEnabled ) {
1:             runMarshallCacheEvictionSweep();
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:             dsm.tightMarshal2(this, c, ds, bs);            
/////////////////////////////////////////////////////////////////////////
1:     public void runMarshallCacheEvictionSweep() {
1:         // Do we need to start evicting??
0:         while( marshallCacheMap.size() > MARSHAL_CACHE_PREFERED_SIZE ) {
0:             
1:             marshallCacheMap.remove(marshallCache[nextMarshallCacheEvictionIndex]);
0:             marshallCache[nextMarshallCacheEvictionIndex]=null;
0: 
1:             nextMarshallCacheEvictionIndex++;
0:             if( nextMarshallCacheEvictionIndex >= MARSHAL_CACHE_SIZE ) {
0:                 nextMarshallCacheEvictionIndex=0;
1:             }
0:             
1:         }
1:     }
1:     public Short getMarshallCacheIndex(DataStructure o) {
1:     public Short addToMarshallCache(DataStructure o) {
1:         short i = nextMarshallCacheIndex++;
0:         
0:         marshallCache[i] = o;
0:         Short index = new Short(i);
commit:33b73ac
/////////////////////////////////////////////////////////////////////////
0: import org.activeio.PacketData;
/////////////////////////////////////////////////////////////////////////
0:     private boolean tightEncodingEnabled=true;
0:     private boolean prefixPacketSize=true;
/////////////////////////////////////////////////////////////////////////
0:             ^ (cacheEnabled         ? 0x10000000:0x20000000)
0:             ^ (stackTraceEnabled    ? 0x01000000:0x02000000)
0:             ^ (tightEncodingEnabled ? 0x00100000:0x00200000);
/////////////////////////////////////////////////////////////////////////
0:             o.version == version && 
0:             o.tightEncodingEnabled == tightEncodingEnabled;
/////////////////////////////////////////////////////////////////////////
0:                 if( tightEncodingEnabled ) {
0:                     
0:                     BooleanStream bs = new BooleanStream();
0:                     size += dsm.tightMarshal1(this, c, bs);
0:                     size += bs.marshalledSize();
0:     
0:                     ByteArrayOutputStream baos = new ByteArrayOutputStream(size);
0:                     DataOutputStream ds = new DataOutputStream(baos);
0:                     if( prefixPacketSize ) {
0:                         ds.writeInt(size);
1:                     }
1:                     ds.writeByte(type);
1:                     bs.marshal(ds);
0:                     dsm.tightMarshal2(this, c, ds, bs);                
0:                     ds.close();
0:                     sequence = baos.toByteSequence();
0:                     
1:                 } else {
0:                     
0:                     ByteArrayOutputStream baos = new ByteArrayOutputStream(size);
0:                     DataOutputStream ds = new DataOutputStream(baos);
0:                     if( prefixPacketSize ) {
0:                         ds.writeInt(0); // we don't know the final size yet but write this here for now.
1:                     }
1:                     ds.writeByte(type);
0:                     dsm.looseMarshal(this, c, ds);                
0:                     ds.close();
0:                     sequence = baos.toByteSequence();
0:                     
0:                     if( prefixPacketSize ) {
0:                         size = sequence.getLength()-4;
0:                         ByteArrayPacket packet = new ByteArrayPacket(sequence);
0:                         PacketData.writeIntBig(packet, size);
1:                     }
1:                 }
0:                 
/////////////////////////////////////////////////////////////////////////
0:         
0:         if( prefixPacketSize ) {
0:             int size = dis.readInt();
0:             if( sequence.getLength()-4 != size )
0:                 System.out.println("Packet size does not match marshaled size: "+size+", "+(sequence.getLength()-4));
0:     //            throw new IOException("Packet size does not match marshaled size");
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:             size += dsm.tightMarshal1(this, c, bs);
0:             dsm.tightMarshal2(this, c, ds, bs);
/////////////////////////////////////////////////////////////////////////
0:             if( this.tightEncodingEnabled ) {
0:                 BooleanStream bs = new BooleanStream();
1:                 bs.unmarshal(dis);
1:                 dsm.tightUnmarshal(this, data, dis, bs);
1:             } else {
1:                 dsm.looseUnmarshal(this, data, dis);
1:             }
1:     public int tightMarshalNestedObject1(DataStructure o, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         return 1 + dsm.tightMarshal1(this, o, bs);
0:     public void tightMarshalNestedObject2(DataStructure o, DataOutputStream ds, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             dsm.tightMarshal2(this, o, ds, bs);
0:     public DataStructure tightUnmarshalNestedObject(DataInputStream dis, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 dsm.tightUnmarshal(this, data, dis, bs2);
1:                 dsm.tightUnmarshal(this, data, dis, bs);
/////////////////////////////////////////////////////////////////////////
0:     public DataStructure looseUnmarshalNestedObject(DataInputStream dis) throws IOException {
0:         if( dis.readBoolean() ) {
0:             
1:             byte dataType = dis.readByte();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[dataType & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+dataType);
1:             DataStructure data = dsm.createObject();
1:             dsm.looseUnmarshal(this, data, dis);
1:             return data;
0:             
1:         } else {
1:             return null;
1:         }
1:     }
0: 
0:     public void looseMarshalNestedObject(DataStructure o, DataOutputStream dataOut) throws IOException {
0:         dataOut.writeBoolean(o!=null);
0:         if( o!=null ) {
1:             byte type = o.getDataStructureType();
0:             dataOut.writeByte(type);
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+type);
1:             dsm.looseMarshal(this, o, dataOut);
1:         }
1:     }
0: 
0:     
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTightEncodingEnabled() {
1:         return tightEncodingEnabled;
1:     }
0: 
1:     public void setTightEncodingEnabled(boolean tightEncodingEnabled) {
1:         this.tightEncodingEnabled = tightEncodingEnabled;
1:     }
0: 
0:     public boolean isPrefixPacketSize() {
0:         return prefixPacketSize;
1:     }
0: 
0:     public void setPrefixPacketSize(boolean prefixPacketSize) {
0:         this.prefixPacketSize = prefixPacketSize;
1:     }
0:     
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.openwire;
0: 
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.lang.reflect.Method;
1: import java.util.HashMap;
0: 
0: import org.activeio.ByteArrayOutputStream;
0: import org.activeio.ByteSequence;
0: import org.activeio.Packet;
0: import org.activeio.adapter.PacketToInputStream;
0: import org.activeio.command.ClassLoading;
0: import org.activeio.command.WireFormat;
0: import org.activeio.packet.ByteArrayPacket;
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.MarshallAware;
0: 
1: /**
0:  * 
0:  * @version $Revision$
1:  */
0: final public class OpenWireFormat implements WireFormat {
0:     
1:     static final byte NULL_TYPE = CommandTypes.NULL;
0:     private static final int MARSHAL_CACHE_SIZE = Short.MAX_VALUE/2;
1:     private DataStreamMarshaller dataMarshallers[];
1:     private int version;
0:     private boolean stackTraceEnabled=true;
0:     private boolean tcpNoDelayEnabled=false;
0:     private boolean cacheEnabled=true;
0: 
0:     private HashMap marshallCacheMap = new HashMap();
0:     private short nextMarshallCacheIndex=0;    
0:     private short lasMarshallCacheEvictionIndex=100;    
0:     private DataStructure marshallCache[] = new DataStructure[MARSHAL_CACHE_SIZE];
0:     private DataStructure unmarshallCache[] = new DataStructure[MARSHAL_CACHE_SIZE];
0:     
0:     public OpenWireFormat() {
0:         this(true);
1:     }
0:     
0:     public OpenWireFormat(boolean cacheEnabled) {
0:         setVersion(1);
0:         setCacheEnabled(cacheEnabled);
1:     }
0:     
0:     public int hashCode() {
0:         return  version 
0:             ^ (cacheEnabled?0x10000000:0x20000000)
0:             ^ (stackTraceEnabled?0x30000000:0x40000000);
1:     }
0:     
1:     public boolean equals(Object object) {
0:         if( object == null )
1:             return false;
0:         OpenWireFormat o = (OpenWireFormat) object;
0:         return o.stackTraceEnabled == stackTraceEnabled &&
0:             o.cacheEnabled == cacheEnabled &&
0:             o.version == version;
1:     }
0:     
1:     public String toString() {
0:         return "OpenWireFormat{version="+version+", cacheEnabled="+cacheEnabled+", stackTraceEnabled="+stackTraceEnabled+"}";
1:     }
0:     
1:     public int getVersion() {
1:         return version;
1:     }
0:     
0:     public Packet marshal(Object command) throws IOException {
0:         
0:         MarshallAware ma=null;
0:         // If not using value caching, then the marshaled form is always the same
0:         if( !cacheEnabled && ((DataStructure)command).isMarshallAware() ) {
0:             ma = (MarshallAware) command;
1:         }
0:         
0:         ByteSequence sequence=null;
0:         if( ma!=null ) {
0:             sequence = ma.getCachedMarshalledForm(this);
1:         }
0:         
0:         if( sequence == null ) {
0:             
0:             int size=1;
0:             if( command != null) {
0:                 
0:                 DataStructure c = (DataStructure) command;
1:                 byte type = c.getDataStructureType();
0:                 DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:                 if( dsm == null )
0:                     throw new IOException("Unknown data type: "+type);
0:                 BooleanStream bs = new BooleanStream();
0:                 size += dsm.marshal1(this, c, bs);
0:                 size += bs.marshalledSize();
0: 
0:                 ByteArrayOutputStream baos = new ByteArrayOutputStream(size);
0:                 DataOutputStream ds = new DataOutputStream(baos);
0:                 ds.writeInt(size);
0:                 ds.writeByte(type);
0:                 bs.marshal(ds);
0:                 dsm.marshal2(this, c, ds, bs);                
0:                 ds.close();
0:                 
0:                 sequence = baos.toByteSequence();
0:                 
1:             } else {
0:                 
0:                 ByteArrayOutputStream baos = new ByteArrayOutputStream(5);
0:                 DataOutputStream daos = new DataOutputStream(baos);
0:                 daos.writeInt(size);
0:                 daos.writeByte(NULL_TYPE);
0:                 daos.close();
0:                 sequence = baos.toByteSequence();
1:             }
0:             
0:             if( ma!=null ) {
0:                 ma.setCachedMarshalledForm(this, sequence);
1:             }
1:         }
0:         return new ByteArrayPacket(sequence);
1:     }
0:     
0:     public Object unmarshal(Packet packet) throws IOException {
0:         ByteSequence sequence = packet.asByteSequence();
0:         DataInputStream dis = new DataInputStream(new PacketToInputStream(packet));
0:         int size = dis.readInt();
0:         if( sequence.getLength() != size+4 )
0:             System.out.println("Packet size does not match marshaled size: "+size+", "+(sequence.getLength()-4));
0: //            throw new IOException("Packet size does not match marshaled size");        
0:         Object command = doUnmarshal(dis);
0:         if( !cacheEnabled && ((DataStructure)command).isMarshallAware() ) {
0:             ((MarshallAware) command).setCachedMarshalledForm(this, sequence);
1:         }
1:         return command;
1:     }
0:     
0:     public void marshal(Object o, DataOutputStream ds) throws IOException {
0:         int size=1;
0:         if( o != null) {
0:             DataStructure c = (DataStructure) o;
1:             byte type = c.getDataStructureType();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+type);
0: 
0:             BooleanStream bs = new BooleanStream();
0:             size += dsm.marshal1(this, c, bs);
0:             size += bs.marshalledSize(); 
0: 
0:             ds.writeInt(size);
0:             ds.writeByte(type);            
0:             bs.marshal(ds);
0:             dsm.marshal2(this, c, ds, bs);
1:         } else {
0:             ds.writeInt(size);
0:             ds.writeByte(NULL_TYPE);
1:         }
1:     }
0:     
0:     public Object unmarshal(DataInputStream dis) throws IOException {
0:         dis.readInt();
0:         return doUnmarshal(dis);
1:     }
0:     
1:     /**
0:      * Allows you to dynamically switch the version of the openwire protocol being used.
1:      * @param version
1:      */
1:     public void setVersion(int version) {
0:         String mfName = "org.apache.activemq.openwire.v"+version+".MarshallerFactory";
1:         Class mfClass;
1:         try {
0:             mfClass = ClassLoading.loadClass(mfName, getClass().getClassLoader());
1:         } catch (ClassNotFoundException e) {
0:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid version: "+version+", could not load "+mfName).initCause(e);
1:         }
1:         try {
0:             Method method = mfClass.getMethod("createMarshallerMap", new Class[]{OpenWireFormat.class});
0:             dataMarshallers = (DataStreamMarshaller[]) method.invoke(null, new Object[]{this});
1:         } catch (Throwable e) {
0:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid version: "+version+", "+mfName+" does not properly implement the createMarshallerMap method.").initCause(e);
1:         }
1:         this.version = version;
1:     }
0:         
0:     public Object doUnmarshal(DataInputStream dis) throws IOException {
1:         byte dataType = dis.readByte();
0:         if( dataType!=NULL_TYPE ) {
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[dataType & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+dataType);
1:             Object data = dsm.createObject();
0:             BooleanStream bs = new BooleanStream();
0:             bs.unmarshal(dis);
0:             dsm.unmarshal(this, data, dis, bs);
1:             return data;
1:         } else {
1:             return null;
1:         }
1:     }
0:     
0:     public int marshal1NestedObject(DataStructure o, BooleanStream bs) throws IOException {
1:         bs.writeBoolean(o != null);
0:         if( o == null ) 
1:             return 0;
0: 
0:         if( o.isMarshallAware() ) {
0:             MarshallAware ma = (MarshallAware) o;
0:             ByteSequence sequence=ma.getCachedMarshalledForm(this);
0:             bs.writeBoolean(sequence!=null);
0:             if( sequence!=null ) {
0:                 return 1 + sequence.getLength();           
1:             }
1:         }
0:         
1:         byte type = o.getDataStructureType();
0:         DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:         if( dsm == null )
0:             throw new IOException("Unknown data type: "+type);
0:         return 1 + dsm.marshal1(this, o, bs);
1:     }
0:     
0:     public void marshal2NestedObject(DataStructure o, DataOutputStream ds, BooleanStream bs) throws IOException {
0:         if( !bs.readBoolean() ) 
1:             return;
0:             
1:         byte type = o.getDataStructureType();
0:         ds.writeByte(type);
0: 
0:         if( o.isMarshallAware() && bs.readBoolean() ) {
0:                         
0:             MarshallAware ma = (MarshallAware) o;
0:             ByteSequence sequence=ma.getCachedMarshalledForm(this);
0:             ds.write(sequence.getData(), sequence.getOffset(), sequence.getLength());
0:             
1:         } else {
0:             
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+type);
0:             dsm.marshal2(this, o, ds, bs);
0:             
1:         }
1:     }
0:     
0:     public DataStructure unmarshalNestedObject(DataInputStream dis, BooleanStream bs) throws IOException {
0:         if( bs.readBoolean() ) {
0:             
1:             byte dataType = dis.readByte();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[dataType & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+dataType);
1:             DataStructure data = dsm.createObject();
0: 
0:             if( data.isMarshallAware() && bs.readBoolean() ) {
0:                 
0:                 dis.readInt();
1:                 dis.readByte();
0:                 
1:                 BooleanStream bs2 = new BooleanStream();
1:                 bs2.unmarshal(dis);
0:                 dsm.unmarshal(this, data, dis, bs2);
0: 
1:                 // TODO: extract the sequence from the dis and associate it.
0: //                MarshallAware ma = (MarshallAware)data
0: //                ma.setCachedMarshalledForm(this, sequence);
0:                 
1:             } else {
0:                 dsm.unmarshal(this, data, dis, bs);
1:             }
0:             
1:             return data;
1:         } else {
1:             return null;
1:         }
1:     }
0:     
0:     public Short getMarshallCacheIndex(Object o) {
0:         return (Short) marshallCacheMap.get(o);
1:     }
0:     
0:     public Short addToMarshallCache(Object o) {
0:         Short index = new Short(nextMarshallCacheIndex++);
0:         if( nextMarshallCacheIndex >= MARSHAL_CACHE_SIZE ) {
0:             nextMarshallCacheIndex=0;
1:         }
0:         lasMarshallCacheEvictionIndex++;
0:         if( lasMarshallCacheEvictionIndex >= MARSHAL_CACHE_SIZE ) {
0:             lasMarshallCacheEvictionIndex=0;
1:         }
0:         if( marshallCache[lasMarshallCacheEvictionIndex]!=null ) {
0:             marshallCacheMap.remove(marshallCache[lasMarshallCacheEvictionIndex]);
0:             marshallCache[lasMarshallCacheEvictionIndex]=null;
1:         }
0:         marshallCacheMap.put(o, index);
0:         return index;
1:     }
0:     
1:     public void setInUnmarshallCache(short index, DataStructure o) {
0:         unmarshallCache[index]=o;
1:     }
0:     
1:     public DataStructure getFromUnmarshallCache(short index) {
1:         return unmarshallCache[index];
1:     }
0: 
0: 
1:     public void setStackTraceEnabled(boolean b) {
1:         stackTraceEnabled = b;
1:     }
1:     public boolean isStackTraceEnabled() {
1:         return stackTraceEnabled;
1:     }
0: 
1:     public boolean isTcpNoDelayEnabled() {
1:         return tcpNoDelayEnabled;
1:     }
1:     public void setTcpNoDelayEnabled(boolean tcpNoDelayEnabled) {
1:         this.tcpNoDelayEnabled = tcpNoDelayEnabled;
1:     }
0: 
1:     public boolean isCacheEnabled() {
1:         return cacheEnabled;
1:     }
1:     public void setCacheEnabled(boolean cacheEnabled) {
1:         this.cacheEnabled = cacheEnabled;
1:     }
0: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:c50c1f5
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_MAX_FRAME_SIZE = Long.MAX_VALUE;
commit:3cce6b7
/////////////////////////////////////////////////////////////////////////
1:         OpenWireFormat answer = new OpenWireFormat(version);
commit:eb22a02
/////////////////////////////////////////////////////////////////////////
1:     public static final int DEFAULT_WIRE_VERSION = CommandTypes.PROTOCOL_VERSION;
commit:8443bd1
/////////////////////////////////////////////////////////////////////////
0:     public static final int DEFAULT_VERSION = CommandTypes.PROTOCOL_STORE_VERSION;
author:Robert Davies
-------------------------------------------------------------------------------
commit:5bd4b19
/////////////////////////////////////////////////////////////////////////
1:     private DataStructure marshallCache[] = null;
1:     private DataStructure unmarshallCache[] = null;
/////////////////////////////////////////////////////////////////////////
1:         if(cacheEnabled){
1:             marshallCache = new DataStructure[MARSHAL_CACHE_SIZE];
1:             unmarshallCache = new DataStructure[MARSHAL_CACHE_SIZE];
0:         }
commit:4b5bc5e
/////////////////////////////////////////////////////////////////////////
1:     public synchronized ByteSequence marshal(Object command) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Object unmarshal(ByteSequence sequence) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void marshal(Object o, DataOutput dataOut) throws IOException {
commit:4821b9d
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInput;
1: import java.io.DataOutput;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.DataByteArrayInputStream;
0: import org.apache.activemq.util.DataByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
1:     private DataByteArrayOutputStream bytesOut = new DataByteArrayOutputStream();
1:     private DataByteArrayInputStream bytesIn = new DataByteArrayInputStream();
0: 		this(2);
/////////////////////////////////////////////////////////////////////////
0:                     bytesOut.restart(size);
0:                         bytesOut.writeInt(size);
0:                     bytesOut.writeByte(type);
0:                     bs.marshal(bytesOut);
0:                     dsm.tightMarshal2(this, c, bytesOut, bs);                
1:                     sequence = bytesOut.toByteSequence();
0:                     bytesOut.restart();
0:                         bytesOut.writeInt(0); // we don't know the final size yet but write this here for now.
0:                     bytesOut.writeByte(type);
0:                     dsm.looseMarshal(this, c, bytesOut);                
1:                     sequence = bytesOut.toByteSequence();
/////////////////////////////////////////////////////////////////////////
0:                 bytesOut.restart(5);
0:                 bytesOut.writeInt(size);
0:                 bytesOut.writeByte(NULL_TYPE);
0:                 sequence = bytesOut.toByteSequence();
/////////////////////////////////////////////////////////////////////////
1:         bytesIn.restart(sequence);
0:         //DataInputStream dis = new DataInputStream(new ByteArrayInputStream(sequence));
1:             int size = bytesIn.readInt();
1:         Object command = doUnmarshal(bytesIn);
0:     public void marshal(Object o, DataOutput dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:             	DataOutput looseOut = dataOut;
0:             	            	
0: 	                bytesOut.restart();
0: 	                looseOut = bytesOut;
1:                     ByteSequence sequence = bytesOut.toByteSequence();
/////////////////////////////////////////////////////////////////////////
1:     public Object unmarshal(DataInput dis) throws IOException {
1:         DataInput dataIn = dis;
0:         	int size = dis.readInt();
0:             //byte[] data = new byte[size];
0:             //dis.readFully(data);
0:             //bytesIn.restart(data);
0:             //dataIn = bytesIn;
1:         return doUnmarshal(dataIn);
/////////////////////////////////////////////////////////////////////////
1:     public void tightMarshal2(Object o, DataOutput ds, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public Object doUnmarshal(DataInput dis) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public void tightMarshalNestedObject2(DataStructure o, DataOutput ds, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public DataStructure tightUnmarshalNestedObject(DataInput dis, BooleanStream bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public DataStructure looseUnmarshalNestedObject(DataInput dis) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public void looseMarshalNestedObject(DataStructure o, DataOutput dataOut) throws IOException {
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a4b8c8e
/////////////////////////////////////////////////////////////////////////
0: 
1:             if (size > maxFrameSize) {
0:                 throw new IOException("Frame size of " + (size / (1024 * 1024)) + " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
0:             }
commit:8a82119
/////////////////////////////////////////////////////////////////////////
0:             int size = dis.readInt();
1:             if (size > maxFrameSize) {
0:                 throw new IOException("Frame size of " + (size / (1024 * 1024)) + " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
0:             }
commit:e5e99d7
/////////////////////////////////////////////////////////////////////////
0:     public static final int DEFAULT_MAX_FRAME_SIZE = 100 * 1024 * 1024; //100 MB
/////////////////////////////////////////////////////////////////////////
1:     private long maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
/////////////////////////////////////////////////////////////////////////
1:                + tightEncodingEnabled + ", sizePrefixDisabled=" + sizePrefixDisabled +  ", maxFrameSize=" + maxFrameSize + "}";
/////////////////////////////////////////////////////////////////////////
1:     public long getMaxFrameSize() {
1:         return maxFrameSize;
0:     }
0: 
1:     public void setMaxFrameSize(long maxFrameSize) {
1:         this.maxFrameSize = maxFrameSize;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         this.setMaxFrameSize(min(preferedWireFormatInfo.getMaxFrameSize(), info.getMaxFrameSize()));
1:         info.setMaxFrameSize(this.getMaxFrameSize());
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected long min(long version1, long version2) {
1:         if (version1 < version2 && version1 > 0 || version2 <= 0) {
1:             return version1;
0:         }
1:         return version2;
0:     }
commit:15065b7
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     
0:     private AtomicBoolean receivingMessage = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:         receivingMessage.set(true);
/////////////////////////////////////////////////////////////////////////
0:             receivingMessage.set(false);
0:             receivingMessage.set(false);
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean inReceive() {
0:     	return receivingMessage.get();
0:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:8cf4795
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.MarshallAware;
0: import org.apache.activemq.command.WireFormatInfo;
0: import org.apache.activemq.util.*;
0: import org.apache.activemq.wireformat.WireFormat;
0: 
0: 
0:     public static final int DEFAULT_VERSION = 3;
0: 
0:     private int version;
/////////////////////////////////////////////////////////////////////////
0: 		this(DEFAULT_VERSION);
commit:094f007
/////////////////////////////////////////////////////////////////////////
0:     private int version = 2;
commit:f6d4f9f
/////////////////////////////////////////////////////////////////////////
0: 		this.setVersion(min(preferedWireFormatInfo.getVersion(), info.getVersion()) );
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected int min(int version1, int version2) {
1:         if (version1 < version2 && version1 > 0 || version2 <= 0) {
1:             return version1;
0:         }
1:         return version2;
0:     }
commit:c2fc820
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.lang.reflect.Method;
0: import java.util.HashMap;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if( dataType!=NULL_TYPE ) {
/////////////////////////////////////////////////////////////////////////
commit:8704338
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.LastPartialCommand;
0: import org.apache.activemq.command.PartialCommand;
/////////////////////////////////////////////////////////////////////////
0:             
0:             // TODO - we could remove this if we have a way to disable BooleanStream on 
0:             // certain types of message
0:             if (type == CommandTypes.PARTIAL_COMMAND || type == CommandTypes.PARTIAL_LAST_COMMAND) {
0:                 marshalPartialCommand((PartialCommand) o, dataOut);
0:                 return;
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         
0:         // TODO - we could remove this if we have a way to disable BooleanStream on 
0:         // certain types of message
0:         if (dataType == CommandTypes.PARTIAL_COMMAND || dataType == CommandTypes.PARTIAL_LAST_COMMAND) {
0:             return doUnmarshalPartialCommand(dataType, dis);
0:         }
0:         else if( dataType!=NULL_TYPE ) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     // Partial command marshalling
0:     // 
0:     // TODO - remove if we can figure out a clean way to disable BooleanStream in OpenWire on commands 
0:     // with no optional values (partial commands only have a mandatory byte[])
0: 	//
0:     
0:     protected void marshalPartialCommand(PartialCommand command, DataOutputStream dataOut) throws IOException {
0:         byte[] data = command.getData();
0:         int dataSize = data.length;
0: 
0:         if (!isSizePrefixDisabled()) {
0:             int size = dataSize + 1 + 4;
0:             dataOut.writeInt(size);
0:         }
0: 
0:         if (command.isLastPart()) {
0:             dataOut.write(LastPartialCommand.DATA_STRUCTURE_TYPE);
0:         }
0:         else {
0:             dataOut.write(PartialCommand.DATA_STRUCTURE_TYPE);
0:         }
0: 
0:         dataOut.writeInt(command.getCommandId());
0:         dataOut.writeInt(dataSize);
0:         dataOut.write(data);
0: 
0:     }
0:     
0:     protected Object doUnmarshalPartialCommand(byte dataType, DataInputStream dis) throws IOException {
0:         // size of entire command is already read
0:         
0:         PartialCommand answer = null;
0:         if (dataType == LastPartialCommand.DATA_STRUCTURE_TYPE) {
0:             answer = new LastPartialCommand();
0:         }
0:         else {
0:             answer = new PartialCommand();
0:         }
0:         answer.setCommandId(dis.readInt());
0:         
0:         int size = dis.readInt();
0:         byte[] data = new byte[size];
0:         dis.readFully(data);
0:         answer.setData(data);
1:         return answer;
0:     }
0: 
commit:4446d55
/////////////////////////////////////////////////////////////////////////
0:         answer.version = version;
1:         answer.preferedWireFormatInfo = preferedWireFormatInfo;
/////////////////////////////////////////////////////////////////////////
0:         return "OpenWireFormat{version="+version+", cacheEnabled="+cacheEnabled+", stackTraceEnabled="+stackTraceEnabled+", tightEncodingEnabled="+tightEncodingEnabled+", sizePrefixDisabled="+sizePrefixDisabled+"}";
0:         //return "OpenWireFormat{id="+id+", tightEncodingEnabled="+tightEncodingEnabled+"}";
commit:22bb1bd
/////////////////////////////////////////////////////////////////////////
1:     public OpenWireFormat copy() {
0:         OpenWireFormat answer = new OpenWireFormat();
1:         answer.stackTraceEnabled = stackTraceEnabled;
1:         answer.tcpNoDelayEnabled = tcpNoDelayEnabled;
1:         answer.cacheEnabled = cacheEnabled;
1:         answer.tightEncodingEnabled = tightEncodingEnabled;
1:         answer.sizePrefixDisabled = sizePrefixDisabled;
0:         return answer;
0:     }
0:     
commit:f8e1c0e
/////////////////////////////////////////////////////////////////////////
1:      * Used by NIO or AIO transports
1:      */
1:     public int tightMarshal1(Object o, BooleanStream bs) throws IOException {
0:         int size=1;
0:         if( o != null) {
0:             DataStructure c = (DataStructure) o;
0:             byte type = c.getDataStructureType();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+type);
0: 
0:             size += dsm.tightMarshal1(this, c, bs);
0:             size += bs.marshalledSize(); 
0:         }
1:         return size;
0:     }
0:     
1:     /**
0:      * Used by NIO or AIO transports; note that the size is not written as part of this method.
1:      */
0:     public void tightMarshal2(Object o, DataOutputStream ds, BooleanStream bs) throws IOException {
0:         if( cacheEnabled ) {
1:             runMarshallCacheEvictionSweep();
0:         }
0:         
0:         if( o != null) {
0:             DataStructure c = (DataStructure) o;
0:             byte type = c.getDataStructureType();
0:             DataStreamMarshaller dsm = (DataStreamMarshaller) dataMarshallers[type & 0xFF];
0:             if( dsm == null )
0:                 throw new IOException("Unknown data type: "+type);
0: 
0:             ds.writeByte(type);            
0:             bs.marshal(ds);
0:             dsm.tightMarshal2(this, c, ds, bs);            
0:         } 
0:     }
0: 
0:     
1:     /**
commit:d666be0
/////////////////////////////////////////////////////////////////////////
0:         nextMarshallCacheIndex++;
/////////////////////////////////////////////////////////////////////////
0:         marshallCache[nextMarshallCacheIndex] = (DataStructure) o;
0:         Short index = new Short(nextMarshallCacheIndex);
============================================================================