1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.thread;
1:d29ca2a: 
1:1f521da: import java.util.concurrent.Executor;
1:86cbdfd: import java.util.concurrent.ExecutorService;
1:e3fcf71: import java.util.concurrent.RejectedExecutionHandler;
1:86cbdfd: import java.util.concurrent.SynchronousQueue;
1:86cbdfd: import java.util.concurrent.ThreadFactory;
1:86cbdfd: import java.util.concurrent.ThreadPoolExecutor;
1:86cbdfd: import java.util.concurrent.TimeUnit;
1:cf5de8e: import java.util.concurrent.atomic.AtomicBoolean;
1:986ed14: import java.util.concurrent.atomic.AtomicLong;
1:fe5164a: import java.util.concurrent.atomic.AtomicReference;
1:d29ca2a: 
1:287f69d: import org.apache.activemq.util.ThreadPoolUtils;
1:287f69d: import org.slf4j.Logger;
1:287f69d: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:f812e34:  * Manages the thread pool for long running tasks. Long running tasks are not
1:f812e34:  * always active but when they are active, they may need a few iterations of
1:f812e34:  * processing for them to become idle. The manager ensures that each task is
1:ebcc1b4:  * processes but that no one task overtakes the system. This is somewhat like
1:f812e34:  * cooperative multitasking.
1:b0c2a40:  *
1:cf5de8e:  * @org.apache.xbean.XBean
1:d29ca2a:  */
1:1f521da: public class TaskRunnerFactory implements Executor {
1:d29ca2a: 
1:287f69d:     private static final Logger LOG = LoggerFactory.getLogger(TaskRunnerFactory.class);
1:fe5164a:     private final AtomicReference<ExecutorService> executorRef = new AtomicReference<>();
1:e2aad41:     private int maxIterationsPerRun;
1:e2aad41:     private String name;
1:e2aad41:     private int priority;
1:e2aad41:     private boolean daemon;
1:ce5d2a9:     private final AtomicLong id = new AtomicLong(0);
1:cf5de8e:     private boolean dedicatedTaskRunner;
1:287f69d:     private long shutdownAwaitTermination = 30000;
1:ce5d2a9:     private final AtomicBoolean initDone = new AtomicBoolean(false);
1:ebcc1b4:     private int maxThreadPoolSize = getDefaultMaximumPoolSize();
1:e3fcf71:     private RejectedExecutionHandler rejectedTaskHandler = null;
1:dffccb1:     private ClassLoader threadClassLoader;
1:d29ca2a: 
1:d29ca2a:     public TaskRunnerFactory() {
1:0b01996:         this("ActiveMQ Task");
1:d29ca2a:     }
1:ebcc1b4: 
1:0b01996:     public TaskRunnerFactory(String name) {
1:0b01996:         this(name, Thread.NORM_PRIORITY, true, 1000);
1:6c1676b:     }
1:f812e34: 
1:c808beb:     private TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun) {
1:3e7847a:         this(name, priority, daemon, maxIterationsPerRun, false);
1:6c1676b:     }
1:f812e34: 
1:9cc2d37:     public TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun, boolean dedicatedTaskRunner) {
1:3e7847a:         this(name, priority, daemon, maxIterationsPerRun, dedicatedTaskRunner, getDefaultMaximumPoolSize());
1:0b01996:     }
1:e2aad41: 
1:c33231b:     public TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun, boolean dedicatedTaskRunner, int maxThreadPoolSize) {
1:e2aad41:         this.name = name;
1:e2aad41:         this.priority = priority;
1:e2aad41:         this.daemon = daemon;
2:d29ca2a:         this.maxIterationsPerRun = maxIterationsPerRun;
1:cf5de8e:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:c33231b:         this.maxThreadPoolSize = maxThreadPoolSize;
1:d29ca2a:     }
1:f812e34: 
1:cf5de8e:     public void init() {
1:fe5164a:         if (!initDone.get()) {
1:f812e34:             // If your OS/JVM combination has a good thread model, you may want to
1:cf5de8e:             // avoid using a thread pool to run tasks and use a DedicatedTaskRunner instead.
1:fe5164a:             //AMQ-6602 - lock instead of using compareAndSet to prevent threads from seeing a null value
1:fe5164a:             //for executorRef inside createTaskRunner() on contention and creating a DedicatedTaskRunner
1:fe5164a:             synchronized(this) {
1:fe5164a:                 //need to recheck if initDone is true under the lock
1:fe5164a:                 if (!initDone.get()) {
1:fe5164a:                     if (dedicatedTaskRunner || "true".equalsIgnoreCase(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
1:fe5164a:                         executorRef.set(null);
1:fe5164a:                     } else {
1:fe5164a:                         executorRef.compareAndSet(null, createDefaultExecutor());
1:fe5164a:                     }
1:fe5164a:                     LOG.debug("Initialized TaskRunnerFactory[{}] using ExecutorService: {}", name, executorRef.get());
1:fe5164a:                     initDone.set(true);
1:fe5164a:                 }
1:e2aad41:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:e2aad41: 
1:6c1676b:     /**
1:6c1676b:      * Performs a shutdown only, by which the thread pool is shutdown by not graceful nor aggressively.
1:d29ca2a:      *
1:6c1676b:      * @see ThreadPoolUtils#shutdown(java.util.concurrent.ExecutorService)
1:6c1676b:      */
1:6cf2169:     public void shutdown() {
1:fe5164a:         ExecutorService executor = executorRef.get();
1:6cf2169:         if (executor != null) {
1:6c1676b:             ThreadPoolUtils.shutdown(executor);
1:d29ca2a:         }
1:fe5164a:         clearExecutor();
1:d29ca2a:     }
1:e2aad41: 
1:6c1676b:     /**
1:6c1676b:      * Performs a shutdown now (aggressively) on the thread pool.
1:d29ca2a:      *
1:6c1676b:      * @see ThreadPoolUtils#shutdownNow(java.util.concurrent.ExecutorService)
1:6c1676b:      */
1:6c1676b:     public void shutdownNow() {
1:fe5164a:         ExecutorService executor = executorRef.get();
1:6c1676b:         if (executor != null) {
1:6c1676b:             ThreadPoolUtils.shutdownNow(executor);
1:d29ca2a:         }
1:fe5164a:         clearExecutor();
1:d29ca2a:     }
1:d29ca2a: 
1:6c1676b:     /**
1:6c1676b:      * Performs a graceful shutdown.
1:d29ca2a:      *
1:6c1676b:      * @see ThreadPoolUtils#shutdownGraceful(java.util.concurrent.ExecutorService)
1:6c1676b:      */
1:6c1676b:     public void shutdownGraceful() {
1:fe5164a:         ExecutorService executor = executorRef.get();
1:6c1676b:         if (executor != null) {
1:6c1676b:             ThreadPoolUtils.shutdownGraceful(executor, shutdownAwaitTermination);
1:fe5164a:         }
1:fe5164a:         clearExecutor();
1:6c1676b:     }
1:fe5164a: 
1:fe5164a:     private void clearExecutor() {
1:fe5164a:         //clear under a lock to prevent threads from seeing initDone == true
1:fe5164a:         //but then getting null from executorRef
1:fe5164a:         synchronized(this) {
1:fe5164a:             executorRef.set(null);
1:fe5164a:             initDone.set(false);
1:fe5164a:         }
1:6c1676b:     }
1:d29ca2a: 
1:e2aad41:     public TaskRunner createTaskRunner(Task task, String name) {
1:cf5de8e:         init();
1:fe5164a:         ExecutorService executor = executorRef.get();
1:f812e34:         if (executor != null) {
1:e2aad41:             return new PooledTaskRunner(executor, task, maxIterationsPerRun);
2:e2aad41:         } else {
1:e2aad41:             return new DedicatedTaskRunner(task, name, priority, daemon);
1:e2aad41:         }
1:c33231b:     }
1:f812e34: 
1:ce5d2a9:     @Override
1:1f521da:     public void execute(Runnable runnable) {
1:0b01996:         execute(runnable, name);
1:1f521da:     }
1:1f521da: 
1:1f521da:     public void execute(Runnable runnable, String name) {
1:cf5de8e:         init();
1:287f69d:         LOG.trace("Execute[{}] runnable: {}", name, runnable);
1:fe5164a:         ExecutorService executor = executorRef.get();
1:1f521da:         if (executor != null) {
1:1f521da:             executor.execute(runnable);
1:1f521da:         } else {
1:6c1676b:             doExecuteNewThread(runnable, name);
1:1f521da:         }
1:1f521da:     }
1:1f521da: 
1:6c1676b:     private void doExecuteNewThread(Runnable runnable, String name) {
1:6c1676b:         String threadName = name + "-" + id.incrementAndGet();
1:6c1676b:         Thread thread = new Thread(runnable, threadName);
1:6c1676b:         thread.setDaemon(daemon);
1:e2aad41: 
1:6c1676b:         LOG.trace("Created and running thread[{}]: {}", threadName, thread);
1:6c1676b:         thread.start();
1:6c1676b:     }
1:d29ca2a: 
1:6cf2169:     protected ExecutorService createDefaultExecutor() {
1:ebcc1b4:         ThreadPoolExecutor rc = new ThreadPoolExecutor(getDefaultCorePoolSize(), getMaxThreadPoolSize(), getDefaultKeepAliveTime(), TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
1:ce5d2a9:             @Override
1:d29ca2a:             public Thread newThread(Runnable runnable) {
1:287f69d:                 String threadName = name + "-" + id.incrementAndGet();
1:287f69d:                 Thread thread = new Thread(runnable, threadName);
1:d29ca2a:                 thread.setDaemon(daemon);
1:d29ca2a:                 thread.setPriority(priority);
1:dffccb1:                 if (threadClassLoader != null) {
1:dffccb1:                     thread.setContextClassLoader(threadClassLoader);
1:dffccb1:                 }
1:b679c8d:                 thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
1:b679c8d:                     @Override
1:b679c8d:                     public void uncaughtException(final Thread t, final Throwable e) {
1:b679c8d:                         LOG.error("Error in thread '{}'", t.getName(), e);
1:b679c8d:                     }
1:b679c8d:                 });
1:b679c8d: 
1:287f69d:                 LOG.trace("Created thread[{}]: {}", threadName, thread);
1:d29ca2a:                 return thread;
1:cf5de8e:             }
1:d29ca2a:         });
1:9a866cf: 
1:e3fcf71:         if (rejectedTaskHandler != null) {
1:e3fcf71:             rc.setRejectedExecutionHandler(rejectedTaskHandler);
1:9a866cf:         } else {
1:9a866cf:             rc.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
1:e3fcf71:         }
1:9a866cf: 
1:d29ca2a:         return rc;
1:cf5de8e:     }
1:ebcc1b4: 
1:cf5de8e:     public ExecutorService getExecutor() {
1:fe5164a:         return executorRef.get();
3:cf5de8e:     }
1:ebcc1b4: 
1:cf5de8e:     public void setExecutor(ExecutorService executor) {
1:fe5164a:         this.executorRef.set(executor);
1:cf5de8e:     }
1:e2aad41: 
1:d29ca2a:     public int getMaxIterationsPerRun() {
1:d29ca2a:         return maxIterationsPerRun;
1:cf5de8e:     }
1:d29ca2a: 
1:d29ca2a:     public void setMaxIterationsPerRun(int maxIterationsPerRun) {
1:d29ca2a:         this.maxIterationsPerRun = maxIterationsPerRun;
1:d29ca2a:     }
1:d29ca2a: 
1:cf5de8e:     public String getName() {
1:cf5de8e:         return name;
1:d29ca2a:     }
1:d29ca2a: 
1:cf5de8e:     public void setName(String name) {
1:cf5de8e:         this.name = name;
1:d29ca2a:     }
1:d29ca2a: 
1:cf5de8e:     public int getPriority() {
1:cf5de8e:         return priority;
1:cf5de8e:     }
1:d29ca2a: 
1:cf5de8e:     public void setPriority(int priority) {
1:cf5de8e:         this.priority = priority;
1:cf5de8e:     }
1:6c1676b: 
1:cf5de8e:     public boolean isDaemon() {
1:cf5de8e:         return daemon;
1:cf5de8e:     }
1:6c1676b: 
1:cf5de8e:     public void setDaemon(boolean daemon) {
1:cf5de8e:         this.daemon = daemon;
1:cf5de8e:     }
1:6c1676b: 
1:cf5de8e:     public boolean isDedicatedTaskRunner() {
1:cf5de8e:         return dedicatedTaskRunner;
1:cf5de8e:     }
1:6c1676b: 
1:cf5de8e:     public void setDedicatedTaskRunner(boolean dedicatedTaskRunner) {
1:cf5de8e:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:cf5de8e:     }
1:287f69d: 
1:c33231b:     public int getMaxThreadPoolSize() {
1:c33231b:         return maxThreadPoolSize;
1:c33231b:     }
1:287f69d: 
1:c33231b:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:c33231b:         this.maxThreadPoolSize = maxThreadPoolSize;
1:c33231b:     }
1:0b01996: 
1:dffccb1:     public void setThreadClassLoader(ClassLoader threadClassLoader) {
1:dffccb1:         this.threadClassLoader = threadClassLoader;
1:dffccb1:     }
1:dffccb1: 
1:e3fcf71:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:e3fcf71:         return rejectedTaskHandler;
1:e3fcf71:     }
2:e3fcf71: 
1:e3fcf71:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:e3fcf71:         this.rejectedTaskHandler = rejectedTaskHandler;
1:e3fcf71:     }
1:287f69d: 
1:287f69d:     public long getShutdownAwaitTermination() {
1:287f69d:         return shutdownAwaitTermination;
1:287f69d:     }
1:287f69d: 
1:287f69d:     public void setShutdownAwaitTermination(long shutdownAwaitTermination) {
1:287f69d:         this.shutdownAwaitTermination = shutdownAwaitTermination;
1:287f69d:     }
1:287f69d: 
1:ebcc1b4:     private static int getDefaultCorePoolSize() {
1:ebcc1b4:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.corePoolSize", 0);
1:ebcc1b4:     }
1:ebcc1b4: 
1:ebcc1b4:     private static int getDefaultMaximumPoolSize() {
1:ebcc1b4:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.maximumPoolSize", Integer.MAX_VALUE);
1:ebcc1b4:     }
1:ebcc1b4: 
1:ce5d2a9:     private static int getDefaultKeepAliveTime() {
1:ce5d2a9:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.keepAliveTime", 30);
1:ce5d2a9:     }
1:cf5de8e: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:fe5164a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicReference<ExecutorService> executorRef = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:         if (!initDone.get()) {
1:             //AMQ-6602 - lock instead of using compareAndSet to prevent threads from seeing a null value
1:             //for executorRef inside createTaskRunner() on contention and creating a DedicatedTaskRunner
1:             synchronized(this) {
1:                 //need to recheck if initDone is true under the lock
1:                 if (!initDone.get()) {
1:                     if (dedicatedTaskRunner || "true".equalsIgnoreCase(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
1:                         executorRef.set(null);
1:                     } else {
1:                         executorRef.compareAndSet(null, createDefaultExecutor());
1:                     }
1:                     LOG.debug("Initialized TaskRunnerFactory[{}] using ExecutorService: {}", name, executorRef.get());
1:                     initDone.set(true);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         ExecutorService executor = executorRef.get();
1:         clearExecutor();
/////////////////////////////////////////////////////////////////////////
1:         ExecutorService executor = executorRef.get();
1:         clearExecutor();
/////////////////////////////////////////////////////////////////////////
1:         ExecutorService executor = executorRef.get();
1:         clearExecutor();
1:     }
1: 
1:     private void clearExecutor() {
1:         //clear under a lock to prevent threads from seeing initDone == true
1:         //but then getting null from executorRef
1:         synchronized(this) {
1:             executorRef.set(null);
1:             initDone.set(false);
1:         }
1:         ExecutorService executor = executorRef.get();
/////////////////////////////////////////////////////////////////////////
1:         ExecutorService executor = executorRef.get();
/////////////////////////////////////////////////////////////////////////
1:         return executorRef.get();
1:         this.executorRef.set(executor);
commit:b679c8d
/////////////////////////////////////////////////////////////////////////
1:                 thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
1:                     @Override
1:                     public void uncaughtException(final Thread t, final Throwable e) {
1:                         LOG.error("Error in thread '{}'", t.getName(), e);
1:                     }
1:                 });
1:                 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:3e7847a
/////////////////////////////////////////////////////////////////////////
1:         this(name, priority, daemon, maxIterationsPerRun, false);
1:         this(name, priority, daemon, maxIterationsPerRun, dedicatedTaskRunner, getDefaultMaximumPoolSize());
commit:9a866cf
/////////////////////////////////////////////////////////////////////////
1: 
1:         } else {
1:             rc.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
1: 
commit:ebcc1b4
/////////////////////////////////////////////////////////////////////////
1:  * processes but that no one task overtakes the system. This is somewhat like
/////////////////////////////////////////////////////////////////////////
1:     private int maxThreadPoolSize = getDefaultMaximumPoolSize();
/////////////////////////////////////////////////////////////////////////
1:         ThreadPoolExecutor rc = new ThreadPoolExecutor(getDefaultCorePoolSize(), getMaxThreadPoolSize(), getDefaultKeepAliveTime(), TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1: 
1:         
1:         
/////////////////////////////////////////////////////////////////////////
1:     private static int getDefaultCorePoolSize() {
1:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.corePoolSize", 0);
1:     }
1: 
1:     private static int getDefaultMaximumPoolSize() {
1:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.maximumPoolSize", Integer.MAX_VALUE);
1:     }
1: 
commit:ce5d2a9
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicLong id = new AtomicLong(0);
1:     private final AtomicBoolean initDone = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(0, getMaxThreadPoolSize(), getDefaultKeepAliveTime(), TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     private static int getDefaultKeepAliveTime() {
1:         return Integer.getInteger("org.apache.activemq.thread.TaskRunnerFactory.keepAliveTime", 30);
1:     }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:dffccb1
/////////////////////////////////////////////////////////////////////////
1:     private ClassLoader threadClassLoader;
/////////////////////////////////////////////////////////////////////////
1:                 if (threadClassLoader != null) {
1:                     thread.setContextClassLoader(threadClassLoader);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     public void setThreadClassLoader(ClassLoader threadClassLoader) {
1:         this.threadClassLoader = threadClassLoader;
1:     }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:1f521da
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Executor;
/////////////////////////////////////////////////////////////////////////
1: public class TaskRunnerFactory implements Executor {
/////////////////////////////////////////////////////////////////////////
1:     public void execute(Runnable runnable) {
0:         execute(runnable, "ActiveMQ Task");
1:     }
1:     
1:     public void execute(Runnable runnable, String name) {
1:         if (executor != null) {
1:             executor.execute(runnable);
1:         } else {
0:             new Thread(runnable, name).start();
1:         }
1:     }
1: 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(1, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * Manages the thread pool for long running tasks. Long running tasks are not
1:  * always active but when they are active, they may need a few iterations of
1:  * processing for them to become idle. The manager ensures that each task is
0:  * processes but that no one task overtakes the system. This is kina like
1:  * cooperative multitasking.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // If your OS/JVM combination has a good thread model, you may want to
0:         // avoid
0:         // using a thread pool to run tasks and use a DedicatedTaskRunner
0:         // instead.
0:         if ("true".equals(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (executor != null) {
1: 
/////////////////////////////////////////////////////////////////////////
0:         // rc.allowCoreThreadTimeOut(true);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executor;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:         //rc.allowCoreThreadTimeOut(true);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
1:     private int maxIterationsPerRun;
1:     private String name;
1:     private int priority;
1:     private boolean daemon;
0:         this("ActiveMQ Task", Thread.NORM_PRIORITY, true, 1000);
1:         
1:         this.name = name;
1:         this.priority = priority;
1:         this.daemon = daemon;
1:         
0:         // If your OS/JVM combination has a good thread model, you may want to avoid 
0:         // using a thread pool to run tasks and use a DedicatedTaskRunner instead.
0:         if( "true".equals(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner")) ) {
0:             executor = null;
1:         } else {
0:             executor = createDefaultExecutor();
1:         }
1:     
1:     public TaskRunner createTaskRunner(Task task, String name) {
0:         if( executor!=null ) {
1:             return new PooledTaskRunner(executor, task, maxIterationsPerRun);
1:         } else {
1:             return new DedicatedTaskRunner(task, name, priority, daemon);
1:         }
0:     protected Executor createDefaultExecutor() {
1:         
/////////////////////////////////////////////////////////////////////////
1:             
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.thread;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.Executor;
0: import edu.emory.mathcs.backport.java.util.concurrent.SynchronousQueue;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: 
1: /**
0:  * Manages the thread pool for long running tasks.
1:  * 
0:  * Long running tasks are not always active but when they are active, they may
0:  * need a few iterations of processing for them to become idle. The manager
0:  * ensures that each task is processes but that no one task overtakes the
0:  * system.
1:  * 
0:  * This is kina like cooperative multitasking.
1:  * 
0:  * @version $Revision: 1.5 $
1:  */
0: public class TaskRunnerFactory {
1: 
0:     private Executor executor;
0:     private int maxIterationsPerRun = 1000;
1: 
1:     public TaskRunnerFactory() {
0:         setExecutor(createDefaultExecutor("ActiveMQ Task", Thread.NORM_PRIORITY, true));
1:     }
1: 
0:     public TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun) {
1:         this.maxIterationsPerRun = maxIterationsPerRun;
0:         setExecutor(createDefaultExecutor(name, priority, daemon));
1:     }
1: 
0:     public TaskRunnerFactory(Executor executor, int maxIterationsPerRun) {
0:         this.executor = executor;
1:         this.maxIterationsPerRun = maxIterationsPerRun;
1:     }
1: 
0:     public TaskRunner createTaskRunner(Task task) {
0:         return new SimpleTaskRunner(executor, task, maxIterationsPerRun);
1:     }
1:     
0:     public Executor getExecutor() {
0:         return executor;
1:     }
1: 
0:     public void setExecutor(Executor executor) {
0:         this.executor = executor;
1:     }
1: 
1:     public int getMaxIterationsPerRun() {
1:         return maxIterationsPerRun;
1:     }
1: 
1:     public void setMaxIterationsPerRun(int maxIterationsPerRun) {
1:         this.maxIterationsPerRun = maxIterationsPerRun;
1:     }
1: 
0:     protected Executor createDefaultExecutor(final String name, final int priority, final boolean daemon) {
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(1, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue(), new ThreadFactory() {
1:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, name);
1:                 thread.setDaemon(daemon);
1:                 thread.setPriority(priority);
1:                 return thread;
1:             }
1:         });
0:         rc.allowCoreThreadTimeOut(true);
1:         return rc;
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Performs a shutdown only, by which the thread pool is shutdown by not graceful nor aggressively.
0:      *
1:      * @see ThreadPoolUtils#shutdown(java.util.concurrent.ExecutorService)
1:      */
1:             ThreadPoolUtils.shutdown(executor);
0:             executor = null;
1:         }
0:         initDone.set(false);
1:     }
1: 
1:     /**
1:      * Performs a shutdown now (aggressively) on the thread pool.
0:      *
1:      * @see ThreadPoolUtils#shutdownNow(java.util.concurrent.ExecutorService)
1:      */
1:     public void shutdownNow() {
1:         if (executor != null) {
1:             ThreadPoolUtils.shutdownNow(executor);
0:             executor = null;
1:         }
0:         initDone.set(false);
1:     }
1: 
1:     /**
1:      * Performs a graceful shutdown.
0:      *
1:      * @see ThreadPoolUtils#shutdownGraceful(java.util.concurrent.ExecutorService)
1:      */
1:     public void shutdownGraceful() {
1:         if (executor != null) {
1:             ThreadPoolUtils.shutdownGraceful(executor, shutdownAwaitTermination);
/////////////////////////////////////////////////////////////////////////
1:             doExecuteNewThread(runnable, name);
1:     private void doExecuteNewThread(Runnable runnable, String name) {
1:         String threadName = name + "-" + id.incrementAndGet();
1:         Thread thread = new Thread(runnable, threadName);
1:         thread.setDaemon(daemon);
1: 
1:         LOG.trace("Created and running thread[{}]: {}", threadName, thread);
1:         thread.start();
1:     }
1: 
commit:287f69d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TaskRunnerFactory.class);
/////////////////////////////////////////////////////////////////////////
1:     private long shutdownAwaitTermination = 30000;
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Initialized TaskRunnerFactory[{}] using ExecutorService: {}", name, executor);
0:             ThreadPoolUtils.shutdown(executor, shutdownAwaitTermination);
0:             executor = null;
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("Execute[{}] runnable: {}", name, runnable);
/////////////////////////////////////////////////////////////////////////
1:                 String threadName = name + "-" + id.incrementAndGet();
1:                 Thread thread = new Thread(runnable, threadName);
1: 
1:                 LOG.trace("Created thread[{}]: {}", threadName, thread);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long getShutdownAwaitTermination() {
1:         return shutdownAwaitTermination;
1:     }
1: 
1:     public void setShutdownAwaitTermination(long shutdownAwaitTermination) {
1:         this.shutdownAwaitTermination = shutdownAwaitTermination;
1:     }
1: 
commit:0b01996
/////////////////////////////////////////////////////////////////////////
1:         this("ActiveMQ Task");
1:     }
1: 
1:     public TaskRunnerFactory(String name) {
1:         this(name, Thread.NORM_PRIORITY, true, 1000);
/////////////////////////////////////////////////////////////////////////
1:         execute(runnable, name);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e3fcf71
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.RejectedExecutionHandler;
/////////////////////////////////////////////////////////////////////////
1:     private RejectedExecutionHandler rejectedTaskHandler = null;
/////////////////////////////////////////////////////////////////////////
1:         if (rejectedTaskHandler != null) {
1:             rc.setRejectedExecutionHandler(rejectedTaskHandler);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:         return rejectedTaskHandler;
1:     }
1: 
1:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:         this.rejectedTaskHandler = rejectedTaskHandler;
1:     }
commit:c33231b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.LinkedBlockingQueue;
/////////////////////////////////////////////////////////////////////////
0:     private int maxThreadPoolSize = Integer.MAX_VALUE;
/////////////////////////////////////////////////////////////////////////
0:         this(name, priority, daemon, maxIterationsPerRun, dedicatedTaskRunner, Integer.MAX_VALUE);
1:     }
0: 
1:     public TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun, boolean dedicatedTaskRunner, int maxThreadPoolSize) {
1:         this.maxThreadPoolSize = maxThreadPoolSize;
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(0, getMaxThreadPoolSize(), 30, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getMaxThreadPoolSize() {
1:         return maxThreadPoolSize;
1:     }
0: 
1:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:         this.maxThreadPoolSize = maxThreadPoolSize;
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:5cd9eba
/////////////////////////////////////////////////////////////////////////
0: 
0:         this(name,priority,daemon,maxIterationsPerRun,false);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 30, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:cf5de8e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:  *
1:  * @org.apache.xbean.XBean
/////////////////////////////////////////////////////////////////////////
1:     private boolean dedicatedTaskRunner;
0:     private AtomicBoolean initDone = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:     }
1:     public void init() {
0:         if (initDone.compareAndSet(false, true)) {
0:             // If your OS/JVM combination has a good thread model, you may want to
1:             // avoid using a thread pool to run tasks and use a DedicatedTaskRunner instead.
0:             if (dedicatedTaskRunner || "true".equalsIgnoreCase(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
0:                 executor = null;
0:             } else if (executor == null) {
0:                 executor = createDefaultExecutor();
1:             }
/////////////////////////////////////////////////////////////////////////
0:         initDone.set(false);
1:         init();
/////////////////////////////////////////////////////////////////////////
1:         init();
/////////////////////////////////////////////////////////////////////////
1:     public ExecutorService getExecutor() {
0:         return executor;
1:     }
0: 
1:     public void setExecutor(ExecutorService executor) {
0:         this.executor = executor;
1:     }
0: 
0:     public int getMaxIterationsPerRun() {
0:         return maxIterationsPerRun;
1:     }
0: 
0:     public void setMaxIterationsPerRun(int maxIterationsPerRun) {
0:         this.maxIterationsPerRun = maxIterationsPerRun;
1:     }
0: 
1:     public String getName() {
1:         return name;
1:     }
0: 
1:     public void setName(String name) {
1:         this.name = name;
1:     }
0: 
1:     public int getPriority() {
1:         return priority;
1:     }
0: 
1:     public void setPriority(int priority) {
1:         this.priority = priority;
1:     }
0: 
1:     public boolean isDaemon() {
1:         return daemon;
1:     }
0: 
1:     public void setDaemon(boolean daemon) {
1:         this.daemon = daemon;
1:     }
0: 
1:     public boolean isDedicatedTaskRunner() {
1:         return dedicatedTaskRunner;
1:     }
0: 
1:     public void setDedicatedTaskRunner(boolean dedicatedTaskRunner) {
1:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:     }
commit:986ed14
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
0:  * processes but that no one task overtakes the system. This is kinda like
/////////////////////////////////////////////////////////////////////////
0:     private AtomicLong id = new AtomicLong(0);
/////////////////////////////////////////////////////////////////////////
0:             new Thread(runnable, name + "-" + id.incrementAndGet()).start();
0:                 Thread thread = new Thread(runnable, name + "-" + id.incrementAndGet());
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:     private TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:398f8ec
/////////////////////////////////////////////////////////////////////////
0:         if (dedicatedTaskRunner || "true".equalsIgnoreCase(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
commit:9cc2d37
/////////////////////////////////////////////////////////////////////////
0:     
0:     	this(name,priority,daemon,maxIterationsPerRun,false);
0:     }
0: 
0: 
1:     public TaskRunnerFactory(String name, int priority, boolean daemon, int maxIterationsPerRun, boolean dedicatedTaskRunner) {
/////////////////////////////////////////////////////////////////////////
0:         if (dedicatedTaskRunner || "true".equals(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {
commit:628842f
/////////////////////////////////////////////////////////////////////////
0:         ThreadPoolExecutor rc = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
author:James Strachan
-------------------------------------------------------------------------------
commit:6cf2169
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
/////////////////////////////////////////////////////////////////////////
0:     private ExecutorService executor;
/////////////////////////////////////////////////////////////////////////
1:     public void shutdown() {
1:         if (executor != null) {
0:             executor.shutdownNow();
0:         }
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
1:     protected ExecutorService createDefaultExecutor() {
/////////////////////////////////////////////////////////////////////////
============================================================================