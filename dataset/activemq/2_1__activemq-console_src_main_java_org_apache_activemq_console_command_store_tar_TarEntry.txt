1:3f32507: /*
1:3f32507:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:3f32507:  *  contributor license agreements.  See the NOTICE file distributed with
1:3f32507:  *  this work for additional information regarding copyright ownership.
1:3f32507:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:3f32507:  *  (the "License"); you may not use this file except in compliance with
1:3f32507:  *  the License.  You may obtain a copy of the License at
1:3f32507:  *
1:3f32507:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3f32507:  *
1:3f32507:  *  Unless required by applicable law or agreed to in writing, software
1:3f32507:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:3f32507:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3f32507:  *  See the License for the specific language governing permissions and
1:3f32507:  *  limitations under the License.
1:3f32507:  *
1:3f32507:  */
1:3f32507: 
1:3f32507: /*
1:3f32507:  * This package is based on the work done by Timothy Gerard Endres
1:3f32507:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:3f32507:  */
1:3f32507: 
1:3f32507: package org.apache.activemq.console.command.store.tar;
1:3f32507: 
1:3f32507: import java.io.File;
1:3f32507: import java.util.Date;
1:3f32507: import java.util.Locale;
1:3f32507: 
1:3f32507: /**
1:3f32507:  * This class represents an entry in a Tar archive. It consists
1:3f32507:  * of the entry's header, as well as the entry's File. Entries
1:3f32507:  * can be instantiated in one of three ways, depending on how
1:3f32507:  * they are to be used.
1:3f32507:  * <p>
1:3f32507:  * TarEntries that are created from the header bytes read from
1:3f32507:  * an archive are instantiated with the TarEntry( byte[] )
1:3f32507:  * constructor. These entries will be used when extracting from
1:3f32507:  * or listing the contents of an archive. These entries have their
1:3f32507:  * header filled in using the header bytes. They also set the File
1:3f32507:  * to null, since they reference an archive entry not a file.
1:3f32507:  * <p>
1:3f32507:  * TarEntries that are created from Files that are to be written
1:3f32507:  * into an archive are instantiated with the TarEntry( File )
1:3f32507:  * constructor. These entries have their header filled in using
1:3f32507:  * the File's information. They also keep a reference to the File
1:3f32507:  * for convenience when writing entries.
1:3f32507:  * <p>
1:3f32507:  * Finally, TarEntries can be constructed from nothing but a name.
1:3f32507:  * This allows the programmer to construct the entry by hand, for
1:3f32507:  * instance when only an InputStream is available for writing to
1:3f32507:  * the archive, and the header information is constructed from
1:3f32507:  * other information. In this case the header fields are set to
1:3f32507:  * defaults and the File is set to null.
1:3f32507:  *
1:3f32507:  * <p>
1:3f32507:  * The C structure for a Tar Entry's header is:
1:3f32507:  * <pre>
1:3f32507:  * struct header {
1:3f32507:  * char name[NAMSIZ];
1:3f32507:  * char mode[8];
1:3f32507:  * char uid[8];
1:3f32507:  * char gid[8];
1:3f32507:  * char size[12];
1:3f32507:  * char mtime[12];
1:3f32507:  * char chksum[8];
1:3f32507:  * char linkflag;
1:3f32507:  * char linkname[NAMSIZ];
1:3f32507:  * char magic[8];
1:3f32507:  * char uname[TUNMLEN];
1:3f32507:  * char gname[TGNMLEN];
1:3f32507:  * char devmajor[8];
1:3f32507:  * char devminor[8];
1:3f32507:  * } header;
1:3f32507:  * </pre>
1:3f32507:  *
1:3f32507:  */
1:3f32507: 
1:3f32507: public class TarEntry implements TarConstants {
1:3f32507:     /** The entry's name. */
1:3f32507:     private StringBuffer name;
1:3f32507: 
1:3f32507:     /** The entry's permission mode. */
1:3f32507:     private int mode;
1:3f32507: 
1:3f32507:     /** The entry's user id. */
1:3f32507:     private int userId;
1:3f32507: 
1:3f32507:     /** The entry's group id. */
1:3f32507:     private int groupId;
1:3f32507: 
1:3f32507:     /** The entry's size. */
1:3f32507:     private long size;
1:3f32507: 
1:3f32507:     /** The entry's modification time. */
1:3f32507:     private long modTime;
1:3f32507: 
1:3f32507:     /** The entry's link flag. */
1:3f32507:     private byte linkFlag;
1:3f32507: 
1:3f32507:     /** The entry's link name. */
1:3f32507:     private StringBuffer linkName;
1:3f32507: 
1:3f32507:     /** The entry's magic tag. */
1:3f32507:     private StringBuffer magic;
1:3f32507: 
1:3f32507:     /** The entry's user name. */
1:3f32507:     private StringBuffer userName;
1:3f32507: 
1:3f32507:     /** The entry's group name. */
1:3f32507:     private StringBuffer groupName;
1:3f32507: 
1:3f32507:     /** The entry's major device number. */
1:3f32507:     private int devMajor;
1:3f32507: 
1:3f32507:     /** The entry's minor device number. */
1:3f32507:     private int devMinor;
1:3f32507: 
1:3f32507:     /** The entry's file reference */
1:3f32507:     private File file;
1:3f32507: 
1:3f32507:     /** Maximum length of a user's name in the tar file */
1:3f32507:     public static final int MAX_NAMELEN = 31;
1:3f32507: 
1:3f32507:     /** Default permissions bits for directories */
1:3f32507:     public static final int DEFAULT_DIR_MODE = 040755;
1:3f32507: 
1:3f32507:     /** Default permissions bits for files */
1:3f32507:     public static final int DEFAULT_FILE_MODE = 0100644;
1:3f32507: 
1:3f32507:     /** Convert millis to seconds */
1:3f32507:     public static final int MILLIS_PER_SECOND = 1000;
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an empty entry and prepares the header values.
1:3f32507:      */
1:3f32507:     private TarEntry () {
1:3f32507:         this.magic = new StringBuffer(TMAGIC);
1:3f32507:         this.name = new StringBuffer();
1:3f32507:         this.linkName = new StringBuffer();
1:3f32507: 
1:3f32507:         String user = System.getProperty("user.name", "");
1:3f32507: 
1:3f32507:         if (user.length() > MAX_NAMELEN) {
1:3f32507:             user = user.substring(0, MAX_NAMELEN);
1:3f32507:         }
1:3f32507: 
1:3f32507:         this.userId = 0;
1:3f32507:         this.groupId = 0;
1:3f32507:         this.userName = new StringBuffer(user);
1:3f32507:         this.groupName = new StringBuffer("");
1:3f32507:         this.file = null;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an entry with only a name. This allows the programmer
1:3f32507:      * to construct the entry's header "by hand". File is set to null.
1:3f32507:      *
1:3f32507:      * @param name the entry name
1:3f32507:      */
1:3f32507:     public TarEntry(String name) {
1:3f32507:         this(name, false);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an entry with only a name. This allows the programmer
1:3f32507:      * to construct the entry's header "by hand". File is set to null.
1:3f32507:      *
1:3f32507:      * @param name the entry name
1:3f32507:      * @param preserveLeadingSlashes whether to allow leading slashes
1:3f32507:      * in the name.
1:3f32507:      */
1:3f32507:     public TarEntry(String name, boolean preserveLeadingSlashes) {
1:3f32507:         this();
1:3f32507: 
1:3f32507:         name = normalizeFileName(name, preserveLeadingSlashes);
1:3f32507:         boolean isDir = name.endsWith("/");
1:3f32507: 
1:3f32507:         this.devMajor = 0;
1:3f32507:         this.devMinor = 0;
1:3f32507:         this.name = new StringBuffer(name);
1:3f32507:         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;
1:3f32507:         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
1:3f32507:         this.userId = 0;
1:3f32507:         this.groupId = 0;
1:3f32507:         this.size = 0;
1:3f32507:         this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;
1:3f32507:         this.linkName = new StringBuffer("");
1:3f32507:         this.userName = new StringBuffer("");
1:3f32507:         this.groupName = new StringBuffer("");
1:3f32507:         this.devMajor = 0;
1:3f32507:         this.devMinor = 0;
1:3f32507: 
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an entry with a name and a link flag.
1:3f32507:      *
1:3f32507:      * @param name the entry name
1:3f32507:      * @param linkFlag the entry link flag.
1:3f32507:      */
1:3f32507:     public TarEntry(String name, byte linkFlag) {
1:3f32507:         this(name);
1:3f32507:         this.linkFlag = linkFlag;
1:3f32507:         if (linkFlag == LF_GNUTYPE_LONGNAME) {
1:3f32507:             magic = new StringBuffer(GNU_TMAGIC);
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an entry for a file. File is set to file, and the
1:3f32507:      * header is constructed from information from the file.
1:3f32507:      *
1:3f32507:      * @param file The file that the entry represents.
1:3f32507:      */
1:3f32507:     public TarEntry(File file) {
1:3f32507:         this();
1:3f32507: 
1:3f32507:         this.file = file;
1:3f32507: 
1:3f32507:         String fileName = normalizeFileName(file.getPath(), false);
1:3f32507:         this.linkName = new StringBuffer("");
1:3f32507:         this.name = new StringBuffer(fileName);
1:3f32507: 
1:3f32507:         if (file.isDirectory()) {
1:3f32507:             this.mode = DEFAULT_DIR_MODE;
1:3f32507:             this.linkFlag = LF_DIR;
1:3f32507: 
1:3f32507:             int nameLength = name.length();
1:3f32507:             if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {
1:3f32507:                 this.name.append("/");
1:3f32507:             }
1:3f32507:             this.size = 0;
1:3f32507:         } else {
1:3f32507:             this.mode = DEFAULT_FILE_MODE;
1:3f32507:             this.linkFlag = LF_NORMAL;
1:3f32507:             this.size = file.length();
1:3f32507:         }
1:3f32507: 
1:3f32507:         this.modTime = file.lastModified() / MILLIS_PER_SECOND;
1:3f32507:         this.devMajor = 0;
1:3f32507:         this.devMinor = 0;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Construct an entry from an archive's header bytes. File is set
1:3f32507:      * to null.
1:3f32507:      *
1:3f32507:      * @param headerBuf The header bytes from a tar archive entry.
1:3f32507:      */
1:3f32507:     public TarEntry(byte[] headerBuf) {
1:3f32507:         this();
1:3f32507:         parseTarHeader(headerBuf);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Determine if the two entries are equal. Equality is determined
1:3f32507:      * by the header names being equal.
1:3f32507:      *
1:3f32507:      * @param it Entry to be checked for equality.
1:3f32507:      * @return True if the entries are equal.
1:3f32507:      */
1:3f32507:     public boolean equals(TarEntry it) {
1:3f32507:         return getName().equals(it.getName());
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Determine if the two entries are equal. Equality is determined
1:3f32507:      * by the header names being equal.
1:3f32507:      *
1:3f32507:      * @param it Entry to be checked for equality.
1:3f32507:      * @return True if the entries are equal.
1:3f32507:      */
1:3f32507:     public boolean equals(Object it) {
1:3f32507:         if (it == null || getClass() != it.getClass()) {
1:3f32507:             return false;
1:3f32507:         }
1:3f32507:         return equals((TarEntry) it);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Hashcodes are based on entry names.
1:3f32507:      *
1:3f32507:      * @return the entry hashcode
1:3f32507:      */
1:3f32507:     public int hashCode() {
1:3f32507:         return getName().hashCode();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Determine if the given entry is a descendant of this entry.
1:3f32507:      * Descendancy is determined by the name of the descendant
1:3f32507:      * starting with this entry's name.
1:3f32507:      *
1:3f32507:      * @param desc Entry to be checked as a descendent of this.
1:3f32507:      * @return True if entry is a descendant of this.
1:3f32507:      */
1:3f32507:     public boolean isDescendent(TarEntry desc) {
1:3f32507:         return desc.getName().startsWith(getName());
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's name.
1:3f32507:      *
1:3f32507:      * @return This entry's name.
1:3f32507:      */
1:3f32507:     public String getName() {
1:3f32507:         return name.toString();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's name.
1:3f32507:      *
1:3f32507:      * @param name This entry's new name.
1:3f32507:      */
1:3f32507:     public void setName(String name) {
1:3f32507:         this.name = new StringBuffer(normalizeFileName(name, false));
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set the mode for this entry
1:3f32507:      *
1:3f32507:      * @param mode the mode for this entry
1:3f32507:      */
1:3f32507:     public void setMode(int mode) {
1:3f32507:         this.mode = mode;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's link name.
1:3f32507:      *
1:3f32507:      * @return This entry's link name.
1:3f32507:      */
1:3f32507:     public String getLinkName() {
1:3f32507:         return linkName.toString();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's user id.
1:3f32507:      *
1:3f32507:      * @return This entry's user id.
1:3f32507:      */
1:3f32507:     public int getUserId() {
1:3f32507:         return userId;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's user id.
1:3f32507:      *
1:3f32507:      * @param userId This entry's new user id.
1:3f32507:      */
1:3f32507:     public void setUserId(int userId) {
1:3f32507:         this.userId = userId;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's group id.
1:3f32507:      *
1:3f32507:      * @return This entry's group id.
1:3f32507:      */
1:3f32507:     public int getGroupId() {
1:3f32507:         return groupId;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's group id.
1:3f32507:      *
1:3f32507:      * @param groupId This entry's new group id.
1:3f32507:      */
1:3f32507:     public void setGroupId(int groupId) {
1:3f32507:         this.groupId = groupId;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's user name.
1:3f32507:      *
1:3f32507:      * @return This entry's user name.
1:3f32507:      */
1:3f32507:     public String getUserName() {
1:3f32507:         return userName.toString();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's user name.
1:3f32507:      *
1:3f32507:      * @param userName This entry's new user name.
1:3f32507:      */
1:3f32507:     public void setUserName(String userName) {
1:3f32507:         this.userName = new StringBuffer(userName);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's group name.
1:3f32507:      *
1:3f32507:      * @return This entry's group name.
1:3f32507:      */
1:3f32507:     public String getGroupName() {
1:3f32507:         return groupName.toString();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's group name.
1:3f32507:      *
1:3f32507:      * @param groupName This entry's new group name.
1:3f32507:      */
1:3f32507:     public void setGroupName(String groupName) {
1:3f32507:         this.groupName = new StringBuffer(groupName);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Convenience method to set this entry's group and user ids.
1:3f32507:      *
1:3f32507:      * @param userId This entry's new user id.
1:3f32507:      * @param groupId This entry's new group id.
1:3f32507:      */
1:3f32507:     public void setIds(int userId, int groupId) {
1:3f32507:         setUserId(userId);
1:3f32507:         setGroupId(groupId);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Convenience method to set this entry's group and user names.
1:3f32507:      *
1:3f32507:      * @param userName This entry's new user name.
1:3f32507:      * @param groupName This entry's new group name.
1:3f32507:      */
1:3f32507:     public void setNames(String userName, String groupName) {
1:3f32507:         setUserName(userName);
1:3f32507:         setGroupName(groupName);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's modification time. The parameter passed
1:3f32507:      * to this method is in "Java time".
1:3f32507:      *
1:3f32507:      * @param time This entry's new modification time.
1:3f32507:      */
1:3f32507:     public void setModTime(long time) {
1:3f32507:         modTime = time / MILLIS_PER_SECOND;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's modification time.
1:3f32507:      *
1:3f32507:      * @param time This entry's new modification time.
1:3f32507:      */
1:3f32507:     public void setModTime(Date time) {
1:3f32507:         modTime = time.getTime() / MILLIS_PER_SECOND;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's modification time.
1:3f32507:      *
1:3f32507:      * @return time This entry's new modification time.
1:3f32507:      */
1:3f32507:     public Date getModTime() {
1:3f32507:         return new Date(modTime * MILLIS_PER_SECOND);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's file.
1:3f32507:      *
1:3f32507:      * @return This entry's file.
1:3f32507:      */
1:3f32507:     public File getFile() {
1:3f32507:         return file;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's mode.
1:3f32507:      *
1:3f32507:      * @return This entry's mode.
1:3f32507:      */
1:3f32507:     public int getMode() {
1:3f32507:         return mode;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get this entry's file size.
1:3f32507:      *
1:3f32507:      * @return This entry's file size.
1:3f32507:      */
1:3f32507:     public long getSize() {
1:3f32507:         return size;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set this entry's file size.
1:3f32507:      *
1:3f32507:      * @param size This entry's new file size.
1:3f32507:      */
1:3f32507:     public void setSize(long size) {
1:3f32507:         this.size = size;
1:3f32507:     }
1:3f32507: 
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Indicate if this entry is a GNU long name block
1:3f32507:      *
1:3f32507:      * @return true if this is a long name extension provided by GNU tar
1:3f32507:      */
1:3f32507:     public boolean isGNULongNameEntry() {
1:3f32507:         return linkFlag == LF_GNUTYPE_LONGNAME
1:3f32507:                            && name.toString().equals(GNU_LONGLINK);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Return whether or not this entry represents a directory.
1:3f32507:      *
1:3f32507:      * @return True if this entry is a directory.
1:3f32507:      */
1:3f32507:     public boolean isDirectory() {
1:3f32507:         if (file != null) {
1:3f32507:             return file.isDirectory();
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (linkFlag == LF_DIR) {
1:3f32507:             return true;
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (getName().endsWith("/")) {
1:3f32507:             return true;
1:3f32507:         }
1:3f32507: 
1:3f32507:         return false;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * If this entry represents a file, and the file is a directory, return
1:3f32507:      * an array of TarEntries for this entry's children.
1:3f32507:      *
1:3f32507:      * @return An array of TarEntry's for this entry's children.
1:3f32507:      */
1:3f32507:     public TarEntry[] getDirectoryEntries() {
1:3f32507:         if (file == null || !file.isDirectory()) {
1:3f32507:             return new TarEntry[0];
1:3f32507:         }
1:3f32507: 
1:3f32507:         String[]   list = file.list();
1:3f32507:         TarEntry[] result = new TarEntry[list.length];
1:3f32507: 
1:3f32507:         for (int i = 0; i < list.length; ++i) {
1:3f32507:             result[i] = new TarEntry(new File(file, list[i]));
1:3f32507:         }
1:3f32507: 
1:3f32507:         return result;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Write an entry's header information to a header buffer.
1:3f32507:      *
1:3f32507:      * @param outbuf The tar entry header buffer to fill in.
1:3f32507:      */
1:3f32507:     public void writeEntryHeader(byte[] outbuf) {
1:3f32507:         int offset = 0;
1:3f32507: 
1:3f32507:         offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);
1:3f32507:         offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);
1:3f32507:         offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);
1:3f32507:         offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);
1:3f32507:         offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);
1:3f32507:         offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);
1:3f32507: 
1:3f32507:         int csOffset = offset;
1:3f32507: 
1:3f32507:         for (int c = 0; c < CHKSUMLEN; ++c) {
1:3f32507:             outbuf[offset++] = (byte) ' ';
1:3f32507:         }
1:3f32507: 
1:3f32507:         outbuf[offset++] = linkFlag;
1:3f32507:         offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);
1:3f32507:         offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);
1:3f32507:         offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);
1:3f32507:         offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);
1:3f32507:         offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);
1:3f32507:         offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);
1:3f32507: 
1:3f32507:         while (offset < outbuf.length) {
1:3f32507:             outbuf[offset++] = 0;
1:3f32507:         }
1:3f32507: 
1:3f32507:         long chk = TarUtils.computeCheckSum(outbuf);
1:3f32507: 
1:3f32507:         TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Parse an entry's header information from a header buffer.
1:3f32507:      *
1:3f32507:      * @param header The tar entry header buffer to get information from.
1:3f32507:      */
1:3f32507:     public void parseTarHeader(byte[] header) {
1:3f32507:         int offset = 0;
1:3f32507: 
1:3f32507:         name = TarUtils.parseName(header, offset, NAMELEN);
1:3f32507:         offset += NAMELEN;
1:3f32507:         mode = (int) TarUtils.parseOctal(header, offset, MODELEN);
1:3f32507:         offset += MODELEN;
1:3f32507:         userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
1:3f32507:         offset += UIDLEN;
1:3f32507:         groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
1:3f32507:         offset += GIDLEN;
1:3f32507:         size = TarUtils.parseOctal(header, offset, SIZELEN);
1:3f32507:         offset += SIZELEN;
1:3f32507:         modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
1:3f32507:         offset += MODTIMELEN;
1:3f32507:         offset += CHKSUMLEN;
1:3f32507:         linkFlag = header[offset++];
1:3f32507:         linkName = TarUtils.parseName(header, offset, NAMELEN);
1:3f32507:         offset += NAMELEN;
1:3f32507:         magic = TarUtils.parseName(header, offset, MAGICLEN);
1:3f32507:         offset += MAGICLEN;
1:3f32507:         userName = TarUtils.parseName(header, offset, UNAMELEN);
1:3f32507:         offset += UNAMELEN;
1:3f32507:         groupName = TarUtils.parseName(header, offset, GNAMELEN);
1:3f32507:         offset += GNAMELEN;
1:3f32507:         devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
1:3f32507:         offset += DEVLEN;
1:3f32507:         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Strips Windows' drive letter as well as any leading slashes,
1:3f32507:      * turns path separators into forward slahes.
1:3f32507:      */
1:3f32507:     private static String normalizeFileName(String fileName,
1:3f32507:                                             boolean preserveLeadingSlashes) {
1:3f32507:         String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
1:3f32507: 
1:3f32507:         if (osname != null) {
1:3f32507: 
1:3f32507:             // Strip off drive letters!
1:3f32507:             // REVIEW Would a better check be "(File.separator == '\')"?
1:3f32507: 
1:3f32507:             if (osname.startsWith("windows")) {
1:3f32507:                 if (fileName.length() > 2) {
1:3f32507:                     char ch1 = fileName.charAt(0);
1:3f32507:                     char ch2 = fileName.charAt(1);
1:3f32507: 
1:3f32507:                     if (ch2 == ':'
1:3f32507:                         && ((ch1 >= 'a' && ch1 <= 'z')
1:3f32507:                             || (ch1 >= 'A' && ch1 <= 'Z'))) {
1:3f32507:                         fileName = fileName.substring(2);
1:3f32507:                     }
1:3f32507:                 }
1:3f32507:             } else if (osname.indexOf("netware") > -1) {
1:3f32507:                 int colon = fileName.indexOf(':');
1:3f32507:                 if (colon != -1) {
1:3f32507:                     fileName = fileName.substring(colon + 1);
1:3f32507:                 }
1:3f32507:             }
1:3f32507:         }
1:3f32507: 
1:3f32507:         fileName = fileName.replace(File.separatorChar, '/');
1:3f32507: 
1:3f32507:         // No absolute pathnames
1:3f32507:         // Windows (and Posix?) paths can start with "\\NetworkDrive\",
1:3f32507:         // so we loop on starting /'s.
1:3f32507:         while (!preserveLeadingSlashes && fileName.startsWith("/")) {
1:3f32507:             fileName = fileName.substring(1);
1:3f32507:         }
1:3f32507:         return fileName;
1:3f32507:     }
1:3f32507: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:3f32507
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  *
1:  */
1: 
1: /*
1:  * This package is based on the work done by Timothy Gerard Endres
1:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:  */
1: 
1: package org.apache.activemq.console.command.store.tar;
1: 
1: import java.io.File;
1: import java.util.Date;
1: import java.util.Locale;
1: 
1: /**
1:  * This class represents an entry in a Tar archive. It consists
1:  * of the entry's header, as well as the entry's File. Entries
1:  * can be instantiated in one of three ways, depending on how
1:  * they are to be used.
1:  * <p>
1:  * TarEntries that are created from the header bytes read from
1:  * an archive are instantiated with the TarEntry( byte[] )
1:  * constructor. These entries will be used when extracting from
1:  * or listing the contents of an archive. These entries have their
1:  * header filled in using the header bytes. They also set the File
1:  * to null, since they reference an archive entry not a file.
1:  * <p>
1:  * TarEntries that are created from Files that are to be written
1:  * into an archive are instantiated with the TarEntry( File )
1:  * constructor. These entries have their header filled in using
1:  * the File's information. They also keep a reference to the File
1:  * for convenience when writing entries.
1:  * <p>
1:  * Finally, TarEntries can be constructed from nothing but a name.
1:  * This allows the programmer to construct the entry by hand, for
1:  * instance when only an InputStream is available for writing to
1:  * the archive, and the header information is constructed from
1:  * other information. In this case the header fields are set to
1:  * defaults and the File is set to null.
1:  *
1:  * <p>
1:  * The C structure for a Tar Entry's header is:
1:  * <pre>
1:  * struct header {
1:  * char name[NAMSIZ];
1:  * char mode[8];
1:  * char uid[8];
1:  * char gid[8];
1:  * char size[12];
1:  * char mtime[12];
1:  * char chksum[8];
1:  * char linkflag;
1:  * char linkname[NAMSIZ];
1:  * char magic[8];
1:  * char uname[TUNMLEN];
1:  * char gname[TGNMLEN];
1:  * char devmajor[8];
1:  * char devminor[8];
1:  * } header;
1:  * </pre>
1:  *
1:  */
1: 
1: public class TarEntry implements TarConstants {
1:     /** The entry's name. */
1:     private StringBuffer name;
1: 
1:     /** The entry's permission mode. */
1:     private int mode;
1: 
1:     /** The entry's user id. */
1:     private int userId;
1: 
1:     /** The entry's group id. */
1:     private int groupId;
1: 
1:     /** The entry's size. */
1:     private long size;
1: 
1:     /** The entry's modification time. */
1:     private long modTime;
1: 
1:     /** The entry's link flag. */
1:     private byte linkFlag;
1: 
1:     /** The entry's link name. */
1:     private StringBuffer linkName;
1: 
1:     /** The entry's magic tag. */
1:     private StringBuffer magic;
1: 
1:     /** The entry's user name. */
1:     private StringBuffer userName;
1: 
1:     /** The entry's group name. */
1:     private StringBuffer groupName;
1: 
1:     /** The entry's major device number. */
1:     private int devMajor;
1: 
1:     /** The entry's minor device number. */
1:     private int devMinor;
1: 
1:     /** The entry's file reference */
1:     private File file;
1: 
1:     /** Maximum length of a user's name in the tar file */
1:     public static final int MAX_NAMELEN = 31;
1: 
1:     /** Default permissions bits for directories */
1:     public static final int DEFAULT_DIR_MODE = 040755;
1: 
1:     /** Default permissions bits for files */
1:     public static final int DEFAULT_FILE_MODE = 0100644;
1: 
1:     /** Convert millis to seconds */
1:     public static final int MILLIS_PER_SECOND = 1000;
1: 
1:     /**
1:      * Construct an empty entry and prepares the header values.
1:      */
1:     private TarEntry () {
1:         this.magic = new StringBuffer(TMAGIC);
1:         this.name = new StringBuffer();
1:         this.linkName = new StringBuffer();
1: 
1:         String user = System.getProperty("user.name", "");
1: 
1:         if (user.length() > MAX_NAMELEN) {
1:             user = user.substring(0, MAX_NAMELEN);
1:         }
1: 
1:         this.userId = 0;
1:         this.groupId = 0;
1:         this.userName = new StringBuffer(user);
1:         this.groupName = new StringBuffer("");
1:         this.file = null;
1:     }
1: 
1:     /**
1:      * Construct an entry with only a name. This allows the programmer
1:      * to construct the entry's header "by hand". File is set to null.
1:      *
1:      * @param name the entry name
1:      */
1:     public TarEntry(String name) {
1:         this(name, false);
1:     }
1: 
1:     /**
1:      * Construct an entry with only a name. This allows the programmer
1:      * to construct the entry's header "by hand". File is set to null.
1:      *
1:      * @param name the entry name
1:      * @param preserveLeadingSlashes whether to allow leading slashes
1:      * in the name.
1:      */
1:     public TarEntry(String name, boolean preserveLeadingSlashes) {
1:         this();
1: 
1:         name = normalizeFileName(name, preserveLeadingSlashes);
1:         boolean isDir = name.endsWith("/");
1: 
1:         this.devMajor = 0;
1:         this.devMinor = 0;
1:         this.name = new StringBuffer(name);
1:         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;
1:         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
1:         this.userId = 0;
1:         this.groupId = 0;
1:         this.size = 0;
1:         this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;
1:         this.linkName = new StringBuffer("");
1:         this.userName = new StringBuffer("");
1:         this.groupName = new StringBuffer("");
1:         this.devMajor = 0;
1:         this.devMinor = 0;
1: 
1:     }
1: 
1:     /**
1:      * Construct an entry with a name and a link flag.
1:      *
1:      * @param name the entry name
1:      * @param linkFlag the entry link flag.
1:      */
1:     public TarEntry(String name, byte linkFlag) {
1:         this(name);
1:         this.linkFlag = linkFlag;
1:         if (linkFlag == LF_GNUTYPE_LONGNAME) {
1:             magic = new StringBuffer(GNU_TMAGIC);
1:         }
1:     }
1: 
1:     /**
1:      * Construct an entry for a file. File is set to file, and the
1:      * header is constructed from information from the file.
1:      *
1:      * @param file The file that the entry represents.
1:      */
1:     public TarEntry(File file) {
1:         this();
1: 
1:         this.file = file;
1: 
1:         String fileName = normalizeFileName(file.getPath(), false);
1:         this.linkName = new StringBuffer("");
1:         this.name = new StringBuffer(fileName);
1: 
1:         if (file.isDirectory()) {
1:             this.mode = DEFAULT_DIR_MODE;
1:             this.linkFlag = LF_DIR;
1: 
1:             int nameLength = name.length();
1:             if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {
1:                 this.name.append("/");
1:             }
1:             this.size = 0;
1:         } else {
1:             this.mode = DEFAULT_FILE_MODE;
1:             this.linkFlag = LF_NORMAL;
1:             this.size = file.length();
1:         }
1: 
1:         this.modTime = file.lastModified() / MILLIS_PER_SECOND;
1:         this.devMajor = 0;
1:         this.devMinor = 0;
1:     }
1: 
1:     /**
1:      * Construct an entry from an archive's header bytes. File is set
1:      * to null.
1:      *
1:      * @param headerBuf The header bytes from a tar archive entry.
1:      */
1:     public TarEntry(byte[] headerBuf) {
1:         this();
1:         parseTarHeader(headerBuf);
1:     }
1: 
1:     /**
1:      * Determine if the two entries are equal. Equality is determined
1:      * by the header names being equal.
1:      *
1:      * @param it Entry to be checked for equality.
1:      * @return True if the entries are equal.
1:      */
1:     public boolean equals(TarEntry it) {
1:         return getName().equals(it.getName());
1:     }
1: 
1:     /**
1:      * Determine if the two entries are equal. Equality is determined
1:      * by the header names being equal.
1:      *
1:      * @param it Entry to be checked for equality.
1:      * @return True if the entries are equal.
1:      */
1:     public boolean equals(Object it) {
1:         if (it == null || getClass() != it.getClass()) {
1:             return false;
1:         }
1:         return equals((TarEntry) it);
1:     }
1: 
1:     /**
1:      * Hashcodes are based on entry names.
1:      *
1:      * @return the entry hashcode
1:      */
1:     public int hashCode() {
1:         return getName().hashCode();
1:     }
1: 
1:     /**
1:      * Determine if the given entry is a descendant of this entry.
1:      * Descendancy is determined by the name of the descendant
1:      * starting with this entry's name.
1:      *
1:      * @param desc Entry to be checked as a descendent of this.
1:      * @return True if entry is a descendant of this.
1:      */
1:     public boolean isDescendent(TarEntry desc) {
1:         return desc.getName().startsWith(getName());
1:     }
1: 
1:     /**
1:      * Get this entry's name.
1:      *
1:      * @return This entry's name.
1:      */
1:     public String getName() {
1:         return name.toString();
1:     }
1: 
1:     /**
1:      * Set this entry's name.
1:      *
1:      * @param name This entry's new name.
1:      */
1:     public void setName(String name) {
1:         this.name = new StringBuffer(normalizeFileName(name, false));
1:     }
1: 
1:     /**
1:      * Set the mode for this entry
1:      *
1:      * @param mode the mode for this entry
1:      */
1:     public void setMode(int mode) {
1:         this.mode = mode;
1:     }
1: 
1:     /**
1:      * Get this entry's link name.
1:      *
1:      * @return This entry's link name.
1:      */
1:     public String getLinkName() {
1:         return linkName.toString();
1:     }
1: 
1:     /**
1:      * Get this entry's user id.
1:      *
1:      * @return This entry's user id.
1:      */
1:     public int getUserId() {
1:         return userId;
1:     }
1: 
1:     /**
1:      * Set this entry's user id.
1:      *
1:      * @param userId This entry's new user id.
1:      */
1:     public void setUserId(int userId) {
1:         this.userId = userId;
1:     }
1: 
1:     /**
1:      * Get this entry's group id.
1:      *
1:      * @return This entry's group id.
1:      */
1:     public int getGroupId() {
1:         return groupId;
1:     }
1: 
1:     /**
1:      * Set this entry's group id.
1:      *
1:      * @param groupId This entry's new group id.
1:      */
1:     public void setGroupId(int groupId) {
1:         this.groupId = groupId;
1:     }
1: 
1:     /**
1:      * Get this entry's user name.
1:      *
1:      * @return This entry's user name.
1:      */
1:     public String getUserName() {
1:         return userName.toString();
1:     }
1: 
1:     /**
1:      * Set this entry's user name.
1:      *
1:      * @param userName This entry's new user name.
1:      */
1:     public void setUserName(String userName) {
1:         this.userName = new StringBuffer(userName);
1:     }
1: 
1:     /**
1:      * Get this entry's group name.
1:      *
1:      * @return This entry's group name.
1:      */
1:     public String getGroupName() {
1:         return groupName.toString();
1:     }
1: 
1:     /**
1:      * Set this entry's group name.
1:      *
1:      * @param groupName This entry's new group name.
1:      */
1:     public void setGroupName(String groupName) {
1:         this.groupName = new StringBuffer(groupName);
1:     }
1: 
1:     /**
1:      * Convenience method to set this entry's group and user ids.
1:      *
1:      * @param userId This entry's new user id.
1:      * @param groupId This entry's new group id.
1:      */
1:     public void setIds(int userId, int groupId) {
1:         setUserId(userId);
1:         setGroupId(groupId);
1:     }
1: 
1:     /**
1:      * Convenience method to set this entry's group and user names.
1:      *
1:      * @param userName This entry's new user name.
1:      * @param groupName This entry's new group name.
1:      */
1:     public void setNames(String userName, String groupName) {
1:         setUserName(userName);
1:         setGroupName(groupName);
1:     }
1: 
1:     /**
1:      * Set this entry's modification time. The parameter passed
1:      * to this method is in "Java time".
1:      *
1:      * @param time This entry's new modification time.
1:      */
1:     public void setModTime(long time) {
1:         modTime = time / MILLIS_PER_SECOND;
1:     }
1: 
1:     /**
1:      * Set this entry's modification time.
1:      *
1:      * @param time This entry's new modification time.
1:      */
1:     public void setModTime(Date time) {
1:         modTime = time.getTime() / MILLIS_PER_SECOND;
1:     }
1: 
1:     /**
1:      * Set this entry's modification time.
1:      *
1:      * @return time This entry's new modification time.
1:      */
1:     public Date getModTime() {
1:         return new Date(modTime * MILLIS_PER_SECOND);
1:     }
1: 
1:     /**
1:      * Get this entry's file.
1:      *
1:      * @return This entry's file.
1:      */
1:     public File getFile() {
1:         return file;
1:     }
1: 
1:     /**
1:      * Get this entry's mode.
1:      *
1:      * @return This entry's mode.
1:      */
1:     public int getMode() {
1:         return mode;
1:     }
1: 
1:     /**
1:      * Get this entry's file size.
1:      *
1:      * @return This entry's file size.
1:      */
1:     public long getSize() {
1:         return size;
1:     }
1: 
1:     /**
1:      * Set this entry's file size.
1:      *
1:      * @param size This entry's new file size.
1:      */
1:     public void setSize(long size) {
1:         this.size = size;
1:     }
1: 
1: 
1:     /**
1:      * Indicate if this entry is a GNU long name block
1:      *
1:      * @return true if this is a long name extension provided by GNU tar
1:      */
1:     public boolean isGNULongNameEntry() {
1:         return linkFlag == LF_GNUTYPE_LONGNAME
1:                            && name.toString().equals(GNU_LONGLINK);
1:     }
1: 
1:     /**
1:      * Return whether or not this entry represents a directory.
1:      *
1:      * @return True if this entry is a directory.
1:      */
1:     public boolean isDirectory() {
1:         if (file != null) {
1:             return file.isDirectory();
1:         }
1: 
1:         if (linkFlag == LF_DIR) {
1:             return true;
1:         }
1: 
1:         if (getName().endsWith("/")) {
1:             return true;
1:         }
1: 
1:         return false;
1:     }
1: 
1:     /**
1:      * If this entry represents a file, and the file is a directory, return
1:      * an array of TarEntries for this entry's children.
1:      *
1:      * @return An array of TarEntry's for this entry's children.
1:      */
1:     public TarEntry[] getDirectoryEntries() {
1:         if (file == null || !file.isDirectory()) {
1:             return new TarEntry[0];
1:         }
1: 
1:         String[]   list = file.list();
1:         TarEntry[] result = new TarEntry[list.length];
1: 
1:         for (int i = 0; i < list.length; ++i) {
1:             result[i] = new TarEntry(new File(file, list[i]));
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * Write an entry's header information to a header buffer.
1:      *
1:      * @param outbuf The tar entry header buffer to fill in.
1:      */
1:     public void writeEntryHeader(byte[] outbuf) {
1:         int offset = 0;
1: 
1:         offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);
1:         offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);
1:         offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);
1:         offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);
1:         offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);
1:         offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);
1: 
1:         int csOffset = offset;
1: 
1:         for (int c = 0; c < CHKSUMLEN; ++c) {
1:             outbuf[offset++] = (byte) ' ';
1:         }
1: 
1:         outbuf[offset++] = linkFlag;
1:         offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);
1:         offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);
1:         offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);
1:         offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);
1:         offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);
1:         offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);
1: 
1:         while (offset < outbuf.length) {
1:             outbuf[offset++] = 0;
1:         }
1: 
1:         long chk = TarUtils.computeCheckSum(outbuf);
1: 
1:         TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);
1:     }
1: 
1:     /**
1:      * Parse an entry's header information from a header buffer.
1:      *
1:      * @param header The tar entry header buffer to get information from.
1:      */
1:     public void parseTarHeader(byte[] header) {
1:         int offset = 0;
1: 
1:         name = TarUtils.parseName(header, offset, NAMELEN);
1:         offset += NAMELEN;
1:         mode = (int) TarUtils.parseOctal(header, offset, MODELEN);
1:         offset += MODELEN;
1:         userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
1:         offset += UIDLEN;
1:         groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
1:         offset += GIDLEN;
1:         size = TarUtils.parseOctal(header, offset, SIZELEN);
1:         offset += SIZELEN;
1:         modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
1:         offset += MODTIMELEN;
1:         offset += CHKSUMLEN;
1:         linkFlag = header[offset++];
1:         linkName = TarUtils.parseName(header, offset, NAMELEN);
1:         offset += NAMELEN;
1:         magic = TarUtils.parseName(header, offset, MAGICLEN);
1:         offset += MAGICLEN;
1:         userName = TarUtils.parseName(header, offset, UNAMELEN);
1:         offset += UNAMELEN;
1:         groupName = TarUtils.parseName(header, offset, GNAMELEN);
1:         offset += GNAMELEN;
1:         devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
1:         offset += DEVLEN;
1:         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
1:     }
1: 
1:     /**
1:      * Strips Windows' drive letter as well as any leading slashes,
1:      * turns path separators into forward slahes.
1:      */
1:     private static String normalizeFileName(String fileName,
1:                                             boolean preserveLeadingSlashes) {
1:         String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
1: 
1:         if (osname != null) {
1: 
1:             // Strip off drive letters!
1:             // REVIEW Would a better check be "(File.separator == '\')"?
1: 
1:             if (osname.startsWith("windows")) {
1:                 if (fileName.length() > 2) {
1:                     char ch1 = fileName.charAt(0);
1:                     char ch2 = fileName.charAt(1);
1: 
1:                     if (ch2 == ':'
1:                         && ((ch1 >= 'a' && ch1 <= 'z')
1:                             || (ch1 >= 'A' && ch1 <= 'Z'))) {
1:                         fileName = fileName.substring(2);
1:                     }
1:                 }
1:             } else if (osname.indexOf("netware") > -1) {
1:                 int colon = fileName.indexOf(':');
1:                 if (colon != -1) {
1:                     fileName = fileName.substring(colon + 1);
1:                 }
1:             }
1:         }
1: 
1:         fileName = fileName.replace(File.separatorChar, '/');
1: 
1:         // No absolute pathnames
1:         // Windows (and Posix?) paths can start with "\\NetworkDrive\",
1:         // so we loop on starting /'s.
1:         while (!preserveLeadingSlashes && fileName.startsWith("/")) {
1:             fileName = fileName.substring(1);
1:         }
1:         return fileName;
1:     }
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:cfe5e98
/////////////////////////////////////////////////////////////////////////
0: /*
0:  *  Licensed to the Apache Software Foundation (ASF) under one or more
0:  *  contributor license agreements.  See the NOTICE file distributed with
0:  *  this work for additional information regarding copyright ownership.
0:  *  The ASF licenses this file to You under the Apache License, Version 2.0
0:  *  (the "License"); you may not use this file except in compliance with
0:  *  the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  *  Unless required by applicable law or agreed to in writing, software
0:  *  distributed under the License is distributed on an "AS IS" BASIS,
0:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  *  See the License for the specific language governing permissions and
0:  *  limitations under the License.
0:  *
0:  */
0: 
0: /*
0:  * This package is based on the work done by Timothy Gerard Endres
0:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
0:  */
0: 
0: package org.apache.activemq.console.command.store.tar;
0: 
0: import java.io.File;
0: import java.util.Date;
0: import java.util.Locale;
0: 
0: /**
0:  * This class represents an entry in a Tar archive. It consists
0:  * of the entry's header, as well as the entry's File. Entries
0:  * can be instantiated in one of three ways, depending on how
0:  * they are to be used.
0:  * <p>
0:  * TarEntries that are created from the header bytes read from
0:  * an archive are instantiated with the TarEntry( byte[] )
0:  * constructor. These entries will be used when extracting from
0:  * or listing the contents of an archive. These entries have their
0:  * header filled in using the header bytes. They also set the File
0:  * to null, since they reference an archive entry not a file.
0:  * <p>
0:  * TarEntries that are created from Files that are to be written
0:  * into an archive are instantiated with the TarEntry( File )
0:  * constructor. These entries have their header filled in using
0:  * the File's information. They also keep a reference to the File
0:  * for convenience when writing entries.
0:  * <p>
0:  * Finally, TarEntries can be constructed from nothing but a name.
0:  * This allows the programmer to construct the entry by hand, for
0:  * instance when only an InputStream is available for writing to
0:  * the archive, and the header information is constructed from
0:  * other information. In this case the header fields are set to
0:  * defaults and the File is set to null.
0:  *
0:  * <p>
0:  * The C structure for a Tar Entry's header is:
0:  * <pre>
0:  * struct header {
0:  * char name[NAMSIZ];
0:  * char mode[8];
0:  * char uid[8];
0:  * char gid[8];
0:  * char size[12];
0:  * char mtime[12];
0:  * char chksum[8];
0:  * char linkflag;
0:  * char linkname[NAMSIZ];
0:  * char magic[8];
0:  * char uname[TUNMLEN];
0:  * char gname[TGNMLEN];
0:  * char devmajor[8];
0:  * char devminor[8];
0:  * } header;
0:  * </pre>
0:  *
0:  */
0: 
0: public class TarEntry implements TarConstants {
0:     /** The entry's name. */
0:     private StringBuffer name;
0: 
0:     /** The entry's permission mode. */
0:     private int mode;
0: 
0:     /** The entry's user id. */
0:     private int userId;
0: 
0:     /** The entry's group id. */
0:     private int groupId;
0: 
0:     /** The entry's size. */
0:     private long size;
0: 
0:     /** The entry's modification time. */
0:     private long modTime;
0: 
0:     /** The entry's link flag. */
0:     private byte linkFlag;
0: 
0:     /** The entry's link name. */
0:     private StringBuffer linkName;
0: 
0:     /** The entry's magic tag. */
0:     private StringBuffer magic;
0: 
0:     /** The entry's user name. */
0:     private StringBuffer userName;
0: 
0:     /** The entry's group name. */
0:     private StringBuffer groupName;
0: 
0:     /** The entry's major device number. */
0:     private int devMajor;
0: 
0:     /** The entry's minor device number. */
0:     private int devMinor;
0: 
0:     /** The entry's file reference */
0:     private File file;
0: 
0:     /** Maximum length of a user's name in the tar file */
0:     public static final int MAX_NAMELEN = 31;
0: 
0:     /** Default permissions bits for directories */
0:     public static final int DEFAULT_DIR_MODE = 040755;
0: 
0:     /** Default permissions bits for files */
0:     public static final int DEFAULT_FILE_MODE = 0100644;
0: 
0:     /** Convert millis to seconds */
0:     public static final int MILLIS_PER_SECOND = 1000;
0: 
0:     /**
0:      * Construct an empty entry and prepares the header values.
0:      */
0:     private TarEntry () {
0:         this.magic = new StringBuffer(TMAGIC);
0:         this.name = new StringBuffer();
0:         this.linkName = new StringBuffer();
0: 
0:         String user = System.getProperty("user.name", "");
0: 
0:         if (user.length() > MAX_NAMELEN) {
0:             user = user.substring(0, MAX_NAMELEN);
0:         }
0: 
0:         this.userId = 0;
0:         this.groupId = 0;
0:         this.userName = new StringBuffer(user);
0:         this.groupName = new StringBuffer("");
0:         this.file = null;
0:     }
0: 
0:     /**
0:      * Construct an entry with only a name. This allows the programmer
0:      * to construct the entry's header "by hand". File is set to null.
0:      *
0:      * @param name the entry name
0:      */
0:     public TarEntry(String name) {
0:         this(name, false);
0:     }
0: 
0:     /**
0:      * Construct an entry with only a name. This allows the programmer
0:      * to construct the entry's header "by hand". File is set to null.
0:      *
0:      * @param name the entry name
0:      * @param preserveLeadingSlashes whether to allow leading slashes
0:      * in the name.
0:      */
0:     public TarEntry(String name, boolean preserveLeadingSlashes) {
0:         this();
0: 
0:         name = normalizeFileName(name, preserveLeadingSlashes);
0:         boolean isDir = name.endsWith("/");
0: 
0:         this.devMajor = 0;
0:         this.devMinor = 0;
0:         this.name = new StringBuffer(name);
0:         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;
0:         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
0:         this.userId = 0;
0:         this.groupId = 0;
0:         this.size = 0;
0:         this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;
0:         this.linkName = new StringBuffer("");
0:         this.userName = new StringBuffer("");
0:         this.groupName = new StringBuffer("");
0:         this.devMajor = 0;
0:         this.devMinor = 0;
0: 
0:     }
0: 
0:     /**
0:      * Construct an entry with a name and a link flag.
0:      *
0:      * @param name the entry name
0:      * @param linkFlag the entry link flag.
0:      */
0:     public TarEntry(String name, byte linkFlag) {
0:         this(name);
0:         this.linkFlag = linkFlag;
0:         if (linkFlag == LF_GNUTYPE_LONGNAME) {
0:             magic = new StringBuffer(GNU_TMAGIC);
0:         }
0:     }
0: 
0:     /**
0:      * Construct an entry for a file. File is set to file, and the
0:      * header is constructed from information from the file.
0:      *
0:      * @param file The file that the entry represents.
0:      */
0:     public TarEntry(File file) {
0:         this();
0: 
0:         this.file = file;
0: 
0:         String fileName = normalizeFileName(file.getPath(), false);
0:         this.linkName = new StringBuffer("");
0:         this.name = new StringBuffer(fileName);
0: 
0:         if (file.isDirectory()) {
0:             this.mode = DEFAULT_DIR_MODE;
0:             this.linkFlag = LF_DIR;
0: 
0:             int nameLength = name.length();
0:             if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {
0:                 this.name.append("/");
0:             }
0:             this.size = 0;
0:         } else {
0:             this.mode = DEFAULT_FILE_MODE;
0:             this.linkFlag = LF_NORMAL;
0:             this.size = file.length();
0:         }
0: 
0:         this.modTime = file.lastModified() / MILLIS_PER_SECOND;
0:         this.devMajor = 0;
0:         this.devMinor = 0;
0:     }
0: 
0:     /**
0:      * Construct an entry from an archive's header bytes. File is set
0:      * to null.
0:      *
0:      * @param headerBuf The header bytes from a tar archive entry.
0:      */
0:     public TarEntry(byte[] headerBuf) {
0:         this();
0:         parseTarHeader(headerBuf);
0:     }
0: 
0:     /**
0:      * Determine if the two entries are equal. Equality is determined
0:      * by the header names being equal.
0:      *
0:      * @param it Entry to be checked for equality.
0:      * @return True if the entries are equal.
0:      */
0:     public boolean equals(TarEntry it) {
0:         return getName().equals(it.getName());
0:     }
0: 
0:     /**
0:      * Determine if the two entries are equal. Equality is determined
0:      * by the header names being equal.
0:      *
0:      * @param it Entry to be checked for equality.
0:      * @return True if the entries are equal.
0:      */
0:     public boolean equals(Object it) {
0:         if (it == null || getClass() != it.getClass()) {
0:             return false;
0:         }
0:         return equals((TarEntry) it);
0:     }
0: 
0:     /**
0:      * Hashcodes are based on entry names.
0:      *
0:      * @return the entry hashcode
0:      */
0:     public int hashCode() {
0:         return getName().hashCode();
0:     }
0: 
0:     /**
0:      * Determine if the given entry is a descendant of this entry.
0:      * Descendancy is determined by the name of the descendant
0:      * starting with this entry's name.
0:      *
0:      * @param desc Entry to be checked as a descendent of this.
0:      * @return True if entry is a descendant of this.
0:      */
0:     public boolean isDescendent(TarEntry desc) {
0:         return desc.getName().startsWith(getName());
0:     }
0: 
0:     /**
0:      * Get this entry's name.
0:      *
0:      * @return This entry's name.
0:      */
0:     public String getName() {
0:         return name.toString();
0:     }
0: 
0:     /**
0:      * Set this entry's name.
0:      *
0:      * @param name This entry's new name.
0:      */
0:     public void setName(String name) {
0:         this.name = new StringBuffer(normalizeFileName(name, false));
0:     }
0: 
0:     /**
0:      * Set the mode for this entry
0:      *
0:      * @param mode the mode for this entry
0:      */
0:     public void setMode(int mode) {
0:         this.mode = mode;
0:     }
0: 
0:     /**
0:      * Get this entry's link name.
0:      *
0:      * @return This entry's link name.
0:      */
0:     public String getLinkName() {
0:         return linkName.toString();
0:     }
0: 
0:     /**
0:      * Get this entry's user id.
0:      *
0:      * @return This entry's user id.
0:      */
0:     public int getUserId() {
0:         return userId;
0:     }
0: 
0:     /**
0:      * Set this entry's user id.
0:      *
0:      * @param userId This entry's new user id.
0:      */
0:     public void setUserId(int userId) {
0:         this.userId = userId;
0:     }
0: 
0:     /**
0:      * Get this entry's group id.
0:      *
0:      * @return This entry's group id.
0:      */
0:     public int getGroupId() {
0:         return groupId;
0:     }
0: 
0:     /**
0:      * Set this entry's group id.
0:      *
0:      * @param groupId This entry's new group id.
0:      */
0:     public void setGroupId(int groupId) {
0:         this.groupId = groupId;
0:     }
0: 
0:     /**
0:      * Get this entry's user name.
0:      *
0:      * @return This entry's user name.
0:      */
0:     public String getUserName() {
0:         return userName.toString();
0:     }
0: 
0:     /**
0:      * Set this entry's user name.
0:      *
0:      * @param userName This entry's new user name.
0:      */
0:     public void setUserName(String userName) {
0:         this.userName = new StringBuffer(userName);
0:     }
0: 
0:     /**
0:      * Get this entry's group name.
0:      *
0:      * @return This entry's group name.
0:      */
0:     public String getGroupName() {
0:         return groupName.toString();
0:     }
0: 
0:     /**
0:      * Set this entry's group name.
0:      *
0:      * @param groupName This entry's new group name.
0:      */
0:     public void setGroupName(String groupName) {
0:         this.groupName = new StringBuffer(groupName);
0:     }
0: 
0:     /**
0:      * Convenience method to set this entry's group and user ids.
0:      *
0:      * @param userId This entry's new user id.
0:      * @param groupId This entry's new group id.
0:      */
0:     public void setIds(int userId, int groupId) {
0:         setUserId(userId);
0:         setGroupId(groupId);
0:     }
0: 
0:     /**
0:      * Convenience method to set this entry's group and user names.
0:      *
0:      * @param userName This entry's new user name.
0:      * @param groupName This entry's new group name.
0:      */
0:     public void setNames(String userName, String groupName) {
0:         setUserName(userName);
0:         setGroupName(groupName);
0:     }
0: 
0:     /**
0:      * Set this entry's modification time. The parameter passed
0:      * to this method is in "Java time".
0:      *
0:      * @param time This entry's new modification time.
0:      */
0:     public void setModTime(long time) {
0:         modTime = time / MILLIS_PER_SECOND;
0:     }
0: 
0:     /**
0:      * Set this entry's modification time.
0:      *
0:      * @param time This entry's new modification time.
0:      */
0:     public void setModTime(Date time) {
0:         modTime = time.getTime() / MILLIS_PER_SECOND;
0:     }
0: 
0:     /**
0:      * Set this entry's modification time.
0:      *
0:      * @return time This entry's new modification time.
0:      */
0:     public Date getModTime() {
0:         return new Date(modTime * MILLIS_PER_SECOND);
0:     }
0: 
0:     /**
0:      * Get this entry's file.
0:      *
0:      * @return This entry's file.
0:      */
0:     public File getFile() {
0:         return file;
0:     }
0: 
0:     /**
0:      * Get this entry's mode.
0:      *
0:      * @return This entry's mode.
0:      */
0:     public int getMode() {
0:         return mode;
0:     }
0: 
0:     /**
0:      * Get this entry's file size.
0:      *
0:      * @return This entry's file size.
0:      */
0:     public long getSize() {
0:         return size;
0:     }
0: 
0:     /**
0:      * Set this entry's file size.
0:      *
0:      * @param size This entry's new file size.
0:      */
0:     public void setSize(long size) {
0:         this.size = size;
0:     }
0: 
0: 
0:     /**
0:      * Indicate if this entry is a GNU long name block
0:      *
0:      * @return true if this is a long name extension provided by GNU tar
0:      */
0:     public boolean isGNULongNameEntry() {
0:         return linkFlag == LF_GNUTYPE_LONGNAME
0:                            && name.toString().equals(GNU_LONGLINK);
0:     }
0: 
0:     /**
0:      * Return whether or not this entry represents a directory.
0:      *
0:      * @return True if this entry is a directory.
0:      */
0:     public boolean isDirectory() {
0:         if (file != null) {
0:             return file.isDirectory();
0:         }
0: 
0:         if (linkFlag == LF_DIR) {
0:             return true;
0:         }
0: 
0:         if (getName().endsWith("/")) {
0:             return true;
0:         }
0: 
0:         return false;
0:     }
0: 
0:     /**
0:      * If this entry represents a file, and the file is a directory, return
0:      * an array of TarEntries for this entry's children.
0:      *
0:      * @return An array of TarEntry's for this entry's children.
0:      */
0:     public TarEntry[] getDirectoryEntries() {
0:         if (file == null || !file.isDirectory()) {
0:             return new TarEntry[0];
0:         }
0: 
0:         String[]   list = file.list();
0:         TarEntry[] result = new TarEntry[list.length];
0: 
0:         for (int i = 0; i < list.length; ++i) {
0:             result[i] = new TarEntry(new File(file, list[i]));
0:         }
0: 
0:         return result;
0:     }
0: 
0:     /**
0:      * Write an entry's header information to a header buffer.
0:      *
0:      * @param outbuf The tar entry header buffer to fill in.
0:      */
0:     public void writeEntryHeader(byte[] outbuf) {
0:         int offset = 0;
0: 
0:         offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);
0:         offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);
0:         offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);
0:         offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);
0:         offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);
0:         offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);
0: 
0:         int csOffset = offset;
0: 
0:         for (int c = 0; c < CHKSUMLEN; ++c) {
0:             outbuf[offset++] = (byte) ' ';
0:         }
0: 
0:         outbuf[offset++] = linkFlag;
0:         offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);
0:         offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);
0:         offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);
0:         offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);
0:         offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);
0:         offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);
0: 
0:         while (offset < outbuf.length) {
0:             outbuf[offset++] = 0;
0:         }
0: 
0:         long chk = TarUtils.computeCheckSum(outbuf);
0: 
0:         TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);
0:     }
0: 
0:     /**
0:      * Parse an entry's header information from a header buffer.
0:      *
0:      * @param header The tar entry header buffer to get information from.
0:      */
0:     public void parseTarHeader(byte[] header) {
0:         int offset = 0;
0: 
0:         name = TarUtils.parseName(header, offset, NAMELEN);
0:         offset += NAMELEN;
0:         mode = (int) TarUtils.parseOctal(header, offset, MODELEN);
0:         offset += MODELEN;
0:         userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
0:         offset += UIDLEN;
0:         groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
0:         offset += GIDLEN;
0:         size = TarUtils.parseOctal(header, offset, SIZELEN);
0:         offset += SIZELEN;
0:         modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
0:         offset += MODTIMELEN;
0:         offset += CHKSUMLEN;
0:         linkFlag = header[offset++];
0:         linkName = TarUtils.parseName(header, offset, NAMELEN);
0:         offset += NAMELEN;
0:         magic = TarUtils.parseName(header, offset, MAGICLEN);
0:         offset += MAGICLEN;
0:         userName = TarUtils.parseName(header, offset, UNAMELEN);
0:         offset += UNAMELEN;
0:         groupName = TarUtils.parseName(header, offset, GNAMELEN);
0:         offset += GNAMELEN;
0:         devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
0:         offset += DEVLEN;
0:         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
0:     }
0: 
0:     /**
0:      * Strips Windows' drive letter as well as any leading slashes,
0:      * turns path separators into forward slahes.
0:      */
0:     private static String normalizeFileName(String fileName,
0:                                             boolean preserveLeadingSlashes) {
0:         String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
0: 
0:         if (osname != null) {
0: 
0:             // Strip off drive letters!
0:             // REVIEW Would a better check be "(File.separator == '\')"?
0: 
0:             if (osname.startsWith("windows")) {
0:                 if (fileName.length() > 2) {
0:                     char ch1 = fileName.charAt(0);
0:                     char ch2 = fileName.charAt(1);
0: 
0:                     if (ch2 == ':'
0:                         && ((ch1 >= 'a' && ch1 <= 'z')
0:                             || (ch1 >= 'A' && ch1 <= 'Z'))) {
0:                         fileName = fileName.substring(2);
0:                     }
0:                 }
0:             } else if (osname.indexOf("netware") > -1) {
0:                 int colon = fileName.indexOf(':');
0:                 if (colon != -1) {
0:                     fileName = fileName.substring(colon + 1);
0:                 }
0:             }
0:         }
0: 
0:         fileName = fileName.replace(File.separatorChar, '/');
0: 
0:         // No absolute pathnames
0:         // Windows (and Posix?) paths can start with "\\NetworkDrive\",
0:         // so we loop on starting /'s.
0:         while (!preserveLeadingSlashes && fileName.startsWith("/")) {
0:             fileName = fileName.substring(1);
0:         }
0:         return fileName;
0:     }
0: }
============================================================================