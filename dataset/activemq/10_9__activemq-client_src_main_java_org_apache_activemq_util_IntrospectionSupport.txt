1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:5be5a62:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:5be5a62:  *
1:5be5a62:  * Unless required by applicable law or agreed to in writing, software
1:5be5a62:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5be5a62:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5be5a62:  * See the License for the specific language governing permissions and
1:5be5a62:  * limitations under the License.
1:5be5a62:  */
1:d29ca2a: package org.apache.activemq.util;
1:7f0e135: 
1:013f372: import java.lang.reflect.Field;
1:d29ca2a: import java.lang.reflect.Method;
1:013f372: import java.lang.reflect.Modifier;
1:013f372: import java.util.Arrays;
1:d29ca2a: import java.util.HashMap;
1:d29ca2a: import java.util.Iterator;
1:013f372: import java.util.LinkedHashMap;
1:b186513: import java.util.List;
1:4b44d31: import java.util.Locale;
1:d29ca2a: import java.util.Map;
1:d29ca2a: import java.util.Map.Entry;
1:74a7a8b: import java.util.Set;
1:74a7a8b: 
1:9822d58: import javax.net.ssl.SSLServerSocket;
1:9822d58: 
1:74a7a8b: import org.apache.activemq.command.ActiveMQDestination;
1:1802116: import org.slf4j.Logger;
1:1802116: import org.slf4j.LoggerFactory;
1:f812e34: 
1:933eb2f: public final class IntrospectionSupport {
1:65f2428: 
1:1802116:     private static final Logger LOG = LoggerFactory.getLogger(IntrospectionSupport.class);
1:933eb2f: 
1:933eb2f:     private IntrospectionSupport() {
1:6b283ab:     }
1:f812e34: 
1:fc00993:     public static boolean getProperties(Object target, Map props, String optionPrefix) {
1:f812e34: 
1:7f0e135:         boolean rc = false;
1:fc00993:         if (target == null) {
1:7f0e135:             throw new IllegalArgumentException("target was null.");
1:933eb2f:         }
1:fc00993:         if (props == null) {
1:7f0e135:             throw new IllegalArgumentException("props was null.");
1:fc00993:         }
1:f812e34: 
1:fc00993:         if (optionPrefix == null) {
1:f812e34:             optionPrefix = "";
1:fc00993:         }
1:f812e34: 
1:f0b3f1c:         Class<?> clazz = target.getClass();
1:7f0e135:         Method[] methods = clazz.getMethods();
1:f0b3f1c:         for (Method method : methods) {
1:7f0e135:             String name = method.getName();
1:f0b3f1c:             Class<?> type = method.getReturnType();
1:f0b3f1c:             Class<?> params[] = method.getParameterTypes();
1:1802116:             if ((name.startsWith("is") || name.startsWith("get")) && params.length == 0 && type != null) {
1:f812e34: 
1:65f2428:                 try {
1:f812e34: 
1:e85a8bd:                     Object value = method.invoke(target);
1:fc00993:                     if (value == null) {
1:f812e34:                         continue;
1:65f2428:                     }
1:f812e34: 
1:f812e34:                     String strValue = convertToString(value, type);
1:fc00993:                     if (strValue == null) {
1:f812e34:                         continue;
1:65f2428:                     }
1:8248314:                     if (name.startsWith("get")) {
1:4b44d31:                         name = name.substring(3, 4).toLowerCase(Locale.ENGLISH)
1:8248314:                                 + name.substring(4);
1:8248314:                     } else {
1:4b44d31:                         name = name.substring(2, 3).toLowerCase(Locale.ENGLISH)
1:8248314:                                 + name.substring(3);
1:65f2428:                     }
1:f812e34:                     props.put(optionPrefix + name, strValue);
1:7f0e135:                     rc = true;
1:f812e34: 
1:864fdbe:                 } catch (Exception ignore) {
1:fc00993:                 }
1:fc00993:             }
1:fc00993:         }
1:f812e34: 
1:7f0e135:         return rc;
1:fc00993:     }
1:f812e34: 
1:ecf89a6:     public static boolean setProperties(Object target, Map<String, ?> props, String optionPrefix) {
1:7f0e135:         boolean rc = false;
1:fc00993:         if (target == null) {
1:d29ca2a:             throw new IllegalArgumentException("target was null.");
1:fc00993:         }
1:fc00993:         if (props == null) {
1:d29ca2a:             throw new IllegalArgumentException("props was null.");
1:fc00993:         }
1:f812e34: 
1:933eb2f:         for (Iterator<String> iter = props.keySet().iterator(); iter.hasNext();) {
1:933eb2f:             String name = iter.next();
1:f812e34:             if (name.startsWith(optionPrefix)) {
1:d29ca2a:                 Object value = props.get(name);
1:d29ca2a:                 name = name.substring(optionPrefix.length());
1:f812e34:                 if (setProperty(target, name, value)) {
2:d29ca2a:                     iter.remove();
1:d29ca2a:                     rc = true;
1:fc00993:                 }
1:fc00993:             }
1:fc00993:         }
1:7f0e135:         return rc;
1:fc00993:     }
1:f812e34: 
1:933eb2f:     public static Map<String, Object> extractProperties(Map props, String optionPrefix) {
1:fc00993:         if (props == null) {
1:d29ca2a:             throw new IllegalArgumentException("props was null.");
1:f812e34:         }
1:f812e34: 
1:933eb2f:         HashMap<String, Object> rc = new HashMap<String, Object>(props.size());
1:f812e34: 
1:f0b3f1c:         for (Iterator<?> iter = props.keySet().iterator(); iter.hasNext();) {
1:f812e34:             String name = (String)iter.next();
1:f812e34:             if (name.startsWith(optionPrefix)) {
1:d29ca2a:                 Object value = props.get(name);
1:d29ca2a:                 name = name.substring(optionPrefix.length());
1:d29ca2a:                 rc.put(name, value);
1:d29ca2a:                 iter.remove();
1:7f0e135:             }
1:7f0e135:         }
1:f812e34: 
1:d29ca2a:         return rc;
1:7f0e135:     }
1:f812e34: 
1:f6bf823:     public static boolean setProperties(Object target, Map<?, ?> props) {
1:f6bf823:         return setProperties(target, props, true);
1:f6bf823:     }
1:f6bf823: 
1:f6bf823:     public static boolean setProperties(Object target, Map<?, ?> props, boolean removeIfSet) {
1:f812e34:         boolean rc = false;
1:f812e34: 
1:fc00993:         if (target == null) {
1:d29ca2a:             throw new IllegalArgumentException("target was null.");
1:7f0e135:         }
1:fc00993:         if (props == null) {
1:d29ca2a:             throw new IllegalArgumentException("props was null.");
1:d29ca2a:         }
1:f812e34: 
1:f0b3f1c:         for (Iterator<?> iter = props.entrySet().iterator(); iter.hasNext();) {
1:f0b3f1c:             Map.Entry<?,?> entry = (Entry<?,?>)iter.next();
1:f812e34:             if (setProperty(target, (String)entry.getKey(), entry.getValue())) {
1:f6bf823:                 if (removeIfSet) {
1:f6bf823:                     iter.remove();
1:f6bf823:                 }
1:f812e34:                 rc = true;
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:7f0e135: 
1:41265f2:     public static boolean setProperty(Object target, String name, Object value) {
1:f812e34:         try {
1:f0b3f1c:             Class<?> clazz = target.getClass();
1:9822d58:             if (target instanceof SSLServerSocket) {
1:9822d58:                 // overcome illegal access issues with internal implementation class
1:9822d58:                 clazz = SSLServerSocket.class;
1:9822d58:             }
1:d29ca2a:             Method setter = findSetterMethod(clazz, name);
1:fc00993:             if (setter == null) {
2:d29ca2a:                 return false;
1:fc00993:             }
1:f812e34: 
1:f812e34:             // If the type is null or it matches the needed type, just use the
1:f812e34:             // value directly
1:f812e34:             if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
1:e85a8bd:                 setter.invoke(target, value);
1:d29ca2a:             } else {
1:d29ca2a:                 // We need to convert it
1:e85a8bd:                 setter.invoke(target, convert(value, setter.getParameterTypes()[0]));
1:013f372:             }
3:d29ca2a:             return true;
1:864fdbe:         } catch (Exception e) {
1:864fdbe:             LOG.error(String.format("Could not set property %s on %s", name, target), e);
1:d29ca2a:             return false;
1:fc00993:         }
1:d29ca2a:     }
1:7f0e135: 
1:1802116:     private static Object convert(Object value, Class to) {
1:1802116:         if (value == null) {
1:1802116:             // lets avoid NullPointerException when converting to boolean for null values
1:1802116:             if (boolean.class.isAssignableFrom(to)) {
1:1802116:                 return Boolean.FALSE;
1:d29ca2a:             }
1:d29ca2a:             return null;
1:7f0e135:         }
1:7f0e135: 
1:1802116:         // eager same instance type test to avoid the overhead of invoking the type converter
1:1802116:         // if already same type
1:1802116:         if (to.isAssignableFrom(value.getClass())) {
1:1802116:             return to.cast(value);
1:7f0e135:         }
1:7f0e135: 
1:e85a8bd:         // special for String[] as we do not want to use a PropertyEditor for that
1:1802116:         if (to.isAssignableFrom(String[].class)) {
1:e85a8bd:             return StringArrayConverter.convertToStringArray(value);
1:7f0e135:         }
1:7f0e135: 
1:1802116:         // special for String to List<ActiveMQDestination> as we do not want to use a PropertyEditor for that
1:1802116:         if (value.getClass().equals(String.class) && to.equals(List.class)) {
1:1802116:             Object answer = StringToListOfActiveMQDestinationConverter.convertToActiveMQDestination(value);
1:1802116:             if (answer != null) {
1:1802116:                 return answer;
1:d29ca2a:             }
1:d29ca2a:         }
1:7f0e135: 
1:1802116:         TypeConversionSupport.Converter converter = TypeConversionSupport.lookupConverter(value.getClass(), to);
1:1802116:         if (converter != null) {
1:1802116:             return converter.convert(value);
1:1802116:         } else {
1:1802116:             throw new IllegalArgumentException("Cannot convert from " + value.getClass()
1:1802116:                     + " to " + to + " with value " + value);
1:d29ca2a:         }
1:d29ca2a:     }
1:7f0e135: 
1:1802116:     public static String convertToString(Object value, Class to) {
1:1802116:         if (value == null) {
1:7f0e135:             return null;
1:d29ca2a:         }
1:7f0e135: 
1:1802116:         // already a String
1:1802116:         if (value instanceof String) {
1:1802116:             return (String) value;
1:d29ca2a:         }
1:7f0e135: 
1:e85a8bd:         // special for String[] as we do not want to use a PropertyEditor for that
1:1802116:         if (String[].class.isInstance(value)) {
1:e85a8bd:             String[] array = (String[]) value;
1:e85a8bd:             return StringArrayConverter.convertToString(array);
1:d29ca2a:         }
1:7f0e135: 
1:1802116:         // special for String to List<ActiveMQDestination> as we do not want to use a PropertyEditor for that
1:1802116:         if (List.class.isInstance(value)) {
1:1802116:             // if the list is a ActiveMQDestination, then return a comma list
1:1802116:             String answer = StringToListOfActiveMQDestinationConverter.convertFromActiveMQDestination(value);
1:1802116:             if (answer != null) {
1:1802116:                 return answer;
1:d29ca2a:             }
1:d29ca2a:         }
1:7f0e135: 
1:1802116:         TypeConversionSupport.Converter converter = TypeConversionSupport.lookupConverter(value.getClass(), String.class);
1:1802116:         if (converter != null) {
1:1802116:             return (String) converter.convert(value);
1:1802116:         } else {
1:1802116:             throw new IllegalArgumentException("Cannot convert from " + value.getClass()
1:1802116:                     + " to " + to + " with value " + value);
1:d29ca2a:         }
3:1802116:     }
1:7f0e135: 
1:6630e81:     public static Method findSetterMethod(Class clazz, String name) {
1:d29ca2a:         // Build the method name.
1:0567645:         name = "set" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
1:d29ca2a:         Method[] methods = clazz.getMethods();
1:f0b3f1c:         for (Method method : methods) {
1:f0b3f1c:             Class<?> params[] = method.getParameterTypes();
1:1c1ed4d:             if (method.getName().equals(name) && params.length == 1 ) {
1:d29ca2a:                 return method;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return null;
1:d29ca2a:     }
1:7f0e135: 
1:6630e81:     public static Method findGetterMethod(Class clazz, String name) {
1:6630e81:         // Build the method name.
1:6630e81:         name = "get" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
1:6630e81:         Method[] methods = clazz.getMethods();
1:6630e81:         for (Method method : methods) {
1:6630e81:             Class<?> params[] = method.getParameterTypes();
1:6630e81:             if (method.getName().equals(name) && params.length == 0 ) {
1:6630e81:                 return method;
1:6630e81:             }
1:6630e81:         }
1:6630e81:         return null;
1:6630e81:     }
1:6630e81: 
1:fc00993:     public static String toString(Object target) {
1:1f01c94:         return toString(target, Object.class, null);
1:d29ca2a:     }
1:7f0e135: 
1:fc00993:     public static String toString(Object target, Class stopClass) {
1:f0b3f1c:         return toString(target, stopClass, null);
1:d29ca2a:     }
1:7f0e135: 
1:1f01c94:     public static String toString(Object target, Class stopClass, Map<String, Object> overrideFields) {
1:933eb2f:         LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();
1:013f372:         addFields(target, target.getClass(), stopClass, map);
1:1f01c94:         if (overrideFields != null) {
1:f0b3f1c:             for(String key : overrideFields.keySet()) {
1:f0b3f1c:                 Object value = overrideFields.get(key);
1:f0b3f1c:                 map.put(key, value);
1:013f372:             }
1:7f0e135: 
1:013f372:         }
1:9c0d3ce:         StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
1:9c0d3ce:         buffer.append(" {");
1:f0b3f1c:         Set<Entry<String, Object>> entrySet = map.entrySet();
1:9c0d3ce:         boolean first = true;
1:f0b3f1c:         for (Map.Entry<String,Object> entry : entrySet) {
1:1466d6c:             Object value = entry.getValue();
1:1466d6c:             Object key = entry.getKey();
1:9c0d3ce:             if (first) {
1:9c0d3ce:                 first = false;
1:f812e34:             } else {
1:9c0d3ce:                 buffer.append(", ");
1:f0b3f1c:             }
1:1466d6c:             buffer.append(key);
1:9c0d3ce:             buffer.append(" = ");
1:7f0e135: 
1:1466d6c:             appendToString(buffer, key, value);
1:1802116:         }
1:9c0d3ce:         buffer.append("}");
1:9c0d3ce:         return buffer.toString();
1:1802116:     }
7:013f372: 
1:1466d6c:     protected static void appendToString(StringBuffer buffer, Object key, Object value) {
1:9c0d3ce:         if (value instanceof ActiveMQDestination) {
1:f812e34:             ActiveMQDestination destination = (ActiveMQDestination)value;
1:9c0d3ce:             buffer.append(destination.getQualifiedName());
1:4b44d31:         } else if (key.toString().toLowerCase(Locale.ENGLISH).contains("password")){
1:f0b3f1c:             buffer.append("*****");
1:f812e34:         } else {
1:9c0d3ce:             buffer.append(value);
1:1802116:         }
1:1802116:     }
1:013f372: 
1:fc00993:     public static String simpleName(Class clazz) {
1:013f372:         String name = clazz.getName();
1:013f372:         int p = name.lastIndexOf(".");
1:f812e34:         if (p >= 0) {
1:f812e34:             name = name.substring(p + 1);
1:013f372:         }
1:013f372:         return name;
1:013f372:     }
1:f812e34: 
1:933eb2f:     private static void addFields(Object target, Class startClass, Class<Object> stopClass, LinkedHashMap<String, Object> map) {
1:013f372: 
1:fc00993:         if (startClass != stopClass) {
1:f812e34:             addFields(target, startClass.getSuperclass(), stopClass, map);
1:fc00993:         }
1:f812e34: 
1:013f372:         Field[] fields = startClass.getDeclaredFields();
1:f0b3f1c:         for (Field field : fields) {
1:933eb2f:             if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())
1:933eb2f:                 || Modifier.isPrivate(field.getModifiers())) {
2:7f0e135:                 continue;
1:013f372:             }
1:f812e34: 
1:7f0e135:             try {
1:013f372:                 field.setAccessible(true);
1:013f372:                 Object o = field.get(target);
1:f812e34:                 if (o != null && o.getClass().isArray()) {
2:013f372:                     try {
1:f812e34:                         o = Arrays.asList((Object[])o);
1:864fdbe:                     } catch (Exception e) {
1:013f372:                     }
1:013f372:                 }
1:013f372:                 map.put(field.getName(), o);
1:864fdbe:             } catch (Exception e) {
1:1802116:                 LOG.debug("Error getting field " + field + " on class " + startClass + ". This exception is ignored.", e);
1:013f372:             }
1:013f372:         }
1:1802116:     }
1:1802116: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:f6bf823
/////////////////////////////////////////////////////////////////////////
1:     public static boolean setProperties(Object target, Map<?, ?> props) {
1:         return setProperties(target, props, true);
1:     }
1: 
1:     public static boolean setProperties(Object target, Map<?, ?> props, boolean removeIfSet) {
/////////////////////////////////////////////////////////////////////////
1:                 if (removeIfSet) {
1:                     iter.remove();
1:                 }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:6630e81
/////////////////////////////////////////////////////////////////////////
1:     public static Method findSetterMethod(Class clazz, String name) {
/////////////////////////////////////////////////////////////////////////
1:     public static Method findGetterMethod(Class clazz, String name) {
1:         // Build the method name.
1:         name = "get" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
1:         Method[] methods = clazz.getMethods();
1:         for (Method method : methods) {
1:             Class<?> params[] = method.getParameterTypes();
1:             if (method.getName().equals(name) && params.length == 0 ) {
1:                 return method;
1:             }
1:         }
1:         return null;
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:864fdbe
/////////////////////////////////////////////////////////////////////////
1:                 } catch (Exception ignore) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception e) {
1:             LOG.error(String.format("Could not set property %s on %s", name, target), e);
/////////////////////////////////////////////////////////////////////////
1:                     } catch (Exception e) {
1:             } catch (Exception e) {
commit:9822d58
/////////////////////////////////////////////////////////////////////////
1: import javax.net.ssl.SSLServerSocket;
1: 
/////////////////////////////////////////////////////////////////////////
0:                     PropertyEditorManager.registerEditor(String[].class, StringArrayEditor.class);
/////////////////////////////////////////////////////////////////////////
1:             if (target instanceof SSLServerSocket) {
1:                 // overcome illegal access issues with internal implementation class
1:                 clazz = SSLServerSocket.class;
1:             }
commit:0567645
/////////////////////////////////////////////////////////////////////////
1:         name = "set" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
commit:6b283ab
/////////////////////////////////////////////////////////////////////////
0: 		synchronized (PropertyEditorManager.class) {
0: 		    String[] existingSearchPath = PropertyEditorManager.getEditorSearchPath();
0: 		    String[] newSearchPath = (String[]) Array.newInstance(String.class,
0: 		            existingSearchPath.length + additionalPath.length);
0: 		    System.arraycopy(existingSearchPath, 0,
0: 		            newSearchPath, 0,
0: 		            existingSearchPath.length);
0: 		    System.arraycopy(additionalPath, 0, 
0: 		            newSearchPath, existingSearchPath.length,
0: 		            additionalPath.length);
0: 		    PropertyEditorManager.setEditorSearchPath(newSearchPath);
1: 		}
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:65f2428
/////////////////////////////////////////////////////////////////////////
1:     
0:     static {
0:         // Add Spring and ActiveMQ specific property editors
0:         String[] additionalPath = new String[] {
0:                 "org.springframework.beans.propertyeditors",
0:                 "org.apache.activemq.util" };
0:         synchronized (PropertyEditorManager.class) {
0:             String[] existingSearchPath = PropertyEditorManager.getEditorSearchPath();
0:             String[] newSearchPath = (String[]) Array.newInstance(String.class,
0:                     existingSearchPath.length + additionalPath.length);
0:             System.arraycopy(existingSearchPath, 0,
0:                     newSearchPath, 0,
0:                     existingSearchPath.length);
0:             System.arraycopy(additionalPath, 0, 
0:                     newSearchPath, existingSearchPath.length,
0:                     additionalPath.length);
1:             try {
0:                 PropertyEditorManager.setEditorSearchPath(newSearchPath);                
0:                 PropertyEditorManager.registerEditor(String[].class, StringArrayEditor.class);
0:             } catch(java.security.AccessControlException ignore) {
0:                 // we might be in an applet...
1:             }
1:         }
1:     }
commit:1c1ed4d
/////////////////////////////////////////////////////////////////////////
1:             if (method.getName().equals(name) && params.length == 1 ) {
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: public final class IntrospectionSupport {
1:     
1:     private IntrospectionSupport() {
1:     }
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<String> iter = props.keySet().iterator(); iter.hasNext();) {
1:             String name = iter.next();
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, Object> extractProperties(Map props, String optionPrefix) {
1:         HashMap<String, Object> rc = new HashMap<String, Object>(props.size());
/////////////////////////////////////////////////////////////////////////
1:         LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
1:     private static void addFields(Object target, Class startClass, Class<Object> stopClass, LinkedHashMap<String, Object> map) {
/////////////////////////////////////////////////////////////////////////
1:             if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())
1:                 || Modifier.isPrivate(field.getModifiers())) {
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     public static boolean setProperties(Object target, Map<String, ?> props, String optionPrefix) {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     public static boolean getProperties(Object target, Map props, String optionPrefix) {
1:         if (target == null) {
1:         }
1:         if (props == null) {
1:         }
1:         if (optionPrefix == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     if (value == null) {
1:                     }
1:                     if (strValue == null) {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:     public static boolean setProperties(Object target, Map props, String optionPrefix) {
1:         if (target == null) {
1:         }
1:         if (props == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (props == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (target == null) {
1:         }
1:         if (props == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (setter == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (PropertyEditorManager.findEditor(clazz) != null) {
1:         }
0:         if (clazz == URI.class) {
1:         }
0:         if (clazz == Boolean.class) {
1:         }
1:     public static String toString(Object target) {
1:     public static String toString(Object target, Class stopClass) {
/////////////////////////////////////////////////////////////////////////
1:     public static String simpleName(Class clazz) {
/////////////////////////////////////////////////////////////////////////
0:     private static void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
1:         if (startClass != stopClass) {
1:         }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         if (target == null)
0:         if (props == null)
1: 
0:         if (optionPrefix == null)
1:             optionPrefix = "";
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (name.startsWith("get") && params.length == 0 && type != null && isSettableType(type)) {
1:                 try {
1: 
0:                     Object value = method.invoke(target, new Object[] {});
0:                     if (value == null)
1:                         continue;
1: 
1:                     String strValue = convertToString(value, type);
0:                     if (strValue == null)
1:                         continue;
1: 
0:                     name = name.substring(3, 4).toLowerCase() + name.substring(4);
1:                     props.put(optionPrefix + name, strValue);
1: 
0:                 } catch (Throwable ignore) {
1:                 }
1: 
1: 
1: 
0:         if (target == null)
0:         if (props == null)
1: 
1:             String name = (String)iter.next();
1:             if (name.startsWith(optionPrefix)) {
1:                 if (setProperty(target, name, value)) {
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (props == null)
1: 
0:             String name = (String)iter.next();
1:             if (name.startsWith(optionPrefix)) {
1: 
1: 
1:         boolean rc = false;
1: 
0:         if (target == null)
0:         if (props == null)
1: 
0:             Map.Entry entry = (Entry)iter.next();
1:             if (setProperty(target, (String)entry.getKey(), entry.getValue())) {
1:                 rc = true;
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (setter == null)
1: 
1:             // If the type is null or it matches the needed type, just use the
1:             // value directly
1:             if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
0:                 setter.invoke(target, new Object[] {value});
0:                 setter.invoke(target, new Object[] {convert(value, setter.getParameterTypes()[0])});
/////////////////////////////////////////////////////////////////////////
0:         if (editor != null) {
0:         if (type == URI.class) {
/////////////////////////////////////////////////////////////////////////
0:         if (editor != null) {
0:         if (type == URI.class) {
/////////////////////////////////////////////////////////////////////////
0:         name = "set" + name.substring(0, 1).toUpperCase() + name.substring(1);
0:             if (method.getName().equals(name) && params.length == 1 && isSettableType(params[0])) {
/////////////////////////////////////////////////////////////////////////
0:         if (PropertyEditorManager.findEditor(clazz) != null)
0:         if (clazz == URI.class)
0:         if (clazz == Boolean.class)
/////////////////////////////////////////////////////////////////////////
0:             Map.Entry entry = (Map.Entry)iter.next();
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQDestination destination = (ActiveMQDestination)value;
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:         if (p >= 0) {
1:             name = name.substring(p + 1);
1: 
0:         if (startClass != stopClass)
1:             addFields(target, startClass.getSuperclass(), stopClass, map);
1: 
0:             if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers()) || Modifier.isPrivate(field.getModifiers())) {
1: 
1:                 if (o != null && o.getClass().isArray()) {
1:                         o = Arrays.asList((Object[])o);
/////////////////////////////////////////////////////////////////////////
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:41265f2
/////////////////////////////////////////////////////////////////////////
1:     public static boolean setProperty(Object target, String name, Object value) {
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f0e135
/////////////////////////////////////////////////////////////////////////
1: 	
0:     static public boolean getProperties(Object target, Map props, String optionPrefix) {
1:     	
1:         boolean rc = false;
0:         if( target == null )
1:             throw new IllegalArgumentException("target was null.");
0:         if( props == null )
1:             throw new IllegalArgumentException("props was null.");
1:         
0:         if( optionPrefix == null )
0:         	optionPrefix="";
1:         
0:         Class clazz = target.getClass();
1:         Method[] methods = clazz.getMethods();
0:         for (int i = 0; i < methods.length; i++) {
0:             Method method = methods[i];
1:             String name = method.getName();
0:             Class type = method.getReturnType();
0:             Class params[] = method.getParameterTypes();
0:             if( name.startsWith("get") && params.length==0 && 
0:             		type!=null && isSettableType(type)) {
1: 
1:             	try {
1:             		
0:             		Object value = method.invoke(target, new Object[]{});
0:             		if( value == null )
1:             			continue;
1:             		
0:             		String strValue = convertToString(value, type);
0:             		if( strValue ==null )
1:             			continue;
1:             		
0:                     name = name.substring(3,4).toLowerCase()+name.substring(4);
0:                     props.put(optionPrefix+name, strValue);
1:                     rc = true;
1:                     
0:             	} catch ( Throwable ignore) {
1:             	}
1:             	
1:             }
1:         }
1:         
1:         return rc;
1:     }
1: 	
1: 	
1: 	
/////////////////////////////////////////////////////////////////////////
1:           
0:     public static boolean setProperties(Object target, Map props) {
1:     	boolean rc = false;
1:     	
/////////////////////////////////////////////////////////////////////////
0:                 rc=true;
1:         
1:         return rc;
/////////////////////////////////////////////////////////////////////////
0:     private static String convertToString(Object value, Class type) throws URISyntaxException {
0:         PropertyEditor editor = PropertyEditorManager.findEditor(type);
0:         if( editor != null ) { 
0:             editor.setValue(value);
0:             return editor.getAsText();
1:         }
0:         if( type == URI.class ) {
0:             return ((URI)value).toString();
1:         }
1:         return null;
1:     }
1: 
commit:013f372
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Modifier;
1: import java.util.Arrays;
1: import java.util.LinkedHashMap;
/////////////////////////////////////////////////////////////////////////
0:     static public String toString(Object target) {
0:         return toString(target, Object.class);
1:     }
1: 
0:     static public String toString(Object target, Class stopClass) {
0:         LinkedHashMap map = new LinkedHashMap();
1:         addFields(target, target.getClass(), stopClass, map);
0:         return simpleName(target.getClass())+" "+map;
1:     }
1: 
0:     static public String simpleName(Class clazz) {
1:         String name = clazz.getName();
1:         int p = name.lastIndexOf(".");
0:         if( p >= 0 ) {
0:             name = name.substring(p+1);
1:         }
1:         return name;
1:     }
1:     
1: 
0:     static private void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
1:         
0:         if( startClass!=stopClass ) 
0:             addFields( target, startClass.getSuperclass(), stopClass, map );
1:         
1:         Field[] fields = startClass.getDeclaredFields();
0:         for (int i = 0; i < fields.length; i++) {
0:             Field field = fields[i];
0:             if( Modifier.isStatic(field.getModifiers()) || 
0:                 Modifier.isTransient(field.getModifiers()) ||
0:                 Modifier.isPrivate(field.getModifiers())  ) {
0:                 continue;
1:             }
1:             
1:             try {
1:                 field.setAccessible(true);
1:                 Object o = field.get(target);
0:                 if( o!=null && o.getClass().isArray() ) {
1:                     try {
0:                         o = Arrays.asList((Object[]) o);
0:                     } catch (Throwable e) {
1:                     }
1:                 }
1:                 map.put(field.getName(), o);
0:             } catch (Throwable e) {
0:                 e.printStackTrace();
1:             }
1:         }
1:         
1:     }
1: 
commit:5be5a62
/////////////////////////////////////////////////////////////////////////
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0: * <a href="http://activemq.org">ActiveMQ: The Open Source Message Fabric</a>
0: *
0: * Copyright 2005 (C) LogicBlaze, Inc. http://www.logicblaze.com
0: *
0: * Licensed under the Apache License, Version 2.0 (the "License");
0: * you may not use this file except in compliance with the License.
0: * You may obtain a copy of the License at
0: *
0: * http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing, software
0: * distributed under the License is distributed on an "AS IS" BASIS,
0: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: * See the License for the specific language governing permissions and
0: * limitations under the License.
0: *
0: **/
1: package org.apache.activemq.util;
0: 
0: import java.beans.PropertyEditor;
0: import java.beans.PropertyEditorManager;
1: import java.lang.reflect.Method;
0: import java.net.URI;
0: import java.net.URISyntaxException;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.Map.Entry;
0: 
0: public class IntrospectionSupport {
0:         
0:     static public boolean setProperties(Object target, Map props, String optionPrefix) {
0:         boolean rc = false;
0:         if( target == null )
1:             throw new IllegalArgumentException("target was null.");
0:         if( props == null )
1:             throw new IllegalArgumentException("props was null.");
0:         
0:         for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
0:             String name = (String) iter.next();
0:             if( name.startsWith(optionPrefix) ) {
1:                 Object value = props.get(name);
1:                 name = name.substring(optionPrefix.length());
0:                 if( setProperty(target, name, value) ) {
1:                     iter.remove();
1:                     rc = true;
1:                 }
1:             }
1:         }
1:         return rc;
1:     }
0:     
0:     public static Map extractProperties(Map props, String optionPrefix) {
0:         if( props == null )
1:             throw new IllegalArgumentException("props was null.");
0: 
0:         HashMap rc = new HashMap(props.size());
0:         
0:         for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
0:             String name = (String) iter.next();
0:             if( name.startsWith(optionPrefix) ) {
1:                 Object value = props.get(name);
1:                 name = name.substring(optionPrefix.length());
1:                 rc.put(name, value);
1:                 iter.remove();
1:             }
1:         }
0:         
1:         return rc;
1:     }
0:     
0:     public static void setProperties(Object target, Map props) {
0:         if( target == null )
1:             throw new IllegalArgumentException("target was null.");
0:         if( props == null )
1:             throw new IllegalArgumentException("props was null.");
0:         
0:         for (Iterator iter = props.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Entry) iter.next();
0:             if( setProperty(target, (String) entry.getKey(), entry.getValue()) ) {
1:                 iter.remove();
1:             }
1:         }
1:     }
0: 
0:     private static boolean setProperty(Object target, String name, Object value) {
0:         try {
0:             Class clazz = target.getClass();
1:             Method setter = findSetterMethod(clazz, name);
0:             if( setter == null )
1:                 return false;
0:             
0:             // If the type is null or it matches the needed type, just use the value directly
0:             if( value == null || value.getClass()==setter.getParameterTypes()[0] ) {
0:                 setter.invoke(target, new Object[]{value});
1:             } else {
1:                 // We need to convert it
0:                 setter.invoke(target, new Object[]{ convert(value, setter.getParameterTypes()[0]) });
1:             }
1:             return true;
0:         } catch (Throwable ignore) {
1:             return false;
1:         }
1:     }
0: 
0:     private static Object convert(Object value, Class type) throws URISyntaxException {
0:         PropertyEditor editor = PropertyEditorManager.findEditor(type);
0:         if( editor != null ) { 
0:             editor.setAsText(value.toString());
0:             return editor.getValue();
1:         }
0:         if( type == URI.class ) {
0:             return new URI(value.toString());
1:         }
1:         return null;
1:     }
0: 
0:     private static Method findSetterMethod(Class clazz, String name) {
1:         // Build the method name.
0:         name = "set"+name.substring(0,1).toUpperCase()+name.substring(1);
1:         Method[] methods = clazz.getMethods();
0:         for (int i = 0; i < methods.length; i++) {
0:             Method method = methods[i];
0:             Class params[] = method.getParameterTypes();
0:             if( method.getName().equals(name) 
0:                     && params.length==1
0:                     && isSettableType(params[0])) {
1:                 return method;
1:             }
1:         }
1:         return null;
1:     }
0: 
0:     private static boolean isSettableType(Class clazz) {
0:         if( PropertyEditorManager.findEditor(clazz)!=null )
1:             return true;
0:         if( clazz == URI.class )
1:             return true;
1:         return false;
1:     }
0: 
0:     
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:f0b3f1c
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = target.getClass();
1:         for (Method method : methods) {
1:             Class<?> type = method.getReturnType();
1:             Class<?> params[] = method.getParameterTypes();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<?> iter = props.keySet().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<?> iter = props.entrySet().iterator(); iter.hasNext();) {
1:             Map.Entry<?,?> entry = (Entry<?,?>)iter.next();
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = target.getClass();
/////////////////////////////////////////////////////////////////////////
1:         for (Method method : methods) {
1:             Class<?> params[] = method.getParameterTypes();
/////////////////////////////////////////////////////////////////////////
0: 
1:         return toString(target, stopClass, null);
1:             for(String key : overrideFields.keySet()) {
1:                 Object value = overrideFields.get(key);
1:                 map.put(key, value);
1:             }
1:         Set<Entry<String, Object>> entrySet = map.entrySet();
1:         for (Map.Entry<String,Object> entry : entrySet) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:             buffer.append("*****");
/////////////////////////////////////////////////////////////////////////
1:         for (Field field : fields) {
/////////////////////////////////////////////////////////////////////////
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:1802116
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(IntrospectionSupport.class);
/////////////////////////////////////////////////////////////////////////
1:             if ((name.startsWith("is") || name.startsWith("get")) && params.length == 0 && type != null) {
/////////////////////////////////////////////////////////////////////////
1:     private static Object convert(Object value, Class to) {
1:         if (value == null) {
1:             // lets avoid NullPointerException when converting to boolean for null values
1:             if (boolean.class.isAssignableFrom(to)) {
1:                 return Boolean.FALSE;
1:             }
0:             return null;
1:         }
0: 
1:         // eager same instance type test to avoid the overhead of invoking the type converter
1:         // if already same type
1:         if (to.isAssignableFrom(value.getClass())) {
1:             return to.cast(value);
1:         }
0: 
1:         if (to.isAssignableFrom(String[].class)) {
1:         // special for String to List<ActiveMQDestination> as we do not want to use a PropertyEditor for that
1:         if (value.getClass().equals(String.class) && to.equals(List.class)) {
1:             Object answer = StringToListOfActiveMQDestinationConverter.convertToActiveMQDestination(value);
1:             if (answer != null) {
1:                 return answer;
1:             }
0: 
1:         TypeConversionSupport.Converter converter = TypeConversionSupport.lookupConverter(value.getClass(), to);
1:         if (converter != null) {
1:             return converter.convert(value);
1:         } else {
1:             throw new IllegalArgumentException("Cannot convert from " + value.getClass()
1:                     + " to " + to + " with value " + value);
1:         }
1:     public static String convertToString(Object value, Class to) {
1:         if (value == null) {
0:             return null;
1:         }
0: 
1:         // already a String
1:         if (value instanceof String) {
1:             return (String) value;
1:         }
0: 
1:         if (String[].class.isInstance(value)) {
1:         // special for String to List<ActiveMQDestination> as we do not want to use a PropertyEditor for that
1:         if (List.class.isInstance(value)) {
1:             // if the list is a ActiveMQDestination, then return a comma list
1:             String answer = StringToListOfActiveMQDestinationConverter.convertFromActiveMQDestination(value);
1:             if (answer != null) {
1:                 return answer;
1:             }
0: 
1:         TypeConversionSupport.Converter converter = TypeConversionSupport.lookupConverter(value.getClass(), String.class);
1:         if (converter != null) {
1:             return (String) converter.convert(value);
1:         } else {
1:             throw new IllegalArgumentException("Cannot convert from " + value.getClass()
1:                     + " to " + to + " with value " + value);
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Error getting field " + field + " on class " + startClass + ". This exception is ignored.", e);
commit:e85a8bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     Object value = method.invoke(target);
/////////////////////////////////////////////////////////////////////////
1:                 setter.invoke(target, value);
1:                 setter.invoke(target, convert(value, setter.getParameterTypes()[0]));
/////////////////////////////////////////////////////////////////////////
1:         // special for String[] as we do not want to use a PropertyEditor for that
0:         if (type.isAssignableFrom(String[].class)) {
1:             return StringArrayConverter.convertToStringArray(value);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:         // special for String[] as we do not want to use a PropertyEditor for that
0:         if (value != null && value.getClass().isAssignableFrom(String[].class)) {
1:             String[] array = (String[]) value;
1:             return StringArrayConverter.convertToString(array);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         // special for String[]
0:         if (clazz.isAssignableFrom(String[].class)) {
0:             return true;
0:         }
0: 
commit:b186513
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: import java.util.List;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:             List<String> list = new ArrayList<String>();
0:             list.addAll(Arrays.asList(PropertyEditorManager.getEditorSearchPath()));
0: 
0:             if (!list.contains(additionalPath[0])) {
0:                 list.add(additionalPath[0]);
0:             }
0:             if (!list.contains(additionalPath[1])) {
0:                 list.add(additionalPath[1]);
0:             }
0: 
0:             String[] newSearchPath = list.toArray(new String[list.size()]);
0:                 PropertyEditorManager.setEditorSearchPath(newSearchPath);
commit:4b44d31
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:                         name = name.substring(3, 4).toLowerCase(Locale.ENGLISH)
1:                         name = name.substring(2, 3).toLowerCase(Locale.ENGLISH)
/////////////////////////////////////////////////////////////////////////
1:         } else if (key.toString().toLowerCase(Locale.ENGLISH).contains("password")){
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:b4de4f5
/////////////////////////////////////////////////////////////////////////
0:         } else if (key.toString().toLowerCase().contains("password")){
commit:1466d6c
/////////////////////////////////////////////////////////////////////////
1:             Object value = entry.getValue();
1:             Object key = entry.getKey();
1:             buffer.append(key);
0:             
1:             appendToString(buffer, key, value);
1:     protected static void appendToString(StringBuffer buffer, Object key, Object value) {
0:         } else if (key.toString().contains("password")){
0:             buffer.append("*****");           
commit:a55efe9
/////////////////////////////////////////////////////////////////////////
0:             buffer.append(entry.getKey());
0:             appendToString(buffer, entry.getValue());
0:     protected static void appendToString(StringBuffer buffer, Object value) {
commit:0dc6e0c
/////////////////////////////////////////////////////////////////////////
0:             Object value = entry.getValue();
0:             Object key = entry.getKey();
0:             buffer.append(key);
0:             
0:             appendToString(buffer, key, value);
0:     protected static void appendToString(StringBuffer buffer, Object key, Object value) {
0:         } else if (key.toString().contains("password")){
0:             buffer.append("*****");           
commit:ff59a59
/////////////////////////////////////////////////////////////////////////
commit:8f80e34
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Array;
/////////////////////////////////////////////////////////////////////////
0: 
0: 		// Add Spring and ActiveMQ specific property editors
0: 		String[] additionalPath = new String[] {
0: 				"org.springframework.beans.propertyeditors",
0: 				"org.apache.activemq.util" };
0: 
0: 		String[] searchPath = (String[]) Array.newInstance(String.class,
0: 				PropertyEditorManager.getEditorSearchPath().length
0: 						+ additionalPath.length);
0: 		System.arraycopy(PropertyEditorManager.getEditorSearchPath(), 0,
0: 				searchPath, 0,
0: 				PropertyEditorManager.getEditorSearchPath().length);
0: 		System.arraycopy(additionalPath, 0, searchPath, PropertyEditorManager
0: 				.getEditorSearchPath().length, additionalPath.length);
commit:d185430
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.ArrayUtils;
0: 
0: 
0: 	
0: 	static {
0: 		// find Spring and ActiveMQ specific property editors
0: 		 String[] searchPath = (String[])ArrayUtils.addAll(
0: 				 PropertyEditorManager.getEditorSearchPath(), 
0: 				 new String[] {
0: 					"org.springframework.beans.propertyeditors"
0: 				  , "org.apache.activemq.util"
0: 				 }
0: 			);
0: 		PropertyEditorManager.setEditorSearchPath(searchPath);
0: 	}
/////////////////////////////////////////////////////////////////////////
0:     private static Object convert(Object value, Class type) {
0:     public static String convertToString(Object value, Class type) {
/////////////////////////////////////////////////////////////////////////
0:         	
commit:1f01c94
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
1:         return toString(target, Object.class, null);
0:     }
0:     
0:     public static String toString(Object target, Class stopClass) {
0:     	return toString(target, stopClass, null);
1:     public static String toString(Object target, Class stopClass, Map<String, Object> overrideFields) {
1:         if (overrideFields != null) {
0:         	for(String key : overrideFields.keySet()) {
0:         	    Object value = overrideFields.get(key);
0:         	    map.put(key, value);
0:         	}
0: 
0:         }
author:Robert Davies
-------------------------------------------------------------------------------
commit:8248314
/////////////////////////////////////////////////////////////////////////
0:             if ((name.startsWith("is") || name.startsWith("get")) && params.length == 0 && type != null && isSettableType(type)) {
/////////////////////////////////////////////////////////////////////////
1:                     if (name.startsWith("get")) {
0:                         name = name.substring(3, 4).toLowerCase()
1:                                 + name.substring(4);
1:                     } else {
0:                         name = name.substring(2, 3).toLowerCase()
1:                                 + name.substring(3);
0:                     }
author:James Strachan
-------------------------------------------------------------------------------
commit:fdb9c41
/////////////////////////////////////////////////////////////////////////
0:         if( clazz == Boolean.class )
0:             return true;
commit:9c0d3ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: 
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
1:         buffer.append(" {");
0:         Set entrySet = map.entrySet();
1:         boolean first = true;
0:         for (Iterator iter = entrySet.iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Map.Entry) iter.next();
1:             if (first) {
1:                 first = false;
0:             }
0:             else {
1:                 buffer.append(", ");
0:             }
0:             buffer.append(entry.getKey());
1:             buffer.append(" = ");
0:             appendToString(buffer, entry.getValue());
0:         }
1:         buffer.append("}");
1:         return buffer.toString();
0:     }
0: 
0:     protected static void appendToString(StringBuffer buffer, Object value) {
1:         if (value instanceof ActiveMQDestination) {
0:             ActiveMQDestination destination = (ActiveMQDestination) value;
1:             buffer.append(destination.getQualifiedName());
0:         }
0:         else {
1:             buffer.append(value);
0:         }
============================================================================