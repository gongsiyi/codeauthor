1:b7c2b67: /**
1:b7c2b67:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b7c2b67:  * contributor license agreements.  See the NOTICE file distributed with
1:b7c2b67:  * this work for additional information regarding copyright ownership.
1:b7c2b67:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b7c2b67:  * (the "License"); you may not use this file except in compliance with
1:b7c2b67:  * the License.  You may obtain a copy of the License at
1:b7c2b67:  *
1:b7c2b67:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b7c2b67:  *
1:b7c2b67:  * Unless required by applicable law or agreed to in writing, software
1:b7c2b67:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b7c2b67:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b7c2b67:  * See the License for the specific language governing permissions and
1:b7c2b67:  * limitations under the License.
1:b7c2b67:  */
1:b7c2b67: package org.apache.activemq.store.kahadb;
4:b7c2b67: 
1:b7c2b67: import java.io.DataInput;
1:b7c2b67: import java.io.DataOutput;
1:b7c2b67: import java.io.File;
1:b7c2b67: import java.io.IOException;
1:b7c2b67: import java.io.InputStream;
1:b7c2b67: import java.io.OutputStream;
1:b7c2b67: import java.util.ArrayList;
1:b7c2b67: import java.util.HashMap;
1:b7c2b67: import java.util.HashSet;
1:b7c2b67: import java.util.Iterator;
1:b7c2b67: import java.util.LinkedHashMap;
1:b7c2b67: import java.util.TreeMap;
1:b7c2b67: import java.util.Map.Entry;
1:b7c2b67: import java.util.concurrent.atomic.AtomicBoolean;
1:b7c2b67: 
1:b7c2b67: import org.apache.activemq.command.SubscriptionInfo;
1:b7c2b67: import org.apache.activemq.command.TransactionId;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaDestination;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
1:b7c2b67: import org.apache.activemq.util.ByteSequence;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:b7c2b67: 
1:b7c2b67: public class TempMessageDatabase {
1:b7c2b67: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TempMessageDatabase.class);
1:b7c2b67: 
1:b7c2b67:     public static final int CLOSED_STATE = 1;
1:b7c2b67:     public static final int OPEN_STATE = 2;
1:b7c2b67: 
1:b7c2b67:     protected BTreeIndex<String, StoredDestination> destinations;
1:b7c2b67:     protected PageFile pageFile;
1:b7c2b67: 
1:b7c2b67:     protected File directory;
1:b7c2b67:     
1:b7c2b67:     boolean enableIndexWriteAsync = true;
1:b7c2b67:     int setIndexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE; 
1:b7c2b67:     
1:b7c2b67:     protected AtomicBoolean started = new AtomicBoolean();
1:b7c2b67:     protected AtomicBoolean opened = new AtomicBoolean();
1:b7c2b67: 
1:b7c2b67:     public TempMessageDatabase() {
4:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void start() throws Exception {
1:b7c2b67:         if (started.compareAndSet(false, true)) {
1:b7c2b67:         	load();
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void stop() throws Exception {
1:b7c2b67:         if (started.compareAndSet(true, false)) {
1:b7c2b67:             unload();
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67: 	private void loadPageFile() throws IOException {
1:b7c2b67: 		synchronized (indexMutex) {
1:b7c2b67: 		    final PageFile pageFile = getPageFile();
1:b7c2b67:             pageFile.load();
1:b7c2b67:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                 public void execute(Transaction tx) throws IOException {
1:b7c2b67:                     destinations = new BTreeIndex<String, StoredDestination>(pageFile, tx.allocate().getPageId());
1:b7c2b67:                     destinations.setKeyMarshaller(StringMarshaller.INSTANCE);
1:b7c2b67:                     destinations.setValueMarshaller(new StoredDestinationMarshaller());
1:b7c2b67:                     destinations.load(tx);
1:b7c2b67:                 }
1:b7c2b67:             });
1:b7c2b67:             pageFile.flush();
1:b7c2b67:             storedDestinations.clear();
1:b7c2b67:         }
1:b7c2b67: 	}
1:b7c2b67: 	
1:b7c2b67: 	/**
1:b7c2b67: 	 * @throws IOException
1:b7c2b67: 	 */
1:b7c2b67: 	public void open() throws IOException {
1:b7c2b67: 		if( opened.compareAndSet(false, true) ) {
1:b7c2b67: 	        loadPageFile();
1:b7c2b67: 		}
1:b7c2b67: 	}
1:b7c2b67: 	
1:b7c2b67:     public void load() throws IOException {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67: 	    	open();
1:b7c2b67:             pageFile.unload();
1:b7c2b67:             pageFile.delete();
1:b7c2b67:             loadPageFile();
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     
1:b7c2b67: 	public void close() throws IOException, InterruptedException {
1:b7c2b67: 		if( opened.compareAndSet(true, false)) {
1:b7c2b67: 	        synchronized (indexMutex) {
1:b7c2b67: 	            pageFile.unload();
1:b7c2b67: 	        }
1:b7c2b67: 		}
1:b7c2b67: 	}
1:b7c2b67: 	
1:b7c2b67:     public void unload() throws IOException, InterruptedException {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             if( pageFile.isLoaded() ) {
1:b7c2b67:                 close();
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void processAdd(final KahaAddMessageCommand command, TransactionId txid, final ByteSequence data) throws IOException {
1:b7c2b67:         if (txid!=null) {
1:b7c2b67:             synchronized (indexMutex) {
1:b7c2b67:                 ArrayList<Operation> inflightTx = getInflightTx(txid);
1:b7c2b67:                 inflightTx.add(new AddOpperation(command, data));
1:b7c2b67:             }
1:b7c2b67:         } else {
1:b7c2b67:             synchronized (indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                     public void execute(Transaction tx) throws IOException {
1:b7c2b67:                         upadateIndex(tx, command, data);
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void processRemove(final KahaRemoveMessageCommand command, TransactionId txid) throws IOException {
1:b7c2b67:         if (txid!=null) {
1:b7c2b67:             synchronized (indexMutex) {
1:b7c2b67:                 ArrayList<Operation> inflightTx = getInflightTx(txid);
1:b7c2b67:                 inflightTx.add(new RemoveOpperation(command));
1:b7c2b67:             }
1:b7c2b67:         } else {
1:b7c2b67:             synchronized (indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                     public void execute(Transaction tx) throws IOException {
1:b7c2b67:                         updateIndex(tx, command);
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void process(final KahaRemoveDestinationCommand command) throws IOException {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                 public void execute(Transaction tx) throws IOException {
1:b7c2b67:                     updateIndex(tx, command);
1:b7c2b67:                 }
1:b7c2b67:             });
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void process(final KahaSubscriptionCommand command) throws IOException {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                 public void execute(Transaction tx) throws IOException {
1:b7c2b67:                     updateIndex(tx, command);
1:b7c2b67:                 }
1:b7c2b67:             });
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void processCommit(TransactionId key) throws IOException {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             ArrayList<Operation> inflightTx = inflightTransactions.remove(key);
1:b7c2b67:             if (inflightTx == null) {
1:b7c2b67:                 inflightTx = preparedTransactions.remove(key);
1:b7c2b67:             }
1:b7c2b67:             if (inflightTx == null) {
1:b7c2b67:                 return;
1:b7c2b67:             }
1:b7c2b67: 
1:b7c2b67:             final ArrayList<Operation> messagingTx = inflightTx;
1:b7c2b67:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:b7c2b67:                 public void execute(Transaction tx) throws IOException {
1:b7c2b67:                     for (Operation op : messagingTx) {
1:b7c2b67:                         op.execute(tx);
1:b7c2b67:                     }
1:b7c2b67:                 }
1:b7c2b67:             });
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void processPrepare(TransactionId key) {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             ArrayList<Operation> tx = inflightTransactions.remove(key);
1:b7c2b67:             if (tx != null) {
1:b7c2b67:                 preparedTransactions.put(key, tx);
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void processRollback(TransactionId key) {
1:b7c2b67:         synchronized (indexMutex) {
1:b7c2b67:             ArrayList<Operation> tx = inflightTransactions.remove(key);
1:b7c2b67:             if (tx == null) {
1:b7c2b67:                 preparedTransactions.remove(key);
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67:     // These methods do the actual index updates.
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67: 
1:b7c2b67:     protected final Object indexMutex = new Object();
1:b7c2b67: 	private final HashSet<Integer> journalFilesBeingReplicated = new HashSet<Integer>();
1:b7c2b67: 
1:b7c2b67:     private void upadateIndex(Transaction tx, KahaAddMessageCommand command, ByteSequence data) throws IOException {
1:b7c2b67:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:b7c2b67: 
1:b7c2b67:         // Skip adding the message to the index if this is a topic and there are
1:b7c2b67:         // no subscriptions.
1:b7c2b67:         if (sd.subscriptions != null && sd.ackPositions.isEmpty()) {
1:b7c2b67:             return;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         // Add the message.
1:b7c2b67:         long id = sd.nextMessageId++;
1:b7c2b67:         Long previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);
1:b7c2b67:         if( previous == null ) {
1:b7c2b67:             sd.orderIndex.put(tx, id, new MessageRecord(command.getMessageId(), data));
1:b7c2b67:         } else {
1:b7c2b67:             // restore the previous value.. Looks like this was a redo of a previously
1:b7c2b67:             // added message.  We don't want to assing it a new id as the other indexes would 
1:b7c2b67:             // be wrong..
1:b7c2b67:             sd.messageIdIndex.put(tx, command.getMessageId(), previous);
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     private void updateIndex(Transaction tx, KahaRemoveMessageCommand command) throws IOException {
1:b7c2b67:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:b7c2b67:         if (!command.hasSubscriptionKey()) {
1:b7c2b67:             
1:b7c2b67:             // In the queue case we just remove the message from the index..
1:b7c2b67:             Long sequenceId = sd.messageIdIndex.remove(tx, command.getMessageId());
1:b7c2b67:             if (sequenceId != null) {
1:b7c2b67:                 sd.orderIndex.remove(tx, sequenceId);
1:b7c2b67:             }
1:b7c2b67:         } else {
1:b7c2b67:             // In the topic case we need remove the message once it's been acked
1:b7c2b67:             // by all the subs
1:b7c2b67:             Long sequence = sd.messageIdIndex.get(tx, command.getMessageId());
1:b7c2b67: 
1:b7c2b67:             // Make sure it's a valid message id...
1:b7c2b67:             if (sequence != null) {
1:b7c2b67:                 String subscriptionKey = command.getSubscriptionKey();
1:b7c2b67:                 Long prev = sd.subscriptionAcks.put(tx, subscriptionKey, sequence);
1:b7c2b67: 
1:b7c2b67:                 // The following method handles deleting un-referenced messages.
1:b7c2b67:                 removeAckByteSequence(tx, sd, subscriptionKey, prev);
1:b7c2b67: 
1:b7c2b67:                 // Add it to the new location set.
1:b7c2b67:                 addAckByteSequence(sd, sequence, subscriptionKey);
1:b7c2b67:             }
1:b7c2b67: 
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     private void updateIndex(Transaction tx, KahaRemoveDestinationCommand command) throws IOException {
1:b7c2b67:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:b7c2b67:         sd.orderIndex.clear(tx);
1:b7c2b67:         sd.orderIndex.unload(tx);
1:b7c2b67:         tx.free(sd.orderIndex.getPageId());
1:b7c2b67:         
1:b7c2b67:         sd.messageIdIndex.clear(tx);
1:b7c2b67:         sd.messageIdIndex.unload(tx);
1:b7c2b67:         tx.free(sd.messageIdIndex.getPageId());
1:b7c2b67: 
1:b7c2b67:         if (sd.subscriptions != null) {
1:b7c2b67:             sd.subscriptions.clear(tx);
1:b7c2b67:             sd.subscriptions.unload(tx);
1:b7c2b67:             tx.free(sd.subscriptions.getPageId());
1:b7c2b67: 
1:b7c2b67:             sd.subscriptionAcks.clear(tx);
1:b7c2b67:             sd.subscriptionAcks.unload(tx);
1:b7c2b67:             tx.free(sd.subscriptionAcks.getPageId());
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         String key = key(command.getDestination());
1:b7c2b67:         storedDestinations.remove(key);
1:b7c2b67:         destinations.remove(tx, key);
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     private void updateIndex(Transaction tx, KahaSubscriptionCommand command) throws IOException {
1:b7c2b67:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:b7c2b67: 
1:b7c2b67:         // If set then we are creating it.. otherwise we are destroying the sub
1:b7c2b67:         if (command.hasSubscriptionInfo()) {
1:b7c2b67:             String subscriptionKey = command.getSubscriptionKey();
1:b7c2b67:             sd.subscriptions.put(tx, subscriptionKey, command);
1:b7c2b67:             long ackByteSequence=-1;
1:b7c2b67:             if (!command.getRetroactive()) {
1:b7c2b67:                 ackByteSequence = sd.nextMessageId-1;
1:b7c2b67:             }
1:b7c2b67: 
1:b7c2b67:             sd.subscriptionAcks.put(tx, subscriptionKey, ackByteSequence);
1:b7c2b67:             addAckByteSequence(sd, ackByteSequence, subscriptionKey);
1:b7c2b67:         } else {
1:b7c2b67:             // delete the sub...
1:b7c2b67:             String subscriptionKey = command.getSubscriptionKey();
1:b7c2b67:             sd.subscriptions.remove(tx, subscriptionKey);
1:b7c2b67:             Long prev = sd.subscriptionAcks.remove(tx, subscriptionKey);
1:b7c2b67:             if( prev!=null ) {
1:b7c2b67:                 removeAckByteSequence(tx, sd, subscriptionKey, prev);
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     public HashSet<Integer> getJournalFilesBeingReplicated() {
1:b7c2b67: 		return journalFilesBeingReplicated;
1:b7c2b67: 	}
1:b7c2b67: 
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67:     // StoredDestination related implementation methods.
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67: 
1:b7c2b67: 
1:b7c2b67: 	private final HashMap<String, StoredDestination> storedDestinations = new HashMap<String, StoredDestination>();
1:b7c2b67: 
1:b7c2b67:     class StoredSubscription {
1:b7c2b67:         SubscriptionInfo subscriptionInfo;
1:b7c2b67:         String lastAckId;
1:b7c2b67:         ByteSequence lastAckByteSequence;
1:b7c2b67:         ByteSequence cursor;
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     static class MessageRecord {
1:b7c2b67:         final String messageId;
1:b7c2b67:         final ByteSequence data;
1:b7c2b67:         
1:b7c2b67:         public MessageRecord(String messageId, ByteSequence location) {
1:b7c2b67:             this.messageId=messageId;
1:b7c2b67:             this.data=location;
1:b7c2b67:         }
1:b7c2b67:         
1:b7c2b67:         @Override
1:b7c2b67:         public String toString() {
1:b7c2b67:             return "["+messageId+","+data+"]";
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67:     
1:e22a37a:     static protected class MessageKeysMarshaller extends VariableMarshaller<MessageRecord> {
1:b7c2b67:         static final MessageKeysMarshaller INSTANCE = new MessageKeysMarshaller();
1:b7c2b67:         
1:b7c2b67:         public MessageRecord readPayload(DataInput dataIn) throws IOException {
1:b7c2b67:             return new MessageRecord(dataIn.readUTF(), ByteSequenceMarshaller.INSTANCE.readPayload(dataIn));
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void writePayload(MessageRecord object, DataOutput dataOut) throws IOException {
1:b7c2b67:             dataOut.writeUTF(object.messageId);
1:b7c2b67:             ByteSequenceMarshaller.INSTANCE.writePayload(object.data, dataOut);
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     static class StoredDestination {
1:b7c2b67:         long nextMessageId;
1:b7c2b67:         BTreeIndex<Long, MessageRecord> orderIndex;
1:b7c2b67:         BTreeIndex<String, Long> messageIdIndex;
1:b7c2b67: 
1:b7c2b67:         // These bits are only set for Topics
1:b7c2b67:         BTreeIndex<String, KahaSubscriptionCommand> subscriptions;
1:b7c2b67:         BTreeIndex<String, Long> subscriptionAcks;
1:b7c2b67:         HashMap<String, Long> subscriptionCursors;
1:b7c2b67:         TreeMap<Long, HashSet<String>> ackPositions;
1:b7c2b67:     }
1:b7c2b67: 
1:e22a37a:     protected class StoredDestinationMarshaller extends VariableMarshaller<StoredDestination> {
1:b7c2b67:         public Class<StoredDestination> getType() {
1:b7c2b67:             return StoredDestination.class;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public StoredDestination readPayload(DataInput dataIn) throws IOException {
1:b7c2b67:             StoredDestination value = new StoredDestination();
1:b7c2b67:             value.orderIndex = new BTreeIndex<Long, MessageRecord>(pageFile, dataIn.readLong());
1:b7c2b67:             value.messageIdIndex = new BTreeIndex<String, Long>(pageFile, dataIn.readLong());
1:b7c2b67: 
1:b7c2b67:             if (dataIn.readBoolean()) {
1:b7c2b67:                 value.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, dataIn.readLong());
1:b7c2b67:                 value.subscriptionAcks = new BTreeIndex<String, Long>(pageFile, dataIn.readLong());
1:b7c2b67:             }
1:b7c2b67:             return value;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void writePayload(StoredDestination value, DataOutput dataOut) throws IOException {
1:b7c2b67:             dataOut.writeLong(value.orderIndex.getPageId());
1:b7c2b67:             dataOut.writeLong(value.messageIdIndex.getPageId());
1:b7c2b67:             if (value.subscriptions != null) {
1:b7c2b67:                 dataOut.writeBoolean(true);
1:b7c2b67:                 dataOut.writeLong(value.subscriptions.getPageId());
1:b7c2b67:                 dataOut.writeLong(value.subscriptionAcks.getPageId());
1:b7c2b67:             } else {
1:b7c2b67:                 dataOut.writeBoolean(false);
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:e22a37a:     static class ByteSequenceMarshaller extends VariableMarshaller<ByteSequence> {
1:b7c2b67:         final static ByteSequenceMarshaller INSTANCE = new ByteSequenceMarshaller();
1:b7c2b67: 
1:b7c2b67:         public ByteSequence readPayload(DataInput dataIn) throws IOException {
1:b7c2b67:         	byte data[] = new byte[dataIn.readInt()];
1:b7c2b67:         	dataIn.readFully(data);
1:b7c2b67:             return new ByteSequence(data);
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void writePayload(ByteSequence object, DataOutput dataOut) throws IOException {
1:b7c2b67:             dataOut.writeInt(object.getLength());
1:b7c2b67:             dataOut.write(object.getData(), object.getOffset(), object.getLength());
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:e22a37a:     static class KahaSubscriptionCommandMarshaller extends VariableMarshaller<KahaSubscriptionCommand> {
1:b7c2b67:         final static KahaSubscriptionCommandMarshaller INSTANCE = new KahaSubscriptionCommandMarshaller();
1:b7c2b67: 
1:b7c2b67:         public KahaSubscriptionCommand readPayload(DataInput dataIn) throws IOException {
1:b7c2b67:             KahaSubscriptionCommand rc = new KahaSubscriptionCommand();
1:b7c2b67:             rc.mergeFramed((InputStream)dataIn);
1:b7c2b67:             return rc;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void writePayload(KahaSubscriptionCommand object, DataOutput dataOut) throws IOException {
1:b7c2b67:             object.writeFramed((OutputStream)dataOut);
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     protected StoredDestination getStoredDestination(KahaDestination destination, Transaction tx) throws IOException {
1:b7c2b67:         String key = key(destination);
1:b7c2b67:         StoredDestination rc = storedDestinations.get(key);
1:b7c2b67:         if (rc == null) {
1:b7c2b67:             boolean topic = destination.getType() == KahaDestination.DestinationType.TOPIC || destination.getType() == KahaDestination.DestinationType.TEMP_TOPIC;
1:b7c2b67:             rc = loadStoredDestination(tx, key, topic);
1:b7c2b67:             // Cache it. We may want to remove/unload destinations from the
1:b7c2b67:             // cache that are not used for a while
1:b7c2b67:             // to reduce memory usage.
1:b7c2b67:             storedDestinations.put(key, rc);
1:b7c2b67:         }
1:b7c2b67:         return rc;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     /**
1:b7c2b67:      * @param tx
1:b7c2b67:      * @param key
1:b7c2b67:      * @param topic
1:b7c2b67:      * @return
1:b7c2b67:      * @throws IOException
1:b7c2b67:      */
1:b7c2b67:     private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {
1:b7c2b67:         // Try to load the existing indexes..
1:b7c2b67:         StoredDestination rc = destinations.get(tx, key);
1:b7c2b67:         if (rc == null) {
1:b7c2b67:             // Brand new destination.. allocate indexes for it.
1:b7c2b67:             rc = new StoredDestination();
1:b7c2b67:             rc.orderIndex = new BTreeIndex<Long, MessageRecord>(pageFile, tx.allocate());
1:b7c2b67:             rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());
1:b7c2b67: 
1:b7c2b67:             if (topic) {
1:b7c2b67:                 rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());
1:b7c2b67:                 rc.subscriptionAcks = new BTreeIndex<String, Long>(pageFile, tx.allocate());
1:b7c2b67:             }
1:b7c2b67:             destinations.put(tx, key, rc);
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         // Configure the marshalers and load.
1:b7c2b67:         rc.orderIndex.setKeyMarshaller(LongMarshaller.INSTANCE);
1:b7c2b67:         rc.orderIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);
1:b7c2b67:         rc.orderIndex.load(tx);
1:b7c2b67: 
1:b7c2b67:         // Figure out the next key using the last entry in the destination.
1:b7c2b67:         Entry<Long, MessageRecord> lastEntry = rc.orderIndex.getLast(tx);
1:b7c2b67:         if( lastEntry!=null ) {
1:b7c2b67:             rc.nextMessageId = lastEntry.getKey()+1;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:b7c2b67:         rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);
1:b7c2b67:         rc.messageIdIndex.load(tx);
1:b7c2b67:         
1:b7c2b67:         // If it was a topic...
1:b7c2b67:         if (topic) {
1:b7c2b67: 
1:b7c2b67:             rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);
1:b7c2b67:             rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);
1:b7c2b67:             rc.subscriptions.load(tx);
1:b7c2b67: 
1:b7c2b67:             rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);
1:b7c2b67:             rc.subscriptionAcks.setValueMarshaller(LongMarshaller.INSTANCE);
1:b7c2b67:             rc.subscriptionAcks.load(tx);
1:b7c2b67: 
1:b7c2b67:             rc.ackPositions = new TreeMap<Long, HashSet<String>>();
1:b7c2b67:             rc.subscriptionCursors = new HashMap<String, Long>();
1:b7c2b67: 
1:b7c2b67:             for (Iterator<Entry<String, Long>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {
1:b7c2b67:                 Entry<String, Long> entry = iterator.next();
1:b7c2b67:                 addAckByteSequence(rc, entry.getValue(), entry.getKey());
1:b7c2b67:             }
1:b7c2b67: 
1:b7c2b67:         }
1:b7c2b67:         return rc;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     /**
1:b7c2b67:      * @param sd
1:b7c2b67:      * @param messageSequence
1:b7c2b67:      * @param subscriptionKey
1:b7c2b67:      */
1:b7c2b67:     private void addAckByteSequence(StoredDestination sd, Long messageSequence, String subscriptionKey) {
1:b7c2b67:         HashSet<String> hs = sd.ackPositions.get(messageSequence);
1:b7c2b67:         if (hs == null) {
1:b7c2b67:             hs = new HashSet<String>();
1:b7c2b67:             sd.ackPositions.put(messageSequence, hs);
1:b7c2b67:         }
1:b7c2b67:         hs.add(subscriptionKey);
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     /**
1:b7c2b67:      * @param tx
1:b7c2b67:      * @param sd
1:b7c2b67:      * @param subscriptionKey
1:b7c2b67:      * @param sequenceId
1:b7c2b67:      * @throws IOException
1:b7c2b67:      */
1:b7c2b67:     private void removeAckByteSequence(Transaction tx, StoredDestination sd, String subscriptionKey, Long sequenceId) throws IOException {
1:b7c2b67:         // Remove the sub from the previous location set..
1:b7c2b67:         if (sequenceId != null) {
1:b7c2b67:             HashSet<String> hs = sd.ackPositions.get(sequenceId);
1:b7c2b67:             if (hs != null) {
1:b7c2b67:                 hs.remove(subscriptionKey);
1:b7c2b67:                 if (hs.isEmpty()) {
1:b7c2b67:                     HashSet<String> firstSet = sd.ackPositions.values().iterator().next();
1:b7c2b67:                     sd.ackPositions.remove(sequenceId);
1:b7c2b67: 
1:b7c2b67:                     // Did we just empty out the first set in the
1:b7c2b67:                     // ordered list of ack locations? Then it's time to
1:b7c2b67:                     // delete some messages.
1:b7c2b67:                     if (hs == firstSet) {
1:b7c2b67: 
1:b7c2b67:                         // Find all the entries that need to get deleted.
1:b7c2b67:                         ArrayList<Entry<Long, MessageRecord>> deletes = new ArrayList<Entry<Long, MessageRecord>>();
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext();) {
1:b7c2b67:                             Entry<Long, MessageRecord> entry = iterator.next();
1:b7c2b67:                             if (entry.getKey().compareTo(sequenceId) <= 0) {
1:b7c2b67:                                 // We don't do the actually delete while we are
1:b7c2b67:                                 // iterating the BTree since
1:b7c2b67:                                 // iterating would fail.
1:b7c2b67:                                 deletes.add(entry);
1:b7c2b67:                             }
1:b7c2b67:                         }
1:b7c2b67: 
1:b7c2b67:                         // Do the actual deletes.
1:b7c2b67:                         for (Entry<Long, MessageRecord> entry : deletes) {
1:b7c2b67:                             sd.messageIdIndex.remove(tx,entry.getValue().messageId);
1:b7c2b67:                             sd.orderIndex.remove(tx,entry.getKey());
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 }
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     private String key(KahaDestination destination) {
1:b7c2b67:         return destination.getType().getNumber() + ":" + destination.getName();
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67:     // Transaction related implementation methods.
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67:     protected final LinkedHashMap<TransactionId, ArrayList<Operation>> inflightTransactions = new LinkedHashMap<TransactionId, ArrayList<Operation>>();
1:b7c2b67:     protected final LinkedHashMap<TransactionId, ArrayList<Operation>> preparedTransactions = new LinkedHashMap<TransactionId, ArrayList<Operation>>();
1:b7c2b67:  
1:b7c2b67:     private ArrayList<Operation> getInflightTx(TransactionId key) {
1:b7c2b67:         ArrayList<Operation> tx = inflightTransactions.get(key);
1:b7c2b67:         if (tx == null) {
1:b7c2b67:             tx = new ArrayList<Operation>();
1:b7c2b67:             inflightTransactions.put(key, tx);
1:b7c2b67:         }
1:b7c2b67:         return tx;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     abstract class Operation {
1:b7c2b67:         abstract public void execute(Transaction tx) throws IOException;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     class AddOpperation extends Operation {
1:b7c2b67:         final KahaAddMessageCommand command;
1:b7c2b67: 		private final ByteSequence data;
1:b7c2b67: 
1:b7c2b67:         public AddOpperation(KahaAddMessageCommand command, ByteSequence location) {
1:b7c2b67:             this.command = command;
1:b7c2b67: 			this.data = location;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void execute(Transaction tx) throws IOException {
1:b7c2b67:             upadateIndex(tx, command, data);
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public KahaAddMessageCommand getCommand() {
1:b7c2b67:             return command;
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     class RemoveOpperation extends Operation {
1:b7c2b67:         final KahaRemoveMessageCommand command;
1:b7c2b67: 
1:b7c2b67:         public RemoveOpperation(KahaRemoveMessageCommand command) {
1:b7c2b67:             this.command = command;
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public void execute(Transaction tx) throws IOException {
1:b7c2b67:             updateIndex(tx, command);
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         public KahaRemoveMessageCommand getCommand() {
1:b7c2b67:             return command;
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67:     // Initialization related implementation methods.
1:b7c2b67:     // /////////////////////////////////////////////////////////////////
1:b7c2b67: 
1:b7c2b67:     private PageFile createPageFile() {
1:b7c2b67:         PageFile index = new PageFile(directory, "temp-db");
1:b7c2b67:         index.setEnableWriteThread(isEnableIndexWriteAsync());
1:b7c2b67:         index.setWriteBatchSize(getIndexWriteBatchSize());
1:b7c2b67:         index.setEnableDiskSyncs(false);
1:b7c2b67:         index.setEnableRecoveryFile(false);
1:b7c2b67:         return index;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public File getDirectory() {
1:b7c2b67:         return directory;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public void setDirectory(File directory) {
1:b7c2b67:         this.directory = directory;
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     public void setIndexWriteBatchSize(int setIndexWriteBatchSize) {
1:b7c2b67:         this.setIndexWriteBatchSize = setIndexWriteBatchSize;
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     public int getIndexWriteBatchSize() {
1:b7c2b67:         return setIndexWriteBatchSize;
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     public void setEnableIndexWriteAsync(boolean enableIndexWriteAsync) {
1:b7c2b67:         this.enableIndexWriteAsync = enableIndexWriteAsync;
1:b7c2b67:     }
1:b7c2b67:     
1:b7c2b67:     boolean isEnableIndexWriteAsync() {
1:b7c2b67:         return enableIndexWriteAsync;
1:b7c2b67:     }
1:b7c2b67:         
1:b7c2b67:     public PageFile getPageFile() {
1:b7c2b67:         if (pageFile == null) {
1:b7c2b67:             pageFile = createPageFile();
1:b7c2b67:         }
1:b7c2b67: 		return pageFile;
1:b7c2b67: 	}
1:b7c2b67: 
1:b7c2b67: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:e22a37a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.VariableMarshaller;
/////////////////////////////////////////////////////////////////////////
1:     static protected class MessageKeysMarshaller extends VariableMarshaller<MessageRecord> {
/////////////////////////////////////////////////////////////////////////
1:     protected class StoredDestinationMarshaller extends VariableMarshaller<StoredDestination> {
/////////////////////////////////////////////////////////////////////////
1:     static class ByteSequenceMarshaller extends VariableMarshaller<ByteSequence> {
/////////////////////////////////////////////////////////////////////////
1:     static class KahaSubscriptionCommandMarshaller extends VariableMarshaller<KahaSubscriptionCommand> {
commit:b7c2b67
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.TreeMap;
1: import java.util.Map.Entry;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
1: import org.apache.activemq.store.kahadb.data.KahaDestination;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
1: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
1: import org.apache.activemq.util.ByteSequence;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.index.BTreeIndex;
0: import org.apache.kahadb.page.PageFile;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.LongMarshaller;
0: import org.apache.kahadb.util.Marshaller;
0: import org.apache.kahadb.util.StringMarshaller;
1: 
1: public class TempMessageDatabase {
1: 
0:     private static final Log LOG = LogFactory.getLog(TempMessageDatabase.class);
1: 
1:     public static final int CLOSED_STATE = 1;
1:     public static final int OPEN_STATE = 2;
1: 
1:     protected BTreeIndex<String, StoredDestination> destinations;
1:     protected PageFile pageFile;
1: 
1:     protected File directory;
1:     
1:     boolean enableIndexWriteAsync = true;
1:     int setIndexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE; 
1:     
1:     protected AtomicBoolean started = new AtomicBoolean();
1:     protected AtomicBoolean opened = new AtomicBoolean();
1: 
1:     public TempMessageDatabase() {
1:     }
1: 
1:     public void start() throws Exception {
1:         if (started.compareAndSet(false, true)) {
1:         	load();
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
1:         if (started.compareAndSet(true, false)) {
1:             unload();
1:         }
1:     }
1: 
1: 	private void loadPageFile() throws IOException {
1: 		synchronized (indexMutex) {
1: 		    final PageFile pageFile = getPageFile();
1:             pageFile.load();
1:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     destinations = new BTreeIndex<String, StoredDestination>(pageFile, tx.allocate().getPageId());
1:                     destinations.setKeyMarshaller(StringMarshaller.INSTANCE);
1:                     destinations.setValueMarshaller(new StoredDestinationMarshaller());
1:                     destinations.load(tx);
1:                 }
1:             });
1:             pageFile.flush();
1:             storedDestinations.clear();
1:         }
1: 	}
1: 	
1: 	/**
1: 	 * @throws IOException
1: 	 */
1: 	public void open() throws IOException {
1: 		if( opened.compareAndSet(false, true) ) {
1: 	        loadPageFile();
1: 		}
1: 	}
1: 	
1:     public void load() throws IOException {
1:         synchronized (indexMutex) {
1: 	    	open();
1:             pageFile.unload();
1:             pageFile.delete();
1:             loadPageFile();
1:         }
1:     }
1: 
1:     
1: 	public void close() throws IOException, InterruptedException {
1: 		if( opened.compareAndSet(true, false)) {
1: 	        synchronized (indexMutex) {
1: 	            pageFile.unload();
1: 	        }
1: 		}
1: 	}
1: 	
1:     public void unload() throws IOException, InterruptedException {
1:         synchronized (indexMutex) {
1:             if( pageFile.isLoaded() ) {
1:                 close();
1:             }
1:         }
1:     }
1: 
1:     public void processAdd(final KahaAddMessageCommand command, TransactionId txid, final ByteSequence data) throws IOException {
1:         if (txid!=null) {
1:             synchronized (indexMutex) {
1:                 ArrayList<Operation> inflightTx = getInflightTx(txid);
1:                 inflightTx.add(new AddOpperation(command, data));
1:             }
1:         } else {
1:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                     public void execute(Transaction tx) throws IOException {
1:                         upadateIndex(tx, command, data);
1:                     }
1:                 });
1:             }
1:         }
1:     }
1: 
1:     public void processRemove(final KahaRemoveMessageCommand command, TransactionId txid) throws IOException {
1:         if (txid!=null) {
1:             synchronized (indexMutex) {
1:                 ArrayList<Operation> inflightTx = getInflightTx(txid);
1:                 inflightTx.add(new RemoveOpperation(command));
1:             }
1:         } else {
1:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                     public void execute(Transaction tx) throws IOException {
1:                         updateIndex(tx, command);
1:                     }
1:                 });
1:             }
1:         }
1: 
1:     }
1: 
1:     public void process(final KahaRemoveDestinationCommand command) throws IOException {
1:         synchronized (indexMutex) {
1:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     updateIndex(tx, command);
1:                 }
1:             });
1:         }
1:     }
1: 
1:     public void process(final KahaSubscriptionCommand command) throws IOException {
1:         synchronized (indexMutex) {
1:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     updateIndex(tx, command);
1:                 }
1:             });
1:         }
1:     }
1: 
1:     public void processCommit(TransactionId key) throws IOException {
1:         synchronized (indexMutex) {
1:             ArrayList<Operation> inflightTx = inflightTransactions.remove(key);
1:             if (inflightTx == null) {
1:                 inflightTx = preparedTransactions.remove(key);
1:             }
1:             if (inflightTx == null) {
1:                 return;
1:             }
1: 
1:             final ArrayList<Operation> messagingTx = inflightTx;
1:             pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     for (Operation op : messagingTx) {
1:                         op.execute(tx);
1:                     }
1:                 }
1:             });
1:         }
1:     }
1: 
1:     public void processPrepare(TransactionId key) {
1:         synchronized (indexMutex) {
1:             ArrayList<Operation> tx = inflightTransactions.remove(key);
1:             if (tx != null) {
1:                 preparedTransactions.put(key, tx);
1:             }
1:         }
1:     }
1: 
1:     public void processRollback(TransactionId key) {
1:         synchronized (indexMutex) {
1:             ArrayList<Operation> tx = inflightTransactions.remove(key);
1:             if (tx == null) {
1:                 preparedTransactions.remove(key);
1:             }
1:         }
1:     }
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // These methods do the actual index updates.
1:     // /////////////////////////////////////////////////////////////////
1: 
1:     protected final Object indexMutex = new Object();
1: 	private final HashSet<Integer> journalFilesBeingReplicated = new HashSet<Integer>();
1: 
1:     private void upadateIndex(Transaction tx, KahaAddMessageCommand command, ByteSequence data) throws IOException {
1:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1: 
1:         // Skip adding the message to the index if this is a topic and there are
1:         // no subscriptions.
1:         if (sd.subscriptions != null && sd.ackPositions.isEmpty()) {
1:             return;
1:         }
1: 
1:         // Add the message.
1:         long id = sd.nextMessageId++;
1:         Long previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);
1:         if( previous == null ) {
1:             sd.orderIndex.put(tx, id, new MessageRecord(command.getMessageId(), data));
1:         } else {
1:             // restore the previous value.. Looks like this was a redo of a previously
1:             // added message.  We don't want to assing it a new id as the other indexes would 
1:             // be wrong..
1:             sd.messageIdIndex.put(tx, command.getMessageId(), previous);
1:         }
1:     }
1: 
1:     private void updateIndex(Transaction tx, KahaRemoveMessageCommand command) throws IOException {
1:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:         if (!command.hasSubscriptionKey()) {
1:             
1:             // In the queue case we just remove the message from the index..
1:             Long sequenceId = sd.messageIdIndex.remove(tx, command.getMessageId());
1:             if (sequenceId != null) {
1:                 sd.orderIndex.remove(tx, sequenceId);
1:             }
1:         } else {
1:             // In the topic case we need remove the message once it's been acked
1:             // by all the subs
1:             Long sequence = sd.messageIdIndex.get(tx, command.getMessageId());
1: 
1:             // Make sure it's a valid message id...
1:             if (sequence != null) {
1:                 String subscriptionKey = command.getSubscriptionKey();
1:                 Long prev = sd.subscriptionAcks.put(tx, subscriptionKey, sequence);
1: 
1:                 // The following method handles deleting un-referenced messages.
1:                 removeAckByteSequence(tx, sd, subscriptionKey, prev);
1: 
1:                 // Add it to the new location set.
1:                 addAckByteSequence(sd, sequence, subscriptionKey);
1:             }
1: 
1:         }
1:     }
1: 
1:     private void updateIndex(Transaction tx, KahaRemoveDestinationCommand command) throws IOException {
1:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1:         sd.orderIndex.clear(tx);
1:         sd.orderIndex.unload(tx);
1:         tx.free(sd.orderIndex.getPageId());
1:         
1:         sd.messageIdIndex.clear(tx);
1:         sd.messageIdIndex.unload(tx);
1:         tx.free(sd.messageIdIndex.getPageId());
1: 
1:         if (sd.subscriptions != null) {
1:             sd.subscriptions.clear(tx);
1:             sd.subscriptions.unload(tx);
1:             tx.free(sd.subscriptions.getPageId());
1: 
1:             sd.subscriptionAcks.clear(tx);
1:             sd.subscriptionAcks.unload(tx);
1:             tx.free(sd.subscriptionAcks.getPageId());
1:         }
1: 
1:         String key = key(command.getDestination());
1:         storedDestinations.remove(key);
1:         destinations.remove(tx, key);
1:     }
1: 
1:     private void updateIndex(Transaction tx, KahaSubscriptionCommand command) throws IOException {
1:         StoredDestination sd = getStoredDestination(command.getDestination(), tx);
1: 
1:         // If set then we are creating it.. otherwise we are destroying the sub
1:         if (command.hasSubscriptionInfo()) {
1:             String subscriptionKey = command.getSubscriptionKey();
1:             sd.subscriptions.put(tx, subscriptionKey, command);
1:             long ackByteSequence=-1;
1:             if (!command.getRetroactive()) {
1:                 ackByteSequence = sd.nextMessageId-1;
1:             }
1: 
1:             sd.subscriptionAcks.put(tx, subscriptionKey, ackByteSequence);
1:             addAckByteSequence(sd, ackByteSequence, subscriptionKey);
1:         } else {
1:             // delete the sub...
1:             String subscriptionKey = command.getSubscriptionKey();
1:             sd.subscriptions.remove(tx, subscriptionKey);
1:             Long prev = sd.subscriptionAcks.remove(tx, subscriptionKey);
1:             if( prev!=null ) {
1:                 removeAckByteSequence(tx, sd, subscriptionKey, prev);
1:             }
1:         }
1: 
1:     }
1:     
1:     public HashSet<Integer> getJournalFilesBeingReplicated() {
1: 		return journalFilesBeingReplicated;
1: 	}
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // StoredDestination related implementation methods.
1:     // /////////////////////////////////////////////////////////////////
1: 
1: 
1: 	private final HashMap<String, StoredDestination> storedDestinations = new HashMap<String, StoredDestination>();
1: 
1:     class StoredSubscription {
1:         SubscriptionInfo subscriptionInfo;
1:         String lastAckId;
1:         ByteSequence lastAckByteSequence;
1:         ByteSequence cursor;
1:     }
1:     
1:     static class MessageRecord {
1:         final String messageId;
1:         final ByteSequence data;
1:         
1:         public MessageRecord(String messageId, ByteSequence location) {
1:             this.messageId=messageId;
1:             this.data=location;
1:         }
1:         
1:         @Override
1:         public String toString() {
1:             return "["+messageId+","+data+"]";
1:         }
1:     }
1:     
0:     static protected class MessageKeysMarshaller implements Marshaller<MessageRecord> {
1:         static final MessageKeysMarshaller INSTANCE = new MessageKeysMarshaller();
1:         
0:         public Class<MessageRecord> getType() {
0:             return MessageRecord.class;
1:         }
1: 
1:         public MessageRecord readPayload(DataInput dataIn) throws IOException {
1:             return new MessageRecord(dataIn.readUTF(), ByteSequenceMarshaller.INSTANCE.readPayload(dataIn));
1:         }
1: 
1:         public void writePayload(MessageRecord object, DataOutput dataOut) throws IOException {
1:             dataOut.writeUTF(object.messageId);
1:             ByteSequenceMarshaller.INSTANCE.writePayload(object.data, dataOut);
1:         }
1:     }
1:     
1:     static class StoredDestination {
1:         long nextMessageId;
1:         BTreeIndex<Long, MessageRecord> orderIndex;
1:         BTreeIndex<String, Long> messageIdIndex;
1: 
1:         // These bits are only set for Topics
1:         BTreeIndex<String, KahaSubscriptionCommand> subscriptions;
1:         BTreeIndex<String, Long> subscriptionAcks;
1:         HashMap<String, Long> subscriptionCursors;
1:         TreeMap<Long, HashSet<String>> ackPositions;
1:     }
1: 
0:     protected class StoredDestinationMarshaller implements Marshaller<StoredDestination> {
1:         public Class<StoredDestination> getType() {
1:             return StoredDestination.class;
1:         }
1: 
1:         public StoredDestination readPayload(DataInput dataIn) throws IOException {
1:             StoredDestination value = new StoredDestination();
1:             value.orderIndex = new BTreeIndex<Long, MessageRecord>(pageFile, dataIn.readLong());
1:             value.messageIdIndex = new BTreeIndex<String, Long>(pageFile, dataIn.readLong());
1: 
1:             if (dataIn.readBoolean()) {
1:                 value.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, dataIn.readLong());
1:                 value.subscriptionAcks = new BTreeIndex<String, Long>(pageFile, dataIn.readLong());
1:             }
1:             return value;
1:         }
1: 
1:         public void writePayload(StoredDestination value, DataOutput dataOut) throws IOException {
1:             dataOut.writeLong(value.orderIndex.getPageId());
1:             dataOut.writeLong(value.messageIdIndex.getPageId());
1:             if (value.subscriptions != null) {
1:                 dataOut.writeBoolean(true);
1:                 dataOut.writeLong(value.subscriptions.getPageId());
1:                 dataOut.writeLong(value.subscriptionAcks.getPageId());
1:             } else {
1:                 dataOut.writeBoolean(false);
1:             }
1:         }
1:     }
1: 
0:     static class ByteSequenceMarshaller implements Marshaller<ByteSequence> {
1:         final static ByteSequenceMarshaller INSTANCE = new ByteSequenceMarshaller();
1: 
0:         public Class<ByteSequence> getType() {
0:             return ByteSequence.class;
1:         }
1: 
1:         public ByteSequence readPayload(DataInput dataIn) throws IOException {
1:         	byte data[] = new byte[dataIn.readInt()];
1:         	dataIn.readFully(data);
1:             return new ByteSequence(data);
1:         }
1: 
1:         public void writePayload(ByteSequence object, DataOutput dataOut) throws IOException {
1:             dataOut.writeInt(object.getLength());
1:             dataOut.write(object.getData(), object.getOffset(), object.getLength());
1:         }
1:     }
1: 
0:     static class KahaSubscriptionCommandMarshaller implements Marshaller<KahaSubscriptionCommand> {
1:         final static KahaSubscriptionCommandMarshaller INSTANCE = new KahaSubscriptionCommandMarshaller();
1: 
0:         public Class<KahaSubscriptionCommand> getType() {
0:             return KahaSubscriptionCommand.class;
1:         }
1: 
1:         public KahaSubscriptionCommand readPayload(DataInput dataIn) throws IOException {
1:             KahaSubscriptionCommand rc = new KahaSubscriptionCommand();
1:             rc.mergeFramed((InputStream)dataIn);
1:             return rc;
1:         }
1: 
1:         public void writePayload(KahaSubscriptionCommand object, DataOutput dataOut) throws IOException {
1:             object.writeFramed((OutputStream)dataOut);
1:         }
1:     }
1: 
1:     protected StoredDestination getStoredDestination(KahaDestination destination, Transaction tx) throws IOException {
1:         String key = key(destination);
1:         StoredDestination rc = storedDestinations.get(key);
1:         if (rc == null) {
1:             boolean topic = destination.getType() == KahaDestination.DestinationType.TOPIC || destination.getType() == KahaDestination.DestinationType.TEMP_TOPIC;
1:             rc = loadStoredDestination(tx, key, topic);
1:             // Cache it. We may want to remove/unload destinations from the
1:             // cache that are not used for a while
1:             // to reduce memory usage.
1:             storedDestinations.put(key, rc);
1:         }
1:         return rc;
1:     }
1: 
1:     /**
1:      * @param tx
1:      * @param key
1:      * @param topic
1:      * @return
1:      * @throws IOException
1:      */
1:     private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {
1:         // Try to load the existing indexes..
1:         StoredDestination rc = destinations.get(tx, key);
1:         if (rc == null) {
1:             // Brand new destination.. allocate indexes for it.
1:             rc = new StoredDestination();
1:             rc.orderIndex = new BTreeIndex<Long, MessageRecord>(pageFile, tx.allocate());
1:             rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());
1: 
1:             if (topic) {
1:                 rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());
1:                 rc.subscriptionAcks = new BTreeIndex<String, Long>(pageFile, tx.allocate());
1:             }
1:             destinations.put(tx, key, rc);
1:         }
1: 
1:         // Configure the marshalers and load.
1:         rc.orderIndex.setKeyMarshaller(LongMarshaller.INSTANCE);
1:         rc.orderIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);
1:         rc.orderIndex.load(tx);
1: 
1:         // Figure out the next key using the last entry in the destination.
1:         Entry<Long, MessageRecord> lastEntry = rc.orderIndex.getLast(tx);
1:         if( lastEntry!=null ) {
1:             rc.nextMessageId = lastEntry.getKey()+1;
1:         }
1: 
1:         rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);
1:         rc.messageIdIndex.load(tx);
1:         
1:         // If it was a topic...
1:         if (topic) {
1: 
1:             rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);
1:             rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);
1:             rc.subscriptions.load(tx);
1: 
1:             rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);
1:             rc.subscriptionAcks.setValueMarshaller(LongMarshaller.INSTANCE);
1:             rc.subscriptionAcks.load(tx);
1: 
1:             rc.ackPositions = new TreeMap<Long, HashSet<String>>();
1:             rc.subscriptionCursors = new HashMap<String, Long>();
1: 
1:             for (Iterator<Entry<String, Long>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {
1:                 Entry<String, Long> entry = iterator.next();
1:                 addAckByteSequence(rc, entry.getValue(), entry.getKey());
1:             }
1: 
1:         }
1:         return rc;
1:     }
1: 
1:     /**
1:      * @param sd
1:      * @param messageSequence
1:      * @param subscriptionKey
1:      */
1:     private void addAckByteSequence(StoredDestination sd, Long messageSequence, String subscriptionKey) {
1:         HashSet<String> hs = sd.ackPositions.get(messageSequence);
1:         if (hs == null) {
1:             hs = new HashSet<String>();
1:             sd.ackPositions.put(messageSequence, hs);
1:         }
1:         hs.add(subscriptionKey);
1:     }
1: 
1:     /**
1:      * @param tx
1:      * @param sd
1:      * @param subscriptionKey
1:      * @param sequenceId
1:      * @throws IOException
1:      */
1:     private void removeAckByteSequence(Transaction tx, StoredDestination sd, String subscriptionKey, Long sequenceId) throws IOException {
1:         // Remove the sub from the previous location set..
1:         if (sequenceId != null) {
1:             HashSet<String> hs = sd.ackPositions.get(sequenceId);
1:             if (hs != null) {
1:                 hs.remove(subscriptionKey);
1:                 if (hs.isEmpty()) {
1:                     HashSet<String> firstSet = sd.ackPositions.values().iterator().next();
1:                     sd.ackPositions.remove(sequenceId);
1: 
1:                     // Did we just empty out the first set in the
1:                     // ordered list of ack locations? Then it's time to
1:                     // delete some messages.
1:                     if (hs == firstSet) {
1: 
1:                         // Find all the entries that need to get deleted.
1:                         ArrayList<Entry<Long, MessageRecord>> deletes = new ArrayList<Entry<Long, MessageRecord>>();
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext();) {
1:                             Entry<Long, MessageRecord> entry = iterator.next();
1:                             if (entry.getKey().compareTo(sequenceId) <= 0) {
1:                                 // We don't do the actually delete while we are
1:                                 // iterating the BTree since
1:                                 // iterating would fail.
1:                                 deletes.add(entry);
1:                             }
1:                         }
1: 
1:                         // Do the actual deletes.
1:                         for (Entry<Long, MessageRecord> entry : deletes) {
1:                             sd.messageIdIndex.remove(tx,entry.getValue().messageId);
1:                             sd.orderIndex.remove(tx,entry.getKey());
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private String key(KahaDestination destination) {
1:         return destination.getType().getNumber() + ":" + destination.getName();
1:     }
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // Transaction related implementation methods.
1:     // /////////////////////////////////////////////////////////////////
1:     protected final LinkedHashMap<TransactionId, ArrayList<Operation>> inflightTransactions = new LinkedHashMap<TransactionId, ArrayList<Operation>>();
1:     protected final LinkedHashMap<TransactionId, ArrayList<Operation>> preparedTransactions = new LinkedHashMap<TransactionId, ArrayList<Operation>>();
1:  
1:     private ArrayList<Operation> getInflightTx(TransactionId key) {
1:         ArrayList<Operation> tx = inflightTransactions.get(key);
1:         if (tx == null) {
1:             tx = new ArrayList<Operation>();
1:             inflightTransactions.put(key, tx);
1:         }
1:         return tx;
1:     }
1: 
1:     abstract class Operation {
1:         abstract public void execute(Transaction tx) throws IOException;
1:     }
1: 
1:     class AddOpperation extends Operation {
1:         final KahaAddMessageCommand command;
1: 		private final ByteSequence data;
1: 
1:         public AddOpperation(KahaAddMessageCommand command, ByteSequence location) {
1:             this.command = command;
1: 			this.data = location;
1:         }
1: 
1:         public void execute(Transaction tx) throws IOException {
1:             upadateIndex(tx, command, data);
1:         }
1: 
1:         public KahaAddMessageCommand getCommand() {
1:             return command;
1:         }
1:     }
1: 
1:     class RemoveOpperation extends Operation {
1:         final KahaRemoveMessageCommand command;
1: 
1:         public RemoveOpperation(KahaRemoveMessageCommand command) {
1:             this.command = command;
1:         }
1: 
1:         public void execute(Transaction tx) throws IOException {
1:             updateIndex(tx, command);
1:         }
1: 
1:         public KahaRemoveMessageCommand getCommand() {
1:             return command;
1:         }
1:     }
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // Initialization related implementation methods.
1:     // /////////////////////////////////////////////////////////////////
1: 
1:     private PageFile createPageFile() {
1:         PageFile index = new PageFile(directory, "temp-db");
1:         index.setEnableWriteThread(isEnableIndexWriteAsync());
1:         index.setWriteBatchSize(getIndexWriteBatchSize());
1:         index.setEnableDiskSyncs(false);
1:         index.setEnableRecoveryFile(false);
1:         return index;
1:     }
1: 
1:     public File getDirectory() {
1:         return directory;
1:     }
1: 
1:     public void setDirectory(File directory) {
1:         this.directory = directory;
1:     }
1:     
1:     public void setIndexWriteBatchSize(int setIndexWriteBatchSize) {
1:         this.setIndexWriteBatchSize = setIndexWriteBatchSize;
1:     }
1: 
1:     public int getIndexWriteBatchSize() {
1:         return setIndexWriteBatchSize;
1:     }
1:     
1:     public void setEnableIndexWriteAsync(boolean enableIndexWriteAsync) {
1:         this.enableIndexWriteAsync = enableIndexWriteAsync;
1:     }
1:     
1:     boolean isEnableIndexWriteAsync() {
1:         return enableIndexWriteAsync;
1:     }
1:         
1:     public PageFile getPageFile() {
1:         if (pageFile == null) {
1:             pageFile = createPageFile();
1:         }
1: 		return pageFile;
1: 	}
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TempMessageDatabase.class);
============================================================================