1:cec3245: /*
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
1:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
1:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.client;
1:8e6a404: 
1:72839b7: import java.io.IOException;
1:72839b7: import java.util.ArrayList;
1:72839b7: import java.util.LinkedHashSet;
1:72839b7: import java.util.List;
1:4a1c05b: import java.util.Map;
1:72839b7: import java.util.Set;
1:72839b7: import java.util.concurrent.TimeUnit;
1:72839b7: import java.util.concurrent.atomic.AtomicBoolean;
4:72839b7: 
1:72839b7: import javax.jms.InvalidDestinationException;
1:72839b7: 
1:72839b7: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1:72839b7: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
1:fddbac2: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
1:272fb2b: import org.apache.qpid.proton.amqp.Binary;
1:72839b7: import org.apache.qpid.proton.amqp.Symbol;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Accepted;
1:272fb2b: import org.apache.qpid.proton.amqp.messaging.Modified;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Outcome;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Rejected;
1:272fb2b: import org.apache.qpid.proton.amqp.messaging.Released;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Source;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Target;
1:72839b7: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
1:72839b7: import org.apache.qpid.proton.amqp.transport.DeliveryState;
1:272fb2b: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1:72839b7: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1:72839b7: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1:72839b7: import org.apache.qpid.proton.engine.Delivery;
1:72839b7: import org.apache.qpid.proton.engine.Sender;
1:72839b7: import org.apache.qpid.proton.message.Message;
1:72839b7: import org.slf4j.Logger;
1:72839b7: import org.slf4j.LoggerFactory;
1:72839b7: 
2:72839b7: /**
1:72839b7:  * Sender class that manages a Proton sender endpoint.
1:72839b7:  */
1:72839b7: public class AmqpSender extends AmqpAbstractResource<Sender> {
1:72839b7: 
1:72839b7:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSender.class);
1:72839b7:     private static final byte[] EMPTY_BYTE_ARRAY = new byte[] {};
1:72839b7: 
1:72839b7:     public static final long DEFAULT_SEND_TIMEOUT = 15000;
1:72839b7: 
1:72839b7:     private final AmqpTransferTagGenerator tagGenerator = new AmqpTransferTagGenerator(true);
1:72839b7:     private final AtomicBoolean closed = new AtomicBoolean();
1:72839b7: 
1:72839b7:     private final AmqpSession session;
1:72839b7:     private final String address;
1:72839b7:     private final String senderId;
1:381a1ae: 
1:8e6a404:     private final Target userSpecifiedTarget;
1:381a1ae:     private final SenderSettleMode userSpecifiedSenderSettlementMode;
1:381a1ae:     private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;
1:72839b7: 
1:72839b7:     private boolean presettle;
1:72839b7:     private long sendTimeout = DEFAULT_SEND_TIMEOUT;
1:72839b7: 
1:4a1c05b:     private final Set<Delivery> pending = new LinkedHashSet<>();
1:72839b7:     private byte[] encodeBuffer = new byte[1024 * 8];
1:72839b7: 
1:4a1c05b:     private Symbol[] desiredCapabilities;
1:4a1c05b:     private Symbol[] offeredCapabilities;
1:4a1c05b:     private Map<Symbol, Object> properties;
1:4a1c05b: 
1:72839b7:     /**
1:72839b7:      * Create a new sender instance.
1:72839b7:      *
1:72839b7:      * @param session
1:72839b7:      * 		  The parent session that created the session.
1:72839b7:      * @param address
1:72839b7:      *        The address that this sender produces to.
1:72839b7:      * @param senderId
1:72839b7:      *        The unique ID assigned to this sender.
1:72839b7:      */
1:72839b7:     public AmqpSender(AmqpSession session, String address, String senderId) {
1:381a1ae:         this(session, address, senderId, null, null);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     /**
1:381a1ae:      * Create a new sender instance.
1:381a1ae:      *
1:381a1ae:      * @param session
1:381a1ae:      *        The parent session that created the session.
1:381a1ae:      * @param address
1:381a1ae:      *        The address that this sender produces to.
1:381a1ae:      * @param senderId
1:381a1ae:      *        The unique ID assigned to this sender.
1:381a1ae:      * @param senderMode
1:381a1ae:      *        The {@link SenderSettleMode} to use on open.
1:381a1ae:      * @param receiverMode
1:381a1ae:      *        The {@link ReceiverSettleMode} to use on open.
1:381a1ae:      */
1:381a1ae:     public AmqpSender(AmqpSession session, String address, String senderId, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) {
1:4a1c05b: 
1:8e6a404:         if (address != null && address.isEmpty()) {
1:8e6a404:             throw new IllegalArgumentException("Address cannot be empty.");
1:8e6a404:         }
1:8e6a404: 
1:72839b7:         this.session = session;
1:72839b7:         this.address = address;
1:72839b7:         this.senderId = senderId;
1:8e6a404:         this.userSpecifiedTarget = null;
1:381a1ae:         this.userSpecifiedSenderSettlementMode = senderMode;
1:381a1ae:         this.userSpecifiedReceiverSettlementMode = receiverMode;
1:8e6a404:     }
1:8e6a404: 
1:8e6a404:     /**
1:8e6a404:      * Create a new sender instance using the given Target when creating the link.
1:8e6a404:      *
1:8e6a404:      * @param session
1:8e6a404:      *        The parent session that created the session.
1:8e6a404:      * @param address
1:8e6a404:      *        The address that this sender produces to.
1:8e6a404:      * @param senderId
1:8e6a404:      *        The unique ID assigned to this sender.
1:8e6a404:      */
1:8e6a404:     public AmqpSender(AmqpSession session, Target target, String senderId) {
1:8e6a404: 
1:8e6a404:         if (target == null) {
1:8e6a404:             throw new IllegalArgumentException("User specified Target cannot be null");
1:8e6a404:         }
1:8e6a404: 
1:8e6a404:         this.session = session;
1:8e6a404:         this.userSpecifiedTarget = target;
1:8e6a404:         this.address = target.getAddress();
1:8e6a404:         this.senderId = senderId;
1:381a1ae:         this.userSpecifiedSenderSettlementMode = null;
1:381a1ae:         this.userSpecifiedReceiverSettlementMode = null;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Sends the given message to this senders assigned address.
1:72839b7:      *
1:72839b7:      * @param message
1:72839b7:      *        the message to send.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs during the send.
1:72839b7:      */
1:72839b7:     public void send(final AmqpMessage message) throws IOException {
1:72839b7:         checkClosed();
1:b4ab0e1:         send(message, null);
1:b4ab0e1:     }
1:b4ab0e1: 
1:b4ab0e1:     /**
1:b4ab0e1:      * Sends the given message to this senders assigned address using the supplied transaction ID.
1:b4ab0e1:      *
1:b4ab0e1:      * @param message
1:b4ab0e1:      *        the message to send.
1:b4ab0e1:      * @param txId
1:b4ab0e1:      *        the transaction ID to assign the outgoing send.
1:b4ab0e1:      *
1:b4ab0e1:      * @throws IOException if an error occurs during the send.
1:b4ab0e1:      */
1:b4ab0e1:     public void send(final AmqpMessage message, final AmqpTransactionId txId) throws IOException {
1:b4ab0e1:         checkClosed();
1:72839b7:         final ClientFuture sendRequest = new ClientFuture();
1:72839b7: 
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 try {
1:b4ab0e1:                     doSend(message, sendRequest, txId);
1:8448cf1:                     session.pumpToProtonTransport(sendRequest);
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     sendRequest.onFailure(e);
1:72839b7:                     session.getConnection().fireClientException(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         if (sendTimeout <= 0) {
1:72839b7:             sendRequest.sync();
3:72839b7:         } else {
1:72839b7:             sendRequest.sync(sendTimeout, TimeUnit.MILLISECONDS);
1:72839b7:         }
1:72839b7:     }
1:b3bf8e7: 
1:72839b7:     /**
1:72839b7:      * Close the sender, a closed sender will throw exceptions if any further send
1:72839b7:      * calls are made.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs while closing the sender.
1:72839b7:      */
1:72839b7:     public void close() throws IOException {
1:72839b7:         if (closed.compareAndSet(false, true)) {
1:72839b7:             final ClientFuture request = new ClientFuture();
1:72839b7:             session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:                 @Override
1:72839b7:                 public void run() {
1:72839b7:                     checkClosed();
1:72839b7:                     close(request);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:72839b7:                 }
1:72839b7:             });
1:72839b7: 
1:72839b7:             request.sync();
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return this session's parent AmqpSession.
1:72839b7:      */
1:72839b7:     public AmqpSession getSession() {
1:72839b7:         return session;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return an unmodifiable view of the underlying Sender instance.
1:72839b7:      */
1:72839b7:     public Sender getSender() {
1:fddbac2:         return UnmodifiableProxy.senderProxy(getEndpoint());
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the assigned address of this sender.
1:72839b7:      */
1:72839b7:     public String getAddress() {
1:72839b7:         return address;
1:72839b7:     }
1:72839b7: 
1:72839b7:     //----- Sender configuration ---------------------------------------------//
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return will messages be settle on send.
1:72839b7:      */
1:72839b7:     public boolean isPresettle() {
1:72839b7:         return presettle;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Configure is sent messages are marked as settled on send, defaults to false.
1:72839b7:      *
1:72839b7:      * @param presettle
1:72839b7:      * 		  configure if this sender will presettle all sent messages.
1:72839b7:      */
1:72839b7:     public void setPresettle(boolean presettle) {
1:72839b7:         this.presettle = presettle;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the currently configured send timeout.
1:72839b7:      */
1:72839b7:     public long getSendTimeout() {
1:72839b7:         return sendTimeout;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Sets the amount of time the sender will block on a send before failing.
1:72839b7:      *
1:72839b7:      * @param sendTimeout
1:72839b7:      *        time in milliseconds to wait.
1:72839b7:      */
1:72839b7:     public void setSendTimeout(long sendTimeout) {
1:72839b7:         this.sendTimeout = sendTimeout;
1:72839b7:     }
1:72839b7: 
1:4a1c05b:     public void setDesiredCapabilities(Symbol[] desiredCapabilities) {
1:4a1c05b:         if (getEndpoint() != null) {
1:4a1c05b:             throw new IllegalStateException("Endpoint already established");
1:4a1c05b:         }
1:4a1c05b: 
1:4a1c05b:         this.desiredCapabilities = desiredCapabilities;
1:4a1c05b:     }
1:4a1c05b: 
1:4a1c05b:     public void setOfferedCapabilities(Symbol[] offeredCapabilities) {
1:4a1c05b:         if (getEndpoint() != null) {
1:4a1c05b:             throw new IllegalStateException("Endpoint already established");
1:4a1c05b:         }
1:4a1c05b: 
1:4a1c05b:         this.offeredCapabilities = offeredCapabilities;
1:4a1c05b:     }
1:4a1c05b: 
1:4a1c05b:     public void setProperties(Map<Symbol, Object> properties) {
1:4a1c05b:         if (getEndpoint() != null) {
1:4a1c05b:             throw new IllegalStateException("Endpoint already established");
1:4a1c05b:         }
1:4a1c05b: 
1:4a1c05b:         this.properties = properties;
1:4a1c05b:     }
1:4a1c05b: 
1:72839b7:     //----- Private Sender implementation ------------------------------------//
1:72839b7: 
1:72839b7:     private void checkClosed() {
1:72839b7:         if (isClosed()) {
1:72839b7:             throw new IllegalStateException("Sender is already closed");
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpen() {
1:72839b7: 
1:6a2ffca:         Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL };
1:72839b7:         Source source = new Source();
1:72839b7:         source.setAddress(senderId);
1:72839b7:         source.setOutcomes(outcomes);
1:72839b7: 
1:8e6a404:         Target target = userSpecifiedTarget;
1:8e6a404:         if (target == null) {
1:8e6a404:             target = new Target();
1:8e6a404:             target.setAddress(address);
1:8e6a404:         }
1:72839b7: 
1:72839b7:         String senderName = senderId + ":" + address;
1:72839b7: 
1:72839b7:         Sender sender = session.getEndpoint().sender(senderName);
1:72839b7:         sender.setSource(source);
1:72839b7:         sender.setTarget(target);
1:381a1ae: 
1:381a1ae:         if (userSpecifiedSenderSettlementMode != null) {
1:381a1ae:             sender.setSenderSettleMode(userSpecifiedSenderSettlementMode);
1:381a1ae:             if (SenderSettleMode.SETTLED.equals(userSpecifiedSenderSettlementMode)) {
1:381a1ae:                 presettle = true;
1:381a1ae:             }
1:72839b7:         } else {
1:381a1ae:             if (presettle) {
1:381a1ae:                 sender.setSenderSettleMode(SenderSettleMode.SETTLED);
1:381a1ae:             } else {
1:381a1ae:                 sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:381a1ae:             }
1:72839b7:         }
1:381a1ae: 
1:381a1ae:         if (userSpecifiedReceiverSettlementMode != null) {
1:381a1ae:             sender.setReceiverSettleMode(userSpecifiedReceiverSettlementMode);
1:381a1ae:         } else {
1:381a1ae:             sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1:381a1ae:         }
1:72839b7: 
1:4a1c05b:         sender.setDesiredCapabilities(desiredCapabilities);
1:4a1c05b:         sender.setOfferedCapabilities(offeredCapabilities);
1:4a1c05b:         sender.setProperties(properties);
1:4a1c05b: 
1:72839b7:         setEndpoint(sender);
1:72839b7: 
1:72839b7:         super.doOpen();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenCompletion() {
1:72839b7:         // Verify the attach response contained a non-null target
1:72839b7:         org.apache.qpid.proton.amqp.transport.Target t = getEndpoint().getRemoteTarget();
1:72839b7:         if (t != null) {
1:72839b7:             super.doOpenCompletion();
1:72839b7:         } else {
1:72839b7:             // No link terminus was created, the peer will now detach/close us.
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectOpenedResource(getSender());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doClosedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectClosedResource(getSender());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doDetachedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectDetachedResource(getSender());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:cec3245:     protected void doDeliveryUpdateInspection(Delivery delivery) {
1:cec3245:         try {
1:cec3245:             getStateInspector().inspectDeliveryUpdate(getSender(), delivery);
1:cec3245:         } catch (Throwable error) {
1:cec3245:             getStateInspector().markAsInvalid(error.getMessage());
1:cec3245:         }
1:cec3245:     }
1:cec3245: 
1:72839b7:     @Override
1:72839b7:     protected Exception getOpenAbortException() {
1:72839b7:         // Verify the attach response contained a non-null target
1:72839b7:         org.apache.qpid.proton.amqp.transport.Target t = getEndpoint().getRemoteTarget();
1:72839b7:         if (t != null) {
1:72839b7:             return super.getOpenAbortException();
1:72839b7:         } else {
1:72839b7:             // No link terminus was created, the peer has detach/closed us, create IDE.
1:72839b7:             return new InvalidDestinationException("Link creation was refused");
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:b4ab0e1:     private void doSend(AmqpMessage message, AsyncResult request, AmqpTransactionId txId) throws Exception {
1:72839b7:         LOG.trace("Producer sending message: {}", message);
1:72839b7: 
1:72839b7:         Delivery delivery = null;
2:72839b7:         if (presettle) {
1:72839b7:             delivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);
1:72839b7:         } else {
1:272fb2b:             byte[] tag = tagGenerator.getNextTag();
1:72839b7:             delivery = getEndpoint().delivery(tag, 0, tag.length);
1:72839b7:         }
1:72839b7: 
1:72839b7:         delivery.setContext(request);
1:72839b7: 
1:b4ab0e1:         Binary amqpTxId = null;
1:b4ab0e1:         if (txId != null) {
1:b4ab0e1:             amqpTxId = txId.getRemoteTxId();
1:b4ab0e1:         } else if (session.isInTransaction()) {
1:b4ab0e1:             amqpTxId = session.getTransactionId().getRemoteTxId();
1:b4ab0e1:         }
1:b4ab0e1: 
1:b4ab0e1:         if (amqpTxId != null) {
1:272fb2b:             TransactionalState state = new TransactionalState();
1:272fb2b:             state.setTxnId(amqpTxId);
1:272fb2b:             delivery.disposition(state);
1:272fb2b:         }
1:272fb2b: 
1:72839b7:         encodeAndSend(message.getWrappedMessage(), delivery);
1:72839b7: 
1:72839b7:         if (presettle) {
1:b3bf8e7:             delivery.settle();
1:72839b7:             request.onSuccess();
1:72839b7:         } else {
1:72839b7:             pending.add(delivery);
1:72839b7:             getEndpoint().advance();
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void encodeAndSend(Message message, Delivery delivery) throws IOException {
1:72839b7: 
1:72839b7:         int encodedSize;
1:72839b7:         while (true) {
1:72839b7:             try {
1:72839b7:                 encodedSize = message.encode(encodeBuffer, 0, encodeBuffer.length);
1:72839b7:                 break;
1:72839b7:             } catch (java.nio.BufferOverflowException e) {
1:72839b7:                 encodeBuffer = new byte[encodeBuffer.length * 2];
1:72839b7:             }
1:72839b7:         }
1:72839b7: 
1:72839b7:         int sentSoFar = 0;
1:72839b7: 
1:72839b7:         while (true) {
1:72839b7:             int sent = getEndpoint().send(encodeBuffer, sentSoFar, encodedSize - sentSoFar);
1:72839b7:             if (sent > 0) {
1:72839b7:                 sentSoFar += sent;
1:72839b7:                 if ((encodedSize - sentSoFar) == 0) {
1:72839b7:                     break;
1:72839b7:                 }
1:72839b7:             } else {
1:72839b7:                 LOG.warn("{} failed to send any data from current Message.", this);
1:72839b7:             }
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     public void processDeliveryUpdates(AmqpConnection connection) throws IOException {
1:4a1c05b:         List<Delivery> toRemove = new ArrayList<>();
1:72839b7: 
1:72839b7:         for (Delivery delivery : pending) {
1:72839b7:             DeliveryState state = delivery.getRemoteState();
1:72839b7:             if (state == null) {
2:72839b7:                 continue;
1:72839b7:             }
1:72839b7: 
1:cec3245:             doDeliveryUpdateInspection(delivery);
1:cec3245: 
1:72839b7:             Outcome outcome = null;
1:72839b7:             if (state instanceof TransactionalState) {
1:72839b7:                 LOG.trace("State of delivery is Transactional, retrieving outcome: {}", state);
1:72839b7:                 outcome = ((TransactionalState) state).getOutcome();
1:72839b7:             } else if (state instanceof Outcome) {
1:72839b7:                 outcome = (Outcome) state;
1:72839b7:             } else {
1:72839b7:                 LOG.warn("Message send updated with unsupported state: {}", state);
1:b3bf8e7:                 outcome = null;
1:72839b7:             }
1:72839b7: 
1:72839b7:             AsyncResult request = (AsyncResult) delivery.getContext();
1:272fb2b:             Exception deliveryError = null;
1:72839b7: 
1:72839b7:             if (outcome instanceof Accepted) {
1:72839b7:                 LOG.trace("Outcome of delivery was accepted: {}", delivery);
2:72839b7:                 if (request != null && !request.isComplete()) {
1:72839b7:                     request.onSuccess();
1:72839b7:                 }
1:72839b7:             } else if (outcome instanceof Rejected) {
1:72839b7:                 LOG.trace("Outcome of delivery was rejected: {}", delivery);
1:272fb2b:                 ErrorCondition remoteError = ((Rejected) outcome).getError();
1:272fb2b:                 if (remoteError == null) {
1:272fb2b:                     remoteError = getEndpoint().getRemoteCondition();
1:72839b7:                 }
1:272fb2b: 
1:272fb2b:                 deliveryError = AmqpSupport.convertToException(remoteError);
1:272fb2b:             } else if (outcome instanceof Released) {
1:272fb2b:                 LOG.trace("Outcome of delivery was released: {}", delivery);
1:272fb2b:                 deliveryError = new IOException("Delivery failed: released by receiver");
1:272fb2b:             } else if (outcome instanceof Modified) {
1:272fb2b:                 LOG.trace("Outcome of delivery was modified: {}", delivery);
1:272fb2b:                 deliveryError = new IOException("Delivery failed: failure at remote");
1:72839b7:             }
1:72839b7: 
1:272fb2b:             if (deliveryError != null) {
1:272fb2b:                 if (request != null && !request.isComplete()) {
1:272fb2b:                     request.onFailure(deliveryError);
1:272fb2b:                 } else {
1:272fb2b:                     connection.fireClientException(deliveryError);
1:272fb2b:                 }
1:272fb2b:             }
1:272fb2b: 
1:272fb2b:             tagGenerator.returnTag(delivery.getTag());
1:72839b7:             delivery.settle();
1:b3bf8e7:             toRemove.add(delivery);
1:72839b7:         }
1:72839b7: 
1:72839b7:         pending.removeAll(toRemove);
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     public String toString() {
1:72839b7:         return getClass().getSimpleName() + "{ address = " + address + "}";
1:72839b7:     }
1:72839b7: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:fddbac2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return UnmodifiableProxy.senderProxy(getEndpoint());
commit:381a1ae
/////////////////////////////////////////////////////////////////////////
1: 
1:     private final SenderSettleMode userSpecifiedSenderSettlementMode;
1:     private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;
/////////////////////////////////////////////////////////////////////////
1:         this(session, address, senderId, null, null);
1:     }
1: 
1:     /**
1:      * Create a new sender instance.
1:      *
1:      * @param session
1:      *        The parent session that created the session.
1:      * @param address
1:      *        The address that this sender produces to.
1:      * @param senderId
1:      *        The unique ID assigned to this sender.
1:      * @param senderMode
1:      *        The {@link SenderSettleMode} to use on open.
1:      * @param receiverMode
1:      *        The {@link ReceiverSettleMode} to use on open.
1:      */
1:     public AmqpSender(AmqpSession session, String address, String senderId, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) {
/////////////////////////////////////////////////////////////////////////
1:         this.userSpecifiedSenderSettlementMode = senderMode;
1:         this.userSpecifiedReceiverSettlementMode = receiverMode;
/////////////////////////////////////////////////////////////////////////
1:         this.userSpecifiedSenderSettlementMode = null;
1:         this.userSpecifiedReceiverSettlementMode = null;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (userSpecifiedSenderSettlementMode != null) {
1:             sender.setSenderSettleMode(userSpecifiedSenderSettlementMode);
1:             if (SenderSettleMode.SETTLED.equals(userSpecifiedSenderSettlementMode)) {
1:                 presettle = true;
1:             }
1:             if (presettle) {
1:                 sender.setSenderSettleMode(SenderSettleMode.SETTLED);
1:             } else {
1:                 sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:             }
1: 
1:         if (userSpecifiedReceiverSettlementMode != null) {
1:             sender.setReceiverSettleMode(userSpecifiedReceiverSettlementMode);
1:         } else {
1:             sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1:         }
commit:4a1c05b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     private final Set<Delivery> pending = new LinkedHashSet<>();
1:     private Symbol[] desiredCapabilities;
1:     private Symbol[] offeredCapabilities;
1:     private Map<Symbol, Object> properties;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setDesiredCapabilities(Symbol[] desiredCapabilities) {
1:         if (getEndpoint() != null) {
1:             throw new IllegalStateException("Endpoint already established");
1:         }
1: 
1:         this.desiredCapabilities = desiredCapabilities;
1:     }
1: 
1:     public void setOfferedCapabilities(Symbol[] offeredCapabilities) {
1:         if (getEndpoint() != null) {
1:             throw new IllegalStateException("Endpoint already established");
1:         }
1: 
1:         this.offeredCapabilities = offeredCapabilities;
1:     }
1: 
1:     public void setProperties(Map<Symbol, Object> properties) {
1:         if (getEndpoint() != null) {
1:             throw new IllegalStateException("Endpoint already established");
1:         }
1: 
1:         this.properties = properties;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         sender.setDesiredCapabilities(desiredCapabilities);
1:         sender.setOfferedCapabilities(offeredCapabilities);
1:         sender.setProperties(properties);
1: 
/////////////////////////////////////////////////////////////////////////
1:         List<Delivery> toRemove = new ArrayList<>();
commit:cec3245
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:     protected void doDeliveryUpdateInspection(Delivery delivery) {
1:         try {
1:             getStateInspector().inspectDeliveryUpdate(getSender(), delivery);
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             doDeliveryUpdateInspection(delivery);
1: 
commit:b4ab0e1
/////////////////////////////////////////////////////////////////////////
1:         send(message, null);
1:     }
1: 
1:     /**
1:      * Sends the given message to this senders assigned address using the supplied transaction ID.
1:      *
1:      * @param message
1:      *        the message to send.
1:      * @param txId
1:      *        the transaction ID to assign the outgoing send.
1:      *
1:      * @throws IOException if an error occurs during the send.
1:      */
1:     public void send(final AmqpMessage message, final AmqpTransactionId txId) throws IOException {
1:         checkClosed();
/////////////////////////////////////////////////////////////////////////
1:                     doSend(message, sendRequest, txId);
/////////////////////////////////////////////////////////////////////////
1:     private void doSend(AmqpMessage message, AsyncResult request, AmqpTransactionId txId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         Binary amqpTxId = null;
1:         if (txId != null) {
1:             amqpTxId = txId.getRemoteTxId();
1:         } else if (session.isInTransaction()) {
1:             amqpTxId = session.getTransactionId().getRemoteTxId();
1:         }
1: 
1:         if (amqpTxId != null) {
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(sendRequest);
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
commit:272fb2b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.Binary;
1: import org.apache.qpid.proton.amqp.messaging.Modified;
1: import org.apache.qpid.proton.amqp.messaging.Released;
1: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
/////////////////////////////////////////////////////////////////////////
1:             byte[] tag = tagGenerator.getNextTag();
0:         if (session.isInTransaction()) {
0:             Binary amqpTxId = session.getTransactionId().getRemoteTxId();
1:             TransactionalState state = new TransactionalState();
1:             state.setTxnId(amqpTxId);
1:             delivery.disposition(state);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             Exception deliveryError = null;
1:                 ErrorCondition remoteError = ((Rejected) outcome).getError();
1:                 if (remoteError == null) {
1:                     remoteError = getEndpoint().getRemoteCondition();
1: 
1:                 deliveryError = AmqpSupport.convertToException(remoteError);
1:             } else if (outcome instanceof Released) {
1:                 LOG.trace("Outcome of delivery was released: {}", delivery);
1:                 deliveryError = new IOException("Delivery failed: released by receiver");
1:             } else if (outcome instanceof Modified) {
1:                 LOG.trace("Outcome of delivery was modified: {}", delivery);
1:                 deliveryError = new IOException("Delivery failed: failure at remote");
1:             if (deliveryError != null) {
1:                 if (request != null && !request.isComplete()) {
1:                     request.onFailure(deliveryError);
1:                 } else {
1:                     connection.fireClientException(deliveryError);
1:                 }
1:             }
1: 
1:             tagGenerator.returnTag(delivery.getTag());
commit:7c06d8d
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             getStateInspector().inspectOpenedResource(getSender());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectClosedResource(getSender());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectDetachedResource(getSender());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
commit:6a2ffca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL };
commit:b3bf8e7
/////////////////////////////////////////////////////////////////////////
1:                 outcome = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             } else if (outcome != null) {
1: 
1:             delivery.settle();
1:             toRemove.add(delivery);
commit:8e6a404
/////////////////////////////////////////////////////////////////////////
1:     private final Target userSpecifiedTarget;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (address != null && address.isEmpty()) {
1:             throw new IllegalArgumentException("Address cannot be empty.");
1:         }
1: 
1:         this.userSpecifiedTarget = null;
1:     }
1: 
1:     /**
1:      * Create a new sender instance using the given Target when creating the link.
1:      *
1:      * @param session
1:      *        The parent session that created the session.
1:      * @param address
1:      *        The address that this sender produces to.
1:      * @param senderId
1:      *        The unique ID assigned to this sender.
1:      */
1:     public AmqpSender(AmqpSession session, Target target, String senderId) {
1: 
1:         if (target == null) {
1:             throw new IllegalArgumentException("User specified Target cannot be null");
1:         }
1: 
1:         this.session = session;
1:         this.userSpecifiedTarget = target;
1:         this.address = target.getAddress();
1:         this.senderId = senderId;
/////////////////////////////////////////////////////////////////////////
1:         Target target = userSpecifiedTarget;
1:         if (target == null) {
1:             target = new Target();
1:             target.setAddress(address);
1:         }
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.LinkedHashSet;
1: import java.util.List;
1: import java.util.Set;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.jms.InvalidDestinationException;
1: 
1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
0: import org.apache.activemq.transport.amqp.client.util.UnmodifiableSender;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.messaging.Accepted;
1: import org.apache.qpid.proton.amqp.messaging.Outcome;
1: import org.apache.qpid.proton.amqp.messaging.Rejected;
1: import org.apache.qpid.proton.amqp.messaging.Source;
1: import org.apache.qpid.proton.amqp.messaging.Target;
1: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
1: import org.apache.qpid.proton.amqp.transport.DeliveryState;
1: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1: import org.apache.qpid.proton.engine.Delivery;
1: import org.apache.qpid.proton.engine.Sender;
1: import org.apache.qpid.proton.message.Message;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Sender class that manages a Proton sender endpoint.
1:  */
1: public class AmqpSender extends AmqpAbstractResource<Sender> {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSender.class);
1:     private static final byte[] EMPTY_BYTE_ARRAY = new byte[] {};
0:     //TODO: Use constants available from Proton 0.9
0:     private static final Symbol ACCEPTED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:accepted:list");
0:     private static final Symbol REJECTED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:rejected:list");
1: 
1:     public static final long DEFAULT_SEND_TIMEOUT = 15000;
1: 
1:     private final AmqpTransferTagGenerator tagGenerator = new AmqpTransferTagGenerator(true);
1:     private final AtomicBoolean closed = new AtomicBoolean();
1: 
1:     private final AmqpSession session;
1:     private final String address;
1:     private final String senderId;
1: 
1:     private boolean presettle;
1:     private long sendTimeout = DEFAULT_SEND_TIMEOUT;
1: 
0:     private final Set<Delivery> pending = new LinkedHashSet<Delivery>();
1:     private byte[] encodeBuffer = new byte[1024 * 8];
1: 
1:     /**
1:      * Create a new sender instance.
1:      *
1:      * @param session
1:      * 		  The parent session that created the session.
1:      * @param address
1:      *        The address that this sender produces to.
1:      * @param senderId
1:      *        The unique ID assigned to this sender.
1:      */
1:     public AmqpSender(AmqpSession session, String address, String senderId) {
1:         this.session = session;
1:         this.address = address;
1:         this.senderId = senderId;
1:     }
1: 
1:     /**
1:      * Sends the given message to this senders assigned address.
1:      *
1:      * @param message
1:      *        the message to send.
1:      *
1:      * @throws IOException if an error occurs during the send.
1:      */
1:     public void send(final AmqpMessage message) throws IOException {
1:         checkClosed();
1:         final ClientFuture sendRequest = new ClientFuture();
1: 
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 try {
0:                     doSend(message, sendRequest);
0:                     session.pumpToProtonTransport();
1:                 } catch (Exception e) {
1:                     sendRequest.onFailure(e);
1:                     session.getConnection().fireClientException(e);
1:                 }
1:             }
1:         });
1: 
1:         if (sendTimeout <= 0) {
1:             sendRequest.sync();
1:         } else {
1:             sendRequest.sync(sendTimeout, TimeUnit.MILLISECONDS);
1:         }
1:     }
1: 
1:     /**
1:      * Close the sender, a closed sender will throw exceptions if any further send
1:      * calls are made.
1:      *
1:      * @throws IOException if an error occurs while closing the sender.
1:      */
1:     public void close() throws IOException {
1:         if (closed.compareAndSet(false, true)) {
1:             final ClientFuture request = new ClientFuture();
1:             session.getScheduler().execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     checkClosed();
1:                     close(request);
0:                     session.pumpToProtonTransport();
1:                 }
1:             });
1: 
1:             request.sync();
1:         }
1:     }
1: 
1:     /**
1:      * @return this session's parent AmqpSession.
1:      */
1:     public AmqpSession getSession() {
1:         return session;
1:     }
1: 
1:     /**
1:      * @return an unmodifiable view of the underlying Sender instance.
1:      */
1:     public Sender getSender() {
0:         return new UnmodifiableSender(getEndpoint());
1:     }
1: 
1:     /**
1:      * @return the assigned address of this sender.
1:      */
1:     public String getAddress() {
1:         return address;
1:     }
1: 
1:     //----- Sender configuration ---------------------------------------------//
1: 
1:     /**
1:      * @return will messages be settle on send.
1:      */
1:     public boolean isPresettle() {
1:         return presettle;
1:     }
1: 
1:     /**
1:      * Configure is sent messages are marked as settled on send, defaults to false.
1:      *
1:      * @param presettle
1:      * 		  configure if this sender will presettle all sent messages.
1:      */
1:     public void setPresettle(boolean presettle) {
1:         this.presettle = presettle;
1:     }
1: 
1:     /**
1:      * @return the currently configured send timeout.
1:      */
1:     public long getSendTimeout() {
1:         return sendTimeout;
1:     }
1: 
1:     /**
1:      * Sets the amount of time the sender will block on a send before failing.
1:      *
1:      * @param sendTimeout
1:      *        time in milliseconds to wait.
1:      */
1:     public void setSendTimeout(long sendTimeout) {
1:         this.sendTimeout = sendTimeout;
1:     }
1: 
1:     //----- Private Sender implementation ------------------------------------//
1: 
1:     private void checkClosed() {
1:         if (isClosed()) {
1:             throw new IllegalStateException("Sender is already closed");
1:         }
1:     }
1: 
1:     @Override
1:     protected void doOpen() {
1: 
0:         Symbol[] outcomes = new Symbol[]{ACCEPTED_DESCRIPTOR_SYMBOL, REJECTED_DESCRIPTOR_SYMBOL};
1:         Source source = new Source();
1:         source.setAddress(senderId);
1:         source.setOutcomes(outcomes);
1: 
0:         Target target = new Target();
0:         target.setAddress(address);
1: 
1:         String senderName = senderId + ":" + address;
1: 
1:         Sender sender = session.getEndpoint().sender(senderName);
1:         sender.setSource(source);
1:         sender.setTarget(target);
1:         if (presettle) {
0:             sender.setSenderSettleMode(SenderSettleMode.SETTLED);
1:         } else {
0:             sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:         }
0:         sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1: 
1:         setEndpoint(sender);
1: 
1:         super.doOpen();
1:     }
1: 
1:     @Override
1:     protected void doOpenCompletion() {
1:         // Verify the attach response contained a non-null target
1:         org.apache.qpid.proton.amqp.transport.Target t = getEndpoint().getRemoteTarget();
1:         if (t != null) {
1:             super.doOpenCompletion();
1:         } else {
1:             // No link terminus was created, the peer will now detach/close us.
1:         }
1:     }
1: 
1:     @Override
1:     protected void doOpenInspection() {
0:         getStateInspector().inspectOpenedResource(getSender());
1:     }
1: 
1:     @Override
1:     protected void doClosedInspection() {
0:         getStateInspector().inspectClosedResource(getSender());
1:     }
1: 
1:     @Override
1:     protected void doDetachedInspection() {
0:         getStateInspector().inspectDetachedResource(getSender());
1:     }
1: 
1:     @Override
1:     protected Exception getOpenAbortException() {
1:         // Verify the attach response contained a non-null target
1:         org.apache.qpid.proton.amqp.transport.Target t = getEndpoint().getRemoteTarget();
1:         if (t != null) {
1:             return super.getOpenAbortException();
1:         } else {
1:             // No link terminus was created, the peer has detach/closed us, create IDE.
1:             return new InvalidDestinationException("Link creation was refused");
1:         }
1:     }
1: 
0:     private void doSend(AmqpMessage message, AsyncResult request) throws Exception {
1: 
1:         LOG.trace("Producer sending message: {}", message);
1: 
0:         byte[] tag = tagGenerator.getNextTag();
1:         Delivery delivery = null;
1: 
1:         if (presettle) {
1:             delivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);
1:         } else {
1:             delivery = getEndpoint().delivery(tag, 0, tag.length);
1:         }
1: 
1:         delivery.setContext(request);
1: 
1:         encodeAndSend(message.getWrappedMessage(), delivery);
1: 
1:         if (presettle) {
1:             delivery.settle();
1:             request.onSuccess();
1:         } else {
1:             pending.add(delivery);
1:             getEndpoint().advance();
1:         }
1:     }
1: 
1:     private void encodeAndSend(Message message, Delivery delivery) throws IOException {
1: 
1:         int encodedSize;
1:         while (true) {
1:             try {
1:                 encodedSize = message.encode(encodeBuffer, 0, encodeBuffer.length);
1:                 break;
1:             } catch (java.nio.BufferOverflowException e) {
1:                 encodeBuffer = new byte[encodeBuffer.length * 2];
1:             }
1:         }
1: 
1:         int sentSoFar = 0;
1: 
1:         while (true) {
1:             int sent = getEndpoint().send(encodeBuffer, sentSoFar, encodedSize - sentSoFar);
1:             if (sent > 0) {
1:                 sentSoFar += sent;
1:                 if ((encodedSize - sentSoFar) == 0) {
1:                     break;
1:                 }
1:             } else {
1:                 LOG.warn("{} failed to send any data from current Message.", this);
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     public void processDeliveryUpdates(AmqpConnection connection) throws IOException {
0:         List<Delivery> toRemove = new ArrayList<Delivery>();
1: 
1:         for (Delivery delivery : pending) {
1:             DeliveryState state = delivery.getRemoteState();
1:             if (state == null) {
1:                 continue;
1:             }
1: 
1:             Outcome outcome = null;
1:             if (state instanceof TransactionalState) {
1:                 LOG.trace("State of delivery is Transactional, retrieving outcome: {}", state);
1:                 outcome = ((TransactionalState) state).getOutcome();
1:             } else if (state instanceof Outcome) {
1:                 outcome = (Outcome) state;
1:             } else {
1:                 LOG.warn("Message send updated with unsupported state: {}", state);
1:                 continue;
1:             }
1: 
1:             AsyncResult request = (AsyncResult) delivery.getContext();
1: 
1:             if (outcome instanceof Accepted) {
0:                 toRemove.add(delivery);
1:                 LOG.trace("Outcome of delivery was accepted: {}", delivery);
0:                 tagGenerator.returnTag(delivery.getTag());
1:                 if (request != null && !request.isComplete()) {
1:                     request.onSuccess();
1:                 }
1:             } else if (outcome instanceof Rejected) {
0:                 Exception remoteError = getRemoteError();
0:                 toRemove.add(delivery);
1:                 LOG.trace("Outcome of delivery was rejected: {}", delivery);
0:                 tagGenerator.returnTag(delivery.getTag());
1:                 if (request != null && !request.isComplete()) {
0:                     request.onFailure(remoteError);
1:                 } else {
0:                     connection.fireClientException(getRemoteError());
1:                 }
1:             } else {
0:                 LOG.warn("Message send updated with unsupported outcome: {}", outcome);
1:             }
1:         }
1: 
1:         pending.removeAll(toRemove);
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return getClass().getSimpleName() + "{ address = " + address + "}";
1:     }
1: }
============================================================================