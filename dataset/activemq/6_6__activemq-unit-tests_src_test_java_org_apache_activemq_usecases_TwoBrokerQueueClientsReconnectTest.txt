1:a677c21: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
4:a677c21:  *
1:a677c21:  * Unless required by applicable law or agreed to in writing, software
1:a677c21:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a677c21:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a677c21:  * See the License for the specific language governing permissions and
1:a677c21:  * limitations under the License.
1:a677c21:  */
1:a677c21: package org.apache.activemq.usecases;
2:a677c21: 
1:74a7a8b: import java.net.URI;
1:af1b232: import java.util.Collection;
1:af1b232: import java.util.Iterator;
1:0018f4a: import java.util.concurrent.CountDownLatch;
1:0018f4a: import java.util.concurrent.Executors;
1:0018f4a: import java.util.concurrent.TimeUnit;
1:0018f4a: import java.util.concurrent.atomic.AtomicBoolean;
1:a677c21: 
1:74a7a8b: import javax.jms.Connection;
1:a677c21: import javax.jms.Destination;
1:a677c21: import javax.jms.Message;
1:a677c21: import javax.jms.MessageConsumer;
1:74a7a8b: import javax.jms.Session;
1:74a7a8b: 
1:74a7a8b: import org.apache.activemq.ActiveMQConnectionFactory;
1:74a7a8b: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:74a7a8b: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:0018f4a: import org.apache.activemq.broker.BrokerPlugin;
1:0018f4a: import org.apache.activemq.broker.BrokerPluginSupport;
1:af1b232: import org.apache.activemq.broker.BrokerService;
1:0018f4a: import org.apache.activemq.broker.ProducerBrokerExchange;
1:af1b232: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:af1b232: import org.apache.activemq.broker.region.policy.PolicyMap;
1:fb0b63e: import org.apache.activemq.command.ActiveMQDestination;
1:af1b232: import org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory;
1:af1b232: import org.apache.activemq.network.NetworkConnector;
1:140ce1b: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:0018f4a: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a677c21: 
1:a677c21: /**
1:4743a20:  *
1:a677c21:  */
1:a677c21: public class TwoBrokerQueueClientsReconnectTest extends JmsMultipleBrokersTestSupport {
1:230a86c:     protected static final int MESSAGE_COUNT = 100; // Best if a factor of 100
1:a677c21:     protected static final int PREFETCH_COUNT = 1;
1:af1b232:     protected static final int NETWORK_PREFETCH = 1;
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TwoBrokerQueueClientsReconnectTest.class);
1:fc00993: 
1:a677c21: 
1:933eb2f:     protected int msgsClient1;
1:933eb2f:     protected int msgsClient2;
1:933eb2f:     protected String broker1;
1:933eb2f:     protected String broker2;
1:a677c21: 
1:a677c21:     public void testClientAReceivesOnly() throws Exception {
1:a677c21:         broker1 = "BrokerA";
1:a677c21:         broker2 = "BrokerB";
1:a677c21: 
1:a677c21:         doOneClientReceivesOnly();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testClientBReceivesOnly() throws Exception {
1:a677c21:         broker1 = "BrokerB";
1:a677c21:         broker2 = "BrokerA";
1:a677c21: 
1:a677c21:         doOneClientReceivesOnly();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void doOneClientReceivesOnly() throws Exception {
1:c8be8aa:         // allow immediate replay back to origin
1:c8be8aa:         applyRateLimitNetworkFilter(0);
1:c8be8aa: 
1:a677c21:         // Bridge brokers
1:a677c21:         bridgeBrokers(broker1, broker2);
1:a677c21:         bridgeBrokers(broker2, broker1);
1:a677c21: 
1:a677c21:         // Run brokers
1:a677c21:         startAllBrokers();
1:a677c21: 
1:a677c21:         // Create queue
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Create consumers
1:a677c21:         MessageConsumer client1 = createConsumer(broker1, dest);
1:a677c21:         MessageConsumer client2 = createConsumer(broker2, dest);
1:a677c21: 
1:a677c21:         // Give clients time to register with broker
3:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Always send messages to broker A
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21: 
1:a677c21:         // Close the second client, messages should be sent to the first client
1:a677c21:         client2.close();
1:a677c21: 
1:a677c21:         // Let the first client receive all messages
1:a677c21:         msgsClient1 += receiveAllMessages(client1);
1:a677c21:         client1.close();
1:a677c21: 
1:a677c21:         // First client should have received 100 messages
1:a677c21:         assertEquals("Client for " + broker1 + " should have receive all messages.", MESSAGE_COUNT, msgsClient1);
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testClientAReceivesOnlyAfterReconnect() throws Exception {
1:a677c21:         broker1 = "BrokerA";
1:a677c21:         broker2 = "BrokerB";
1:a677c21: 
1:a677c21:         doOneClientReceivesOnlyAfterReconnect();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testClientBReceivesOnlyAfterReconnect() throws Exception {
1:a677c21:         broker1 = "BrokerB";
1:a677c21:         broker2 = "BrokerA";
1:a677c21: 
1:a677c21:         doOneClientReceivesOnlyAfterReconnect();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void doOneClientReceivesOnlyAfterReconnect() throws Exception {
1:c8be8aa:         // allow immediate replay back to origin
1:c8be8aa:         applyRateLimitNetworkFilter(0);
1:c8be8aa: 
1:a677c21:         // Bridge brokers
1:a677c21:         bridgeBrokers(broker1, broker2);
1:a677c21:         bridgeBrokers(broker2, broker1);
1:a677c21: 
1:a677c21:         // Run brokers
1:a677c21:         startAllBrokers();
1:a677c21: 
1:a677c21:         // Create queue
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Create first consumer
1:a677c21:         MessageConsumer client1 = createConsumer(broker1, dest);
1:a677c21:         MessageConsumer client2 = createConsumer(broker2, dest);
1:a677c21: 
1:a677c21:         // Give clients time to register with broker
1:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Always send message to broker A
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21: 
1:a677c21:         // Let the first client receive the first 20% of messages
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:a677c21: 
2:a677c21:         // Disconnect the first client
1:a677c21:         client1.close();
1:a677c21: 
1:a677c21:         // Create another client for the first broker
2:a677c21:         client1 = createConsumer(broker1, dest);
1:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Close the second client, messages should be sent to the first client
1:a677c21:         client2.close();
1:a677c21: 
1:a677c21:         // Receive the rest of the messages
1:a677c21:         msgsClient1 += receiveAllMessages(client1);
1:a677c21:         client1.close();
1:a677c21: 
1:a677c21:         // The first client should have received 100 messages
1:a677c21:         assertEquals("Client for " + broker1 + " should have received all messages.", MESSAGE_COUNT, msgsClient1);
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testTwoClientsReceiveClientADisconnects() throws Exception {
1:a677c21:         broker1 = "BrokerA";
1:a677c21:         broker2 = "BrokerB";
1:a677c21: 
1:a677c21:         doTwoClientsReceiveOneClientDisconnects();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testTwoClientsReceiveClientBDisconnects() throws Exception {
1:a677c21:         broker1 = "BrokerB";
1:a677c21:         broker2 = "BrokerA";
1:a677c21: 
1:a677c21:         doTwoClientsReceiveOneClientDisconnects();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void doTwoClientsReceiveOneClientDisconnects() throws Exception {
1:af1b232:         // ensure all message do not flow across the network too quickly
1:af1b232:         applyRateLimitNetworkFilter(0.8 * MESSAGE_COUNT);
1:af1b232: 
1:a677c21:         // Bridge brokers
1:a677c21:         bridgeBrokers(broker1, broker2);
1:a677c21:         bridgeBrokers(broker2, broker1);
1:a677c21: 
1:a677c21:         // Run brokers
1:a677c21:         startAllBrokers();
1:a677c21: 
1:a677c21:         // Create queue
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Create first client
1:a677c21:         MessageConsumer client1 = createConsumer(broker1, dest);
1:a677c21:         MessageConsumer client2 = createConsumer(broker2, dest);
1:a677c21: 
1:a677c21:         // Give clients time to register with broker
1:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Always send messages to broker A
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21: 
1:af1b232:         LOG.info("Let each client receive 20% of the messages - 40% total");
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:a677c21: 
1:a677c21:         // Disconnect the first client
1:a677c21:         client1.close();
1:a677c21: 
1:af1b232:         LOG.info("Let the second client receive the rest of the messages");
1:a677c21:         msgsClient2 += receiveAllMessages(client2);
1:a677c21:         client2.close();
1:a677c21: 
1:a677c21:         // First client should have received 20% of the messages
1:a677c21:         assertEquals("Client for " + broker1 + " should have received 20% of the messages.", (int)(MESSAGE_COUNT * 0.20), msgsClient1);
1:a677c21: 
1:a677c21:         // Second client should have received 80% of the messages
1:a677c21:         assertEquals("Client for " + broker2 + " should have received 80% of the messages.", (int)(MESSAGE_COUNT * 0.80), msgsClient2);
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testTwoClientsReceiveClientAReconnects() throws Exception {
1:a677c21:         broker1 = "BrokerA";
1:a677c21:         broker2 = "BrokerB";
1:a677c21: 
1:a677c21:         doTwoClientsReceiveOneClientReconnects();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void testTwoClientsReceiveClientBReconnects() throws Exception {
1:a677c21:         broker1 = "BrokerB";
1:a677c21:         broker2 = "BrokerA";
1:a677c21: 
1:a677c21:         doTwoClientsReceiveOneClientReconnects();
1:a677c21:     }
1:a677c21: 
1:a677c21:     public void doTwoClientsReceiveOneClientReconnects() throws Exception {
1:af1b232:         // ensure all message do not flow across the network too quickly
1:af1b232:         applyRateLimitNetworkFilter(0.2 * MESSAGE_COUNT);
1:af1b232: 
1:a677c21:         // Bridge brokers
1:a677c21:         bridgeBrokers(broker1, broker2);
1:a677c21:         bridgeBrokers(broker2, broker1);
1:a677c21: 
1:a677c21:         // Run brokers
1:a677c21:         startAllBrokers();
1:a677c21: 
1:a677c21:         // Create queue
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Create the first client
1:a677c21:         MessageConsumer client1 = createConsumer(broker1, dest);
1:a677c21:         MessageConsumer client2 = createConsumer(broker2, dest);
1:a677c21: 
1:a677c21:         // Give clients time to register with broker
1:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Always send messages to broker A
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21: 
2:a677c21:         // Let each client receive 20% of the messages - 40% total
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:a677c21: 
1:af1b232:         LOG.info("msgsClient1=" + msgsClient1);
1:af1b232:         LOG.info("msgsClient2=" + msgsClient2);
1:af1b232: 
1:af1b232:         Thread.sleep(1000);
1:af1b232:         LOG.info("Disconnect the first client");
1:a677c21:         client1.close();
1:a677c21: 
1:af1b232:         LOG.info("Let the second client receive 20% more of the total messages");
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:af1b232: 
1:af1b232:         LOG.info("msgsClient2=" + msgsClient2);
1:a677c21: 
1:a677c21:         // Create another client for broker 1
1:a677c21:         client1 = createConsumer(broker1, dest);
1:af1b232:         Thread.sleep(1000);
1:a677c21: 
1:a677c21:         // Let each client receive 20% of the messages - 40% total
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:a677c21:         client1.close();
1:af1b232:         LOG.info("new consumer addition, msgsClient1=" + msgsClient1);
1:a677c21: 
1:af1b232:         Thread.sleep(2000);
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:a677c21:         client2.close();
1:af1b232:         LOG.info("msgsClient2=" + msgsClient2);
1:a677c21: 
1:a677c21:         // First client should have received 40 messages
1:a677c21:         assertEquals("Client for " + broker1 + " should have received 40% of the messages.", (int)(MESSAGE_COUNT * 0.40), msgsClient1);
1:a677c21: 
1:a677c21:         // Second client should have received 60 messages
1:a677c21:         assertEquals("Client for " + broker2 + " should have received 60% of the messages.", (int)(MESSAGE_COUNT * 0.60), msgsClient2);
1:a677c21:     }
1:a677c21: 
1:af1b232:     private void applyRateLimitNetworkFilter(double rateLimit) {
1:af1b232:         ConditionalNetworkBridgeFilterFactory filterFactory = new ConditionalNetworkBridgeFilterFactory();
1:af1b232:         filterFactory.setReplayWhenNoConsumers(true);
1:af1b232:         filterFactory.setRateLimit((int) rateLimit);
1:af1b232:         filterFactory.setRateDuration(1000);
1:af1b232: 
1:af1b232:         Collection<BrokerItem> brokerList = brokers.values();
1:af1b232:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:af1b232:             BrokerService broker = i.next().broker;
1:af1b232:             broker.getDestinationPolicy().getDefaultEntry().setNetworkBridgeFilterFactory(filterFactory);
1:af1b232:         }
1:af1b232:     }
1:af1b232: 
1:a677c21:     public void testTwoClientsReceiveTwoClientReconnects() throws Exception {
1:af1b232:         // ensure all message do not flow across the network too quickly
1:af1b232:         applyRateLimitNetworkFilter(0.5 * MESSAGE_COUNT);
1:af1b232: 
1:a677c21:         broker1 = "BrokerA";
1:a677c21:         broker2 = "BrokerB";
1:a677c21: 
1:a677c21:         // Bridge brokers
1:a677c21:         bridgeBrokers(broker1, broker2);
1:a677c21:         bridgeBrokers(broker2, broker1);
1:a677c21: 
1:a677c21:         // Run brokers
1:a677c21:         startAllBrokers();
1:a677c21: 
1:a677c21:         // Create queue
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Create the first client
1:a677c21:         MessageConsumer client1 = createConsumer(broker1, dest);
1:a677c21:         MessageConsumer client2 = createConsumer(broker2, dest);
1:a677c21: 
1:a677c21:         // Give clients time to register with broker
1:a677c21:         Thread.sleep(500);
1:a677c21: 
1:a677c21:         // Always send messages to broker A
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21: 
1:a677c21:         // Let each client receive 20% of the messages - 40% total
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:a677c21: 
1:af1b232:         LOG.info("Disconnect both clients");
1:a677c21:         client1.close();
1:a677c21:         client2.close();
1:a677c21: 
1:230a86c:         // Let each client receive 30% more of the total messages - 60% total
1:af1b232:         LOG.info("Serially create another two clients for each broker and consume in turn");
1:af1b232:         client1 = createConsumer(broker1, dest);
1:a677c21:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.30));
1:a677c21:         client1.close();
1:a677c21: 
1:af1b232:         // the close will allow replay or the replay of the remaining messages
1:af1b232:         client2 = createConsumer(broker2, dest);
1:a677c21:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.30));
1:a677c21:         client2.close();
1:a677c21: 
1:a677c21:         // First client should have received 50% of the messages
1:a677c21:         assertEquals("Client for " + broker1 + " should have received 50% of the messages.", (int)(MESSAGE_COUNT * 0.50), msgsClient1);
1:a677c21: 
1:a677c21:         // Second client should have received 50% of the messages
1:a677c21:         assertEquals("Client for " + broker2 + " should have received 50% of the messages.", (int)(MESSAGE_COUNT * 0.50), msgsClient2);
1:a677c21:     }
1:a677c21: 
1:4743a20:     @SuppressWarnings("unchecked")
1:0018f4a:     public void testDuplicateSend() throws Exception {
1:0018f4a:         broker1 = "BrokerA";
1:0018f4a:         broker2 = "BrokerB";
1:0018f4a: 
1:49718ed:         // enable producer audit for the network connector, off by default b/c of interference with composite
1:49718ed:         // dests and virtual topics
1:49718ed:         brokers.get(broker2).broker.getTransportConnectors().get(0).setAuditNetworkProducers(true);
1:0018f4a:         bridgeBrokers(broker1, broker2);
1:0018f4a: 
1:0018f4a:         final AtomicBoolean first = new AtomicBoolean();
1:0018f4a:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1:0018f4a: 
1:0018f4a:         BrokerService brokerService = brokers.get(broker2).broker;
1:0018f4a:         brokerService.setPersistent(true);
1:0018f4a:         brokerService.setDeleteAllMessagesOnStartup(true);
1:0018f4a:         brokerService.setPlugins(new BrokerPlugin[]{
1:0018f4a:                 new BrokerPluginSupport() {
1:0018f4a:                     @Override
1:0018f4a:                     public void send(final ProducerBrokerExchange producerExchange,
1:0018f4a:                                      org.apache.activemq.command.Message messageSend)
1:0018f4a:                             throws Exception {
1:0018f4a:                         super.send(producerExchange, messageSend);
1:0018f4a:                         if (first.compareAndSet(false, true)) {
1:0018f4a:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:0018f4a:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:4743a20:                                 @Override
1:0018f4a:                                 public void run() {
1:0018f4a:                                     try {
1:0018f4a:                                         LOG.info("Waiting for recepit");
1:0018f4a:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:0018f4a:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:0018f4a:                                         producerExchange.getConnectionContext().getConnection().stop();
1:0018f4a:                                     } catch (Exception e) {
1:0018f4a:                                         e.printStackTrace();
1:0018f4a:                                     }
1:0018f4a:                                 }
1:0018f4a:                             });
1:0018f4a:                         }
1:0018f4a:                     }
1:0018f4a:                 }
1:0018f4a:         });
1:0018f4a: 
1:0018f4a:         // Run brokers
1:0018f4a:         startAllBrokers();
1:0018f4a: 
1:49718ed:         waitForBridgeFormation();
1:49718ed: 
1:0018f4a:         // Create queue
1:0018f4a:         Destination dest = createDestination("TEST.FOO", false);
1:0018f4a: 
1:0018f4a:         MessageConsumer client2 = createConsumer(broker2, dest);
1:0018f4a: 
1:0018f4a:         sendMessages("BrokerA", dest, 1);
1:2b1cda1: 
1:0018f4a:         assertEquals("Client got message", 1, receiveExactMessages(client2, 1));
1:0018f4a:         client2.close();
1:0018f4a:         gotMessageLatch.countDown();
1:0018f4a: 
1:0018f4a:         // message still pending on broker1
1:0018f4a:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1:0018f4a: 
1:0018f4a:         client2 = createConsumer(broker2, dest);
1:0018f4a: 
1:0018f4a:         LOG.info("Let the second client receive the rest of the messages");
1:0018f4a:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:0018f4a:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:0018f4a: 
1:0018f4a:         assertEquals("no messages enqueued", 0, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:0018f4a:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:0018f4a:             public boolean isSatisified() throws Exception {
1:0018f4a:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:0018f4a:             }
1:0018f4a:         }));
1:0018f4a:     }
1:2b1cda1: 
1:2b1cda1: 
1:2b1cda1:     @SuppressWarnings("unchecked")
1:2b1cda1:     public void testDuplicateSendWithCursorAudit() throws Exception {
1:2b1cda1:         broker1 = "BrokerA";
1:2b1cda1:         broker2 = "BrokerB";
1:2b1cda1: 
1:2b1cda1:         brokers.get(broker2).broker.getDestinationPolicy().getDefaultEntry().setEnableAudit(true);
1:2b1cda1: 
1:2b1cda1:         bridgeBrokers(broker1, broker2);
1:2b1cda1: 
1:2b1cda1:         final AtomicBoolean first = new AtomicBoolean();
1:2b1cda1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1:2b1cda1: 
1:2b1cda1:         BrokerService brokerService = brokers.get(broker2).broker;
1:2b1cda1:         brokerService.setPersistent(true);
1:2b1cda1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:2b1cda1:         brokerService.setPlugins(new BrokerPlugin[]{
1:2b1cda1:                 new BrokerPluginSupport() {
1:2b1cda1:                     @Override
1:2b1cda1:                     public void send(final ProducerBrokerExchange producerExchange,
1:2b1cda1:                                      org.apache.activemq.command.Message messageSend)
1:2b1cda1:                             throws Exception {
1:2b1cda1:                         super.send(producerExchange, messageSend);
1:2b1cda1:                         if (first.compareAndSet(false, true)) {
1:2b1cda1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:2b1cda1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:2b1cda1:                                 @Override
1:2b1cda1:                                 public void run() {
1:2b1cda1:                                     try {
1:2b1cda1:                                         LOG.info("Waiting for recepit");
1:2b1cda1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:2b1cda1:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:2b1cda1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:2b1cda1:                                     } catch (Exception e) {
1:2b1cda1:                                         e.printStackTrace();
1:2b1cda1:                                     }
1:2b1cda1:                                 }
1:2b1cda1:                             });
1:2b1cda1:                         }
1:2b1cda1:                     }
1:2b1cda1:                 }
1:2b1cda1:         });
1:2b1cda1: 
1:2b1cda1:         // Run brokers
1:2b1cda1:         startAllBrokers();
1:2b1cda1: 
1:2b1cda1:         waitForBridgeFormation();
1:2b1cda1: 
1:2b1cda1:         // Create queue
1:2b1cda1:         Destination dest = createDestination("TEST.FOO", false);
1:2b1cda1: 
1:2b1cda1:         MessageConsumer client2 = createConsumer(broker2, dest);
1:2b1cda1: 
1:2b1cda1:         sendMessages("BrokerA", dest, 1);
1:2b1cda1: 
1:2b1cda1:         assertEquals("Client got message", 1, receiveExactMessages(client2, 1));
1:2b1cda1:         client2.close();
1:2b1cda1:         gotMessageLatch.countDown();
1:2b1cda1: 
1:2b1cda1:         // message still pending on broker1
1:2b1cda1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1:2b1cda1: 
1:2b1cda1:         client2 = createConsumer(broker2, dest);
1:fb0b63e: 
1:2b1cda1:         LOG.info("Let the second client receive the rest of the messages");
1:2b1cda1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:2b1cda1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:0018f4a: 
1:2b1cda1:         assertEquals("1 messages enqueued on dlq", 1, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:2b1cda1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:2b1cda1:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:2b1cda1:             }
1:2b1cda1:         }));
1:2b1cda1:     }
1:2b1cda1: 
1:4743a20:     @SuppressWarnings("unchecked")
1:fb0b63e:     public void testDuplicateSendWithNoAuditEnqueueCountStat() throws Exception {
1:fb0b63e:         broker1 = "BrokerA";
1:fb0b63e:         broker2 = "BrokerB";
1:fb0b63e: 
1:fb0b63e:         NetworkConnector networkConnector = bridgeBrokers(broker1, broker2);
1:2b1cda1: 
1:fb0b63e:         final AtomicBoolean first = new AtomicBoolean();
1:fb0b63e:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1:fb0b63e: 
1:fb0b63e:         BrokerService brokerService = brokers.get(broker2).broker;
1:fb0b63e:         brokerService.setPersistent(true);
1:fb0b63e:         brokerService.setDeleteAllMessagesOnStartup(true);
1:140ce1b:         // disable concurrent dispatch otherwise store duplicate suppression will be skipped b/c cursor audit is already
1:140ce1b:         // disabled so verification of stats will fail - ie: duplicate will be dispatched
1:140ce1b:         ((KahaDBPersistenceAdapter)brokerService.getPersistenceAdapter()).setConcurrentStoreAndDispatchQueues(false);
1:fb0b63e:         brokerService.setPlugins(new BrokerPlugin[]{
1:fb0b63e:                 new BrokerPluginSupport() {
1:2b1cda1:                     @Override
1:fb0b63e:                     public void send(final ProducerBrokerExchange producerExchange,
1:fb0b63e:                                      org.apache.activemq.command.Message messageSend)
1:fb0b63e:                             throws Exception {
1:fb0b63e:                         super.send(producerExchange, messageSend);
1:fb0b63e:                         if (first.compareAndSet(false, true)) {
1:fb0b63e:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:fb0b63e:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:fb0b63e:                                 @Override
1:fb0b63e:                                 public void run() {
1:fb0b63e:                                     try {
1:fb0b63e:                                         LOG.info("Waiting for recepit");
1:fb0b63e:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:fb0b63e:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:fb0b63e:                                         producerExchange.getConnectionContext().getConnection().stop();
1:fb0b63e:                                     } catch (Exception e) {
1:fb0b63e:                                         e.printStackTrace();
1:fb0b63e:                                     }
1:fb0b63e:                                 }
1:fb0b63e:                             });
1:fb0b63e:                         }
1:fb0b63e:                     }
1:fb0b63e:                 }
1:fb0b63e:         });
1:fb0b63e: 
1:fb0b63e:         // Create queue
1:fb0b63e:         ActiveMQDestination dest = createDestination("TEST.FOO", false);
1:fb0b63e: 
1:fb0b63e:         // statically include our destination
1:fb0b63e:         networkConnector.addStaticallyIncludedDestination(dest);
1:2b1cda1: 
1:fb0b63e:         // Run brokers
1:fb0b63e:         startAllBrokers();
1:fb0b63e: 
1:fb0b63e:         waitForBridgeFormation();
1:fb0b63e: 
1:fb0b63e:         sendMessages("BrokerA", dest, 1);
1:fb0b63e: 
1:fb0b63e:         // wait for broker2 to get the initial forward
1:fb0b63e:         Wait.waitFor(new Wait.Condition(){
1:fb0b63e:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:fb0b63e:                 return brokers.get(broker2).broker.getAdminView().getTotalMessageCount() == 1;
1:fb0b63e:             }
1:fb0b63e:         });
1:fb0b63e: 
1:fb0b63e:         // message still pending on broker1
1:fb0b63e:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1:fb0b63e: 
1:fb0b63e:         // allow the bridge to be shutdown and restarted
1:fb0b63e:         gotMessageLatch.countDown();
1:fb0b63e: 
1:fb0b63e: 
1:fb0b63e:         // verify message is forwarded after restart
1:fb0b63e:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:fb0b63e:             @Override
1:fb0b63e:             public boolean isSatisified() throws Exception {
1:fb0b63e:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:fb0b63e:             }
1:fb0b63e:         }));
1:fb0b63e: 
1:fb0b63e:         assertEquals("one messages pending", 1, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:fb0b63e:         assertEquals("one messages enqueued", 1, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getEnqueues().getCount());
1:fb0b63e:     }
1:2b1cda1: 
1:2b1cda1:     @SuppressWarnings("unchecked")
1:2b1cda1:     public void testDuplicateSendWithNoAuditEnqueueCountStatConcurrentStoreAndDispatch() throws Exception {
1:2b1cda1:         broker1 = "BrokerA";
1:2b1cda1:         broker2 = "BrokerB";
1:2b1cda1: 
1:2b1cda1:         NetworkConnector networkConnector = bridgeBrokers(broker1, broker2);
1:2b1cda1: 
1:2b1cda1:         final AtomicBoolean first = new AtomicBoolean();
1:2b1cda1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1:2b1cda1: 
1:2b1cda1:         BrokerService brokerService = brokers.get(broker2).broker;
1:2b1cda1:         brokerService.setPersistent(true);
1:2b1cda1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:2b1cda1:         brokerService.setPlugins(new BrokerPlugin[]{
1:2b1cda1:                 new BrokerPluginSupport() {
1:2b1cda1:                     @Override
1:2b1cda1:                     public void send(final ProducerBrokerExchange producerExchange,
1:2b1cda1:                                      org.apache.activemq.command.Message messageSend)
1:2b1cda1:                             throws Exception {
1:2b1cda1:                         super.send(producerExchange, messageSend);
1:2b1cda1:                         if (first.compareAndSet(false, true)) {
1:2b1cda1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:2b1cda1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:0018f4a:                                 @Override
1:2b1cda1:                                 public void run() {
1:2b1cda1:                                     try {
1:2b1cda1:                                         LOG.info("Waiting for recepit");
1:2b1cda1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:2b1cda1:                                         LOG.info("Stopping connection post send and receive by local queue over bridge");
1:2b1cda1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:2b1cda1:                                     } catch (Exception e) {
1:2b1cda1:                                         e.printStackTrace();
1:2b1cda1:                                     }
1:2b1cda1:                                 }
1:2b1cda1:                             });
1:2b1cda1:                         }
1:2b1cda1:                     }
1:2b1cda1:                 }
1:2b1cda1:         });
1:2b1cda1: 
1:2b1cda1:         // Create queue
1:2b1cda1:         final ActiveMQDestination dest = createDestination("TEST.FOO", false);
1:2b1cda1: 
1:2b1cda1:         // statically include our destination
1:2b1cda1:         networkConnector.addStaticallyIncludedDestination(dest);
1:2b1cda1: 
1:2b1cda1:         // Run brokers
1:2b1cda1:         startAllBrokers();
1:2b1cda1: 
1:2b1cda1:         waitForBridgeFormation();
1:2b1cda1: 
1:2b1cda1:         sendMessages("BrokerA", dest, 1);
1:2b1cda1: 
1:2b1cda1:         // wait for broker2 to get the initial forward
1:2b1cda1:         Wait.waitFor(new Wait.Condition(){
1:2b1cda1:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return brokers.get(broker2).broker.getAdminView().getTotalMessageCount() == 1;
1:2b1cda1:             }
1:2b1cda1:         });
1:2b1cda1: 
1:2b1cda1:         // message still pending on broker1
1:2b1cda1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1:2b1cda1: 
1:2b1cda1:         // allow the bridge to be shutdown and restarted
1:2b1cda1:         gotMessageLatch.countDown();
1:fb0b63e: 
1:fb0b63e: 
1:2b1cda1:         // verify message is forwarded after restart
1:2b1cda1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:2b1cda1:             @Override
1:fb0b63e:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:2b1cda1:             }
1:2b1cda1:         }));
1:0018f4a: 
1:2b1cda1:         // duplicate ready to dispatch
1:2b1cda1:         assertEquals("one messages pending", 2, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:2b1cda1:         assertEquals("one messages enqueued", 2, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getEnqueues().getCount());
1:2b1cda1:         assertEquals("one messages", 2, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount());
1:2b1cda1: 
1:2b1cda1:         // only one message available in the store...
1:2b1cda1: 
1:2b1cda1:         Connection conn = createConnection(broker2);
1:2b1cda1:         conn.start();
1:2b1cda1:         Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:2b1cda1:         MessageConsumer messageConsumer = sess.createConsumer(dest);
1:2b1cda1:         assertEquals("Client got message", 1, receiveExactMessages(messageConsumer, 1));
1:2b1cda1:         messageConsumer.close(); // no ack
1:2b1cda1: 
1:2b1cda1:         assertTrue("1 messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:2b1cda1:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return 1 == brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount();
1:2b1cda1:             }
1:2b1cda1:         }));
1:2b1cda1: 
1:2b1cda1:         // restart to validate message not acked due to duplicate processing
1:2b1cda1:         // consume again and ack
1:2b1cda1:         destroyAllBrokers();
1:2b1cda1: 
1:2b1cda1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerB?useJmx=true&advisorySupport=false")).start();
1:2b1cda1: 
1:2b1cda1:         assertEquals("Receive after restart and previous receive unacked", 1, receiveExactMessages(createConsumer(broker2, dest), 1));
1:2b1cda1: 
1:2b1cda1:         assertTrue("no messages enqueued", Wait.waitFor(new Wait.Condition() {
1:2b1cda1:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return 0 == brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount();
1:2b1cda1:             }
1:2b1cda1:         }));
1:2b1cda1: 
1:2b1cda1:         final ActiveMQDestination dlq = createDestination("ActiveMQ.DLQ", false);
1:2b1cda1:         assertTrue("one message still on dlq", Wait.waitFor(new Wait.Condition() {
1:2b1cda1:             @Override
1:2b1cda1:             public boolean isSatisified() throws Exception {
1:2b1cda1:                 return 1 == brokers.get(broker2).broker.getDestination(dlq).getDestinationStatistics().getMessages().getCount();
1:2b1cda1:             }
1:2b1cda1:         }));
1:2b1cda1: 
1:2b1cda1:     }
1:2b1cda1: 
1:a677c21:     protected int receiveExactMessages(MessageConsumer consumer, int msgCount) throws Exception {
1:a677c21:         Message msg;
1:a677c21:         int i;
1:230a86c:         for (i = 0; i < msgCount; i++) {
1:af1b232:             msg = consumer.receive(4000);
1:a677c21:             if (msg == null) {
1:fc00993:                 LOG.error("Consumer failed to receive exactly " + msgCount + " messages. Actual messages received is: " + i);
1:a677c21:                 break;
1:a677c21:             }
1:a677c21:         }
1:a677c21: 
1:a677c21:         return i;
1:a677c21:     }
1:a677c21: 
1:a677c21:     protected int receiveAllMessages(MessageConsumer consumer) throws Exception {
1:a677c21:         int msgsReceived = 0;
1:a677c21: 
1:a677c21:         Message msg;
1:a677c21:         do {
2:a677c21:             msg = consumer.receive(1000);
1:a677c21:             if (msg != null) {
1:a677c21:                 msgsReceived++;
1:a677c21:             }
1:a677c21:         } while (msg != null);
1:a677c21: 
1:a677c21:         return msgsReceived;
1:a677c21:     }
1:a677c21: 
1:4743a20:     @Override
1:a677c21:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {
1:a677c21:         Connection conn = createConnection(brokerName);
1:a677c21:         conn.start();
1:a677c21:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a677c21:         return sess.createConsumer(dest);
1:a677c21:     }
1:a677c21: 
1:4743a20:     @Override
1:af1b232:     protected void configureBroker(BrokerService broker) {
1:af1b232:         PolicyMap policyMap = new PolicyMap();
1:af1b232:         PolicyEntry defaultEntry = new PolicyEntry();
1:2b1cda1:         defaultEntry.setExpireMessagesPeriod(0);
1:af1b232:         defaultEntry.setEnableAudit(false);
1:af1b232:         policyMap.setDefaultEntry(defaultEntry);
1:af1b232:         broker.setDestinationPolicy(policyMap);
1:af1b232:     }
1:af1b232: 
1:4743a20:     @Override
1:af1b232:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL, boolean conduit, boolean failover) throws Exception {
1:af1b232:         NetworkConnector nc = super.bridgeBrokers(localBroker,remoteBroker, dynamicOnly, networkTTL, conduit, failover);
1:af1b232:         nc.setPrefetchSize(NETWORK_PREFETCH);
1:af1b232:         nc.setDecreaseNetworkConsumerPriority(true);
1:af1b232:         return nc;
1:af1b232:     }
1:af1b232: 
1:4743a20:     @Override
1:a677c21:     public void setUp() throws Exception {
1:a677c21:         super.setAutoFail(true);
1:a677c21:         super.setUp();
1:2b1cda1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerA?persistent=false&useJmx=true"));
1:2b1cda1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerB?persistent=false&useJmx=true"));
1:a677c21: 
1:a677c21:         // Configure broker connection factory
1:933eb2f:         ActiveMQConnectionFactory factoryA;
1:933eb2f:         ActiveMQConnectionFactory factoryB;
1:a677c21:         factoryA = (ActiveMQConnectionFactory)getConnectionFactory("BrokerA");
1:a677c21:         factoryB = (ActiveMQConnectionFactory)getConnectionFactory("BrokerB");
1:a677c21: 
1:a677c21:         // Set prefetch policy
1:a677c21:         ActiveMQPrefetchPolicy policy = new ActiveMQPrefetchPolicy();
1:a677c21:         policy.setAll(PREFETCH_COUNT);
1:a677c21: 
1:a677c21:         factoryA.setPrefetchPolicy(policy);
1:a677c21:         factoryB.setPrefetchPolicy(policy);
1:a677c21: 
1:2b1cda1:         factoryA.setWatchTopicAdvisories(false);
1:2b1cda1:         factoryB.setWatchTopicAdvisories(false);
1:a677c21:         msgsClient1 = 0;
1:a677c21:         msgsClient2 = 0;
1:a677c21:     }
1:a677c21: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:2b1cda1
/////////////////////////////////////////////////////////////////////////
1: 
1:     @SuppressWarnings("unchecked")
1:     public void testDuplicateSendWithCursorAudit() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         brokers.get(broker2).broker.getDestinationPolicy().getDefaultEntry().setEnableAudit(true);
1: 
1:         bridgeBrokers(broker1, broker2);
1: 
1:         final AtomicBoolean first = new AtomicBoolean();
1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1: 
1:         BrokerService brokerService = brokers.get(broker2).broker;
1:         brokerService.setPersistent(true);
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setPlugins(new BrokerPlugin[]{
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void send(final ProducerBrokerExchange producerExchange,
1:                                      org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         super.send(producerExchange, messageSend);
1:                         if (first.compareAndSet(false, true)) {
1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 @Override
1:                                 public void run() {
1:                                     try {
1:                                         LOG.info("Waiting for recepit");
1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         waitForBridgeFormation();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         sendMessages("BrokerA", dest, 1);
1: 
1:         assertEquals("Client got message", 1, receiveExactMessages(client2, 1));
1:         client2.close();
1:         gotMessageLatch.countDown();
1: 
1:         // message still pending on broker1
1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1: 
1:         client2 = createConsumer(broker2, dest);
1: 
1:         LOG.info("Let the second client receive the rest of the messages");
1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1: 
1:         assertEquals("1 messages enqueued on dlq", 1, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:             }
1:         }));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1:     public void testDuplicateSendWithNoAuditEnqueueCountStatConcurrentStoreAndDispatch() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         NetworkConnector networkConnector = bridgeBrokers(broker1, broker2);
1: 
1:         final AtomicBoolean first = new AtomicBoolean();
1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1: 
1:         BrokerService brokerService = brokers.get(broker2).broker;
1:         brokerService.setPersistent(true);
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setPlugins(new BrokerPlugin[]{
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void send(final ProducerBrokerExchange producerExchange,
1:                                      org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         super.send(producerExchange, messageSend);
1:                         if (first.compareAndSet(false, true)) {
1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 @Override
1:                                 public void run() {
1:                                     try {
1:                                         LOG.info("Waiting for recepit");
1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:                                         LOG.info("Stopping connection post send and receive by local queue over bridge");
1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1: 
1:         // Create queue
1:         final ActiveMQDestination dest = createDestination("TEST.FOO", false);
1: 
1:         // statically include our destination
1:         networkConnector.addStaticallyIncludedDestination(dest);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         waitForBridgeFormation();
1: 
1:         sendMessages("BrokerA", dest, 1);
1: 
1:         // wait for broker2 to get the initial forward
1:         Wait.waitFor(new Wait.Condition(){
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokers.get(broker2).broker.getAdminView().getTotalMessageCount() == 1;
1:             }
1:         });
1: 
1:         // message still pending on broker1
1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1: 
1:         // allow the bridge to be shutdown and restarted
1:         gotMessageLatch.countDown();
1: 
1: 
1:         // verify message is forwarded after restart
1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:             }
1:         }));
1: 
1:         // duplicate ready to dispatch
1:         assertEquals("one messages pending", 2, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:         assertEquals("one messages enqueued", 2, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals("one messages", 2, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount());
1: 
1:         // only one message available in the store...
1: 
1:         Connection conn = createConnection(broker2);
1:         conn.start();
1:         Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer messageConsumer = sess.createConsumer(dest);
1:         assertEquals("Client got message", 1, receiveExactMessages(messageConsumer, 1));
1:         messageConsumer.close(); // no ack
1: 
1:         assertTrue("1 messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 1 == brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount();
1:             }
1:         }));
1: 
1:         // restart to validate message not acked due to duplicate processing
1:         // consume again and ack
1:         destroyAllBrokers();
1: 
1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerB?useJmx=true&advisorySupport=false")).start();
1: 
1:         assertEquals("Receive after restart and previous receive unacked", 1, receiveExactMessages(createConsumer(broker2, dest), 1));
1: 
1:         assertTrue("no messages enqueued", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getMessages().getCount();
1:             }
1:         }));
1: 
1:         final ActiveMQDestination dlq = createDestination("ActiveMQ.DLQ", false);
1:         assertTrue("one message still on dlq", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 1 == brokers.get(broker2).broker.getDestination(dlq).getDestinationStatistics().getMessages().getCount();
1:             }
1:         }));
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         defaultEntry.setExpireMessagesPeriod(0);
/////////////////////////////////////////////////////////////////////////
1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerA?persistent=false&useJmx=true"));
1:         createBroker(new URI("broker:(tcp://localhost:0)/BrokerB?persistent=false&useJmx=true"));
/////////////////////////////////////////////////////////////////////////
1:         factoryA.setWatchTopicAdvisories(false);
1:         factoryB.setWatchTopicAdvisories(false);
commit:140ce1b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:         // disable concurrent dispatch otherwise store duplicate suppression will be skipped b/c cursor audit is already
1:         // disabled so verification of stats will fail - ie: duplicate will be dispatched
1:         ((KahaDBPersistenceAdapter)brokerService.getPersistenceAdapter()).setConcurrentStoreAndDispatchQueues(false);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:fb0b63e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     public void testDuplicateSendWithNoAuditEnqueueCountStat() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         NetworkConnector networkConnector = bridgeBrokers(broker1, broker2);
1: 
1:         final AtomicBoolean first = new AtomicBoolean();
1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1: 
1:         BrokerService brokerService = brokers.get(broker2).broker;
1:         brokerService.setPersistent(true);
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setPlugins(new BrokerPlugin[]{
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void send(final ProducerBrokerExchange producerExchange,
1:                                      org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         super.send(producerExchange, messageSend);
1:                         if (first.compareAndSet(false, true)) {
1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 public void run() {
1:                                     try {
1:                                         LOG.info("Waiting for recepit");
1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1: 
1:         // Create queue
1:         ActiveMQDestination dest = createDestination("TEST.FOO", false);
1: 
1:         // statically include our destination
1:         networkConnector.addStaticallyIncludedDestination(dest);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         waitForBridgeFormation();
1: 
1:         sendMessages("BrokerA", dest, 1);
1: 
1:         // wait for broker2 to get the initial forward
1:         Wait.waitFor(new Wait.Condition(){
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokers.get(broker2).broker.getAdminView().getTotalMessageCount() == 1;
1:             }
1:         });
1: 
1:         // message still pending on broker1
1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1: 
1:         // allow the bridge to be shutdown and restarted
1:         gotMessageLatch.countDown();
1: 
1: 
1:         // verify message is forwarded after restart
1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:             }
1:         }));
1: 
1:         assertEquals("one messages pending", 1, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:         assertEquals("one messages enqueued", 1, brokers.get(broker2).broker.getDestination(dest).getDestinationStatistics().getEnqueues().getCount());
1:     }
1: 
commit:49718ed
/////////////////////////////////////////////////////////////////////////
1:         // enable producer audit for the network connector, off by default b/c of interference with composite
1:         // dests and virtual topics
1:         brokers.get(broker2).broker.getTransportConnectors().get(0).setAuditNetworkProducers(true);
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
1: 
commit:0018f4a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerPluginSupport;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:     public void testDuplicateSend() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         bridgeBrokers(broker1, broker2);
1: 
1:         final AtomicBoolean first = new AtomicBoolean();
1:         final CountDownLatch gotMessageLatch = new CountDownLatch(1);
1: 
1:         BrokerService brokerService = brokers.get(broker2).broker;
1:         brokerService.setPersistent(true);
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setPlugins(new BrokerPlugin[]{
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void send(final ProducerBrokerExchange producerExchange,
1:                                      org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         super.send(producerExchange, messageSend);
1:                         if (first.compareAndSet(false, true)) {
1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 public void run() {
1:                                     try {
1:                                         LOG.info("Waiting for recepit");
1:                                         assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));
1:                                         LOG.info("Stopping connection post send and receive and multiple producers");
1:                                         producerExchange.getConnectionContext().getConnection().stop();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         sendMessages("BrokerA", dest, 1);
1: 
1:         assertEquals("Client got message", 1, receiveExactMessages(client2, 1));
1:         client2.close();
1:         gotMessageLatch.countDown();
1: 
1:         // message still pending on broker1
1:         assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());
1: 
1:         client2 = createConsumer(broker2, dest);
1: 
1:         LOG.info("Let the second client receive the rest of the messages");
1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1:         assertEquals("no duplicate message", 0, receiveAllMessages(client2));
1: 
1:         assertEquals("no messages enqueued", 0, brokers.get(broker2).broker.getAdminView().getTotalMessageCount());
1:         assertTrue("no messages enqueued on origin", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == brokers.get(broker1).broker.getAdminView().getTotalMessageCount();
1:             }
1:         }));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         createBroker(new URI("broker:(tcp://localhost:61616)/BrokerA?persistent=false&useJmx=true"));
0:         createBroker(new URI("broker:(tcp://localhost:61617)/BrokerB?persistent=false&useJmx=true"));
commit:c8be8aa
/////////////////////////////////////////////////////////////////////////
1:         // allow immediate replay back to origin
1:         applyRateLimitNetworkFilter(0);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // allow immediate replay back to origin
1:         applyRateLimitNetworkFilter(0);
1: 
commit:af1b232
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory;
1: import org.apache.activemq.network.NetworkConnector;
/////////////////////////////////////////////////////////////////////////
1:     protected static final int NETWORK_PREFETCH = 1;
/////////////////////////////////////////////////////////////////////////
1:         // ensure all message do not flow across the network too quickly
1:         applyRateLimitNetworkFilter(0.8 * MESSAGE_COUNT);
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Let each client receive 20% of the messages - 40% total");
1:         LOG.info("Let the second client receive the rest of the messages");
/////////////////////////////////////////////////////////////////////////
1:         // ensure all message do not flow across the network too quickly
1:         applyRateLimitNetworkFilter(0.2 * MESSAGE_COUNT);
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("msgsClient1=" + msgsClient1);
1:         LOG.info("msgsClient2=" + msgsClient2);
1: 
1:         Thread.sleep(1000);
1:         LOG.info("Disconnect the first client");
1:         LOG.info("Let the second client receive 20% more of the total messages");
1:         LOG.info("msgsClient2=" + msgsClient2);
1: 
1:         Thread.sleep(1000);
1:         LOG.info("new consumer addition, msgsClient1=" + msgsClient1);
1:         Thread.sleep(2000);
1:         LOG.info("msgsClient2=" + msgsClient2);
/////////////////////////////////////////////////////////////////////////
1:     private void applyRateLimitNetworkFilter(double rateLimit) {
1:         ConditionalNetworkBridgeFilterFactory filterFactory = new ConditionalNetworkBridgeFilterFactory();
1:         filterFactory.setReplayWhenNoConsumers(true);
1:         filterFactory.setRateLimit((int) rateLimit);
1:         filterFactory.setRateDuration(1000);
1: 
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             broker.getDestinationPolicy().getDefaultEntry().setNetworkBridgeFilterFactory(filterFactory);
1:         }
1:     }
1: 
1:         // ensure all message do not flow across the network too quickly
1:         applyRateLimitNetworkFilter(0.5 * MESSAGE_COUNT);
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Disconnect both clients");
1:         LOG.info("Serially create another two clients for each broker and consume in turn");
1:         client1 = createConsumer(broker1, dest);
1:         // the close will allow replay or the replay of the remaining messages
1:         client2 = createConsumer(broker2, dest);
/////////////////////////////////////////////////////////////////////////
1:             msg = consumer.receive(4000);
/////////////////////////////////////////////////////////////////////////
1:     protected void configureBroker(BrokerService broker) {
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setEnableAudit(false);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         broker.setDestinationPolicy(policyMap);
1:     }
1: 
1:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL, boolean conduit, boolean failover) throws Exception {
1:         NetworkConnector nc = super.bridgeBrokers(localBroker,remoteBroker, dynamicOnly, networkTTL, conduit, failover);
1:         nc.setPrefetchSize(NETWORK_PREFETCH);
1:         nc.setDecreaseNetworkConsumerPriority(true);
1:         return nc;
1:     }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     protected int msgsClient1;
1:     protected int msgsClient2;
1:     protected String broker1;
1:     protected String broker2;
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory factoryA;
1:         ActiveMQConnectionFactory factoryB;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TwoBrokerQueueClientsReconnectTest.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Consumer failed to receive exactly " + msgCount + " messages. Actual messages received is: " + i);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import javax.jms.Connection;
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:     protected static final int MESSAGE_COUNT = 100; // Best if a factor of 100
/////////////////////////////////////////////////////////////////////////
1:         // Let each client receive 30% more of the total messages - 60% total
/////////////////////////////////////////////////////////////////////////
1:         for (i = 0; i < msgCount; i++) {
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TwoBrokerQueueClientsReconnectTest.class);
author:James Strachan
-------------------------------------------------------------------------------
commit:b19f17c
/////////////////////////////////////////////////////////////////////////
0:                 log.error("Consumer failed to receive exactly " + msgCount + " messages. Actual messages received is: " + i);
commit:a677c21
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
0: import org.apache.activemq.JmsMultipleBrokersTestSupport;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: 
1: import javax.jms.Destination;
1: import javax.jms.Message;
0: import javax.jms.Connection;
0: import javax.jms.Session;
1: import javax.jms.MessageConsumer;
0: import java.net.URI;
1: 
1: /**
0:  * @version $Revision: 1.1.1.1 $
1:  */
1: public class TwoBrokerQueueClientsReconnectTest extends JmsMultipleBrokersTestSupport {
0:     protected static final int MESSAGE_COUNT  = 100; // Best if a factor of 100
1:     protected static final int PREFETCH_COUNT = 1;
1: 
0:     protected int msgsClient1, msgsClient2;
0:     protected String broker1, broker2;
1: 
1:     public void testClientAReceivesOnly() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         doOneClientReceivesOnly();
1:     }
1: 
1:     public void testClientBReceivesOnly() throws Exception {
1:         broker1 = "BrokerB";
1:         broker2 = "BrokerA";
1: 
1:         doOneClientReceivesOnly();
1:     }
1: 
1:     public void doOneClientReceivesOnly() throws Exception {
1:         // Bridge brokers
1:         bridgeBrokers(broker1, broker2);
1:         bridgeBrokers(broker2, broker1);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Create consumers
1:         MessageConsumer client1 = createConsumer(broker1, dest);
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         // Give clients time to register with broker
1:         Thread.sleep(500);
1: 
1:         // Always send messages to broker A
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Close the second client, messages should be sent to the first client
1:         client2.close();
1: 
1:         // Let the first client receive all messages
1:         msgsClient1 += receiveAllMessages(client1);
1:         client1.close();
1: 
1:         // First client should have received 100 messages
1:         assertEquals("Client for " + broker1 + " should have receive all messages.", MESSAGE_COUNT, msgsClient1);
1:     }
1: 
1:     public void testClientAReceivesOnlyAfterReconnect() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         doOneClientReceivesOnlyAfterReconnect();
1:     }
1: 
1:     public void testClientBReceivesOnlyAfterReconnect() throws Exception {
1:         broker1 = "BrokerB";
1:         broker2 = "BrokerA";
1: 
1:         doOneClientReceivesOnlyAfterReconnect();
1:     }
1: 
1:     public void doOneClientReceivesOnlyAfterReconnect() throws Exception {
1:         // Bridge brokers
1:         bridgeBrokers(broker1, broker2);
1:         bridgeBrokers(broker2, broker1);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Create first consumer
1:         MessageConsumer client1 = createConsumer(broker1, dest);
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         // Give clients time to register with broker
1:         Thread.sleep(500);
1: 
1:         // Always send message to broker A
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Let the first client receive the first 20% of messages
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1: 
1:         // Disconnect the first client
1:         client1.close();
1: 
1:         // Create another client for the first broker
1:         client1 = createConsumer(broker1, dest);
1:         Thread.sleep(500);
1: 
1:         // Close the second client, messages should be sent to the first client
1:         client2.close();
1: 
1:         // Receive the rest of the messages
1:         msgsClient1 += receiveAllMessages(client1);
1:         client1.close();
1: 
1:         // The first client should have received 100 messages
1:         assertEquals("Client for " + broker1 + " should have received all messages.", MESSAGE_COUNT, msgsClient1);
1:     }
1: 
1:     public void testTwoClientsReceiveClientADisconnects() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         doTwoClientsReceiveOneClientDisconnects();
1:     }
1: 
1:     public void testTwoClientsReceiveClientBDisconnects() throws Exception {
1:         broker1 = "BrokerB";
1:         broker2 = "BrokerA";
1: 
1:         doTwoClientsReceiveOneClientDisconnects();
1:     }
1: 
1:     public void doTwoClientsReceiveOneClientDisconnects() throws Exception {
1:         // Bridge brokers
1:         bridgeBrokers(broker1, broker2);
1:         bridgeBrokers(broker2, broker1);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Create first client
1:         MessageConsumer client1 = createConsumer(broker1, dest);
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         // Give clients time to register with broker
1:         Thread.sleep(500);
1: 
1:         // Always send messages to broker A
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Let each client receive 20% of the messages - 40% total
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1: 
1:         // Disconnect the first client
1:         client1.close();
1: 
0:         // Let the second client receive the rest of the messages
1:         msgsClient2 += receiveAllMessages(client2);
1:         client2.close();
1: 
1:         // First client should have received 20% of the messages
1:         assertEquals("Client for " + broker1 + " should have received 20% of the messages.", (int)(MESSAGE_COUNT * 0.20), msgsClient1);
1: 
1:         // Second client should have received 80% of the messages
1:         assertEquals("Client for " + broker2 + " should have received 80% of the messages.", (int)(MESSAGE_COUNT * 0.80), msgsClient2);
1:     }
1: 
1:     public void testTwoClientsReceiveClientAReconnects() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         doTwoClientsReceiveOneClientReconnects();
1:     }
1: 
1:     public void testTwoClientsReceiveClientBReconnects() throws Exception {
1:         broker1 = "BrokerB";
1:         broker2 = "BrokerA";
1: 
1:         doTwoClientsReceiveOneClientReconnects();
1:     }
1: 
1:     public void doTwoClientsReceiveOneClientReconnects() throws Exception {
1:         // Bridge brokers
1:         bridgeBrokers(broker1, broker2);
1:         bridgeBrokers(broker2, broker1);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Create the first client
1:         MessageConsumer client1 = createConsumer(broker1, dest);
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         // Give clients time to register with broker
1:         Thread.sleep(500);
1: 
1:         // Always send messages to broker A
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Let each client receive 20% of the messages - 40% total
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1: 
1:         // Disconnect the first client
1:         client1.close();
1: 
0:         // Let the second client receive 20% more of the total messages
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1: 
1:         // Create another client for broker 1
1:         client1 = createConsumer(broker1, dest);
1:         Thread.sleep(500);
1: 
1:         // Let each client receive 20% of the messages - 40% total
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:         client1.close();
1: 
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1:         client2.close();
1: 
1:         // First client should have received 40 messages
1:         assertEquals("Client for " + broker1 + " should have received 40% of the messages.", (int)(MESSAGE_COUNT * 0.40), msgsClient1);
1: 
1:         // Second client should have received 60 messages
1:         assertEquals("Client for " + broker2 + " should have received 60% of the messages.", (int)(MESSAGE_COUNT * 0.60), msgsClient2);
1:     }
1: 
1:     public void testTwoClientsReceiveTwoClientReconnects() throws Exception {
1:         broker1 = "BrokerA";
1:         broker2 = "BrokerB";
1: 
1:         // Bridge brokers
1:         bridgeBrokers(broker1, broker2);
1:         bridgeBrokers(broker2, broker1);
1: 
1:         // Run brokers
1:         startAllBrokers();
1: 
1:         // Create queue
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Create the first client
1:         MessageConsumer client1 = createConsumer(broker1, dest);
1:         MessageConsumer client2 = createConsumer(broker2, dest);
1: 
1:         // Give clients time to register with broker
1:         Thread.sleep(500);
1: 
1:         // Always send messages to broker A
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Let each client receive 20% of the messages - 40% total
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));
1: 
0:         // Disconnect both clients
1:         client1.close();
1:         client2.close();
1: 
0:         // Create another two clients for each broker
1:         client1 = createConsumer(broker1, dest);
0:         client2 = createConsumer(broker2, dest);
1:         Thread.sleep(500);
1: 
0:         // Let each client receive 30% more of the total messages  - 60% total
1:         msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.30));
1:         client1.close();
1: 
1:         msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.30));
1:         client2.close();
1: 
1:         // First client should have received 50% of the messages
1:         assertEquals("Client for " + broker1 + " should have received 50% of the messages.", (int)(MESSAGE_COUNT * 0.50), msgsClient1);
1: 
1:         // Second client should have received 50% of the messages
1:         assertEquals("Client for " + broker2 + " should have received 50% of the messages.", (int)(MESSAGE_COUNT * 0.50), msgsClient2);
1:     }
1: 
1:     protected int receiveExactMessages(MessageConsumer consumer, int msgCount) throws Exception {
1:         Message msg;
1:         int i;
0:         for (i=0; i<msgCount; i++) {
1:             msg = consumer.receive(1000);
1:             if (msg == null) {
0:                 System.err.println("Consumer failed to receive exactly " + msgCount + " messages. Actual messages received is: " + i);
1:                 break;
1:             }
1:         }
1: 
1:         return i;
1:     }
1: 
1:     protected int receiveAllMessages(MessageConsumer consumer) throws Exception {
1:         int msgsReceived = 0;
1: 
1:         Message msg;
1:         do {
1:             msg = consumer.receive(1000);
1:             if (msg != null) {
1:                 msgsReceived++;
1:             }
1:         } while (msg != null);
1: 
1:         return msgsReceived;
1:     }
1: 
1:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {
1:         Connection conn = createConnection(brokerName);
1:         conn.start();
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         return sess.createConsumer(dest);
1:     }
1: 
1:     public void setUp() throws Exception {
1:         super.setAutoFail(true);
1:         super.setUp();
0:         createBroker(new URI("broker:(tcp://localhost:61616)/BrokerA?persistent=false&useJmx=false"));
0:         createBroker(new URI("broker:(tcp://localhost:61617)/BrokerB?persistent=false&useJmx=false"));
1: 
1:         // Configure broker connection factory
0:         ActiveMQConnectionFactory factoryA, factoryB;
1:         factoryA = (ActiveMQConnectionFactory)getConnectionFactory("BrokerA");
1:         factoryB = (ActiveMQConnectionFactory)getConnectionFactory("BrokerB");
1: 
1:         // Set prefetch policy
1:         ActiveMQPrefetchPolicy policy = new ActiveMQPrefetchPolicy();
1:         policy.setAll(PREFETCH_COUNT);
1: 
1:         factoryA.setPrefetchPolicy(policy);
1:         factoryB.setPrefetchPolicy(policy);
1: 
1:         msgsClient1 = 0;
1:         msgsClient2 = 0;
1:     }
1: }
============================================================================