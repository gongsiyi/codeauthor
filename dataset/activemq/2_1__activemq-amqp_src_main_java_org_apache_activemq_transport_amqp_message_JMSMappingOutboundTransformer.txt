1:16c487a: /*
1:6e69319:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6e69319:  * contributor license agreements.  See the NOTICE file distributed with
1:6e69319:  * this work for additional information regarding copyright ownership.
1:6e69319:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6e69319:  * (the "License"); you may not use this file except in compliance with
1:6e69319:  * the License.  You may obtain a copy of the License at
1:d54e21b:  *
1:6e69319:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d54e21b:  *
1:6e69319:  * Unless required by applicable law or agreed to in writing, software
1:6e69319:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6e69319:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e69319:  * See the License for the specific language governing permissions and
1:6e69319:  * limitations under the License.
2:6e69319:  */
1:6e69319: package org.apache.activemq.transport.amqp.message;
1:d54e21b: 
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_DATA;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_NULL;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_SEQUENCE;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_UNKNOWN;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_BINARY;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_LIST;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_STRING;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.CONTENT_ENCODING;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.CONTENT_TYPE;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.DELIVERY_ANNOTATION_PREFIX;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.EMPTY_BINARY;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.FIRST_ACQUIRER;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.FOOTER_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.HEADER;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_CONTENT_TYPE;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_DELIVERY_ANNOTATION_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_FOOTER_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_MESSAGE_ANNOTATION_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_ORIGINAL_ENCODING;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_PREFIX_LENGTH;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.MESSAGE_ANNOTATION_PREFIX;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.MESSAGE_FORMAT;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.NATIVE;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.ORIGINAL_ENCODING;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.PROPERTIES;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.REPLYTO_GROUP_ID;
1:d54e21b: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.SERIALIZED_JAVA_OBJECT_CONTENT_TYPE;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.getBinaryFromMessageBody;
1:63d62a7: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.getMapFromMessageBody;
1:d54e21b: 
1:63d62a7: import java.io.IOException;
1:63d62a7: import java.nio.charset.StandardCharsets;
1:6e69319: import java.util.ArrayList;
1:6e69319: import java.util.Date;
1:6e69319: import java.util.HashMap;
1:d54e21b: import java.util.Map;
13:6e69319: 
1:6e69319: import javax.jms.JMSException;
1:6e69319: import javax.jms.Message;
1:6e69319: import javax.jms.MessageEOFException;
1:6e69319: import javax.jms.TextMessage;
1:6e69319: 
1:63d62a7: import org.apache.activemq.command.ActiveMQBytesMessage;
1:63d62a7: import org.apache.activemq.command.ActiveMQDestination;
1:63d62a7: import org.apache.activemq.command.ActiveMQMapMessage;
1:63d62a7: import org.apache.activemq.command.ActiveMQMessage;
1:63d62a7: import org.apache.activemq.command.ActiveMQObjectMessage;
1:63d62a7: import org.apache.activemq.command.ActiveMQStreamMessage;
1:63d62a7: import org.apache.activemq.command.ActiveMQTextMessage;
1:baef8f8: import org.apache.activemq.command.CommandTypes;
1:63d62a7: import org.apache.activemq.command.MessageId;
1:4d6f4d7: import org.apache.activemq.transport.amqp.AmqpProtocolException;
1:63d62a7: import org.apache.activemq.util.JMSExceptionSupport;
1:63d62a7: import org.apache.activemq.util.TypeConversionSupport;
1:6e69319: import org.apache.qpid.proton.amqp.Binary;
1:6e69319: import org.apache.qpid.proton.amqp.Symbol;
1:6e69319: import org.apache.qpid.proton.amqp.UnsignedByte;
1:6e69319: import org.apache.qpid.proton.amqp.UnsignedInteger;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.AmqpSequence;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.Data;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.Footer;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.Header;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.Properties;
1:6e69319: import org.apache.qpid.proton.amqp.messaging.Section;
1:63d62a7: import org.apache.qpid.proton.codec.AMQPDefinedTypes;
1:63d62a7: import org.apache.qpid.proton.codec.DecoderImpl;
1:63d62a7: import org.apache.qpid.proton.codec.EncoderImpl;
1:6e69319: 
1:63d62a7: public class JMSMappingOutboundTransformer implements OutboundTransformer {
1:6e69319: 
1:528c25c:     public static final Symbol JMS_DEST_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-jms-dest");
1:528c25c:     public static final Symbol JMS_REPLY_TO_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-jms-reply-to");
1:528c25c: 
1:b1a9a93:     private static final String AMQ_SCHEDULED_MESSAGE_PREFIX = "AMQ_SCHEDULED_";
1:b1a9a93: 
1:528c25c:     public static final byte QUEUE_TYPE = 0x00;
1:528c25c:     public static final byte TOPIC_TYPE = 0x01;
1:528c25c:     public static final byte TEMP_QUEUE_TYPE = 0x02;
1:528c25c:     public static final byte TEMP_TOPIC_TYPE = 0x03;
1:528c25c: 
1:9ec6ee4:     private final UTF8BufferType utf8BufferEncoding;
1:9ec6ee4: 
1:63d62a7:     // For now Proton requires that we create a decoder to create an encoder
1:63d62a7:     private final DecoderImpl decoder = new DecoderImpl();
1:63d62a7:     private final EncoderImpl encoder = new EncoderImpl(decoder);
1:63d62a7:     {
1:63d62a7:         AMQPDefinedTypes.registerAllTypes(decoder, encoder);
1:9ec6ee4: 
1:9ec6ee4:         utf8BufferEncoding = new UTF8BufferType(encoder, decoder);
1:9ec6ee4: 
1:9ec6ee4:         encoder.register(utf8BufferEncoding);
36:6e69319:     }
1:d54e21b: 
1:6e69319:     @Override
1:63d62a7:     public EncodedMessage transform(ActiveMQMessage message) throws Exception {
1:63d62a7:         if (message == null) {
4:6e69319:             return null;
1:6e69319:         }
1:af13292: 
1:63d62a7:         long messageFormat = 0;
1:63d62a7:         Header header = null;
1:63d62a7:         Properties properties = null;
1:d54e21b:         Map<Symbol, Object> daMap = null;
1:d54e21b:         Map<Symbol, Object> maMap = null;
1:d54e21b:         Map<String,Object> apMap = null;
1:d54e21b:         Map<Object, Object> footerMap = null;
1:528c25c: 
1:63d62a7:         Section body = convertBody(message);
1:528c25c: 
1:63d62a7:         if (message.isPersistent()) {
1:63d62a7:             if (header == null) {
1:63d62a7:                 header = new Header();
1:63d62a7:             }
1:63d62a7:             header.setDurable(true);
1:d54e21b:         }
1:63d62a7:         byte priority = message.getPriority();
1:63d62a7:         if (priority != Message.DEFAULT_PRIORITY) {
1:63d62a7:             if (header == null) {
1:63d62a7:                 header = new Header();
1:63d62a7:             }
1:baef8f8:             header.setPriority(UnsignedByte.valueOf(priority));
1:6e69319:         }
1:63d62a7:         String type = message.getType();
1:63d62a7:         if (type != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setSubject(type);
1:63d62a7:         }
1:63d62a7:         MessageId messageId = message.getMessageId();
1:63d62a7:         if (messageId != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setMessageId(getOriginalMessageId(message));
1:63d62a7:         }
1:63d62a7:         ActiveMQDestination destination = message.getDestination();
1:63d62a7:         if (destination != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setTo(destination.getQualifiedName());
3:6e69319:             if (maMap == null) {
1:9ec6ee4:                 maMap = new HashMap<>();
1:6e69319:             }
1:63d62a7:             maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(destination));
1:6e69319:         }
1:63d62a7:         ActiveMQDestination replyTo = message.getReplyTo();
1:63d62a7:         if (replyTo != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setReplyTo(replyTo.getQualifiedName());
1:6e69319:             if (maMap == null) {
1:9ec6ee4:                 maMap = new HashMap<>();
1:6e69319:             }
1:63d62a7:             maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(replyTo));
1:6e69319:         }
1:63d62a7:         String correlationId = message.getCorrelationId();
1:63d62a7:         if (correlationId != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:d54e21b:             try {
1:63d62a7:                 properties.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));
1:16c487a:             } catch (AmqpProtocolException e) {
1:63d62a7:                 properties.setCorrelationId(correlationId);
1:d54e21b:             }
1:16c487a:         }
1:63d62a7:         long expiration = message.getExpiration();
1:63d62a7:         if (expiration != 0) {
1:63d62a7:             long ttl = expiration - System.currentTimeMillis();
1:6e69319:             if (ttl < 0) {
1:6e69319:                 ttl = 1;
1:63d62a7:             }
1:63d62a7: 
1:63d62a7:             if (header == null) {
1:63d62a7:                 header = new Header();
1:4d6f4d7:             }
1:6e69319:             header.setTtl(new UnsignedInteger((int) ttl));
1:d54e21b: 
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:6e69319:             }
1:63d62a7:             properties.setAbsoluteExpiryTime(new Date(expiration));
1:63d62a7:         }
1:63d62a7:         long timeStamp = message.getTimestamp();
1:63d62a7:         if (timeStamp != 0) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setCreationTime(new Date(timeStamp));
1:6e69319:         }
1:528c25c: 
1:63d62a7:         // JMSX Message Properties
1:63d62a7:         int deliveryCount = message.getRedeliveryCounter();
1:63d62a7:         if (deliveryCount > 0) {
1:63d62a7:             if (header == null) {
1:63d62a7:                 header = new Header();
1:63d62a7:             }
1:45f60e4:             header.setDeliveryCount(UnsignedInteger.valueOf(deliveryCount));
1:63d62a7:         }
1:63d62a7:         String userId = message.getUserID();
1:63d62a7:         if (userId != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setUserId(new Binary(userId.getBytes(StandardCharsets.UTF_8)));
1:63d62a7:         }
1:63d62a7:         String groupId = message.getGroupID();
1:63d62a7:         if (groupId != null) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:63d62a7:             properties.setGroupId(groupId);
1:63d62a7:         }
1:63d62a7:         int groupSequence = message.getGroupSequence();
1:63d62a7:         if (groupSequence > 0) {
1:63d62a7:             if (properties == null) {
1:63d62a7:                 properties = new Properties();
1:63d62a7:             }
1:45f60e4:             properties.setGroupSequence(UnsignedInteger.valueOf(groupSequence));
1:63d62a7:         }
1:63d62a7: 
1:63d62a7:         final Map<String, Object> entries;
1:63d62a7:         try {
1:63d62a7:             entries = message.getProperties();
1:63d62a7:         } catch (IOException e) {
1:63d62a7:             throw JMSExceptionSupport.create(e);
1:63d62a7:         }
1:63d62a7: 
1:63d62a7:         for (Map.Entry<String, Object> entry : entries.entrySet()) {
1:63d62a7:             String key = entry.getKey();
1:63d62a7:             Object value = entry.getValue();
1:63d62a7: 
1:63d62a7:             if (key.startsWith(JMS_AMQP_PREFIX)) {
1:63d62a7:                 if (key.startsWith(NATIVE, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     // skip transformer appended properties
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(ORIGINAL_ENCODING, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     // skip transformer appended properties
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(MESSAGE_FORMAT, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     messageFormat = (long) TypeConversionSupport.convert(entry.getValue(), Long.class);
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(HEADER, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (header == null) {
1:63d62a7:                         header = new Header();
1:63d62a7:                     }
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(PROPERTIES, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (properties == null) {
1:63d62a7:                         properties = new Properties();
1:63d62a7:                     }
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(MESSAGE_ANNOTATION_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (maMap == null) {
1:9ec6ee4:                         maMap = new HashMap<>();
1:63d62a7:                     }
1:63d62a7:                     String name = key.substring(JMS_AMQP_MESSAGE_ANNOTATION_PREFIX.length());
1:63d62a7:                     maMap.put(Symbol.valueOf(name), value);
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(FIRST_ACQUIRER, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (header == null) {
1:63d62a7:                         header = new Header();
1:63d62a7:                     }
1:63d62a7:                     header.setFirstAcquirer((boolean) TypeConversionSupport.convert(value, Boolean.class));
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(CONTENT_TYPE, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (properties == null) {
1:63d62a7:                         properties = new Properties();
1:63d62a7:                     }
1:63d62a7:                     properties.setContentType(Symbol.getSymbol((String) TypeConversionSupport.convert(value, String.class)));
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(CONTENT_ENCODING, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (properties == null) {
1:63d62a7:                         properties = new Properties();
1:63d62a7:                     }
1:63d62a7:                     properties.setContentEncoding(Symbol.getSymbol((String) TypeConversionSupport.convert(value, String.class)));
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(REPLYTO_GROUP_ID, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (properties == null) {
1:63d62a7:                         properties = new Properties();
1:63d62a7:                     }
1:63d62a7:                     properties.setReplyToGroupId((String) TypeConversionSupport.convert(value, String.class));
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(DELIVERY_ANNOTATION_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (daMap == null) {
1:9ec6ee4:                         daMap = new HashMap<>();
1:63d62a7:                     }
1:63d62a7:                     String name = key.substring(JMS_AMQP_DELIVERY_ANNOTATION_PREFIX.length());
1:63d62a7:                     daMap.put(Symbol.valueOf(name), value);
1:63d62a7:                     continue;
1:63d62a7:                 } else if (key.startsWith(FOOTER_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:63d62a7:                     if (footerMap == null) {
1:9ec6ee4:                         footerMap = new HashMap<>();
1:63d62a7:                     }
1:63d62a7:                     String name = key.substring(JMS_AMQP_FOOTER_PREFIX.length());
1:63d62a7:                     footerMap.put(name, value);
1:63d62a7:                     continue;
1:63d62a7:                 }
1:b1a9a93:             } else if (key.startsWith(AMQ_SCHEDULED_MESSAGE_PREFIX )) {
1:b1a9a93:                 // strip off the scheduled message properties
1:b1a9a93:                 continue;
1:63d62a7:             }
1:63d62a7: 
1:63d62a7:             // The property didn't map into any other slot so we store it in the
1:63d62a7:             // Application Properties section of the message.
1:63d62a7:             if (apMap == null) {
1:9ec6ee4:                 apMap = new HashMap<>();
1:63d62a7:             }
1:63d62a7:             apMap.put(key, value);
1:63d62a7:         }
1:63d62a7: 
1:63d62a7:         final AmqpWritableBuffer buffer = new AmqpWritableBuffer();
1:63d62a7:         encoder.setByteBuffer(buffer);
1:63d62a7: 
1:63d62a7:         if (header != null) {
1:63d62a7:             encoder.writeObject(header);
1:63d62a7:         }
1:6e69319:         if (daMap != null) {
1:63d62a7:             encoder.writeObject(new DeliveryAnnotations(daMap));
1:6e69319:         }
1:63d62a7:         if (maMap != null) {
1:63d62a7:             encoder.writeObject(new MessageAnnotations(maMap));
1:63d62a7:         }
1:63d62a7:         if (properties != null) {
1:63d62a7:             encoder.writeObject(properties);
1:63d62a7:         }
1:6e69319:         if (apMap != null) {
1:63d62a7:             encoder.writeObject(new ApplicationProperties(apMap));
1:6e69319:         }
1:63d62a7:         if (body != null) {
1:63d62a7:             encoder.writeObject(body);
1:63d62a7:         }
1:6e69319:         if (footerMap != null) {
1:63d62a7:             encoder.writeObject(new Footer(footerMap));
1:6e69319:         }
1:528c25c: 
1:63d62a7:         return new EncodedMessage(messageFormat, buffer.getArray(), 0, buffer.getArrayLength());
1:6e69319:     }
1:528c25c: 
1:63d62a7:     private Section convertBody(ActiveMQMessage message) throws JMSException {
1:6e69319: 
1:d54e21b:         Section body = null;
1:d54e21b:         short orignalEncoding = AMQP_UNKNOWN;
1:d54e21b: 
1:63d62a7:         try {
1:63d62a7:             orignalEncoding = message.getShortProperty(JMS_AMQP_ORIGINAL_ENCODING);
1:63d62a7:         } catch (Exception ex) {
1:63d62a7:             // Ignore and stick with UNKNOWN
1:d54e21b:         }
1:d54e21b: 
1:baef8f8:         int messageType = message.getDataStructureType();
1:baef8f8: 
1:baef8f8:         if (messageType == CommandTypes.ACTIVEMQ_BYTES_MESSAGE) {
1:63d62a7:             Binary payload = getBinaryFromMessageBody((ActiveMQBytesMessage) message);
1:d54e21b: 
1:d54e21b:             if (payload == null) {
1:d54e21b:                 payload = EMPTY_BINARY;
1:d54e21b:             }
1:d54e21b: 
1:d54e21b:             switch (orignalEncoding) {
1:d54e21b:                 case AMQP_NULL:
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_VALUE_BINARY:
1:d54e21b:                     body = new AmqpValue(payload);
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_DATA:
1:d54e21b:                 case AMQP_UNKNOWN:
1:d54e21b:                 default:
1:d54e21b:                     body = new Data(payload);
1:d54e21b:                     break;
1:d54e21b:             }
1:baef8f8:         } else if (messageType == CommandTypes.ACTIVEMQ_TEXT_MESSAGE) {
1:d54e21b:             switch (orignalEncoding) {
1:d54e21b:                 case AMQP_NULL:
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_DATA:
1:63d62a7:                     body = new Data(getBinaryFromMessageBody((ActiveMQTextMessage) message));
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_VALUE_STRING:
1:d54e21b:                 case AMQP_UNKNOWN:
1:d54e21b:                 default:
1:d54e21b:                     body = new AmqpValue(((TextMessage) message).getText());
1:d54e21b:                     break;
1:d54e21b:             }
1:baef8f8:         } else if (messageType == CommandTypes.ACTIVEMQ_MAP_MESSAGE) {
1:63d62a7:             body = new AmqpValue(getMapFromMessageBody((ActiveMQMapMessage) message));
1:baef8f8:         } else if (messageType == CommandTypes.ACTIVEMQ_STREAM_MESSAGE) {
1:9ec6ee4:             ArrayList<Object> list = new ArrayList<>();
1:63d62a7:             final ActiveMQStreamMessage m = (ActiveMQStreamMessage) message;
1:d54e21b:             try {
1:d54e21b:                 while (true) {
1:d54e21b:                     list.add(m.readObject());
1:d54e21b:                 }
1:d54e21b:             } catch (MessageEOFException e) {
1:d54e21b:             }
1:d54e21b: 
1:d54e21b:             switch (orignalEncoding) {
1:d54e21b:                 case AMQP_SEQUENCE:
1:d54e21b:                     body = new AmqpSequence(list);
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_VALUE_LIST:
1:d54e21b:                 case AMQP_UNKNOWN:
1:d54e21b:                 default:
1:d54e21b:                     body = new AmqpValue(list);
1:d54e21b:                     break;
1:d54e21b:             }
1:baef8f8:         } else if (messageType == CommandTypes.ACTIVEMQ_OBJECT_MESSAGE) {
1:63d62a7:             Binary payload = getBinaryFromMessageBody((ActiveMQObjectMessage) message);
1:d54e21b: 
1:d54e21b:             if (payload == null) {
1:d54e21b:                 payload = EMPTY_BINARY;
1:d54e21b:             }
1:d54e21b: 
1:d54e21b:             switch (orignalEncoding) {
1:d54e21b:                 case AMQP_VALUE_BINARY:
1:d54e21b:                     body = new AmqpValue(payload);
1:d54e21b:                     break;
1:d54e21b:                 case AMQP_DATA:
1:d54e21b:                 case AMQP_UNKNOWN:
1:d54e21b:                 default:
1:d54e21b:                     body = new Data(payload);
1:d54e21b:                     break;
1:d54e21b:             }
1:d54e21b: 
1:d54e21b:             // For a non-AMQP message we tag the outbound content type as containing
1:d54e21b:             // a serialized Java object so that an AMQP client has a hint as to what
1:d54e21b:             // we are sending it.
1:63d62a7:             if (!message.propertyExists(JMS_AMQP_CONTENT_TYPE)) {
1:63d62a7:                 message.setReadOnlyProperties(false);
1:63d62a7:                 message.setStringProperty(JMS_AMQP_CONTENT_TYPE, SERIALIZED_JAVA_OBJECT_CONTENT_TYPE);
1:63d62a7:                 message.setReadOnlyProperties(true);
1:d54e21b:             }
1:d54e21b:         }
1:d54e21b: 
1:d54e21b:         return body;
1:d54e21b:     }
1:d54e21b: 
1:baef8f8:     private static byte destinationType(ActiveMQDestination destination) {
1:baef8f8:         if (destination.isQueue()) {
1:baef8f8:             if (destination.isTemporary()) {
1:528c25c:                 return TEMP_QUEUE_TYPE;
1:af13292:             } else {
1:528c25c:                 return QUEUE_TYPE;
1:af13292:             }
1:baef8f8:         } else if (destination.isTopic()) {
1:baef8f8:             if (destination.isTemporary()) {
1:528c25c:                 return TEMP_TOPIC_TYPE;
2:528c25c:             } else {
1:528c25c:                 return TOPIC_TYPE;
1:528c25c:             }
1:528c25c:         }
1:528c25c: 
2:528c25c:         throw new IllegalArgumentException("Unknown Destination Type passed to JMS Transformer.");
1:528c25c:     }
1:528c25c: 
1:63d62a7:     private static Object getOriginalMessageId(ActiveMQMessage message) {
1:63d62a7:         Object result;
1:63d62a7:         MessageId messageId = message.getMessageId();
1:63d62a7:         if (messageId.getTextView() != null) {
1:63d62a7:             try {
1:63d62a7:                 result = AMQPMessageIdHelper.INSTANCE.toIdObject(messageId.getTextView());
1:63d62a7:             } catch (AmqpProtocolException e) {
1:63d62a7:                 result = messageId.getTextView();
1:528c25c:             }
1:63d62a7:         } else {
1:63d62a7:             result = messageId.toString();
1:6e69319:         }
1:528c25c: 
1:63d62a7:         return result;
1:6e69319:     }
1:6e69319: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:ba7934e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9ec6ee4
/////////////////////////////////////////////////////////////////////////
1:     private final UTF8BufferType utf8BufferEncoding;
1: 
1: 
1:         utf8BufferEncoding = new UTF8BufferType(encoder, decoder);
1: 
1:         encoder.register(utf8BufferEncoding);
/////////////////////////////////////////////////////////////////////////
1:                 maMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                 maMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                         maMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                         daMap = new HashMap<>();
1:                         footerMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                 apMap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<Object> list = new ArrayList<>();
commit:baef8f8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
1:             header.setPriority(UnsignedByte.valueOf(priority));
/////////////////////////////////////////////////////////////////////////
1:         int messageType = message.getDataStructureType();
1: 
1:         if (messageType == CommandTypes.ACTIVEMQ_BYTES_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
1:         } else if (messageType == CommandTypes.ACTIVEMQ_TEXT_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
1:         } else if (messageType == CommandTypes.ACTIVEMQ_MAP_MESSAGE) {
1:         } else if (messageType == CommandTypes.ACTIVEMQ_STREAM_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
1:         } else if (messageType == CommandTypes.ACTIVEMQ_OBJECT_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
1:     private static byte destinationType(ActiveMQDestination destination) {
1:         if (destination.isQueue()) {
1:             if (destination.isTemporary()) {
1:         } else if (destination.isTopic()) {
1:             if (destination.isTemporary()) {
commit:45f60e4
/////////////////////////////////////////////////////////////////////////
1:             header.setDeliveryCount(UnsignedInteger.valueOf(deliveryCount));
/////////////////////////////////////////////////////////////////////////
1:             properties.setGroupSequence(UnsignedInteger.valueOf(groupSequence));
commit:b1a9a93
/////////////////////////////////////////////////////////////////////////
1:     private static final String AMQ_SCHEDULED_MESSAGE_PREFIX = "AMQ_SCHEDULED_";
1: 
/////////////////////////////////////////////////////////////////////////
1:             } else if (key.startsWith(AMQ_SCHEDULED_MESSAGE_PREFIX )) {
1:                 // strip off the scheduled message properties
1:                 continue;
commit:63d62a7
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.CONTENT_ENCODING;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.CONTENT_TYPE;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.DELIVERY_ANNOTATION_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.FIRST_ACQUIRER;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.FOOTER_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.HEADER;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_CONTENT_TYPE;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_DELIVERY_ANNOTATION_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_FOOTER_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_MESSAGE_ANNOTATION_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_ORIGINAL_ENCODING;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_PREFIX_LENGTH;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.MESSAGE_ANNOTATION_PREFIX;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.MESSAGE_FORMAT;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.NATIVE;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.ORIGINAL_ENCODING;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.PROPERTIES;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.REPLYTO_GROUP_ID;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.getBinaryFromMessageBody;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.getMapFromMessageBody;
1: import java.io.IOException;
1: import java.nio.charset.StandardCharsets;
1: import org.apache.activemq.command.ActiveMQBytesMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMapMessage;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQObjectMessage;
1: import org.apache.activemq.command.ActiveMQStreamMessage;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.util.JMSExceptionSupport;
1: import org.apache.activemq.util.TypeConversionSupport;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.codec.AMQPDefinedTypes;
1: import org.apache.qpid.proton.codec.DecoderImpl;
1: import org.apache.qpid.proton.codec.EncoderImpl;
0: import org.fusesource.hawtbuf.UTF8Buffer;
1: public class JMSMappingOutboundTransformer implements OutboundTransformer {
/////////////////////////////////////////////////////////////////////////
1:     // For now Proton requires that we create a decoder to create an encoder
1:     private final DecoderImpl decoder = new DecoderImpl();
1:     private final EncoderImpl encoder = new EncoderImpl(decoder);
1:     {
1:         AMQPDefinedTypes.registerAllTypes(decoder, encoder);
1:     public EncodedMessage transform(ActiveMQMessage message) throws Exception {
1:         if (message == null) {
1:         long messageFormat = 0;
1:         Header header = null;
1:         Properties properties = null;
1:         Section body = convertBody(message);
1:         if (message.isPersistent()) {
1:             if (header == null) {
1:                 header = new Header();
1:             }
1:             header.setDurable(true);
1:         byte priority = message.getPriority();
1:         if (priority != Message.DEFAULT_PRIORITY) {
1:             if (header == null) {
1:                 header = new Header();
1:             }
0:             header.setPriority(new UnsignedByte(priority));
1:         String type = message.getType();
1:         if (type != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setSubject(type);
1:         }
1:         MessageId messageId = message.getMessageId();
1:         if (messageId != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setMessageId(getOriginalMessageId(message));
1:         }
1:         ActiveMQDestination destination = message.getDestination();
1:         if (destination != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setTo(destination.getQualifiedName());
1:             maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(destination));
1:         ActiveMQDestination replyTo = message.getReplyTo();
1:         if (replyTo != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setReplyTo(replyTo.getQualifiedName());
1:             maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(replyTo));
1:         String correlationId = message.getCorrelationId();
1:         if (correlationId != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:                 properties.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));
1:                 properties.setCorrelationId(correlationId);
1:         long expiration = message.getExpiration();
1:         if (expiration != 0) {
1:             long ttl = expiration - System.currentTimeMillis();
1: 
1:             if (header == null) {
1:                 header = new Header();
1:             }
1:             if (properties == null) {
1:                 properties = new Properties();
1:             properties.setAbsoluteExpiryTime(new Date(expiration));
1:         }
1:         long timeStamp = message.getTimestamp();
1:         if (timeStamp != 0) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setCreationTime(new Date(timeStamp));
1:         // JMSX Message Properties
1:         int deliveryCount = message.getRedeliveryCounter();
1:         if (deliveryCount > 0) {
1:             if (header == null) {
1:                 header = new Header();
1:             }
0:             header.setDeliveryCount(new UnsignedInteger(deliveryCount));
1:         String userId = message.getUserID();
1:         if (userId != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setUserId(new Binary(userId.getBytes(StandardCharsets.UTF_8)));
1:         }
1:         String groupId = message.getGroupID();
1:         if (groupId != null) {
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
1:             properties.setGroupId(groupId);
1:         }
1:         int groupSequence = message.getGroupSequence();
1:         if (groupSequence > 0) {
0:             UnsignedInteger value = new UnsignedInteger(groupSequence);
1:             if (properties == null) {
1:                 properties = new Properties();
1:             }
0:             properties.setGroupSequence(value);
1:         }
1: 
1:         final Map<String, Object> entries;
1:         try {
1:             entries = message.getProperties();
1:         } catch (IOException e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1: 
1:         for (Map.Entry<String, Object> entry : entries.entrySet()) {
1:             String key = entry.getKey();
1:             Object value = entry.getValue();
0:             if (value instanceof UTF8Buffer) {
0:                 value = value.toString();
1:             }
1: 
1:             if (key.startsWith(JMS_AMQP_PREFIX)) {
1:                 if (key.startsWith(NATIVE, JMS_AMQP_PREFIX_LENGTH)) {
1:                     // skip transformer appended properties
1:                     continue;
1:                 } else if (key.startsWith(ORIGINAL_ENCODING, JMS_AMQP_PREFIX_LENGTH)) {
1:                     // skip transformer appended properties
1:                     continue;
1:                 } else if (key.startsWith(MESSAGE_FORMAT, JMS_AMQP_PREFIX_LENGTH)) {
1:                     messageFormat = (long) TypeConversionSupport.convert(entry.getValue(), Long.class);
1:                     continue;
1:                 } else if (key.startsWith(HEADER, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (header == null) {
1:                         header = new Header();
1:                     }
1:                     continue;
1:                 } else if (key.startsWith(PROPERTIES, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (properties == null) {
1:                         properties = new Properties();
1:                     }
1:                     continue;
1:                 } else if (key.startsWith(MESSAGE_ANNOTATION_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (maMap == null) {
0:                         maMap = new HashMap<Symbol, Object>();
1:                     }
1:                     String name = key.substring(JMS_AMQP_MESSAGE_ANNOTATION_PREFIX.length());
1:                     maMap.put(Symbol.valueOf(name), value);
1:                     continue;
1:                 } else if (key.startsWith(FIRST_ACQUIRER, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (header == null) {
1:                         header = new Header();
1:                     }
1:                     header.setFirstAcquirer((boolean) TypeConversionSupport.convert(value, Boolean.class));
1:                     continue;
1:                 } else if (key.startsWith(CONTENT_TYPE, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (properties == null) {
1:                         properties = new Properties();
1:                     }
1:                     properties.setContentType(Symbol.getSymbol((String) TypeConversionSupport.convert(value, String.class)));
1:                     continue;
1:                 } else if (key.startsWith(CONTENT_ENCODING, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (properties == null) {
1:                         properties = new Properties();
1:                     }
1:                     properties.setContentEncoding(Symbol.getSymbol((String) TypeConversionSupport.convert(value, String.class)));
1:                     continue;
1:                 } else if (key.startsWith(REPLYTO_GROUP_ID, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (properties == null) {
1:                         properties = new Properties();
1:                     }
1:                     properties.setReplyToGroupId((String) TypeConversionSupport.convert(value, String.class));
1:                     continue;
1:                 } else if (key.startsWith(DELIVERY_ANNOTATION_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (daMap == null) {
0:                         daMap = new HashMap<Symbol, Object>();
1:                     }
1:                     String name = key.substring(JMS_AMQP_DELIVERY_ANNOTATION_PREFIX.length());
1:                     daMap.put(Symbol.valueOf(name), value);
1:                     continue;
1:                 } else if (key.startsWith(FOOTER_PREFIX, JMS_AMQP_PREFIX_LENGTH)) {
1:                     if (footerMap == null) {
0:                         footerMap = new HashMap<Object, Object>();
1:                     }
1:                     String name = key.substring(JMS_AMQP_FOOTER_PREFIX.length());
1:                     footerMap.put(name, value);
1:                     continue;
1:                 }
1:             }
1: 
1:             // The property didn't map into any other slot so we store it in the
1:             // Application Properties section of the message.
1:             if (apMap == null) {
0:                 apMap = new HashMap<String, Object>();
1:             }
1:             apMap.put(key, value);
1:         }
1: 
1:         final AmqpWritableBuffer buffer = new AmqpWritableBuffer();
1:         encoder.setByteBuffer(buffer);
1: 
1:         if (header != null) {
1:             encoder.writeObject(header);
1:         }
1:             encoder.writeObject(new DeliveryAnnotations(daMap));
1:         if (maMap != null) {
1:             encoder.writeObject(new MessageAnnotations(maMap));
1:         }
1:         if (properties != null) {
1:             encoder.writeObject(properties);
1:         }
1:             encoder.writeObject(new ApplicationProperties(apMap));
1:         if (body != null) {
1:             encoder.writeObject(body);
1:         }
1:             encoder.writeObject(new Footer(footerMap));
1:         return new EncodedMessage(messageFormat, buffer.getArray(), 0, buffer.getArrayLength());
1:     private Section convertBody(ActiveMQMessage message) throws JMSException {
1:         try {
1:             orignalEncoding = message.getShortProperty(JMS_AMQP_ORIGINAL_ENCODING);
1:         } catch (Exception ex) {
1:             // Ignore and stick with UNKNOWN
0:         if (message instanceof ActiveMQBytesMessage) {
1:             Binary payload = getBinaryFromMessageBody((ActiveMQBytesMessage) message);
/////////////////////////////////////////////////////////////////////////
0:         } else if (message instanceof ActiveMQTextMessage) {
1:                     body = new Data(getBinaryFromMessageBody((ActiveMQTextMessage) message));
/////////////////////////////////////////////////////////////////////////
0:         } else if (message instanceof ActiveMQMapMessage) {
1:             body = new AmqpValue(getMapFromMessageBody((ActiveMQMapMessage) message));
0:         } else if (message instanceof ActiveMQStreamMessage) {
1:             final ActiveMQStreamMessage m = (ActiveMQStreamMessage) message;
/////////////////////////////////////////////////////////////////////////
0:         } else if (message instanceof ActiveMQObjectMessage) {
1:             Binary payload = getBinaryFromMessageBody((ActiveMQObjectMessage) message);
/////////////////////////////////////////////////////////////////////////
1:             if (!message.propertyExists(JMS_AMQP_CONTENT_TYPE)) {
1:                 message.setReadOnlyProperties(false);
1:                 message.setStringProperty(JMS_AMQP_CONTENT_TYPE, SERIALIZED_JAVA_OBJECT_CONTENT_TYPE);
1:                 message.setReadOnlyProperties(true);
/////////////////////////////////////////////////////////////////////////
1:     private static Object getOriginalMessageId(ActiveMQMessage message) {
1:         Object result;
1:         MessageId messageId = message.getMessageId();
1:         if (messageId.getTextView() != null) {
1:             try {
1:                 result = AMQPMessageIdHelper.INSTANCE.toIdObject(messageId.getTextView());
1:             } catch (AmqpProtocolException e) {
1:                 result = messageId.getTextView();
1:         } else {
1:             result = messageId.toString();
1:         return result;
commit:d54e21b
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_DATA;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_NULL;
0: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_ORIGINAL_ENCODING_KEY;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_SEQUENCE;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_UNKNOWN;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_BINARY;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_LIST;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.AMQP_VALUE_STRING;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.EMPTY_BINARY;
1: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.SERIALIZED_JAVA_OBJECT_CONTENT_TYPE;
1: 
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public JMSMappingOutboundTransformer(ActiveMQJMSVendor vendor) {
/////////////////////////////////////////////////////////////////////////
0:      * to do this on their own way.
0:      * @param message
0:      *      The message to transform into an AMQP version for dispatch.
1:      *
0:      * @return an AMQP Message that represents the given JMS Message.
1:      *
0:      * @throws Exception if an error occurs during the conversion.
0:     public ProtonJMessage convert(Message message) throws JMSException, UnsupportedEncodingException {
1: 
1:         Map<Symbol, Object> daMap = null;
1:         Map<Symbol, Object> maMap = null;
1:         Map<String,Object> apMap = null;
1:         Map<Object, Object> footerMap = null;
0:         body = convertBody(message);
0:         header.setDurable(message.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);
0:         header.setPriority(new UnsignedByte((byte) message.getJMSPriority()));
0:         if (message.getJMSType() != null) {
0:             props.setSubject(message.getJMSType());
0:         if (message.getJMSMessageID() != null) {
0:             props.setMessageId(vendor.getOriginalMessageId(message));
1:         }
0:         if (message.getJMSDestination() != null) {
0:             props.setTo(vendor.toAddress(message.getJMSDestination()));
0:             maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(message.getJMSDestination()));
0:             maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSDestination()));
0:         if (message.getJMSReplyTo() != null) {
0:             props.setReplyTo(vendor.toAddress(message.getJMSReplyTo()));
0:             maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(message.getJMSReplyTo()));
0:             maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSReplyTo()));
0:         if (message.getJMSCorrelationID() != null) {
0:             String correlationId = message.getJMSCorrelationID();
0:         if (message.getJMSExpiration() != 0) {
0:             long ttl = message.getJMSExpiration() - System.currentTimeMillis();
0:             props.setAbsoluteExpiryTime(new Date(message.getJMSExpiration()));
0:         if (message.getJMSTimestamp() != 0) {
0:             props.setCreationTime(new Date(message.getJMSTimestamp()));
0:         @SuppressWarnings("unchecked")
0:         final Enumeration<String> keys = message.getPropertyNames();
1: 
0:             if (key.equals(messageFormatKey) || key.equals(nativeKey) || key.equals(AMQP_ORIGINAL_ENCODING_KEY)) {
0:                 // skip transformer appended properties
0:                 header.setFirstAcquirer(message.getBooleanProperty(key));
0:                 int amqpDeliveryCount = message.getIntProperty(key) - 1;
0:                 String value = message.getStringProperty(key);
0:                 String value = message.getStringProperty(key);
0:                     apMap = new HashMap<String, Object>();
0:                 UnsignedInteger value = new UnsignedInteger(message.getIntProperty(key));
0:                     apMap = new HashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
0:                 daMap.put(Symbol.valueOf(name), message.getObjectProperty(key));
0:                 maMap.put(Symbol.valueOf(name), message.getObjectProperty(key));
0:                 props.setContentType(Symbol.getSymbol(message.getStringProperty(key)));
0:                 props.setContentEncoding(Symbol.getSymbol(message.getStringProperty(key)));
0:                 props.setReplyToGroupId(message.getStringProperty(key));
0:                     footerMap = new HashMap<Object, Object>();
0:                 footerMap.put(name, message.getObjectProperty(key));
0:                     apMap = new HashMap<String, Object>();
0:                 apMap.put(key, message.getObjectProperty(key));
/////////////////////////////////////////////////////////////////////////
0:     private Section convertBody(Message message) throws JMSException {
1: 
1:         Section body = null;
1:         short orignalEncoding = AMQP_UNKNOWN;
1: 
0:         if (message.propertyExists(AMQP_ORIGINAL_ENCODING_KEY)) {
1:             try {
0:                 orignalEncoding = message.getShortProperty(AMQP_ORIGINAL_ENCODING_KEY);
0:             } catch (Exception ex) {
1:             }
1:         }
1: 
0:         if (message instanceof BytesMessage) {
0:             Binary payload = vendor.getBinaryFromMessageBody((BytesMessage) message);
1: 
1:             if (payload == null) {
1:                 payload = EMPTY_BINARY;
1:             }
1: 
1:             switch (orignalEncoding) {
1:                 case AMQP_NULL:
1:                     break;
1:                 case AMQP_VALUE_BINARY:
1:                     body = new AmqpValue(payload);
1:                     break;
1:                 case AMQP_DATA:
1:                 case AMQP_UNKNOWN:
1:                 default:
1:                     body = new Data(payload);
1:                     break;
1:             }
0:         } else if (message instanceof TextMessage) {
1:             switch (orignalEncoding) {
1:                 case AMQP_NULL:
1:                     break;
1:                 case AMQP_DATA:
0:                     body = new Data(vendor.getBinaryFromMessageBody((TextMessage) message));
1:                     break;
1:                 case AMQP_VALUE_STRING:
1:                 case AMQP_UNKNOWN:
1:                 default:
1:                     body = new AmqpValue(((TextMessage) message).getText());
1:                     break;
1:             }
0:         } else if (message instanceof MapMessage) {
0:             body = new AmqpValue(vendor.getMapFromMessageBody((MapMessage) message));
0:         } else if (message instanceof StreamMessage) {
0:             ArrayList<Object> list = new ArrayList<Object>();
0:             final StreamMessage m = (StreamMessage) message;
1:             try {
1:                 while (true) {
1:                     list.add(m.readObject());
1:                 }
1:             } catch (MessageEOFException e) {
1:             }
1: 
1:             switch (orignalEncoding) {
1:                 case AMQP_SEQUENCE:
1:                     body = new AmqpSequence(list);
1:                     break;
1:                 case AMQP_VALUE_LIST:
1:                 case AMQP_UNKNOWN:
1:                 default:
1:                     body = new AmqpValue(list);
1:                     break;
1:             }
0:         } else if (message instanceof ObjectMessage) {
0:             Binary payload = vendor.getBinaryFromMessageBody((ObjectMessage) message);
1: 
1:             if (payload == null) {
1:                 payload = EMPTY_BINARY;
1:             }
1: 
1:             switch (orignalEncoding) {
1:                 case AMQP_VALUE_BINARY:
1:                     body = new AmqpValue(payload);
1:                     break;
1:                 case AMQP_DATA:
1:                 case AMQP_UNKNOWN:
1:                 default:
1:                     body = new Data(payload);
1:                     break;
1:             }
1: 
1:             // For a non-AMQP message we tag the outbound content type as containing
1:             // a serialized Java object so that an AMQP client has a hint as to what
1:             // we are sending it.
0:             if (!message.propertyExists(contentTypeKey)) {
0:                 vendor.setMessageProperty(message, contentTypeKey, SERIALIZED_JAVA_OBJECT_CONTENT_TYPE);
1:             }
1:         }
1: 
1:         return body;
1:     }
1: 
commit:16c487a
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
0:             String correlationId = msg.getJMSCorrelationID();
0:             try {
0:                 props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));
1:             } catch (AmqpProtocolException e) {
0:                 props.setCorrelationId(correlationId);
1:             }
commit:4d6f4d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.AmqpProtocolException;
/////////////////////////////////////////////////////////////////////////
0:                 try {
0:                     props.setMessageId(AMQPMessageIdHelper.INSTANCE.toIdObject(msgId.getTextView()));
0:                 } catch (AmqpProtocolException e) {
0:                     props.setMessageId(msgId.getTextView().toString());
1:                 }
commit:af13292
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQMessage amqMsg = (ActiveMQMessage) msg;
1: 
0:             MessageId msgId = amqMsg.getMessageId();
0:             if (msgId.getTextView() != null) {
0:                 props.setMessageId(msgId.getTextView());
1:             } else {
0:                 props.setMessageId(msgId.toString());
1:             }
commit:528c25c
/////////////////////////////////////////////////////////////////////////
1:     public static final Symbol JMS_DEST_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-jms-dest");
1:     public static final Symbol JMS_REPLY_TO_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-jms-reply-to");
1: 
1:     public static final byte QUEUE_TYPE = 0x00;
1:     public static final byte TOPIC_TYPE = 0x01;
1:     public static final byte TEMP_QUEUE_TYPE = 0x02;
1:     public static final byte TEMP_TOPIC_TYPE = 0x03;
1: 
0:     // Deprecated legacy values used by old QPid AMQP 1.0 JMS client.
1: 
0:     public static final Symbol LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-to-type");
0:     public static final Symbol LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION = Symbol.valueOf("x-opt-reply-type");
1: 
0:     public static final String LEGACY_QUEUE_TYPE = "queue";
0:     public static final String LEGACY_TOPIC_TYPE = "topic";
0:     public static final String LEGACY_TEMP_QUEUE_TYPE = "temporary,queue";
0:     public static final String LEGACY_TEMP_TOPIC_TYPE = "temporary,topic";
1: 
/////////////////////////////////////////////////////////////////////////
0:             maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));
1: 
0:             // Deprecated: used by legacy QPid AMQP 1.0 JMS client
0:             maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));
0:             maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));
1: 
0:             // Deprecated: used by legacy QPid AMQP 1.0 JMS client
0:             maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));
/////////////////////////////////////////////////////////////////////////
0:     private static byte destinationType(Destination destination) {
0:         if (destination instanceof Queue) {
0:             if (destination instanceof TemporaryQueue) {
1:                 return TEMP_QUEUE_TYPE;
1:             } else {
1:                 return QUEUE_TYPE;
1:             }
0:         } else if (destination instanceof Topic) {
0:             if (destination instanceof TemporaryTopic) {
1:                 return TEMP_TOPIC_TYPE;
1:             } else {
1:                 return TOPIC_TYPE;
1:             }
1:         }
1: 
1:         throw new IllegalArgumentException("Unknown Destination Type passed to JMS Transformer.");
1:     }
1: 
0:     // Used by legacy QPid AMQP 1.0 JMS client.
0:     @Deprecated
0:                 return LEGACY_TEMP_QUEUE_TYPE;
0:                 return LEGACY_QUEUE_TYPE;
0:         } else if (destination instanceof Topic) {
0:                 return LEGACY_TEMP_TOPIC_TYPE;
0:                 return LEGACY_TOPIC_TYPE;
1: 
1:         throw new IllegalArgumentException("Unknown Destination Type passed to JMS Transformer.");
commit:6e69319
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.message;
1: 
0: import java.io.UnsupportedEncodingException;
0: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
1: import java.util.Date;
0: import java.util.Enumeration;
1: import java.util.HashMap;
1: 
0: import javax.jms.BytesMessage;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Destination;
1: import javax.jms.JMSException;
0: import javax.jms.MapMessage;
1: import javax.jms.Message;
1: import javax.jms.MessageEOFException;
0: import javax.jms.MessageFormatException;
0: import javax.jms.ObjectMessage;
0: import javax.jms.Queue;
0: import javax.jms.StreamMessage;
0: import javax.jms.TemporaryQueue;
0: import javax.jms.TemporaryTopic;
1: import javax.jms.TextMessage;
0: import javax.jms.Topic;
1: 
1: import org.apache.qpid.proton.amqp.Binary;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.UnsignedByte;
1: import org.apache.qpid.proton.amqp.UnsignedInteger;
1: import org.apache.qpid.proton.amqp.messaging.AmqpSequence;
1: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
1: import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
1: import org.apache.qpid.proton.amqp.messaging.Data;
1: import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;
1: import org.apache.qpid.proton.amqp.messaging.Footer;
1: import org.apache.qpid.proton.amqp.messaging.Header;
1: import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;
1: import org.apache.qpid.proton.amqp.messaging.Properties;
1: import org.apache.qpid.proton.amqp.messaging.Section;
0: import org.apache.qpid.proton.codec.CompositeWritableBuffer;
0: import org.apache.qpid.proton.codec.DroppingWritableBuffer;
0: import org.apache.qpid.proton.codec.WritableBuffer;
0: import org.apache.qpid.proton.message.ProtonJMessage;
1: 
0: public class JMSMappingOutboundTransformer extends OutboundTransformer {
1: 
0:     public JMSMappingOutboundTransformer(JMSVendor vendor) {
0:         super(vendor);
1:     }
1: 
1:     @Override
0:     public EncodedMessage transform(Message msg) throws Exception {
0:         if (msg == null) {
1:             return null;
1:         }
1: 
0:         try {
0:             if (msg.getBooleanProperty(prefixVendor + "NATIVE")) {
1:                 return null;
1:             }
0:         } catch (MessageFormatException e) {
1:             return null;
1:         }
0:         ProtonJMessage amqp = convert(msg);
1: 
0:         long messageFormat;
0:         try {
0:             messageFormat = msg.getLongProperty(this.messageFormatKey);
0:         } catch (MessageFormatException e) {
1:             return null;
1:         }
1: 
0:         ByteBuffer buffer = ByteBuffer.wrap(new byte[1024 * 4]);
0:         final DroppingWritableBuffer overflow = new DroppingWritableBuffer();
0:         int c = amqp.encode(new CompositeWritableBuffer(new WritableBuffer.ByteBufferWrapper(buffer), overflow));
0:         if (overflow.position() > 0) {
0:             buffer = ByteBuffer.wrap(new byte[1024 * 4 + overflow.position()]);
0:             c = amqp.encode(new WritableBuffer.ByteBufferWrapper(buffer));
1:         }
1: 
0:         return new EncodedMessage(messageFormat, buffer.array(), 0, c);
1:     }
1: 
0:     /**
0:      * Perform the conversion between JMS Message and Proton Message without
0:      * re-encoding it to array. This is needed because some frameworks may elect
0:      * to do this on their own way (Netty for instance using Nettybuffers)
0:      *
0:      * @param msg
0:      * @return
0:      * @throws Exception
1:      */
0:     public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {
0:         Header header = new Header();
0:         Properties props = new Properties();
0:         HashMap<Symbol, Object> daMap = null;
0:         HashMap<Symbol, Object> maMap = null;
0:         HashMap apMap = null;
0:         Section body = null;
0:         HashMap footerMap = null;
0:         if (msg instanceof BytesMessage) {
0:             BytesMessage m = (BytesMessage) msg;
0:             byte data[] = new byte[(int) m.getBodyLength()];
0:             m.readBytes(data);
0:             m.reset(); // Need to reset after readBytes or future readBytes
0:                        // calls (ex: redeliveries) will fail and return -1
0:             body = new Data(new Binary(data));
1:         }
0:         if (msg instanceof TextMessage) {
0:             body = new AmqpValue(((TextMessage) msg).getText());
1:         }
0:         if (msg instanceof MapMessage) {
0:             final HashMap<String, Object> map = new HashMap<String, Object>();
0:             final MapMessage m = (MapMessage) msg;
0:             final Enumeration<String> names = m.getMapNames();
0:             while (names.hasMoreElements()) {
0:                 String key = names.nextElement();
0:                 map.put(key, m.getObject(key));
1:             }
0:             body = new AmqpValue(map);
1:         }
0:         if (msg instanceof StreamMessage) {
0:             ArrayList<Object> list = new ArrayList<Object>();
0:             final StreamMessage m = (StreamMessage) msg;
0:             try {
0:                 while (true) {
0:                     list.add(m.readObject());
1:                 }
0:             } catch (MessageEOFException e) {
1:             }
0:             body = new AmqpSequence(list);
1:         }
0:         if (msg instanceof ObjectMessage) {
0:             body = new AmqpValue(((ObjectMessage) msg).getObject());
1:         }
1: 
0:         header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);
0:         header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));
0:         if (msg.getJMSType() != null) {
1:             if (maMap == null) {
0:                 maMap = new HashMap<Symbol, Object>();
1:             }
0:             maMap.put(Symbol.valueOf("x-opt-jms-type"), msg.getJMSType());
1:         }
0:         if (msg.getJMSMessageID() != null) {
0:             props.setMessageId(msg.getJMSMessageID());
1:         }
0:         if (msg.getJMSDestination() != null) {
0:             props.setTo(vendor.toAddress(msg.getJMSDestination()));
1:             if (maMap == null) {
0:                 maMap = new HashMap<Symbol, Object>();
1:             }
0:             maMap.put(Symbol.valueOf("x-opt-to-type"), destinationAttributes(msg.getJMSDestination()));
1:         }
0:         if (msg.getJMSReplyTo() != null) {
0:             props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));
1:             if (maMap == null) {
0:                 maMap = new HashMap<Symbol, Object>();
1:             }
0:             maMap.put(Symbol.valueOf("x-opt-reply-type"), destinationAttributes(msg.getJMSReplyTo()));
1:         }
0:         if (msg.getJMSCorrelationID() != null) {
0:             props.setCorrelationId(msg.getJMSCorrelationID());
1:         }
0:         if (msg.getJMSExpiration() != 0) {
0:             long ttl = msg.getJMSExpiration() - System.currentTimeMillis();
1:             if (ttl < 0) {
1:                 ttl = 1;
1:             }
1:             header.setTtl(new UnsignedInteger((int) ttl));
1: 
0:             props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));
1:         }
0:         if (msg.getJMSTimestamp() != 0) {
0:             props.setCreationTime(new Date(msg.getJMSTimestamp()));
1:         }
1: 
0:         final Enumeration<String> keys = msg.getPropertyNames();
0:         while (keys.hasMoreElements()) {
0:             String key = keys.nextElement();
0:             if (key.equals(messageFormatKey) || key.equals(nativeKey)) {
0:                 // skip..
0:             } else if (key.equals(firstAcquirerKey)) {
0:                 header.setFirstAcquirer(msg.getBooleanProperty(key));
0:             } else if (key.startsWith("JMSXDeliveryCount")) {
0:                 // The AMQP delivery-count field only includes prior failed delivery attempts,
0:                 // whereas JMSXDeliveryCount includes the first/current delivery attempt.
0:                 int amqpDeliveryCount = msg.getIntProperty(key) - 1;
0:                 if (amqpDeliveryCount > 0) {
0:                     header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));
1:                 }
0:             } else if (key.startsWith("JMSXUserID")) {
0:                 String value = msg.getStringProperty(key);
0:                 props.setUserId(new Binary(value.getBytes("UTF-8")));
0:             } else if (key.startsWith("JMSXGroupID")) {
0:                 String value = msg.getStringProperty(key);
0:                 props.setGroupId(value);
0:                 if (apMap == null) {
0:                     apMap = new HashMap();
1:                 }
0:                 apMap.put(key, value);
0:             } else if (key.startsWith("JMSXGroupSeq")) {
0:                 UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));
0:                 props.setGroupSequence(value);
0:                 if (apMap == null) {
0:                     apMap = new HashMap();
1:                 }
0:                 apMap.put(key, value);
0:             } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {
0:                 if (daMap == null) {
0:                     daMap = new HashMap<Symbol, Object>();
1:                 }
0:                 String name = key.substring(prefixDeliveryAnnotationsKey.length());
0:                 daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));
0:             } else if (key.startsWith(prefixMessageAnnotationsKey)) {
1:                 if (maMap == null) {
0:                     maMap = new HashMap<Symbol, Object>();
1:                 }
0:                 String name = key.substring(prefixMessageAnnotationsKey.length());
0:                 maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));
0:             } else if (key.equals(subjectKey)) {
0:                 props.setSubject(msg.getStringProperty(key));
0:             } else if (key.equals(contentTypeKey)) {
0:                 props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));
0:             } else if (key.equals(contentEncodingKey)) {
0:                 props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));
0:             } else if (key.equals(replyToGroupIDKey)) {
0:                 props.setReplyToGroupId(msg.getStringProperty(key));
0:             } else if (key.startsWith(prefixFooterKey)) {
0:                 if (footerMap == null) {
0:                     footerMap = new HashMap();
1:                 }
0:                 String name = key.substring(prefixFooterKey.length());
0:                 footerMap.put(name, msg.getObjectProperty(key));
0:             } else {
0:                 if (apMap == null) {
0:                     apMap = new HashMap();
1:                 }
0:                 apMap.put(key, msg.getObjectProperty(key));
1:             }
1:         }
1: 
0:         MessageAnnotations ma = null;
0:         if (maMap != null) {
0:             ma = new MessageAnnotations(maMap);
1:         }
0:         DeliveryAnnotations da = null;
1:         if (daMap != null) {
0:             da = new DeliveryAnnotations(daMap);
1:         }
0:         ApplicationProperties ap = null;
1:         if (apMap != null) {
0:             ap = new ApplicationProperties(apMap);
1:         }
0:         Footer footer = null;
1:         if (footerMap != null) {
0:             footer = new Footer(footerMap);
1:         }
1: 
0:         return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);
1:     }
1: 
0:     private Object destinationAttributes(Destination destination) {
0:         if (isUseByteDestinationTypeAnnotations()) {
0:             if (destination instanceof Queue) {
0:                 if (destination instanceof TemporaryQueue) {
0:                     return JMSVendor.TEMP_QUEUE_TYPE;
0:                 } else {
0:                     return JMSVendor.QUEUE_TYPE;
1:                 }
1:             }
0:             if (destination instanceof Topic) {
0:                 if (destination instanceof TemporaryTopic) {
0:                     return JMSVendor.TEMP_TOPIC_TYPE;
0:                 } else {
0:                     return JMSVendor.TOPIC_TYPE;
1:                 }
1:             }
0:             return JMSVendor.QUEUE_TYPE;
0:         } else {
0:             if (destination instanceof Queue) {
0:                 if (destination instanceof TemporaryQueue) {
0:                     return "temporary,queue";
0:                 } else {
0:                     return "queue";
1:                 }
1:             }
0:             if (destination instanceof Topic) {
0:                 if (destination instanceof TemporaryTopic) {
0:                     return "temporary,topic";
0:                 } else {
0:                     return "topic";
1:                 }
1:             }
0:             return "";
1:         }
1:     }
1: }
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:6b18857
/////////////////////////////////////////////////////////////////////////
0:             props.setSubject(msg.getJMSType());
/////////////////////////////////////////////////////////////////////////
commit:37b1b6a
/////////////////////////////////////////////////////////////////////////
0:     private static String destinationAttributes(Destination destination) {
0:         if (destination instanceof Queue) {
0:             if (destination instanceof TemporaryQueue) {
0:                 return "temporary,queue";
0:             } else {
0:                 return "queue";
0:         if (destination instanceof Topic) {
0:             if (destination instanceof TemporaryTopic) {
0:                 return "temporary,topic";
0:             } else {
0:                 return "topic";
0:             }
0:         }
0:         return "";
============================================================================