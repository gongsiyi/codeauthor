1:dd2556b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:4dd5b5e:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8f3e831:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:dd2556b:  */
1:d29ca2a: package org.apache.activemq.pool;
1:8fc47c6: 
1:b66559e: import java.io.IOException;
1:b66559e: import java.util.HashMap;
1:55a8ef5: import java.util.Properties;
1:dd2556b: 
1:d29ca2a: import javax.jms.Connection;
1:b66559e: import javax.naming.NamingException;
1:b66559e: import javax.naming.Reference;
1:dd2556b: 
1:c0bc3e0: import org.apache.activemq.ActiveMQConnection;
1:c0bc3e0: import org.apache.activemq.ActiveMQConnectionFactory;
1:c0bc3e0: import org.apache.activemq.Service;
1:b66559e: import org.apache.activemq.jms.pool.ConnectionPool;
1:b66559e: import org.apache.activemq.jndi.JNDIReferenceFactory;
1:b66559e: import org.apache.activemq.jndi.JNDIStorableInterface;
1:b66559e: import org.apache.activemq.transport.TransportListener;
1:b66559e: import org.apache.activemq.util.IntrospectionSupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:8fc47c6: 
1:dd2556b: /**
1:b66559e:  * Add Service and Referenceable and TransportListener to @link{org.apache.activemq.jms.pool.PooledConnectionFactory}
1:8fc47c6:  *
1:99372e1:  * @org.apache.xbean.XBean element="pooledConnectionFactory"
1:dd2556b:  */
1:b66559e: public class PooledConnectionFactory extends org.apache.activemq.jms.pool.PooledConnectionFactory implements JNDIStorableInterface, Service {
1:b66559e:     public static final String POOL_PROPS_PREFIX = "pool";
1:b432173: 
1:b66559e:     private static final transient Logger LOG = LoggerFactory.getLogger(org.apache.activemq.jms.pool.PooledConnectionFactory.class);
1:b432173: 
1:d29ca2a:     public PooledConnectionFactory() {
1:b66559e:         super();
1:8fc47c6:     }
1:8fc47c6: 
1:b66559e:     public PooledConnectionFactory(ActiveMQConnectionFactory activeMQConnectionFactory) {
1:b66559e:         setConnectionFactory(activeMQConnectionFactory);
1:dd2556b:     }
1:b66559e: 
1:d29ca2a:     public PooledConnectionFactory(String brokerURL) {
1:b66559e:         setConnectionFactory(new ActiveMQConnectionFactory(brokerURL));
1:dd2556b:     }
1:b66559e: 
1:b432173:     @SuppressWarnings({ "unchecked", "rawtypes" })
1:55a8ef5:     protected void buildFromProperties(Properties props) {
1:55a8ef5:         ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
1:55a8ef5:         activeMQConnectionFactory.buildFromProperties(props);
1:b66559e:         setConnectionFactory(activeMQConnectionFactory);
1:b66559e:         IntrospectionSupport.setProperties(this, new HashMap(props), POOL_PROPS_PREFIX);
1:8fc47c6:     }
1:b66559e: 
1:b432173:     @Override
1:b66559e:     protected void populateProperties(Properties props) {
1:b66559e:         ((ActiveMQConnectionFactory)getConnectionFactory()).populateProperties(props);
1:b432173:         super.populateProperties(props);
1:8fc47c6:     }
1:b66559e: 
2:55a8ef5:     @Override
1:b66559e:     public void setProperties(Properties properties) {
1:b66559e:         buildFromProperties(properties);
1:8fc47c6:     }
1:b66559e: 
1:b66559e:     @Override
1:b66559e:     public Properties getProperties() {
1:b66559e:         Properties properties = new Properties();
1:b66559e:         populateProperties(properties);
1:b66559e:         return properties;
1:8fc47c6:     }
1:b66559e: 
1:b66559e:     @Override
1:b66559e:     public Reference getReference() throws NamingException {
1:b66559e:         return JNDIReferenceFactory.createReference(this.getClass().getName(), this);
3:b66559e:     }
1:b66559e: 
1:b66559e:     @Override
1:b66559e:     protected Connection newPooledConnection(ConnectionPool connection) {
1:b66559e:         return new PooledConnection(connection);
1:b66559e:     }
1:b66559e: 
1:b66559e:     @Override
1:b66559e:     protected org.apache.activemq.jms.pool.ConnectionPool createConnectionPool(Connection connection) {
1:b66559e:         return new ConnectionPool(connection) {
1:b66559e: 
1:b66559e:             @Override
1:b66559e:             protected Connection wrap(final Connection connection) {
1:b66559e:                 // Add a transport Listener so that we can notice if this connection
1:b66559e:                 // should be expired due to a connection failure.
1:b66559e:                 ((ActiveMQConnection)connection).addTransportListener(new TransportListener() {
1:b66559e:                     @Override
1:b66559e:                     public void onCommand(Object command) {
1:b66559e:                     }
1:b66559e: 
1:b66559e:                     @Override
1:b66559e:                     public void onException(IOException error) {
1:b66559e:                         synchronized (this) {
1:b66559e:                             setHasExpired(true);
1:960186a:                             // only log if not stopped
1:960186a:                             if (!stopped.get()) {
1:960186a:                                 LOG.info("Expiring connection " + connection + " on IOException: " + error.getMessage());
1:960186a:                                 // log stacktrace at debug level
1:960186a:                                 LOG.debug("Expiring connection " + connection + " on IOException: ", error);
1:960186a:                             }
1:b66559e:                         }
1:b66559e:                     }
1:b66559e: 
1:b66559e:                     @Override
1:b66559e:                     public void transportInterupted() {
1:b66559e:                     }
1:b66559e: 
1:b66559e:                     @Override
1:b66559e:                     public void transportResumed() {
1:b66559e:                     }
1:b66559e:                 });
1:b66559e: 
1:b66559e:                 // make sure that we set the hasFailed flag, in case the transport already failed
1:b66559e:                 // prior to the addition of our new TransportListener
1:b66559e:                 setHasExpired(((ActiveMQConnection)connection).isTransportFailed());
1:b66559e: 
1:b66559e:                 // may want to return an amq EnhancedConnection
1:b66559e:                 return connection;
1:b66559e:             }
1:b66559e: 
1:b66559e:             @Override
1:b66559e:             protected void unWrap(Connection connection) {
1:b66559e:                 if (connection != null) {
1:b66559e:                     ((ActiveMQConnection)connection).cleanUpTempDestinations();
1:b66559e:                 }
1:b66559e:             }
1:b66559e:         };
1:b66559e:     }
1:b66559e: }
============================================================================
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:960186a
/////////////////////////////////////////////////////////////////////////
1:                             // only log if not stopped
1:                             if (!stopped.get()) {
1:                                 LOG.info("Expiring connection " + connection + " on IOException: " + error.getMessage());
1:                                 // log stacktrace at debug level
1:                                 LOG.debug("Expiring connection " + connection + " on IOException: ", error);
1:                             }
commit:dd2556b
/////////////////////////////////////////////////////////////////////////
0:     private int maximumActiveSessionPerConnection = 500;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @deprecated use {@link #getMaximumActiveSessionPerConnection()}
1:      */
0:     @Deprecated
0:         return getMaximumActiveSessionPerConnection();
1:     }
1: 
1:     /**
0:      * @deprecated use {@link #setMaximumActiveSessionPerConnection(int)}
1:      */
0:     @Deprecated
0:     public void setMaximumActive(int maximumActive) {
0:         setMaximumActiveSessionPerConnection(maximumActive);
1:     }
1: 
0:     public int getMaximumActiveSessionPerConnection() {
0:         return maximumActiveSessionPerConnection;
0:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
0:         this.maximumActiveSessionPerConnection = maximumActiveSessionPerConnection;
/////////////////////////////////////////////////////////////////////////
0:             return new GenericObjectPoolFactory(null, maximumActiveSessionPerConnection);
0:                 maximumActiveSessionPerConnection,
commit:8fc47c6
/////////////////////////////////////////////////////////////////////////
0:     private final Map<ConnectionKey, LinkedList<ConnectionPool>> cache = new HashMap<ConnectionKey, LinkedList<ConnectionPool>>();
0:     private final AtomicBoolean stopped = new AtomicBoolean(false);
0:     private boolean createConnectionOnStartup = true;
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Connection has expired: {}", connection);
1:             }
1: 
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Created new connection: {}", connection);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Staring the PooledConnectionFactory");
0:         stopped.set(false);
0:         if (isCreateConnectionOnStartup()) {
0:             try {
0:                 // warm the pool by creating a connection during startup
0:                 createConnection();
0:             } catch (JMSException e) {
0:                 LOG.warn("Create pooled connection during start failed. This exception will be ignored.", e);
1:             }
0:         LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}", cache.size());
0:                 } catch (Exception e) {
0:                     LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isCreateConnectionOnStartup() {
0:         return createConnectionOnStartup;
1:     }
1: 
0:     /**
0:      * Whether to create a connection on starting this {@link PooledConnectionFactory}.
0:      * <p/>
0:      * This can be used to warmup the pool on startup. Notice that any kind of exception
0:      * happens during startup is logged at WARN level and ignored.
1:      *
0:      * @param createConnectionOnStartup <tt>true</tt> to create a connection on startup
0:      */
0:     public void setCreateConnectionOnStartup(boolean createConnectionOnStartup) {
0:         this.createConnectionOnStartup = createConnectionOnStartup;
1:     }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:b432173
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "unchecked", "rawtypes" })
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         super.populateProperties(props);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:gtully
-------------------------------------------------------------------------------
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.HashMap;
1: import javax.naming.NamingException;
1: import javax.naming.Reference;
1: import org.apache.activemq.jms.pool.ConnectionPool;
1: import org.apache.activemq.jndi.JNDIReferenceFactory;
1: import org.apache.activemq.jndi.JNDIStorableInterface;
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.IntrospectionSupport;
1:  * Add Service and Referenceable and TransportListener to @link{org.apache.activemq.jms.pool.PooledConnectionFactory}
1: public class PooledConnectionFactory extends org.apache.activemq.jms.pool.PooledConnectionFactory implements JNDIStorableInterface, Service {
1:     public static final String POOL_PROPS_PREFIX = "pool";
1:     private static final transient Logger LOG = LoggerFactory.getLogger(org.apache.activemq.jms.pool.PooledConnectionFactory.class);
1:         super();
1:     public PooledConnectionFactory(ActiveMQConnectionFactory activeMQConnectionFactory) {
1:         setConnectionFactory(activeMQConnectionFactory);
1:     }
1: 
1:         setConnectionFactory(new ActiveMQConnectionFactory(brokerURL));
1:         setConnectionFactory(activeMQConnectionFactory);
1:         IntrospectionSupport.setProperties(this, new HashMap(props), POOL_PROPS_PREFIX);
1:     }
1: 
1:     protected void populateProperties(Properties props) {
1:         ((ActiveMQConnectionFactory)getConnectionFactory()).populateProperties(props);
0:         IntrospectionSupport.getProperties(this, props, POOL_PROPS_PREFIX);
1:     public void setProperties(Properties properties) {
1:         buildFromProperties(properties);
1: 
1:     @Override
1:     public Properties getProperties() {
1:         Properties properties = new Properties();
1:         populateProperties(properties);
1:         return properties;
1:     }
1: 
1: 
1:     @Override
1:     public Reference getReference() throws NamingException {
1:         return JNDIReferenceFactory.createReference(this.getClass().getName(), this);
1:     }
1: 
1:     @Override
1:     protected Connection newPooledConnection(ConnectionPool connection) {
1:         return new PooledConnection(connection);
1:     }
1: 
1:     @Override
1:     protected org.apache.activemq.jms.pool.ConnectionPool createConnectionPool(Connection connection) {
1:         return new ConnectionPool(connection) {
1: 
1:             @Override
1:             protected Connection wrap(final Connection connection) {
1:                 // Add a transport Listener so that we can notice if this connection
1:                 // should be expired due to a connection failure.
1:                 ((ActiveMQConnection)connection).addTransportListener(new TransportListener() {
1:                     @Override
1:                     public void onCommand(Object command) {
1:                     }
1: 
1:                     @Override
1:                     public void onException(IOException error) {
1:                         synchronized (this) {
1:                             setHasExpired(true);
0:                             LOG.info("Expiring connection {} on IOException: {}" , connection, error);
0:                             LOG.debug("Expiring connection on IOException", error);
1:                         }
1:                     }
1: 
1:                     @Override
1:                     public void transportInterupted() {
1:                     }
1: 
1:                     @Override
1:                     public void transportResumed() {
1:                     }
1:                 });
1: 
1:                 // make sure that we set the hasFailed flag, in case the transport already failed
1:                 // prior to the addition of our new TransportListener
1:                 setHasExpired(((ActiveMQConnection)connection).isTransportFailed());
1: 
1:                 // may want to return an amq EnhancedConnection
1:                 return connection;
1:             }
1: 
1:             @Override
1:             protected void unWrap(Connection connection) {
1:                 if (connection != null) {
1:                     ((ActiveMQConnection)connection).cleanUpTempDestinations();
1:                 }
1:             }
1:         };
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:55a8ef5
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.jndi.JNDIBaseStorable;
/////////////////////////////////////////////////////////////////////////
0: public class PooledConnectionFactory extends JNDIBaseStorable implements ConnectionFactory, Service {
/////////////////////////////////////////////////////////////////////////
0: 
1:     @Override
1:     protected void buildFromProperties(Properties props) {
1:         ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
1:         activeMQConnectionFactory.buildFromProperties(props);
0:         connectionFactory = activeMQConnectionFactory;
0:     }
0: 
1:     @Override
0:     protected void populateProperties(Properties props) {
0:         ((ActiveMQConnectionFactory)connectionFactory).populateProperties(props);
0:     }
commit:4a23f0d
/////////////////////////////////////////////////////////////////////////
0:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that 
0:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail: 
commit:8f3e831
/////////////////////////////////////////////////////////////////////////
0:  * Connections, sessions and producers are returned to a pool after use so that they can be reused later
0:  * without having to undergo the cost of creating them again.
0:  * b>NOTE:</b> while this implementation does allow the creation of a collection of active consumers,
0:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which 
0:  * are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually
0:  * just created at startup and left active, handling incoming messages as they come. When a consumer is
0:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because, 
0:  * even if a consumer is idle, ActiveMQ will keep delivering messages to the consumer's prefetch buffer,
0:  * where they'll get held until the consumer is active again.
1:  * 
0:  * If you are creating a collection of consumers (for example, for multi-threaded message consumption), you
0:  * might want to consider using a lower value for each consumer (e.g. 10 or 20), to ensure that all messages
0:  * don't end up going to just one of the consumers. See this FAQ entry for more detail: 
0:  * http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
commit:ff43b7a
/////////////////////////////////////////////////////////////////////////
0:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's <a
0:  * href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
0:  * <b>NOTE</b> this implementation does not pool consumers. Pooling makes sense for seldom used
0:  * resources that are expensive to create and can remain idle a minimal cost. like sessions and producers.
0:  * Consumers on the other hand, will consume messages even when idle due to <a 
0:  * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch</a>.
0:  * If you want to consider a consumer pool, configure an appropriate prefetch and a pool
0:  * allocation strategy that is inclusive. Also note that message order guarantees will be
0:  * lost across the consumer pool. 
commit:4dd5b5e
/////////////////////////////////////////////////////////////////////////
0:     private long expiryTimeout = 0l;
/////////////////////////////////////////////////////////////////////////
0:         result.setExpiryTimeout(getExpiryTimeout());
/////////////////////////////////////////////////////////////////////////
0:             for (ConnectionPool connection : iter.next()) {
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * allow connections to expire, irrespective of load or idle time. This is useful with failover
0:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
1:      * 
0:      * @param expiryTimeout non zero in milliseconds
0:      */
0:     public void setExpiryTimeout(long expiryTimeout) {
0:         this.expiryTimeout = expiryTimeout;   
0:     }
0:     
0:     public long getExpiryTimeout() {
0:         return expiryTimeout;
0:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:858ab26
/////////////////////////////////////////////////////////////////////////
0: 
0:             // We can race against other threads returning the connection when there is an
0:             // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
0:             // we win and get a non-closed instance and then increment the reference count
0:             // under lock to prevent another thread from triggering an expiration check and
0:             // pulling the rug out from under us.
0:             while (connection == null) {
0:                 connection = connectionsPool.borrowObject(key);
0:                 synchronized (connection) {
0:                     if (connection.getConnection() != null) {
0:                         connection.incrementReferenceCount();
0:                         break;
0:                     }
0: 
0:                     // Return the bad one to the pool and let if get destroyed as normal.
0:                     connectionsPool.returnObject(key, connection);
0:                     connection = null;
0:                 }
0:             }
commit:e1d4a0f
/////////////////////////////////////////////////////////////////////////
0:     public long getTimeBetweenExpirationCheckMillis() {
commit:f664be7
/////////////////////////////////////////////////////////////////////////
0:      * @return idle timeout value (milliseconds)
0:      * Sets the idle timeout  value for Connection's that are created by this pool in Milliseconds,
0:      * defaults to 30 seconds.
commit:a34fbb9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:8b84374
/////////////////////////////////////////////////////////////////////////
0:                     ConnectionPool connection = createConnectionPool(delegate);
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Delegate that creates each instance of an ConnectionPool object.  Subclasses can override
0:      * this method to customize the type of connection pool returned.
0:      *
0:      * @param connection
0:      *
0:      * @return instance of a new ConnectionPool.
0:      */
0:     protected ConnectionPool createConnectionPool(ActiveMQConnection connection) {
0:         return new ConnectionPool(connection);
0:     }
commit:a59c9ba
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.commons.pool.KeyedObjectPool;
0: import org.apache.commons.pool.KeyedPoolableObjectFactory;
0: import org.apache.commons.pool.ObjectPoolFactory;
0: import org.apache.commons.pool.impl.GenericKeyedObjectPool;
0:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's
0:  * <a href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
/////////////////////////////////////////////////////////////////////////
0:  * Optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
0:  * pool. This is performed by an "idle object eviction" thread, which runs asynchronously. Caution should
0:  * be used when configuring this optional feature. Eviction runs contend with client threads for access
0:  * to objects in the pool, so if they run too frequently performance issues may result. The idle object
0:  * eviction thread may be configured using the {@link setTimeBetweenExpirationCheckMillis} method.  By
0:  * default the value is -1 which means no eviction thread will be run.  Set to a non-negative value to
0:  * configure the idle eviction thread to run.
0:  *
0: 
0:     private final AtomicBoolean stopped = new AtomicBoolean(false);
0:     private final GenericKeyedObjectPool<ConnectionKey, ConnectionPool> connectionsPool;
0: 
0: 
0:     /**
0:      * Creates new PooledConnectionFactory with a default ActiveMQConnectionFactory instance.
0:      * <p/>
0:      * The URI used to connect to ActiveMQ comes from the default value of ActiveMQConnectionFactory.
0:      */
0:     /**
0:      * Creates a new PooledConnectionFactory that will use the given broker URI to connect to
0:      * ActiveMQ.
0:      *
0:      * @param brokerURL
0:      *      The URI to use to configure the internal ActiveMQConnectionFactory.
0:      */
0:     /**
0:      * Creates a new PooledConnectionFactory that will use the given ActiveMQConnectionFactory to
0:      * create new ActiveMQConnection instances that will be pooled.
0:      *
0:      * @param connectionFactory
0:      *      The ActiveMQConnectionFactory to create new Connections for this pool.
0:      */
0: 
0:         this.connectionsPool = new GenericKeyedObjectPool<ConnectionKey, ConnectionPool>(
0:             new KeyedPoolableObjectFactory<ConnectionKey, ConnectionPool>() {
0: 
0:                 @Override
0:                 public void activateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
0:                 }
0: 
0:                 @Override
0:                 public void destroyObject(ConnectionKey key, ConnectionPool connection) throws Exception {
0:                     try {
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace("Destroying connection: {}", connection);
0:                         }
0:                         connection.close();
0:                     } catch (Exception e) {
0:                         LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
0:                     }
0:                 }
0: 
0:                 @Override
0:                 public ConnectionPool makeObject(ConnectionKey key) throws Exception {
0:                     ActiveMQConnection delegate = createConnection(key);
0: 
0:                     ConnectionPool connection = new ConnectionPool(delegate);
0:                     connection.setIdleTimeout(getIdleTimeout());
0:                     connection.setExpiryTimeout(getExpiryTimeout());
0:                     connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
0:                     connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
0: 
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("Created new connection: {}", connection);
0:                     }
0: 
0:                     return connection;
0:                 }
0: 
0:                 @Override
0:                 public void passivateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
0:                 }
0: 
0:                 @Override
0:                 public boolean validateObject(ConnectionKey key, ConnectionPool connection) {
0:                     if (connection != null && connection.expiredCheck()) {
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace("Connection has expired: {} and will be destroyed", connection);
0:                         }
0: 
0:                         return false;
0:                     }
0: 
0:                     return true;
0:                 }
0:         });
0: 
0:         // Set max idle (not max active) since our connections always idle in the pool.
0:         this.connectionsPool.setMaxIdle(1);
0: 
0:         // We always want our validate method to control when idle objects are evicted.
0:         this.connectionsPool.setTestOnBorrow(true);
0:         this.connectionsPool.setTestWhileIdle(true);
0:     /**
0:      * @return the currently configured ConnectionFactory used to create the pooled Connections.
0:      */
0:     /**
0:      * Sets the ConnectionFactory used to create new pooled Connections.
0:      * <p/>
0:      * Updates to this value do not affect Connections that were previously created and placed
0:      * into the pool.  In order to allocate new Connections based off this new ConnectionFactory
0:      * it is first necessary to {@link clear} the pooled Connections.
0:      *
0:      * @param connectionFactory
0:      *      The factory to use to create pooled Connections.
0:      */
0:     @Override
0:     @Override
0:         ConnectionKey key = new ConnectionKey(userName, password);
0:         // This will either return an existing non-expired ConnectionPool or it
0:         // will create a new one to meet the demand.
0:         if (connectionsPool.getNumIdle(key) < getMaxConnections()) {
0:             try {
0:                 // we want borrowObject to return the one we added.
0:                 connectionsPool.setLifo(true);
0:                 connectionsPool.addObject(key);
0:             } catch (Exception e) {
0:                 throw JMSExceptionSupport.create("Error while attempting to add new Connection to the pool", e);
0:         } else {
0:             // now we want the oldest one in the pool.
0:             connectionsPool.setLifo(false);
0:         try {
0:             connection = connectionsPool.borrowObject(key);
0:         } catch (Exception e) {
0:             throw JMSExceptionSupport.create("Error while attempting to retrieve a connection from the pool", e);
0: 
0:         try {
0:             connectionsPool.returnObject(key, connection);
0:         } catch (Exception e) {
0:             throw JMSExceptionSupport.create("Error when returning connection to the pool", e);
0:         }
0: 
0:     /**
0:      * @deprecated
0:      */
0:     public ObjectPoolFactory<?> getPoolFactory() {
0:         return null;
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:         LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:         LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}",
0:                   connectionsPool.getNumActive());
0: 
0:         if (stopped.compareAndSet(false, true)) {
0:             try {
0:                 connectionsPool.close();
0:             } catch (Exception e) {
0:      * Clears all connections from the pool.  Each connection that is currently in the pool is
0:      * closed and removed from the pool.  A new connection will be created on the next call to
0:      * {@link createConnection}.  Care should be taken when using this method as Connections that
0:      * are in use be client's will be closed.
0:     public void clear() {
0: 
0:         if (stopped.get()) {
0:             return;
0:         }
0: 
0:         this.connectionsPool.clear();
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Returns the currently configured maximum number of sessions a pooled Connection will
0:      * create before it either blocks or throws an exception when a new session is requested,
0:      * depending on configuration.
0:      *
0:      * @return the number of session instances that can be taken from a pooled connection.
0:      */
0:      *
0:      * @param maximumActiveSessionPerConnection
0:      *      The maximum number of active session per connection in the pool.
/////////////////////////////////////////////////////////////////////////
0:      * Returns whether a pooled Connection will enter a blocked state or will throw an Exception
0:      * once the maximum number of sessions has been borrowed from the the Session Pool.
0:      *
0:      * @return true if the pooled Connection createSession method will block when the limit is hit.
0:      * @see setBlockIfSessionPoolIsFull
0:     public boolean isBlockIfSessionPoolIsFull() {
0:         return this.blockIfSessionPoolIsFull;
0:      * Returns the maximum number to pooled Connections that this factory will allow before it
0:      * begins to return connections from the pool on calls to ({@link createConnection}.
0:      *
0:      * @return the maxConnections that will be created for this pool.
0:      */
0:     public int getMaxConnections() {
0:         return connectionsPool.getMaxIdle();
0:     }
0: 
0:     /**
0:      * Sets the maximum number of pooled Connections (defaults to one).  Each call to
0:      * {@link createConnection} will result in a new Connection being create up to the max
0:      * connections value.
0:      *
0:         this.connectionsPool.setMaxIdle(maxConnections);
0:      * Gets the Idle timeout value applied to new Connection's that are created by this pool.
0:      * <p/>
0:      * The idle timeout is used determine if a Connection instance has sat to long in the pool unused
0:      * and if so is closed and removed from the pool.  The default value is 30 seconds.
0:      * @return
0:     /**
0:      * Sets the idle timeout value for Connection's that are created by this pool, defaults to 30 seconds.
0:      * <p/>
0:      * For a Connection that is in the pool but has no current users the idle timeout determines how
0:      * long the Connection can live before it is eligible for removal from the pool.  Normally the
0:      * connections are tested when an attempt to check one out occurs so a Connection instance can sit
0:      * in the pool much longer than its idle timeout if connections are used infrequently.
0:      *
0:      *
0:      * @param idleTimeout
0:      *      The maximum time a pooled Connection can sit unused before it is eligible for removal.
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * @return the configured expiration timeout for connections in the pool.
0:      */
0:     /**
0:      * @return true if a Connection is created immediately on a call to {@link start}.
0:      */
/////////////////////////////////////////////////////////////////////////
0:      * This can be used to warm-up the pool on startup. Notice that any kind of exception
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Gets the Pool of ConnectionPool instances which are keyed by different ConnectionKeys.
0:      *
0:      * @return this factories pool of ConnectionPool instances.
0:      */
0:     KeyedObjectPool<ConnectionKey, ConnectionPool> getConnectionsPool() {
0:         return this.connectionsPool;
0:     }
0: 
0:     /**
0:      * Sets the number of milliseconds to sleep between runs of the idle Connection eviction thread.
0:      * When non-positive, no idle object eviction thread will be run, and Connections will only be
0:      * checked on borrow to determine if they have sat idle for too long or have failed for some
0:      * other reason.
0:      * <p/>
0:      * By default this value is set to -1 and no expiration thread ever runs.
0:      *
0:      * @param timeBetweenExpirationCheckMillis
0:      *      The time to wait between runs of the idle Connection eviction thread.
0:      */
0:     public void setTimeBetweenExpirationCheckMillis(long timeBetweenExpirationCheckMillis) {
0:         this.connectionsPool.setTimeBetweenEvictionRunsMillis(timeBetweenExpirationCheckMillis);
0:     }
0: 
0:     /**
0:      * @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
0:      */
0:     public long setTimeBetweenExpirationCheckMillis() {
0:         return this.connectionsPool.getTimeBetweenEvictionRunsMillis();
0:     }
0: 
0:     /**
0:      * @return the number of Connections currently in the Pool
0:      */
0:     public int getNumConnections() {
0:         return this.connectionsPool.getNumIdle();
0:     }
0: 
0:     /**
0:      * @deprecated
0:      */
0:     public void setPoolFactory(ObjectPoolFactory<?> factory) {
0:     }
commit:5ac1540
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which
0:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because,
0:  *
0:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
0:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail:
0:  *
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0:     private boolean blockIfSessionPoolIsFull = true;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:      * Controls the behavior of the internal session pool. By default the call to
0:      * Connection.getSession() will block if the session pool is full.  If the
0:      * argument false is given, it will change the default behavior and instead the
0:      * call to getSession() will throw a JMSException.
0:      *
0:      * The size of the session pool is controlled by the @see #maximumActive
0:      *
0:      * @param block - if true, the call to getSession() blocks if the pool is full
0:      * until a session object is available.  defaults to true.
0:         this.blockIfSessionPoolIsFull = block;
/////////////////////////////////////////////////////////////////////////
0:      *
0:          if (blockIfSessionPoolIsFull) {
0:             return new GenericObjectPoolFactory(null, maximumActive);
0:         } else {
0:             return new GenericObjectPoolFactory(null,
0:                 maximumActive,
0:                 GenericObjectPool.WHEN_EXHAUSTED_FAIL,
0:                 GenericObjectPool.DEFAULT_MAX_WAIT);
0:         }
/////////////////////////////////////////////////////////////////////////
0:      *
0:         this.expiryTimeout = expiryTimeout;
0: 
commit:cf914d1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.pool.impl.GenericObjectPool;
/////////////////////////////////////////////////////////////////////////
0:     private boolean blockIfSessionPoolIsFull = false;
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * Controls the behavior of the internal session pool. 
0:      * By default the call to Connection.getSession() will 
0:      * return a JMSException if the session pool is full.
0:      * If the argument true is given, it will change the 
0:      * default behavior and instead the call to getSession()
0:      * will block until a session is available in the pool, which
0:      * used to be the default behavior in ActiveMQ versions < 5.6.
0:      * 
0:      * The size of the session pool is controlled by the @see #maximumActive 
0:      * property.
0:      * 
0:      * @param block - if true, the call to getSession() blocks if the pool
0:      * is full until a session object is available. 
0:      * defaults to false.
0:      */
0:     public void setBlockIfSessionPoolIsFull(boolean block) {
0:     	this.blockIfSessionPoolIsFull = block;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Creates an ObjectPoolFactory. Its behavior is controlled by the two
0:      * properties @see #maximumActive and @see #blockIfSessionPoolIsFull.
0:      * 
0:      * @return the newly created but empty ObjectPoolFactory
0:      */
0:      	if (blockIfSessionPoolIsFull) {
0:     		return new GenericObjectPoolFactory(null, maximumActive);
0:     	} else { 
0:     		return new GenericObjectPoolFactory(null, 
0:         		maximumActive, 
0:         		GenericObjectPool.WHEN_EXHAUSTED_FAIL, 
0:         		GenericObjectPool.DEFAULT_MAX_WAIT);
0:     	}
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private Map<ConnectionKey, LinkedList<ConnectionPool>> cache = new HashMap<ConnectionKey, LinkedList<ConnectionPool>>();
/////////////////////////////////////////////////////////////////////////
0:         LinkedList<ConnectionPool> pools = cache.get(key);
0:             pools = new LinkedList<ConnectionPool>();
0:             connection = pools.removeFirst();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<LinkedList<ConnectionPool>> iter = cache.values().iterator(); iter.hasNext();) {
0:             LinkedList list = iter.next();
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:         LinkedList pools = (LinkedList)cache.get(key);
0: 
0:         if (pools == null) {
0:             connection = (ConnectionPool)pools.removeFirst();
0: 
0:         // Now.. we might get a connection, but it might be that we need to
0:         if (connection != null && connection.expiredCheck()) {
0:             connection = null;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             return (ActiveMQConnection)connectionFactory.createConnection();
0:         } else {
0:             return (ActiveMQConnection)connectionFactory.createConnection(key.getUserName(), key
0:                 .getPassword());
/////////////////////////////////////////////////////////////////////////
0:         } catch (JMSException e) {
0:     public void stop() throws Exception {
0:         for (Iterator iter = cache.values().iterator(); iter.hasNext();) {
0:             LinkedList list = (LinkedList)iter.next();
0:             for (Iterator i = list.iterator(); i.hasNext();) {
0:                 ConnectionPool connection = (ConnectionPool)i.next();
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:c0bc3e0
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.Service;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.commons.pool.ObjectPoolFactory;
0: import org.apache.commons.pool.impl.GenericObjectPoolFactory;
/////////////////////////////////////////////////////////////////////////
0:         
0:         // Now.. we might get a connection, but it might be that we need to 
0:         // dump it..
0:         if( connection!=null && connection.expiredCheck() ) {
0:         	connection=null;
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:             connection.close();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.pool;
0: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.Service;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: 
1: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: 
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
0: 
0: /**
0:  * A JMS provider which pools Connection, Session and MessageProducer instances
0:  * so it can be used with tools like Spring's <a
0:  * href="http://activemq.org/Spring+Support">JmsTemplate</a>.
0:  * 
0:  * <b>NOTE</b> this implementation is only intended for use when sending
0:  * messages.
0:  * 
0:  * @version $Revision: 1.1 $
0:  */
0: public class PooledConnectionFactory implements ConnectionFactory, Service {
0:     private ActiveMQConnectionFactory connectionFactory;
0:     private Map cache = new HashMap();
0: 
1:     public PooledConnectionFactory() {
0:         this(new ActiveMQConnectionFactory());
0:     }
0: 
1:     public PooledConnectionFactory(String brokerURL) {
0:         this(new ActiveMQConnectionFactory(brokerURL));
0:     }
0: 
0:     public PooledConnectionFactory(ActiveMQConnectionFactory connectionFactory) {
0:         this.connectionFactory = connectionFactory;
0:     }
0: 
0:     public ActiveMQConnectionFactory getConnectionFactory() {
0:         return connectionFactory;
0:     }
0: 
0:     public void setConnectionFactory(ActiveMQConnectionFactory connectionFactory) {
0:         this.connectionFactory = connectionFactory;
0:     }
0: 
0:     public Connection createConnection() throws JMSException {
0:         return createConnection(null, null);
0:     }
0: 
0:     public synchronized Connection createConnection(String userName, String password) throws JMSException {
0:         ConnectionKey key = new ConnectionKey(userName, password);
0:         ConnectionPool connection = (ConnectionPool) cache.get(key);
0:         if (connection == null) {
0:             ActiveMQConnection delegate = createConnection(key);
0:             connection = new ConnectionPool(delegate);
0:             cache.put(key, connection);
0:         }
0:         return new PooledConnection(connection);
0:     }
0: 
0:     protected ActiveMQConnection createConnection(ConnectionKey key) throws JMSException {
0:         if (key.getUserName() == null && key.getPassword() == null) {
0:             return (ActiveMQConnection) connectionFactory.createConnection();
0:         }
0:         else {
0:             return (ActiveMQConnection) connectionFactory.createConnection(key.getUserName(), key.getPassword());
0:         }
0:     }
0: 
0:     /**
0:      * @see org.apache.activemq.service.Service#start()
0:      */
0:     public void start() {
0:         try {
0:             createConnection();
0:         }
0:         catch (JMSException e) {
0:             IOExceptionSupport.create(e);
0:         }
0:     }
0: 
0:     public void stop() throws Exception {
0:         ServiceStopper stopper = new ServiceStopper();
0:         for (Iterator iter = cache.values().iterator(); iter.hasNext();) {
0:             ConnectionPool connection = (ConnectionPool) iter.next();
0:             try {
0:                 connection.close();
0:             }
0:             catch (JMSException e) {
0:                 stopper.onException(this, e);
0:             }
0:         }
0:         stopper.throwFirstException();
0:     }
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledConnectionFactory.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:99372e1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean element="pooledConnectionFactory"
0:  * 
commit:6dc8e1d
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Log LOG = LogFactory.getLog(PooledConnectionFactory.class);
0:     private AtomicBoolean stopped = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:         if (stopped.get()) {
0:             LOG.debug("PooledConnectionFactory is stopped, skip create new connection.");
0:             return null;
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:             stopped.set(false);
0:             LOG.warn("Create pooled connection during start failed.", e);
0:     public void stop() {
0:         LOG.debug("Stop the PooledConnectionFactory, number of connections in cache: "+cache.size());
0:         stopped.set(true);
0:                 try {
0:                     connection.close();
0:                 }catch(Exception e) {
0:                     LOG.warn("Close connection failed",e);
0:                 }
commit:5c7374b
/////////////////////////////////////////////////////////////////////////
0:     private int idleTimeout = 30 * 1000;
/////////////////////////////////////////////////////////////////////////
0:         ConnectionPool result =  new ConnectionPool(connection, getPoolFactory(), transactionManager);
0:         result.setIdleTimeout(getIdleTimeout());
0:         return result;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public int getIdleTimeout() {
0:         return idleTimeout;
0:     }
0: 
0:     public void setIdleTimeout(int idleTimeout) {
0:         this.idleTimeout = idleTimeout;
0:     }
commit:fe3f492
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception{
0:         for(Iterator iter=cache.values().iterator();iter.hasNext();){
0:             LinkedList list=(LinkedList)iter.next();
0:             for(Iterator i=list.iterator();i.hasNext();){
0:                 ConnectionPool connection=(ConnectionPool)i.next();
0:                 connection.close();
0:             }
0:         cache.clear();
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:2e57fb5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ConnectionPool result =  new ConnectionPool(connection, getPoolFactory());
/////////////////////////////////////////////////////////////////////////
0:             return (ActiveMQConnection)connectionFactory.createConnection(key.getUserName(), key.getPassword());
/////////////////////////////////////////////////////////////////////////
0:                 ConnectionPool connection = (ConnectionPool) i.next();
commit:8704012
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedList;
0: import javax.transaction.TransactionManager;
/////////////////////////////////////////////////////////////////////////
0:     private ConnectionFactory connectionFactory;
0:     private int maximumActive = 500;
0:     private int maxConnections = 1;
0:     private TransactionManager transactionManager;
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionFactory getConnectionFactory() {
0:     public void setConnectionFactory(ConnectionFactory connectionFactory) {
0:     public TransactionManager getTransactionManager() {
0:         return transactionManager;
0:     }
0: 
0:     public void setTransactionManager(TransactionManager transactionManager) {
0:         this.transactionManager = transactionManager;
0:     }
0: 
0:         LinkedList pools = (LinkedList) cache.get(key);
0:         
0:         if (pools ==  null) {
0:             pools = new LinkedList();
0:             cache.put(key, pools);
0:         }
0: 
0:         ConnectionPool connection = null;
0:         if (pools.size() == maxConnections) {
0:             connection = (ConnectionPool) pools.removeFirst();
0:         }
/////////////////////////////////////////////////////////////////////////
0:             connection = createConnectionPool(delegate);
0:         pools.add(connection);
0:     
0:     protected ConnectionPool createConnectionPool(ActiveMQConnection connection) {
0:         return new ConnectionPool(connection, getPoolFactory(), transactionManager);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * @return the maxConnections
0:      */
0:     public int getMaxConnections() {
0:         return maxConnections;
0:     }
0: 
0:     /**
0:      * @param maxConnections the maxConnections to set
0:      */
0:     public void setMaxConnections(int maxConnections) {
0:         this.maxConnections = maxConnections;
0:     }
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:2fd7ccb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.pool.ObjectPoolFactory;
0: import org.apache.commons.pool.impl.GenericObjectPoolFactory;
0: import org.apache.commons.pool.impl.GenericObjectPool.Config;
/////////////////////////////////////////////////////////////////////////
0:  * messages. It does not deal with pooling of consumers; for that look at a
0:  * library like <a href="http://jencks.org/">Jencks</a> such as in <a
0:  * href="http://jencks.org/Message+Driven+POJOs">this example</a>
0:     private ObjectPoolFactory poolFactory;
0:     private int maximumActive = 5000;
/////////////////////////////////////////////////////////////////////////
0:             connection = new ConnectionPool(delegate, getPoolFactory());
/////////////////////////////////////////////////////////////////////////
0: 
0:     public ObjectPoolFactory getPoolFactory() {
0:         if (poolFactory == null) {
0:             poolFactory = createPoolFactory();
0:         }
0:         return poolFactory;
0:     }
0: 
0:     /**
0:      * Sets the object pool factory used to create individual session pools for
0:      * each connection
0:      */
0:     public void setPoolFactory(ObjectPoolFactory poolFactory) {
0:         this.poolFactory = poolFactory;
0:     }
0: 
0:     public int getMaximumActive() {
0:         return maximumActive;
0:     }
0: 
0:     /**
0:      * Sets the maximum number of active sessions per connection
0:      */
0:     public void setMaximumActive(int maximumActive) {
0:         this.maximumActive = maximumActive;
0:     }
0: 
0:     protected ObjectPoolFactory createPoolFactory() {
0:         return new GenericObjectPoolFactory(null, maximumActive);
0:     }
commit:35f915f
/////////////////////////////////////////////////////////////////////////
0:  * It does not deal with pooling of consumers; for that look at a library like 
0:  * <a href="http://jencks.org/">Jencks</a> such as in
0:  * <a href="http://jencks.org/Message+Driven+POJOs">this example</a>
============================================================================