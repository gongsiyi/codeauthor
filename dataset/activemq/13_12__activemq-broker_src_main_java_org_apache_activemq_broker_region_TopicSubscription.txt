1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:fc00993:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:eb983f7: 
1:d29ca2a: import java.io.IOException;
1:2b7bb6f: import java.util.ArrayList;
1:d29ca2a: import java.util.LinkedList;
1:2b7bb6f: import java.util.List;
1:86cbdfd: import java.util.concurrent.atomic.AtomicLong;
1:156a609: 
1:d29ca2a: import javax.jms.JMSException;
1:156a609: 
1:eb983f7: import org.apache.activemq.ActiveMQMessageAudit;
1:4098942: import org.apache.activemq.broker.Broker;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:9359e9f: import org.apache.activemq.broker.region.cursors.FilePendingMessageCursor;
1:0c0be94: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1:222daf2: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
1:062dc56: import org.apache.activemq.broker.region.policy.MessageEvictionStrategy;
1:062dc56: import org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy;
1:6eaea6f: import org.apache.activemq.command.ConsumerControl;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageDispatch;
1:4098942: import org.apache.activemq.command.MessageDispatchNotification;
1:4605503: import org.apache.activemq.command.MessageId;
1:9d671b7: import org.apache.activemq.command.MessagePull;
1:9d671b7: import org.apache.activemq.command.Response;
1:afe73c1: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:ae61847: import org.apache.activemq.transport.TransmitCallback;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:ae5bd2e: 
1:230a86c: public class TopicSubscription extends AbstractSubscription {
1:ae5bd2e: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TopicSubscription.class);
1:fc00993:     private static final AtomicLong CURSOR_NAME_COUNTER = new AtomicLong(0);
1:ae5bd2e: 
1:0c0be94:     protected PendingMessageCursor matched;
1:6d8e2c5:     protected final SystemUsage usageManager;
1:fc00993:     boolean singleDestination = true;
1:fc00993:     Destination destination;
1:afe73c1:     private final Scheduler scheduler;
1:ae5bd2e: 
1:230a86c:     private int maximumPendingMessages = -1;
1:230a86c:     private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();
1:230a86c:     private int discarded;
1:230a86c:     private final Object matchedListMutex = new Object();
1:230a86c:     private int memoryUsageHighWaterMark = 95;
1:eb983f7:     // allow duplicate suppression in a ring network of brokers
1:eb983f7:     protected int maxProducersToAudit = 1024;
1:eb983f7:     protected int maxAuditDepth = 1000;
1:eb983f7:     protected boolean enableAudit = false;
1:eb983f7:     protected ActiveMQMessageAudit audit;
1:f42c91f:     protected boolean active = false;
1:2562cf2:     protected boolean discarding = false;
1:65b0f2a:     private boolean useTopicSubscriptionInflightStats = true;
1:4605503: 
1:2b7bb6f:     //Used for inflight message size calculations
1:2b7bb6f:     protected final Object dispatchLock = new Object();
1:f69fd6f:     protected final List<DispatchedNode> dispatched = new ArrayList<>();
1:4605503: 
1:16f2d75:     public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {
1:230a86c:         super(broker, context, info);
1:230a86c:         this.usageManager = usageManager;
1:fc00993:         String matchedName = "TopicSubscription:" + CURSOR_NAME_COUNTER.getAndIncrement() + "[" + info.getConsumerId().toString() + "]";
1:c7d8715:         if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {
1:00879cf:             this.matched = new VMPendingMessageCursor(false);
1:8dbb48a:         } else {
1:00879cf:             this.matched = new FilePendingMessageCursor(broker,matchedName,false);
1:222daf2:         }
1:f69fd6f: 
1:afe73c1:         this.scheduler = broker.getScheduler();
1:e050519:     }
1:4605503: 
1:0c0be94:     public void init() throws Exception {
1:6d8e2c5:         this.matched.setSystemUsage(usageManager);
1:785454a:         this.matched.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:b036d4d:         this.matched.start();
1:eb983f7:         if (enableAudit) {
1:eb983f7:             audit= new ActiveMQMessageAudit(maxAuditDepth, maxProducersToAudit);
1:eb983f7:         }
1:f42c91f:         this.active=true;
1:d29ca2a:     }
1:ffee8b4: 
1:4605503:     @Override
1:230a86c:     public void add(MessageReference node) throws Exception {
1:eb983f7:         if (isDuplicate(node)) {
1:687badb:             return;
1:4605503:         }
1:32e63dc:         // Lets use an indirect reference so that we can associate a unique
1:32e63dc:         // locator /w the message.
1:32e63dc:         node = new IndirectMessageReference(node.getMessage());
1:eece576:         getSubscriptionStatistics().getEnqueues().increment();
1:8dbb48a:         synchronized (matchedListMutex) {
1:2562cf2:             // if this subscriber is already discarding a message, we don't want to add
1:2562cf2:             // any more messages to it as those messages can only be advisories generated in the process,
1:2562cf2:             // which can trigger the recursive call loop
1:2562cf2:             if (discarding) return;
1:2562cf2: 
1:8dbb48a:             if (!isFull() && matched.isEmpty()) {
1:8dbb48a:                 // if maximumPendingMessages is set we will only discard messages which
1:8dbb48a:                 // have not been dispatched (i.e. we allow the prefetch buffer to be filled)
1:8dbb48a:                 dispatch(node);
1:8dbb48a:                 setSlowConsumer(false);
1:4605503:             } else {
1:8dbb48a:                 if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {
1:8dbb48a:                     // Slow consumers should log and set their state as such.
1:8dbb48a:                     if (!isSlowConsumer()) {
1:8dbb48a:                         LOG.warn("{}: has twice its prefetch limit pending, without an ack; it appears to be slow", toString());
1:8dbb48a:                         setSlowConsumer(true);
1:8dbb48a:                         for (Destination dest: destinations) {
1:8dbb48a:                             dest.slowConsumer(getContext(), this);
1:8dbb48a:                         }
1:687badb:                     }
1:1be9398:                 }
1:8dbb48a:                 if (maximumPendingMessages != 0) {
1:8dbb48a:                     boolean warnedAboutWait = false;
1:8dbb48a:                     while (active) {
1:f42c91f:                         while (matched.isFull()) {
1:156a609:                             if (getContext().getStopping().get()) {
1:e1bbde7:                                 LOG.warn("{}: stopped waiting for space in pendingMessage cursor for: {}", toString(), node.getMessageId());
1:eece576:                                 getSubscriptionStatistics().getEnqueues().decrement();
1:81f3935:                                 return;
1:eb983f7:                             }
1:ae7df9f:                             if (!warnedAboutWait) {
1:e1bbde7:                                 LOG.info("{}: Pending message cursor [{}] is full, temp usag ({}%) or memory usage ({}%) limit reached, blocking message add() pending the release of resources.",
1:e1bbde7:                                         new Object[]{
1:e1bbde7:                                                 toString(),
1:e1bbde7:                                                 matched,
1:e1bbde7:                                                 matched.getSystemUsage().getTempUsage().getPercentUsage(),
1:e1bbde7:                                                 matched.getSystemUsage().getMemoryUsage().getPercentUsage()
1:4605503:                                         });
1:ae7df9f:                                 warnedAboutWait = true;
1:ae7df9f:                             }
1:f42c91f:                             matchedListMutex.wait(20);
1:156a609:                         }
1:ae5bd2e:                         // Temporary storage could be full - so just try to add the message
1:ae5bd2e:                         // see https://issues.apache.org/activemq/browse/AMQ-2475
1:f42c91f:                         if (matched.tryAddMessageLast(node, 10)) {
1:ffee8b4:                             break;
1:ffee8b4:                         }
1:ffee8b4:                     }
1:230a86c:                     if (maximumPendingMessages > 0) {
1:230a86c:                         // calculate the high water mark from which point we
1:230a86c:                         // will eagerly evict expired messages
1:230a86c:                         int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();
1:230a86c:                         if (maximumPendingMessages > 0 && maximumPendingMessages < max) {
1:230a86c:                             max = maximumPendingMessages;
1:ffee8b4:                         }
1:230a86c:                         if (!matched.isEmpty() && matched.size() > max) {
1:9359e9f:                             removeExpiredMessages();
1:b136df1:                         }
1:95d0dec:                         // lets discard old messages as we are a slow consumer
1:230a86c:                         while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {
1:230a86c:                             int pageInSize = matched.size() - maximumPendingMessages;
1:ae5bd2e:                             // only page in a 1000 at a time - else we could blow the memory
1:230a86c:                             pageInSize = Math.max(1000, pageInSize);
1:07cb724:                             LinkedList<MessageReference> list = null;
1:cf55702:                             MessageReference[] oldMessages=null;
1:cf55702:                             synchronized(matched){
1:a2af47b:                                 list = matched.pageInList(pageInSize);
1:ae5bd2e:                                 oldMessages = messageEvictionStrategy.evictMessages(list);
1:a2af47b:                                 for (MessageReference ref : list) {
1:a2af47b:                                     ref.decrementReferenceCount();
1:b136df1:                                 }
1:a2af47b:                             }
1:cf55702:                             int messagesToEvict = 0;
1:cf55702:                             if (oldMessages != null){
1:ae5bd2e:                                 messagesToEvict = oldMessages.length;
1:ae5bd2e:                                 for (int i = 0; i < messagesToEvict; i++) {
1:ae5bd2e:                                     MessageReference oldMessage = oldMessages[i];
1:ae5bd2e:                                     discard(oldMessage);
1:ae5bd2e:                                 }
1:ae5bd2e:                             }
1:ae5bd2e:                             // lets avoid an infinite loop if we are given a bad eviction strategy
1:171e322:                             // for a bad strategy lets just not evict
1:230a86c:                             if (messagesToEvict == 0) {
1:e1bbde7:                                 LOG.warn("No messages to evict returned for {} from eviction strategy: {} out of {} candidates", new Object[]{
1:e1bbde7:                                         destination, messageEvictionStrategy, list.size()
1:e1bbde7:                                 });
1:b136df1:                                 break;
1:d29ca2a:                             }
1:d29ca2a:                         }
1:d29ca2a:                     }
1:8dbb48a:                     dispatchMatched();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:ffee8b4: 
1:eb983f7:     private boolean isDuplicate(MessageReference node) {
1:eb983f7:         boolean duplicate = false;
1:eb983f7:         if (enableAudit && audit != null) {
1:eb983f7:             duplicate = audit.isDuplicate(node);
1:eb983f7:             if (LOG.isDebugEnabled()) {
1:eb983f7:                 if (duplicate) {
1:e1bbde7:                     LOG.debug("{}, ignoring duplicate add: {}", this, node.getMessageId());
1:eb983f7:                 }
1:eb983f7:             }
1:eb983f7:         }
1:eb983f7:         return duplicate;
1:eb983f7:     }
1:eb983f7: 
1:4605503:     /**
1:230a86c:      * Discard any expired messages from the matched list. Called from a
1:230a86c:      * synchronized block.
1:ae5bd2e:      *
1:b036d4d:      * @throws IOException
1:4605503:      */
1:230a86c:     protected void removeExpiredMessages() throws IOException {
1:230a86c:         try {
1:ec63977:             matched.reset();
1:230a86c:             while (matched.hasNext()) {
1:230a86c:                 MessageReference node = matched.next();
1:5619cd0:                 node.decrementReferenceCount();
1:01cfa77:                 if (node.isExpired()) {
1:ec63977:                     matched.remove();
1:5619cd0:                     node.decrementReferenceCount();
1:01cfa77:                     if (broker.isExpired(node)) {
1:01cfa77:                         ((Destination) node.getRegionDestination()).getDestinationStatistics().getExpired().increment();
1:01cfa77:                         broker.messageExpired(getContext(), node, this);
1:d29ca2a:                     }
1:b136df1:                     break;
1:d29ca2a:                 }
1:d29ca2a:             }
1:230a86c:         } finally {
1:ec63977:             matched.release();
1:f42c91f:         }
1:f42c91f:     }
1:afe73c1: 
1:ae61847:     @Override
1:230a86c:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) {
1:230a86c:         synchronized (matchedListMutex) {
1:230a86c:             try {
1:ec63977:                 matched.reset();
1:230a86c:                 while (matched.hasNext()) {
1:230a86c:                     MessageReference node = matched.next();
1:c46562b:                     node.decrementReferenceCount();
1:230a86c:                     if (node.getMessageId().equals(mdn.getMessageId())) {
1:2b7bb6f:                         synchronized(dispatchLock) {
1:2b7bb6f:                             matched.remove();
1:2b7bb6f:                             getSubscriptionStatistics().getDispatched().increment();
1:65b0f2a:                             if (isUseTopicSubscriptionInflightStats()) {
1:65b0f2a:                                 dispatched.add(new DispatchedNode(node));
1:65b0f2a:                                 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:65b0f2a:                             }
1:2b7bb6f:                             node.decrementReferenceCount();
1:2b7bb6f:                         }
1:2b7bb6f:                         break;
1:2b7bb6f:                     }
1:01cfa77:                 }
1:230a86c:             } finally {
1:ec63977:                 matched.release();
1:f42c91f:             }
1:f42c91f:         }
1:f42c91f:     }
1:afe73c1: 
1:ae61847:     @Override
1:fc00993:     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
1:2b99f39:         super.acknowledge(context, ack);
1:2b99f39: 
1:e050519:         if (ack.isStandardAck()) {
1:e050519:             updateStatsOnAck(context, ack);
1:e050519:         } else if (ack.isPoisonAck()) {
1:e050519:             if (ack.isInTransaction()) {
1:e050519:                 throw new JMSException("Poison ack cannot be transacted: " + ack);
1:e050519:             }
1:e050519:             updateStatsOnAck(context, ack);
1:41a1007:             contractPrefetchExtension(ack.getMessageCount());
1:e050519:         } else if (ack.isIndividualAck()) {
1:e050519:             updateStatsOnAck(context, ack);
1:41a1007:             if (ack.isInTransaction()) {
1:41a1007:                 expandPrefetchExtension(1);
1:e050519:             }
1:b136df1:         } else if (ack.isExpiredAck()) {
2:ee54f09:             updateStatsOnAck(ack);
1:41a1007:             contractPrefetchExtension(ack.getMessageCount());
1:e050519:         } else if (ack.isDeliveredAck()) {
1:e050519:             // Message was delivered but not acknowledged: update pre-fetch counters.
1:41a1007:            expandPrefetchExtension(ack.getMessageCount());
1:81f3935:         } else if (ack.isRedeliveredAck()) {
1:e050519:             // No processing for redelivered needed
1:b136df1:             return;
1:e050519:         } else {
1:e050519:             throw new JMSException("Invalid acknowledgment: " + ack);
1:e050519:         }
1:e050519: 
1:b136df1:         dispatchMatched();
1:e050519:     }
1:e050519: 
1:e050519:     private void updateStatsOnAck(final ConnectionContext context, final MessageAck ack) {
1:e050519:         if (context.isInTransaction()) {
1:e050519:             context.getTransaction().addSynchronization(new Synchronization() {
1:e050519: 
1:e050519:                 @Override
1:41a1007:                 public void afterRollback() {
1:41a1007:                     contractPrefetchExtension(ack.getMessageCount());
1:e050519:                 }
1:e050519: 
1:e050519:                 @Override
1:e050519:                 public void afterCommit() throws Exception {
1:41a1007:                     contractPrefetchExtension(ack.getMessageCount());
1:e050519:                     updateStatsOnAck(ack);
1:e050519:                     dispatchMatched();
1:e050519:                 }
1:e050519:             });
1:e050519:         } else {
1:e050519:             updateStatsOnAck(ack);
1:e050519:         }
1:e050519:     }
1:afe73c1: 
1:ae61847:     @Override
1:05ff52d:     public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {
1:ae5bd2e: 
1:afe73c1:         // The slave should not deliver pull messages.
1:ffee8b4:         if (getPrefetchSize() == 0) {
1:ffee8b4: 
1:eece576:             final long currentDispatchedCount = getSubscriptionStatistics().getDispatched().getCount();
1:05ff52d:             prefetchExtension.set(pull.getQuantity());
1:e050519:             dispatchMatched();
1:afe73c1: 
1:afe73c1:             // If there was nothing dispatched.. we may need to setup a timeout.
1:eece576:             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {
1:afe73c1: 
1:afe73c1:                 // immediate timeout used by receiveNoWait()
1:afe73c1:                 if (pull.getTimeout() == -1) {
1:afe73c1:                     // Send a NULL message to signal nothing pending.
1:afe73c1:                     dispatch(null);
1:05ff52d:                     prefetchExtension.set(0);
1:ffee8b4:                 }
1:afe73c1: 
1:afe73c1:                 if (pull.getTimeout() > 0) {
1:afe73c1:                     scheduler.executeAfterDelay(new Runnable() {
1:afe73c1: 
1:ae61847:                         @Override
1:afe73c1:                         public void run() {
1:05ff52d:                             pullTimeout(currentDispatchedCount, pull.isAlwaysSignalDone());
1:b997d25:                         }
1:afe73c1:                     }, pull.getTimeout());
1:afe73c1:                 }
1:afe73c1:             }
1:afe73c1:         }
1:9d671b7:         return null;
1:afe73c1:     }
1:ae5bd2e: 
1:4605503:     /**
1:afe73c1:      * Occurs when a pull times out. If nothing has been dispatched since the
1:afe73c1:      * timeout was setup, then send the NULL message.
1:afe73c1:      */
1:05ff52d:     private final void pullTimeout(long currentDispatchedCount, boolean alwaysSendDone) {
1:afe73c1:         synchronized (matchedListMutex) {
1:eece576:             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || alwaysSendDone) {
1:afe73c1:                 try {
1:afe73c1:                     dispatch(null);
1:afe73c1:                 } catch (Exception e) {
1:afe73c1:                     context.getConnection().serviceException(e);
1:b136df1:                 } finally {
1:05ff52d:                     prefetchExtension.set(0);
1:afe73c1:                 }
1:afe73c1:             }
1:afe73c1:         }
1:afe73c1:     }
1:afe73c1: 
1:afe73c1:     /**
1:ee54f09:      * Update the statistics on message ack.
1:4605503:      * @param ack
1:4605503:      */
1:ee54f09:     private void updateStatsOnAck(final MessageAck ack) {
1:65b0f2a:         //Allow disabling inflight stats to save memory usage
1:65b0f2a:         if (isUseTopicSubscriptionInflightStats()) {
1:65b0f2a:             synchronized(dispatchLock) {
1:65b0f2a:                 boolean inAckRange = false;
1:65b0f2a:                 List<DispatchedNode> removeList = new ArrayList<>();
1:65b0f2a:                 for (final DispatchedNode node : dispatched) {
1:65b0f2a:                     MessageId messageId = node.getMessageId();
1:65b0f2a:                     if (ack.getFirstMessageId() == null
1:65b0f2a:                             || ack.getFirstMessageId().equals(messageId)) {
1:65b0f2a:                         inAckRange = true;
1:65b0f2a:                     }
1:65b0f2a:                     if (inAckRange) {
1:65b0f2a:                         removeList.add(node);
1:65b0f2a:                         if (ack.getLastMessageId().equals(messageId)) {
1:65b0f2a:                             break;
1:65b0f2a:                         }
1:65b0f2a:                     }
1:2b7bb6f:                 }
1:65b0f2a: 
1:65b0f2a:                 for (final DispatchedNode node : removeList) {
1:65b0f2a:                     dispatched.remove(node);
1:65b0f2a:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:65b0f2a: 
1:65b0f2a:                     final Destination destination = node.getDestination();
1:65b0f2a:                     incrementStatsOnAck(destination, ack, 1);
1:65b0f2a:                     if (!ack.isInTransaction()) {
1:65b0f2a:                         contractPrefetchExtension(1);
1:2b7bb6f:                     }
1:2b7bb6f:                 }
1:4605503:             }
1:65b0f2a:         } else {
1:65b0f2a:             if (singleDestination && destination != null) {
1:65b0f2a:                 incrementStatsOnAck(destination, ack, ack.getMessageCount());
1:65b0f2a:             }
1:65b0f2a:             if (!ack.isInTransaction()) {
1:65b0f2a:                 contractPrefetchExtension(ack.getMessageCount());
1:65b0f2a:             }
1:65b0f2a:         }
1:4605503:     }
1:65b0f2a: 
1:65b0f2a:     private void incrementStatsOnAck(final Destination destination, final MessageAck ack, final int count) {
1:65b0f2a:         getSubscriptionStatistics().getDequeues().add(count);
1:65b0f2a:         destination.getDestinationStatistics().getDequeues().add(count);
1:65b0f2a:         destination.getDestinationStatistics().getInflight().subtract(count);
1:65b0f2a:         if (info.isNetworkSubscription()) {
1:65b0f2a:             destination.getDestinationStatistics().getForwards().add(count);
1:65b0f2a:         }
1:65b0f2a:         if (ack.isExpiredAck()) {
1:65b0f2a:             destination.getDestinationStatistics().getExpired().add(count);
1:4605503:         }
1:41a1007:     }
1:2b7bb6f: 
1:ae61847:     @Override
1:ea03bb1:     public int countBeforeFull() {
1:ea03bb1:         return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - getDispatchedQueueSize();
1:ea03bb1:     }
1:ea03bb1: 
1:ea03bb1:     @Override
1:230a86c:     public int getPendingQueueSize() {
1:07d4e8c:         return matched();
1:25e3c1b:     }
1:ee54f09: 
1:ae61847:     @Override
1:734fb7d:     public long getPendingMessageSize() {
1:734fb7d:         synchronized (matchedListMutex) {
1:734fb7d:             return matched.messageSize();
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:230a86c:     public int getDispatchedQueueSize() {
1:eece576:         return (int)(getSubscriptionStatistics().getDispatched().getCount() -
1:e050519:                      getSubscriptionStatistics().getDequeues().getCount());
1:b136df1:     }
1:fc00993: 
1:230a86c:     public int getMaximumPendingMessages() {
1:0d5de13:         return maximumPendingMessages;
1:b136df1:     }
1:fc00993: 
1:ae61847:     @Override
1:230a86c:     public long getDispatchedCounter() {
1:eece576:         return getSubscriptionStatistics().getDispatched().getCount();
1:ee54f09:     }
1:fc00993: 
1:ae61847:     @Override
1:230a86c:     public long getEnqueueCounter() {
1:eece576:         return getSubscriptionStatistics().getEnqueues().getCount();
1:ee54f09:     }
1:74a7a8b: 
1:ae61847:     @Override
1:230a86c:     public long getDequeueCounter() {
1:eece576:         return getSubscriptionStatistics().getDequeues().getCount();
1:ee54f09:     }
1:74a7a8b: 
1:d4382e4:     /**
1:062dc56:      * @return the number of messages discarded due to being a slow consumer
1:c6e0984:      */
1:230a86c:     public int discarded() {
1:230a86c:         synchronized (matchedListMutex) {
1:062dc56:             return discarded;
1:ee54f09:         }
1:ee54f09:     }
1:230a86c: 
1:6eaea6f:     /**
1:230a86c:      * @return the number of matched messages (messages targeted for the
1:230a86c:      *         subscription but not yet able to be dispatched due to the
1:230a86c:      *         prefetch buffer being full).
1:d4382e4:      */
1:230a86c:     public int matched() {
1:230a86c:         synchronized (matchedListMutex) {
1:062dc56:             return matched.size();
1:afe73c1:         }
1:07d4e8c:     }
1:230a86c: 
1:6eaea6f:     /**
1:230a86c:      * Sets the maximum number of pending messages that can be matched against
1:230a86c:      * this consumer before old messages are discarded.
1:6eaea6f:      */
1:230a86c:     public void setMaximumPendingMessages(int maximumPendingMessages) {
1:230a86c:         this.maximumPendingMessages = maximumPendingMessages;
1:07d4e8c:     }
1:230a86c: 
1:230a86c:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:062dc56:         return messageEvictionStrategy;
1:07d4e8c:     }
1:a58d36b: 
1:cc6fec6:     /**
1:230a86c:      * Sets the eviction strategy used to decide which message to evict when the
1:230a86c:      * slow consumer needs to discard messages
1:6eaea6f:      */
1:230a86c:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
1:230a86c:         this.messageEvictionStrategy = messageEvictionStrategy;
1:f42c91f:     }
1:c46562b: 
1:eb983f7:     public int getMaxProducersToAudit() {
1:eb983f7:         return maxProducersToAudit;
1:eb983f7:     }
1:eb983f7: 
1:eb983f7:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
1:eb983f7:         this.maxProducersToAudit = maxProducersToAudit;
1:eb983f7:         if (audit != null) {
1:eb983f7:             audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
1:eb983f7:         }
1:eb983f7:     }
1:eb983f7: 
1:eb983f7:     public int getMaxAuditDepth() {
1:eb983f7:         return maxAuditDepth;
1:eb983f7:     }
1:eb983f7: 
1:eb983f7:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
1:eb983f7:         this.maxAuditDepth = maxAuditDepth;
1:eb983f7:         if (audit != null) {
1:eb983f7:             audit.setAuditDepth(maxAuditDepth);
1:eb983f7:         }
1:eb983f7:     }
1:eb983f7: 
1:eb983f7:     public boolean isEnableAudit() {
1:eb983f7:         return enableAudit;
1:eb983f7:     }
1:eb983f7: 
1:eb983f7:     public synchronized void setEnableAudit(boolean enableAudit) {
1:eb983f7:         this.enableAudit = enableAudit;
1:ae5bd2e:         if (enableAudit && audit == null) {
1:eb983f7:             audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:eb983f7:         }
1:eb983f7:     }
1:eb983f7: 
1:062dc56:     // Implementation methods
1:062dc56:     // -------------------------------------------------------------------------
1:ae61847:     @Override
1:d4382e4:     public boolean isFull() {
1:e050519:         return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : getDispatchedQueueSize() - prefetchExtension.get() >= info.getPrefetchSize();
1:ffee8b4:     }
1:ae5bd2e: 
1:ae61847:     @Override
1:d4382e4:     public int getInFlightSize() {
1:d4382e4:         return getDispatchedQueueSize();
1:07cb724:     }
1:ae5bd2e: 
2:062dc56:     /**
1:6eaea6f:      * @return true when 60% or more room is left for dispatching messages
1:6eaea6f:      */
1:ae61847:     @Override
1:230a86c:     public boolean isLowWaterMark() {
1:e050519:         return (getDispatchedQueueSize() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
1:07cb724:     }
1:ae5bd2e: 
1:6eaea6f:     /**
1:6eaea6f:      * @return true when 10% or less room is left for dispatching messages
1:6eaea6f:      */
1:ae61847:     @Override
1:230a86c:     public boolean isHighWaterMark() {
1:e050519:         return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
1:dfdd896:     }
1:c46562b: 
1:b036d4d:     /**
1:b036d4d:      * @param memoryUsageHighWaterMark the memoryUsageHighWaterMark to set
1:b036d4d:      */
1:230a86c:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:230a86c:         this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;
1:cdc2fd3:     }
1:c46562b: 
1:b036d4d:     /**
1:b036d4d:      * @return the memoryUsageHighWaterMark
1:b036d4d:      */
1:230a86c:     public int getMemoryUsageHighWaterMark() {
1:b036d4d:         return this.memoryUsageHighWaterMark;
1:cdc2fd3:     }
1:07d4e8c: 
1:b036d4d:     /**
1:b036d4d:      * @return the usageManager
1:b036d4d:      */
1:6d8e2c5:     public SystemUsage getUsageManager() {
1:b036d4d:         return this.usageManager;
1:cdc2fd3:     }
1:230a86c: 
1:0c0be94:     /**
1:0c0be94:      * @return the matched
1:0c0be94:      */
1:230a86c:     public PendingMessageCursor getMatched() {
1:0c0be94:         return this.matched;
1:cf55702:     }
1:07d4e8c: 
1:0c0be94:     /**
1:0c0be94:      * @param matched the matched to set
1:0c0be94:      */
1:230a86c:     public void setMatched(PendingMessageCursor matched) {
1:230a86c:         this.matched = matched;
1:cf55702:     }
1:07d4e8c: 
1:6eaea6f:     /**
1:6eaea6f:      * inform the MessageConsumer on the client to change it's prefetch
1:ae5bd2e:      *
1:6eaea6f:      * @param newPrefetch
1:b036d4d:      */
1:ae61847:     @Override
1:230a86c:     public void updateConsumerPrefetch(int newPrefetch) {
1:230a86c:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()) {
1:230a86c:             ConsumerControl cc = new ConsumerControl();
1:6eaea6f:             cc.setConsumerId(info.getConsumerId());
1:6eaea6f:             cc.setPrefetch(newPrefetch);
1:6eaea6f:             context.getConnection().dispatchAsync(cc);
1:cf55702:         }
1:d4382e4:     }
1:07d4e8c: 
1:ae5bd2e:     private void dispatchMatched() throws IOException {
1:230a86c:         synchronized (matchedListMutex) {
1:d4382e4:             if (!matched.isEmpty() && !isFull()) {
1:230a86c:                 try {
1:d4382e4:                     matched.reset();
1:ae5bd2e: 
1:230a86c:                     while (matched.hasNext() && !isFull()) {
1:f42c91f:                         MessageReference message = matched.next();
1:5619cd0:                         message.decrementReferenceCount();
1:d4382e4:                         matched.remove();
1:ae5bd2e:                         // Message may have been sitting in the matched list a while
1:a58d36b:                         // waiting for the consumer to ak the message.
1:2a153b0:                         if (message.isExpired()) {
1:2a153b0:                             discard(message);
1:a58d36b:                             continue; // just drop it.
1:2562cf2:                         }
1:d29ca2a:                         dispatch(message);
1:a58d36b:                     }
1:230a86c:                 } finally {
1:d4382e4:                     matched.release();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d4382e4:         }
1:d4382e4:     }
1:a58d36b: 
1:230a86c:     private void dispatch(final MessageReference node) throws IOException {
1:05ff52d:         Message message = node != null ? node.getMessage() : null;
1:afe73c1:         if (node != null) {
1:5eb274d:             node.incrementReferenceCount();
1:afe73c1:         }
1:d29ca2a:         // Make sure we can dispatch a message.
1:230a86c:         MessageDispatch md = new MessageDispatch();
1:d29ca2a:         md.setMessage(message);
1:6d003a8:         md.setConsumerId(info.getConsumerId());
1:afe73c1:         if (node != null) {
1:9a8f6e4:             md.setDestination(((Destination)node.getRegionDestination()).getActiveMQDestination());
1:2b7bb6f:             synchronized(dispatchLock) {
1:2b7bb6f:                 getSubscriptionStatistics().getDispatched().increment();
1:65b0f2a:                 if (isUseTopicSubscriptionInflightStats()) {
1:65b0f2a:                     dispatched.add(new DispatchedNode(node));
1:65b0f2a:                     getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:65b0f2a:                 }
1:2b7bb6f:             }
1:2b7bb6f: 
1:afe73c1:             // Keep track if this subscription is receiving messages from a single destination.
1:afe73c1:             if (singleDestination) {
1:afe73c1:                 if (destination == null) {
1:9a8f6e4:                     destination = (Destination)node.getRegionDestination();
1:b997d25:                 } else {
1:afe73c1:                     if (destination != node.getRegionDestination()) {
1:afe73c1:                         singleDestination = false;
1:afe73c1:                     }
1:afe73c1:                 }
1:d29ca2a:             }
1:c46562b: 
1:05ff52d:             if (getPrefetchSize() == 0) {
1:e050519:                 decrementPrefetchExtension(1);
1:a414c20:             }
1:a414c20:         }
1:e050519: 
1:230a86c:         if (info.isDispatchAsync()) {
1:afe73c1:             if (node != null) {
1:ae61847:                 md.setTransmitCallback(new TransmitCallback() {
1:ae61847: 
1:ae61847:                     @Override
1:ae61847:                     public void onSuccess() {
1:ae61847:                         Destination regionDestination = (Destination) node.getRegionDestination();
1:ae61847:                         regionDestination.getDestinationStatistics().getDispatched().increment();
1:ae61847:                         regionDestination.getDestinationStatistics().getInflight().increment();
1:ae61847:                         node.decrementReferenceCount();
1:ae61847:                     }
1:ae61847: 
1:ae61847:                     @Override
1:ae61847:                     public void onFailure() {
1:9a8f6e4:                         Destination regionDestination = (Destination) node.getRegionDestination();
1:9a8f6e4:                         regionDestination.getDestinationStatistics().getDispatched().increment();
1:9a8f6e4:                         regionDestination.getDestinationStatistics().getInflight().increment();
1:afe73c1:                         node.decrementReferenceCount();
1:afe73c1:                     }
1:e1bbde7:                 });
1:0c0be94:             }
1:d29ca2a:             context.getConnection().dispatchAsync(md);
1:afe73c1:         } else {
1:d29ca2a:             context.getConnection().dispatchSync(md);
1:afe73c1:             if (node != null) {
1:9a8f6e4:                 Destination regionDestination = (Destination) node.getRegionDestination();
1:9a8f6e4:                 regionDestination.getDestinationStatistics().getDispatched().increment();
1:9a8f6e4:                 regionDestination.getDestinationStatistics().getInflight().increment();
1:afe73c1:                 node.decrementReferenceCount();
1:afe73c1:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:a414c20:     private void discard(MessageReference message) {
1:2562cf2:         discarding = true;
1:2562cf2:         try {
1:2562cf2:             message.decrementReferenceCount();
1:2562cf2:             matched.remove(message);
1:2562cf2:             discarded++;
1:f69fd6f:             if (destination != null) {
1:f69fd6f:                 destination.getDestinationStatistics().getDequeues().increment();
1:f69fd6f:             }
1:e1bbde7:             LOG.debug("{}, discarding message {}", this, message);
1:2562cf2:             Destination dest = (Destination) message.getRegionDestination();
1:2562cf2:             if (dest != null) {
1:2562cf2:                 dest.messageDiscarded(getContext(), this, message);
1:f69fd6f:             }
1:2562cf2:             broker.getRoot().sendToDeadLetterQueue(getContext(), message, this, new Throwable("TopicSubDiscard. ID:" + info.getConsumerId()));
1:2562cf2:         } finally {
1:2562cf2:             discarding = false;
1:2562cf2:         }
1:d29ca2a:     }
1:07d4e8c: 
1:ae61847:     @Override
1:230a86c:     public String toString() {
1:230a86c:         return "TopicSubscription:" + " consumer=" + info.getConsumerId() + ", destinations=" + destinations.size() + ", dispatched=" + getDispatchedQueueSize() + ", delivered="
1:687badb:                 + getDequeueCounter() + ", matched=" + matched() + ", discarded=" + discarded() + ", prefetchExtension=" + prefetchExtension.get()
1:687badb:                 + ", usePrefetchExtension=" + isUsePrefetchExtension();
1:d29ca2a:     }
1:07d4e8c: 
1:afe73c1:     @Override
1:230a86c:     public void destroy() {
1:f42c91f:         this.active=false;
2:230a86c:         synchronized (matchedListMutex) {
1:230a86c:             try {
1:0c0be94:                 matched.destroy();
1:230a86c:             } catch (Exception e) {
1:230a86c:                 LOG.warn("Failed to destroy cursor", e);
1:c46562b:             }
1:c46562b:         }
1:1b6d397:         setSlowConsumer(false);
1:2b7bb6f:         synchronized(dispatchLock) {
1:2b7bb6f:             dispatched.clear();
1:2b7bb6f:         }
1:c46562b:     }
1:c46562b: 
1:f42c91f:     @Override
1:015cd8a:     public int getPrefetchSize() {
1:f42c91f:         return info.getPrefetchSize();
1:230a86c:     }
1:230a86c: 
1:ae5bd2e:     @Override
1:ae5bd2e:     public void setPrefetchSize(int newSize) {
1:ae5bd2e:         info.setPrefetchSize(newSize);
1:ae5bd2e:         try {
1:afe73c1:             dispatchMatched();
1:ae5bd2e:         } catch(Exception e) {
1:ae5bd2e:             LOG.trace("Caught exception on dispatch after prefetch size change.");
1:ae5bd2e:         }
1:ae5bd2e:     }
1:687badb: 
1:65b0f2a:     public boolean isUseTopicSubscriptionInflightStats() {
1:65b0f2a:         return useTopicSubscriptionInflightStats;
1:65b0f2a:     }
1:65b0f2a: 
1:65b0f2a:     public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {
1:65b0f2a:         this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;
1:65b0f2a:     }
1:65b0f2a: 
1:f69fd6f:     private static class DispatchedNode {
1:f69fd6f:         private final int size;
1:f69fd6f:         private final MessageId messageId;
1:f69fd6f:         private final Destination destination;
1:f69fd6f: 
1:f69fd6f:         public DispatchedNode(final MessageReference node) {
1:f69fd6f:             super();
1:f69fd6f:             this.size = node.getSize();
1:f69fd6f:             this.messageId = node.getMessageId();
1:f69fd6f:             this.destination = node.getRegionDestination() instanceof Destination ?
1:f69fd6f:                     ((Destination)node.getRegionDestination()) : null;
1:f69fd6f:         }
1:f69fd6f: 
1:f69fd6f:         public long getSize() {
1:f69fd6f:             return size;
1:f69fd6f:         }
1:f69fd6f: 
1:f69fd6f:         public MessageId getMessageId() {
1:f69fd6f:             return messageId;
1:f69fd6f:         }
1:f69fd6f: 
1:f69fd6f:         public Destination getDestination() {
1:f69fd6f:             return destination;
1:f69fd6f:         }
1:f69fd6f:     }
1:f69fd6f: 
1:dfdd896: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:65b0f2a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean useTopicSubscriptionInflightStats = true;
/////////////////////////////////////////////////////////////////////////
1:                             if (isUseTopicSubscriptionInflightStats()) {
1:                                 dispatched.add(new DispatchedNode(node));
1:                                 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:                             }
/////////////////////////////////////////////////////////////////////////
1:         //Allow disabling inflight stats to save memory usage
1:         if (isUseTopicSubscriptionInflightStats()) {
1:             synchronized(dispatchLock) {
1:                 boolean inAckRange = false;
1:                 List<DispatchedNode> removeList = new ArrayList<>();
1:                 for (final DispatchedNode node : dispatched) {
1:                     MessageId messageId = node.getMessageId();
1:                     if (ack.getFirstMessageId() == null
1:                             || ack.getFirstMessageId().equals(messageId)) {
1:                         inAckRange = true;
1:                     }
1:                     if (inAckRange) {
1:                         removeList.add(node);
1:                         if (ack.getLastMessageId().equals(messageId)) {
1:                             break;
1:                         }
1:                     }
1: 
1:                 for (final DispatchedNode node : removeList) {
1:                     dispatched.remove(node);
1:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1: 
1:                     final Destination destination = node.getDestination();
1:                     incrementStatsOnAck(destination, ack, 1);
1:                     if (!ack.isInTransaction()) {
1:                         contractPrefetchExtension(1);
1:         } else {
1:             if (singleDestination && destination != null) {
1:                 incrementStatsOnAck(destination, ack, ack.getMessageCount());
1:             if (!ack.isInTransaction()) {
1:                 contractPrefetchExtension(ack.getMessageCount());
1:             }
1:         }
1:     }
1: 
1:     private void incrementStatsOnAck(final Destination destination, final MessageAck ack, final int count) {
1:         getSubscriptionStatistics().getDequeues().add(count);
1:         destination.getDestinationStatistics().getDequeues().add(count);
1:         destination.getDestinationStatistics().getInflight().subtract(count);
1:         if (info.isNetworkSubscription()) {
1:             destination.getDestinationStatistics().getForwards().add(count);
1:         }
1:         if (ack.isExpiredAck()) {
1:             destination.getDestinationStatistics().getExpired().add(count);
/////////////////////////////////////////////////////////////////////////
1:                 if (isUseTopicSubscriptionInflightStats()) {
1:                     dispatched.add(new DispatchedNode(node));
1:                     getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUseTopicSubscriptionInflightStats() {
1:         return useTopicSubscriptionInflightStats;
1:     }
1: 
1:     public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {
1:         this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;
1:     }
1: 
commit:f69fd6f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     protected final List<DispatchedNode> dispatched = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:                             dispatched.add(new DispatchedNode(node));
/////////////////////////////////////////////////////////////////////////
0:             List<DispatchedNode> removeList = new ArrayList<>();
0:             for (final DispatchedNode node : dispatched) {
/////////////////////////////////////////////////////////////////////////
0:             for (final DispatchedNode node : removeList) {
1: 
0:                 final Destination destination = node.getDestination();
1:                 if (destination != null) {
1:                     destination.getDestinationStatistics().getDequeues().increment();
0:                     destination.getDestinationStatistics().getInflight().decrement();
0:                     if (info.isNetworkSubscription()) {
0:                         destination.getDestinationStatistics().getForwards().increment();
1:                     }
0:                     if (ack.isExpiredAck()) {
0:                         destination.getDestinationStatistics().getExpired().increment();
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                 dispatched.add(new DispatchedNode(node));
/////////////////////////////////////////////////////////////////////////
1:     private static class DispatchedNode {
1:         private final int size;
1:         private final MessageId messageId;
1:         private final Destination destination;
1: 
1:         public DispatchedNode(final MessageReference node) {
1:             super();
1:             this.size = node.getSize();
1:             this.messageId = node.getMessageId();
1:             this.destination = node.getRegionDestination() instanceof Destination ?
1:                     ((Destination)node.getRegionDestination()) : null;
1:         }
1: 
1:         public long getSize() {
1:             return size;
1:         }
1: 
1:         public MessageId getMessageId() {
1:             return messageId;
1:         }
1: 
1:         public Destination getDestination() {
1:             return destination;
1:         }
1:     }
1: 
commit:d0c9514
/////////////////////////////////////////////////////////////////////////
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     public long getPendingMessageSize() {
1:         synchronized (matchedListMutex) {
1:             return matched.messageSize();
1:         }
1:     }
1: 
1:     @Override
commit:2b7bb6f
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     //Used for inflight message size calculations
1:     protected final Object dispatchLock = new Object();
0:     protected final List<MessageReference> dispatched = new ArrayList<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:                         synchronized(dispatchLock) {
1:                             matched.remove();
1:                             getSubscriptionStatistics().getDispatched().increment();
0:                             dispatched.add(node);
0:                             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:                             node.decrementReferenceCount();
1:                         }
/////////////////////////////////////////////////////////////////////////
0:      * Update the inflight statistics on message ack.
1:         synchronized(dispatchLock) {
0:             boolean inAckRange = false;
0:             List<MessageReference> removeList = new ArrayList<MessageReference>();
0:             for (final MessageReference node : dispatched) {
0:                 MessageId messageId = node.getMessageId();
0:                 if (ack.getFirstMessageId() == null
0:                         || ack.getFirstMessageId().equals(messageId)) {
0:                     inAckRange = true;
1:                 }
0:                 if (inAckRange) {
0:                     removeList.add(node);
0:                     if (ack.getLastMessageId().equals(messageId)) {
1:                         break;
1:                     }
1:                 }
1: 
0:             for (final MessageReference node : removeList) {
0:                 dispatched.remove(node);
0:                 getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             synchronized(dispatchLock) {
1:                 getSubscriptionStatistics().getDispatched().increment();
0:                 dispatched.add(node);
0:                 getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchLock) {
1:             dispatched.clear();
1:         }
commit:4605503
/////////////////////////////////////////////////////////////////////////
0: import java.util.Comparator;
0: import java.util.Iterator;
0: import java.util.NavigableMap;
0: import java.util.concurrent.ConcurrentSkipListMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * This Map is used to keep track of messages that have been dispatched in sorted order to
0:      * optimize message acknowledgement
1:      */
0:     private NavigableMap<MessageId, MessageReference> dispatched = new ConcurrentSkipListMap<>(
0:             new Comparator<MessageId>() {
1:                 @Override
0:                 public int compare(MessageId m1, MessageId m2) {
0:                     return m1 == null ? (m2 == null ? 0 : -1) : (m2 == null ? 1
0:                             : Long.compare(m1.getBrokerSequenceId(), m2.getBrokerSequenceId()));
1:                 }
1:             });
1: 
/////////////////////////////////////////////////////////////////////////
0:                         dispatched.put(node.getMessageId(), node);
0:                         getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
/////////////////////////////////////////////////////////////////////////
0:                         updateInflightMessageSizeOnAck(ack);
/////////////////////////////////////////////////////////////////////////
0:                 updateInflightMessageSizeOnAck(ack);
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Update the inflight statistics on message ack.  Since a message ack could be a range,
0:      * we need to grab a subtree of the dispatched map to acknowledge messages.  Finding the
0:      * subMap is an O(log n) operation.
1:      * @param ack
1:      */
0:     private void updateInflightMessageSizeOnAck(final MessageAck ack) {
0:         if (ack.getFirstMessageId() != null) {
0:             NavigableMap<MessageId, MessageReference> acked = dispatched
0:                     .subMap(ack.getFirstMessageId(), true, ack.getLastMessageId(), true);
0:             Iterator<MessageId> i = acked.keySet().iterator();
0:             while (i.hasNext()) {
0:                 getSubscriptionStatistics().getInflightMessageSize().addSize(-acked.get(i.next()).getSize());
0:                 i.remove();
1:             }
1:         } else {
0:             getSubscriptionStatistics().getInflightMessageSize().addSize(-dispatched.get(ack.getLastMessageId()).getSize());
0:             dispatched.remove(ack.getLastMessageId());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             dispatched.put(node.getMessageId(), node);
0:             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
/////////////////////////////////////////////////////////////////////////
0:         dispatched.clear();
commit:ea03bb1
/////////////////////////////////////////////////////////////////////////
1:     public int countBeforeFull() {
1:         return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - getDispatchedQueueSize();
1:     }
1: 
1:     @Override
commit:eece576
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         getSubscriptionStatistics().getEnqueues().increment();
/////////////////////////////////////////////////////////////////////////
1:                                 getSubscriptionStatistics().getEnqueues().decrement();
/////////////////////////////////////////////////////////////////////////
0:                     getSubscriptionStatistics().getDispatched().increment();
/////////////////////////////////////////////////////////////////////////
0:                         getSubscriptionStatistics().getDispatched().increment();
/////////////////////////////////////////////////////////////////////////
0:                         synchronized (TopicSubscription.this) {
0:                         getSubscriptionStatistics().getDequeues().add(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:                 getSubscriptionStatistics().getDequeues().add(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:             getSubscriptionStatistics().getDequeues().add(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
1:             final long currentDispatchedCount = getSubscriptionStatistics().getDispatched().getCount();
1:             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {
/////////////////////////////////////////////////////////////////////////
1:             if (currentDispatchedCount == getSubscriptionStatistics().getDispatched().getCount() || alwaysSendDone) {
/////////////////////////////////////////////////////////////////////////
1:         return (int)(getSubscriptionStatistics().getDispatched().getCount() -
0:                 prefetchExtension.get() - getSubscriptionStatistics().getDequeues().getCount());
/////////////////////////////////////////////////////////////////////////
1:         return getSubscriptionStatistics().getDispatched().getCount();
1:         return getSubscriptionStatistics().getEnqueues().getCount();
1:         return getSubscriptionStatistics().getDequeues().getCount();
/////////////////////////////////////////////////////////////////////////
0:             getSubscriptionStatistics().getDispatched().increment();
/////////////////////////////////////////////////////////////////////////
0:                 + getDequeueCounter() + ", matched=" + matched() + ", discarded=" + discarded();
author:gtully
-------------------------------------------------------------------------------
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1:             contractPrefetchExtension(ack.getMessageCount());
1:             if (ack.isInTransaction()) {
1:                 expandPrefetchExtension(1);
1:             contractPrefetchExtension(ack.getMessageCount());
1:            expandPrefetchExtension(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
1:                 public void afterRollback() {
1:                     contractPrefetchExtension(ack.getMessageCount());
1:                     contractPrefetchExtension(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:                 if (!ack.isInTransaction()) {
0:                     contractPrefetchExtension(1);
1:                 }
commit:ffee8b4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void decrementPrefetchExtension() {
0:         while (true) {
0:             int currentExtension = prefetchExtension.get();
0:             int newExtension = Math.max(0, currentExtension - 1);
0:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                 break;
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (info.getPrefetchSize() == 0) {
0:             return prefetchExtension.get() == 0;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (getPrefetchSize() == 0) {
0:                 decrementPrefetchExtension();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 + getDequeueCounter() + ", matched=" + matched() + ", discarded=" + discarded() + ", prefetchExtension=" + prefetchExtension.get();
commit:01cfa77
/////////////////////////////////////////////////////////////////////////
1:                 if (node.isExpired()) {
1:                     if (broker.isExpired(node)) {
1:                         ((Destination) node.getRegionDestination()).getDestinationStatistics().getExpired().increment();
1:                         broker.messageExpired(getContext(), node, this);
1:                     }
commit:8dbb48a
/////////////////////////////////////////////////////////////////////////
1:         synchronized (matchedListMutex) {
1:             if (!isFull() && matched.isEmpty()) {
1:                 // if maximumPendingMessages is set we will only discard messages which
1:                 // have not been dispatched (i.e. we allow the prefetch buffer to be filled)
1:                 dispatch(node);
1:                 setSlowConsumer(false);
1:             } else {
1:                 if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {
1:                     // Slow consumers should log and set their state as such.
1:                     if (!isSlowConsumer()) {
1:                         LOG.warn("{}: has twice its prefetch limit pending, without an ack; it appears to be slow", toString());
1:                         setSlowConsumer(true);
1:                         for (Destination dest: destinations) {
1:                             dest.slowConsumer(getContext(), this);
1:                         }
1:                 if (maximumPendingMessages != 0) {
1:                     boolean warnedAboutWait = false;
1:                     while (active) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     dispatchMatched();
commit:25e3c1b
/////////////////////////////////////////////////////////////////////////
0:                     if (info.isNetworkSubscription()) {
0:                         destination.getDestinationStatistics().getForwards().add(ack.getMessageCount());
1:                     }
commit:b136df1
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicInteger prefetchExtension = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
0:             while (true) {
0:                 int currentExtension = prefetchExtension.get();
0:                 int newExtension = Math.max(0, currentExtension - ack.getMessageCount());
0:                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                     break;
1:                 }
1:             }
0:             prefetchExtension.addAndGet(ack.getMessageCount());
1:             dispatchMatched();
1:             return;
1:         } else if (ack.isExpiredAck()) {
0:             if (singleDestination && destination != null) {
0:                 destination.getDestinationStatistics().getExpired().add(ack.getMessageCount());
0:                 destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0:             while (true) {
0:                 int currentExtension = prefetchExtension.get();
0:                 int newExtension = Math.max(0, currentExtension - ack.getMessageCount());
0:                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                     break;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:             final long currentDispatchedCount = dispatchedCounter.get();
0:             prefetchExtension.incrementAndGet();
0:             if (currentDispatchedCount == dispatchedCounter.get()) {
0:                     prefetchExtension.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                             pullTimeout(currentDispatchedCount);
/////////////////////////////////////////////////////////////////////////
0:     private final void pullTimeout(long currentDispatchedCount) {
0:             if (currentDispatchedCount == dispatchedCounter.get()) {
1:                 } finally {
0:                     prefetchExtension.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:         return (int)(dispatchedCounter.get() - prefetchExtension.get() - dequeueCounter.get());
/////////////////////////////////////////////////////////////////////////
0:         return getDispatchedQueueSize() >= info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
author:Vasco Veloso
-------------------------------------------------------------------------------
commit:687badb
/////////////////////////////////////////////////////////////////////////
0:         if (!isUsePrefetchExtension()) {
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 + getDequeueCounter() + ", matched=" + matched() + ", discarded=" + discarded() + ", prefetchExtension=" + prefetchExtension.get()
1:                 + ", usePrefetchExtension=" + isUsePrefetchExtension();
/////////////////////////////////////////////////////////////////////////
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e050519
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (ack.isStandardAck()) {
1:             updateStatsOnAck(context, ack);
1:         } else if (ack.isPoisonAck()) {
1:             if (ack.isInTransaction()) {
1:                 throw new JMSException("Poison ack cannot be transacted: " + ack);
1:             updateStatsOnAck(context, ack);
0:             if (getPrefetchSize() != 0) {
0:                 decrementPrefetchExtension(ack.getMessageCount());
1:             }
1:         } else if (ack.isIndividualAck()) {
1:             updateStatsOnAck(context, ack);
0:             if (getPrefetchSize() != 0 && ack.isInTransaction()) {
0:                 incrementPrefetchExtension(ack.getMessageCount());
1:             }
0:             if (getPrefetchSize() != 0) {
0:                 incrementPrefetchExtension(ack.getMessageCount());
1:             }
1:         } else if (ack.isDeliveredAck()) {
1:             // Message was delivered but not acknowledged: update pre-fetch counters.
0:             if (getPrefetchSize() != 0) {
0:                 incrementPrefetchExtension(ack.getMessageCount());
1:             }
1:             // No processing for redelivered needed
1:         } else {
1:             throw new JMSException("Invalid acknowledgment: " + ack);
1: 
1:         dispatchMatched();
1:     }
1: 
1:     private void updateStatsOnAck(final ConnectionContext context, final MessageAck ack) {
1:         if (context.isInTransaction()) {
1:             context.getTransaction().addSynchronization(new Synchronization() {
1: 
1:                 @Override
0:                 public void beforeEnd() {
0:                     if (getPrefetchSize() != 0) {
0:                         decrementPrefetchExtension(ack.getMessageCount());
1:                     }
1:                 }
1: 
1:                 @Override
1:                 public void afterCommit() throws Exception {
1:                     updateStatsOnAck(ack);
1:                     dispatchMatched();
1:                 }
1:             });
1:         } else {
1:             updateStatsOnAck(ack);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     private void incrementPrefetchExtension(int amount) {
0:             int newExtension = Math.max(0, currentExtension + amount);
0:     private void decrementPrefetchExtension(int amount) {
0:             int newExtension = Math.max(0, currentExtension - amount);
/////////////////////////////////////////////////////////////////////////
1:                      getSubscriptionStatistics().getDequeues().getCount());
/////////////////////////////////////////////////////////////////////////
1:         return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : getDispatchedQueueSize() - prefetchExtension.get() >= info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
1:         return (getDispatchedQueueSize() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
/////////////////////////////////////////////////////////////////////////
1:         return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
/////////////////////////////////////////////////////////////////////////
1:                 decrementPrefetchExtension(1);
1: 
commit:05ff52d
/////////////////////////////////////////////////////////////////////////
1:     public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {
1:         if (getPrefetchSize() == 0) {
1:             prefetchExtension.set(pull.getQuantity());
0:             if (currentDispatchedCount == dispatchedCounter.get() || pull.isAlwaysSignalDone()) {
1:                     prefetchExtension.set(0);
/////////////////////////////////////////////////////////////////////////
1:                             pullTimeout(currentDispatchedCount, pull.isAlwaysSignalDone());
/////////////////////////////////////////////////////////////////////////
1:     private final void pullTimeout(long currentDispatchedCount, boolean alwaysSendDone) {
0:             if (currentDispatchedCount == dispatchedCounter.get() || alwaysSendDone) {
1:                     prefetchExtension.set(0);
/////////////////////////////////////////////////////////////////////////
1:         Message message = node != null ? node.getMessage() : null;
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("{}: has twice its prefetch limit pending, without an ack; it appears to be slow", toString());
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.warn("{}: stopped waiting for space in pendingMessage cursor for: {}", toString(), node.getMessageId());
1:                                 LOG.info("{}: Pending message cursor [{}] is full, temp usag ({}%) or memory usage ({}%) limit reached, blocking message add() pending the release of resources.",
1:                                         new Object[]{
1:                                                 toString(),
1:                                                 matched,
1:                                                 matched.getSystemUsage().getTempUsage().getPercentUsage(),
1:                                                 matched.getSystemUsage().getMemoryUsage().getPercentUsage()
1:                                         });
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.warn("No messages to evict returned for {} from eviction strategy: {} out of {} candidates", new Object[]{
1:                                         destination, messageEvictionStrategy, list.size()
1:                                 });
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("{}, ignoring duplicate add: {}", this, node.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{}, discarding message {}", this, message);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:ee54f09
/////////////////////////////////////////////////////////////////////////
1:                         updateStatsOnAck(ack);
1:                 updateStatsOnAck(ack);
0:             updatePrefetch(ack);
/////////////////////////////////////////////////////////////////////////
0:             updateStatsOnAck(ack);
0:             updatePrefetch(ack);
/////////////////////////////////////////////////////////////////////////
1:      * Update the statistics on message ack.
1:     private void updateStatsOnAck(final MessageAck ack) {
/////////////////////////////////////////////////////////////////////////
0:                 getSubscriptionStatistics().getDequeues().increment();
0:                 ((Destination)node.getRegionDestination()).getDestinationStatistics().getDequeues().increment();
0:                 ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
0:                 if (info.isNetworkSubscription()) {
0:                     ((Destination)node.getRegionDestination()).getDestinationStatistics().getForwards().add(ack.getMessageCount());
1:                 }
0:                 if (ack.isExpiredAck()) {
0:                     destination.getDestinationStatistics().getExpired().add(ack.getMessageCount());
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private void updatePrefetch(MessageAck ack) {
0:         while (true) {
0:             int currentExtension = prefetchExtension.get();
0:             int newExtension = Math.max(0, currentExtension - ack.getMessageCount());
0:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
0:                 break;
commit:2562cf2
/////////////////////////////////////////////////////////////////////////
1:     protected boolean discarding = false;
/////////////////////////////////////////////////////////////////////////
1:             // if this subscriber is already discarding a message, we don't want to add
1:             // any more messages to it as those messages can only be advisories generated in the process,
1:             // which can trigger the recursive call loop
1:             if (discarding) return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         discarding = true;
1:         try {
1:             message.decrementReferenceCount();
1:             matched.remove(message);
1:             discarded++;
0:             if (destination != null) {
0:                 destination.getDestinationStatistics().getDequeues().increment();
1:             }
0:             LOG.debug("{}, discarding message {}", this, message);
1:             Destination dest = (Destination) message.getRegionDestination();
1:             if (dest != null) {
1:                 dest.messageDiscarded(getContext(), this, message);
1:             }
1:             broker.getRoot().sendToDeadLetterQueue(getContext(), message, this, new Throwable("TopicSubDiscard. ID:" + info.getConsumerId()));
1:         } finally {
1:             discarding = false;
author:Gary Tully
-------------------------------------------------------------------------------
commit:708be6d
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(getContext(), message, this, new Throwable("TopicSubDiscard. ID:" + info.getConsumerId()));
commit:c7d8715
/////////////////////////////////////////////////////////////////////////
1:         if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {
commit:1be9398
/////////////////////////////////////////////////////////////////////////
0:             if ( info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize() ) {
0:                 //we are slow
0:                 if(!isSlowConsumer()) {
0:                     LOG.warn(toString() + ": has twice its prefetch limit pending, without an ack; it appears to be slow");
0:                     setSlowConsumer(true);
0:                     for (Destination dest: destinations) {
0:                         dest.slowConsumer(getContext(), this);
1:                     }
commit:179d95e
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn(toString() + ": has reached its prefetch limit without an ack, it appears to be slow");
commit:44488a5
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(this + ", ignoring duplicate add: " + node.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(this + ", discarding message " + message);
commit:27c1719
/////////////////////////////////////////////////////////////////////////
0:                     broker.messageExpired(getContext(), node, this);
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(getContext(), message, this);
commit:81f3935
/////////////////////////////////////////////////////////////////////////
1:         } else if (ack.isRedeliveredAck()) {
0:             // nothing to do atm
1:             return;
commit:ae7df9f
/////////////////////////////////////////////////////////////////////////
0:                 boolean warnedAboutWait = false;
0:             		        LOG.warn(toString() + ": stopped waiting for space in pendingMessage cursor for: " + node.getMessageId());
1:             		    if (!warnedAboutWait) {
0:             		        LOG.info(toString() + ": Pending message cursor ["+ matched + "] is full, temp usage (" + + matched.getSystemUsage().getTempUsage().getPercentUsage() + "%) or memory usage (" + matched.getSystemUsage().getMemoryUsage().getPercentUsage() + "%) limit reached, blocking message add() pending the release of resources.");
1:             		        warnedAboutWait = true;
1:             		    }
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             setSlowConsumer(false);
0:             if(!isSlowConsumer()) {
0:                 setSlowConsumer(true);
/////////////////////////////////////////////////////////////////////////
0:         setSlowConsumer(false);
commit:eb983f7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
1:     
1:     // allow duplicate suppression in a ring network of brokers
1:     protected int maxProducersToAudit = 1024;
1:     protected int maxAuditDepth = 1000;
1:     protected boolean enableAudit = false;
1:     protected ActiveMQMessageAudit audit;
/////////////////////////////////////////////////////////////////////////
1:         if (enableAudit) {
1:             audit= new ActiveMQMessageAudit(maxAuditDepth, maxProducersToAudit);
1:         }
1:         if (isDuplicate(node)) {
0:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private boolean isDuplicate(MessageReference node) {
1:         boolean duplicate = false;
1:         if (enableAudit && audit != null) {
1:             duplicate = audit.isDuplicate(node);
1:             if (LOG.isDebugEnabled()) {
1:                 if (duplicate) {
0:                     LOG.debug("ignoring duplicate add: " + node.getMessageId());
1:                 }
1:             }
1:         }
1:         return duplicate;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
1:     }
1: 
1:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
1:         if (audit != null) {
1:             audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
1:         }
1:     }
1: 
1:     public int getMaxAuditDepth() {
1:         return maxAuditDepth;
1:     }
1:     
1:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
1:         if (audit != null) {
1:             audit.setAuditDepth(maxAuditDepth);
1:         }
1:     }
1:     
1:     public boolean isEnableAudit() {
1:         return enableAudit;
1:     }
1: 
1:     public synchronized void setEnableAudit(boolean enableAudit) {
1:         this.enableAudit = enableAudit;
0:         if (enableAudit && audit==null) {
1:             audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:         }
1:     }
1:     
commit:3e4fc0a
/////////////////////////////////////////////////////////////////////////
0:             dest.messageDiscarded(getContext(), this, message);
commit:156a609
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             		    if (getContext().getStopping().get()) {
0:             		        LOG.warn("stopped waiting for space in pendingMessage cursor for: " + node.getMessageId());
0:             		        enqueueCounter.decrementAndGet();
0:             		        return;
1:             		    }
commit:a2af47b
/////////////////////////////////////////////////////////////////////////
0:             //we are slow
/////////////////////////////////////////////////////////////////////////
1:                                 list = matched.pageInList(pageInSize);
1:                             	for (MessageReference ref : list) {
1:                             	    ref.decrementReferenceCount();
1:                             	}
/////////////////////////////////////////////////////////////////////////
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1:                 node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
1:                     node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                         MessageReference message = (MessageReference) matched.next();
1:                         message.decrementReferenceCount();
commit:5eb274d
/////////////////////////////////////////////////////////////////////////
0:             // if maximumPendingMessages is set we will only discard messages which
0:             // have not been dispatched (i.e. we allow the prefetch buffer to be filled)
/////////////////////////////////////////////////////////////////////////
1:         node.incrementReferenceCount();
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
0:                     node.getRegionDestination().getDestinationStatistics().getExpired().increment();
commit:a707594
/////////////////////////////////////////////////////////////////////////
0:             // also. get these for a consumer expired message.
0:             if (destination != null && !ack.isInTransaction()) {
0:                 destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0:                 destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());   
0:             dequeueCounter.addAndGet(ack.getMessageCount());
commit:9b801d1
/////////////////////////////////////////////////////////////////////////
commit:b997d25
/////////////////////////////////////////////////////////////////////////
0:             if (ack.isInTransaction()) {
0:                 if (destination != null) {
0:                     destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());
1:                 }
1:             } else {
0:                 // expired message - expired message in a transacion
0:                 dequeueCounter.addAndGet(ack.getMessageCount());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2b99f39
/////////////////////////////////////////////////////////////////////////
1:         super.acknowledge(context, ack);
1: 
commit:ae61847
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransmitCallback;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 md.setTransmitCallback(new TransmitCallback() {
1: 
1:                     public void onSuccess() {
1:                         Destination regionDestination = (Destination) node.getRegionDestination();
1:                         regionDestination.getDestinationStatistics().getDispatched().increment();
1:                         regionDestination.getDestinationStatistics().getInflight().increment();
1:                         node.decrementReferenceCount();
1:                     }
1: 
1:                     @Override
1:                     public void onFailure() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:afe73c1
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean prefetchWindowOpen = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.scheduler = broker.getScheduler();
/////////////////////////////////////////////////////////////////////////
0:         if (!isFull() && matched.isEmpty() && !isSlave()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The slave should not deliver pull messages.
0:         if (getPrefetchSize() == 0 && !isSlave()) {
1: 
0:             prefetchWindowOpen.set(true);
1:             dispatchMatched();
1: 
1:             // If there was nothing dispatched.. we may need to setup a timeout.
0:             if (prefetchWindowOpen.get()) {
1: 
1:                 // immediate timeout used by receiveNoWait()
1:                 if (pull.getTimeout() == -1) {
0:                     prefetchWindowOpen.set(false);
1:                     // Send a NULL message to signal nothing pending.
1:                     dispatch(null);
1:                 }
1: 
1:                 if (pull.getTimeout() > 0) {
1:                     scheduler.executeAfterDelay(new Runnable() {
1: 
1:                         public void run() {
0:                             pullTimeout();
1:                         }
1:                     }, pull.getTimeout());
1:                 }
1:             }
1:         }
1:     /**
1:      * Occurs when a pull times out. If nothing has been dispatched since the
1:      * timeout was setup, then send the NULL message.
1:      */
0:     private final void pullTimeout() {
1:         synchronized (matchedListMutex) {
0:             if (prefetchWindowOpen.compareAndSet(true, false)) {
1:                 try {
1:                     dispatch(null);
1:                 } catch (Exception e) {
1:                     context.getConnection().serviceException(e);
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         return getDispatchedQueueSize() >= info.getPrefetchSize() && !prefetchWindowOpen.get();
/////////////////////////////////////////////////////////////////////////
0:                         prefetchWindowOpen.set(false);
/////////////////////////////////////////////////////////////////////////
1:         if (node != null) {
0:             node.incrementReferenceCount();
1:         }
1:         if (node != null) {
0:             md.setDestination(node.getRegionDestination().getActiveMQDestination());
0:             dispatchedCounter.incrementAndGet();
1:             // Keep track if this subscription is receiving messages from a single destination.
1:             if (singleDestination) {
1:                 if (destination == null) {
0:                     destination = node.getRegionDestination();
1:                 } else {
1:                     if (destination != node.getRegionDestination()) {
1:                         singleDestination = false;
1:                     }
1:             if (node != null) {
0:                 md.setTransmitCallback(new Runnable() {
1:                     @Override
0:                     public void run() {
0:                         node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
0:                         node.getRegionDestination().getDestinationStatistics().getInflight().increment();
1:                         node.decrementReferenceCount();
1:                     }
0:                 });
1:             }
1:             if (node != null) {
0:                 node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
0:                 node.getRegionDestination().getDestinationStatistics().getInflight().increment();
1:                 node.decrementReferenceCount();
1:             }
commit:ae5bd2e
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {
0:                 // Slow consumers should log and set their state as such.
0:                 if (!isSlowConsumer()) {
/////////////////////////////////////////////////////////////////////////
1:                         // Temporary storage could be full - so just try to add the message
1:                         // see https://issues.apache.org/activemq/browse/AMQ-2475
/////////////////////////////////////////////////////////////////////////
1:                             // only page in a 1000 at a time - else we could blow the memory
1:                                 oldMessages = messageEvictionStrategy.evictMessages(list);
0:                                 for (MessageReference ref : list) {
0:                                     ref.decrementReferenceCount();
1:                                 }
1:                                 messagesToEvict = oldMessages.length;
1:                                 for (int i = 0; i < messagesToEvict; i++) {
1:                                     MessageReference oldMessage = oldMessages[i];
1:                                     discard(oldMessage);
1:                                 }
1:                             // lets avoid an infinite loop if we are given a bad eviction strategy
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:             // Message was delivered but not acknowledged: update pre-fetch counters.
0:                 destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         if (enableAudit && audit == null) {
1: 
0:         return getDispatchedQueueSize() >= info.getPrefetchSize();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     private void dispatchMatched() throws IOException {
1: 
1:                         // Message may have been sitting in the matched list a while
/////////////////////////////////////////////////////////////////////////
0:         // Keep track if this subscription is receiving messages from a single destination.
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void setPrefetchSize(int newSize) {
1:         info.setPrefetchSize(newSize);
1:         try {
0:             dispatchMatched();
1:         } catch(Exception e) {
1:             LOG.trace("Caught exception on dispatch after prefetch size change.");
1:         }
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
1:         // Lets use an indirect reference so that we can associate a unique
1:         // locator /w the message.
1:         node = new IndirectMessageReference(node.getMessage());
/////////////////////////////////////////////////////////////////////////
0:         Message message = node.getMessage();
commit:30f531d
/////////////////////////////////////////////////////////////////////////
0:         if (!isFull() && matched.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:         if (getPrefetchSize() == 0 ) {
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
0:                     ((Destination)node.getRegionDestination()).getDestinationStatistics().getExpired().increment();
/////////////////////////////////////////////////////////////////////////
1:             md.setDestination(((Destination)node.getRegionDestination()).getActiveMQDestination());
1:                     destination = (Destination)node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                         Destination regionDestination = (Destination) node.getRegionDestination();
1:                         regionDestination.getDestinationStatistics().getDispatched().increment();
1:                         regionDestination.getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
1:                 Destination regionDestination = (Destination) node.getRegionDestination();
1:                 regionDestination.getDestinationStatistics().getDispatched().increment();
1:                 regionDestination.getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
0:         Destination dest = (Destination) message.getRegionDestination();
commit:222daf2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0:         Store tempDataStore = broker.getTempDataStore();
0:         if (tempDataStore != null) {
0:             this.matched = new FilePendingMessageCursor(matchedName, tempDataStore);
0:         } else {
0:             this.matched = new VMPendingMessageCursor();
1:         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
1:     private static final AtomicLong CURSOR_NAME_COUNTER = new AtomicLong(0);
1:     
0:     protected final UsageManager usageManager;
1:     
1:     boolean singleDestination = true;
1:     Destination destination;
1: 
1:         String matchedName = "TopicSubscription:" + CURSOR_NAME_COUNTER.getAndIncrement() + "[" + info.getConsumerId().toString() + "]";
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1: public class TopicSubscription extends AbstractSubscription {
0:     private static final Log LOG = LogFactory.getLog(TopicSubscription.class);
0:     private static final AtomicLong cursorNameCounter = new AtomicLong(0);
0:     protected AtomicLong dispatchedCounter = new AtomicLong();
0:     protected AtomicLong prefetchExtension = new AtomicLong();
1:     private int maximumPendingMessages = -1;
1:     private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();
1:     private int discarded;
1:     private final Object matchedListMutex = new Object();
0:     private final AtomicLong enqueueCounter = new AtomicLong(0);
0:     private final AtomicLong dequeueCounter = new AtomicLong(0);
0:     boolean singleDestination = true;
1:     private int memoryUsageHighWaterMark = 95;
0:     public TopicSubscription(Broker broker, ConnectionContext context, ConsumerInfo info, UsageManager usageManager) throws Exception {
1:         super(broker, context, info);
1:         this.usageManager = usageManager;
0:         String matchedName = "TopicSubscription:" + cursorNameCounter.getAndIncrement() + "[" + info.getConsumerId().toString() + "]";
0:         this.matched = new FilePendingMessageCursor(matchedName, broker.getTempDataStore());
1: 
1: 
1: 
1:     public void add(MessageReference node) throws Exception {
0:         if (!isFull() && !isSlave()) {
0:             // if maximumPendingMessages is set we will only discard messages
0:             // which
0:             // have not been dispatched (i.e. we allow the prefetch buffer to be
0:             // filled)
0:         } else {
0:             if (maximumPendingMessages != 0) {
1:                 synchronized (matchedListMutex) {
1:                     if (maximumPendingMessages > 0) {
1:                         // calculate the high water mark from which point we
1:                         // will eagerly evict expired messages
1:                         int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();
1:                         if (maximumPendingMessages > 0 && maximumPendingMessages < max) {
1:                             max = maximumPendingMessages;
1:                         if (!matched.isEmpty() && matched.size() > max) {
1:                         while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {
1:                             int pageInSize = matched.size() - maximumPendingMessages;
0:                             // only page in a 1000 at a time - else we could
0:                             // blow da memory
1:                             pageInSize = Math.max(1000, pageInSize);
0:                             LinkedList list = matched.pageInList(pageInSize);
0:                             MessageReference[] oldMessages = messageEvictionStrategy.evictMessages(list);
0:                             int messagesToEvict = oldMessages.length;
0:                             for (int i = 0; i < messagesToEvict; i++) {
0:                                 MessageReference oldMessage = oldMessages[i];
0:                             // lets avoid an infinite loop if we are given a bad
0:                             // eviction strategy
1:                             if (messagesToEvict == 0) {
0:                                 LOG.warn("No messages to evict returned from eviction strategy: " + messageEvictionStrategy);
/////////////////////////////////////////////////////////////////////////
1:      * Discard any expired messages from the matched list. Called from a
1:      * synchronized block.
1:     protected void removeExpiredMessages() throws IOException {
1:         try {
1:             while (matched.hasNext()) {
1:                 MessageReference node = matched.next();
0:                 if (broker.isExpired(node)) {
0:                     broker.messageExpired(getContext(), node);
1:         } finally {
1:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) {
1:         synchronized (matchedListMutex) {
1:             try {
1:                 while (matched.hasNext()) {
1:                     MessageReference node = matched.next();
1:                     if (node.getMessageId().equals(mdn.getMessageId())) {
1:             } finally {
0:     synchronized public void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
0:         boolean wasFull = isFull();
0:         if (ack.isStandardAck() || ack.isPoisonAck()) {
0:             if (context.isInTransaction()) {
0:                 prefetchExtension.addAndGet(ack.getMessageCount());
0:                 context.getTransaction().addSynchronization(new Synchronization() {
0:                     public void afterCommit() throws Exception {
0:                         synchronized (TopicSubscription.this) {
0:                             if (singleDestination && destination != null) {
/////////////////////////////////////////////////////////////////////////
0:             } else {
0:                 if (singleDestination && destination != null) {
0:             if (wasFull && !isFull()) {
0:         } else if (ack.isDeliveredAck()) {
0:             // Message was delivered but not acknowledged: update pre-fetch
0:             // counters.
0:             prefetchExtension.addAndGet(ack.getMessageCount());
0:             if (wasFull && !isFull()) {
0:         throw new JMSException("Invalid acknowledgment: " + ack);
0:     public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
1:     public int getPendingQueueSize() {
1:     public int getDispatchedQueueSize() {
0:         return (int)(dispatchedCounter.get() - dequeueCounter.get());
1:     public int getMaximumPendingMessages() {
1:     public long getDispatchedCounter() {
0:         return dispatchedCounter.get();
1:     public long getEnqueueCounter() {
1:     public long getDequeueCounter() {
1:     public int discarded() {
1:         synchronized (matchedListMutex) {
1:      * @return the number of matched messages (messages targeted for the
1:      *         subscription but not yet able to be dispatched due to the
1:      *         prefetch buffer being full).
1:     public int matched() {
1:         synchronized (matchedListMutex) {
1:      * Sets the maximum number of pending messages that can be matched against
1:      * this consumer before old messages are discarded.
1:     public void setMaximumPendingMessages(int maximumPendingMessages) {
1:         this.maximumPendingMessages = maximumPendingMessages;
1:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:      * Sets the eviction strategy used to decide which message to evict when the
1:      * slow consumer needs to discard messages
1:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
1:         this.messageEvictionStrategy = messageEvictionStrategy;
0:     private boolean isFull() {
0:         return getDispatchedQueueSize() - prefetchExtension.get() >= info.getPrefetchSize();
1:     public boolean isLowWaterMark() {
0:         return (getDispatchedQueueSize() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
1:     public boolean isHighWaterMark() {
0:         return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
1:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:         this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;
1:     public int getMemoryUsageHighWaterMark() {
0:     public UsageManager getUsageManager() {
1: 
1:     public PendingMessageCursor getMatched() {
1:     public void setMatched(PendingMessageCursor matched) {
1:         this.matched = matched;
/////////////////////////////////////////////////////////////////////////
1:     public void updateConsumerPrefetch(int newPrefetch) {
1:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()) {
1:             ConsumerControl cc = new ConsumerControl();
/////////////////////////////////////////////////////////////////////////
0:     public void optimizePrefetch() {
0:          * &&context.getConnection().isManageable()){
0:          * if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() &&
0:          * isLowWaterMark()){
0:          * info.setCurrentPrefetchSize(info.getPrefetchSize());
0:          * if(info.getCurrentPrefetchSize()==info.getPrefetchSize() &&
0:          * isHighWaterMark()){ // want to purge any outstanding acks held by the
0:          * consumer info.setCurrentPrefetchSize(1); updateConsumerPrefetch(1); } }
0:     private void dispatchMatched() throws IOException {
1:         synchronized (matchedListMutex) {
1:             try {
1:                 while (matched.hasNext() && !isFull()) {
0:                     MessageReference message = (MessageReference)matched.next();
0:                     if (broker.isExpired(message)) {
0:                         broker.messageExpired(getContext(), message);
1:             } finally {
1:     private void dispatch(final MessageReference node) throws IOException {
0:         Message message = (Message)node;
1:         MessageDispatch md = new MessageDispatch();
0:         // Keep track if this subscription is receiving messages from a single
0:         // destination.
0:         if (singleDestination) {
0:             if (destination == null) {
0:                 destination = node.getRegionDestination();
0:             } else {
0:                 if (destination != node.getRegionDestination()) {
0:                     singleDestination = false;
1:         if (info.isDispatchAsync()) {
0:             md.setTransmitCallback(new Runnable() {
0:                 public void run() {
0:         } else {
1: 
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Discarding message " + message);
0:         broker.getRoot().sendToDeadLetterQueue(getContext(), message);
1:     public String toString() {
1:         return "TopicSubscription:" + " consumer=" + info.getConsumerId() + ", destinations=" + destinations.size() + ", dispatched=" + getDispatchedQueueSize() + ", delivered="
0:                + getDequeueCounter() + ", matched=" + matched() + ", discarded=" + discarded();
1:     public void destroy() {
1:         synchronized (matchedListMutex) {
1:             try {
1:             } catch (Exception e) {
1:                 LOG.warn("Failed to destroy cursor", e);
0:         return (int)(info.getPrefetchSize() + prefetchExtension.get());
1:     }
1: 
commit:f7db42a
/////////////////////////////////////////////////////////////////////////
0:             md.setTransmitCallback(new Runnable(){
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
commit:a58d36b
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 // Message may have been sitting in the matched list a while
1:                 // waiting for the consumer to ak the message.
0:         		if( message.isExpired() ) {
0:         			message.decrementReferenceCount();
1:         			continue; // just drop it.
1:         		}
1: 
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
commit:c6e0984
/////////////////////////////////////////////////////////////////////////
0:     	/*
/////////////////////////////////////////////////////////////////////////
1:         */
commit:c46562b
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicLong enqueueCounter = new AtomicLong(0);
0:     private final AtomicLong dequeueCounter = new AtomicLong(0);
/////////////////////////////////////////////////////////////////////////
1:         
0:         enqueueCounter.incrementAndGet();        
1:         
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:                         dequeueCounter.addAndGet(ack.getMessageCount());
0:                 dequeueCounter.addAndGet(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0: 		return enqueueCounter.get();
1:     
0:         return dequeueCounter.get();
/////////////////////////////////////////////////////////////////////////
0:     public void destroy() {
0:         synchronized(matchedListMutex){
0:             for (Iterator iter = matched.iterator(); iter.hasNext();) {
0:                 MessageReference node = (MessageReference) iter.next();
1:                 node.decrementReferenceCount();
1:             }
0:             matched.clear();
1:         }
1:     }
1: 
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicLong;
1: 	
1:     
0:     protected AtomicLong dispatched=new AtomicLong();
0:     protected AtomicLong delivered=new AtomicLong();
0:     long enqueueCounter;
1:     
/////////////////////////////////////////////////////////////////////////
0:         enqueueCounter++;
/////////////////////////////////////////////////////////////////////////
0:     public int getPendingQueueSize(){
1:         return matched();
0:     public int getDispatchedQueueSize(){
0:         return (int)(dispatched.get()-delivered.get());
0:     
0: 	public long getDispatchedCounter() {
0: 		return dispatched.get();
1: 	}
0: 
0: 	public long getEnqueueCounter() {
0: 		return enqueueCounter;
1: 	}
0:     public long getDequeueCounter(){
0:         return delivered.get();
1:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:                         +", dispatched="+getDispatchedQueueSize()+", delivered="+getDequeueCounter()+", matched="+matched()+", discarded="+discarded();
0: 
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception{
0:                     public void afterCommit() throws Exception{
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
0: 
1: import java.io.IOException;
0: import java.util.Iterator;
1: import java.util.LinkedList;
0: 
0: import javax.jms.InvalidSelectorException;
1: import javax.jms.JMSException;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.transaction.Synchronization;
0: 
0: public class TopicSubscription extends AbstractSubscription {
0:     
0:     final protected LinkedList matched = new LinkedList();
0:     final protected ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
0:     final protected UsageManager usageManager;
0:     protected int dispatched=0;
0:     protected int delivered=0;
0:     
0:     public TopicSubscription(ConnectionContext context, ConsumerInfo info, UsageManager usageManager) throws InvalidSelectorException {
0:         super(context, info);
0:         this.usageManager=usageManager;
1:     }
0: 
0:     public void add(MessageReference node) throws InterruptedException, IOException {
0:         node.incrementReferenceCount();
0:         if( !isFull() ) {
0:             dispatch(node);
0:         } else {
0:             matched.addLast(node);
1:         }        
1:     }
0:     
0:     public void acknowledge(final ConnectionContext context, final MessageAck ack) throws Throwable {
0:         
0:         // Handle the standard acknowledgment case.
0:         boolean wasFull = isFull();
0:         if( ack.isStandardAck() || ack.isPoisonAck() ) {
0:             if ( context.isInTransaction() ) {
0:                 delivered += ack.getMessageCount();
0:                 context.getTransaction().addSynchronization(new Synchronization(){
0:                     public void afterCommit() throws Throwable {
0:                         synchronized(TopicSubscription.this) {
0:                             dispatched -= ack.getMessageCount();
0:                             delivered = Math.max(0, delivered - ack.getMessageCount());
1:                         }
1:                     }
0:                 });
0:             } else {
0:                 dispatched -= ack.getMessageCount();
0:                 delivered = Math.max(0, delivered - ack.getMessageCount());
1:             }
0:             
0:             if( wasFull && !isFull() ) {                            
0:                 dispatchMatched();
1:             }
0:             return;
0:             
0:         } else if( ack.isDeliveredAck() ) {
0:             // Message was delivered but not acknowledged: update pre-fetch counters.
0:             delivered += ack.getMessageCount();
0:             if( wasFull && !isFull() ) {                            
0:                 dispatchMatched();
1:             }
0:             return;
1:         }
0:         
0:         throw new JMSException("Invalid acknowledgment: "+ack);
1:     }
0:     
0:     private boolean isFull() {
0:         return dispatched-delivered >= info.getPrefetchSize();
1:     }
0:     
0:     private void dispatchMatched() throws IOException {
0:         for (Iterator iter = matched.iterator(); iter.hasNext() && !isFull();) {
0:             MessageReference message = (MessageReference) iter.next();
0:             iter.remove();
1:             dispatch(message);
1:         }
1:     }
0: 
0:     private void dispatch(final MessageReference node) throws IOException {
0:                 
0:         Message message = (Message) node;
0:         
1:         // Make sure we can dispatch a message.        
0:         MessageDispatch md = new MessageDispatch();
1:         md.setMessage(message);
0:         md.setConsumerId( info.getConsumerId() );
0:         md.setDestination( node.getRegionDestination().getActiveMQDestination() );
0: 
0:         dispatched++;
0:         if( info.isDispatchAsync() ) {
0:             md.setConsumer(new Runnable(){
0:                 public void run() {
0:                     node.decrementReferenceCount();
1:                 }
0:             });
1:             context.getConnection().dispatchAsync(md);
0:         } else {
1:             context.getConnection().dispatchSync(md);                
0:             node.decrementReferenceCount();
1:         }        
1:     }
0:     
0:     public String toString() {
0:         return 
0:             "TopicSubscription:" +
0:             " consumer="+info.getConsumerId()+
0:             ", destinations="+destinations.size()+
0:             ", dispatched="+dispatched+
0:             ", delivered="+this.delivered+
0:             ", matched="+this.matched.size();
1:     }
0: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a798c85
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.warn("No messages to evict returned for "  + destination + " from eviction strategy: " + messageEvictionStrategy + " out of " + list.size() + " candidates");
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(TopicSubscription.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:             this.matched = new VMPendingMessageCursor(false);
1:             this.matched = new FilePendingMessageCursor(broker,matchedName,false);
commit:f42c91f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected boolean active = false;
/////////////////////////////////////////////////////////////////////////
1:         this.active=true;
/////////////////////////////////////////////////////////////////////////
0:                 while (active) {
0:                     synchronized (matchedListMutex) {
1:                         while (matched.isFull()) {
0:                             if (getContext().getStopping().get()) {
0:                                 LOG.warn(toString() + ": stopped waiting for space in pendingMessage cursor for: "
0:                                         + node.getMessageId());
0:                                 enqueueCounter.decrementAndGet();
0:                                 return;
1:                             }
0:                             if (!warnedAboutWait) {
0:                                 LOG.info(toString() + ": Pending message cursor [" + matched
0:                                         + "] is full, temp usage ("
0:                                         + +matched.getSystemUsage().getTempUsage().getPercentUsage()
0:                                         + "%) or memory usage ("
0:                                         + matched.getSystemUsage().getMemoryUsage().getPercentUsage()
0:                                         + "%) limit reached, blocking message add() pending the release of resources.");
0:                                 warnedAboutWait = true;
1:                             }
1:                             matchedListMutex.wait(20);
1:                         }
0:                         //Temporary storage could be full - so just try to add the message
0:                         //see https://issues.apache.org/activemq/browse/AMQ-2475
1:                         if (matched.tryAddMessageLast(node, 10)) {
0:                             break;
1:                         }
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                         MessageReference message = matched.next();
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:         this.active=false;
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:         return info.getPrefetchSize();
commit:07cb724
/////////////////////////////////////////////////////////////////////////
0:             	synchronized(matchedListMutex){
0:             		while (matched.isFull()){
0:             			matchedListMutex.wait(20);
1:             		}
0:             		matched.addMessageLast(node);
1:             	}
0:                     
/////////////////////////////////////////////////////////////////////////
1:                             LinkedList<MessageReference> list = null;
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:         this.matched.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
commit:dfdd896
/////////////////////////////////////////////////////////////////////////
0:             if (destination != null) {
0:                 destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if(destination != null) {
0:             destination.getDestinationStatistics().getDequeues().increment();
0:             destination.getDestinationStatistics().getInflight().decrement();
1:         }
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0:     private boolean slowConsumer;
/////////////////////////////////////////////////////////////////////////
0:             slowConsumer=false;
0:           //we are slow
0:             if(!slowConsumer) {
0:                 slowConsumer=true;
0:                 for (Destination dest: destinations) {
0:                     dest.slowConsumer(getContext(), this);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:         Destination dest = message.getRegionDestination();
0:         if (dest != null) {
0:             dest.messageDiscarded(getContext(), message);
1:         }
commit:ab3b155
/////////////////////////////////////////////////////////////////////////
0:         if (ack.isStandardAck() || ack.isPoisonAck() || ack.isIndividualAck()) {
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {
0:         super(broker, context, info);
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:     public TopicSubscription(Broker broker, Destination destination,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {
0:         super(broker, destination,context, info);
commit:cf55702
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:                             LinkedList list = null;
1:                             MessageReference[] oldMessages=null;
1:                             synchronized(matched){
0:                             list = matched.pageInList(pageInSize);
0:                             	oldMessages = messageEvictionStrategy.evictMessages(list);
1:                             }
1:                             int messagesToEvict = 0;
1:                             if (oldMessages != null){
0: 	                            messagesToEvict = oldMessages.length;
0: 	                            for (int i = 0; i < messagesToEvict; i++) {
0: 	                                MessageReference oldMessage = oldMessages[i];
0: 	                                discard(oldMessage);
1: 	                            }
/////////////////////////////////////////////////////////////////////////
0:     	List<MessageReference> result = new ArrayList<MessageReference>();
0:         synchronized(matched) {
0:             result.addAll(matched.pageInList(1000));
1:         }
0:         return result;
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0:                     destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:             destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
1:                         if (message.isExpired()) {
1:                             discard(message);
/////////////////////////////////////////////////////////////////////////
0:                     node.getRegionDestination().getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
0:             node.getRegionDestination().getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
0:         destination.getDestinationStatistics().getDequeues().increment();
0:         destination.getDestinationStatistics().getInflight().decrement();
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
0:         if (!isFull() && matched.isEmpty()  && !isSlave()) {
/////////////////////////////////////////////////////////////////////////
0:                 dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:                        synchronized (TopicSubscription.this) {
0:                         dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:             dispatchMatched();
0:             dequeueCounter.addAndGet(ack.getMessageCount());
0:             dispatchMatched();
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFull() {
0:         return getDispatchedQueueSize()  >= info.getPrefetchSize();
0:     
1:     public int getInFlightSize() {
1:         return getDispatchedQueueSize();
1:     }
0:     
0:     
0:         return getDispatchedQueueSize() <= (info.getPrefetchSize() * .4);
0:         return getDispatchedQueueSize() >= (info.getPrefetchSize() * .9);
/////////////////////////////////////////////////////////////////////////
0:     private void dispatchMatched() throws IOException {       
1:             if (!matched.isEmpty() && !isFull()) {
0:                 try {
1:                     matched.reset();
0:                    
0:                     while (matched.hasNext() && !isFull()) {
0:                         MessageReference message = (MessageReference) matched
0:                                 .next();
1:                         matched.remove();
0:                         // Message may have been sitting in the matched list a
0:                         // while
0:                         // waiting for the consumer to ak the message.
0:                         if (broker.isExpired(message)) {
0:                             message.decrementReferenceCount();
0:                             broker.messageExpired(getContext(), message);
0:                             dequeueCounter.incrementAndGet();
0:                             continue; // just drop it.
1:                         }
0:                         dispatch(message);
0:                 } finally {
1:                     matched.release();
/////////////////////////////////////////////////////////////////////////
0:         return (int)info.getPrefetchSize();
1:     }
0:     
1:     /**
0:      * Get the list of inflight messages
0:      * @return the list
1:      */
0:     public synchronized List<MessageReference> getInFlightMessages(){
0:         return matched.pageInList(1000);
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
0:         if (info.getDestination().isTemporary() || broker == null || broker.getTempDataStore()==null ) {
0:         } else {
0:             this.matched = new FilePendingMessageCursor(broker,matchedName);
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected final SystemUsage usageManager;
/////////////////////////////////////////////////////////////////////////
0:     public TopicSubscription(Broker broker, ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         this.matched.setSystemUsage(usageManager);
/////////////////////////////////////////////////////////////////////////
1:     public SystemUsage getUsageManager() {
commit:a401575
/////////////////////////////////////////////////////////////////////////
0:                 if(broker.isExpired(node)){
/////////////////////////////////////////////////////////////////////////
0:                     if(broker.isExpired(message)){
commit:a414c20
/////////////////////////////////////////////////////////////////////////
0:                                 discard(oldMessage);
/////////////////////////////////////////////////////////////////////////
0:                     broker.messageExpired(getContext(),node);
/////////////////////////////////////////////////////////////////////////
0:                         broker.messageExpired(getContext(),message);
0:                         dequeueCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:     
1:     private void discard(MessageReference message) {
0:         message.decrementReferenceCount();
0:         matched.remove(message);
0:         discarded++;
0:         dequeueCounter.incrementAndGet();
0:         if(log.isDebugEnabled()){
0:             log.debug("Discarding message "+message);
1:         }
0:         broker.getRoot().sendToDeadLetterQueue(getContext(),message);
1:     }
commit:83a6eff
/////////////////////////////////////////////////////////////////////////
0:         if(!isFull()&&!isSlave()){
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
1:     protected PendingMessageCursor matched;
/////////////////////////////////////////////////////////////////////////
0:             throws Exception{
0:        
1:     }
0:     
1:     public void init() throws Exception {
0:     
0:     public void add(MessageReference node) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the matched
1:      */
0:     public PendingMessageCursor getMatched(){
1:         return this.matched;
0:     }
0: 
1:     /**
1:      * @param matched the matched to set
1:      */
0:     public void setMatched(PendingMessageCursor matched){
0:         this.matched=matched;
0:     }
/////////////////////////////////////////////////////////////////////////
0:             try{
1:                 matched.destroy();
0:             }catch(Exception e){
0:                log.warn("Failed to destroy cursor",e);
0:             }
0: 
0:     
0:     
commit:b036d4d
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static final AtomicLong cursorNameCounter=new AtomicLong(0);
0:     private MessageEvictionStrategy messageEvictionStrategy=new OldestMessageEvictionStrategy();
0:     private int discarded=0;
0:     private final AtomicLong enqueueCounter=new AtomicLong(0);
0:     private final AtomicLong dequeueCounter=new AtomicLong(0);
0:     Destination destination;
0:     private int memoryUsageHighWaterMark=95;
0: 
0:             throws InvalidSelectorException{
0:         String matchedName="TopicSubscription:"+cursorNameCounter.getAndIncrement()+"["+info.getConsumerId().toString()
0:                 +"]";
0:         this.matched=new FilePendingMessageCursor(matchedName,broker.getTempDataStore());
0:         this.matched.setUsageManager(usageManager);
1:         this.matched.start();
0:         enqueueCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                     if(maximumPendingMessages>0){
0:                         int max=messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();
0:                         if(maximumPendingMessages>0&&maximumPendingMessages<max){
0:                             max=maximumPendingMessages;
0:                         if(!matched.isEmpty()&&matched.size()>max){
0:                         while(!matched.isEmpty()&&matched.size()>maximumPendingMessages){
0:                             int pageInSize=matched.size()-maximumPendingMessages;
0:                             // only page in a 1000 at a time - else we could blow da memory
0:                             pageInSize=Math.max(1000,pageInSize);
0:                             LinkedList list=matched.pageInList(pageInSize);
0:                             MessageReference[] oldMessages=messageEvictionStrategy.evictMessages(list);
0:                             int messagesToEvict=oldMessages.length;
0:                             for(int i=0;i<messagesToEvict;i++){
0:                                 MessageReference oldMessage=oldMessages[i];
0:                                 oldMessage.decrementReferenceCount();
0:                                 if(log.isDebugEnabled()){
0:                                     log.debug("Discarding message "+oldMessages[i]);
0:                             }
0:                             if(messagesToEvict==0){
0:                                 log.warn("No messages to evict returned from eviction strategy: "
0:                                         +messageEvictionStrategy);
/////////////////////////////////////////////////////////////////////////
0:      * 
1:      * @throws IOException
/////////////////////////////////////////////////////////////////////////
0: 
0:                         synchronized(TopicSubscription.this){
0:                             if(singleDestination){
0:                                 destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0:                             }
0:                         }
0:                 if(singleDestination){
0:                     destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     public Response pullMessage(ConnectionContext context,MessagePull pull) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     public long getDispatchedCounter(){
0:         return dispatched.get();
0:     }
0: 
0:     public long getEnqueueCounter(){
0:         return enqueueCounter.get();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public int discarded(){
0:         synchronized(matchedListMutex){
0:      * @return the number of matched messages (messages targeted for the subscription but not yet able to be dispatched
0:      *         due to the prefetch buffer being full).
0:     public int matched(){
0:         synchronized(matchedListMutex){
/////////////////////////////////////////////////////////////////////////
0:     public MessageEvictionStrategy getMessageEvictionStrategy(){
0:      * Sets the eviction strategy used to decide which message to evict when the slow consumer needs to discard messages
0:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy){
0:         this.messageEvictionStrategy=messageEvictionStrategy;
0: 
0:         return (dispatched.get()-delivered.get())<=(info.getPrefetchSize()*.4);
0: 
0:         return (dispatched.get()-delivered.get())>=(info.getPrefetchSize()*.9);
0: 
1:     /**
1:      * @param memoryUsageHighWaterMark the memoryUsageHighWaterMark to set
1:      */
0:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark){
0:         this.memoryUsageHighWaterMark=memoryUsageHighWaterMark;
0:     }
0: 
1:     /**
1:      * @return the memoryUsageHighWaterMark
1:      */
0:     public int getMemoryUsageHighWaterMark(){
1:         return this.memoryUsageHighWaterMark;
0:     }
0: 
1:     /**
1:      * @return the usageManager
1:      */
0:     public UsageManager getUsageManager(){
1:         return this.usageManager;
0:     }
0: 
0:      * 
0:         if(context!=null&&context.getConnection()!=null&&context.getConnection().isManageable()){
0:             ConsumerControl cc=new ConsumerControl();
0: 
0:      * 
0:         /*
0:          * if(info!=null&&info.isOptimizedAcknowledge()&&context!=null&&context.getConnection()!=null
0:          * &&context.getConnection().isManageable()){ if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() &&
0:          * isLowWaterMark()){ info.setCurrentPrefetchSize(info.getPrefetchSize());
0:          * updateConsumerPrefetch(info.getPrefetchSize()); }else
0:          * if(info.getCurrentPrefetchSize()==info.getPrefetchSize() && isHighWaterMark()){ // want to purge any
0:          * outstanding acks held by the consumer info.setCurrentPrefetchSize(1); updateConsumerPrefetch(1); } }
1:          */
0:                 while(matched.hasNext()&&!isFull()){
/////////////////////////////////////////////////////////////////////////
0:         Message message=(Message)node;
0:         if(singleDestination){
0:             if(destination==null){
0:                 destination=node.getRegionDestination();
0:             }else{
0:                 if(destination!=node.getRegionDestination()){
0:                     singleDestination=false;
0:                 }
0:             }
0: 
0:                     node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
/////////////////////////////////////////////////////////////////////////
0:                 +", dispatched="+getDispatchedQueueSize()+", delivered="+getDequeueCounter()+", matched="+matched()
0:                 +", discarded="+discarded();
0:     public void destroy(){
commit:ec63977
/////////////////////////////////////////////////////////////////////////
0:     protected void removeExpiredMessages() throws IOException{
0:         try{
0:             while(matched.hasNext()){
0:                 if(node.isExpired()){
0:         }finally{
0:     public void processMessageDispatchNotification(MessageDispatchNotification mdn){
0:         synchronized(matchedListMutex){
0:             try{
1:                 matched.reset();
0:                 while(matched.hasNext()){
0:                     MessageReference node=matched.next();
0:                     if(node.getMessageId().equals(mdn.getMessageId())){
1:                         matched.remove();
0:                         dispatched.incrementAndGet();
0:                         node.decrementReferenceCount();
0:                         break;
0:                     }
0:                 }
0:             }finally{
1:                 matched.release();
0:             }
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             try{
1:                 matched.reset();
0:                 while(matched.hasNext()){
0:                     MessageReference message=(MessageReference)matched.next();
0:                     matched.remove();
0:                     // Message may have been sitting in the matched list a while
0:                     // waiting for the consumer to ak the message.
0:                     if(message.isExpired()){
0:                         message.decrementReferenceCount();
0:                         continue; // just drop it.
0:                     }
0:                     dispatch(message);
0:                 }
0:             }finally{
1:                 matched.release();
commit:9359e9f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.FilePendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:     final protected FilePendingMessageCursor matched;
/////////////////////////////////////////////////////////////////////////
0:         this.matched = new FilePendingMessageCursor(info.getConsumerId().toString(), broker.getTempDataStore());
/////////////////////////////////////////////////////////////////////////
0:                     matched.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
1:                             removeExpiredMessages();
0:                             int pageInSize = matched.size() - maximumPendingMessages;
0:                             //only page in a 1000 at a time - else we could blow da memory
0:                             pageInSize = Math.max(1000,pageInSize);
0:                             LinkedList list = matched.pageInList(pageInSize);
0:                             MessageReference[] oldMessages = messageEvictionStrategy.evictMessages(list);
0:                                 MessageReference oldMessage = oldMessages[i];
0:                             	oldMessage.decrementReferenceCount();
0:                                 matched.remove(oldMessage);
0:                                 
/////////////////////////////////////////////////////////////////////////
0:     protected void removeExpiredMessages() throws IOException {
0:         matched.reset();
0:         while(matched.hasNext()) {
0:             MessageReference node=matched.next();
0:                 matched.remove();
0:         matched.release();
0:             matched.reset();
0:             while(matched.hasNext()) {
0:                 MessageReference node=matched.next();
0:                     matched.remove();
0:             matched.release();
/////////////////////////////////////////////////////////////////////////
0:             matched.reset();
0:             while(matched.hasNext()) {
0:                 MessageReference message=(MessageReference) matched.next();
0:                 matched.remove();
/////////////////////////////////////////////////////////////////////////
0:             matched.release();
/////////////////////////////////////////////////////////////////////////
0:             matched.destroy();
commit:6eaea6f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
0:             optimizePrefetch();
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return true when 60% or more room is left for dispatching messages
1:      */
0:     public boolean isLowWaterMark(){
0:         return (dispatched.get()-delivered.get()) <= (info.getPrefetchSize() *.4);
0:     }
0:     
1:     /**
1:      * @return true when 10% or less room is left for dispatching messages
1:      */
0:     public boolean isHighWaterMark(){
0:         return (dispatched.get()-delivered.get()) >= (info.getPrefetchSize() *.9);
0:     }
0:     
1:     /**
1:      * inform the MessageConsumer on the client to change it's prefetch
1:      * @param newPrefetch
1:      */
0:     public void updateConsumerPrefetch(int newPrefetch){
0:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()){
0:             ConsumerControl cc = new ConsumerControl();
1:             cc.setConsumerId(info.getConsumerId());
1:             cc.setPrefetch(newPrefetch);
1:             context.getConnection().dispatchAsync(cc);
0:         }
0:     }
0:     
1:     /**
0:      * optimize message consumer prefetch if the consumer supports it
0:      *
1:      */
0:     public void optimizePrefetch(){
0:         if(info!=null&&info.isOptimizedAcknowledge()&&context!=null&&context.getConnection()!=null
0:                         &&context.getConnection().isManageable()){
0:             if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() && isLowWaterMark()){
0:                 info.setCurrentPrefetchSize(info.getPrefetchSize());
0:                 updateConsumerPrefetch(info.getPrefetchSize());
0:             }else if(info.getCurrentPrefetchSize()==info.getPrefetchSize() && isHighWaterMark()){
0:                 // want to purge any outstanding acks held by the consumer
0:                 info.setCurrentPrefetchSize(1);
0:                 updateConsumerPrefetch(1);
0:             }
0:         }
0:     }
commit:6d003a8
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
0: 
0: public class TopicSubscription extends AbstractSubscription{
0:     private static final Log log=LogFactory.getLog(TopicSubscription.class);
0:     final protected LinkedList matched=new LinkedList();
0:     final protected ActiveMQDestination dlqDestination=new ActiveMQQueue("ActiveMQ.DLQ");
0:     protected AtomicInteger dispatched=new AtomicInteger();
0:     protected AtomicInteger delivered=new AtomicInteger();
0:     private int maximumPendingMessages=-1;
0:     private final Object matchedListMutex=new Object();
0: 
0:     public TopicSubscription(Broker broker,ConnectionContext context,ConsumerInfo info,UsageManager usageManager)
0:                     throws InvalidSelectorException{
0:         super(broker,context,info);
0:     public void add(MessageReference node) throws InterruptedException,IOException{
0:         if(!isFull()&&!isSlaveBroker()){
0:         }else{
0:             if(maximumPendingMessages!=0){
0:                 synchronized(matchedListMutex){
0:                     if(maximumPendingMessages>0){
0:                         while(!matched.isEmpty()&&matched.size()>maximumPendingMessages){
0:                             MessageReference oldMessage=(MessageReference) matched.removeFirst();
0:                             if (log.isDebugEnabled()){
0:                                 log.debug("Discarding message " + oldMessage);
0:                             }
0:         }
0: 
0:     public void processMessageDispatchNotification(MessageDispatchNotification mdn){
0:         synchronized(matchedListMutex){
0:             for(Iterator i=matched.iterator();i.hasNext();){
0:                 MessageReference node=(MessageReference) i.next();
0:                 if(node.getMessageId().equals(mdn.getMessageId())){
0:                     dispatched.incrementAndGet();
0: 
0:     public void acknowledge(final ConnectionContext context,final MessageAck ack) throws Throwable{
0:         boolean wasFull=isFull();
0:         if(ack.isStandardAck()||ack.isPoisonAck()){
0:             if(context.isInTransaction()){
0:                 delivered.addAndGet(ack.getMessageCount());
0:                     public void afterCommit() throws Throwable{
0:                         dispatched.addAndGet(-ack.getMessageCount());
0:                         delivered.set(Math.max(0,delivered.get()-ack.getMessageCount()));
0:             }else{
0:                 dispatched.addAndGet(-ack.getMessageCount());
0:                 delivered.set(Math.max(0,delivered.get()-ack.getMessageCount()));
0:             if(wasFull&&!isFull()){
0:         }else if(ack.isDeliveredAck()){
0:             delivered.addAndGet(ack.getMessageCount());
0:             if(wasFull&&!isFull()){
0: 
0:         return matched.size()-dispatched.get();
0: 
0:         return dispatched.get();
0: 
0:         return delivered.get();
0: 
0:     public int getMaximumPendingMessages(){
0:      * Sets the maximum number of pending messages that can be matched against this consumer before old messages are
0:      * discarded.
0:     public void setMaximumPendingMessages(int maximumPendingMessages){
0:         this.maximumPendingMessages=maximumPendingMessages;
0:     private boolean isFull(){
0:         return dispatched.get()-delivered.get()>=info.getPrefetchSize();
0: 
0:     private void dispatchMatched() throws IOException{
0:         synchronized(matchedListMutex){
0:             for(Iterator iter=matched.iterator();iter.hasNext()&&!isFull();){
0:                 MessageReference message=(MessageReference) iter.next();
0:                 iter.remove();
0:                 dispatch(message);
0:             }
0:     private void dispatch(final MessageReference node) throws IOException{
0:         Message message=(Message) node;
0:         // Make sure we can dispatch a message.
0:         MessageDispatch md=new MessageDispatch();
1:         md.setConsumerId(info.getConsumerId());
0:         md.setDestination(node.getRegionDestination().getActiveMQDestination());
0:         dispatched.incrementAndGet();
0:         if(info.isDispatchAsync()){
0:                 public void run(){
0:         }else{
0:             context.getConnection().dispatchSync(md);
0:         }
0:     public String toString(){
0:         return "TopicSubscription:"+" consumer="+info.getConsumerId()+", destinations="+destinations.size()
0:                         +", dispatched="+dispatched+", delivered="+this.delivered+", matched="+this.matched.size();
0:     }
commit:2867249
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log log = LogFactory.getLog(TopicSubscription.class);
/////////////////////////////////////////////////////////////////////////
0:                         log.warn("discarding " + (matched.size() - maximumPendingMessages) + " messages for slow consumer");
0:                         while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {
commit:3601e81
/////////////////////////////////////////////////////////////////////////
0:     public int pending(){
0:         return matched.size() - dispatched;
0:     }
0:     
0:     public int dispatched(){
0:         return dispatched;
0:     }
0:     
0:     public int delivered(){
0:         return delivered;
0:     }
0:     
commit:4098942
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
0:     public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, UsageManager usageManager) throws InvalidSelectorException {
0:         super(broker,context, info);
0:         if( !isFull() && !isSlaveBroker() ) {
0:             synchronized(matched){
0:             }
0:     public void processMessageDispatchNotification(MessageDispatchNotification  mdn){
0:         synchronized(matched){
0:             for (Iterator i = matched.iterator(); i.hasNext();){
0:                 MessageReference node = (MessageReference)i.next();
0:                 if (node.getMessageId().equals(mdn.getMessageId())){
0:                     i.remove();
0:                     dispatched++;
0:                     node.decrementReferenceCount();
0:                     break;
0:                 }
0:             }
0:         }
0:     }
0:     
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:b743552
/////////////////////////////////////////////////////////////////////////
0:                         	if( singleDestination && destination!=null) {
/////////////////////////////////////////////////////////////////////////
0:             	if( singleDestination && destination!=null) {
commit:015cd8a
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicLong dispatchedCounter=new AtomicLong();
0:     protected AtomicLong prefetchExtension=new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0:                     dispatchedCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                         dispatchedCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:             	prefetchExtension.addAndGet(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:                         prefetchExtension.addAndGet(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:                 prefetchExtension.addAndGet(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:         	prefetchExtension.addAndGet(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
0:     	return (int)(dispatchedCounter.get()-dequeueCounter.get());
/////////////////////////////////////////////////////////////////////////
0:     	return dispatchedCounter.get();
/////////////////////////////////////////////////////////////////////////
0:     	return getDispatchedQueueSize()-prefetchExtension.get()>=info.getPrefetchSize();
0:     	return (getDispatchedQueueSize()-prefetchExtension.get()) <= (info.getPrefetchSize() *.4);
0:     	return (getDispatchedQueueSize()-prefetchExtension.get()) >= (info.getPrefetchSize() *.9);
/////////////////////////////////////////////////////////////////////////
0:         dispatchedCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:     public int getPrefetchSize() {
0:         return (int) (info.getPrefetchSize() + prefetchExtension.get());
0:     }    
commit:36de58b
/////////////////////////////////////////////////////////////////////////
0:     boolean singleDestination=true;
0:     Destination destination;    
0:     
/////////////////////////////////////////////////////////////////////////
0:                     	synchronized( TopicSubscription.this ) {
0: 	                    	if( singleDestination ) {
0: 	                    		destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0: 	                    	}
0:                     	}                    
0:             	
0:             	if( singleDestination ) {
0:             		destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());
0:             	}
0:             	            
/////////////////////////////////////////////////////////////////////////
0:        
0:         // Keep track if this subscription is receiving messages from a single destination.
0:         if( singleDestination ) {
0:         	if( destination == null ) {
0:         		destination = node.getRegionDestination();
0:         	} else {
0:         		if( destination != node.getRegionDestination() ) {
0:         			singleDestination = false;
0:         		}
0:         	}
0:         }
0:                 
0:                     node.getRegionDestination().getDestinationStatistics().getDispatched().increment();	
0:             node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
author:James Strachan
-------------------------------------------------------------------------------
commit:9d671b7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:     public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
0:         // not supported for topics
1:         return null;
0:     }
0: 
commit:171e322
/////////////////////////////////////////////////////////////////////////
0:                             MessageReference[] oldMessages = messageEvictionStrategy.evictMessages(matched);
0:                             int messagesToEvict = oldMessages.length;
0:                             for(int i = 0; i < messagesToEvict; i++) {
0:                             	oldMessages[i].decrementReferenceCount();
0:                                 discarded++;
0:                                 if (log.isDebugEnabled()) {
0:                                     log.debug("Discarding message " + oldMessages[i]);
0:                                 }
0: 							}
0:                             
0:                             // lets avoid an infinite loop if we are given a bad eviction strategy
1:                             // for a bad strategy lets just not evict
0:                             if (messagesToEvict == 0) {
0:                                 log.warn("No messages to evict returned from eviction strategy: " + messageEvictionStrategy);
0:                                 break;
commit:cc6fec6
/////////////////////////////////////////////////////////////////////////
0:                     if (maximumPendingMessages > 0) {
0:                         
0:                         // calculate the high water mark from which point we will eagerly evict expired messages
0:                         int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();
0:                         if (maximumPendingMessages > 0 && maximumPendingMessages < max) {
0:                             max = maximumPendingMessages;
0:                         }
0:                         if (!matched.isEmpty() && matched.size() > max) {
0:                             removeExpiredMessages(matched);
0:                         }
0: 
0:                         while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {
0:                             MessageReference oldMessage = messageEvictionStrategy.evictMessage(matched);
0:                             if (log.isDebugEnabled()) {
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Discard any expired messages from the matched list. Called from a synchronized block.
0:      * @throws IOException 
0:      */
0:     protected void removeExpiredMessages(LinkedList messages) throws IOException {
0:         for(Iterator i=matched.iterator();i.hasNext();){
0:             MessageReference node=(MessageReference) i.next();
0:             if (node.isExpired()) {
0:                 i.remove();
0:                 dispatched.incrementAndGet();
0:                 node.decrementReferenceCount();
0:                 break;
0:             }
0:         }
0:     }
0: 
commit:062dc56
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.MessageEvictionStrategy;
1: import org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy;
/////////////////////////////////////////////////////////////////////////
0:     private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();
0:     private int discarded = 0;
/////////////////////////////////////////////////////////////////////////
0:                             MessageReference oldMessage=messageEvictionStrategy.evictMessage(matched);
0:                             discarded++;
/////////////////////////////////////////////////////////////////////////
0:         return matched()-dispatched();
/////////////////////////////////////////////////////////////////////////
1:      * @return the number of messages discarded due to being a slow consumer
0:      */
0:     public int discarded() {
0:         synchronized(matchedListMutex) {
1:             return discarded;
0:         }
0:     }
0: 
1:     /**
0:      * @return the number of matched messages (messages targeted for the subscription but not
0:      * yet able to be dispatched due to the prefetch buffer being full).
0:      */
0:     public int matched() {
0:         synchronized(matchedListMutex) {
1:             return matched.size();
0:         }
0:     }
0: 
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:         return messageEvictionStrategy;
0:     }
0: 
0:     /**
0:      * Sets the eviction strategy used to decide which message to evict when the slow consumer
0:      * needs to discard messages
0:      */
0:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
0:         this.messageEvictionStrategy = messageEvictionStrategy;
0:     }
0: 
0:     
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
0: 
/////////////////////////////////////////////////////////////////////////
0:                         +", dispatched="+dispatched()+", delivered="+delivered()+", matched="+matched()+", discarded="+discarded();
commit:95d0dec
/////////////////////////////////////////////////////////////////////////
0:     private int maximumPendingMessages = -1;
/////////////////////////////////////////////////////////////////////////
0:             if (maximumPendingMessages != 0) {
0:                 synchronized (matched) {
0:                     matched.addLast(node);
0: 
0:                     // NOTE - be careful about the slaveBroker!
0:                     if (maximumPendingMessages > 0) {
1:                         // lets discard old messages as we are a slow consumer
0:                         while (matched.size() > maximumPendingMessages) {
0:                             MessageReference oldMessage = (MessageReference) matched.removeFirst();
0:                             oldMessage.decrementReferenceCount();
0:                         }
commit:d8c0862
/////////////////////////////////////////////////////////////////////////
0:             // if maximumPendingMessages is set we will only discard messages which
0:             // have not been dispatched (i.e. we allow the prefetch buffer to be filled)
0:                 
0:                 // NOTE - be careful about the slaveBroker!
commit:0d5de13
/////////////////////////////////////////////////////////////////////////
0:     private int maximumPendingMessages = 0;
/////////////////////////////////////////////////////////////////////////
0:         if( !isFull() && !isSlaveBroker()) {
0:             // TODO - if we have already dispatched too many messages to this slow consumer
0:             // should we avoid dispatching and just discard old messages as shown below
0:             synchronized (matched) {
0:                 matched.addLast(node);
0:                 if (maximumPendingMessages > 0) {
0:                     // lets discard old messages as we are a slow consumer
0:                     while (matched.size() > maximumPendingMessages) {
0:                         MessageReference oldMessage = (MessageReference) matched.removeFirst();
0:                         oldMessage.decrementReferenceCount();
0:                     }
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     public int getMaximumPendingMessages() {
1:         return maximumPendingMessages;
0:     }
0: 
0:     /**
0:      * Sets the maximum number of pending messages that can be matched against this consumer
0:      * before old messages are discarded.
0:      */
0:     public void setMaximumPendingMessages(int maximumPendingMessages) {
0:         this.maximumPendingMessages = maximumPendingMessages;
0:     }
0: 
============================================================================