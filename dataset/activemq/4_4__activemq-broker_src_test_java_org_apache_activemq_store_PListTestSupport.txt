1:32e63dc: /**
1:32e63dc:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:32e63dc:  * contributor license agreements.  See the NOTICE file distributed with
1:32e63dc:  * this work for additional information regarding copyright ownership.
1:32e63dc:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:32e63dc:  * (the "License"); you may not use this file except in compliance with
1:32e63dc:  * the License.  You may obtain a copy of the License at
1:32e63dc:  *
1:32e63dc:  *      http://www.apache.org/licenses/LICENSE-2.0
1:32e63dc:  *
1:32e63dc:  * Unless required by applicable law or agreed to in writing, software
1:32e63dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:32e63dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:32e63dc:  * See the License for the specific language governing permissions and
1:32e63dc:  * limitations under the License.
1:32e63dc:  */
1:32e63dc: package org.apache.activemq.store;
2:32e63dc: 
1:32e63dc: import static org.junit.Assert.assertEquals;
1:32e63dc: import static org.junit.Assert.assertFalse;
1:32e63dc: import static org.junit.Assert.assertTrue;
1:32e63dc: 
1:32e63dc: import java.io.File;
1:32e63dc: import java.io.IOException;
1:9ef4259: import java.util.HashMap;
1:9ef4259: import java.util.Iterator;
1:9ef4259: import java.util.LinkedHashMap;
1:9ef4259: import java.util.LinkedList;
1:9ef4259: import java.util.Map;
1:9ef4259: import java.util.Vector;
1:32e63dc: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:32e63dc: import java.util.concurrent.ExecutorService;
1:32e63dc: import java.util.concurrent.Executors;
1:32e63dc: import java.util.concurrent.TimeUnit;
1:32e63dc: 
1:32e63dc: import org.apache.activemq.util.ByteSequence;
1:9ef4259: import org.apache.activemq.util.IOHelper;
1:32e63dc: import org.junit.After;
1:32e63dc: import org.junit.Before;
1:32e63dc: import org.junit.Ignore;
1:a82c95c: import org.junit.Rule;
1:32e63dc: import org.junit.Test;
1:a82c95c: import org.junit.rules.TemporaryFolder;
1:32e63dc: import org.slf4j.Logger;
1:32e63dc: import org.slf4j.LoggerFactory;
1:32e63dc: 
1:32e63dc: public abstract class PListTestSupport {
1:32e63dc:     static final Logger LOG = LoggerFactory.getLogger(PListTestSupport.class);
1:5a87481:     protected PListStore store;
1:32e63dc:     private PList plist;
1:32e63dc:     final ByteSequence payload = new ByteSequence(new byte[400]);
1:32e63dc:     final String idSeed = new String("Seed" + new byte[1024]);
1:32e63dc:     final Vector<Throwable> exceptions = new Vector<Throwable>();
1:32e63dc:     ExecutorService executor;
1:32e63dc: 
1:a82c95c:     @Rule
1:a82c95c:     public TemporaryFolder tempFolder = new TemporaryFolder();
1:a82c95c: 
1:32e63dc:     @Test
1:32e63dc:     public void testAddLast() throws Exception {
1:32e63dc:         final int COUNT = 1000;
1:32e63dc:         LinkedList<ByteSequence> list = new LinkedList<ByteSequence>();
1:32e63dc:         for (int i = 0; i < COUNT; i++) {
1:32e63dc:             String test = new String("test" + i);
1:32e63dc:             ByteSequence bs = new ByteSequence(test.getBytes());
1:32e63dc:             list.addLast(bs);
1:32e63dc:             plist.addLast(test, bs);
1:32e63dc:         }
1:32e63dc:         assertEquals(plist.size(), COUNT);
1:32e63dc: 
1:32e63dc:         PList.PListIterator actual = plist.iterator();
1:32e63dc:         Iterator<ByteSequence> expected = list.iterator();
1:32e63dc:         while (expected.hasNext()) {
1:32e63dc:             ByteSequence bs = expected.next();
1:32e63dc:             assertTrue(actual.hasNext());
1:32e63dc:             PListEntry entry = actual.next();
1:32e63dc:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:32e63dc:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
1:32e63dc:                     entry.getByteSequence().getLength());
1:32e63dc:             assertEquals(origStr, plistString);
1:32e63dc:         }
1:32e63dc:         assertFalse(actual.hasNext());
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:    @Test
1:32e63dc:     public void testAddFirst() throws Exception {
1:32e63dc:        final int COUNT = 1000;
1:32e63dc:        LinkedList<ByteSequence> list = new LinkedList<ByteSequence>();
1:32e63dc:        for (int i = 0; i < COUNT; i++) {
1:32e63dc:            String test = new String("test" + i);
1:32e63dc:            ByteSequence bs = new ByteSequence(test.getBytes());
1:32e63dc:            list.addFirst(bs);
1:32e63dc:            plist.addFirst(test, bs);
1:32e63dc:        }
1:32e63dc:        assertEquals(plist.size(), COUNT);
1:32e63dc: 
1:32e63dc:        PList.PListIterator actual = plist.iterator();
1:32e63dc:        Iterator<ByteSequence> expected = list.iterator();
1:32e63dc:        while (expected.hasNext()) {
1:32e63dc:            ByteSequence bs = expected.next();
1:32e63dc:            assertTrue(actual.hasNext());
1:32e63dc:            PListEntry entry = actual.next();
1:32e63dc:            String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:32e63dc:            String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
1:32e63dc:                    entry.getByteSequence().getLength());
1:32e63dc:            assertEquals(origStr, plistString);
1:32e63dc:        }
1:32e63dc:        assertFalse(actual.hasNext());
1:32e63dc:    }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRemove() throws IOException {
1:32e63dc:         doTestRemove(2000);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     private PListEntry getFirst(PList plist) throws IOException {
1:32e63dc:         PList.PListIterator iterator = plist.iterator();
1:32e63dc:         try {
1:32e63dc:             if( iterator.hasNext() ) {
1:32e63dc:                 return iterator.next();
1:32e63dc:             } else {
1:32e63dc:                 return null;
1:32e63dc:             }
1:32e63dc:         }finally {
1:32e63dc:             iterator.release();
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     protected void doTestRemove(final int COUNT) throws IOException {
1:32e63dc:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:32e63dc:         for (int i = 0; i < COUNT; i++) {
1:32e63dc:             String test = new String("test" + i);
1:32e63dc:             ByteSequence bs = new ByteSequence(test.getBytes());
1:32e63dc:             map.put(test, bs);
1:32e63dc:             plist.addLast(test, bs);
1:32e63dc:         }
1:32e63dc:         assertEquals(plist.size(), COUNT);
1:32e63dc:         PListEntry entry = getFirst(plist);
1:32e63dc:         while (entry != null) {
1:32e63dc:             plist.remove(entry.getLocator());
1:32e63dc:             entry = getFirst(plist);
1:32e63dc:         }
1:32e63dc:         assertEquals(0,plist.size());
1:32e63dc: 
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testDestroy() throws Exception {
1:32e63dc:         doTestRemove(1);
1:32e63dc:         plist.destroy();
1:32e63dc:         assertEquals(0,plist.size());
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testDestroyNonEmpty() throws Exception {
1:32e63dc:         final int COUNT = 1000;
1:32e63dc:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:32e63dc:         for (int i = 0; i < COUNT; i++) {
1:32e63dc:             String test = new String("test" + i);
1:32e63dc:             ByteSequence bs = new ByteSequence(test.getBytes());
1:32e63dc:             map.put(test, bs);
1:32e63dc:             plist.addLast(test, bs);
1:32e63dc:         }
1:32e63dc:         plist.destroy();
1:32e63dc:         assertEquals(0,plist.size());
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRemoveSecond() throws Exception {
1:32e63dc:         Object first = plist.addLast("First", new ByteSequence("A".getBytes()));
1:32e63dc:         Object second = plist.addLast("Second", new ByteSequence("B".getBytes()));
1:32e63dc: 
1:32e63dc:         assertTrue(plist.remove(second));
1:32e63dc:         assertTrue(plist.remove(first));
1:32e63dc:         assertFalse(plist.remove(first));
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRemoveSingleEntry() throws Exception {
1:32e63dc:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:32e63dc: 
1:32e63dc:         Iterator<PListEntry> iterator = plist.iterator();
1:32e63dc:         while (iterator.hasNext()) {
1:32e63dc:             iterator.next();
1:32e63dc:             iterator.remove();
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRemoveSecondPosition() throws Exception {
1:32e63dc:         Object first = plist.addLast("First", new ByteSequence("A".getBytes()));
1:32e63dc:         Object second = plist.addLast("Second", new ByteSequence("B".getBytes()));
1:32e63dc: 
1:32e63dc:         assertTrue(plist.remove(second));
1:32e63dc:         assertTrue(plist.remove(first));
1:32e63dc:         assertFalse(plist.remove(first));
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testConcurrentAddRemove() throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
2:32e63dc:         IOHelper.mkdirs(directory);
2:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createConcurrentAddRemovePListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc:         final ByteSequence payload = new ByteSequence(new byte[1024*2]);
1:32e63dc: 
1:32e63dc: 
1:32e63dc:         final Vector<Throwable> exceptions = new Vector<Throwable>();
1:32e63dc:         final int iterations = 1000;
1:32e63dc:         final int numLists = 10;
1:32e63dc: 
1:32e63dc:         final PList[] lists = new PList[numLists];
1:32e63dc:         String threadName = Thread.currentThread().getName();
1:32e63dc:         for (int i=0; i<numLists; i++) {
1:32e63dc:             Thread.currentThread().setName("C:"+String.valueOf(i));
1:32e63dc:             lists[i] = store.getPList(String.valueOf(i));
1:32e63dc:         }
1:32e63dc:         Thread.currentThread().setName(threadName);
1:32e63dc: 
1:32e63dc:         executor = Executors.newFixedThreadPool(100);
1:32e63dc:         class A implements Runnable {
1:32e63dc:             @Override
1:32e63dc:             public void run() {
1:32e63dc:                 final String threadName = Thread.currentThread().getName();
1:32e63dc:                 try {
1:32e63dc:                     for (int i=0; i<iterations; i++) {
1:32e63dc:                         PList candidate = lists[i%numLists];
1:32e63dc:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
1:32e63dc:                         synchronized (plistLocks(candidate)) {
1:32e63dc:                             Object last = candidate.addLast(String.valueOf(i), payload);
1:32e63dc:                             getFirst(candidate);
1:b933496:                             assertTrue(candidate.remove(last));
1:32e63dc:                         }
1:32e63dc:                     }
1:32e63dc:                 } catch (Exception error) {
1:32e63dc:                     LOG.error("Unexpcted ex", error);
1:32e63dc:                     error.printStackTrace();
1:32e63dc:                     exceptions.add(error);
1:32e63dc:                 }  finally {
1:32e63dc:                     Thread.currentThread().setName(threadName);
1:32e63dc:                 }
1:32e63dc:             }
1:32e63dc:         };
1:32e63dc: 
1:32e63dc:         class B implements  Runnable {
1:32e63dc:             @Override
1:32e63dc:             public void run() {
1:32e63dc:                 final String threadName = Thread.currentThread().getName();
1:32e63dc:                 try {
1:32e63dc:                     for (int i=0; i<iterations; i++) {
1:32e63dc:                         PList candidate = lists[i%numLists];
1:32e63dc:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
1:32e63dc:                          synchronized (plistLocks(candidate)) {
1:32e63dc:                              Object last = candidate.addLast(String.valueOf(i), payload);
1:32e63dc:                              getFirst(candidate);
2:32e63dc:                              assertTrue(candidate.remove(last));
1:32e63dc:                          }
1:32e63dc:                     }
1:32e63dc:                 } catch (Exception error) {
1:32e63dc:                     error.printStackTrace();
1:32e63dc:                     exceptions.add(error);
1:32e63dc:                 }  finally {
1:32e63dc:                     Thread.currentThread().setName(threadName);
1:32e63dc:                 }
1:32e63dc:             }
1:32e63dc:         };
1:32e63dc: 
1:32e63dc:         executor.execute(new A());
1:32e63dc:         executor.execute(new A());
1:32e63dc:         executor.execute(new A());
1:32e63dc:         executor.execute(new B());
1:32e63dc:         executor.execute(new B());
1:32e63dc:         executor.execute(new B());
1:32e63dc: 
1:32e63dc:         executor.shutdown();
1:2c3046b:         boolean finishedInTime = executor.awaitTermination(5, TimeUnit.MINUTES);
1:2c3046b:         LOG.info("Tested completion finished in time? -> {}", finishedInTime ? "YES" : "NO");
1:32e63dc: 
1:32e63dc:         assertTrue("no exceptions", exceptions.isEmpty());
1:32e63dc:         assertTrue("finished ok", finishedInTime);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     protected abstract PListStore createConcurrentAddRemovePListStore();
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testConcurrentAddLast() throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
1:32e63dc:         IOHelper.mkdirs(directory);
1:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createPListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc: 
1:32e63dc:         final int numThreads = 20;
1:32e63dc:         final int iterations = 1000;
1:32e63dc:         executor = Executors.newFixedThreadPool(100);
1:32e63dc:         for (int i=0; i<numThreads; i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         for (int i=0; i<numThreads; i++) {
1:32e63dc:             executor.execute(new Job(i, PListTestSupport.TaskType.ITERATE, iterations));
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         for (int i=0; i<100; i++) {
1:32e63dc:             executor.execute(new Job(i+20, PListTestSupport.TaskType.ADD, 100));
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         executor.shutdown();
1:32e63dc:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:32e63dc:         assertTrue("finished ok", finishedInTime);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testOverFlow() throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
1:32e63dc:         IOHelper.mkdirs(directory);
1:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createPListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc:         for (int i=0;i<2000; i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.ADD, 5).run();
1:32e63dc: 
1:32e63dc:         }
1:32e63dc: //        LOG.info("After Load index file: " + store.pageFile.getFile().length());
1:32e63dc: //        LOG.info("After remove index file: " + store.pageFile.getFile().length());
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testConcurrentAddRemoveWithPreload() throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
1:32e63dc:         IOHelper.mkdirs(directory);
1:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createConcurrentAddRemoveWithPreloadPListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc:         final int iterations = 500;
1:32e63dc:         final int numLists = 10;
1:32e63dc: 
1:32e63dc:         // prime the store
1:32e63dc: 
1:32e63dc:         // create/delete
1:32e63dc:         LOG.info("create");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("delete");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("fill");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:32e63dc:         }
1:32e63dc:         LOG.info("remove");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.REMOVE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("check empty");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             assertEquals("empty " + i, 0, store.getPList("List-" + i).size());
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("delete again");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("fill again");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("parallel add and remove");
1:32e63dc:         executor = Executors.newFixedThreadPool(numLists*2);
1:32e63dc:         for (int i=0; i<numLists*2; i++) {
1:32e63dc:             executor.execute(new Job(i, i>=numLists ? PListTestSupport.TaskType.ADD : PListTestSupport.TaskType.REMOVE, iterations));
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         executor.shutdown();
1:32e63dc:         LOG.info("wait for parallel work to complete");
1:32e63dc:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:32e63dc:         assertTrue("no exceptions", exceptions.isEmpty());
1:32e63dc:         assertTrue("finished ok", finishedInTime);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     protected abstract PListStore createConcurrentAddRemoveWithPreloadPListStore();
1:32e63dc: 
1:32e63dc:     // for non determinant issues, increasing this may help diagnose
1:32e63dc:     final int numRepeats = 1;
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRepeatStressWithCache() throws Exception {
1:32e63dc:         for (int i=0; i<numRepeats;i++) {
1:32e63dc:             do_testConcurrentAddIterateRemove(true);
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Test
1:32e63dc:     public void testRepeatStressWithOutCache() throws Exception {
1:32e63dc:         for (int i=0; i<numRepeats;i++) {
1:32e63dc:             do_testConcurrentAddIterateRemove(false);
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     public void do_testConcurrentAddIterateRemove(boolean enablePageCache) throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
1:32e63dc:         IOHelper.mkdirs(directory);
1:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createConcurrentAddIterateRemovePListStore(enablePageCache);
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc:         final int iterations = 500;
1:32e63dc:         final int numLists = 10;
1:32e63dc: 
1:32e63dc:         LOG.info("create");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("fill");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("parallel add and remove");
1:32e63dc:         executor = Executors.newFixedThreadPool(400);
1:32e63dc:         final int numProducer = 5;
1:32e63dc:         final int numConsumer = 10;
1:32e63dc:         for (int i=0; i<numLists; i++) {
1:32e63dc:             for (int j=0; j<numProducer; j++) {
1:32e63dc:                 executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations*2));
1:32e63dc:             }
1:32e63dc:             for (int k=0;k<numConsumer; k++) {
1:32e63dc:                 executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations/4));
1:32e63dc:             }
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:          for (int i=numLists; i<numLists*10; i++) {
1:32e63dc:             executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));
1:32e63dc:          }
1:32e63dc: 
1:32e63dc:         executor.shutdown();
1:32e63dc:         LOG.info("wait for parallel work to complete");
1:32e63dc:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:32e63dc:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:32e63dc:         assertTrue("test did not  timeout ", shutdown);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     protected abstract PListStore createConcurrentAddIterateRemovePListStore(boolean enablePageCache);
1:32e63dc: 
1:32e63dc:     @Ignore("Takes too long.. might have broken it.")
1:32e63dc:     @Test
1:32e63dc:     public void testConcurrentAddIterate() throws Exception {
1:32e63dc:         File directory = store.getDirectory();
1:32e63dc:         store.stop();
1:32e63dc:         IOHelper.mkdirs(directory);
1:32e63dc:         IOHelper.deleteChildren(directory);
1:32e63dc:         store = createConcurrentAddIteratePListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc: 
1:32e63dc:         final int iterations = 250;
1:32e63dc:         final int numLists = 10;
1:32e63dc: 
1:32e63dc:         LOG.info("create");
1:32e63dc:         for (int i=0; i<numLists;i++) {
1:32e63dc:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         LOG.info("parallel add and iterate");
1:32e63dc:         // We want a lot of adds occurring so that new free pages get created along
1:32e63dc:         // with overlapping seeks from the iterators so that we are likely to seek into
1:32e63dc:         // some bad area in the page file.
1:32e63dc:         executor = Executors.newFixedThreadPool(400);
1:32e63dc:         final int numProducer = 300;
1:32e63dc:         final int numConsumer = 100;
1:32e63dc:         for (int i=0; i<numLists; i++) {
1:32e63dc:             for (int j=0; j<numProducer; j++) {
1:32e63dc:                 executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));
1:32e63dc:             }
1:32e63dc:             for (int k=0;k<numConsumer; k++) {
1:32e63dc:                 executor.execute(new Job(i, TaskType.ITERATE, iterations*2));
1:32e63dc:             }
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         executor.shutdown();
1:32e63dc:         LOG.info("wait for parallel work to complete");
1:32e63dc:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:32e63dc:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:32e63dc:         assertTrue("test did not  timeout ", shutdown);
1:32e63dc: //        LOG.info("Num dataFiles:" + store.getJournal().getFiles().size());
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     abstract protected PListStore createConcurrentAddIteratePListStore();
1:32e63dc: 
1:32e63dc:     enum TaskType {CREATE, DELETE, ADD, REMOVE, ITERATE, ITERATE_REMOVE}
1:9ef4259:     ConcurrentMap<String, Object> entries = new ConcurrentHashMap<String, Object>();
1:32e63dc: 
1:32e63dc:     class Job implements Runnable {
1:32e63dc: 
1:32e63dc:         int id;
1:32e63dc:         TaskType task;
1:32e63dc:         int iterations;
1:32e63dc: 
1:32e63dc:         public Job(int id, TaskType t, int iterations) {
1:32e63dc:             this.id = id;
1:32e63dc:             this.task = t;
1:32e63dc:             this.iterations = iterations;
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         @Override
1:32e63dc:         public void run() {
1:32e63dc:             final String threadName = Thread.currentThread().getName();
1:32e63dc:             try {
1:32e63dc:                 PList plist = null;
1:32e63dc:                 switch (task) {
1:32e63dc:                     case CREATE:
1:32e63dc:                         Thread.currentThread().setName("C:"+id);
1:32e63dc:                         plist = store.getPList(String.valueOf(id));
1:32e63dc:                         LOG.info("Job-" + id + ", CREATE");
1:32e63dc:                         break;
1:32e63dc:                     case DELETE:
1:32e63dc:                         Thread.currentThread().setName("D:"+id);
1:32e63dc:                         store.removePList(String.valueOf(id));
1:32e63dc:                         break;
1:32e63dc:                     case ADD:
1:32e63dc:                         Thread.currentThread().setName("A:"+id);
1:32e63dc:                         plist = store.getPList(String.valueOf(id));
1:32e63dc: 
1:32e63dc:                         for (int j = 0; j < iterations; j++) {
1:32e63dc:                             synchronized (plistLocks(plist)) {
1:32e63dc:                                 if (exceptions.isEmpty()) {
1:32e63dc:                                     String key = "PL>" + id + idSeed + "-" + j;
1:32e63dc:                                     entries.put(key, plist.addLast(key, payload));
1:32e63dc:                                 } else {
1:32e63dc:                                     break;
1:32e63dc:                                 }
1:32e63dc:                             }
1:32e63dc:                         }
1:32e63dc: 
1:32e63dc:                         if (exceptions.isEmpty()) {
1:32e63dc:                             LOG.info("Job-" + id + ", Add, done: " + iterations);
1:32e63dc:                         }
1:32e63dc:                         break;
1:32e63dc:                     case REMOVE:
1:32e63dc:                         Thread.currentThread().setName("R:"+id);
1:32e63dc:                         plist = store.getPList(String.valueOf(id));
1:32e63dc:                         synchronized (plistLocks(plist)) {
1:32e63dc: 
1:32e63dc:                             for (int j = iterations -1; j >= 0; j--) {
1:32e63dc:                                 String key = "PL>" + id + idSeed + "-" + j;
1:32e63dc:                                 Object position = entries.remove(key);
1:32e63dc:                                 if( position!=null ) {
1:32e63dc:                                     plist.remove(position);
1:32e63dc:                                 }
1:32e63dc:                                 if (j > 0 && j % (iterations / 2) == 0) {
1:32e63dc:                                     LOG.info("Job-" + id + " Done remove: " + j);
1:32e63dc:                                 }
1:32e63dc:                             }
1:32e63dc:                         }
1:32e63dc:                         break;
1:32e63dc:                     case ITERATE:
1:32e63dc:                         Thread.currentThread().setName("I:"+id);
1:32e63dc:                         plist = store.getPList(String.valueOf(id));
1:32e63dc:                         int iterateCount = 0;
1:32e63dc:                         synchronized (plistLocks(plist)) {
1:32e63dc:                             if (exceptions.isEmpty()) {
1:32e63dc:                                 Iterator<PListEntry> iterator = plist.iterator();
1:32e63dc:                                 while (iterator.hasNext() && exceptions.isEmpty()) {
1:32e63dc:                                     iterator.next();
1:32e63dc:                                     iterateCount++;
1:32e63dc:                                 }
1:32e63dc: 
1:32e63dc:                                 //LOG.info("Job-" + id + " Done iterate: it=" + iterator + ", count:" + iterateCount + ", size:" + plist.size());
1:32e63dc:                                 if (plist.size() != iterateCount) {
1:32e63dc:                                     System.err.println("Count Wrong: " + iterator);
1:32e63dc:                                 }
1:32e63dc:                                 assertEquals("iterate got all " + id + " iterator:" + iterator , plist.size(), iterateCount);
1:32e63dc:                             }
1:32e63dc:                         }
1:32e63dc:                         break;
1:32e63dc: 
1:32e63dc:                     case ITERATE_REMOVE:
1:32e63dc:                         Thread.currentThread().setName("IRM:"+id);
1:32e63dc:                         plist = store.getPList(String.valueOf(id));
1:32e63dc: 
1:32e63dc:                         int removeCount = 0;
1:32e63dc:                         synchronized (plistLocks(plist)) {
1:32e63dc: 
1:32e63dc:                             Iterator<PListEntry> removeIterator = plist.iterator();
1:32e63dc: 
1:32e63dc:                             while (removeIterator.hasNext()) {
1:32e63dc:                                 removeIterator.next();
1:32e63dc:                                 removeIterator.remove();
1:32e63dc:                                 if (removeCount++ > iterations) {
1:32e63dc:                                     break;
1:32e63dc:                                 }
1:32e63dc:                             }
1:32e63dc:                         }
1:32e63dc:                         LOG.info("Job-" + id + " Done remove: " + removeCount);
1:32e63dc:                         break;
1:32e63dc: 
1:32e63dc:                     default:
1:32e63dc:                 }
1:32e63dc: 
1:32e63dc:             } catch (Exception e) {
1:32e63dc:                 LOG.warn("Job["+id+"] caught exception: " + e.getMessage());
1:32e63dc:                 e.printStackTrace();
1:32e63dc:                 exceptions.add(e);
1:32e63dc:                 if (executor != null) {
1:32e63dc:                     executor.shutdownNow();
1:32e63dc:                 }
1:32e63dc:             } finally {
1:32e63dc:                 Thread.currentThread().setName(threadName);
1:32e63dc:             }
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     Map<PList, Object> locks = new HashMap<PList, Object>();
1:32e63dc:     private Object plistLocks(PList plist) {
1:32e63dc:         Object lock = null;
1:32e63dc:         synchronized (locks) {
1:32e63dc:             if (locks.containsKey(plist)) {
1:32e63dc:                 lock = locks.get(plist);
1:32e63dc:              } else {
1:32e63dc:                 lock = new Object();
1:32e63dc:                 locks.put(plist, lock);
1:32e63dc:             }
1:32e63dc:         }
1:32e63dc:         return lock;
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     @Before
1:32e63dc:     public void setUp() throws Exception {
1:a82c95c:         File directory = tempFolder.newFolder();
1:32e63dc:         startStore(directory);
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     protected void startStore(File directory) throws Exception {
1:32e63dc:         store = createPListStore();
1:32e63dc:         store.setDirectory(directory);
1:32e63dc:         store.start();
1:32e63dc:         plist = store.getPList("main");
1:32e63dc:     }
1:32e63dc: 
1:32e63dc:     abstract protected PListStore createPListStore();
1:32e63dc: 
1:32e63dc:     @After
1:32e63dc:     public void tearDown() throws Exception {
1:32e63dc:         if (executor != null) {
1:32e63dc:             executor.shutdownNow();
1:32e63dc:         }
1:32e63dc:         store.stop();
1:32e63dc:         exceptions.clear();
1:32e63dc:     }
1:32e63dc: 
1:32e63dc: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:a82c95c
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Rule;
1: import org.junit.rules.TemporaryFolder;
/////////////////////////////////////////////////////////////////////////
1:     @Rule
1:     public TemporaryFolder tempFolder = new TemporaryFolder();
1: 
/////////////////////////////////////////////////////////////////////////
1:         File directory = tempFolder.newFolder();
author:gtully
-------------------------------------------------------------------------------
commit:5a87481
/////////////////////////////////////////////////////////////////////////
1:     protected PListStore store;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:0883011
/////////////////////////////////////////////////////////////////////////
0:         File directory = new File("target/test/PlistDB");
commit:2c3046b
/////////////////////////////////////////////////////////////////////////
1:         boolean finishedInTime = executor.awaitTermination(5, TimeUnit.MINUTES);
1:         LOG.info("Tested completion finished in time? -> {}", finishedInTime ? "YES" : "NO");
/////////////////////////////////////////////////////////////////////////
0:         //File directory = new File("target/test/PlistDB");
0:         File directory = new File("/sandbox/temp/plist");
commit:b933496
/////////////////////////////////////////////////////////////////////////
1:                              assertTrue(candidate.remove(last));
/////////////////////////////////////////////////////////////////////////
0:         boolean finishedInTime = executor.awaitTermination(60, TimeUnit.SECONDS);
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.LinkedList;
1: import java.util.Map;
1: import java.util.Vector;
1: import java.util.concurrent.ConcurrentMap;
1: import org.apache.activemq.util.IOHelper;
/////////////////////////////////////////////////////////////////////////
1:     ConcurrentMap<String, Object> entries = new ConcurrentHashMap<String, Object>();
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.io.File;
1: import java.io.IOException;
0: import java.util.*;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: 
0: import org.apache.activemq.util.IOHelper;
1: import org.apache.activemq.util.ByteSequence;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public abstract class PListTestSupport {
1:     static final Logger LOG = LoggerFactory.getLogger(PListTestSupport.class);
0:     private PListStore store;
1:     private PList plist;
1:     final ByteSequence payload = new ByteSequence(new byte[400]);
1:     final String idSeed = new String("Seed" + new byte[1024]);
1:     final Vector<Throwable> exceptions = new Vector<Throwable>();
1:     ExecutorService executor;
1: 
1:     @Test
1:     public void testAddLast() throws Exception {
1:         final int COUNT = 1000;
1:         LinkedList<ByteSequence> list = new LinkedList<ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             list.addLast(bs);
1:             plist.addLast(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
1: 
1:         PList.PListIterator actual = plist.iterator();
1:         Iterator<ByteSequence> expected = list.iterator();
1:         while (expected.hasNext()) {
1:             ByteSequence bs = expected.next();
1:             assertTrue(actual.hasNext());
1:             PListEntry entry = actual.next();
1:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
1:                     entry.getByteSequence().getLength());
1:             assertEquals(origStr, plistString);
1:         }
1:         assertFalse(actual.hasNext());
1:     }
1: 
1:    @Test
1:     public void testAddFirst() throws Exception {
1:        final int COUNT = 1000;
1:        LinkedList<ByteSequence> list = new LinkedList<ByteSequence>();
1:        for (int i = 0; i < COUNT; i++) {
1:            String test = new String("test" + i);
1:            ByteSequence bs = new ByteSequence(test.getBytes());
1:            list.addFirst(bs);
1:            plist.addFirst(test, bs);
1:        }
1:        assertEquals(plist.size(), COUNT);
1: 
1:        PList.PListIterator actual = plist.iterator();
1:        Iterator<ByteSequence> expected = list.iterator();
1:        while (expected.hasNext()) {
1:            ByteSequence bs = expected.next();
1:            assertTrue(actual.hasNext());
1:            PListEntry entry = actual.next();
1:            String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:            String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
1:                    entry.getByteSequence().getLength());
1:            assertEquals(origStr, plistString);
1:        }
1:        assertFalse(actual.hasNext());
1:    }
1: 
1:     @Test
1:     public void testRemove() throws IOException {
1:         doTestRemove(2000);
1:     }
1: 
1:     private PListEntry getFirst(PList plist) throws IOException {
1:         PList.PListIterator iterator = plist.iterator();
1:         try {
1:             if( iterator.hasNext() ) {
1:                 return iterator.next();
1:             } else {
1:                 return null;
1:             }
1:         }finally {
1:             iterator.release();
1:         }
1:     }
1: 
1:     protected void doTestRemove(final int COUNT) throws IOException {
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
1:         PListEntry entry = getFirst(plist);
1:         while (entry != null) {
1:             plist.remove(entry.getLocator());
1:             entry = getFirst(plist);
1:         }
1:         assertEquals(0,plist.size());
1: 
1:     }
1: 
1:     @Test
1:     public void testDestroy() throws Exception {
1:         doTestRemove(1);
1:         plist.destroy();
1:         assertEquals(0,plist.size());
1:     }
1: 
1:     @Test
1:     public void testDestroyNonEmpty() throws Exception {
1:         final int COUNT = 1000;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         plist.destroy();
1:         assertEquals(0,plist.size());
1:     }
1: 
1:     @Test
1:     public void testRemoveSecond() throws Exception {
1:         Object first = plist.addLast("First", new ByteSequence("A".getBytes()));
1:         Object second = plist.addLast("Second", new ByteSequence("B".getBytes()));
1: 
1:         assertTrue(plist.remove(second));
1:         assertTrue(plist.remove(first));
1:         assertFalse(plist.remove(first));
1:     }
1: 
1:     @Test
1:     public void testRemoveSingleEntry() throws Exception {
1:         plist.addLast("First", new ByteSequence("A".getBytes()));
1: 
1:         Iterator<PListEntry> iterator = plist.iterator();
1:         while (iterator.hasNext()) {
1:             iterator.next();
1:             iterator.remove();
1:         }
1:     }
1: 
1:     @Test
1:     public void testRemoveSecondPosition() throws Exception {
1:         Object first = plist.addLast("First", new ByteSequence("A".getBytes()));
1:         Object second = plist.addLast("Second", new ByteSequence("B".getBytes()));
1: 
1:         assertTrue(plist.remove(second));
1:         assertTrue(plist.remove(first));
1:         assertFalse(plist.remove(first));
1:     }
1: 
1:     @Test
1:     public void testConcurrentAddRemove() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createConcurrentAddRemovePListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
1:         final ByteSequence payload = new ByteSequence(new byte[1024*2]);
1: 
1: 
1:         final Vector<Throwable> exceptions = new Vector<Throwable>();
1:         final int iterations = 1000;
1:         final int numLists = 10;
1: 
1:         final PList[] lists = new PList[numLists];
1:         String threadName = Thread.currentThread().getName();
1:         for (int i=0; i<numLists; i++) {
1:             Thread.currentThread().setName("C:"+String.valueOf(i));
1:             lists[i] = store.getPList(String.valueOf(i));
1:         }
1:         Thread.currentThread().setName(threadName);
1: 
1:         executor = Executors.newFixedThreadPool(100);
1:         class A implements Runnable {
1:             @Override
1:             public void run() {
1:                 final String threadName = Thread.currentThread().getName();
1:                 try {
1:                     for (int i=0; i<iterations; i++) {
1:                         PList candidate = lists[i%numLists];
1:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
1:                         synchronized (plistLocks(candidate)) {
1:                             Object last = candidate.addLast(String.valueOf(i), payload);
1:                             getFirst(candidate);
1:                             assertTrue(candidate.remove(last));
1:                         }
1:                     }
1:                 } catch (Exception error) {
1:                     LOG.error("Unexpcted ex", error);
1:                     error.printStackTrace();
1:                     exceptions.add(error);
1:                 }  finally {
1:                     Thread.currentThread().setName(threadName);
1:                 }
1:             }
1:         };
1: 
1:         class B implements  Runnable {
1:             @Override
1:             public void run() {
1:                 final String threadName = Thread.currentThread().getName();
1:                 try {
1:                     for (int i=0; i<iterations; i++) {
1:                         PList candidate = lists[i%numLists];
1:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
1:                          synchronized (plistLocks(candidate)) {
1:                              Object last = candidate.addLast(String.valueOf(i), payload);
1:                              getFirst(candidate);
1:                             assertTrue(candidate.remove(last));
1:                          }
1:                     }
1:                 } catch (Exception error) {
1:                     error.printStackTrace();
1:                     exceptions.add(error);
1:                 }  finally {
1:                     Thread.currentThread().setName(threadName);
1:                 }
1:             }
1:         };
1: 
1:         executor.execute(new A());
1:         executor.execute(new A());
1:         executor.execute(new A());
1:         executor.execute(new B());
1:         executor.execute(new B());
1:         executor.execute(new B());
1: 
1:         executor.shutdown();
0:         boolean finishedInTime = executor.awaitTermination(30, TimeUnit.SECONDS);
1: 
1:         assertTrue("no exceptions", exceptions.isEmpty());
1:         assertTrue("finished ok", finishedInTime);
1:     }
1: 
1:     protected abstract PListStore createConcurrentAddRemovePListStore();
1: 
1:     @Test
1:     public void testConcurrentAddLast() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createPListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
1: 
1:         final int numThreads = 20;
1:         final int iterations = 1000;
1:         executor = Executors.newFixedThreadPool(100);
1:         for (int i=0; i<numThreads; i++) {
1:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:         }
1: 
1:         for (int i=0; i<numThreads; i++) {
1:             executor.execute(new Job(i, PListTestSupport.TaskType.ITERATE, iterations));
1:         }
1: 
1:         for (int i=0; i<100; i++) {
1:             executor.execute(new Job(i+20, PListTestSupport.TaskType.ADD, 100));
1:         }
1: 
1:         executor.shutdown();
1:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:         assertTrue("finished ok", finishedInTime);
1:     }
1: 
1:     @Test
1:     public void testOverFlow() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createPListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
1:         for (int i=0;i<2000; i++) {
1:             new Job(i, PListTestSupport.TaskType.ADD, 5).run();
1: 
1:         }
1: //        LOG.info("After Load index file: " + store.pageFile.getFile().length());
1: //        LOG.info("After remove index file: " + store.pageFile.getFile().length());
1:     }
1: 
1:     @Test
1:     public void testConcurrentAddRemoveWithPreload() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createConcurrentAddRemoveWithPreloadPListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
1:         final int iterations = 500;
1:         final int numLists = 10;
1: 
1:         // prime the store
1: 
1:         // create/delete
1:         LOG.info("create");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:         }
1: 
1:         LOG.info("delete");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();
1:         }
1: 
1:         LOG.info("fill");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:         }
1:         LOG.info("remove");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.REMOVE, iterations).run();
1:         }
1: 
1:         LOG.info("check empty");
1:         for (int i=0; i<numLists;i++) {
1:             assertEquals("empty " + i, 0, store.getPList("List-" + i).size());
1:         }
1: 
1:         LOG.info("delete again");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();
1:         }
1: 
1:         LOG.info("fill again");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:         }
1: 
1:         LOG.info("parallel add and remove");
1:         executor = Executors.newFixedThreadPool(numLists*2);
1:         for (int i=0; i<numLists*2; i++) {
1:             executor.execute(new Job(i, i>=numLists ? PListTestSupport.TaskType.ADD : PListTestSupport.TaskType.REMOVE, iterations));
1:         }
1: 
1:         executor.shutdown();
1:         LOG.info("wait for parallel work to complete");
1:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:         assertTrue("no exceptions", exceptions.isEmpty());
1:         assertTrue("finished ok", finishedInTime);
1:     }
1: 
1:     protected abstract PListStore createConcurrentAddRemoveWithPreloadPListStore();
1: 
1:     // for non determinant issues, increasing this may help diagnose
1:     final int numRepeats = 1;
1: 
1:     @Test
1:     public void testRepeatStressWithCache() throws Exception {
1:         for (int i=0; i<numRepeats;i++) {
1:             do_testConcurrentAddIterateRemove(true);
1:         }
1:     }
1: 
1:     @Test
1:     public void testRepeatStressWithOutCache() throws Exception {
1:         for (int i=0; i<numRepeats;i++) {
1:             do_testConcurrentAddIterateRemove(false);
1:         }
1:     }
1: 
1:     public void do_testConcurrentAddIterateRemove(boolean enablePageCache) throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createConcurrentAddIterateRemovePListStore(enablePageCache);
1:         store.setDirectory(directory);
1:         store.start();
1: 
1:         final int iterations = 500;
1:         final int numLists = 10;
1: 
1:         LOG.info("create");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:         }
1: 
1:         LOG.info("fill");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.ADD, iterations).run();
1:         }
1: 
1:         LOG.info("parallel add and remove");
1:         executor = Executors.newFixedThreadPool(400);
1:         final int numProducer = 5;
1:         final int numConsumer = 10;
1:         for (int i=0; i<numLists; i++) {
1:             for (int j=0; j<numProducer; j++) {
1:                 executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations*2));
1:             }
1:             for (int k=0;k<numConsumer; k++) {
1:                 executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations/4));
1:             }
1:         }
1: 
1:          for (int i=numLists; i<numLists*10; i++) {
1:             executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));
1:          }
1: 
1:         executor.shutdown();
1:         LOG.info("wait for parallel work to complete");
1:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         assertTrue("test did not  timeout ", shutdown);
1:     }
1: 
1:     protected abstract PListStore createConcurrentAddIterateRemovePListStore(boolean enablePageCache);
1: 
1:     @Ignore("Takes too long.. might have broken it.")
1:     @Test
1:     public void testConcurrentAddIterate() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         store = createConcurrentAddIteratePListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
1:         final int iterations = 250;
1:         final int numLists = 10;
1: 
1:         LOG.info("create");
1:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();
1:         }
1: 
1:         LOG.info("parallel add and iterate");
1:         // We want a lot of adds occurring so that new free pages get created along
1:         // with overlapping seeks from the iterators so that we are likely to seek into
1:         // some bad area in the page file.
1:         executor = Executors.newFixedThreadPool(400);
1:         final int numProducer = 300;
1:         final int numConsumer = 100;
1:         for (int i=0; i<numLists; i++) {
1:             for (int j=0; j<numProducer; j++) {
1:                 executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));
1:             }
1:             for (int k=0;k<numConsumer; k++) {
1:                 executor.execute(new Job(i, TaskType.ITERATE, iterations*2));
1:             }
1:         }
1: 
1:         executor.shutdown();
1:         LOG.info("wait for parallel work to complete");
1:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         assertTrue("test did not  timeout ", shutdown);
1: //        LOG.info("Num dataFiles:" + store.getJournal().getFiles().size());
1:     }
1: 
1:     abstract protected PListStore createConcurrentAddIteratePListStore();
1: 
1:     enum TaskType {CREATE, DELETE, ADD, REMOVE, ITERATE, ITERATE_REMOVE}
0:     ConcurrentHashMap<String, Object> entries = new ConcurrentHashMap<String, Object>();
1: 
1:     class Job implements Runnable {
1: 
1:         int id;
1:         TaskType task;
1:         int iterations;
1: 
1:         public Job(int id, TaskType t, int iterations) {
1:             this.id = id;
1:             this.task = t;
1:             this.iterations = iterations;
1:         }
1: 
1:         @Override
1:         public void run() {
1:             final String threadName = Thread.currentThread().getName();
1:             try {
1:                 PList plist = null;
1:                 switch (task) {
1:                     case CREATE:
1:                         Thread.currentThread().setName("C:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         LOG.info("Job-" + id + ", CREATE");
1:                         break;
1:                     case DELETE:
1:                         Thread.currentThread().setName("D:"+id);
1:                         store.removePList(String.valueOf(id));
1:                         break;
1:                     case ADD:
1:                         Thread.currentThread().setName("A:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1: 
1:                         for (int j = 0; j < iterations; j++) {
1:                             synchronized (plistLocks(plist)) {
1:                                 if (exceptions.isEmpty()) {
1:                                     String key = "PL>" + id + idSeed + "-" + j;
1:                                     entries.put(key, plist.addLast(key, payload));
1:                                 } else {
1:                                     break;
1:                                 }
1:                             }
1:                         }
1: 
1:                         if (exceptions.isEmpty()) {
1:                             LOG.info("Job-" + id + ", Add, done: " + iterations);
1:                         }
1:                         break;
1:                     case REMOVE:
1:                         Thread.currentThread().setName("R:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         synchronized (plistLocks(plist)) {
1: 
1:                             for (int j = iterations -1; j >= 0; j--) {
1:                                 String key = "PL>" + id + idSeed + "-" + j;
1:                                 Object position = entries.remove(key);
1:                                 if( position!=null ) {
1:                                     plist.remove(position);
1:                                 }
1:                                 if (j > 0 && j % (iterations / 2) == 0) {
1:                                     LOG.info("Job-" + id + " Done remove: " + j);
1:                                 }
1:                             }
1:                         }
1:                         break;
1:                     case ITERATE:
1:                         Thread.currentThread().setName("I:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         int iterateCount = 0;
1:                         synchronized (plistLocks(plist)) {
1:                             if (exceptions.isEmpty()) {
1:                                 Iterator<PListEntry> iterator = plist.iterator();
1:                                 while (iterator.hasNext() && exceptions.isEmpty()) {
1:                                     iterator.next();
1:                                     iterateCount++;
1:                                 }
1: 
1:                                 //LOG.info("Job-" + id + " Done iterate: it=" + iterator + ", count:" + iterateCount + ", size:" + plist.size());
1:                                 if (plist.size() != iterateCount) {
1:                                     System.err.println("Count Wrong: " + iterator);
1:                                 }
1:                                 assertEquals("iterate got all " + id + " iterator:" + iterator , plist.size(), iterateCount);
1:                             }
1:                         }
1:                         break;
1: 
1:                     case ITERATE_REMOVE:
1:                         Thread.currentThread().setName("IRM:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1: 
1:                         int removeCount = 0;
1:                         synchronized (plistLocks(plist)) {
1: 
1:                             Iterator<PListEntry> removeIterator = plist.iterator();
1: 
1:                             while (removeIterator.hasNext()) {
1:                                 removeIterator.next();
1:                                 removeIterator.remove();
1:                                 if (removeCount++ > iterations) {
1:                                     break;
1:                                 }
1:                             }
1:                         }
1:                         LOG.info("Job-" + id + " Done remove: " + removeCount);
1:                         break;
1: 
1:                     default:
1:                 }
1: 
1:             } catch (Exception e) {
1:                 LOG.warn("Job["+id+"] caught exception: " + e.getMessage());
1:                 e.printStackTrace();
1:                 exceptions.add(e);
1:                 if (executor != null) {
1:                     executor.shutdownNow();
1:                 }
1:             } finally {
1:                 Thread.currentThread().setName(threadName);
1:             }
1:         }
1:     }
1: 
1:     Map<PList, Object> locks = new HashMap<PList, Object>();
1:     private Object plistLocks(PList plist) {
1:         Object lock = null;
1:         synchronized (locks) {
1:             if (locks.containsKey(plist)) {
1:                 lock = locks.get(plist);
1:              } else {
1:                 lock = new Object();
1:                 locks.put(plist, lock);
1:             }
1:         }
1:         return lock;
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
0:         File directory = new File("target/test/PlistDB");
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
1:         startStore(directory);
1: 
1:     }
1: 
1:     protected void startStore(File directory) throws Exception {
1:         store = createPListStore();
1:         store.setDirectory(directory);
1:         store.start();
1:         plist = store.getPList("main");
1:     }
1: 
1:     abstract protected PListStore createPListStore();
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         if (executor != null) {
1:             executor.shutdownNow();
1:         }
1:         store.stop();
1:         exceptions.clear();
1:     }
1: 
1: }
============================================================================