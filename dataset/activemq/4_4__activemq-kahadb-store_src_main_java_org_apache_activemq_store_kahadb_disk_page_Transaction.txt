1:456a2ba: /**
1:456a2ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:456a2ba:  * contributor license agreements.  See the NOTICE file distributed with
1:456a2ba:  * this work for additional information regarding copyright ownership.
1:456a2ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:456a2ba:  * (the "License"); you may not use this file except in compliance with
1:456a2ba:  * the License.  You may obtain a copy of the License at
1:456a2ba:  *
1:456a2ba:  *      http://www.apache.org/licenses/LICENSE-2.0
1:456a2ba:  *
1:456a2ba:  * Unless required by applicable law or agreed to in writing, software
1:456a2ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:456a2ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:456a2ba:  * See the License for the specific language governing permissions and
1:456a2ba:  * limitations under the License.
1:456a2ba:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.page;
1:456a2ba: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile.PageWrite;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.*;
1:1aab71b: import org.apache.activemq.util.ByteSequence;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.DataByteArrayInputStream;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.DataByteArrayOutputStream;
1:1aab71b: import org.apache.activemq.util.IOHelper;
1:456a2ba: 
1:4a7475d: import java.io.*;
1:456a2ba: import java.util.Iterator;
1:456a2ba: import java.util.NoSuchElementException;
1:4a7475d: import java.util.TreeMap;
1:456a2ba: 
1:456a2ba: /**
1:456a2ba:  * The class used to read/update a PageFile object.  Using a transaction allows you to
1:456a2ba:  * do multiple update operations in a single unit of work.
1:456a2ba:  */
1:456a2ba: public class Transaction implements Iterable<Page> {
1:456a2ba: 
1:40ae055:     private RandomAccessFile tmpFile;
1:5bcd417:     private File txFile;
1:d1e7d69:     private long nextLocation = 0;
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * The PageOverflowIOException occurs when a page write is requested
1:456a2ba:      * and it's data is larger than what would fit into a single page.
1:456a2ba:      */
1:456a2ba:     public class PageOverflowIOException extends IOException {
1:cdba931:         private static final long serialVersionUID = 1L;
1:2b10259: 
1:456a2ba:         public PageOverflowIOException(String message) {
1:456a2ba:             super(message);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * The InvalidPageIOException is thrown if try to load/store a a page
1:456a2ba:      * with an invalid page id.
1:456a2ba:      */
1:456a2ba:     public class InvalidPageIOException extends IOException {
1:cdba931:         private static final long serialVersionUID = 1L;
1:cdba931: 
1:456a2ba:         private final long page;
1:456a2ba: 
1:456a2ba:         public InvalidPageIOException(String message, long page) {
1:456a2ba:             super(message);
1:456a2ba:             this.page = page;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public long getPage() {
1:456a2ba:             return page;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.
1:456a2ba:      *
1:456a2ba:      * @param <T> The type of exceptions that operation will throw.
1:456a2ba:      */
1:456a2ba:     public interface Closure <T extends Throwable> {
1:456a2ba:         public void execute(Transaction tx) throws T;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.
1:456a2ba:      *
1:456a2ba:      * @param <R> The type of result that the closure produces.
1:456a2ba:      * @param <T> The type of exceptions that operation will throw.
1:456a2ba:      */
1:456a2ba:     public interface CallableClosure<R, T extends Throwable> {
1:456a2ba:         public R execute(Transaction tx) throws T;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     // The page file that this Transaction operates against.
1:456a2ba:     private final PageFile pageFile;
1:456a2ba:     // If this transaction is updating stuff.. this is the tx of
1:456a2ba:     private long writeTransactionId=-1;
1:456a2ba:     // List of pages that this transaction has modified.
1:40ae055:     private TreeMap<Long, PageWrite> writes=new TreeMap<Long, PageWrite>();
1:456a2ba:     // List of pages allocated in this transaction
1:456a2ba:     private final SequenceSet allocateList = new SequenceSet();
1:456a2ba:     // List of pages freed in this transaction
1:456a2ba:     private final SequenceSet freeList = new SequenceSet();
1:456a2ba: 
1:cdba931:     private long maxTransactionSize = Long.getLong("maxKahaDBTxSize", 10485760L);
1:cdba931: 
1:40ae055:     private long size = 0;
1:2a6a4b2: 
1:456a2ba:     Transaction(PageFile pageFile) {
1:456a2ba:         this.pageFile = pageFile;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @return the page file that created this Transaction
1:456a2ba:      */
1:456a2ba:     public PageFile getPageFile() {
1:456a2ba:         return this.pageFile;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Allocates a free page that you can write data to.
1:456a2ba:      *
1:456a2ba:      * @return a newly allocated page.
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> Page<T> allocate() throws IOException {
1:456a2ba:         return allocate(1);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Allocates a block of free pages that you can write data to.
1:456a2ba:      *
1:456a2ba:      * @param count the number of sequential pages to allocate
1:456a2ba:      * @return the first page of the sequential set.
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> Page<T> allocate(int count) throws IOException {
1:456a2ba:         Page<T> rc = pageFile.allocate(count);
1:456a2ba:         allocateList.add(new Sequence(rc.getPageId(), rc.getPageId()+count-1));
1:456a2ba:         return rc;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Frees up a previously allocated page so that it can be re-allocated again.
1:456a2ba:      *
1:2b10259:      * @param pageId the page to free up
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public void free(long pageId) throws IOException {
1:456a2ba:         free(load(pageId, null));
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.
1:456a2ba:      *
1:2b10259:      * @param pageId the initial page of the sequence that will be getting freed
1:456a2ba:      * @param count the number of pages in the sequence
1:456a2ba:      *
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public void free(long pageId, int count) throws IOException {
1:456a2ba:         free(load(pageId, null), count);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.
1:456a2ba:      *
2:456a2ba:      * @param page the initial page of the sequence that will be getting freed
1:456a2ba:      * @param count the number of pages in the sequence
1:456a2ba:      *
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> void free(Page<T> page, int count) throws IOException {
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba:         long offsetPage = page.getPageId();
1:cdba931:         while (count-- > 0) {
1:456a2ba:             if (page == null) {
1:cdba931:                 page = load(offsetPage, null);
1:456a2ba:             }
1:456a2ba:             free(page);
1:456a2ba:             page = null;
1:cdba931:             // Increment the offsetPage value since using it depends on the current count.
1:cdba931:             offsetPage++;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Frees up a previously allocated page so that it can be re-allocated again.
1:456a2ba:      *
2:456a2ba:      * @param page the page to free up
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> void free(Page<T> page) throws IOException {
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba: 
1:456a2ba:         // We may need loop to free up a page chain.
1:456a2ba:         while (page != null) {
1:456a2ba: 
1:456a2ba:             // Is it already free??
1:456a2ba:             if (page.getType() == Page.PAGE_FREE_TYPE) {
1:456a2ba:                 return;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             Page<T> next = null;
1:456a2ba:             if (page.getType() == Page.PAGE_PART_TYPE) {
1:456a2ba:                 next = load(page.getNext(), null);
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             page.makeFree(getWriteTransactionId());
1:2b10259:             // ensure free page is visible while write is pending
1:2b10259:             pageFile.addToCache(page.copy());
1:456a2ba: 
1:456a2ba:             DataByteArrayOutputStream out = new DataByteArrayOutputStream(pageFile.getPageSize());
1:456a2ba:             page.write(out);
1:456a2ba:             write(page, out.getData());
1:456a2ba: 
1:456a2ba:             freeList.add(page.getPageId());
1:456a2ba:             page = next;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      *
1:456a2ba:      * @param page
1:456a2ba:      *        the page to write. The Page object must be fully populated with a valid pageId, type, and data.
1:456a2ba:      * @param marshaller
1:456a2ba:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to write the data.
1:456a2ba:      * @param overflow
1:456a2ba:      *        If true, then if the page data marshalls to a bigger size than can fit in one page, then additional
1:456a2ba:      *        overflow pages are automatically allocated and chained to this page to store all the data.  If false,
1:456a2ba:      *        and the overflow condition would occur, then the PageOverflowIOException is thrown.
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws PageOverflowIOException
1:456a2ba:      *         If the page data marshalls to size larger than maximum page size and overflow was false.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> void store(Page<T> page, Marshaller<T> marshaller, final boolean overflow) throws IOException {
1:456a2ba:         DataByteArrayOutputStream out = (DataByteArrayOutputStream)openOutputStream(page, overflow);
1:456a2ba:         if (marshaller != null) {
1:456a2ba:             marshaller.writePayload(page.get(), out);
1:456a2ba:         }
1:456a2ba:         out.close();
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @throws IOException
1:456a2ba:      */
1:456a2ba:     public OutputStream openOutputStream(Page page, final boolean overflow) throws IOException {
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba: 
1:456a2ba:         // Copy to protect against the end user changing
1:456a2ba:         // the page instance while we are doing a write.
1:456a2ba:         final Page copy = page.copy();
1:456a2ba:         pageFile.addToCache(copy);
1:456a2ba: 
1:456a2ba:         //
1:456a2ba:         // To support writing VERY large data, we override the output stream so
1:456a2ba:         // that we
1:456a2ba:         // we do the page writes incrementally while the data is being
1:456a2ba:         // marshalled.
1:456a2ba:         DataByteArrayOutputStream out = new DataByteArrayOutputStream(pageFile.getPageSize() * 2) {
1:456a2ba:             Page current = copy;
1:456a2ba: 
4:456a2ba:             @SuppressWarnings("unchecked")
1:456a2ba:             @Override
1:456a2ba:             protected void onWrite() throws IOException {
1:456a2ba: 
1:456a2ba:                 // Are we at an overflow condition?
1:456a2ba:                 final int pageSize = pageFile.getPageSize();
1:456a2ba:                 if (pos >= pageSize) {
1:456a2ba:                     // If overflow is allowed
1:456a2ba:                     if (overflow) {
1:456a2ba: 
1:d1e7d69:                         do {
1:456a2ba:                             Page next;
1:456a2ba:                             if (current.getType() == Page.PAGE_PART_TYPE) {
1:456a2ba:                                 next = load(current.getNext(), null);
1:456a2ba:                             } else {
1:456a2ba:                                 next = allocate();
1:456a2ba:                             }
1:456a2ba: 
1:456a2ba:                             next.txId = current.txId;
1:456a2ba: 
1:456a2ba:                             // Write the page header
1:456a2ba:                             int oldPos = pos;
1:456a2ba:                             pos = 0;
1:456a2ba: 
1:456a2ba:                             current.makePagePart(next.getPageId(), getWriteTransactionId());
1:456a2ba:                             current.write(this);
1:456a2ba: 
1:456a2ba:                             // Do the page write..
1:456a2ba:                             byte[] data = new byte[pageSize];
1:456a2ba:                             System.arraycopy(buf, 0, data, 0, pageSize);
1:456a2ba:                             Transaction.this.write(current, data);
1:456a2ba: 
1:b24dfb9:                             // make the new link visible
1:b24dfb9:                             pageFile.addToCache(current);
1:b24dfb9: 
1:456a2ba:                             // Reset for the next page chunk
1:456a2ba:                             pos = 0;
1:456a2ba:                             // The page header marshalled after the data is written.
1:456a2ba:                             skip(Page.PAGE_HEADER_SIZE);
1:456a2ba:                             // Move the overflow data after the header.
1:456a2ba:                             System.arraycopy(buf, pageSize, buf, pos, oldPos - pageSize);
1:456a2ba:                             pos += oldPos - pageSize;
1:456a2ba:                             current = next;
1:456a2ba: 
1:d1e7d69:                         } while (pos > pageSize);
1:456a2ba:                     } else {
1:456a2ba:                         throw new PageOverflowIOException("Page overflow.");
1:456a2ba:                     }
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             @Override
1:456a2ba:             public void close() throws IOException {
1:456a2ba:                 super.close();
1:456a2ba: 
1:456a2ba:                 // We need to free up the rest of the page chain..
1:456a2ba:                 if (current.getType() == Page.PAGE_PART_TYPE) {
1:456a2ba:                     free(current.getNext());
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:                 current.makePageEnd(pos, getWriteTransactionId());
1:456a2ba: 
1:4cf6151:                 // make visible as end page
1:4cf6151:                 pageFile.addToCache(current);
1:4cf6151: 
1:456a2ba:                 // Write the header..
1:456a2ba:                 pos = 0;
1:456a2ba:                 current.write(this);
1:456a2ba: 
1:456a2ba:                 Transaction.this.write(current, buf);
1:456a2ba:             }
1:456a2ba:         };
1:456a2ba: 
1:456a2ba:         // The page header marshaled after the data is written.
1:456a2ba:         out.skip(Page.PAGE_HEADER_SIZE);
1:456a2ba:         return out;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Loads a page from disk.
1:456a2ba:      *
1:456a2ba:      * @param pageId
1:456a2ba:      *        the id of the page to load
1:456a2ba:      * @param marshaller
1:456a2ba:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.
1:456a2ba:      * @return The page with the given id
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public <T> Page<T> load(long pageId, Marshaller<T> marshaller) throws IOException {
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba:         Page<T> page = new Page<T>(pageId);
1:456a2ba:         load(page, marshaller);
1:456a2ba:         return page;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Loads a page from disk.
1:456a2ba:      *
1:456a2ba:      * @param page - The pageId field must be properly set
1:456a2ba:      * @param marshaller
1:456a2ba:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.
1:456a2ba:      * @throws IOException
1:456a2ba:      *         If an disk error occurred.
1:456a2ba:      * @throws InvalidPageIOException
1:456a2ba:      *         If the page is is not valid.
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     @SuppressWarnings("unchecked")
1:456a2ba:     public <T> void load(Page<T> page, Marshaller<T> marshaller) throws IOException {
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba: 
1:456a2ba:         // Can't load invalid offsets...
1:456a2ba:         long pageId = page.getPageId();
1:456a2ba:         if (pageId < 0) {
1:456a2ba:             throw new InvalidPageIOException("Page id is not valid", pageId);
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         // It might be a page this transaction has modified...
1:456a2ba:         PageWrite update = writes.get(pageId);
1:456a2ba:         if (update != null) {
1:456a2ba:             page.copy(update.getPage());
1:456a2ba:             return;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         // We may be able to get it from the cache...
1:456a2ba:         Page<T> t = pageFile.getFromCache(pageId);
1:456a2ba:         if (t != null) {
1:456a2ba:             page.copy(t);
1:456a2ba:             return;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         if (marshaller != null) {
1:456a2ba:             // Full page read..
1:456a2ba:             InputStream is = openInputStream(page);
1:456a2ba:             DataInputStream dataIn = new DataInputStream(is);
1:456a2ba:             page.set(marshaller.readPayload(dataIn));
1:456a2ba:             is.close();
1:456a2ba:         } else {
1:456a2ba:             // Page header read.
1:456a2ba:             DataByteArrayInputStream in = new DataByteArrayInputStream(new byte[Page.PAGE_HEADER_SIZE]);
1:456a2ba:             pageFile.readPage(pageId, in.getRawData());
1:456a2ba:             page.read(in);
1:456a2ba:             page.set(null);
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         // Cache it.
1:456a2ba:         if (marshaller != null) {
1:456a2ba:             pageFile.addToCache(page);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:1aab71b:      * @see org.apache.activemq.store.kahadb.disk.page.Transaction#load(org.apache.activemq.store.kahadb.disk.page.Page,
1:1aab71b:      *      org.apache.activemq.store.kahadb.disk.util.Marshaller)
1:456a2ba:      */
1:456a2ba:     public InputStream openInputStream(final Page p) throws IOException {
1:456a2ba: 
1:456a2ba:         return new InputStream() {
1:456a2ba: 
1:456a2ba:             private ByteSequence chunk = new ByteSequence(new byte[pageFile.getPageSize()]);
1:456a2ba:             private Page page = readPage(p);
1:456a2ba:             private int pageCount = 1;
1:456a2ba: 
1:456a2ba:             private Page markPage;
1:456a2ba:             private ByteSequence markChunk;
1:456a2ba: 
1:456a2ba:             private Page readPage(Page page) throws IOException {
1:456a2ba:                 // Read the page data
1:456a2ba: 
1:456a2ba:                 pageFile.readPage(page.getPageId(), chunk.getData());
1:456a2ba: 
1:456a2ba:                 chunk.setOffset(0);
1:456a2ba:                 chunk.setLength(pageFile.getPageSize());
1:456a2ba: 
1:456a2ba:                 DataByteArrayInputStream in = new DataByteArrayInputStream(chunk);
1:456a2ba:                 page.read(in);
1:456a2ba: 
1:456a2ba:                 chunk.setOffset(Page.PAGE_HEADER_SIZE);
1:456a2ba:                 if (page.getType() == Page.PAGE_END_TYPE) {
1:456a2ba:                     chunk.setLength((int)(page.getNext()));
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:                 if (page.getType() == Page.PAGE_FREE_TYPE) {
1:2b10259:                     throw new EOFException("Chunk stream does not exist, page: " + page.getPageId() + " is marked free");
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:                 return page;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public int read() throws IOException {
1:456a2ba:                 if (!atEOF()) {
1:456a2ba:                     return chunk.data[chunk.offset++] & 0xff;
1:456a2ba:                 } else {
1:456a2ba:                     return -1;
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             private boolean atEOF() throws IOException {
1:456a2ba:                 if (chunk.offset < chunk.length) {
1:456a2ba:                     return false;
1:456a2ba:                 }
1:456a2ba:                 if (page.getType() == Page.PAGE_END_TYPE) {
1:456a2ba:                     return true;
1:456a2ba:                 }
1:456a2ba:                 fill();
1:456a2ba:                 return chunk.offset >= chunk.length;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             private void fill() throws IOException {
1:456a2ba:                 page = readPage(new Page(page.getNext()));
1:456a2ba:                 pageCount++;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public int read(byte[] b) throws IOException {
1:456a2ba:                 return read(b, 0, b.length);
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public int read(byte b[], int off, int len) throws IOException {
1:456a2ba:                 if (!atEOF()) {
1:456a2ba:                     int rc = 0;
1:456a2ba:                     while (!atEOF() && rc < len) {
1:456a2ba:                         len = Math.min(len, chunk.length - chunk.offset);
1:456a2ba:                         if (len > 0) {
1:456a2ba:                             System.arraycopy(chunk.data, chunk.offset, b, off, len);
1:456a2ba:                             chunk.offset += len;
1:456a2ba:                         }
1:456a2ba:                         rc += len;
1:456a2ba:                     }
1:456a2ba:                     return rc;
1:456a2ba:                 } else {
1:456a2ba:                     return -1;
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public long skip(long len) throws IOException {
1:456a2ba:                 if (atEOF()) {
1:456a2ba:                     int rc = 0;
1:456a2ba:                     while (!atEOF() && rc < len) {
1:456a2ba:                         len = Math.min(len, chunk.length - chunk.offset);
1:456a2ba:                         if (len > 0) {
1:456a2ba:                             chunk.offset += len;
1:456a2ba:                         }
1:456a2ba:                         rc += len;
1:456a2ba:                     }
1:456a2ba:                     return rc;
1:456a2ba:                 } else {
1:456a2ba:                     return -1;
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public int available() {
1:456a2ba:                 return chunk.length - chunk.offset;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public boolean markSupported() {
1:456a2ba:                 return true;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public void mark(int markpos) {
1:456a2ba:                 markPage = page;
1:456a2ba:                 byte data[] = new byte[pageFile.getPageSize()];
1:456a2ba:                 System.arraycopy(chunk.getData(), 0, data, 0, pageFile.getPageSize());
1:456a2ba:                 markChunk = new ByteSequence(data, chunk.getOffset(), chunk.getLength());
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public void reset() {
1:456a2ba:                 page = markPage;
1:456a2ba:                 chunk = markChunk;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:         };
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Allows you to iterate through all active Pages in this object.  Pages with type Page.FREE_TYPE are
1:456a2ba:      * not included in this iteration.
1:456a2ba:      *
1:456a2ba:      * Pages removed with Iterator.remove() will not actually get removed until the transaction commits.
1:456a2ba:      *
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public Iterator<Page> iterator() {
1:456a2ba:         return (Iterator<Page>)iterator(false);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Allows you to iterate through all active Pages in this object.  You can optionally include free pages in the pages
1:456a2ba:      * iterated.
1:456a2ba:      *
1:456a2ba:      * @param includeFreePages - if true, free pages are included in the iteration
1:456a2ba:      * @throws IllegalStateException
1:456a2ba:      *         if the PageFile is not loaded
1:456a2ba:      */
1:456a2ba:     public Iterator<Page> iterator(final boolean includeFreePages) {
1:456a2ba: 
1:456a2ba:         pageFile.assertLoaded();
1:456a2ba: 
1:456a2ba:         return new Iterator<Page>() {
1:cdba931: 
1:456a2ba:             long nextId;
1:456a2ba:             Page nextPage;
1:456a2ba:             Page lastPage;
1:456a2ba: 
1:456a2ba:             private void findNextPage() {
1:456a2ba:                 if (!pageFile.isLoaded()) {
1:456a2ba:                     throw new IllegalStateException("Cannot iterate the pages when the page file is not loaded");
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:                 if (nextPage != null) {
1:456a2ba:                     return;
1:456a2ba:                 }
1:456a2ba: 
1:456a2ba:                 try {
1:456a2ba:                     while (nextId < pageFile.getPageCount()) {
1:456a2ba: 
1:456a2ba:                         Page page = load(nextId, null);
1:456a2ba: 
1:456a2ba:                         if (includeFreePages || page.getType() != Page.PAGE_FREE_TYPE) {
1:456a2ba:                             nextPage = page;
1:456a2ba:                             return;
1:456a2ba:                         } else {
1:456a2ba:                             nextId++;
1:456a2ba:                         }
1:456a2ba:                     }
1:456a2ba:                 } catch (IOException e) {
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public boolean hasNext() {
1:456a2ba:                 findNextPage();
1:456a2ba:                 return nextPage != null;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public Page next() {
1:456a2ba:                 findNextPage();
1:456a2ba:                 if (nextPage != null) {
1:456a2ba:                     lastPage = nextPage;
1:456a2ba:                     nextPage = null;
1:456a2ba:                     nextId++;
1:456a2ba:                     return lastPage;
1:456a2ba:                 } else {
1:456a2ba:                     throw new NoSuchElementException();
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             @SuppressWarnings("unchecked")
1:456a2ba:             public void remove() {
1:456a2ba:                 if (lastPage == null) {
1:456a2ba:                     throw new IllegalStateException();
1:456a2ba:                 }
1:456a2ba:                 try {
1:456a2ba:                     free(lastPage);
1:456a2ba:                     lastPage = null;
1:456a2ba:                 } catch (IOException e) {
1:2a6a4b2:                     throw new RuntimeException(e);
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba:         };
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:     // Commit / Rollback related methods..
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Commits the transaction to the PageFile as a single 'Unit of Work'. Either all page updates associated
1:456a2ba:      * with the transaction are written to disk or none will.
1:456a2ba:      */
1:456a2ba:     public void commit() throws IOException {
1:456a2ba:         if( writeTransactionId!=-1 ) {
1:6994ecb:             if (tmpFile != null) {
1:6994ecb:                 tmpFile.close();
1:6994ecb:                 pageFile.removeTmpFile(getTempFile());
1:6994ecb:                 tmpFile = null;
1:6994ecb:                 txFile = null;
1:d1e7d69:             }
1:456a2ba:             // Actually do the page writes...
1:456a2ba:             pageFile.write(writes.entrySet());
1:456a2ba:             // Release the pages that were freed up in the transaction..
1:456a2ba:             freePages(freeList);
1:456a2ba: 
1:456a2ba:             freeList.clear();
1:456a2ba:             allocateList.clear();
1:456a2ba:             writes.clear();
1:456a2ba:             writeTransactionId = -1;
1:456a2ba:         }
1:40ae055:         size = 0;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Rolls back the transaction.
1:456a2ba:      */
1:456a2ba:     public void rollback() throws IOException {
1:456a2ba:         if( writeTransactionId!=-1 ) {
1:6994ecb:             if (tmpFile != null) {
1:6994ecb:                 tmpFile.close();
1:6994ecb:                 pageFile.removeTmpFile(getTempFile());
1:6994ecb:                 tmpFile = null;
1:6994ecb:                 txFile = null;
1:2a6a4b2:             }
1:456a2ba:             // Release the pages that were allocated in the transaction...
1:456a2ba:             freePages(allocateList);
1:456a2ba: 
1:456a2ba:             freeList.clear();
1:456a2ba:             allocateList.clear();
1:456a2ba:             writes.clear();
1:456a2ba:             writeTransactionId = -1;
1:456a2ba:         }
1:40ae055:         size = 0;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private long getWriteTransactionId() {
1:456a2ba:         if( writeTransactionId==-1 ) {
1:456a2ba:             writeTransactionId = pageFile.getNextWriteTransactionId();
1:456a2ba:         }
1:456a2ba:         return writeTransactionId;
1:456a2ba:     }
1:456a2ba: 
1:2a6a4b2: 
1:40ae055:     protected File getTempFile() {
1:5bcd417:         if (txFile == null) {
1:1aab71b:             txFile = new File(getPageFile().getDirectory(), IOHelper.toFileSystemSafeName("tx-" + Long.toString(getWriteTransactionId()) + "-" + Long.toString(System.currentTimeMillis()) + ".tmp"));
1:6994ecb:         }
1:5bcd417:        return txFile;
1:6994ecb:     }
1:2a6a4b2: 
1:456a2ba:     /**
1:456a2ba:      * Queues up a page write that should get done when commit() gets called.
1:456a2ba:      */
1:456a2ba:     private void write(final Page page, byte[] data) throws IOException {
1:456a2ba:         Long key = page.getPageId();
1:456a2ba: 
1:4a7475d:         // how much pages we have for this transaction
1:4a7475d:         size = writes.size() * pageFile.getPageSize();
1:456a2ba: 
1:40ae055:         PageWrite write;
1:cdba931: 
1:40ae055:         if (size > maxTransactionSize) {
1:40ae055:             if (tmpFile == null) {
1:40ae055:                 tmpFile = new RandomAccessFile(getTempFile(), "rw");
1:456a2ba:             }
1:d1e7d69:             long location = nextLocation;
1:40ae055:             tmpFile.seek(nextLocation);
1:40ae055:             tmpFile.write(data);
1:40ae055:             nextLocation = location + data.length;
1:40ae055:             write = new PageWrite(page, location, data.length, getTempFile());
1:d1e7d69:         } else {
1:40ae055:             write = new PageWrite(page, data);
1:456a2ba:         }
1:40ae055:         writes.put(key, write);
1:2a6a4b2:     }
1:2a6a4b2: 
1:456a2ba:     /**
1:456a2ba:      * @param list
1:456a2ba:      * @throws RuntimeException
1:456a2ba:      */
1:456a2ba:     private void freePages(SequenceSet list) throws RuntimeException {
1:456a2ba:         Sequence seq = list.getHead();
1:456a2ba:         while( seq!=null ) {
1:456a2ba:             seq.each(new Sequence.Closure<RuntimeException>(){
1:456a2ba:                 public void execute(long value) {
1:456a2ba:                     pageFile.freePage(value);
1:456a2ba:                 }
1:456a2ba:             });
1:456a2ba:             seq = seq.getNext();
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @return true if there are no uncommitted page file updates associated with this transaction.
1:456a2ba:      */
1:456a2ba:     public boolean isReadOnly() {
1:456a2ba:         return writeTransactionId==-1;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:     // Transaction closure helpers...
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.
1:456a2ba:      * If the closure throws an Exception, then the transaction is rolled back.
1:456a2ba:      *
1:456a2ba:      * @param <T>
1:456a2ba:      * @param closure - the work to get exectued.
1:456a2ba:      * @throws T if the closure throws it
1:456a2ba:      * @throws IOException If the commit fails.
1:456a2ba:      */
1:456a2ba:     public <T extends Throwable> void execute(Closure<T> closure) throws T, IOException {
1:456a2ba:         boolean success = false;
1:456a2ba:         try {
1:456a2ba:             closure.execute(this);
1:456a2ba:             success = true;
1:456a2ba:         } finally {
1:456a2ba:             if (success) {
1:456a2ba:                 commit();
1:456a2ba:             } else {
1:456a2ba:                 rollback();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.
1:456a2ba:      * If the closure throws an Exception, then the transaction is rolled back.
1:456a2ba:      *
1:456a2ba:      * @param <T>
1:456a2ba:      * @param closure - the work to get exectued.
1:456a2ba:      * @throws T if the closure throws it
1:456a2ba:      * @throws IOException If the commit fails.
1:456a2ba:      */
1:456a2ba:     public <R, T extends Throwable> R execute(CallableClosure<R, T> closure) throws T, IOException {
1:456a2ba:         boolean success = false;
1:456a2ba:         try {
1:456a2ba:             R rc = closure.execute(this);
1:456a2ba:             success = true;
1:456a2ba:             return rc;
1:456a2ba:         } finally {
1:456a2ba:             if (success) {
1:456a2ba:                 commit();
1:456a2ba:             } else {
1:456a2ba:                 rollback();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
2:40ae055: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.page;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile.PageWrite;
1: import org.apache.activemq.store.kahadb.disk.util.*;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.store.kahadb.disk.util.DataByteArrayInputStream;
1: import org.apache.activemq.store.kahadb.disk.util.DataByteArrayOutputStream;
1: import org.apache.activemq.util.IOHelper;
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.activemq.store.kahadb.disk.page.Transaction#load(org.apache.activemq.store.kahadb.disk.page.Page,
1:      *      org.apache.activemq.store.kahadb.disk.util.Marshaller)
/////////////////////////////////////////////////////////////////////////
1:             txFile = new File(getPageFile().getDirectory(), IOHelper.toFileSystemSafeName("tx-" + Long.toString(getWriteTransactionId()) + "-" + Long.toString(System.currentTimeMillis()) + ".tmp"));
commit:715010a
commit:7c70973
/////////////////////////////////////////////////////////////////////////
commit:456a2ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.page;
1: 
0: import com.sun.org.apache.bcel.internal.generic.AllocationInstruction;
1: 
0: import java.io.DataInputStream;
0: import java.io.EOFException;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.NoSuchElementException;
1: 
0: import org.apache.kahadb.page.PageFile.PageWrite;
0: import org.apache.kahadb.util.ByteSequence;
0: import org.apache.kahadb.util.DataByteArrayInputStream;
0: import org.apache.kahadb.util.DataByteArrayOutputStream;
0: import org.apache.kahadb.util.Marshaller;
0: import org.apache.kahadb.util.Sequence;
0: import org.apache.kahadb.util.SequenceSet;
1: 
1: /**
1:  * The class used to read/update a PageFile object.  Using a transaction allows you to
1:  * do multiple update operations in a single unit of work.
1:  */
1: public class Transaction implements Iterable<Page> {
1:     
1:     /**
1:      * The PageOverflowIOException occurs when a page write is requested
1:      * and it's data is larger than what would fit into a single page.
1:      */
1:     public class PageOverflowIOException extends IOException {
1:         public PageOverflowIOException(String message) {
1:             super(message);
1:         }
1:     }
1:     
1:     /**
1:      * The InvalidPageIOException is thrown if try to load/store a a page
1:      * with an invalid page id.
1:      */
1:     public class InvalidPageIOException extends IOException {
1:         private final long page;
1: 
1:         public InvalidPageIOException(String message, long page) {
1:             super(message);
1:             this.page = page;
1:         }
1: 
1:         public long getPage() {
1:             return page;
1:         }
1:     }    
1:     
1:     /**
1:      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.
1:      * 
1:      * @param <T> The type of exceptions that operation will throw.
1:      */
1:     public interface Closure <T extends Throwable> {
1:         public void execute(Transaction tx) throws T;
1:     }
1: 
1:     /**
1:      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.
1:      * 
1:      * @param <R> The type of result that the closure produces.
1:      * @param <T> The type of exceptions that operation will throw.
1:      */
1:     public interface CallableClosure<R, T extends Throwable> {
1:         public R execute(Transaction tx) throws T;
1:     }
1:     
1: 
1:     // The page file that this Transaction operates against.
1:     private final PageFile pageFile;
1:     // If this transaction is updating stuff.. this is the tx of 
1:     private long writeTransactionId=-1;
1:     // List of pages that this transaction has modified.
0:     private HashMap<Long, PageWrite> writes=new HashMap<Long, PageWrite>();
1:     // List of pages allocated in this transaction
1:     private final SequenceSet allocateList = new SequenceSet();
1:     // List of pages freed in this transaction
1:     private final SequenceSet freeList = new SequenceSet();
1: 
1:     Transaction(PageFile pageFile) {
1:         this.pageFile = pageFile;
1:     }
1: 
1:     /**
1:      * @return the page file that created this Transaction
1:      */
1:     public PageFile getPageFile() {
1:         return this.pageFile;
1:     }
1: 
1:     /** 
1:      * Allocates a free page that you can write data to.
1:      * 
1:      * @return a newly allocated page.  
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> Page<T> allocate() throws IOException {
1:         return allocate(1);
1:     }
1: 
1:     /** 
1:      * Allocates a block of free pages that you can write data to.
1:      * 
1:      * @param count the number of sequential pages to allocate
1:      * @return the first page of the sequential set. 
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> Page<T> allocate(int count) throws IOException {
0:         // TODO: we need to track allocated pages so that they can be returned if the 
0:         // transaction gets rolled back.
1:         Page<T> rc = pageFile.allocate(count);
1:         allocateList.add(new Sequence(rc.getPageId(), rc.getPageId()+count-1));
1:         return rc;
1:     }
1: 
1:     /**
1:      * Frees up a previously allocated page so that it can be re-allocated again.
1:      * 
1:      * @param page the page to free up
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public void free(long pageId) throws IOException {
1:         free(load(pageId, null));
1:     }
1: 
1:     /**
1:      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.
1:      * 
1:      * @param page the initial page of the sequence that will be getting freed
1:      * @param count the number of pages in the sequence
1:      * 
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public void free(long pageId, int count) throws IOException {
1:         free(load(pageId, null), count);
1:     }
1: 
1:     /**
1:      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.
1:      * 
1:      * @param page the initial page of the sequence that will be getting freed
1:      * @param count the number of pages in the sequence
1:      * 
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> void free(Page<T> page, int count) throws IOException {
1:         pageFile.assertLoaded();
1:         long offsetPage = page.getPageId();
0:         for (int i = 0; i < count; i++) {
1:             if (page == null) {
0:                 page = load(offsetPage + i, null);
1:             }
1:             free(page);
1:             page = null;
1:         }
1:     }
1:     
1:     /**
1:      * Frees up a previously allocated page so that it can be re-allocated again.
1:      * 
1:      * @param page the page to free up
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> void free(Page<T> page) throws IOException {
1:         pageFile.assertLoaded();
1: 
1:         // We may need loop to free up a page chain.
1:         while (page != null) {
1: 
1:             // Is it already free??
1:             if (page.getType() == Page.PAGE_FREE_TYPE) {
1:                 return;
1:             }
1: 
1:             Page<T> next = null;
1:             if (page.getType() == Page.PAGE_PART_TYPE) {
1:                 next = load(page.getNext(), null);
1:             }
1: 
1:             page.makeFree(getWriteTransactionId());
1: 
1:             DataByteArrayOutputStream out = new DataByteArrayOutputStream(pageFile.getPageSize());
1:             page.write(out);
1:             write(page, out.getData());
1: 
1:             freeList.add(page.getPageId());
1:             page = next;
1:         }
1:     }
1: 
1:     /**
1:      * 
1:      * @param page
1:      *        the page to write. The Page object must be fully populated with a valid pageId, type, and data.
1:      * @param marshaller
1:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to write the data.
1:      * @param overflow
1:      *        If true, then if the page data marshalls to a bigger size than can fit in one page, then additional 
1:      *        overflow pages are automatically allocated and chained to this page to store all the data.  If false,
1:      *        and the overflow condition would occur, then the PageOverflowIOException is thrown. 
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws PageOverflowIOException
1:      *         If the page data marshalls to size larger than maximum page size and overflow was false.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> void store(Page<T> page, Marshaller<T> marshaller, final boolean overflow) throws IOException {
1:         DataByteArrayOutputStream out = (DataByteArrayOutputStream)openOutputStream(page, overflow);
1:         if (marshaller != null) {
1:             marshaller.writePayload(page.get(), out);
1:         }
1:         out.close();
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      */
1:     public OutputStream openOutputStream(Page page, final boolean overflow) throws IOException {
1:         pageFile.assertLoaded();
1: 
1:         // Copy to protect against the end user changing
1:         // the page instance while we are doing a write.
1:         final Page copy = page.copy();
1:         pageFile.addToCache(copy);
1: 
1:         //
1:         // To support writing VERY large data, we override the output stream so
1:         // that we
1:         // we do the page writes incrementally while the data is being
1:         // marshalled.
1:         DataByteArrayOutputStream out = new DataByteArrayOutputStream(pageFile.getPageSize() * 2) {
1:             Page current = copy;
1: 
1:             @SuppressWarnings("unchecked")
1:             @Override
1:             protected void onWrite() throws IOException {
1: 
1:                 // Are we at an overflow condition?
1:                 final int pageSize = pageFile.getPageSize();
1:                 if (pos >= pageSize) {
1:                     // If overflow is allowed
1:                     if (overflow) {
1: 
1:                         Page next;
1:                         if (current.getType() == Page.PAGE_PART_TYPE) {
1:                             next = load(current.getNext(), null);
1:                         } else {
1:                             next = allocate();
1:                         }
1: 
1:                         next.txId = current.txId;
1: 
1:                         // Write the page header
1:                         int oldPos = pos;
1:                         pos = 0;
1: 
1:                         current.makePagePart(next.getPageId(), getWriteTransactionId());
1:                         current.write(this);
1: 
1:                         // Do the page write..
1:                         byte[] data = new byte[pageSize];
1:                         System.arraycopy(buf, 0, data, 0, pageSize);
1:                         Transaction.this.write(current, data);
1: 
1:                         // Reset for the next page chunk
1:                         pos = 0;
1:                         // The page header marshalled after the data is written.
1:                         skip(Page.PAGE_HEADER_SIZE);
1:                         // Move the overflow data after the header.
1:                         System.arraycopy(buf, pageSize, buf, pos, oldPos - pageSize);
1:                         pos += oldPos - pageSize;
1:                         current = next;
1: 
1:                     } else {
1:                         throw new PageOverflowIOException("Page overflow.");
1:                     }
1:                 }
1: 
1:             }
1: 
1:             @SuppressWarnings("unchecked")
1:             @Override
1:             public void close() throws IOException {
1:                 super.close();
1: 
1:                 // We need to free up the rest of the page chain..
1:                 if (current.getType() == Page.PAGE_PART_TYPE) {
1:                     free(current.getNext());
1:                 }
1: 
1:                 current.makePageEnd(pos, getWriteTransactionId());
1: 
1:                 // Write the header..
1:                 pos = 0;
1:                 current.write(this);
1: 
1:                 Transaction.this.write(current, buf);
1:             }
1:         };
1: 
1:         // The page header marshaled after the data is written.
1:         out.skip(Page.PAGE_HEADER_SIZE);
1:         return out;
1:     }
1: 
1:     /**
1:      * Loads a page from disk.
1:      * 
1:      * @param pageId 
1:      *        the id of the page to load
1:      * @param marshaller
1:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.
1:      * @return The page with the given id
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public <T> Page<T> load(long pageId, Marshaller<T> marshaller) throws IOException {
1:         pageFile.assertLoaded();
1:         Page<T> page = new Page<T>(pageId);
1:         load(page, marshaller);
1:         return page;
1:     }
1: 
1:     /**
1:      * Loads a page from disk.
1:      * 
1:      * @param page - The pageId field must be properly set 
1:      * @param marshaller
1:      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.
1:      * @throws IOException
1:      *         If an disk error occurred.
1:      * @throws InvalidPageIOException
1:      *         If the page is is not valid.      
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     @SuppressWarnings("unchecked")
1:     public <T> void load(Page<T> page, Marshaller<T> marshaller) throws IOException {
1:         pageFile.assertLoaded();
1: 
1:         // Can't load invalid offsets...
1:         long pageId = page.getPageId();
1:         if (pageId < 0) {
1:             throw new InvalidPageIOException("Page id is not valid", pageId);
1:         }
1: 
1:         // It might be a page this transaction has modified...
1:         PageWrite update = writes.get(pageId);
1:         if (update != null) {
1:             page.copy(update.getPage());
1:             return;
1:         }
1: 
1:         // We may be able to get it from the cache...
1:         Page<T> t = pageFile.getFromCache(pageId);
1:         if (t != null) {
1:             page.copy(t);
1:             return;
1:         }
1: 
1:         if (marshaller != null) {
1:             // Full page read..
1:             InputStream is = openInputStream(page);
1:             DataInputStream dataIn = new DataInputStream(is);
1:             page.set(marshaller.readPayload(dataIn));
1:             is.close();
1:         } else {
1:             // Page header read.
1:             DataByteArrayInputStream in = new DataByteArrayInputStream(new byte[Page.PAGE_HEADER_SIZE]);
1:             pageFile.readPage(pageId, in.getRawData());
1:             page.read(in);
1:             page.set(null);
1:         }
1: 
1:         // Cache it.
1:         if (marshaller != null) {
1:             pageFile.addToCache(page);
1:         }
1:     }
1: 
1:     /**
0:      * @see org.apache.kahadb.page.Transaction#load(org.apache.kahadb.page.Page,
0:      *      org.apache.kahadb.util.Marshaller)
1:      */
1:     public InputStream openInputStream(final Page p) throws IOException {
1: 
1:         return new InputStream() {
1: 
1:             private ByteSequence chunk = new ByteSequence(new byte[pageFile.getPageSize()]);
1:             private Page page = readPage(p);
1:             private int pageCount = 1;
1: 
1:             private Page markPage;
1:             private ByteSequence markChunk;
1: 
1:             private Page readPage(Page page) throws IOException {
1:                 // Read the page data
1:                 
1:                 pageFile.readPage(page.getPageId(), chunk.getData());
1:                 
1:                 chunk.setOffset(0);
1:                 chunk.setLength(pageFile.getPageSize());
1: 
1:                 DataByteArrayInputStream in = new DataByteArrayInputStream(chunk);
1:                 page.read(in);
1: 
1:                 chunk.setOffset(Page.PAGE_HEADER_SIZE);
1:                 if (page.getType() == Page.PAGE_END_TYPE) {
1:                     chunk.setLength((int)(page.getNext()));
1:                 }
1: 
1:                 if (page.getType() == Page.PAGE_FREE_TYPE) {
0:                     throw new EOFException("Chunk stream does not exist at page: " + page.getPageId());
1:                 }
1: 
1:                 return page;
1:             }
1: 
1:             public int read() throws IOException {
1:                 if (!atEOF()) {
1:                     return chunk.data[chunk.offset++] & 0xff;
1:                 } else {
1:                     return -1;
1:                 }
1:             }
1: 
1:             private boolean atEOF() throws IOException {
1:                 if (chunk.offset < chunk.length) {
1:                     return false;
1:                 }
1:                 if (page.getType() == Page.PAGE_END_TYPE) {
1:                     return true;
1:                 }
1:                 fill();
1:                 return chunk.offset >= chunk.length;
1:             }
1: 
1:             private void fill() throws IOException {
1:                 page = readPage(new Page(page.getNext()));
1:                 pageCount++;
1:             }
1: 
1:             public int read(byte[] b) throws IOException {
1:                 return read(b, 0, b.length);
1:             }
1: 
1:             public int read(byte b[], int off, int len) throws IOException {
1:                 if (!atEOF()) {
1:                     int rc = 0;
1:                     while (!atEOF() && rc < len) {
1:                         len = Math.min(len, chunk.length - chunk.offset);
1:                         if (len > 0) {
1:                             System.arraycopy(chunk.data, chunk.offset, b, off, len);
1:                             chunk.offset += len;
1:                         }
1:                         rc += len;
1:                     }
1:                     return rc;
1:                 } else {
1:                     return -1;
1:                 }
1:             }
1: 
1:             public long skip(long len) throws IOException {
1:                 if (atEOF()) {
1:                     int rc = 0;
1:                     while (!atEOF() && rc < len) {
1:                         len = Math.min(len, chunk.length - chunk.offset);
1:                         if (len > 0) {
1:                             chunk.offset += len;
1:                         }
1:                         rc += len;
1:                     }
1:                     return rc;
1:                 } else {
1:                     return -1;
1:                 }
1:             }
1: 
1:             public int available() {
1:                 return chunk.length - chunk.offset;
1:             }
1: 
1:             public boolean markSupported() {
1:                 return true;
1:             }
1: 
1:             public void mark(int markpos) {
1:                 markPage = page;
1:                 byte data[] = new byte[pageFile.getPageSize()];
1:                 System.arraycopy(chunk.getData(), 0, data, 0, pageFile.getPageSize());
1:                 markChunk = new ByteSequence(data, chunk.getOffset(), chunk.getLength());
1:             }
1: 
1:             public void reset() {
1:                 page = markPage;
1:                 chunk = markChunk;
1:             }
1: 
1:         };
1:     }
1: 
1:     /**
1:      * Allows you to iterate through all active Pages in this object.  Pages with type Page.FREE_TYPE are 
1:      * not included in this iteration. 
1:      * 
1:      * Pages removed with Iterator.remove() will not actually get removed until the transaction commits.
1:      * 
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     @SuppressWarnings("unchecked")
1:     public Iterator<Page> iterator() {
1:         return (Iterator<Page>)iterator(false);
1:     }
1: 
1:     /**
1:      * Allows you to iterate through all active Pages in this object.  You can optionally include free pages in the pages
1:      * iterated.
1:      * 
1:      * @param includeFreePages - if true, free pages are included in the iteration
0:      * @param tx - if not null, then the remove() opeation on the Iterator will operate in scope of that transaction.
1:      * @throws IllegalStateException
1:      *         if the PageFile is not loaded
1:      */
1:     public Iterator<Page> iterator(final boolean includeFreePages) {
1: 
1:         pageFile.assertLoaded();
1: 
1:         return new Iterator<Page>() {
1:             long nextId;
1:             Page nextPage;
1:             Page lastPage;
1: 
1:             private void findNextPage() {
1:                 if (!pageFile.isLoaded()) {
1:                     throw new IllegalStateException("Cannot iterate the pages when the page file is not loaded");
1:                 }
1: 
1:                 if (nextPage != null) {
1:                     return;
1:                 }
1: 
1:                 try {
1:                     while (nextId < pageFile.getPageCount()) {
1: 
1:                         Page page = load(nextId, null);
1: 
1:                         if (includeFreePages || page.getType() != Page.PAGE_FREE_TYPE) {
1:                             nextPage = page;
1:                             return;
1:                         } else {
1:                             nextId++;
1:                         }
1:                     }
1:                 } catch (IOException e) {
1:                 }
1:             }
1: 
1:             public boolean hasNext() {
1:                 findNextPage();
1:                 return nextPage != null;
1:             }
1: 
1:             public Page next() {
1:                 findNextPage();
1:                 if (nextPage != null) {
1:                     lastPage = nextPage;
1:                     nextPage = null;
1:                     nextId++;
1:                     return lastPage;
1:                 } else {
1:                     throw new NoSuchElementException();
1:                 }
1:             }
1: 
1:             @SuppressWarnings("unchecked")
1:             public void remove() {
1:                 if (lastPage == null) {
1:                     throw new IllegalStateException();
1:                 }
1:                 try {
1:                     free(lastPage);
1:                     lastPage = null;
1:                 } catch (IOException e) {
0:                     new RuntimeException(e);
1:                 }
1:             }
1:         };
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////
1:     // Commit / Rollback related methods..
1:     ///////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Commits the transaction to the PageFile as a single 'Unit of Work'. Either all page updates associated
1:      * with the transaction are written to disk or none will.
1:      */
1:     public void commit() throws IOException {
1:         if( writeTransactionId!=-1 ) {
1:             // Actually do the page writes...
1:             pageFile.write(writes.entrySet());
1:             // Release the pages that were freed up in the transaction..
1:             freePages(freeList);
1:             
1:             freeList.clear();
1:             allocateList.clear();
1:             writes.clear();
1:             writeTransactionId = -1;
1:         }
1:     }
1: 
1:     /**
1:      * Rolls back the transaction.
1:      */
1:     public void rollback() throws IOException {
1:         if( writeTransactionId!=-1 ) {
1:             // Release the pages that were allocated in the transaction...
1:             freePages(allocateList);
1: 
1:             freeList.clear();
1:             allocateList.clear();
1:             writes.clear();
1:             writeTransactionId = -1;
1:         }
1:     }
1: 
1:     private long getWriteTransactionId() {
1:         if( writeTransactionId==-1 ) {
1:             writeTransactionId = pageFile.getNextWriteTransactionId();
1:         }
1:         return writeTransactionId;
1:     }
1: 
1:     /**
1:      * Queues up a page write that should get done when commit() gets called.
1:      */
1:     @SuppressWarnings("unchecked")
1:     private void write(final Page page, byte[] data) throws IOException {
1:         Long key = page.getPageId();
0:         // TODO: if a large update transaction is in progress, we may want to move
0:         // all the current updates to a temp file so that we don't keep using 
0:         // up memory.
0:         writes.put(key, new PageWrite(page, data));        
1:     }   
1: 
1:     /**
1:      * @param list
1:      * @throws RuntimeException
1:      */
1:     private void freePages(SequenceSet list) throws RuntimeException {
1:         Sequence seq = list.getHead();
1:         while( seq!=null ) {
1:             seq.each(new Sequence.Closure<RuntimeException>(){
1:                 public void execute(long value) {
1:                     pageFile.freePage(value);
1:                 }
1:             });
1:             seq = seq.getNext();
1:         }
1:     }
1:     
1:     /**
1:      * @return true if there are no uncommitted page file updates associated with this transaction.
1:      */
1:     public boolean isReadOnly() {
1:         return writeTransactionId==-1;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////
1:     // Transaction closure helpers...
1:     ///////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.
1:      * If the closure throws an Exception, then the transaction is rolled back.
1:      * 
1:      * @param <T>
1:      * @param closure - the work to get exectued.
1:      * @throws T if the closure throws it
1:      * @throws IOException If the commit fails.
1:      */
1:     public <T extends Throwable> void execute(Closure<T> closure) throws T, IOException {
1:         boolean success = false;
1:         try {
1:             closure.execute(this);
1:             success = true;
1:         } finally {
1:             if (success) {
1:                 commit();
1:             } else {
1:                 rollback();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.
1:      * If the closure throws an Exception, then the transaction is rolled back.
1:      * 
1:      * @param <T>
1:      * @param closure - the work to get exectued.
1:      * @throws T if the closure throws it
1:      * @throws IOException If the commit fails.
1:      */
1:     public <R, T extends Throwable> R execute(CallableClosure<R, T> closure) throws T, IOException {
1:         boolean success = false;
1:         try {
1:             R rc = closure.execute(this);
1:             success = true;
1:             return rc;
1:         } finally {
1:             if (success) {
1:                 commit();
1:             } else {
1:                 rollback();
1:             }
1:         }
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:4cf6151
/////////////////////////////////////////////////////////////////////////
1:                 // make visible as end page
1:                 pageFile.addToCache(current);
1: 
commit:b24dfb9
/////////////////////////////////////////////////////////////////////////
1:                             // make the new link visible
1:                             pageFile.addToCache(current);
1: 
commit:d1e7d69
/////////////////////////////////////////////////////////////////////////
1:     private long nextLocation = 0;
/////////////////////////////////////////////////////////////////////////
1:                         do {
0:                             Page next;
0:                             if (current.getType() == Page.PAGE_PART_TYPE) {
0:                                 next = load(current.getNext(), null);
1:                             } else {
0:                                 next = allocate();
1:                             }
0:                             next.txId = current.txId;
0:                             // Write the page header
0:                             int oldPos = pos;
0:                             pos = 0;
0:                             current.makePagePart(next.getPageId(), getWriteTransactionId());
0:                             current.write(this);
0:                             // Do the page write..
0:                             byte[] data = new byte[pageSize];
0:                             System.arraycopy(buf, 0, data, 0, pageSize);
0:                             Transaction.this.write(current, data);
0:                             // Reset for the next page chunk
0:                             pos = 0;
0:                             // The page header marshalled after the data is written.
0:                             skip(Page.PAGE_HEADER_SIZE);
0:                             // Move the overflow data after the header.
0:                             System.arraycopy(buf, pageSize, buf, pos, oldPos - pageSize);
0:                             pos += oldPos - pageSize;
0:                             current = next;
1:                         } while (pos > pageSize);
/////////////////////////////////////////////////////////////////////////
1:             long location = nextLocation;
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param pageId the page to free up
/////////////////////////////////////////////////////////////////////////
1:      * @param pageId the initial page of the sequence that will be getting freed
/////////////////////////////////////////////////////////////////////////
1:             // ensure free page is visible while write is pending
1:             pageFile.addToCache(page.copy());
/////////////////////////////////////////////////////////////////////////
1:                     throw new EOFException("Chunk stream does not exist, page: " + page.getPageId() + " is marked free");
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:cdba931
/////////////////////////////////////////////////////////////////////////
1:         private static final long serialVersionUID = 1L;
1: 
/////////////////////////////////////////////////////////////////////////
1:         private static final long serialVersionUID = 1L;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private long maxTransactionSize = Long.getLong("maxKahaDBTxSize", 10485760L);
/////////////////////////////////////////////////////////////////////////
1:         while (count-- > 0) {
1:                 page = load(offsetPage, null);
1:             // Increment the offsetPage value since using it depends on the current count.
1:             offsetPage++;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:2a6a4b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
1: 
0:     // If this transaction is updating stuff.. this is the tx of
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      *
0:      * @return a newly allocated page.
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      *
0:      * @return the first page of the sequential set.
0:         // TODO: we need to track allocated pages so that they can be returned if the
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
0:      *        If true, then if the page data marshalls to a bigger size than can fit in one page, then additional
0:      *        and the overflow condition would occur, then the PageOverflowIOException is thrown.
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @param pageId
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @param page - The pageId field must be properly set
0:      *         If the page is is not valid.
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:      * Allows you to iterate through all active Pages in this object.  Pages with type Page.FREE_TYPE are
0:      * not included in this iteration.
0:      *
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1:                     throw new RuntimeException(e);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:4a7475d
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
0: import java.util.Iterator;
0: import java.util.NoSuchElementException;
1: import java.util.TreeMap;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:         // how much pages we have for this transaction
1:         size = writes.size() * pageFile.getPageSize();
0:         
commit:6994ecb
/////////////////////////////////////////////////////////////////////////
1:             if (tmpFile != null) {
1:                 tmpFile.close();
1:                 pageFile.removeTmpFile(getTempFile());
1:                 tmpFile = null;
1:                 txFile = null;
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (tmpFile != null) {
1:                 tmpFile.close();
1:                 pageFile.removeTmpFile(getTempFile());
1:                 tmpFile = null;
1:                 txFile = null;
1:             }
/////////////////////////////////////////////////////////////////////////
commit:984a9fb
/////////////////////////////////////////////////////////////////////////
0:     private long maxTransactionSize = Long.parseLong(System.getProperty("maxKahaDBTxSize", "" + 10485760));
commit:5bcd417
/////////////////////////////////////////////////////////////////////////
1:     private File txFile;
/////////////////////////////////////////////////////////////////////////
0:     private long maxTransactionSize = Integer.parseInt(System.getProperty("maxKahaDBTxSize", "" + 10485760));
/////////////////////////////////////////////////////////////////////////
0:                 txFile = null;
/////////////////////////////////////////////////////////////////////////
0:                 txFile = null;
/////////////////////////////////////////////////////////////////////////
1:         if (txFile == null) {
0:             txFile = new File(getPageFile().getDirectory(), IOHelper.toFileSystemSafeName("tx-"+ Long.toString(getWriteTransactionId()) + "-" + Long.toString(System.currentTimeMillis()) + ".tmp"));
1:        return txFile;
commit:40ae055
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import java.util.*;
0: import org.apache.kahadb.util.*;
/////////////////////////////////////////////////////////////////////////
0: 
1:     private RandomAccessFile tmpFile;
0:     private File txfFile;
0:     private int nextLocation = 0;
0: 
/////////////////////////////////////////////////////////////////////////
1:     private TreeMap<Long, PageWrite> writes=new TreeMap<Long, PageWrite>();
0:     private long maxTransactionSize = 10485760;
0: 
1:     private long size = 0;
0: 
/////////////////////////////////////////////////////////////////////////
0:             if (tmpFile != null) {
0:                 tmpFile.close();
0:                 if (!getTempFile().delete()) {
0:                     throw new IOException("Can't delete temporary KahaDB transaction file:"  + getTempFile());
1:                 }
0:                 tmpFile = null;
0:                 txfFile = null;
1:             }
1:         size = 0;
/////////////////////////////////////////////////////////////////////////
0:             if (tmpFile != null) {
0:                 tmpFile.close();
0:                 if (getTempFile().delete()) {
0:                     throw new IOException("Can't delete temporary KahaDB transaction file:"  + getTempFile());
0:                 }
0:                 tmpFile = null;
0:                 txfFile = null;
0:             }
1:         size = 0;
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected File getTempFile() {
0:         if (txfFile == null) {
0:             txfFile = new File(getPageFile().getDirectory(), IOHelper.toFileSystemSafeName(Long.toString(getWriteTransactionId())) + ".tmp");
0:         }
0:        return txfFile;
0:     }
0: 
0:         size += data.length;
0: 
1:         PageWrite write;
1:         if (size > maxTransactionSize) {
1:             if (tmpFile == null) {
1:                 tmpFile = new RandomAccessFile(getTempFile(), "rw");
0:             }
0:             int location = nextLocation;
1:             tmpFile.seek(nextLocation);
1:             tmpFile.write(data);
1:             nextLocation = location + data.length;
1:             write = new PageWrite(page, location, data.length, getTempFile());
0:         } else {
1:             write = new PageWrite(page, data);
0:         }
1:         writes.put(key, write);
============================================================================