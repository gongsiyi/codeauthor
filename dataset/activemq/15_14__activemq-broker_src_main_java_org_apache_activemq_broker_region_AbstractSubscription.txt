1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:2b99f39: 
1:74a7a8b: import java.io.IOException;
1:ae7de6c: import java.util.Collections;
1:ae7de6c: import java.util.List;
1:74a7a8b: import java.util.concurrent.CopyOnWriteArrayList;
1:ffee8b4: import java.util.concurrent.atomic.AtomicInteger;
1:81b4b9a: 
1:d29ca2a: import javax.jms.InvalidSelectorException;
1:d29ca2a: import javax.jms.JMSException;
1:0def1d4: import javax.management.ObjectName;
1:94b404d: 
1:4098942: import org.apache.activemq.broker.Broker;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ConsumerId;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:2b99f39: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.filter.BooleanExpression;
1:d29ca2a: import org.apache.activemq.filter.DestinationFilter;
1:d29ca2a: import org.apache.activemq.filter.LogicExpression;
1:d29ca2a: import org.apache.activemq.filter.MessageEvaluationContext;
1:d29ca2a: import org.apache.activemq.filter.NoLocalExpression;
1:d29ca2a: import org.apache.activemq.selector.SelectorParser;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2b99f39: 
1:fc00993: public abstract class AbstractSubscription implements Subscription {
1:74a7a8b: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(AbstractSubscription.class);
1:81b4b9a: 
1:4098942:     protected Broker broker;
1:d29ca2a:     protected ConnectionContext context;
1:d29ca2a:     protected ConsumerInfo info;
1:fc00993:     protected final DestinationFilter destinationFilter;
1:ecf89a6:     protected final CopyOnWriteArrayList<Destination> destinations = new CopyOnWriteArrayList<Destination>();
1:ffee8b4:     protected final AtomicInteger prefetchExtension = new AtomicInteger(0);
1:81b4b9a: 
1:687badb:     private boolean usePrefetchExtension = true;
1:5371cf5:     private BooleanExpression selectorExpression;
1:0def1d4:     private ObjectName objectName;
1:785454a:     private int cursorMemoryHighWaterMark = 70;
1:1b6d397:     private boolean slowConsumer;
1:2b99f39:     private long lastAckTime;
1:eece576:     private final SubscriptionStatistics subscriptionStatistics = new SubscriptionStatistics();
1:230a86c: 
1:16f2d75:     public AbstractSubscription(Broker broker,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
1:4098942:         this.broker = broker;
1:d29ca2a:         this.context = context;
1:d29ca2a:         this.info = info;
1:d29ca2a:         this.destinationFilter = DestinationFilter.parseFilter(info.getDestination());
1:5371cf5:         this.selectorExpression = parseSelector(info);
1:2b99f39:         this.lastAckTime = System.currentTimeMillis();
1:d29ca2a:     }
1:230a86c: 
1:fc00993:     private static BooleanExpression parseSelector(ConsumerInfo info) throws InvalidSelectorException {
1:230a86c:         BooleanExpression rc = null;
1:230a86c:         if (info.getSelector() != null) {
1:1ab76f7:             rc = SelectorParser.parse(info.getSelector());
1:d29ca2a:         }
1:230a86c:         if (info.isNoLocal()) {
1:230a86c:             if (rc == null) {
1:d29ca2a:                 rc = new NoLocalExpression(info.getConsumerId().getConnectionId());
1:d29ca2a:             } else {
1:d29ca2a:                 rc = LogicExpression.createAND(new NoLocalExpression(info.getConsumerId().getConnectionId()), rc);
1:d29ca2a:             }
1:d29ca2a:         }
1:230a86c:         if (info.getAdditionalPredicate() != null) {
1:230a86c:             if (rc == null) {
1:d29ca2a:                 rc = info.getAdditionalPredicate();
1:d29ca2a:             } else {
1:d29ca2a:                 rc = LogicExpression.createAND(info.getAdditionalPredicate(), rc);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:2b99f39:     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
1:2b99f39:         this.lastAckTime = System.currentTimeMillis();
1:eece576:         subscriptionStatistics.getConsumedCount().increment();
1:2b99f39:     }
1:2b99f39: 
1:2b99f39:     @Override
1:fbb26ba:     public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {
1:d29ca2a:         ConsumerId targetConsumerId = node.getTargetConsumerId();
1:230a86c:         if (targetConsumerId != null) {
1:ecf89a6:             if (!targetConsumerId.equals(info.getConsumerId())) {
1:d29ca2a:                 return false;
1:ecf89a6:             }
1:d29ca2a:         }
1:d29ca2a:         try {
1:5371cf5:             return (selectorExpression == null || selectorExpression.matches(context)) && this.context.isAllowedToConsume(node);
1:d29ca2a:         } catch (JMSException e) {
1:e1bbde7:             LOG.info("Selector failed to evaluate: {}", e.getMessage(), e);
1:d29ca2a:             return false;
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:94b404d:     public boolean isWildcard() {
1:94b404d:         return destinationFilter.isWildcard();
1:94b404d:     }
1:94b404d: 
1:94b404d:     @Override
1:d29ca2a:     public boolean matches(ActiveMQDestination destination) {
1:d29ca2a:         return destinationFilter.matches(destination);
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:7f5213b:     public void add(ConnectionContext context, Destination destination) throws Exception {
1:d29ca2a:         destinations.add(destination);
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:ae7de6c:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:d29ca2a:         destinations.remove(destination);
1:ae7de6c:         return Collections.EMPTY_LIST;
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:d29ca2a:     public ConsumerInfo getConsumerInfo() {
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:230a86c:     public void gc() {
1:d29ca2a:     }
1:230a86c: 
1:2b99f39:     @Override
1:95d0dec:     public ConnectionContext getContext() {
1:95d0dec:         return context;
1:d29ca2a:     }
1:f5f1366: 
1:95d0dec:     public ConsumerInfo getInfo() {
1:95d0dec:         return info;
1:785454a:     }
13:d29ca2a: 
1:5371cf5:     public BooleanExpression getSelectorExpression() {
1:5371cf5:         return selectorExpression;
1:4098942:     }
1:230a86c: 
1:2b99f39:     @Override
1:5371cf5:     public String getSelector() {
1:5371cf5:         return info.getSelector();
1:5371cf5:     }
1:230a86c: 
1:2b99f39:     @Override
1:5371cf5:     public void setSelector(String selector) throws InvalidSelectorException {
1:5371cf5:         ConsumerInfo copy = info.copy();
1:5371cf5:         copy.setSelector(selector);
1:5371cf5:         BooleanExpression newSelector = parseSelector(copy);
1:5371cf5:         // its valid so lets actually update it now
1:5371cf5:         info.setSelector(selector);
1:5371cf5:         this.selectorExpression = newSelector;
1:5371cf5:     }
1:d29ca2a: 
1:2b99f39:     @Override
1:0def1d4:     public ObjectName getObjectName() {
1:0def1d4:         return objectName;
1:0def1d4:     }
1:d29ca2a: 
1:2b99f39:     @Override
1:0def1d4:     public void setObjectName(ObjectName objectName) {
1:0def1d4:         this.objectName = objectName;
1:0def1d4:     }
1:230a86c: 
1:2b99f39:     @Override
1:f5f1366:     public int getPrefetchSize() {
1:f5f1366:         return info.getPrefetchSize();
1:f5f1366:     }
1:81b4b9a: 
1:687badb:     public boolean isUsePrefetchExtension() {
1:687badb:         return usePrefetchExtension;
1:687badb:     }
1:687badb: 
1:687badb:     public void setUsePrefetchExtension(boolean usePrefetchExtension) {
1:687badb:         this.usePrefetchExtension = usePrefetchExtension;
1:687badb:     }
1:687badb: 
1:fc63a92:     public void setPrefetchSize(int newSize) {
1:fc63a92:         info.setPrefetchSize(newSize);
1:fc63a92:     }
1:230a86c: 
1:2b99f39:     @Override
1:230a86c:     public boolean isRecoveryRequired() {
1:4eef609:         return true;
1:4eef609:     }
1:2b99f39: 
1:2b99f39:     @Override
1:1b6d397:     public boolean isSlowConsumer() {
1:1b6d397:         return slowConsumer;
1:1b6d397:     }
1:2b99f39: 
1:1b6d397:     public void setSlowConsumer(boolean val) {
1:1b6d397:         slowConsumer = val;
1:1b6d397:     }
1:230a86c: 
1:2b99f39:     @Override
1:230a86c:     public boolean addRecoveredMessage(ConnectionContext context, MessageReference message) throws Exception {
1:a110604:         boolean result = false;
1:a110604:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
1:a110604:         try {
1:9a8f6e4:             Destination regionDestination = (Destination) message.getRegionDestination();
1:9a8f6e4:             msgContext.setDestination(regionDestination.getActiveMQDestination());
1:a110604:             msgContext.setMessageReference(message);
1:230a86c:             result = matches(message, msgContext);
1:a110604:             if (result) {
1:a110604:                 doAddRecoveredMessage(message);
1:a110604:             }
1:230a86c:         } finally {
1:a110604:             msgContext.clear();
1:a110604:         }
1:a110604:         return result;
1:a110604:     }
1:2b99f39: 
1:2b99f39:     @Override
1:230a86c:     public ActiveMQDestination getActiveMQDestination() {
1:a110604:         return info != null ? info.getDestination() : null;
1:d4382e4:     }
1:2b99f39: 
1:2b99f39:     @Override
1:d4382e4:     public boolean isBrowser() {
1:d4382e4:         return info != null && info.isBrowser();
1:d4382e4:     }
1:2b99f39: 
1:2b99f39:     @Override
1:4605503:     public long getInFlightMessageSize() {
1:4605503:         return subscriptionStatistics.getInflightMessageSize().getTotalSize();
1:4605503:     }
1:4605503: 
1:4605503:     @Override
1:d4382e4:     public int getInFlightUsage() {
1:42dabb7:         int prefetchSize = info.getPrefetchSize();
1:42dabb7:         if (prefetchSize > 0) {
1:42dabb7:             return (getInFlightSize() * 100) / prefetchSize;
1:d4382e4:         }
1:d4382e4:         return Integer.MAX_VALUE;
1:cdc2fd3:     }
1:2b99f39: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Add a destination
1:cdc2fd3:      * @param destination
1:cdc2fd3:      */
1:cdc2fd3:     public void addDestination(Destination destination) {
1:cdc2fd3:     }
1:2b99f39: 
1:cdc2fd3:     /**
1:cdc2fd3:      * Remove a destination
1:cdc2fd3:      * @param destination
1:cdc2fd3:      */
1:cdc2fd3:     public void removeDestination(Destination destination) {
1:c8bd57c:     }
1:2b99f39: 
1:2b99f39:     @Override
1:2b99f39:     public int getCursorMemoryHighWaterMark(){
1:2b99f39:         return this.cursorMemoryHighWaterMark;
1:2b99f39:     }
1:2b99f39: 
1:2b99f39:     @Override
1:2b99f39:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark){
1:2b99f39:         this.cursorMemoryHighWaterMark=cursorMemoryHighWaterMark;
1:2b99f39:     }
1:2b99f39: 
1:2b99f39:     @Override
1:c8bd57c:     public int countBeforeFull() {
1:ea03bb1:         return info.getPrefetchSize() - getDispatchedQueueSize();
1:785454a:     }
1:230a86c: 
1:2b99f39:     @Override
1:306f8a0:     public void unmatched(MessageReference node) throws IOException {
1:306f8a0:         // only durable topic subs have something to do here
1:306f8a0:     }
1:230a86c: 
1:a110604:     protected void doAddRecoveredMessage(MessageReference message) throws Exception {
1:a110604:         add(message);
1:a110604:     }
1:2b99f39: 
1:2b99f39:     @Override
1:2b99f39:     public long getTimeOfLastMessageAck() {
1:2b99f39:         return lastAckTime;
1:2b99f39:     }
1:2b99f39: 
1:2b99f39:     public void setTimeOfLastMessageAck(long value) {
1:2b99f39:         this.lastAckTime = value;
1:07ec890:     }
1:07ec890: 
1:81b4b9a:     @Override
1:6683eb6:     public long getConsumedCount(){
1:eece576:         return subscriptionStatistics.getConsumedCount().getCount();
1:6683eb6:     }
1:6683eb6: 
1:81b4b9a:     @Override
1:6683eb6:     public void incrementConsumedCount(){
1:eece576:         subscriptionStatistics.getConsumedCount().increment();
1:6683eb6:     }
1:6683eb6: 
1:81b4b9a:     @Override
1:6683eb6:     public void resetConsumedCount(){
1:eece576:         subscriptionStatistics.getConsumedCount().reset();
1:eece576:     }
1:eece576: 
1:eece576:     @Override
1:eece576:     public SubscriptionStatistics getSubscriptionStatistics() {
1:eece576:         return subscriptionStatistics;
1:2b99f39:     }
1:ffee8b4: 
1:ffee8b4:     public void wakeupDestinationsForDispatch() {
1:ffee8b4:         for (Destination dest : destinations) {
1:ffee8b4:             dest.wakeup();
1:ffee8b4:         }
1:ffee8b4:     }
1:ffee8b4: 
1:ffee8b4:     public AtomicInteger getPrefetchExtension() {
1:ffee8b4:         return this.prefetchExtension;
1:ffee8b4:     }
1:41a1007: 
1:41a1007:     protected void contractPrefetchExtension(int amount) {
1:41a1007:         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
1:41a1007:             decrementPrefetchExtension(amount);
1:41a1007:         }
1:41a1007:     }
1:41a1007: 
1:41a1007:     protected void expandPrefetchExtension(int amount) {
1:41a1007:         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
1:41a1007:             incrementPrefetchExtension(amount);
1:41a1007:         }
1:41a1007:     }
1:41a1007: 
1:41a1007:     protected void decrementPrefetchExtension(int amount) {
1:41a1007:         while (true) {
1:41a1007:             int currentExtension = prefetchExtension.get();
1:41a1007:             int newExtension = Math.max(0, currentExtension - amount);
1:41a1007:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:41a1007:                 break;
1:41a1007:             }
1:41a1007:         }
1:41a1007:     }
1:41a1007: 
1:41a1007:     private void incrementPrefetchExtension(int amount) {
1:41a1007:         while (true) {
1:41a1007:             int currentExtension = prefetchExtension.get();
1:41a1007:             int newExtension = Math.max(currentExtension, currentExtension + amount);
1:41a1007:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:41a1007:                 break;
1:41a1007:             }
1:41a1007:         }
1:41a1007:     }
1:41a1007: 
1:a110604: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void contractPrefetchExtension(int amount) {
1:         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
1:             decrementPrefetchExtension(amount);
1:         }
1:     }
1: 
1:     protected void expandPrefetchExtension(int amount) {
1:         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
1:             incrementPrefetchExtension(amount);
1:         }
1:     }
1: 
1:     protected void decrementPrefetchExtension(int amount) {
1:         while (true) {
1:             int currentExtension = prefetchExtension.get();
1:             int newExtension = Math.max(0, currentExtension - amount);
1:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                 break;
1:             }
1:         }
1:     }
1: 
1:     private void incrementPrefetchExtension(int amount) {
1:         while (true) {
1:             int currentExtension = prefetchExtension.get();
1:             int newExtension = Math.max(currentExtension, currentExtension + amount);
1:             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                 break;
1:             }
1:         }
1:     }
1: 
commit:ffee8b4
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:     protected final AtomicInteger prefetchExtension = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void wakeupDestinationsForDispatch() {
1:         for (Destination dest : destinations) {
1:             dest.wakeup();
1:         }
1:     }
1: 
1:     public AtomicInteger getPrefetchExtension() {
1:         return this.prefetchExtension;
1:     }
author:Vasco Veloso
-------------------------------------------------------------------------------
commit:687badb
/////////////////////////////////////////////////////////////////////////
1:     private boolean usePrefetchExtension = true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUsePrefetchExtension() {
1:         return usePrefetchExtension;
1:     }
1: 
1:     public void setUsePrefetchExtension(boolean usePrefetchExtension) {
1:         this.usePrefetchExtension = usePrefetchExtension;
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:42dabb7
/////////////////////////////////////////////////////////////////////////
1:         int prefetchSize = info.getPrefetchSize();
1:         if (prefetchSize > 0) {
1:             return (getInFlightSize() * 100) / prefetchSize;
commit:4605503
/////////////////////////////////////////////////////////////////////////
1:     public long getInFlightMessageSize() {
1:         return subscriptionStatistics.getInflightMessageSize().getTotalSize();
1:     }
1: 
1:     @Override
commit:ea03bb1
/////////////////////////////////////////////////////////////////////////
1:         return info.getPrefetchSize() - getDispatchedQueueSize();
commit:eece576
/////////////////////////////////////////////////////////////////////////
1:     private final SubscriptionStatistics subscriptionStatistics = new SubscriptionStatistics();
/////////////////////////////////////////////////////////////////////////
1:         subscriptionStatistics.getConsumedCount().increment();
/////////////////////////////////////////////////////////////////////////
0:             return (getInFlightSize() * 100)/info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
1:         return subscriptionStatistics.getConsumedCount().getCount();
1:         subscriptionStatistics.getConsumedCount().increment();
1:         subscriptionStatistics.getConsumedCount().reset();
1:     }
1: 
1:     @Override
1:     public SubscriptionStatistics getSubscriptionStatistics() {
1:         return subscriptionStatistics;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:81b4b9a
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Selector failed to evaluate: {}", e.getMessage(), e);
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:94b404d
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean isWildcard() {
1:         return destinationFilter.isWildcard();
1:     }
1: 
1:     @Override
author:rajdavies
-------------------------------------------------------------------------------
commit:6683eb6
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private AtomicLong consumedCount = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0:         this.consumedCount.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:     public long getConsumedCount(){
0:         return consumedCount.get();
1:     }
1: 
1:     public void incrementConsumedCount(){
0:         consumedCount.incrementAndGet();
1:     }
1: 
1:     public void resetConsumedCount(){
0:         consumedCount.set(0);
author:Rob Davies
-------------------------------------------------------------------------------
commit:07ec890
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.management.CountStatisticImpl;
/////////////////////////////////////////////////////////////////////////
0:     private CountStatisticImpl consumedCount = new CountStatisticImpl("consumed","The number of messages consumed");
/////////////////////////////////////////////////////////////////////////
0:         this.consumedCount.increment();
/////////////////////////////////////////////////////////////////////////
1: 
0:     public CountStatisticImpl getConsumedCount(){
0:         return consumedCount;
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2b99f39
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
1:     private long lastAckTime;
/////////////////////////////////////////////////////////////////////////
1:         this.lastAckTime = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
1:         this.lastAckTime = System.currentTimeMillis();
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1: 
1:     @Override
1: 
1: 
1: 
1: 
1:     @Override
1:     public int getCursorMemoryHighWaterMark(){
1:         return this.cursorMemoryHighWaterMark;
1:     }
1: 
1:     @Override
1:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark){
1:         this.cursorMemoryHighWaterMark=cursorMemoryHighWaterMark;
1:     }
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public long getTimeOfLastMessageAck() {
1:         return lastAckTime;
1:     }
1: 
1:     public void setTimeOfLastMessageAck(long value) {
1:         this.lastAckTime = value;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:30f531d
/////////////////////////////////////////////////////////////////////////
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:             Destination regionDestination = (Destination) message.getRegionDestination();
1:             msgContext.setDestination(regionDestination.getActiveMQDestination());
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:         return Collections.EMPTY_LIST;
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     protected final CopyOnWriteArrayList<Destination> destinations = new CopyOnWriteArrayList<Destination>();
/////////////////////////////////////////////////////////////////////////
1:             if (!targetConsumerId.equals(info.getConsumerId())) {
1:             }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractSubscription implements Subscription {
0:     private static final Log LOG = LogFactory.getLog(AbstractSubscription.class);
1:     protected final DestinationFilter destinationFilter;
0:     protected final CopyOnWriteArrayList destinations = new CopyOnWriteArrayList();
/////////////////////////////////////////////////////////////////////////
1:     private static BooleanExpression parseSelector(ConsumerInfo info) throws InvalidSelectorException {
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Selector failed to evaluate: " + e.getMessage(), e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
0:     public AbstractSubscription(Broker broker, ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
1: 
1:         BooleanExpression rc = null;
1:         if (info.getSelector() != null) {
1:         if (info.isNoLocal()) {
1:             if (rc == null) {
1:         if (info.getAdditionalPredicate() != null) {
1:             if (rc == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (targetConsumerId != null) {
0:             if (!targetConsumerId.equals(info.getConsumerId()))
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void gc() {
1: 
0:     public boolean isSlave() {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public boolean isRecoveryRequired() {
1: 
1:     public boolean addRecoveredMessage(ConnectionContext context, MessageReference message) throws Exception {
1:             result = matches(message, msgContext);
1: 
1:         } finally {
1: 
1:     public ActiveMQDestination getActiveMQDestination() {
1: 
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f5f1366
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getPrefetchSize() {
1:         return info.getPrefetchSize();
1:     }
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void add(ConnectionContext context, Destination destination) throws Exception {
0:     public void remove(ConnectionContext context, Destination destination) throws Exception {
commit:013f372
/////////////////////////////////////////////////////////////////////////
0:     static private final Log log = LogFactory.getLog(AbstractSubscription.class);
/////////////////////////////////////////////////////////////////////////
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
1: 
1: import javax.jms.InvalidSelectorException;
1: import javax.jms.JMSException;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.filter.BooleanExpression;
1: import org.apache.activemq.filter.DestinationFilter;
1: import org.apache.activemq.filter.LogicExpression;
1: import org.apache.activemq.filter.MessageEvaluationContext;
1: import org.apache.activemq.filter.NoLocalExpression;
1: import org.apache.activemq.selector.SelectorParser;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
1: 
0: abstract public class AbstractSubscription implements Subscription {
1:     
0:     protected final Log log;
1:     
1:     protected ConnectionContext context;
1:     protected ConsumerInfo info;
0:     final protected DestinationFilter destinationFilter;
0:     final protected BooleanExpression selector;
1:    
0:     final protected CopyOnWriteArrayList destinations = new CopyOnWriteArrayList();
1: 
0:     public AbstractSubscription(ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {        
1:         this.context = context;
1:         this.info = info;
1:         this.destinationFilter = DestinationFilter.parseFilter(info.getDestination());
0:         this.selector = parseSelector(info);
0:         this.log = LogFactory.getLog(getClass().getName()+"."+info.getConsumerId());
1:     }
1:     
0:     static private BooleanExpression parseSelector(ConsumerInfo info) throws InvalidSelectorException {
0:         BooleanExpression rc=null;
0:         if( info.getSelector() !=null ) {
0:             rc = new SelectorParser().parse(info.getSelector());
1:         }
0:         if( info.isNoLocal() ) {
0:             if( rc == null ) {
1:                 rc = new NoLocalExpression(info.getConsumerId().getConnectionId());
1:             } else {
1:                 rc = LogicExpression.createAND(new NoLocalExpression(info.getConsumerId().getConnectionId()), rc);
1:             }
1:         }
0:         if( info.getAdditionalPredicate() != null ) {
0:             if( rc == null ) {
1:                 rc = info.getAdditionalPredicate();
1:             } else {
1:                 rc = LogicExpression.createAND(info.getAdditionalPredicate(), rc);
1:             }
1:         }
1:         return rc;
1:     }
1: 
0:     public boolean matches(MessageReference node, MessageEvaluationContext context) {
1:         ConsumerId targetConsumerId = node.getTargetConsumerId();
0:         if ( targetConsumerId!=null) {
0:             if( !targetConsumerId.equals(info.getConsumerId()) )
1:                 return false;
1:         }
1:         try {
0:             return selector == null || selector.matches(context);
1:         } catch (JMSException e) {
0:             log.info("Selector failed to evaluate: " + e.getMessage(), e);
1:             return false;
1:         }
1:     }
1:     
1:     public boolean matches(ActiveMQDestination destination) {
1:         return destinationFilter.matches(destination);
1:     }
1: 
0:     public void add(ConnectionContext context, Destination destination) throws Throwable {
1:         destinations.add(destination);
1:     }
1: 
0:     public void remove(ConnectionContext context, Destination destination) throws Throwable {
1:         destinations.remove(destination);
1:     }
1:     
1:     public ConsumerInfo getConsumerInfo() {
1:         return info;
1:     }
1:     
0:     public void gc() {        
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(AbstractSubscription.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:306f8a0
/////////////////////////////////////////////////////////////////////////
1:     public void unmatched(MessageReference node) throws IOException {
1:         // only durable topic subs have something to do here
1:     }
0: 
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1:     private boolean slowConsumer;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isSlowConsumer() {
1:         return slowConsumer;
1:     }
0:     
1:     public void setSlowConsumer(boolean val) {
1:         slowConsumer = val;
1:     }
author:Robert Davies
-------------------------------------------------------------------------------
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:     private int cursorMemoryHighWaterMark = 70;
/////////////////////////////////////////////////////////////////////////
0:     public int getCursorMemoryHighWaterMark(){
0:     	return this.cursorMemoryHighWaterMark;
1:     }
0: 
0: 	public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark){
0: 		this.cursorMemoryHighWaterMark=cursorMemoryHighWaterMark;
1: 	}
0:     
commit:fc63a92
/////////////////////////////////////////////////////////////////////////
1:     public void setPrefetchSize(int newSize) {
1:         info.setPrefetchSize(newSize);
1:     }
commit:c8bd57c
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
0:     
1:     public int countBeforeFull() {
0:         return getDispatchedQueueSize() - info.getPrefetchSize();
1:     }
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Add a destination
1:      * @param destination
1:      */
1:     public void addDestination(Destination destination) {
0:         
1:     }
0:     
0:     
1:     /**
1:      * Remove a destination
1:      * @param destination
1:      */
1:     public void removeDestination(Destination destination) {
0:         
1:     }
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public AbstractSubscription(Broker broker,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:     protected Destination destination;
/////////////////////////////////////////////////////////////////////////
0:     public AbstractSubscription(Broker broker, Destination destination,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         this.destination=destination;
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isBrowser() {
1:         return info != null && info.isBrowser();
1:     }
0:     
1:     public int getInFlightUsage() {
0:         if (info.getPrefetchSize() > 0) {
0:         return (getInFlightSize() * 100)/info.getPrefetchSize();
1:         }
1:         return Integer.MAX_VALUE;
1:     }
commit:1d7b884
/////////////////////////////////////////////////////////////////////////
0:         return broker.getBrokerService().isSlave();
commit:83a6eff
/////////////////////////////////////////////////////////////////////////
0:     public boolean isSlave(){
0:         return getContext().isSlave();
commit:a110604
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean addRecoveredMessage(ConnectionContext context, MessageReference message) throws Exception{
1:         boolean result = false;
1:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
1:         try {
0:             msgContext.setDestination(message.getRegionDestination().getActiveMQDestination());
1:             msgContext.setMessageReference(message);
0:             result = matches(message,msgContext);
1:             if (result) {
1:                 doAddRecoveredMessage(message);
1:             }
0:             
0:         }finally {
1:             msgContext.clear();
1:         }
1:         return result;
1:     }
0:     
0:     public  ActiveMQDestination getActiveMQDestination() {
1:         return info != null ? info.getDestination() : null;
1:     }
0:     
1:     protected void doAddRecoveredMessage(MessageReference message) throws Exception {
1:         add(message);
1:     }
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isRecoveryRequired(){
1:         return true;
1:     }
commit:4098942
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
1:     protected Broker broker;
/////////////////////////////////////////////////////////////////////////
0:     public AbstractSubscription(Broker broker,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {        
1:         this.broker = broker;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isSlaveBroker(){
0:         return broker.isSlaveBroker();
1:     }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1ab76f7
/////////////////////////////////////////////////////////////////////////
1:             rc = SelectorParser.parse(info.getSelector());
author:James Strachan
-------------------------------------------------------------------------------
commit:0def1d4
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
1:     private ObjectName objectName;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public ObjectName getObjectName() {
1:         return objectName;
1:     }
0: 
1:     public void setObjectName(ObjectName objectName) {
1:         this.objectName = objectName;
1:     }
commit:5371cf5
/////////////////////////////////////////////////////////////////////////
1:     private BooleanExpression selectorExpression;
/////////////////////////////////////////////////////////////////////////
1:         this.selectorExpression = parseSelector(info);
/////////////////////////////////////////////////////////////////////////
1:             return (selectorExpression == null || selectorExpression.matches(context)) && this.context.isAllowedToConsume(node);
/////////////////////////////////////////////////////////////////////////
1:     public BooleanExpression getSelectorExpression() {
1:         return selectorExpression;
1:     }
0:     
1:     public String getSelector() {
1:         return info.getSelector();
1:     }
0:     
1:     public void setSelector(String selector) throws InvalidSelectorException {
1:         ConsumerInfo copy = info.copy();
1:         copy.setSelector(selector);
1:         BooleanExpression newSelector = parseSelector(copy);
1:         // its valid so lets actually update it now
1:         info.setSelector(selector);
1:         this.selectorExpression = newSelector;
commit:95d0dec
/////////////////////////////////////////////////////////////////////////
0: 
1:     public ConnectionContext getContext() {
1:         return context;
0:     }
0: 
1:     public ConsumerInfo getInfo() {
1:         return info;
0:     }
0: 
0:     public BooleanExpression getSelector() {
0:         return selector;
0:     }
commit:fbb26ba
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {
0:             return (selector == null || selector.matches(context)) && this.context.isAllowedToConsume(node);
============================================================================