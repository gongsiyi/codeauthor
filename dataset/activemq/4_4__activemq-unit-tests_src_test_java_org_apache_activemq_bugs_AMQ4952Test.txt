1:9b00a09: /**
1:9b00a09:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9b00a09:  * contributor license agreements.  See the NOTICE file distributed with
1:9b00a09:  * this work for additional information regarding copyright ownership.
1:9b00a09:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9b00a09:  * (the "License"); you may not use this file except in compliance with
1:9b00a09:  * the License.  You may obtain a copy of the License at
1:9b00a09:  *
1:9b00a09:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9b00a09:  *
1:9b00a09:  * Unless required by applicable law or agreed to in writing, software
1:9b00a09:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9b00a09:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9b00a09:  * See the License for the specific language governing permissions and
1:9b00a09:  * limitations under the License.
1:9b00a09:  */
22:f92d45b: 
1:f92d45b: package org.apache.activemq.bugs;
1:f92d45b: 
1:c6837ac: import java.io.File;
1:f92d45b: import java.net.URI;
1:9b00a09: import java.sql.PreparedStatement;
1:9b00a09: import java.sql.ResultSet;
1:9b00a09: import java.sql.ResultSetMetaData;
1:9b00a09: import java.sql.SQLException;
1:f92d45b: import java.util.ArrayList;
1:08f21ed: import java.util.Arrays;
1:f92d45b: import java.util.HashMap;
1:f92d45b: import java.util.List;
1:9b00a09: import java.util.concurrent.Callable;
1:9b00a09: import java.util.concurrent.CountDownLatch;
1:9b00a09: import java.util.concurrent.ExecutorService;
1:9b00a09: import java.util.concurrent.Executors;
1:9b00a09: import java.util.concurrent.Future;
1:9b00a09: import java.util.concurrent.TimeUnit;
1:f92d45b: 
1:f92d45b: import javax.jms.Connection;
1:9b00a09: import javax.jms.JMSException;
1:9b00a09: import javax.jms.MessageConsumer;
1:9b00a09: import javax.jms.MessageProducer;
1:9b00a09: import javax.jms.Session;
1:9b00a09: import javax.jms.TextMessage;
1:f92d45b: import javax.sql.DataSource;
1:f92d45b: 
1:f92d45b: import org.apache.activemq.ActiveMQConnectionFactory;
1:9b00a09: import org.apache.activemq.broker.Broker;
1:9b00a09: import org.apache.activemq.broker.BrokerFilter;
1:9b00a09: import org.apache.activemq.broker.BrokerPlugin;
1:9b00a09: import org.apache.activemq.broker.BrokerService;
1:9b00a09: import org.apache.activemq.broker.ProducerBrokerExchange;
1:9b00a09: import org.apache.activemq.broker.TransportConnector;
1:f92d45b: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:f92d45b: import org.apache.activemq.broker.region.policy.PolicyMap;
1:9b00a09: import org.apache.activemq.command.ActiveMQDestination;
1:9b00a09: import org.apache.activemq.command.ActiveMQQueue;
1:f92d45b: import org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory;
1:f92d45b: import org.apache.activemq.network.NetworkConnector;
1:165959e: import org.apache.activemq.store.jdbc.DataSourceServiceSupport;
1:f92d45b: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1:c6837ac: import org.apache.activemq.util.IOHelper;
1:f92d45b: import org.apache.activemq.util.IntrospectionSupport;
1:f92d45b: import org.apache.activemq.util.Wait;
1:f92d45b: import org.apache.derby.jdbc.EmbeddedDataSource;
1:cc47ab6: import org.junit.After;
1:cc47ab6: import org.junit.Before;
1:c6837ac: import org.junit.BeforeClass;
1:cc47ab6: import org.junit.Test;
1:cc47ab6: import org.junit.runner.RunWith;
1:cc47ab6: import org.junit.runners.Parameterized;
1:f92d45b: import org.slf4j.Logger;
1:f92d45b: import org.slf4j.LoggerFactory;
1:f92d45b: 
1:3df943c: import static org.junit.Assert.*;
1:f92d45b: 
1:f92d45b: /**
1:9b00a09:  * Test creates a broker network with two brokers - producerBroker (with a
1:9b00a09:  * message producer attached) and consumerBroker (with consumer attached)
1:f92d45b:  * <p/>
1:9b00a09:  * Simulates network duplicate message by stopping and restarting the
1:9b00a09:  * consumerBroker after message (with message ID ending in 120) is persisted to
1:9b00a09:  * consumerBrokerstore BUT BEFORE ack sent to the producerBroker over the
1:9b00a09:  * network connection. When the network connection is reestablished the
1:9b00a09:  * producerBroker resends message (with messageID ending in 120).
1:f92d45b:  * <p/>
1:f92d45b:  * Expectation:
1:f92d45b:  * <p/>
1:9b00a09:  * With the following policy entries set, would expect the duplicate message to
1:9b00a09:  * be read from the store and dispatched to the consumer - where the duplicate
1:9b00a09:  * could be detected by consumer.
1:f92d45b:  * <p/>
1:9b00a09:  * PolicyEntry policy = new PolicyEntry(); policy.setQueue(">");
1:9b00a09:  * policy.setEnableAudit(false); policy.setUseCache(false);
1:f92d45b:  * policy.setExpireMessagesPeriod(0);
1:f92d45b:  * <p/>
1:f92d45b:  * <p/>
1:9b00a09:  * Note 1: Network needs to use replaywhenNoConsumers so enabling the
1:9b00a09:  * networkAudit to avoid this scenario is not feasible.
1:f92d45b:  * <p/>
1:9b00a09:  * NOTE 2: Added a custom plugin to the consumerBroker so that the
1:9b00a09:  * consumerBroker shutdown will occur after a message has been persisted to
1:9b00a09:  * consumerBroker store but before an ACK is sent back to ProducerBroker. This
1:9b00a09:  * is just a hack to ensure producerBroker will resend the message after
1:9b00a09:  * shutdown.
1:f92d45b:  */
1:f92d45b: 
1:cc47ab6: @RunWith(value = Parameterized.class)
1:3df943c: public class AMQ4952Test {
1:f92d45b: 
1:f92d45b:     private static final Logger LOG = LoggerFactory.getLogger(AMQ4952Test.class);
1:f92d45b: 
1:f92d45b:     protected static final int MESSAGE_COUNT = 1;
1:f92d45b: 
1:f92d45b:     protected BrokerService consumerBroker;
1:f92d45b:     protected BrokerService producerBroker;
1:f92d45b: 
1:f92d45b:     protected ActiveMQQueue QUEUE_NAME = new ActiveMQQueue("duptest.store");
1:f92d45b: 
1:a9c7f71:     private CountDownLatch stopConsumerBroker;
1:a9c7f71:     private CountDownLatch consumerBrokerRestarted;
1:a9c7f71:     private CountDownLatch consumerRestartedAndMessageForwarded;
1:f92d45b: 
1:f92d45b:     private EmbeddedDataSource localDataSource;
1:f92d45b: 
1:cc47ab6:     @Parameterized.Parameter(0)
1:cc47ab6:     public boolean enableCursorAudit;
1:f92d45b: 
1:9b00a09:     @Parameterized.Parameters(name = "enableAudit={0}")
1:cc47ab6:     public static Iterable<Object[]> getTestParameters() {
1:9b00a09:         return Arrays.asList(new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } });
1:cc47ab6:     }
1:cc47ab6: 
1:c6837ac:     @BeforeClass
1:c6837ac:     public static void dbHomeSysProp() throws Exception {
1:c6837ac:         System.setProperty("derby.system.home", new File(IOHelper.getDefaultDataDirectory()).getCanonicalPath());
1:c6837ac:     }
1:c6837ac: 
1:a9c7f71:     public void repeat() throws Exception {
1:a9c7f71:         for (int i=0; i<10; i++) {
1:a9c7f71:             LOG.info("Iteration: " + i);
1:a9c7f71:             testConsumerBrokerRestart();
1:a9c7f71:             tearDown();
1:a9c7f71:             setUp();
1:a9c7f71:         }
1:a9c7f71:     }
1:a9c7f71: 
1:cc47ab6:     @Test
1:f92d45b:     public void testConsumerBrokerRestart() throws Exception {
1:f92d45b: 
1:f92d45b:         Callable consumeMessageTask = new Callable() {
1:f92d45b:             @Override
1:f92d45b:             public Object call() throws Exception {
1:f92d45b: 
1:f92d45b:                 int receivedMessageCount = 0;
1:f92d45b: 
1:f92d45b:                 ActiveMQConnectionFactory consumerFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:2006)?randomize=false&backup=false");
1:f92d45b:                 Connection consumerConnection = consumerFactory.createConnection();
1:f92d45b: 
1:f92d45b:                 try {
1:f92d45b: 
1:f92d45b:                     consumerConnection.setClientID("consumer");
1:f92d45b:                     consumerConnection.start();
1:f92d45b: 
1:f92d45b:                     Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:f92d45b:                     MessageConsumer messageConsumer = consumerSession.createConsumer(QUEUE_NAME);
1:f92d45b: 
1:f92d45b:                     while (true) {
1:a9c7f71:                         TextMessage textMsg = (TextMessage) messageConsumer.receive(1000);
1:a9c7f71: 
1:a9c7f71:                         if (textMsg == null) {
1:a9c7f71:                             textMsg = (TextMessage) messageConsumer.receive(4000);
1:a9c7f71:                         }
1:f92d45b: 
1:f92d45b:                         if (textMsg == null) {
1:f92d45b:                             return receivedMessageCount;
1:f92d45b:                         }
1:f92d45b: 
1:f92d45b:                         receivedMessageCount++;
1:f92d45b:                         LOG.info("*** receivedMessageCount {} message has MessageID {} ", receivedMessageCount, textMsg.getJMSMessageID());
1:f92d45b: 
1:9b00a09:                         // on first delivery ensure the message is pending an
1:9b00a09:                         // ack when it is resent from the producer broker
1:f92d45b:                         if (textMsg.getJMSMessageID().endsWith("1") && receivedMessageCount == 1) {
1:f92d45b:                             LOG.info("Waiting for restart...");
1:f92d45b:                             consumerRestartedAndMessageForwarded.await(90, TimeUnit.SECONDS);
1:f92d45b:                         }
1:f92d45b: 
1:f92d45b:                         textMsg.acknowledge();
1:f92d45b:                     }
1:f92d45b:                 } finally {
1:f92d45b:                     consumerConnection.close();
1:f92d45b:                 }
1:f92d45b:             }
1:f92d45b:         };
1:f92d45b: 
1:f92d45b:         Runnable consumerBrokerResetTask = new Runnable() {
1:f92d45b:             @Override
1:f92d45b:             public void run() {
1:f92d45b: 
1:f92d45b:                 try {
1:f92d45b:                     // wait for signal
1:f92d45b:                     stopConsumerBroker.await();
1:f92d45b: 
1:f92d45b:                     LOG.info("********* STOPPING CONSUMER BROKER");
1:f92d45b: 
2:f92d45b:                     consumerBroker.stop();
1:f92d45b:                     consumerBroker.waitUntilStopped();
1:f92d45b: 
1:f92d45b:                     LOG.info("***** STARTING CONSUMER BROKER");
1:9b00a09:                     // do not delete messages on startup
1:f92d45b:                     consumerBroker = createConsumerBroker(false);
1:f92d45b: 
1:f92d45b:                     LOG.info("***** CONSUMER BROKER STARTED!!");
1:f92d45b:                     consumerBrokerRestarted.countDown();
1:f92d45b: 
1:f92d45b:                     assertTrue("message forwarded on time", Wait.waitFor(new Wait.Condition() {
1:f92d45b:                         @Override
1:f92d45b:                         public boolean isSatisified() throws Exception {
1:f92d45b:                             LOG.info("ProducerBroker totalMessageCount: " + producerBroker.getAdminView().getTotalMessageCount());
1:f92d45b:                             return producerBroker.getAdminView().getTotalMessageCount() == 0;
1:f92d45b:                         }
1:f92d45b:                     }));
1:f92d45b:                     consumerRestartedAndMessageForwarded.countDown();
1:f92d45b: 
1:f92d45b:                 } catch (Exception e) {
1:f92d45b:                     LOG.error("Exception when stopping/starting the consumerBroker ", e);
1:f92d45b:                 }
1:f92d45b: 
1:f92d45b:             }
1:f92d45b:         };
1:f92d45b: 
1:f92d45b:         ExecutorService executor = Executors.newFixedThreadPool(2);
1:f92d45b: 
1:9b00a09:         // start consumerBroker start/stop task
1:f92d45b:         executor.execute(consumerBrokerResetTask);
1:f92d45b: 
1:9b00a09:         // start consuming messages
1:f92d45b:         Future<Integer> numberOfConsumedMessage = executor.submit(consumeMessageTask);
1:f92d45b: 
1:f92d45b:         produceMessages();
1:f92d45b: 
1:9b00a09:         // Wait for consumer to finish
1:f92d45b:         int totalMessagesConsumed = numberOfConsumedMessage.get();
1:f92d45b: 
1:f92d45b:         StringBuffer contents = new StringBuffer();
1:f92d45b:         boolean messageInStore = isMessageInJDBCStore(localDataSource, contents);
1:f92d45b:         LOG.debug("****number of messages received " + totalMessagesConsumed);
1:f92d45b: 
1:f92d45b:         assertEquals("number of messages received", 2, totalMessagesConsumed);
1:f92d45b:         assertEquals("messages left in store", true, messageInStore);
1:f92d45b:         assertTrue("message is in dlq: " + contents.toString(), contents.toString().contains("DLQ"));
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     private void produceMessages() throws JMSException {
1:f92d45b: 
1:f92d45b:         ActiveMQConnectionFactory producerFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:2003)?randomize=false&backup=false");
1:f92d45b:         Connection producerConnection = producerFactory.createConnection();
1:f92d45b: 
1:f92d45b:         try {
1:f92d45b:             producerConnection.setClientID("producer");
1:f92d45b:             producerConnection.start();
1:f92d45b: 
1:f92d45b:             Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f92d45b: 
1:f92d45b:             final MessageProducer remoteProducer = producerSession.createProducer(QUEUE_NAME);
1:f92d45b: 
1:f92d45b:             int i = 0;
1:f92d45b:             while (MESSAGE_COUNT > i) {
1:f92d45b:                 String payload = "test msg " + i;
1:f92d45b:                 TextMessage msg = producerSession.createTextMessage(payload);
1:f92d45b:                 remoteProducer.send(msg);
1:f92d45b:                 i++;
1:f92d45b:             }
1:f92d45b: 
1:f92d45b:         } finally {
1:f92d45b:             producerConnection.close();
1:f92d45b:         }
1:f92d45b:     }
1:f92d45b: 
1:cc47ab6:     @Before
1:cc47ab6:     public void setUp() throws Exception {
1:3df943c:         LOG.debug("Running with enableCursorAudit set to {}", this.enableCursorAudit);
1:a9c7f71:         stopConsumerBroker = new CountDownLatch(1);
1:a9c7f71:         consumerBrokerRestarted = new CountDownLatch(1);
1:a9c7f71:         consumerRestartedAndMessageForwarded = new CountDownLatch(1);
1:a9c7f71: 
1:cc47ab6:         doSetUp();
1:f92d45b:     }
1:f92d45b: 
1:cc47ab6:     @After
1:cc47ab6:     public void tearDown() throws Exception {
1:f92d45b:         doTearDown();
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     protected void doTearDown() throws Exception {
1:f92d45b: 
1:165959e:         DataSource dataSource = ((JDBCPersistenceAdapter)producerBroker.getPersistenceAdapter()).getDataSource();
1:f92d45b:         try {
1:cc47ab6:             producerBroker.stop();
1:f92d45b:         } catch (Exception ex) {
1:165959e:         } finally {
1:165959e:             DataSourceServiceSupport.shutdownDefaultDataSource(dataSource);
1:f92d45b:         }
1:165959e:         dataSource = ((JDBCPersistenceAdapter)consumerBroker.getPersistenceAdapter()).getDataSource();
1:f92d45b:         try {
1:f92d45b:             consumerBroker.stop();
1:f92d45b:         } catch (Exception ex) {
1:165959e:         } finally {
1:165959e:             DataSourceServiceSupport.shutdownDefaultDataSource(dataSource);
1:f92d45b:         }
1:f92d45b:     }
1:f92d45b: 
1:cc47ab6:     protected void doSetUp() throws Exception {
1:f92d45b:         producerBroker = createProducerBroker();
1:f92d45b:         consumerBroker = createConsumerBroker(true);
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     /**
1:9b00a09:      * Producer broker listens on localhost:2003 networks to consumerBroker -
1:9b00a09:      * localhost:2006
1:f92d45b:      *
1:f92d45b:      * @return
1:f92d45b:      * @throws Exception
1:f92d45b:      */
1:f92d45b:     protected BrokerService createProducerBroker() throws Exception {
1:f92d45b: 
1:9b00a09:         String networkToPorts[] = new String[] { "2006" };
1:f92d45b:         HashMap<String, String> networkProps = new HashMap<String, String>();
1:f92d45b: 
1:f92d45b:         networkProps.put("networkTTL", "10");
1:f92d45b:         networkProps.put("conduitSubscriptions", "true");
1:f92d45b:         networkProps.put("decreaseNetworkConsumerPriority", "true");
1:f92d45b:         networkProps.put("dynamicOnly", "true");
1:f92d45b: 
1:f92d45b:         BrokerService broker = new BrokerService();
1:f92d45b:         broker.getManagementContext().setCreateConnector(false);
1:f92d45b:         broker.setDeleteAllMessagesOnStartup(true);
1:f92d45b:         broker.setBrokerName("BP");
1:f92d45b:         broker.setAdvisorySupport(false);
1:f92d45b: 
1:f92d45b:         // lazy init listener on broker start
1:f92d45b:         TransportConnector transportConnector = new TransportConnector();
1:f92d45b:         transportConnector.setUri(new URI("tcp://localhost:2003"));
1:f92d45b:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:f92d45b:         transportConnectors.add(transportConnector);
1:f92d45b:         broker.setTransportConnectors(transportConnectors);
1:f92d45b: 
1:9b00a09:         // network to consumerBroker
1:f92d45b: 
1:f92d45b:         if (networkToPorts != null && networkToPorts.length > 0) {
1:f92d45b:             StringBuilder builder = new StringBuilder("static:(failover:(tcp://localhost:2006)?maxReconnectAttempts=0)?useExponentialBackOff=false");
1:f92d45b:             NetworkConnector nc = broker.addNetworkConnector(builder.toString());
1:f92d45b:             if (networkProps != null) {
1:f92d45b:                 IntrospectionSupport.setProperties(nc, networkProps);
1:f92d45b:             }
1:9b00a09:             nc.setStaticallyIncludedDestinations(Arrays.<ActiveMQDestination> asList(new ActiveMQQueue[] { QUEUE_NAME }));
1:f92d45b:         }
1:f92d45b: 
1:9b00a09:         // Persistence adapter
1:f92d45b: 
1:f92d45b:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:f92d45b:         EmbeddedDataSource remoteDataSource = new EmbeddedDataSource();
1:a7ff597:         remoteDataSource.setDatabaseName("target/derbyDBRemoteBroker");
1:f92d45b:         remoteDataSource.setCreateDatabase("create");
1:f92d45b:         jdbc.setDataSource(remoteDataSource);
1:f92d45b:         broker.setPersistenceAdapter(jdbc);
1:f92d45b: 
1:9b00a09:         // set Policy entries
1:f92d45b:         PolicyEntry policy = new PolicyEntry();
1:f92d45b: 
1:f92d45b:         policy.setQueue(">");
1:f92d45b:         policy.setEnableAudit(false);
2:f92d45b:         policy.setUseCache(false);
1:f92d45b:         policy.setExpireMessagesPeriod(0);
1:f92d45b: 
1:f92d45b:         // set replay with no consumers
1:9b00a09:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory = new ConditionalNetworkBridgeFilterFactory();
1:f92d45b:         conditionalNetworkBridgeFilterFactory.setReplayWhenNoConsumers(true);
1:f92d45b:         policy.setNetworkBridgeFilterFactory(conditionalNetworkBridgeFilterFactory);
1:f92d45b: 
1:f92d45b:         PolicyMap pMap = new PolicyMap();
1:f92d45b:         pMap.setDefaultEntry(policy);
1:f92d45b:         broker.setDestinationPolicy(pMap);
1:f92d45b: 
1:f92d45b:         broker.start();
1:f92d45b:         broker.waitUntilStarted();
1:f92d45b: 
1:f92d45b:         return broker;
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     /**
1:9b00a09:      * consumerBroker - listens on localhost:2006
1:f92d45b:      *
1:9b00a09:      * @param deleteMessages
1:9b00a09:      *            - drop messages when broker instance is created
1:f92d45b:      * @return
1:f92d45b:      * @throws Exception
1:f92d45b:      */
1:f92d45b:     protected BrokerService createConsumerBroker(boolean deleteMessages) throws Exception {
1:f92d45b: 
1:f92d45b:         String scheme = "tcp";
1:f92d45b:         String listenPort = "2006";
1:f92d45b: 
1:f92d45b:         BrokerService broker = new BrokerService();
1:f92d45b:         broker.getManagementContext().setCreateConnector(false);
1:f92d45b:         broker.setDeleteAllMessagesOnStartup(deleteMessages);
1:f92d45b:         broker.setBrokerName("BC");
1:f92d45b:         // lazy init listener on broker start
1:f92d45b:         TransportConnector transportConnector = new TransportConnector();
1:f92d45b:         transportConnector.setUri(new URI(scheme + "://localhost:" + listenPort));
1:f92d45b:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:f92d45b:         transportConnectors.add(transportConnector);
1:f92d45b:         broker.setTransportConnectors(transportConnectors);
1:f92d45b: 
1:9b00a09:         // policy entries
1:f92d45b: 
1:f92d45b:         PolicyEntry policy = new PolicyEntry();
1:f92d45b: 
1:f92d45b:         policy.setQueue(">");
1:cc47ab6:         policy.setEnableAudit(enableCursorAudit);
1:f92d45b:         policy.setExpireMessagesPeriod(0);
1:f92d45b: 
1:f92d45b:         // set replay with no consumers
1:9b00a09:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory = new ConditionalNetworkBridgeFilterFactory();
1:f92d45b:         conditionalNetworkBridgeFilterFactory.setReplayWhenNoConsumers(true);
1:f92d45b:         policy.setNetworkBridgeFilterFactory(conditionalNetworkBridgeFilterFactory);
1:f92d45b: 
1:f92d45b:         PolicyMap pMap = new PolicyMap();
1:f92d45b: 
1:f92d45b:         pMap.setDefaultEntry(policy);
1:f92d45b:         broker.setDestinationPolicy(pMap);
1:f92d45b: 
1:f92d45b:         // Persistence adapter
1:f92d45b:         JDBCPersistenceAdapter localJDBCPersistentAdapter = new JDBCPersistenceAdapter();
1:f92d45b:         EmbeddedDataSource localDataSource = new EmbeddedDataSource();
1:a7ff597:         localDataSource.setDatabaseName("target/derbyDBLocalBroker");
1:f92d45b:         localDataSource.setCreateDatabase("create");
1:f92d45b:         localJDBCPersistentAdapter.setDataSource(localDataSource);
1:f92d45b:         broker.setPersistenceAdapter(localJDBCPersistentAdapter);
1:f92d45b: 
1:f92d45b:         if (deleteMessages) {
1:f92d45b:             // no plugin on restart
1:9b00a09:             broker.setPlugins(new BrokerPlugin[] { new MyTestPlugin() });
1:f92d45b:         }
1:f92d45b: 
1:f92d45b:         this.localDataSource = localDataSource;
1:f92d45b: 
1:f92d45b:         broker.start();
1:f92d45b:         broker.waitUntilStarted();
1:f92d45b: 
1:f92d45b:         return broker;
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     /**
1:f92d45b:      * Query JDBC Store to see if messages are left
1:f92d45b:      *
1:f92d45b:      * @param dataSource
1:f92d45b:      * @return
1:f92d45b:      * @throws SQLException
1:f92d45b:      */
1:9b00a09:     private boolean isMessageInJDBCStore(DataSource dataSource, StringBuffer stringBuffer) throws SQLException {
1:f92d45b: 
1:f92d45b:         boolean tableHasData = false;
1:f92d45b:         String query = "select * from ACTIVEMQ_MSGS";
1:f92d45b: 
1:f92d45b:         java.sql.Connection conn = dataSource.getConnection();
1:f92d45b:         PreparedStatement s = conn.prepareStatement(query);
1:f92d45b: 
1:f92d45b:         ResultSet set = null;
1:f92d45b: 
1:f92d45b:         try {
1:f92d45b:             StringBuffer headers = new StringBuffer();
1:f92d45b:             set = s.executeQuery();
1:f92d45b:             ResultSetMetaData metaData = set.getMetaData();
1:f92d45b:             for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:f92d45b: 
1:f92d45b:                 if (i == 1) {
1:f92d45b:                     headers.append("||");
1:f92d45b:                 }
1:f92d45b:                 headers.append(metaData.getColumnName(i) + "||");
1:f92d45b:             }
1:f92d45b:             LOG.error(headers.toString());
1:f92d45b: 
1:f92d45b:             while (set.next()) {
1:f92d45b:                 tableHasData = true;
1:f92d45b: 
1:f92d45b:                 for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:f92d45b:                     if (i == 1) {
1:f92d45b:                         stringBuffer.append("|");
1:f92d45b:                     }
1:f92d45b:                     stringBuffer.append(set.getString(i) + "|");
1:f92d45b:                 }
1:f92d45b:                 LOG.error(stringBuffer.toString());
1:f92d45b:             }
1:f92d45b:         } finally {
1:f92d45b:             try {
1:f92d45b:                 set.close();
1:f92d45b:             } catch (Throwable ignore) {
1:f92d45b:             }
1:f92d45b:             try {
1:f92d45b:                 s.close();
1:f92d45b:             } catch (Throwable ignore) {
1:f92d45b:             }
1:f92d45b: 
1:f92d45b:             conn.close();
1:f92d45b:         }
1:f92d45b: 
1:f92d45b:         return tableHasData;
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     /**
1:9b00a09:      * plugin used to ensure consumerbroker is restared before the network
1:9b00a09:      * message from producerBroker is acked
1:f92d45b:      */
1:f92d45b:     class MyTestPlugin implements BrokerPlugin {
1:f92d45b: 
1:f92d45b:         @Override
1:f92d45b:         public Broker installPlugin(Broker broker) throws Exception {
1:f92d45b:             return new MyTestBroker(broker);
1:f92d45b:         }
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     class MyTestBroker extends BrokerFilter {
1:f92d45b: 
1:f92d45b:         public MyTestBroker(Broker next) {
1:f92d45b:             super(next);
1:f92d45b:         }
1:f92d45b: 
1:9b00a09:         @Override
1:f92d45b:         public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {
1:f92d45b: 
1:f92d45b:             super.send(producerExchange, messageSend);
1:9b00a09:             LOG.error("Stopping broker on send:  " + messageSend.getMessageId().getProducerSequenceId());
1:f92d45b:             stopConsumerBroker.countDown();
1:f92d45b:             producerExchange.getConnectionContext().setDontSendReponse(true);
1:f92d45b:         }
1:f92d45b:     }
1:f92d45b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:a9c7f71
/////////////////////////////////////////////////////////////////////////
1:     private CountDownLatch stopConsumerBroker;
1:     private CountDownLatch consumerBrokerRestarted;
1:     private CountDownLatch consumerRestartedAndMessageForwarded;
/////////////////////////////////////////////////////////////////////////
1:     public void repeat() throws Exception {
1:         for (int i=0; i<10; i++) {
1:             LOG.info("Iteration: " + i);
1:             testConsumerBrokerRestart();
1:             tearDown();
1:             setUp();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         TextMessage textMsg = (TextMessage) messageConsumer.receive(1000);
1: 
1:                         if (textMsg == null) {
1:                             textMsg = (TextMessage) messageConsumer.receive(4000);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:         stopConsumerBroker = new CountDownLatch(1);
1:         consumerBrokerRestarted = new CountDownLatch(1);
1:         consumerRestartedAndMessageForwarded = new CountDownLatch(1);
1: 
commit:165959e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.jdbc.DataSourceServiceSupport;
/////////////////////////////////////////////////////////////////////////
1:         DataSource dataSource = ((JDBCPersistenceAdapter)producerBroker.getPersistenceAdapter()).getDataSource();
1:         } finally {
1:             DataSourceServiceSupport.shutdownDefaultDataSource(dataSource);
1:         dataSource = ((JDBCPersistenceAdapter)consumerBroker.getPersistenceAdapter()).getDataSource();
1:         } finally {
1:             DataSourceServiceSupport.shutdownDefaultDataSource(dataSource);
commit:c6837ac
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOHelper;
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void dbHomeSysProp() throws Exception {
1:         System.setProperty("derby.system.home", new File(IOHelper.getDefaultDataDirectory()).getCanonicalPath());
1:     }
1: 
commit:08f21ed
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:             nc.setStaticallyIncludedDestinations(Arrays.<ActiveMQDestination>asList(new ActiveMQQueue[]{QUEUE_NAME}));
commit:cc47ab6
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(value = Parameterized.class)
/////////////////////////////////////////////////////////////////////////
1:     @Parameterized.Parameter(0)
1:     public boolean enableCursorAudit;
0:     @Parameterized.Parameters(name="enableAudit={0}")
1:     public static Iterable<Object[]> getTestParameters() {
0:         return Arrays.asList(new Object[][]{{Boolean.TRUE},{Boolean.FALSE}});
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:     public void setUp() throws Exception {
1:         doSetUp();
1:     @After
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             producerBroker.stop();
/////////////////////////////////////////////////////////////////////////
1:     protected void doSetUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         policy.setEnableAudit(enableCursorAudit);
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
1: 
1: package org.apache.activemq.bugs;
1: 
0: import junit.framework.TestCase;
1: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.*;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.command.*;
1: import org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.Wait;
1: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import javax.jms.*;
1: import javax.jms.Connection;
1: import javax.sql.DataSource;
0: import scala.actors.threadpool.Arrays;
1: import java.net.URI;
0: import java.sql.*;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
0: import java.util.concurrent.*;
1: 
1: /**
0:  * Test creates a broker network with two brokers -
0:  * producerBroker (with a message producer attached) and consumerBroker (with consumer attached)
1:  * <p/>
0:  * Simulates network duplicate message by stopping and restarting the consumerBroker after message (with message ID ending in
0:  * 120) is persisted to consumerBrokerstore BUT BEFORE ack sent to the producerBroker over the network connection.
0:  * When the network connection is reestablished the producerBroker resends
0:  * message (with messageID ending in 120).
1:  * <p/>
1:  * Expectation:
1:  * <p/>
0:  * With the following policy entries set,  would  expect the duplicate message to be read from the store
0:  * and dispatched to the consumer - where the duplicate could be detected by consumer.
1:  * <p/>
0:  * PolicyEntry policy = new PolicyEntry();
0:  * policy.setQueue(">");
0:  * policy.setEnableAudit(false);
0:  * policy.setUseCache(false);
1:  * policy.setExpireMessagesPeriod(0);
1:  * <p/>
1:  * <p/>
0:  * Note 1: Network needs to use replaywhenNoConsumers so enabling the networkAudit to avoid this scenario is not feasible.
1:  * <p/>
0:  * NOTE 2: Added a custom plugin to the consumerBroker so that the consumerBroker shutdown will occur after a message has been
0:  * persisted to consumerBroker store but before an ACK is sent back to ProducerBroker. This is just a hack to ensure producerBroker will resend
0:  * the message after shutdown.
1:  */
1: 
0: public class AMQ4952Test extends TestCase {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AMQ4952Test.class);
1: 
1:     protected static final int MESSAGE_COUNT = 1;
1: 
1:     protected BrokerService consumerBroker;
1:     protected BrokerService producerBroker;
1: 
1:     protected ActiveMQQueue QUEUE_NAME = new ActiveMQQueue("duptest.store");
1: 
0:     private final CountDownLatch stopConsumerBroker = new CountDownLatch(1);
0:     private final CountDownLatch consumerBrokerRestarted = new CountDownLatch(1);
0:     private final CountDownLatch consumerRestartedAndMessageForwarded = new CountDownLatch(1);
1: 
1:     private EmbeddedDataSource localDataSource;
1: 
1: 
1:     public void testConsumerBrokerRestart() throws Exception {
1: 
1:         Callable consumeMessageTask = new Callable() {
1:             @Override
1:             public Object call() throws Exception {
1: 
1:                 int receivedMessageCount = 0;
1: 
1:                 ActiveMQConnectionFactory consumerFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:2006)?randomize=false&backup=false");
1:                 Connection consumerConnection = consumerFactory.createConnection();
1: 
1:                 try {
1: 
1:                     consumerConnection.setClientID("consumer");
1:                     consumerConnection.start();
1: 
1:                     Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                     MessageConsumer messageConsumer = consumerSession.createConsumer(QUEUE_NAME);
1: 
1: 
1:                     while (true) {
0:                         TextMessage textMsg = (TextMessage) messageConsumer.receive(5000);
1: 
1:                         if (textMsg == null) {
1:                             return receivedMessageCount;
1:                         }
1: 
1:                         receivedMessageCount++;
1:                         LOG.info("*** receivedMessageCount {} message has MessageID {} ", receivedMessageCount, textMsg.getJMSMessageID());
1: 
0:                         // on first delivery ensure the message is pending an ack when it is resent from the producer broker
1:                         if (textMsg.getJMSMessageID().endsWith("1") && receivedMessageCount == 1) {
1:                             LOG.info("Waiting for restart...");
1:                             consumerRestartedAndMessageForwarded.await(90, TimeUnit.SECONDS);
1:                         }
1: 
1:                         textMsg.acknowledge();
1: 
1:                     }
1:                 } finally {
1:                     consumerConnection.close();
1:                 }
1:             }
1:         };
1: 
1:         Runnable consumerBrokerResetTask = new Runnable() {
1:             public void run() {
1: 
1:                 try {
1:                     // wait for signal
1:                     stopConsumerBroker.await();
1: 
1: 
1:                     LOG.info("********* STOPPING CONSUMER BROKER");
1: 
1:                     consumerBroker.stop();
1:                     consumerBroker.waitUntilStopped();
1: 
1: 
1:                     LOG.info("***** STARTING CONSUMER BROKER");
0:                     // do not delete  messages on startup
1:                     consumerBroker = createConsumerBroker(false);
1: 
1:                     LOG.info("***** CONSUMER BROKER STARTED!!");
1:                     consumerBrokerRestarted.countDown();
1: 
1:                     assertTrue("message forwarded on time", Wait.waitFor(new Wait.Condition() {
1:                         @Override
1:                         public boolean isSatisified() throws Exception {
1:                             LOG.info("ProducerBroker totalMessageCount: " + producerBroker.getAdminView().getTotalMessageCount());
1:                             return producerBroker.getAdminView().getTotalMessageCount() == 0;
1:                         }
1:                     }));
1:                     consumerRestartedAndMessageForwarded.countDown();
1: 
1: 
1:                 } catch (Exception e) {
1:                     LOG.error("Exception when stopping/starting the consumerBroker ", e);
1:                 }
1: 
1: 
1:             }
1:         };
1: 
1: 
1:         ExecutorService executor = Executors.newFixedThreadPool(2);
1: 
0:         //start consumerBroker start/stop task
1:         executor.execute(consumerBrokerResetTask);
1: 
0:         //start consuming messages
1:         Future<Integer> numberOfConsumedMessage = executor.submit(consumeMessageTask);
1: 
1: 
1:         produceMessages();
1: 
0:         //Wait for consumer to finish
1:         int totalMessagesConsumed = numberOfConsumedMessage.get();
1: 
1:         StringBuffer contents = new StringBuffer();
1:         boolean messageInStore = isMessageInJDBCStore(localDataSource, contents);
1:         LOG.debug("****number of messages received " + totalMessagesConsumed);
1: 
1:         assertEquals("number of messages received", 2, totalMessagesConsumed);
1:         assertEquals("messages left in store", true, messageInStore);
1:         assertTrue("message is in dlq: " + contents.toString(), contents.toString().contains("DLQ"));
1: 
1:     }
1: 
1:     private void produceMessages() throws JMSException {
1: 
1:         ActiveMQConnectionFactory producerFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:2003)?randomize=false&backup=false");
1:         Connection producerConnection = producerFactory.createConnection();
1: 
1:         try {
1:             producerConnection.setClientID("producer");
1:             producerConnection.start();
1: 
1:             Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             final MessageProducer remoteProducer = producerSession.createProducer(QUEUE_NAME);
1: 
1:             int i = 0;
1:             while (MESSAGE_COUNT > i) {
1:                 String payload = "test msg " + i;
1:                 TextMessage msg = producerSession.createTextMessage(payload);
1:                 remoteProducer.send(msg);
1:                 i++;
1:             }
1: 
1:         } finally {
1:             producerConnection.close();
1:         }
1:     }
1: 
1:     @Override
0:     protected void setUp() throws Exception {
0:         super.setUp();
0:         doSetUp(true);
1:     }
1: 
1:     @Override
0:     protected void tearDown() throws Exception {
1:         doTearDown();
0:         super.tearDown();
1:     }
1: 
1:     protected void doTearDown() throws Exception {
1: 
1:         try {
1:             consumerBroker.stop();
1:         } catch (Exception ex) {
1:         }
1:         try {
1:             consumerBroker.stop();
1:         } catch (Exception ex) {
1:         }
1:     }
1: 
0:     protected void doSetUp(boolean deleteAllMessages) throws Exception {
1:         producerBroker = createProducerBroker();
1:         consumerBroker = createConsumerBroker(true);
1:     }
1: 
1: 
1:     /**
0:      * Producer broker
0:      * listens on  localhost:2003
0:      * networks to consumerBroker - localhost:2006
1:      *
1:      * @return
1:      * @throws Exception
1:      */
1: 
1:     protected BrokerService createProducerBroker() throws Exception {
1: 
1: 
0:         String networkToPorts[] = new String[]{"2006"};
1:         HashMap<String, String> networkProps = new HashMap<String, String>();
1: 
1:         networkProps.put("networkTTL", "10");
1:         networkProps.put("conduitSubscriptions", "true");
1:         networkProps.put("decreaseNetworkConsumerPriority", "true");
1:         networkProps.put("dynamicOnly", "true");
1: 
1:         BrokerService broker = new BrokerService();
1:         broker.getManagementContext().setCreateConnector(false);
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.setBrokerName("BP");
1:         broker.setAdvisorySupport(false);
1: 
1:         // lazy init listener on broker start
1:         TransportConnector transportConnector = new TransportConnector();
1:         transportConnector.setUri(new URI("tcp://localhost:2003"));
1:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:         transportConnectors.add(transportConnector);
1:         broker.setTransportConnectors(transportConnectors);
1: 
1: 
0:         //network to consumerBroker
1: 
1:         if (networkToPorts != null && networkToPorts.length > 0) {
1:             StringBuilder builder = new StringBuilder("static:(failover:(tcp://localhost:2006)?maxReconnectAttempts=0)?useExponentialBackOff=false");
1:             NetworkConnector nc = broker.addNetworkConnector(builder.toString());
1:             if (networkProps != null) {
1:                 IntrospectionSupport.setProperties(nc, networkProps);
1:             }
0:             nc.setStaticallyIncludedDestinations(Arrays.asList(new ActiveMQQueue[]{QUEUE_NAME}));
1:         }
1: 
0:         //Persistence adapter
1: 
1:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:         EmbeddedDataSource remoteDataSource = new EmbeddedDataSource();
0:         remoteDataSource.setDatabaseName("derbyDBRemoteBroker");
1:         remoteDataSource.setCreateDatabase("create");
1:         jdbc.setDataSource(remoteDataSource);
1:         broker.setPersistenceAdapter(jdbc);
1: 
0:         //set Policy entries
1:         PolicyEntry policy = new PolicyEntry();
1: 
1:         policy.setQueue(">");
1:         policy.setEnableAudit(false);
1:         policy.setUseCache(false);
1:         policy.setExpireMessagesPeriod(0);
1: 
1:         // set replay with no consumers
0:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory =
0:                 new ConditionalNetworkBridgeFilterFactory();
1:         conditionalNetworkBridgeFilterFactory.setReplayWhenNoConsumers(true);
1:         policy.setNetworkBridgeFilterFactory(conditionalNetworkBridgeFilterFactory);
1: 
1:         PolicyMap pMap = new PolicyMap();
1:         pMap.setDefaultEntry(policy);
1:         broker.setDestinationPolicy(pMap);
1: 
1:         broker.start();
1:         broker.waitUntilStarted();
1: 
1:         return broker;
1:     }
1: 
1: 
1:     /**
0:      * consumerBroker
0:      * - listens on localhost:2006
1:      *
0:      * @param deleteMessages - drop messages when broker instance is created
1:      * @return
1:      * @throws Exception
1:      */
1: 
1:     protected BrokerService createConsumerBroker(boolean deleteMessages) throws Exception {
1: 
1:         String scheme = "tcp";
1:         String listenPort = "2006";
1: 
1:         BrokerService broker = new BrokerService();
1:         broker.getManagementContext().setCreateConnector(false);
1:         broker.setDeleteAllMessagesOnStartup(deleteMessages);
1:         broker.setBrokerName("BC");
1:         // lazy init listener on broker start
1:         TransportConnector transportConnector = new TransportConnector();
1:         transportConnector.setUri(new URI(scheme + "://localhost:" + listenPort));
1:         List<TransportConnector> transportConnectors = new ArrayList<TransportConnector>();
1:         transportConnectors.add(transportConnector);
1:         broker.setTransportConnectors(transportConnectors);
1: 
0:         //policy entries
1: 
1:         PolicyEntry policy = new PolicyEntry();
1: 
1:         policy.setQueue(">");
1:         policy.setUseCache(false);
1:         policy.setExpireMessagesPeriod(0);
1: 
1:         // set replay with no consumers
0:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory =
0:                 new ConditionalNetworkBridgeFilterFactory();
1:         conditionalNetworkBridgeFilterFactory.setReplayWhenNoConsumers(true);
1:         policy.setNetworkBridgeFilterFactory(conditionalNetworkBridgeFilterFactory);
1: 
1:         PolicyMap pMap = new PolicyMap();
1: 
1:         pMap.setDefaultEntry(policy);
1:         broker.setDestinationPolicy(pMap);
1: 
1: 
1:         // Persistence adapter
1:         JDBCPersistenceAdapter localJDBCPersistentAdapter = new JDBCPersistenceAdapter();
1:         EmbeddedDataSource localDataSource = new EmbeddedDataSource();
0:         localDataSource.setDatabaseName("derbyDBLocalBroker");
1:         localDataSource.setCreateDatabase("create");
1:         localJDBCPersistentAdapter.setDataSource(localDataSource);
1:         broker.setPersistenceAdapter(localJDBCPersistentAdapter);
1: 
1:         if (deleteMessages) {
1:             // no plugin on restart
0:             broker.setPlugins(new BrokerPlugin[]{new MyTestPlugin()});
1:         }
1: 
1:         this.localDataSource = localDataSource;
1: 
1:         broker.start();
1:         broker.waitUntilStarted();
1: 
1:         return broker;
1:     }
1: 
1: 
1:     /**
1:      * Query JDBC Store to see if messages are left
1:      *
1:      * @param dataSource
1:      * @return
1:      * @throws SQLException
1:      */
1: 
0:     private boolean isMessageInJDBCStore(DataSource dataSource, StringBuffer stringBuffer)
0:             throws SQLException {
1: 
1:         boolean tableHasData = false;
1:         String query = "select * from ACTIVEMQ_MSGS";
1: 
1:         java.sql.Connection conn = dataSource.getConnection();
1:         PreparedStatement s = conn.prepareStatement(query);
1: 
1:         ResultSet set = null;
1: 
1: 
1: 
1:         try {
1:             StringBuffer headers = new StringBuffer();
1:             set = s.executeQuery();
1:             ResultSetMetaData metaData = set.getMetaData();
1:             for (int i = 1; i <= metaData.getColumnCount(); i++) {
1: 
1:                 if (i == 1) {
1:                     headers.append("||");
1:                 }
1:                 headers.append(metaData.getColumnName(i) + "||");
1:             }
1:             LOG.error(headers.toString());
1: 
1: 
1:             while (set.next()) {
1:                 tableHasData = true;
1: 
1:                 for (int i = 1; i <= metaData.getColumnCount(); i++) {
1:                     if (i == 1) {
1:                         stringBuffer.append("|");
1:                     }
1:                     stringBuffer.append(set.getString(i) + "|");
1:                 }
1:                 LOG.error(stringBuffer.toString());
1:             }
1:         } finally {
1:             try {
1:                 set.close();
1:             } catch (Throwable ignore) {
1:             }
1:             try {
1:                 s.close();
1:             } catch (Throwable ignore) {
1:             }
1: 
1:             conn.close();
1:         }
1: 
1:         return tableHasData;
1:     }
1: 
1: 
1:     /**
0:      * plugin used to ensure consumerbroker is restared before the network message from producerBroker is acked
1:      */
1:     class MyTestPlugin implements BrokerPlugin {
1: 
1:         public Broker installPlugin(Broker broker) throws Exception {
1:             return new MyTestBroker(broker);
1:         }
1: 
1:     }
1: 
1:     class MyTestBroker extends BrokerFilter {
1: 
1:         public MyTestBroker(Broker next) {
1:             super(next);
1:         }
1: 
1:         public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {
1: 
1:             super.send(producerExchange, messageSend);
0:             LOG.error("Stopping broker on send:  " +messageSend.getMessageId().getProducerSequenceId());
1:             stopConsumerBroker.countDown();
1:             producerExchange.getConnectionContext().setDontSendReponse(true);
1:         }
1:     }
1: }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:a7ff597
/////////////////////////////////////////////////////////////////////////
1:         remoteDataSource.setDatabaseName("target/derbyDBRemoteBroker");
/////////////////////////////////////////////////////////////////////////
1:         localDataSource.setDatabaseName("target/derbyDBLocalBroker");
/////////////////////////////////////////////////////////////////////////
0: }
author:Kevin Earls
-------------------------------------------------------------------------------
commit:3df943c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.*;
0: 
/////////////////////////////////////////////////////////////////////////
1: public class AMQ4952Test {
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Running with enableCursorAudit set to {}", this.enableCursorAudit);
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9b00a09
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: import java.net.URI;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.HashMap;
0: import java.util.List;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
0: 
0: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
0: import javax.sql.DataSource;
0: 
0: 
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
1:  * Test creates a broker network with two brokers - producerBroker (with a
1:  * message producer attached) and consumerBroker (with consumer attached)
1:  * Simulates network duplicate message by stopping and restarting the
1:  * consumerBroker after message (with message ID ending in 120) is persisted to
1:  * consumerBrokerstore BUT BEFORE ack sent to the producerBroker over the
1:  * network connection. When the network connection is reestablished the
1:  * producerBroker resends message (with messageID ending in 120).
1:  * With the following policy entries set, would expect the duplicate message to
1:  * be read from the store and dispatched to the consumer - where the duplicate
1:  * could be detected by consumer.
1:  * PolicyEntry policy = new PolicyEntry(); policy.setQueue(">");
1:  * policy.setEnableAudit(false); policy.setUseCache(false);
1:  * Note 1: Network needs to use replaywhenNoConsumers so enabling the
1:  * networkAudit to avoid this scenario is not feasible.
1:  * NOTE 2: Added a custom plugin to the consumerBroker so that the
1:  * consumerBroker shutdown will occur after a message has been persisted to
1:  * consumerBroker store but before an ACK is sent back to ProducerBroker. This
1:  * is just a hack to ensure producerBroker will resend the message after
1:  * shutdown.
/////////////////////////////////////////////////////////////////////////
1:     @Parameterized.Parameters(name = "enableAudit={0}")
1:         return Arrays.asList(new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } });
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         // on first delivery ensure the message is pending an
1:                         // ack when it is resent from the producer broker
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                     // do not delete messages on startup
/////////////////////////////////////////////////////////////////////////
1:         // start consumerBroker start/stop task
1:         // start consuming messages
1:         // Wait for consumer to finish
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Producer broker listens on localhost:2003 networks to consumerBroker -
1:      * localhost:2006
1:         String networkToPorts[] = new String[] { "2006" };
/////////////////////////////////////////////////////////////////////////
1:         // network to consumerBroker
/////////////////////////////////////////////////////////////////////////
1:             nc.setStaticallyIncludedDestinations(Arrays.<ActiveMQDestination> asList(new ActiveMQQueue[] { QUEUE_NAME }));
1:         // Persistence adapter
/////////////////////////////////////////////////////////////////////////
1:         // set Policy entries
/////////////////////////////////////////////////////////////////////////
1:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory = new ConditionalNetworkBridgeFilterFactory();
/////////////////////////////////////////////////////////////////////////
1:      * consumerBroker - listens on localhost:2006
1:      * @param deleteMessages
1:      *            - drop messages when broker instance is created
/////////////////////////////////////////////////////////////////////////
1:         // policy entries
/////////////////////////////////////////////////////////////////////////
1:         ConditionalNetworkBridgeFilterFactory conditionalNetworkBridgeFilterFactory = new ConditionalNetworkBridgeFilterFactory();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             broker.setPlugins(new BrokerPlugin[] { new MyTestPlugin() });
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean isMessageInJDBCStore(DataSource dataSource, StringBuffer stringBuffer) throws SQLException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * plugin used to ensure consumerbroker is restared before the network
1:      * message from producerBroker is acked
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:         @Override
1:             LOG.error("Stopping broker on send:  " + messageSend.getMessageId().getProducerSequenceId());
============================================================================